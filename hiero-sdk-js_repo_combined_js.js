// Filename: common_js_test/src/test.js
const { Client, AccountBalanceQuery } = require("@hashgraph/sdk");

describe("CommonJS", function () {
    it("should query each node's balance", async function () {
        const client = Client.forTestnet();

        let succeededAtLeastOnce = false;

        // Iterate over the nodes in the network
        for (const [, nodeAccountId] of Object.entries(client.network)) {
            try {
                await new AccountBalanceQuery()
                    .setNodeAccountIds([nodeAccountId])
                    .setAccountId(nodeAccountId)
                    .execute(client);
                succeededAtLeastOnce = true;
            } catch (error) {
                console.log(`Failed for ${nodeAccountId}`);
            }
        }

        // Close the client connection
        client.close();

        // Ensure that at least one attempt was successful
        if (!succeededAtLeastOnce) {
            throw new Error("No successful query attempts were made.");
        }
    });
});
// Filename: examples/ContractHelper.js
import * as hashgraph from "@hashgraph/sdk";

/**
 *
 * ContractHelper declutters solidity-precomile-example.js
 *
 * When we instantiate a ContractHelper, we provide it with the JSON of a compiled solidity contract
 * which is assumed to have functions named "step0()" through "stepN()".
 *
 * Each of these step functions is assumed to take no function parameters, and to return a Hedera ResponseCode
 * which ought to be SUCCESS -- in other words, an int32 with value 22.
 * See examples/precompile-example/HederaResponseCodes.sol
 *
 * If a step takes function parameters, or if its ContractFunctionResult should be validated with a different method,
 * the user can specify a supplier for a particular step with setParameterSupplier(stepIndex, parametersSupplier),
 * and can specify an alternative validation method with setResultValidator(stepIndex, validateFunction)
 *
 * The contract is created on the Hedera network in the ContractHelper constructor, and when the user is ready to
 * execute the step functions in the contract, they should call executeSteps(firstStepToExecute, lastStepToExecute).
 */
export default class ContractHelper {
    /**
     * @private
     * @param {hashgraph.ContractId} contractId
     */
    constructor(contractId) {
        this.contractId = contractId;

        /** @type {Map<number, (result: hashgraph.ContractFunctionResult) => boolean>} */
        this.stepResultValidators = new Map();

        /** @type {Map<number, () => hashgraph.ContractFunctionParameters>} */
        this.stepParameterSuppliers = new Map();

        /** @type {Map<number, hashgraph.Hbar>} */
        this.stepPayableAmounts = new Map();

        /** @type {Map<number, hashgraph.PrivateKey[]>} */
        this.stepSigners = new Map();

        /** @type {Map<number, hashgraph.AccountId>} */
        this.stepFeePayers = new Map();

        /** @type {Map<number, (tokenAddress: string) => Promise<void>>} */
        this.stepLogic = new Map();
    }

    /**
     * @param {string} bytecode
     * @param {hashgraph.ContractFunctionParameters} constructorParameters
     * @param {hashgraph.Signer} signer
     * @returns {Promise<ContractHelper>}
     */
    static async init(bytecode, constructorParameters, signer) {
        const response = await new hashgraph.ContractCreateFlow()
            .setBytecode(bytecode)
            .setMaxChunks(30)
            .setGas(8_000_000)
            .setConstructorParameters(constructorParameters)
            .executeWithSigner(signer);

        const receipt = await response.getReceiptWithSigner(signer);

        return new ContractHelper(receipt.contractId);
    }

    /**
     * @param {number} stepIndex
     * @param {(result: hashgraph.ContractFunctionResult) => boolean} validator
     * @returns {this}
     */
    setResultValidatorForStep(stepIndex, validator) {
        this.stepResultValidators.set(stepIndex, validator);
        return this;
    }

    /**
     * @param {number} stepIndex
     * @param {(tokenAddress: string) => Promise<void>} logic
     * @returns {this}
     */
    setStepLogic(stepIndex, logic) {
        this.stepLogic.set(stepIndex, logic);
        return this;
    }

    /**
     * @param {number} stepIndex
     * @param {() => hashgraph.ContractFunctionParameters} supplier
     * @returns {this}
     */
    setParameterSupplierForStep(stepIndex, supplier) {
        this.stepParameterSuppliers.set(stepIndex, supplier);
        return this;
    }

    /**
     * @param {number} stepIndex
     * @param {hashgraph.Hbar} amount
     * @returns {this}
     */
    setPayableAmountForStep(stepIndex, amount) {
        this.stepPayableAmounts.set(stepIndex, amount);
        return this;
    }

    /**
     * @param {number} stepIndex
     * @param {hashgraph.PrivateKey} signer
     * @returns {this}
     */
    addSignerForStep(stepIndex, signer) {
        if (this.stepSigners.has(stepIndex)) {
            this.stepSigners.get(stepIndex).push(signer);
        } else {
            this.stepSigners.set(stepIndex, [signer]);
        }

        return this;
    }

    /**
     * @param {number} stepIndex
     * @param {hashgraph.AccountId} feePayerAccountId
     * @param {hashgraph.PrivateKey} feePayerAccountKey
     * @returns {this}
     */
    setFeePayerForStep(stepIndex, feePayerAccountId, feePayerAccountKey) {
        this.stepFeePayers.set(stepIndex, feePayerAccountId);
        return this.addSignerForStep(stepIndex, feePayerAccountKey);
    }

    /**
     * @private
     * @param {number} stepIndex
     * @returns {(tokenAddress: string) => Promise<void>}
     */
    getStepLogic(stepIndex) {
        return this.stepLogic.get(stepIndex);
    }

    /**
     * @private
     * @param {number} stepIndex
     * @returns {(result: hashgraph.ContractFunctionResult) => boolean}
     */
    getResultValidator(stepIndex) {
        if (this.stepResultValidators.has(stepIndex)) {
            return this.stepResultValidators.get(stepIndex);
        }

        return (/** @type {hashgraph.ContractFunctionResult} */ result) => {
            const responseStatus = hashgraph.Status._fromCode(
                result.getInt32(0),
            );
            const isValid = responseStatus == hashgraph.Status.Success;
            if (!isValid) {
                console.log(
                    `Encountered invalid response status ${responseStatus.toString()}`,
                );
            }
            return isValid;
        };
    }

    /**
     * @private
     * @param {number} stepIndex
     * @returns {() => hashgraph.ContractFunctionParameters}
     */
    getParameterSupplier(stepIndex) {
        if (this.stepParameterSuppliers.has(stepIndex)) {
            return this.stepParameterSuppliers.get(stepIndex);
        }

        return () => null;
    }

    /**
     * @private
     * @param {number} stepIndex
     * @returns {hashgraph.Hbar}
     */
    getPayableAmount(stepIndex) {
        return this.stepPayableAmounts.get(stepIndex);
    }

    /**
     * @private
     * @param {number} stepIndex
     * @returns {hashgraph.PrivateKey[]}
     */
    getSigners(stepIndex) {
        if (this.stepSigners.has(stepIndex)) {
            return this.stepSigners.get(stepIndex);
        }

        return [];
    }

    /**
     * @param {number} firstStepToExecute
     * @param {number} lastStepToExecute
     * @param {hashgraph.Signer} signer
     * @returns {Promise<ContractHelper>}
     */
    async executeSteps(firstStepToExecute, lastStepToExecute, signer) {
        for (
            let stepIndex = firstStepToExecute;
            stepIndex <= lastStepToExecute;
            stepIndex++
        ) {
            console.log(`Attempting to execute step ${stepIndex}`);

            let transaction = new hashgraph.ContractExecuteTransaction()
                .setContractId(this.contractId)
                .setGas(10_000_000);

            const payableAmount = this.getPayableAmount(stepIndex);
            if (payableAmount != null) {
                transaction.setPayableAmount(payableAmount);
            }

            const functionName = `step${stepIndex}`;
            const parameters = this.getParameterSupplier(stepIndex)();
            if (parameters != null) {
                transaction.setFunction(functionName, parameters);
            } else {
                transaction.setFunction(functionName);
            }

            const feePayerAccountId = this.stepFeePayers.get(stepIndex);
            if (feePayerAccountId != null) {
                transaction.setTransactionId(
                    hashgraph.TransactionId.generate(feePayerAccountId),
                );
            }

            await transaction.freezeWithSigner(signer);
            for (const signer of this.getSigners(stepIndex)) {
                await transaction.sign(signer);
            }

            transaction = /** @type {hashgraph.ContractExecuteTransaction} */ (
                await transaction.signWithSigner(signer)
            );

            const response = await transaction.executeWithSigner(signer);
            const record = await response.getRecordWithSigner(signer);
            const functionResult = record.contractFunctionResult;

            if (this.getStepLogic(stepIndex)) {
                const additionalFunction = this.getStepLogic(stepIndex);
                const tokenAddress = functionResult.getAddress(1);
                await additionalFunction(tokenAddress);
            }

            if (this.getResultValidator(stepIndex)(functionResult)) {
                console.log(
                    `step ${stepIndex} completed, and returned valid result. (TransactionId "${record.transactionId.toString()}")`,
                );
            } else {
                console.log(
                    `Transaction record: ${JSON.stringify(record, null, 2)}`,
                );
                throw new Error(`step ${stepIndex} returned invalid result`);
            }
        }
        return this;
    }
}
// Filename: examples/account-alias.js
import {
    Wallet,
    LocalProvider,
    PrivateKey,
    PublicKey,
    Hbar,
    AccountId,
    AccountBalanceQuery,
    AccountInfoQuery,
    TransferTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    /*
     * Hedera supports a form of auto account creation.
     *
     * You can "create" an account by generating a private key, and then deriving the public key,
     * without any need to interact with the Hedera network.  The public key more or less acts as the user's
     * account ID.  This public key is an account's aliasKey: a public key that aliases (or will eventually alias)
     * to a Hedera account.
     *
     * An AccountId takes one of two forms: a normal AccountId with a null aliasKey member takes the form 0.0.123,
     * while an account ID with a non-null aliasKey member takes the form
     * 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
     * Note the prefix of "0.0." indicating the shard and realm.  Also note that the aliasKey is stringified
     * as a hex-encoded ASN1 DER representation of the key.
     *
     * An AccountId with an aliasKey can be used just like a normal AccountId for the purposes of queries and
     * transactions, however most queries and transactions involving such an AccountId won't work until Hbar has
     * been transferred to the aliasKey account.
     *
     * There is no record in the Hedera network of an account associated with a given aliasKey
     * until an amount of Hbar is transferred to the account.  The moment that Hbar is transferred to that aliasKey
     * AccountId is the moment that that account actually begins to exist in the Hiero ledger.
     */

    console.log('"Creating" a new account');

    const privateKey = PrivateKey.generateED25519();
    const publicKey = privateKey.publicKey;

    // Assuming that the target shard and realm are known.
    // For now they are virtually always 0 and 0.
    const aliasAccountId = publicKey.toAccountId(0, 0);

    console.log(`New account ID: ${aliasAccountId.toString()}`);
    console.log(`Just the aliasKey: ${aliasAccountId.aliasKey.toString()}`);

    /*
     * Note that no queries or transactions have taken place yet.
     * This account "creation" process is entirely local.
     *
     * AccountId.fromString() can construct an AccountId with an aliasKey.
     * It expects a string of the form 0.0.123 in the case of a normal AccountId, or of the form
     * 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
     * in the case of an AccountId with aliasKey.  Note the prefix of "0.0." to indicate the shard and realm.
     *
     * If the shard and realm are known, you may use PublicKey.fromString().toAccountId() to construct the
     * aliasKey AccountId
     */

    AccountId.fromString(
        "0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777",
    );

    PublicKey.fromString(
        "302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777",
    ).toAccountId(0, 0);

    console.log("Transferring some Hbar to the new account");
    try {
        let transaction = await new TransferTransaction()
            .addHbarTransfer(wallet.getAccountId(), new Hbar(10).negated())
            .addHbarTransfer(aliasAccountId, new Hbar(10))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        const response = await transaction.executeWithSigner(wallet);
        await response.getReceiptWithSigner(wallet);

        const balance = await new AccountBalanceQuery()
            .setNodeAccountIds([response.nodeId])
            .setAccountId(aliasAccountId)
            .executeWithSigner(wallet);

        console.log(`Balances of the new account: ${balance.toString()}`);

        const info = await new AccountInfoQuery()
            .setNodeAccountIds([response.nodeId])
            .setAccountId(aliasAccountId)
            .executeWithSigner(wallet);

        console.log(`Info about the new account: ${info.toString()}`);

        /*
         * Note that once an account exists in the ledger, it is assigned a normal AccountId, which can be retrieved
         * via an AccountInfoQuery.
         *
         * Users may continue to refer to the account by its aliasKey AccountId, but they may also
         * now refer to it by its normal AccountId
         */

        console.log(`The normal account ID: ${info.accountId.toString()}`);
        console.log(`The alias key: ${info.aliasKey.toString()}`);

        console.log("Example complete!");
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/account-allowance.js
import {
    Wallet,
    LocalProvider,
    PrivateKey,
    AccountBalanceQuery,
    AccountCreateTransaction,
    AccountDeleteTransaction,
    TransactionId,
    AccountAllowanceApproveTransaction,
    TransferTransaction,
    Hbar,
} from "@hashgraph/sdk";

/**
 * @typedef {import("@hashgraph/sdk").AccountId} AccountId
 */

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    console.log("Generating accounts for example...");

    const aliceKey = PrivateKey.generateED25519();
    const bobKey = PrivateKey.generateED25519();
    const charlieKey = PrivateKey.generateED25519();

    try {
        let transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(aliceKey)
            .setInitialBalance(new Hbar(5))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const response = await transaction.executeWithSigner(wallet);

        const aliceId = (await response.getReceiptWithSigner(wallet)).accountId;

        transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(bobKey)
            .setInitialBalance(new Hbar(5))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        const bobId = (
            await (
                await transaction.executeWithSigner(wallet)
            ).getReceiptWithSigner(wallet)
        ).accountId;

        transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(charlieKey)
            .setInitialBalance(new Hbar(5))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        const charlieId = (
            await (
                await transaction.executeWithSigner(wallet)
            ).getReceiptWithSigner(wallet)
        ).accountId;

        console.log(`Alice ID:  ${aliceId.toString()}`);
        console.log(`Bob ID:  ${bobId.toString()}`);
        console.log(`Charlie ID:  ${charlieId.toString()}`);

        await printBalances(wallet, aliceId, bobId, charlieId);

        console.log(
            "Approving an allowance of 2 Hbar with owner Alice and spender Bob",
        );

        await (
            await (
                await (
                    await (
                        await new AccountAllowanceApproveTransaction()
                            .approveHbarAllowance(aliceId, bobId, new Hbar(2))
                            .freezeWithSigner(wallet)
                    ).sign(aliceKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        await printBalances(wallet, aliceId, bobId, charlieId);

        console.log(
            "Transferring 1 Hbar from Alice to Charlie, but the transaction is signed _only_ by Bob (Bob is dipping into his allowance from Alice)",
        );

        await (
            await (
                await (
                    await (
                        await new TransferTransaction()
                            // "addApproved*Transfer()" means that the transfer has been approved by an allowance
                            .addApprovedHbarTransfer(
                                aliceId,
                                new Hbar(1).negated(),
                            )
                            .addHbarTransfer(charlieId, new Hbar(1))
                            // The allowance spender must pay the fee for the transaction.
                            // use setTransactionId() to set the account ID that will pay the fee for the transaction.
                            .setTransactionId(TransactionId.generate(bobId))
                            .freezeWithSigner(wallet)
                    ).sign(bobKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(
            "Transfer succeeded.  Bob should now have 1 Hbar left in his allowance.",
        );

        await printBalances(wallet, aliceId, bobId, charlieId);

        try {
            console.log(
                "Attempting to transfer 2 Hbar from Alice to Charlie using Bob's allowance.",
            );
            console.log(
                "This should fail, because there is only 1 Hbar left in Bob's allowance.",
            );

            await (
                await (
                    await (
                        await (
                            await new TransferTransaction()
                                .addApprovedHbarTransfer(
                                    aliceId,
                                    new Hbar(2).negated(),
                                )
                                .addHbarTransfer(charlieId, new Hbar(2))
                                .setTransactionId(TransactionId.generate(bobId))
                                .freezeWithSigner(wallet)
                        ).sign(bobKey)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet)
            ).getReceiptWithSigner(wallet);

            console.log("The transfer succeeded.  This should not happen.");
        } catch (error) {
            console.log("The transfer failed as expected.");
            console.log(/** @type {Error} */ (error).message);
        }

        console.log("Adjusting Bob's allowance to 3 Hbar.");

        await (
            await (
                await (
                    await (
                        await new AccountAllowanceApproveTransaction()
                            .approveHbarAllowance(aliceId, bobId, new Hbar(3))
                            .freezeWithSigner(wallet)
                    ).sign(aliceKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(
            "Attempting to transfer 2 Hbar from Alice to Charlie using Bob's allowance again.",
        );
        console.log("This time it should succeed.");

        await (
            await (
                await (
                    await (
                        await new TransferTransaction()
                            .addApprovedHbarTransfer(
                                aliceId,
                                new Hbar(2).negated(),
                            )
                            .addHbarTransfer(charlieId, new Hbar(2))
                            .setTransactionId(TransactionId.generate(bobId))
                            .freezeWithSigner(wallet)
                    ).sign(bobKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log("Transfer succeeded.");

        await printBalances(wallet, aliceId, bobId, charlieId);

        console.log("Deleting Bob's allowance");

        await (
            await (
                await (
                    await (
                        await new AccountAllowanceApproveTransaction()
                            .approveHbarAllowance(
                                aliceId,
                                bobId,
                                Hbar.fromTinybars(0),
                            )
                            .freezeWithSigner(wallet)
                    ).sign(aliceKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log("Cleaning up...");

        await (
            await (
                await (
                    await (
                        await new AccountDeleteTransaction()
                            .setAccountId(aliceId)
                            .setTransferAccountId(wallet.getAccountId())
                            .freezeWithSigner(wallet)
                    ).sign(aliceKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        await (
            await (
                await (
                    await (
                        await new AccountDeleteTransaction()
                            .setAccountId(bobId)
                            .setTransferAccountId(wallet.getAccountId())
                            .freezeWithSigner(wallet)
                    ).sign(bobKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        await (
            await (
                await (
                    await (
                        await new AccountDeleteTransaction()
                            .setAccountId(charlieId)
                            .setTransferAccountId(wallet.getAccountId())
                            .freezeWithSigner(wallet)
                    ).sign(charlieKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

/**
 * @param {Wallet} wallet
 * @param {AccountId} aliceId
 * @param {AccountId} bobId
 * @param {AccountId} charlieId
 */
async function printBalances(wallet, aliceId, bobId, charlieId) {
    console.log(
        `Alice's balance: ${(
            await new AccountBalanceQuery()
                .setAccountId(aliceId)
                .executeWithSigner(wallet)
        ).hbars.toString()}`,
    );
    console.log(
        `Bob's balance: ${(
            await new AccountBalanceQuery()
                .setAccountId(bobId)
                .executeWithSigner(wallet)
        ).hbars.toString()}`,
    );
    console.log(
        `Charlie's balance: ${(
            await new AccountBalanceQuery()
                .setAccountId(charlieId)
                .executeWithSigner(wallet)
        ).hbars.toString()}`,
    );
}

void main();
// Filename: examples/account-create-with-hts.js
import {
    AccountId,
    PrivateKey,
    Client,
    TokenCreateTransaction,
    TokenType,
    TokenSupplyType,
    TokenMintTransaction,
    TransferTransaction,
    TokenNftInfoQuery,
    NftId,
    AccountInfoQuery,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    TransactionReceipt,
} from "@hashgraph/sdk";
import axios from "axios";

import dotenv from "dotenv";

dotenv.config();

/*
Example for HIP-542.

## Example 1:

### Steps
1. Create an NFT using the Hedera Token Service
2. Mint the NFT
3. Create an ECDSA public key alias
4. Transfer the NFT to the public key alias using the transfer transaction
5. Return the new account ID in the child record
6. Show the new account ID owns the NFT

## Example 2:
### Steps
1. Create a fungible HTS token using the Hedera Token Service
2. Create an ECDSA public key alias
3. Transfer the fungible token to the public key alias
4. Return the new account ID in the child record
5. Show the new account ID owns the fungible token

*/

async function main() {
    // Configure accounts and client, and generate needed keys
    const supplyKey = PrivateKey.generateECDSA();
    const freezeKey = PrivateKey.generateECDSA();
    const wipeKey = PrivateKey.generateECDSA();

    if (process.env.OPERATOR_ID == null || process.env.OPERATOR_KEY == null) {
        throw new Error(
            "Environment variables OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const nodes = {
        "127.0.0.1:50211": new AccountId(3),
    };

    const client = Client.forNetwork(nodes);
    client.setOperator(operatorId, operatorKey);

    /**
     *     Example 1
     *
     * Step 1
     *
     * Create an NFT using the Hedera Token Service
     */
    console.log(`Example 1`);

    // IPFS content identifiers for the NFT metadata
    const CID = [
        "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
        "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
        "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        "Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
        "QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw",
    ];

    let nftCreateTx = new TokenCreateTransaction()
        .setTokenName("HIP-542 Example Collection")
        .setTokenSymbol("HIP-542")
        .setTokenType(TokenType.NonFungibleUnique)
        .setDecimals(0)
        .setInitialSupply(0)
        .setMaxSupply(CID.length)
        .setTreasuryAccountId(operatorId)
        .setSupplyType(TokenSupplyType.Finite)
        .setAdminKey(operatorKey)
        .setFreezeKey(freezeKey)
        .setWipeKey(wipeKey)
        .setSupplyKey(supplyKey)
        .freezeWith(client);

    // Sign the transaction with the operator key
    let nftCreateTxSign = await nftCreateTx.sign(operatorKey);

    // Submit the transaction to the Hedera network
    let nftCreateSubmit = await nftCreateTxSign.execute(client);

    // Get transaction receipt information
    let nftCreateRx = await nftCreateSubmit.getReceipt(client);
    let nftTokenId = nftCreateRx.tokenId;
    console.log(`Created NFT with token id: ${nftTokenId.toString()}`);

    /**
     * Step 2
     *
     * Mint the NFT
     */
    const nftCollection = [];
    for (var i = 0; i < CID.length; i++) {
        nftCollection[i] = await tokenMinterFcn(CID[i]);
        console.log(
            `Created NFT ${nftTokenId.toString()} with serial: ${nftCollection[
                i
            ].serials[0].toString()}`,
        );
    }

    let exampleNftId = nftCollection[0].serials[0];

    /**
     * Step 3
     *
     * Create an ECDSA public key alias
     */
    console.log("Creating a new account...");

    const privateKey = PrivateKey.generateECDSA();
    const publicKey = privateKey.publicKey;

    // Assuming that the target shard and realm are known.
    // For now they are virtually always 0 and 0.
    const aliasAccountId = publicKey.toAccountId(0, 0);

    console.log(`New account ID: ${aliasAccountId.toString()}`);
    console.log(`Just the aliasKey: ${aliasAccountId.aliasKey.toString()}`);

    /**
     * Step 4
     *
     * Transfer the NFT to the public key alias using the transfer transaction
     */
    let nftTransferTx = new TransferTransaction()
        .addNftTransfer(nftTokenId, exampleNftId, operatorId, aliasAccountId)
        .freezeWith(client);

    // Sign the transaction with the operator key
    let nftTransferTxSign = await nftTransferTx.sign(operatorKey);

    // Submit the transaction to the Hedera network
    let nftTransferSubmit = await nftTransferTxSign.execute(client);

    // Get transaction receipt information here
    await nftTransferSubmit.getReceipt(client);

    /**
     * Step 5
     *
     * Return the new account ID in the child record
     */

    //Returns the info for the specified NFT id
    const nftInfo = await new TokenNftInfoQuery()
        .setNftId(new NftId(nftTokenId, exampleNftId))
        .execute(client);

    let nftOwnerAccountId = nftInfo[0].accountId.toString();
    console.log(`Current owner account id: ${nftOwnerAccountId}`);

    /**
     * Step 6
     *
     * Show the new account ID owns the NFT
     */
    const accountId = (
        await new AccountInfoQuery()
            .setAccountId(aliasAccountId)
            .execute(client)
    ).accountId.toString();

    console.log(`The normal account ID of the given alias: ${accountId}`);

    nftOwnerAccountId === accountId
        ? console.log(
              `The NFT owner accountId matches the accountId created with the HTS\n`,
          )
        : console.log(`The two account IDs does not match\n`);

    /**
     *     Example 2
     *
     * Step 1
     *
     * Create a fungible HTS token using the Hedera Token Service
     */
    console.log(`Example 2`);

    const tokenCreateTx = new TokenCreateTransaction()
        .setTokenName("HIP-542 Token")
        .setTokenSymbol("H542")
        .setTokenType(TokenType.FungibleCommon)
        .setTreasuryAccountId(operatorId)
        .setInitialSupply(10000) // Total supply = 10000 / 10 ^ 2
        .setDecimals(2)
        .setAutoRenewAccountId(operatorId)
        .freezeWith(client);

    // Sign the transaction with the operator key
    let tokenCreateTxSign = await tokenCreateTx.sign(operatorKey);

    // Submit the transaction to the Hedera network
    let tokenCreateSubmit = await tokenCreateTxSign.execute(client);

    // Get transaction receipt information
    let tokenCreateRx = await tokenCreateSubmit.getReceipt(client);
    let tokenId = tokenCreateRx.tokenId.toString();
    console.log(`Created token with token id: ${tokenId}`);

    /**
     * Step 2
     *
     * Create an ECDSA public key alias
     */
    console.log("Creating a new account...");

    const privateKey2 = PrivateKey.generateECDSA();
    const publicKey2 = privateKey2.publicKey;

    // Assuming that the target shard and realm are known.
    // For now they are virtually always 0 and 0.
    const aliasAccountId2 = publicKey2.toAccountId(0, 0);

    console.log(`New account ID: ${aliasAccountId2.toString()}`);
    console.log(`Just the aliasKey: ${aliasAccountId2.aliasKey.toString()}`);

    /**
     * Step 3
     *
     * Transfer the fungible token to the public key alias
     */
    let tokenTransferTx = new TransferTransaction()
        .addTokenTransfer(tokenId, operatorId, -10)
        .addTokenTransfer(tokenId, aliasAccountId2, 10)
        .freezeWith(client);

    // Sign the transaction with the operator key
    let tokenTransferTxSign = await tokenTransferTx.sign(operatorKey);

    // Submit the transaction to the Hedera network
    let tokenTransferSubmit = await tokenTransferTxSign.execute(client);

    // Get transaction receipt information
    await tokenTransferSubmit.getReceipt(client);

    /**
     * Step 4
     *
     * Return the new account ID in the child record
     */
    const accountId2 = (
        await new AccountInfoQuery()
            .setAccountId(aliasAccountId2)
            .execute(client)
    ).accountId.toString();

    console.log(`The normal account ID of the given alias: ${accountId2}`);

    /**
     * Step 5
     *
     * Show the new account ID owns the fungible token
     */

    // Wait some time for the mirror node to be updated
    await wait(10000);

    let link;

    if (
        process.env.HEDERA_NETWORK == "local-node" ||
        process.env.HEDERA_NETWORK == "localhost"
    ) {
        link = `http://127.0.0.1:5551/api/v1/accounts?account.id=${accountId2}`;
    } else {
        link = `https://${process.env.HEDERA_NETWORK}.mirrornode.hedera.com/api/v1/accounts?account.id=${accountId2}`;
    }

    try {
        /* eslint-disable */
        const balance = (
            await axios.get(link)
        ).data.accounts[0].balance.tokens.find(
            (token) => token.token_id === tokenId,
        ).balance;
        /* eslint-enable */

        balance === 10
            ? console.log(
                  `Account is created successfully using HTS 'TransferTransaction'`,
              )
            : console.log(
                  "Creating account with HTS using public key alias failed",
              );
    } catch (e) {
        console.log(e);
    }

    /**
     * TOKEN MINTER FUNCTION
     * @param {string} CID
     * @returns {Promise<TransactionReceipt>}
     */
    async function tokenMinterFcn(CID) {
        const mintTx = new TokenMintTransaction()
            .setTokenId(nftTokenId)
            .setMetadata([Buffer.from(CID)])
            .freezeWith(client);
        let mintTxSign = await mintTx.sign(supplyKey);
        let mintTxSubmit = await mintTxSign.execute(client);
        return mintTxSubmit.getReceipt(client);
    }

    /**
     * @param {number} timeout
     * @returns {Promise<any>}
     */
    function wait(timeout) {
        return new Promise((resolve) => {
            setTimeout(resolve, timeout);
        });
    }

    client.close();
}

void main();
// Filename: examples/account-creation-ways.js
import { AccountId, PrivateKey } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

function main() {
    /* Source and context: https://hips.hedera.com/hip/hip-583

        In hedera Hedera, we have the concept of 4 different account representations
            -   An account can have an account ID in shard.realm.accountNumber format (0.0.10)
            -   An account can have a public key alias in 0.0.CIQNOWUYAGBLCCVX2VF75U6JMQDTUDXBOLZ5VJRDEWXQEGTI64DVCGQ format
            -   An account can have an AccountId that is represented in 0x000000000000000000000000000000000000000a (for account ID 0.0.10) long zero format
            -   An account has been represented by an Ethereum public address 0xb794f5ea0ba39494ce839613fffba74279579268
    */

    /*
        Account ID    -   shard.realm.number format, i.e. `0.0.10` with the corresponding `0x000000000000000000000000000000000000000a` ethereum address
    */
    const hederaFormat = AccountId.fromString("0.0.10");
    console.log(`Account ID: ${hederaFormat.toString()}`);
    console.log(
        `Account 0.0.10 corresponding Long-Zero address: ${hederaFormat.toSolidityAddress()}`,
    );

    /*
        Hedera Long-Form Account ID    -   0.0.aliasPublicKey, i.e. `0.0.CIQNOWUYAGBLCCVX2VF75U6JMQDTUDXBOLZ5VJRDEWXQEGTI64DVCGQ`
   */
    const privateKey = PrivateKey.generateECDSA();
    const publicKey = privateKey.publicKey;

    // Assuming that the target shard and realm are known.
    // For now they are virtually always 0 and 0.
    const aliasAccountId = publicKey.toAccountId(0, 0);
    console.log(`Hedera Long-Form Account ID: ${aliasAccountId.toString()}`);

    /*
        Hedera Account Long-Zero address    -   0x000000000000000000000000000000000000000a (for accountId 0.0.10)
    */
    const longZeroAddress = AccountId.fromString(
        "0x000000000000000000000000000000000000000a",
    );
    console.log(
        `Hedera Account Long-Zero address: ${longZeroAddress.toString()}`,
    );

    /*
        Ethereum Account Address / public-address   -   0xb794f5ea0ba39494ce839613fffba74279579268
    */
    const evmAddress = AccountId.fromString(
        "0xb794f5ea0ba39494ce839613fffba74279579268",
    );
    console.log(
        `Ethereum Account Address / public-address: ${evmAddress.toString()}`,
    );

    if (
        hederaFormat.toString() &&
        longZeroAddress.toString() &&
        aliasAccountId.toString() &&
        evmAddress.toString()
    ) {
        process.exit(0);
    }

    process.exit(1);
}

void main();
// Filename: examples/change-or-remove-token-keys.js
import {
    AccountId,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    PublicKey,
    KeyList,
    TokenUpdateTransaction,
    TokenKeyValidation,
    TokenCreateTransaction,
    TokenType,
    TokenInfoQuery,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Change ot remove token keys
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    const adminKey = PrivateKey.generateED25519();
    const supplyKey = PrivateKey.generateED25519();
    const newSupplyKey = PrivateKey.generateED25519();
    const wipeKey = PrivateKey.generateED25519();
    const freezeKey = PrivateKey.generateED25519();
    const pauseKey = PrivateKey.generateED25519();
    const feeScheduleKey = PrivateKey.generateED25519();
    const metadataKey = PrivateKey.generateED25519();

    // This HIP introduces ability to remove lower-privilege keys (Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata) from a Token:
    // - using an update with the empty KeyList;
    const emptyKeyList = KeyList.of();
    // - updating with an “invalid” key such as an Ed25519 0x0000000000000000000000000000000000000000000000000000000000000000 public key,
    // since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes of zeros.
    const unusableKey = PublicKey.unusableKey();

    console.log("=====================================================");
    console.log("Initializing token keys...");
    console.log("-----------------------------------------------------");
    console.log("Admin key:", adminKey.publicKey.toString());
    console.log("Supply key:", supplyKey.publicKey.toString());
    console.log("New supply key:", newSupplyKey.publicKey.toString());
    console.log("Wipe key:", wipeKey.publicKey.toString());
    console.log("Freeze key:", freezeKey.publicKey.toString());
    console.log("Pause key:", pauseKey.publicKey.toString());
    console.log("Fee schedule key:", feeScheduleKey.publicKey.toString());
    console.log("Metadata key:", metadataKey.publicKey.toString());
    console.log("Unusable key:", unusableKey.toString());
    console.log("=====================================================");
    console.log("\n");

    let token, tokenInfo, response, receipt, update;

    console.log("=====================================================");
    console.log("Creating token...");
    console.log("-----------------------------------------------------");
    token = new TokenCreateTransaction()
        .setTokenName("Token")
        .setTokenSymbol("T")
        .setTokenType(TokenType.NonFungibleUnique)
        .setTreasuryAccountId(operatorId)
        .setAdminKey(adminKey)
        .setWipeKey(wipeKey)
        .setFreezeKey(freezeKey)
        .setPauseKey(pauseKey)
        .setSupplyKey(supplyKey)
        .setFeeScheduleKey(feeScheduleKey)
        .setMetadataKey(metadataKey)
        .freezeWith(client);

    response = await (await token.sign(adminKey)).execute(client);

    receipt = await response.getReceipt(client);
    console.log("Token create transction status:", receipt.status.toString());

    const tokenId = receipt.tokenId;
    console.log("Token id:", tokenId.toString());
    console.log("=====================================================");
    console.log("\n");
    console.log("=====================================================");
    console.log("Token keys:");
    console.log("-----------------------------------------------------");
    tokenInfo = await new TokenInfoQuery().setTokenId(tokenId).execute(client);

    console.log("Token admin key:", tokenInfo.adminKey.toString());
    console.log("Token pause key:", tokenInfo.pauseKey.toString());
    console.log("Token freeze key:", tokenInfo.freezeKey.toString());
    console.log("Token wipe key:", tokenInfo.wipeKey.toString());
    console.log("Token supply key:", tokenInfo.supplyKey.toString());
    console.log("Token fee schedule key:", tokenInfo.feeScheduleKey.toString());
    console.log("Token metadata key:", tokenInfo.metadataKey.toString());
    console.log("=====================================================");
    console.log("\n");
    console.log("=====================================================");
    console.log("Removing Wipe Key...");
    console.log("-----------------------------------------------------");
    update = new TokenUpdateTransaction()
        .setTokenId(tokenId)
        .setWipeKey(emptyKeyList)
        .setKeyVerificationMode(TokenKeyValidation.FullValidation)
        .freezeWith(client);
    response = await (await update.sign(adminKey)).execute(client);

    receipt = await response.getReceipt(client);
    console.log("Token update transaction status:", receipt.status.toString());

    tokenInfo = await new TokenInfoQuery().setTokenId(tokenId).execute(client);
    console.log("Token wipeKey is", tokenInfo.wipeKey);
    console.log("=====================================================");
    console.log("\n");
    console.log("=====================================================");
    console.log("Removing Admin Key...");
    console.log("-----------------------------------------------------");
    update = new TokenUpdateTransaction()
        .setTokenId(tokenId)
        .setAdminKey(emptyKeyList)
        .setKeyVerificationMode(TokenKeyValidation.NoValidation)
        .freezeWith(client);
    response = await (await update.sign(adminKey)).execute(client);

    receipt = await response.getReceipt(client);
    console.log("Token update transaction status:", receipt.status.toString());

    tokenInfo = await new TokenInfoQuery().setTokenId(tokenId).execute(client);
    console.log("Token adminKey is", tokenInfo.adminKey);
    console.log("=====================================================");
    console.log("\n");
    console.log("=====================================================");
    console.log("Updating Supply Key...");
    console.log("-----------------------------------------------------");
    console.log(
        "Token supplyKey (before update) is",
        tokenInfo.supplyKey.toString(),
    );
    update = new TokenUpdateTransaction()
        .setTokenId(tokenId)
        .setSupplyKey(newSupplyKey)
        .setKeyVerificationMode(TokenKeyValidation.FullValidation)
        .freezeWith(client);
    response = await (
        await (await update.sign(supplyKey)).sign(newSupplyKey)
    ).execute(client);

    receipt = await response.getReceipt(client);
    console.log("Token update transaction status:", receipt.status.toString());

    tokenInfo = await new TokenInfoQuery().setTokenId(tokenId).execute(client);
    console.log(
        "Token suppleyKey (after update) is",
        tokenInfo.supplyKey.toString(),
    );
    console.log("=====================================================");
    console.log("\n");
    console.log("=====================================================");
    console.log("Updating Supply Key to unusable format...");
    console.log("-----------------------------------------------------");
    console.log(
        "Token supplyKey (before update) is",
        tokenInfo.supplyKey.toString(),
    );
    update = new TokenUpdateTransaction()
        .setTokenId(tokenId)
        .setSupplyKey(unusableKey)
        .setKeyVerificationMode(TokenKeyValidation.NoValidation)
        .freezeWith(client);
    response = await (await update.sign(newSupplyKey)).execute(client);

    receipt = await response.getReceipt(client);
    console.log("Token update transaction status:", receipt.status.toString());

    tokenInfo = await new TokenInfoQuery().setTokenId(tokenId).execute(client);

    console.log(
        "Token suppleyKey (after update) is",
        tokenInfo.supplyKey.toString(),
    );
    console.log("=====================================================");

    client.close();
}

void main();
// Filename: examples/consensus-pub-sub.js
import {
    Client,
    PrivateKey,
    AccountId,
    TopicMessageQuery,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";
import { setTimeout } from "node:timers/promises";

dotenv.config();

async function main() {
    let client;

    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringDer(process.env.OPERATOR_KEY),
    );

    try {
        const response = await new TopicCreateTransaction()
            .setTopicMemo("sdk example create_pub_sub.js")
            .execute(client);

        const receipt = await response.getReceipt(client);
        const topicId = receipt.topicId;

        console.log(`topicId = ${topicId.toString()}`);

        // need to wait before the mirror node can see new topic
        await setTimeout(5000);

        new TopicMessageQuery()
            .setTopicId(topicId)
            .setStartTime(0)
            .subscribe(
                client,
                (message, error) => {
                    console.log(message);
                    console.log(error);
                },
                (message) =>
                    console.log(Buffer.from(message.contents).toString("utf8")),
            );
        const MESSAGES_LIMIT = 20;

        // need to wait some time before we can receive messages
        await setTimeout(5000);

        for (let i = 0; i < MESSAGES_LIMIT; i += 1) {
            //NOSONAR
            // eslint-disable-next-line no-await-in-loop
            await (
                await new TopicMessageSubmitTransaction()
                    .setNodeAccountIds([response.nodeId])
                    .setTopicId(topicId)
                    .setMessage(bigContents)
                    .execute(client)
            ).getReceipt(client);
            console.log(`Sent message ${i}`);
            await setTimeout(5000);
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();

const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`;
// Filename: examples/contract-nonces.js
import {
    Wallet,
    LocalProvider,
    ContractCreateTransaction,
    FileCreateTransaction,
    PrivateKey,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";
dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    // The contract bytecode is located on the `object` field
    const SMART_CONTRACT_BYTECODE =
        "6080604052348015600f57600080fd5b50604051601a90603b565b604051809103906000f0801580156035573d6000803e3d6000fd5b50506047565b605c8061009483390190565b603f806100556000396000f3fe6080604052600080fdfea2646970667358221220a20122cbad3457fedcc0600363d6e895f17048f5caa4afdab9e655123737567d64736f6c634300081200336080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122053dfd8835e3dc6fedfb8b4806460b9b7163f8a7248bac510c6d6808d9da9d6d364736f6c63430008120033";

    try {
        const fileCreateTxResponse = await (
            await new FileCreateTransaction()
                .setKeys([PrivateKey.fromStringDer(process.env.OPERATOR_KEY)])
                .setContents(SMART_CONTRACT_BYTECODE)
                .setMaxTransactionFee(new Hbar(2))
                .freezeWithSigner(wallet)
        ).executeWithSigner(wallet);

        const fileCreateTxReceipt =
            await fileCreateTxResponse.getReceiptWithSigner(wallet);
        const newFileId = fileCreateTxReceipt.fileId;

        const contractCreateTxResponse = await (
            await new ContractCreateTransaction()
                .setAdminKey(PrivateKey.fromStringDer(process.env.OPERATOR_KEY))
                .setGas(100000)
                .setBytecodeFileId(newFileId)
                .setContractMemo(
                    "[e2e::ContractADeploysContractBInConstructor]",
                )
                .freezeWithSigner(wallet)
        ).executeWithSigner(wallet);

        const record =
            await contractCreateTxResponse.getRecordWithSigner(wallet);

        console.log(
            `contractNonces: ${JSON.stringify(
                record.contractFunctionResult.contractNonces,
            )}`,
        );
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/create-account-with-alias-and-receiver-signature.js
import {
    AccountId,
    PrivateKey,
    Client,
    Hbar,
    AccountInfoQuery,
    TransactionReceiptQuery,
    AccountCreateTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/*
Reference: [HIP-583 Expand alias support in CryptoCreate & CryptoTransfer Transactions](https://hips.hedera.com/hip/hip-583)
    ## Example 1:
    - Create an ECSDA private key and an ED25519 admin private key
    - Extract the ECDSA public key
    - Extract the Ethereum public address
    - Use the `AccountCreateTransaction`
        - populate `setAlias(evmAddress)` field with the Ethereum public address
        - populate the `setReceiverSignatureRequired` to true
    - Sign the `AccountCreateTransaction` transaction with both the new private key and the admin key
    - Get the `AccountInfo` and show that the account has contractAccountId
*/

async function main() {
    if (process.env.OPERATOR_ID == null || process.env.OPERATOR_KEY == null) {
        throw new Error(
            "Environment variables OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const nodes = {
        "127.0.0.1:50211": new AccountId(3),
    };

    const client = Client.forNetwork(nodes).setOperator(
        operatorId,
        operatorKey,
    );

    try {
        /**
         * Step 1
         *
         * Create an ECSDA private key and an ED25519 admin private key
         */
        const adminKey = PrivateKey.generateED25519();
        console.log(`Admin private key: ${adminKey.toStringDer()}`);

        const privateKey = PrivateKey.generateECDSA();
        console.log(`Private key: ${privateKey.toStringDer()}`);

        /**
         * Step 2
         *
         * Extract the ECDSA public key
         */
        const publicKey = privateKey.publicKey;
        console.log(`Public key: ${publicKey.toStringDer()}`);

        /**
         *
         * Step 3
         *
         * Extract the Ethereum public address
         */
        const evmAddress = publicKey.toEvmAddress();
        console.log(`Corresponding evm address: ${evmAddress}`);

        /**
         *
         * Step 4
         *
         * Use the `AccountCreateTransaction`
         *   - Populate `setAlias(evmAddress)` field with the Ethereum public address
         *   - Populate the `setReceiverSignatureRequired()` to `true`
         */
        const accountCreateTx = new AccountCreateTransaction()
            .setReceiverSignatureRequired(true)
            .setInitialBalance(Hbar.fromTinybars(100))
            .setKeyWithoutAlias(adminKey)
            .setAlias(evmAddress)
            .freezeWith(client);

        /**
         *
         * Step 5
         *
         * Sign the `AccountCreateTransaction` transaction with both the new private key and key paying for the transaction fee
         */
        const accountCreateTxSign = await (
            await accountCreateTx.sign(privateKey)
        ).sign(adminKey);
        const accountCreateTxResponse =
            await accountCreateTxSign.execute(client);

        /**
         *
         * Step 6
         *
         * Get the account ID of the newly created account
         */
        const receipt = await new TransactionReceiptQuery()
            .setTransactionId(accountCreateTxResponse.transactionId)
            .execute(client);

        const newAccountId = receipt.accountId.toString();
        console.log(`Account ID of the newly created account: ${newAccountId}`);

        /**
         *
         * Step 7
         *
         * Get the `AccountInfo` and show that the account has contractAccountId
         */
        const accountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        accountInfo.contractAccountId !== null
            ? console.log(
                  `The newly created account has an alias: ${accountInfo.contractAccountId}`,
              )
            : console.log(`The new account doesn't have an alias`);
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/create-account-with-alias.js
import {
    AccountId,
    PrivateKey,
    Client,
    Hbar,
    AccountInfoQuery,
    AccountCreateTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/*
Reference: [HIP-583 Expand alias support in CryptoCreate & CryptoTransfer Transactions](https://hips.hedera.com/hip/hip-583)
    ## Example 1:
    - Create a ECSDA private key
    - Extract the ECDSA public key
    - Extract the Ethereum public address
    - Use the `AccountCreateTransaction`
        - populate `setAlias(evmAddress)` field with the Ethereum public address
    - Sign the `AccountCreateTransaction` transaction with both the new private key and key paying for the transaction fee
    - Get the `AccountInfo` and show that the account has contractAccountId
*/

async function main() {
    if (process.env.OPERATOR_ID == null || process.env.OPERATOR_KEY == null) {
        throw new Error(
            "Environment variables OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const nodes = {
        "127.0.0.1:50211": new AccountId(3),
    };

    const client = Client.forNetwork(nodes).setOperator(
        operatorId,
        operatorKey,
    );

    try {
        /**
         * Step 1
         *
         * Create an ECSDA private key
         */
        const privateKey = PrivateKey.generateECDSA();
        console.log(`Private key: ${privateKey.toStringDer()}`);

        /**
         * Step 2
         *
         * Extract the ECDSA public key
         */
        const publicKey = privateKey.publicKey;
        console.log(`Public key: ${publicKey.toStringDer()}`);

        /**
         *
         * Step 3
         *
         * Extract the Ethereum public address
         */
        const evmAddress = publicKey.toEvmAddress();
        console.log(`Corresponding evm address: ${evmAddress}`);

        /**
         *
         * Step 4
         *
         * Use the `AccountCreateTransaction`
         *   - Populate `setAlias(evmAddress)` field with the Ethereum public address
         * Sign the `AccountCreateTransaction` transaction with both the new private key and key paying for the transaction fee
         * Get the account ID of the newly created account
         */
        const receipt = await (
            await (
                await new AccountCreateTransaction()
                    .setInitialBalance(Hbar.fromTinybars(100))
                    .setKeyWithoutAlias(operatorKey)
                    .setAlias(evmAddress)
                    .freezeWith(client)
                    .sign(privateKey)
            ).execute(client)
        ).getReceipt(client);

        const newAccountId = receipt.accountId.toString();
        console.log(`Account ID of the newly created account: ${newAccountId}`);

        /**
         *
         * Step 5
         *
         * Get the `AccountInfo` and show that the account has contractAccountId
         */
        const accountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        console.log(
            `The newly created account has an alias: ${accountInfo.contractAccountId}`,
        );
    } catch (error) {
        console.error(error);
    }

    /* Create an account with derived EVM alias from private ECDSA account key
     *
     * Reference: [Streamline key and alias specifications for AccountCreateTransaction #2795](https://github.com/hiero-ledger/hiero-sdk-js/issues/2795)
     */
    console.log(
        "---Create an account with derived EVM alias from private ECDSA account key---",
    );

    try {
        /**
         * Step 1
         *
         * Create an ECSDA private key
         */
        const privateKey = PrivateKey.generateECDSA();
        console.log(`Private key: ${privateKey.toStringDer()}`);

        /**
         *
         * Step 2
         *
         * Use the `AccountCreateTransaction`
         *   - Populate `setECDSAKeyWithAlias(privateKey)` field with the generated ECDSA private key
         * Sign the `AccountCreateTransaction` transaction with the generated private key and execute it
         * Get the account ID of the newly created account
         */

        const receipt = await (
            await (
                await new AccountCreateTransaction()
                    .setInitialBalance(Hbar.fromTinybars(100))
                    .setECDSAKeyWithAlias(privateKey)
                    .freezeWith(client)
                    .sign(privateKey)
            ).execute(client)
        ).getReceipt(client);

        const newAccountId = receipt.accountId.toString();
        console.log(`Account ID of the newly created account: ${newAccountId}`);

        /**
         *
         * Step 3
         *
         * Get the `AccountInfo` and examine the created account key and alias
         */
        const accountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        console.log(
            `Account's key ${accountInfo.key.toString()} is the same as ${privateKey.publicKey.toStringDer()}`,
        );

        if (
            !accountInfo.contractAccountId.startsWith(
                "000000000000000000000000",
            )
        ) {
            console.log(
                `Initial EVM address: ${privateKey.publicKey.toEvmAddress()} is the same as ${
                    accountInfo.contractAccountId
                }`,
            );
        } else {
            console.log(`The new account doesn't have an EVM alias`);
        }
    } catch (error) {
        console.error(error);
    }

    /* Create an account with derived EVM alias from private ECDSA alias key
     *
     * Reference: [Streamline key and alias specifications for AccountCreateTransaction #2795](https://github.com/hiero-ledger/hiero-sdk-js/issues/2795)
     */

    console.log(
        "---Create an account with derived EVM alias from private ECDSA alias key---",
    );

    try {
        /**
         * Step 1
         *
         * Create an account key and an ECSDA private alias key
         */
        const key = PrivateKey.generateED25519();
        const aliasKey = PrivateKey.generateECDSA();
        console.log(`Alias key: ${aliasKey.toStringDer()}`);

        /**
         *
         * Step 2
         *
         * Use the `AccountCreateTransaction`
         *   - Populate `setKeyWithAlias(key, privateKey)` fields with the generated account key and the alias ECDSA private key
         * Sign the `AccountCreateTransaction` transaction with both keys and execute.
         * Get the account ID of the newly created account
         *
         */

        const receipt = await (
            await (
                await (
                    await new AccountCreateTransaction()
                        .setInitialBalance(Hbar.fromTinybars(100))
                        .setKeyWithAlias(key, aliasKey)
                        .freezeWith(client)
                        .sign(key)
                ).sign(aliasKey)
            ).execute(client)
        ).getReceipt(client);

        const newAccountId = receipt.accountId.toString();
        console.log(`Account ID of the newly created account: ${newAccountId}`);

        /**
         *
         * Step 3
         *
         * Get the `AccountInfo` and examine the created account key and alias
         */
        const accountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        console.log(
            `Account's key ${accountInfo.key.toString()} is the same as ${key.publicKey.toString()}`,
        );

        if (
            !accountInfo.contractAccountId.startsWith(
                "000000000000000000000000",
            )
        ) {
            console.log(
                `Initial EVM address: ${accountInfo.contractAccountId} is the same as ${aliasKey.publicKey.toEvmAddress()}`,
            );
        } else {
            console.log(`The new account doesn't have an alias`);
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/create-account-with-thresholdkey.js
import {
    Client,
    PrivateKey,
    AccountId,
    Hbar,
    AccountCreateTransaction,
    TransferTransaction,
    AccountBalanceQuery,
    AccountDeleteTransaction,
    KeyList,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/**
 * Step 0: Set up client connection to Hedera network
 */

async function main() {
    if (
        !process.env.OPERATOR_ID ||
        !process.env.OPERATOR_KEY ||
        !process.env.HEDERA_NETWORK
    ) {
        console.error(
            "Environment variables OPERATOR_ID, OPERATOR_KEY, and HEDERA_NETWORK are required.",
        );
        throw new Error("Missing required environment variables.");
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    //  Create the client based on the HEDERA_NETWORK environment variable
    const client = Client.forName(process.env.HEDERA_NETWORK);

    client.setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        console.log("Create Account With Threshold Key Example Start!");

        /*
         * Step 1:
         * Generate three new Ed25519 private, public key pairs.
         *
         */

        const privateKeys = [];
        const publicKeys = [];
        for (let i = 0; i < 3; i++) {
            const key = PrivateKey.generateED25519();
            privateKeys.push(key);
            publicKeys.push(key.publicKey);
        }

        console.log("Generating public keys...");
        publicKeys.forEach((publicKey, index) => {
            console.log(
                `Generated public key ${index + 1}: ${publicKey.toString()}`,
            );
        });

        /*
         * Step 2:
         * Create a Key List.
         *
         * Require 2 of the 3 keys we generated to sign on anything modifying this account.
         */
        const thresholdKey = new KeyList(publicKeys, 2);

        /*
         * Step 3:
         * Create a new account setting a Key List from a previous step as an account's key.
         */
        console.log("Creating new account...");
        const accountCreateTxResponse = await new AccountCreateTransaction()
            .setKeyWithoutAlias(thresholdKey)
            .setInitialBalance(new Hbar(100))
            .execute(client);

        const accountCreateTxReceipt =
            await accountCreateTxResponse.getReceipt(client);
        const newAccountId = accountCreateTxReceipt.accountId;

        console.log(`Created account with ID: ${newAccountId.toString()}`);

        /*
         * Step 4:
         * Create a transfer transaction from a newly created account to demonstrate the signing process (threshold).
         */
        console.log("Transferring 1 Hbar from a newly created account...");
        let transferTx = new TransferTransaction()
            .addHbarTransfer(newAccountId, new Hbar(-50))
            .addHbarTransfer(new AccountId(3), new Hbar(50))
            .freezeWith(client);

        // Sign with 2 of the 3 keys
        transferTx = await transferTx.sign(privateKeys[0]);
        transferTx = await transferTx.sign(privateKeys[1]);

        // Execute the transaction
        const transferTxResponse = await transferTx.execute(client);

        // Wait for the transfer to reach consensus
        await transferTxResponse.getReceipt(client);

        // Query the account balance after the transfer
        const accountBalanceAfterTransfer = await new AccountBalanceQuery()
            .setAccountId(newAccountId)
            .execute(client);

        console.log(
            "New account's Hbar balance after transfer: " +
                accountBalanceAfterTransfer.hbars.toString(),
        );

        /*
         * Step 5:
         * Clean up: Delete created account.
         */
        let accountDeleteTx = new AccountDeleteTransaction()
            .setTransferAccountId(operatorId)
            .setAccountId(newAccountId)
            .freezeWith(client);

        accountDeleteTx = await accountDeleteTx.sign(privateKeys[0]);
        accountDeleteTx = await accountDeleteTx.sign(privateKeys[1]);

        const accountDeleteTxResponse = await accountDeleteTx.execute(client);
        await accountDeleteTxResponse.getReceipt(client);

        console.log("Account deleted successfully");
    } catch (error) {
        console.error("Error occurred during account creation");
    } finally {
        client.close();
        console.log("Create Account With Threshold Key Example Complete!");
    }
}

void main();
// Filename: examples/create-account.js
import {
    Wallet,
    LocalProvider,
    PrivateKey,
    AccountCreateTransaction,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const newKey = PrivateKey.generate();

    console.log(`private key = ${newKey.toString()}`);
    console.log(`public key = ${newKey.publicKey.toString()}`);

    try {
        let transaction = await new AccountCreateTransaction()
            .setInitialBalance(new Hbar(10)) // 10 h
            .setKeyWithoutAlias(newKey.publicKey)
            .freezeWithSigner(wallet);

        transaction = await transaction.signWithSigner(wallet);

        const response = await transaction.executeWithSigner(wallet);

        const receipt = await response.getReceiptWithSigner(wallet);

        console.log(`account id = ${receipt.accountId.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/create-contract-with-value.js
import {
    Wallet,
    LocalProvider,
    ContractCreateTransaction,
    FileCreateTransaction,
    ContractDeleteTransaction,
    ContractCallQuery,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

// Import the compiled contract
import payableContract from "./payable.json" with { type: "json" };

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    // The contract bytecode is located on the `object` field
    const contractByteCode = payableContract.object;

    try {
        // Create a file on Hedera which contains the contact bytecode.
        // Note: The contract bytecode **must** be hex encoded, it should not
        // be the actual data the hex represents
        let transaction = await new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents(contractByteCode)
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        let fileTransactionResponse =
            await transaction.executeWithSigner(wallet);

        // Fetch the receipt for transaction that created the file
        const fileReceipt =
            await fileTransactionResponse.getReceiptWithSigner(wallet);

        // The file ID is located on the transaction receipt
        const fileId = fileReceipt.fileId;

        console.log(`contract bytecode file: ${fileId.toString()}`);

        // Create the contract
        let createContractTransaction = await new ContractCreateTransaction()
            // Set gas to create the contract
            .setGas(100000)
            // The contract bytecode must be set to the file ID containing the contract bytecode
            .setBytecodeFileId(fileId)
            // Set the admin key on the contract in case the contract should be deleted or
            // updated in the future
            .setAdminKey(wallet.getAccountKey())
            // Set an initial amount in HBARs to be set to the contract when it is deployed (equivalent of `value`)
            .setInitialBalance(50)
            .freezeWithSigner(wallet);
        createContractTransaction =
            await createContractTransaction.signWithSigner(wallet);

        const contractTransactionResponse =
            await createContractTransaction.executeWithSigner(wallet);

        // Fetch the receipt for the transaction that created the contract
        const contractReceipt =
            await contractTransactionResponse.getReceiptWithSigner(wallet);

        // The contract ID is located on the transaction receipt
        const contractId = contractReceipt.contractId;

        console.log(`new contract ID: ${contractId.toString()}`);

        // Call a method on a contract that exists on Hedera
        // Note: `ContractCallQuery` cannot mutate a contract, it will only return the last state
        // of the contract
        const contractCallResult = await new ContractCallQuery()
            // Set the gas to execute a contract call
            .setGas(75000)
            // Set which contract
            .setContractId(contractId)
            // Set the function to call on the contract
            .setFunction("greet")
            .setQueryPayment(new Hbar(1))
            .executeWithSigner(wallet);

        if (
            contractCallResult.errorMessage != null &&
            contractCallResult.errorMessage != ""
        ) {
            console.log(
                `error calling contract: ${contractCallResult.errorMessage}`,
            );
        }

        // Get the message from the result
        // The `0` is the index to fetch a particular type from
        //
        // e.g.
        // If the return type of `get_message` was `(string[], uint32, string)`
        // then you'd need to get each field separately using:
        //      const stringArray = contractCallResult.getStringArray(0);
        //      const uint32 = contractCallResult.getUint32(1);
        //      const string = contractCallResult.getString(2);
        const message = contractCallResult.getString(0);
        console.log(`contract message: ${message}`);

        let contractDeleteTransaction = await new ContractDeleteTransaction()
            .setContractId(contractId)
            .setTransferAccountId(wallet.accountId)
            .freezeWithSigner(wallet);
        await contractDeleteTransaction.signWithSigner(wallet);
        const contractDeleteResult =
            await contractDeleteTransaction.executeWithSigner(wallet);

        // Delete the contract
        // Note: The admin key of the contract needs to sign the transaction
        // In this case the client operator is the same as the admin key so the
        // automatic signing takes care of this for you
        await contractDeleteResult.getReceiptWithSigner(wallet);

        console.log("contract successfully deleted");
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/create-simple-contract.js
import {
    Wallet,
    LocalProvider,
    ContractCreateTransaction,
    FileCreateTransaction,
    ContractDeleteTransaction,
    ContractCallQuery,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

// Import the compiled contract
import helloWorld from "./hello_world.json" with { type: "json" };

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        // The contract bytecode is located on the `object` field
        const contractByteCode = helloWorld.object;

        // Create a file on Hedera which contains the contact bytecode.
        // Note: The contract bytecode **must** be hex encoded, it should not
        // be the actual data the hex represents
        let transaction = await new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents(contractByteCode)
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        let fileTransactionResponse =
            await transaction.executeWithSigner(wallet);

        // Fetch the receipt for transaction that created the file
        const fileReceipt =
            await fileTransactionResponse.getReceiptWithSigner(wallet);

        // The file ID is located on the transaction receipt
        const fileId = fileReceipt.fileId;

        console.log(`contract bytecode file: ${fileId.toString()}`);

        // Create the contract
        let contractCreateTransaction = await new ContractCreateTransaction()
            // Set gas to create the contract
            .setGas(100000)
            // The contract bytecode must be set to the file ID containing the contract bytecode
            .setBytecodeFileId(fileId)
            // Set the admin key on the contract in case the contract should be deleted or
            // updated in the future
            .setAdminKey(wallet.getAccountKey())
            .freezeWithSigner(wallet);
        contractCreateTransaction =
            await contractCreateTransaction.signWithSigner(wallet);

        const contractTransactionResponse =
            await contractCreateTransaction.executeWithSigner(wallet);

        // Fetch the receipt for the transaction that created the contract
        const contractReceipt =
            await contractTransactionResponse.getReceiptWithSigner(wallet);

        // The contract ID is located on the transaction receipt
        const contractId = contractReceipt.contractId;

        console.log(`new contract ID: ${contractId.toString()}`);

        // Call a method on a contract that exists on Hedera
        // Note: `ContractCallQuery` cannot mutate a contract, it will only return the last state
        // of the contract
        const contractCallResult = await new ContractCallQuery()
            // Set the gas to execute a contract call
            .setGas(75000)
            // Set which contract
            .setContractId(contractId)
            // Set the function to call on the contract
            .setFunction("greet")
            .setQueryPayment(new Hbar(1))
            .executeWithSigner(wallet);

        if (
            contractCallResult.errorMessage != null &&
            contractCallResult.errorMessage != ""
        ) {
            console.log(
                `error calling contract: ${contractCallResult.errorMessage}`,
            );
        }

        // Get the message from the result
        // The `0` is the index to fetch a particular type from
        //
        // e.g.
        // If the return type of `get_message` was `(string[], uint32, string)`
        // then you'd need to get each field separately using:
        //      const stringArray = contractCallResult.getStringArray(0);
        //      const uint32 = contractCallResult.getUint32(1);
        //      const string = contractCallResult.getString(2);
        const message = contractCallResult.getString(0);
        console.log(`contract message: ${message}`);

        let contractDeleteTransaction = await new ContractDeleteTransaction()
            .setContractId(contractId)
            .setTransferAccountId(wallet.accountId)
            .freezeWithSigner(wallet);
        contractDeleteTransaction =
            await contractDeleteTransaction.signWithSigner(wallet);
        const contractDeleteResult =
            await contractDeleteTransaction.executeWithSigner(wallet);

        // Delete the contract
        // Note: The admin key of the contract needs to sign the transaction
        // In this case the client operator is the same as the admin key so the
        // automatic signing takes care of this for you
        await contractDeleteResult.getReceiptWithSigner(wallet);

        console.log("contract successfully deleted");
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/create-stateful-contract.js
import {
    Wallet,
    LocalProvider,
    ContractCreateTransaction,
    ContractExecuteTransaction,
    FileCreateTransaction,
    ContractFunctionParameters,
    ContractCallQuery,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

// Import the compiled contract
import stateful from "./stateful.json" with { type: "json" };

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    // The contract bytecode is located on the `object` field
    const contractByteCode = /** @type {string} */ (stateful.object);

    try {
        // Create a file on Hedera which contains the contact bytecode.
        // Note: The contract bytecode **must** be hex encoded, it should not
        // be the actual data the hex represents
        let transaction = await new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents(contractByteCode)
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const fileTransactionResponse =
            await transaction.executeWithSigner(wallet);

        // Fetch the receipt for transaction that created the file
        const fileReceipt =
            await fileTransactionResponse.getReceiptWithSigner(wallet);

        // The file ID is located on the transaction receipt
        const fileId = fileReceipt.fileId;

        console.log(`contract bytecode file: ${fileId.toString()}`);

        // Create the contract
        let contractCreateTransaction = await new ContractCreateTransaction()
            // Set the parameters that should be passed to the contract constructor
            // In this case we are passing in a string with the value "hello from hedera!"
            // as the only parameter that is passed to the contract
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "hello from hedera!",
                ),
            )
            // Set gas to create the contract
            .setGas(150000)
            // The contract bytecode must be set to the file ID containing the contract bytecode
            .setBytecodeFileId(fileId)
            // Set the admin key on the contract in case the contract should be deleted or
            // updated in the future
            .setAdminKey(wallet.getAccountKey())
            .freezeWithSigner(wallet);
        contractCreateTransaction =
            await contractCreateTransaction.signWithSigner(wallet);
        const contractTransactionResponse =
            await contractCreateTransaction.executeWithSigner(wallet);

        // Fetch the receipt for the transaction that created the contract
        const contractReceipt =
            await contractTransactionResponse.getReceiptWithSigner(wallet);

        // The contract ID is located on the transaction receipt
        const contractId = contractReceipt.contractId;

        console.log(`new contract ID: ${contractId.toString()}`);

        // Call a method on a contract that exists on Hedera
        // Note: `ContractCallQuery` cannot mutate a contract, it will only return the last state
        // of the contract
        const contractCallResult = await new ContractCallQuery()
            // Set the gas to execute a contract call
            .setGas(75000)
            // Set which contract
            .setContractId(contractId)
            // Set the function to call on the contract
            .setFunction("get_message")
            .setQueryPayment(new Hbar(1))
            .executeWithSigner(wallet);

        // Check if an error was returned
        if (
            contractCallResult.errorMessage != null &&
            contractCallResult.errorMessage != ""
        ) {
            console.log(
                `error calling contract: ${contractCallResult.errorMessage}`,
            );
        }

        // Get the message from the result
        // The `0` is the index to fetch a particular type from
        //
        // e.g.
        // If the return type of `get_message` was `(string[], uint32, string)`
        // then you'd need to get each field separately using:
        //      const stringArray = contractCallResult.getStringArray(0);
        //      const uint32 = contractCallResult.getUint32(1);
        //      const string = contractCallResult.getString(2);
        const message = contractCallResult.getString(0);
        console.log(`contract message: ${message}`);

        // Call a method on a contract exists on Hedera, but is allowed to mutate the contract state
        let contractExecuteTransaction = await new ContractExecuteTransaction()
            // Set which contract
            .setContractId(contractId)
            // Set the gas to execute the contract call
            .setGas(75000)
            // Set the function to call and the parameters to send
            // in this case we're calling function "set_message" with a single
            // string parameter of value "hello from hedera again!"
            // If instead the "set_message" method were to require "string[], uint32, string"
            // parameters then you must do:
            //      new ContractFunctionParameters()
            //          .addStringArray(["string 1", "string 2"])
            //          .addUint32(1)
            //          .addString("string 3")
            .setFunction(
                "set_message",
                new ContractFunctionParameters().addString(
                    "hello from hedera again!",
                ),
            )
            .freezeWithSigner(wallet);
        await contractExecuteTransaction.signWithSigner(wallet);
        const contractExecTransactionResponse =
            await contractExecuteTransaction.executeWithSigner(wallet);

        await contractExecTransactionResponse.getReceiptWithSigner(wallet);

        // Call a method on a contract that exists on Hedera
        const contractUpdateResult = await new ContractCallQuery()
            // Set which contract
            .setContractId(contractId)
            // Set gas to use
            .setGas(75000)
            // Set the function to call on the contract
            .setFunction("get_message")
            // Set query payment explicitly
            .setQueryPayment(new Hbar(3))
            .executeWithSigner(wallet);

        // Check if there were any errors
        if (
            contractUpdateResult.errorMessage != null &&
            contractUpdateResult.errorMessage != ""
        ) {
            console.log(
                `error calling contract: ${contractUpdateResult.errorMessage}`,
            );
            return;
        }

        // Get a string from the result at index 0
        const message2 = contractUpdateResult.getString(0);
        console.log(`contract returned message: ${message2}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/create-topic-with-revenue.js
import { TokenCreateTransaction } from "@hashgraph/sdk";
import { TopicUpdateTransaction } from "@hashgraph/sdk";
import { TransferTransaction } from "@hashgraph/sdk";
import {
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
    AccountCreateTransaction,
    AccountId,
    PrivateKey,
    Client,
    Hbar,
    CustomFixedFee,
    AccountBalanceQuery,
    CustomFeeLimit,
    HbarUnit,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        operatorId,
        operatorKey,
    );

    try {
        /*
         * Step 1:
         * Create account - alice
         */
        console.log("Creating account - alice");

        const aliceKey = PrivateKey.generateECDSA();

        const { accountId: aliceAccountId } = await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(aliceKey)
                .setInitialBalance(new Hbar(5))
                .setMaxAutomaticTokenAssociations(100)
                .execute(client)
        ).getReceipt(client);

        console.log(`Alice's account ID: ${aliceAccountId.toString()}`);

        /*
         * Step 2:
         * Create a topic with hbar custom fee
         */

        console.log("Create a topic with hbar custom fee");

        const customFee = new CustomFixedFee()
            .setAmount(new Hbar(1).toTinybars())
            .setFeeCollectorAccountId(operatorId);

        const { topicId } = await (
            await new TopicCreateTransaction()
                .setAdminKey(operatorKey)
                .setFeeScheduleKey(operatorKey)
                .setCustomFees([customFee])
                .execute(client)
        ).getReceipt(client);

        console.log(`Created a topic with id: ${topicId.toString()}`);

        /*
         * Step 3:
         * Submit a message to that topic, paid for by alice, specifying max custom fee amount bigger than the topic’s amount.
         */

        let aliceBalanceBefore = await new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        let feeCollectorBalanceBefore = await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .execute(client);

        console.log("Submitting a message as alice to the topic");

        const customFeeLimit = new CustomFeeLimit()
            .setAccountId(aliceAccountId)
            .setFees([
                new CustomFixedFee().setAmount(
                    Hbar.from(2, HbarUnit.Hbar).toTinybars(),
                ),
            ]);

        client.setOperator(aliceAccountId, aliceKey);

        await (
            await new TopicMessageSubmitTransaction()
                .setCustomFeeLimits([customFeeLimit])
                .setTopicId(topicId)
                .setMessage("Hello, Hedera™ hashgraph!")
                .execute(client)
        ).getReceipt(client);

        console.log("Message submitted successfully");

        /*
         * Step 4:
         * Verify alice was debited the fee amount and the fee collector account was credited the amount.
         */

        client.setOperator(operatorId, operatorKey);

        let aliceBalanceAfter = await new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        let feeCollectorBalanceAfter = await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .execute(client);

        console.log(
            `Alice's balance before: ${aliceBalanceBefore.hbars.toString()} and after: ${aliceBalanceAfter.hbars.toString()}`,
        );

        console.log(
            `Fee collector's balance before: ${feeCollectorBalanceBefore.hbars.toString()} and after: ${feeCollectorBalanceAfter.hbars.toString()}`,
        );

        /*
         * Step 5:
         * Create a fungible token and transfer some tokens to alice
         */

        console.log("Create a token");

        const { tokenId } = await (
            await new TokenCreateTransaction()
                .setTokenName("revenue-generating token")
                .setTokenSymbol("RGT")
                .setTreasuryAccountId(client.operatorAccountId)
                .setDecimals(8)
                .setInitialSupply(100)
                .execute(client)
        ).getReceipt(client);
        // transfer token to alice
        console.log("Transferring the token to alice");

        await (
            await new TransferTransaction()
                .addTokenTransfer(tokenId, client.operatorAccountId, -1)
                .addTokenTransfer(tokenId, aliceAccountId, 1)
                .execute(client)
        ).getReceipt(client);

        /*
         * Step 6:
         * Update the topic to have a fee of the token.
         */
        console.log("Updating the topic to have a custom fee of the token");

        const customFeeToken = new CustomFixedFee()
            .setAmount(1)
            .setFeeCollectorAccountId(operatorId)
            .setDenominatingTokenId(tokenId);

        await (
            await new TopicUpdateTransaction()
                .setTopicId(topicId)
                .setCustomFees([customFeeToken])
                .execute(client)
        ).getReceipt(client);

        /*
         * Step 7:
         * Submit another message to that topic, paid by alice, without specifying max custom fee amount.
         */

        aliceBalanceBefore = await new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        feeCollectorBalanceBefore = await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .execute(client);

        console.log("Submitting a message as alice to the topic");
        client.setOperator(aliceAccountId, aliceKey);

        await (
            await new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage("Μαματα ςι ε εδαλο")
                .execute(client)
        ).getReceipt(client);

        console.log("Message submitted successfully");
        client.setOperator(operatorId, operatorKey);
        /*
         * Step 8:
         * Verify alice was debited the new fee amount and the fee collector account was credited the amount.
         */

        aliceBalanceAfter = await new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        feeCollectorBalanceAfter = await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .execute(client);

        console.log(
            `Alice's hbars balance before: ${aliceBalanceBefore.hbars.toString()} and after: ${aliceBalanceAfter.hbars.toString()}`,
        );

        console.log(
            `Fee collector's hbars balance before: ${feeCollectorBalanceBefore.hbars.toString()} and after: ${feeCollectorBalanceAfter.hbars.toString()}`,
        );

        console.log(
            `Alice's token balance before: ${aliceBalanceBefore.tokens
                .get(tokenId)
                .toString()} and after: ${aliceBalanceAfter.tokens.get(tokenId).toString()}`,
        );

        console.log(
            `Fee collector's token balance before: ${feeCollectorBalanceBefore.tokens
                .get(tokenId)
                .toString()} and after: ${feeCollectorBalanceAfter.tokens.get(tokenId).toString()}`,
        );

        /*
         * Step 9:
         * Create account - bob
         */

        console.log("Creating account - bob");

        const bobKey = PrivateKey.generateECDSA();

        const { accountId: bobAccountId } = await (
            await new AccountCreateTransaction()
                .setMaxAutomaticTokenAssociations(-1)
                .setKeyWithoutAlias(bobKey)
                .setInitialBalance(new Hbar(10))
                .setMaxAutomaticTokenAssociations(100)

                .execute(client)
        ).getReceipt(client);

        console.log(`Bob's account ID: ${bobAccountId.toString()}`);

        /*
         * Step 10:
         * Update the topic’s fee exempt keys and add bob’s public key.
         */

        console.log("Updating the topic to have bob as a fee exempt key");

        await (
            await new TopicUpdateTransaction()
                .setTopicId(topicId)
                .addFeeExemptKey(bobKey)
                .execute(client)
        ).getReceipt(client);

        /*
         * Step 11:
         * Submit another message to that topic, paid with bob, without specifying max custom fee amount.
         */

        const bobBalanceBefore = await new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client);

        client.setOperator(bobAccountId, bobKey);

        console.log("Submitting a message as bob to the topic");

        await (
            await new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage("Hello, Hedera™ hashgraph!")
                .execute(client)
        ).getReceipt(client);

        console.log("Message submitted successfully");

        client.setOperator(operatorId, operatorKey);

        /*
         * Step 12:
         * Verify bob was not debited the fee amount.
         */
        const bobBalanceAfter = await new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client);

        console.log(
            `Bob's hbars balance before: ${bobBalanceBefore.hbars.toString()} and after: ${bobBalanceAfter.hbars.toString()}`,
        );
    } catch (error) {
        console.error(error);
    } finally {
        client.close();
    }
}

void main();
// Filename: examples/create-topic.js
import {
    Wallet,
    LocalProvider,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        // create topic
        let transaction = await new TopicCreateTransaction().freezeWithSigner(
            wallet,
        );
        transaction = await transaction.signWithSigner(wallet);
        const createResponse = await transaction.executeWithSigner(wallet);
        const createReceipt = await createResponse.getReceiptWithSigner(wallet);

        console.log(`topic id = ${createReceipt.topicId.toString()}`);

        // send one message
        let topicMessageSubmitTransaction =
            await new TopicMessageSubmitTransaction({
                topicId: createReceipt.topicId,
                message: "Hello World",
            }).freezeWithSigner(wallet);
        topicMessageSubmitTransaction =
            await topicMessageSubmitTransaction.signWithSigner(wallet);
        const sendResponse =
            await topicMessageSubmitTransaction.executeWithSigner(wallet);

        const sendReceipt = await sendResponse.getReceiptWithSigner(wallet);

        console.log(
            `topic sequence number = ${sendReceipt.topicSequenceNumber.toString()}`,
        );
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/create-update-delete-node.js
import {
    Client,
    PrivateKey,
    AccountId,
    NodeCreateTransaction,
    NodeUpdateTransaction,
    NodeDeleteTransaction,
    ServiceEndpoint,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const network = process.env.HEDERA_NETWORK;
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Transaction parameters
    const accountId = AccountId.fromString("0.0.999");
    const description = "This is a description of the node.";
    const newDescription = "This is new a description of the node.";
    const ipAddressV4 = Uint8Array.of(127, 0, 0, 1);
    const port = 50211;
    const gossipEndpoint = new ServiceEndpoint()
        .setIpAddressV4(ipAddressV4)
        .setPort(port);
    const gossipEndpoints = [gossipEndpoint];
    const serviceEndpoint = new ServiceEndpoint()
        .setIpAddressV4(ipAddressV4)
        .setPort(port);
    const serviceEndpoints = [serviceEndpoint];
    const gossipCaCertificate = new Uint8Array();
    const certificateHash = new Uint8Array();
    const adminKey = PrivateKey.generate();

    // 1. Create a new node
    console.log("Creating a new node...");
    const createTransaction = new NodeCreateTransaction()
        .setAccountId(accountId)
        .setDescription(description)
        .setGossipEndpoints(gossipEndpoints)
        .setServiceEndpoints(serviceEndpoints)
        .setGossipCaCertificate(gossipCaCertificate)
        .setCertificateHash(certificateHash)
        .setAdminKey(adminKey);
    const createTransactionResponse = await createTransaction.execute(client);
    const createTransactionReceipt =
        await createTransactionResponse.getReceipt(client);
    const nodeId = createTransactionReceipt.nodeId;
    console.log(
        `Node create transaction status: ${createTransactionReceipt.status.toString()}`,
    );
    console.log(
        `Node has been created successfully with node id: ${nodeId.toString()}`,
    );

    // 2. Update the node
    console.log("Updating the node...");
    const updateTransaction = new NodeUpdateTransaction()
        .setNodeId(nodeId)
        .setDescription(newDescription);
    const updateTrasnactionResponse = await updateTransaction.execute(client);
    const updateTrasnactionReceipt =
        await updateTrasnactionResponse.getReceipt(client);
    console.log(
        `Node update transaction status: ${updateTrasnactionReceipt.status.toString()}`,
    );

    // 3. Delete the node
    console.log("Deleting the node...");
    const deleteTransaction = new NodeDeleteTransaction().setNodeId(nodeId);
    const deleteTransactionResponse = await deleteTransaction.execute(client);
    const deleteTransactionReceipt =
        await deleteTransactionResponse.getReceipt(client);
    console.log(
        `Node delete transaction status: ${deleteTransactionReceipt.status.toString()}`,
    );

    client.close();
}

void main();
// Filename: examples/custom-grpc-web-proxies-network/src/App.js
import { useEffect } from "react";

import {
    AccountId,
    PrivateKey,
    Client,
    Hbar,
    TransferTransaction,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";

function App() {
    const transferTransaction = async () => {
        /**
         * 1. Setup operatorId and operatorKey
         */
        const operatorId = AccountId.fromString(
            process.env.REACT_APP_OPERATOR_ID,
        );
        const operatorKey = PrivateKey.fromStringECDSA(
            process.env.REACT_APP_OPERATOR_KEY,
        );

        /**
         * 2. Create a custom network with GRPC web proxies
         */
        const nodes = {
            "https://testnet-node02-00-grpc.hedera.com:443": new AccountId(5),
            "https://testnet-node03-00-grpc.hedera.com:443": new AccountId(6),
            "https://testnet-node04-00-grpc.hedera.com:443": new AccountId(7),
        };

        /**
         * 3. Setup the client using "Client"
         */
        const client = Client.forNetwork(nodes);

        client.setOperator(operatorId, operatorKey);
        const debugLogger = new Logger(LogLevel.Debug);
        client.setLogger(debugLogger);

        const newAccountId = new AccountId(2672318);

        /**
         * 4. Execute transfer transaction
         */
        await new TransferTransaction()
            .addHbarTransfer(operatorId, Hbar.fromTinybars(-1)) // Sending account
            .addHbarTransfer(newAccountId, Hbar.fromTinybars(1)) //Receiving account
            .execute(client);
    };

    useEffect(() => {
        // triggers the transaction when the page is loaded
        transferTransaction();
    }, []);

    return (
        <div className="App">
            <h1>Custom gRPC web proxies network example</h1>
            <p>Check the console for the transaction details.</p>
        </div>
    );
}

export default App;
// Filename: examples/custom-grpc-web-proxies-network/src/index.js
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
// Filename: examples/delete-account.js
import {
    Wallet,
    LocalProvider,
    PrivateKey,
    AccountCreateTransaction,
    AccountDeleteTransaction,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const newKey = PrivateKey.generate();

    console.log(`private key = ${newKey.toString()}`);
    console.log(`public key = ${newKey.publicKey.toString()}`);

    try {
        let transaction = await new AccountCreateTransaction()
            .setInitialBalance(new Hbar(10)) // 10 h
            .setKeyWithoutAlias(newKey.publicKey)
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const response = await transaction.executeWithSigner(wallet);

        const receipt = await response.getReceiptWithSigner(wallet);

        console.log(`created account id = ${receipt.accountId.toString()}`);

        let accountDeleteTransaction = await new AccountDeleteTransaction()
            .setNodeAccountIds([response.nodeId])
            .setAccountId(receipt.accountId)
            .setTransferAccountId(wallet.getAccountId())
            .freezeWithSigner(wallet);
        accountDeleteTransaction =
            await accountDeleteTransaction.signWithSigner(wallet);

        newKey.signTransaction(accountDeleteTransaction);

        await accountDeleteTransaction.executeWithSigner(wallet);

        console.log(`deleted account id = ${receipt.accountId.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/exempt-custom-fees.js
import {
    AccountId,
    PrivateKey,
    TokenCreateTransaction,
    TokenType,
    TransferTransaction,
    CustomFractionalFee,
    Hbar,
    AccountCreateTransaction,
    LocalProvider,
    Wallet,
} from "@hashgraph/sdk";
import axios from "axios";

import dotenv from "dotenv";

dotenv.config();

/*
Example for HIP-573: Blanket exemptions for custom fee collectors

1. Create accounts A, B, and C
2. Create a fungible token that has three fractional fees
Fee #1 sends 1/100 of the transferred value to collector 0.0.A.
Fee #2 sends 2/100 of the transferred value to collector 0.0.B.
Fee #3 sends 3/100 of the transferred value to collector 0.0.C.
3. Collector 0.0.B sends 10_000 units of the token to 0.0.A.
4. Get the transaction fee for that transfer transaction
5. Show that the fee collector accounts in the custom fee list of the token
that was created was not charged a custom fee in the transfer

*/

async function main() {
    // If we weren't able to get them, we should throw a new error
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }
    // Configure accounts and client, and generate needed keys
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const provider = new LocalProvider();

    const wallet = new Wallet(operatorId, operatorKey, provider);

    /**
     *     Example 1
     *
     * Step 1
     *
     * Create accounts A, B, and C
     */

    let firstAccountPrivateKey = PrivateKey.generateED25519();
    let firstAccountPublicKey = firstAccountPrivateKey.publicKey;

    let createAccountAtx = await new AccountCreateTransaction()
        .setKeyWithoutAlias(firstAccountPublicKey)
        .setInitialBalance(Hbar.fromString("1000"))
        .freezeWithSigner(wallet);
    createAccountAtx = await createAccountAtx.signWithSigner(wallet);

    let firstResponse = await createAccountAtx.executeWithSigner(wallet);
    const firstAccountId = (await firstResponse.getReceiptWithSigner(wallet))
        .accountId;

    const firstAccountWallet = new Wallet(
        firstAccountId,
        firstAccountPrivateKey,
        provider,
    );

    let secondAccountPrivateKey = PrivateKey.generateED25519();
    let secondAccountPublicKey = secondAccountPrivateKey.publicKey;

    let createAccountBtx = await new AccountCreateTransaction()
        .setKeyWithoutAlias(secondAccountPublicKey)
        .setInitialBalance(Hbar.fromString("1000"))
        .freezeWithSigner(wallet);
    createAccountBtx = await createAccountBtx.signWithSigner(wallet);

    let secondResponse = await createAccountBtx.executeWithSigner(wallet);
    const secondAccountId = (await secondResponse.getReceiptWithSigner(wallet))
        .accountId;

    const secondAccountWallet = new Wallet(
        secondAccountId,
        secondAccountPrivateKey,
        provider,
    );

    let thirdAccountPrivateKey = PrivateKey.generateED25519();
    let thirdAccountPublicKey = thirdAccountPrivateKey.publicKey;

    let createAccountCtx = await new AccountCreateTransaction()
        .setKeyWithoutAlias(thirdAccountPublicKey)
        .setInitialBalance(Hbar.fromString("1000"))
        .freezeWithSigner(wallet);
    createAccountCtx = await createAccountCtx.signWithSigner(wallet);

    let thirdResponse = await createAccountCtx.executeWithSigner(wallet);
    const thirdAccountId = (await thirdResponse.getReceiptWithSigner(wallet))
        .accountId;

    const thirdAccountWallet = new Wallet(
        thirdAccountId,
        thirdAccountPrivateKey,
        provider,
    );

    /**
     * Step 2
     *
     * 2. Create a fungible token that has three fractional fees
     * Fee #1 sends 1/100 of the transferred value to collector 0.0.A.
     * Fee #2 sends 2/100 of the transferred value to collector 0.0.B.
     * Fee #3 sends 3/100 of the transferred value to collector 0.0.C.
     */

    const fee = new CustomFractionalFee()
        .setFeeCollectorAccountId(firstAccountWallet.getAccountId())
        .setNumerator(1)
        .setDenominator(100)
        .setAllCollectorsAreExempt(true);

    const fee2 = new CustomFractionalFee()
        .setFeeCollectorAccountId(secondAccountWallet.getAccountId())
        .setNumerator(2)
        .setDenominator(100)
        .setAllCollectorsAreExempt(true);

    const fee3 = new CustomFractionalFee()
        .setFeeCollectorAccountId(thirdAccountWallet.getAccountId())
        .setNumerator(3)
        .setDenominator(100)
        .setAllCollectorsAreExempt(true);

    let tokenCreateTx = await new TokenCreateTransaction()
        .setTokenName("HIP-573 Token")
        .setTokenSymbol("H573")
        .setTokenType(TokenType.FungibleCommon)
        .setTreasuryAccountId(wallet.getAccountId())
        .setAutoRenewAccountId(wallet.getAccountId())
        .setAdminKey(wallet.getAccountKey())
        .setFreezeKey(wallet.getAccountKey())
        .setWipeKey(wallet.getAccountKey())
        .setInitialSupply(100000000) // Total supply = 100000000 / 10 ^ 2
        .setDecimals(2)
        .setCustomFees([fee, fee2, fee3])
        .setMaxTransactionFee(new Hbar(40))
        .freezeWithSigner(wallet);

    // TokenCreateTransaction should be also signed with all of the fee collector wallets
    // in the custom fee list of the token before executing the transaction
    tokenCreateTx = await tokenCreateTx.signWithSigner(wallet);
    tokenCreateTx = await tokenCreateTx.signWithSigner(firstAccountWallet);
    tokenCreateTx = await tokenCreateTx.signWithSigner(secondAccountWallet);
    tokenCreateTx = await tokenCreateTx.signWithSigner(thirdAccountWallet);

    // Submit the transaction to the Hedera network
    let tokenCreateSubmit = await tokenCreateTx.executeWithSigner(wallet);

    // Get transaction receipt information
    let tokenCreateRx = await tokenCreateSubmit.getReceiptWithSigner(wallet);
    let tokenId = tokenCreateRx.tokenId;
    console.log(`Created token with token id: ${tokenId.toString()}`);

    /**
     * Step 3
     *
     * Collector 0.0.B sends 10_000 units of the token to 0.0.A.
     */

    // First we transfer the amount from treasury account to second account
    let treasuryTokenTransferTx = await new TransferTransaction()
        .addTokenTransfer(tokenId, wallet.getAccountId(), -10000)
        .addTokenTransfer(tokenId, secondAccountWallet.getAccountId(), 10000)
        .freezeWithSigner(wallet);

    treasuryTokenTransferTx =
        await treasuryTokenTransferTx.signWithSigner(wallet);

    let treasuryTokenTransferSubmit =
        await treasuryTokenTransferTx.executeWithSigner(wallet);
    let status = (
        await treasuryTokenTransferSubmit.getReceiptWithSigner(wallet)
    ).status.toString();
    console.log(
        `Sending from treasury account to the second account - 'TransferTransaction' status: ${status}`,
    );

    let tokenTransferTx = await new TransferTransaction()
        .addTokenTransfer(tokenId, secondAccountWallet.getAccountId(), -10000)
        .addTokenTransfer(tokenId, firstAccountWallet.getAccountId(), 10000)
        .freezeWithSigner(wallet);

    // Sign the transaction also with the wallet of the sender
    tokenTransferTx = await tokenTransferTx.signWithSigner(wallet);
    tokenTransferTx = await tokenTransferTx.signWithSigner(secondAccountWallet);

    // Submit the transaction to the Hedera network
    let tokenTransferSubmit = await tokenTransferTx.executeWithSigner(wallet);

    /**
     * Step 4
     *
     * Get the transaction fee for that transfer transaction
     */

    // Get transaction record information
    let transactionFee = (await tokenTransferSubmit.getRecordWithSigner(wallet))
        .transactionFee;

    console.log(`Transaction fee: ${transactionFee.toString()}`);

    /**
     * Step 5
     *
     * Show that the fee collector accounts in the custom fee list
     * of the token that was created was not charged a custom fee in the transfer
     */

    // Wait some time for the mirror node to be updated
    await wait(10000);

    /**@type {number} */
    let firstAccountBalanceAfter;
    let link;
    let link2;
    let link3;
    if (
        process.env.HEDERA_NETWORK == "local-node" ||
        process.env.HEDERA_NETWORK == "localhost"
    ) {
        link = `http://127.0.0.1:5551/api/v1/accounts?account.id=${firstAccountId.toString()}`;
    } else {
        link = `https://${
            process.env.HEDERA_NETWORK
        }.mirrornode.hedera.com/api/v1/accounts?account.id=${firstAccountId.toString()}`;
    }

    try {
        /* eslint-disable */
        firstAccountBalanceAfter = (
            await axios.get(link)
        ).data.accounts[0].balance.tokens.find(
            (token) => token.token_id === tokenId.toString(),
        ).balance;
        /* eslint-enable */
    } catch (e) {
        console.log(e);
    }

    /**@type {number} */
    let secondAccountBalanceAfter;

    if (
        process.env.HEDERA_NETWORK == "local-node" ||
        process.env.HEDERA_NETWORK == "localhost"
    ) {
        link2 = `http://127.0.0.1:5551/api/v1/accounts?account.id=${secondAccountId.toString()}`;
    } else {
        link2 = `https://${
            process.env.HEDERA_NETWORK
        }.mirrornode.hedera.com/api/v1/accounts?account.id=${secondAccountId.toString()}`;
    }

    try {
        /* eslint-disable */
        secondAccountBalanceAfter = (
            await axios.get(link2)
        ).data.accounts[0].balance.tokens.find(
            (token) => token.token_id === tokenId.toString(),
        ).balance;
        /* eslint-enable */
    } catch (e) {
        console.log(e);
    }

    /**@type {number} */
    let thirdAccountBalanceAfter;

    if (
        process.env.HEDERA_NETWORK == "local-node" ||
        process.env.HEDERA_NETWORK == "localhost"
    ) {
        link3 = `http://127.0.0.1:5551/api/v1/accounts?account.id=${thirdAccountId.toString()}`;
    } else {
        link3 = `https://${
            process.env.HEDERA_NETWORK
        }.mirrornode.hedera.com/api/v1/accounts?account.id=${thirdAccountId.toString()}`;
    }

    try {
        /* eslint-disable */
        thirdAccountBalanceAfter = (
            await axios.get(link3)
        ).data.accounts[0].balance.tokens.find(
            (token) => token.token_id === tokenId.toString(),
        ).balance;
        /* eslint-enable */
    } catch (e) {
        console.log(e);
    }

    console.log(
        `First account balance after TransferTransaction: ${firstAccountBalanceAfter}`,
    );
    console.log(
        `Second account balance after TransferTransaction: ${secondAccountBalanceAfter}`,
    );
    console.log(
        `Third account balance after TransferTransaction: ${thirdAccountBalanceAfter}`,
    );

    if (
        firstAccountBalanceAfter === 10000 &&
        secondAccountBalanceAfter === 0 &&
        thirdAccountBalanceAfter === 0
    ) {
        console.log(
            `Fee collector accounts were not charged after transfer transaction`,
        );
    }

    provider.close();
}

/**
 * @param {number} timeout
 * @returns {Promise<any>}
 */
function wait(timeout) {
    return new Promise((resolve) => {
        setTimeout(resolve, timeout);
    });
}

void main();
// Filename: examples/file-append-chunked.js
import {
    Wallet,
    LocalProvider,
    FileCreateTransaction,
    FileAppendTransaction,
    FileContentsQuery,
    Hbar,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`;

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        let transaction = await new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents("[e2e::FileCreateTransaction]")
            .setMaxTransactionFee(new Hbar(5))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const resp = await transaction.executeWithSigner(wallet);

        const receipt = await resp.getReceiptWithSigner(wallet);
        const fileId = receipt.fileId;

        console.log(`file ID = ${fileId.toString()}`);

        await (
            await (
                await (
                    await new FileAppendTransaction()
                        .setNodeAccountIds([resp.nodeId])
                        .setFileId(fileId)
                        .setContents(bigContents)
                        .setMaxTransactionFee(new Hbar(5))
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        const contents = await new FileContentsQuery()
            .setFileId(fileId)
            .executeWithSigner(wallet);

        console.log(
            `File content length according to \`FileInfoQuery\`: ${contents.length}`,
        );
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/generate-key.js
import { Mnemonic } from "@hashgraph/sdk";

async function main() {
    try {
        // generate a 24-word mnemonic
        const mnemonic = await Mnemonic.generate();
        console.log(`24 words mnemonic = ${mnemonic.toString()}`);

        const key = await mnemonic.toStandardEd25519PrivateKey("", 0);
        console.log(`private key = ${key.toString()}`);
        console.log(`public key = ${key.publicKey.toString()}`);

        // [...]

        // recover your key from the mnemonic
        // this takes space-separated or comma-separated words
        const recoveredMnemonic = await Mnemonic.fromString(
            mnemonic.toString(),
        );
        const recoveredRootKey =
            await recoveredMnemonic.toStandardEd25519PrivateKey("", 0);

        recoveredRootKey.toString() === key.toString()
            ? console.log(`successful key recovery!`)
            : console.log(`key recovery failed!`);

        const mnemonic12 = await Mnemonic.generate12();
        console.log(`12 words mnemonic = ${mnemonic12.toString()}`);

        const key12 = await mnemonic12.toStandardEd25519PrivateKey("", 0);
        console.log(`private key = ${key12.toString()}`);
        console.log(`public key = ${key12.publicKey.toString()}`);
    } catch (error) {
        console.error(error);
    }
}

void main()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
// Filename: examples/generate-txid-on-demand.js
import {
    AccountId,
    PrivateKey,
    Client,
    Hbar,
    Timestamp,
    TransactionId,
    AccountCreateTransaction,
    TransferTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";
dotenv.config();

/*
Examples that demonstrates the use of generating transaction IDs on demand

## Example 1:
Sometimes, when you are trying to execute transactions `asynchronosly`,
there is a tiny bit of chance to generate the same `transactionId` given the same `accountId`
and the current timestamp.

With the following approach to generate custom `transactionId`, this issue is avoided

### Steps
1. Create an account to whom to send tinybars
2. Make a thousand iterations of transfer transactions with custom generated `transactionId`
3. Await the receipts of every transaction
4. Check if the count of receipts with status `SUCCESS` equals the count of transactions (should be 1000)


## Example 2:
The `TransactionId` object contains the valid start time for the transaction. This means that
by setting the valid start time to a moment in the future, you would be able to execute the transaction
after the set period (in seconds)

1. Create custom `transactionId` with valid start 10 seconds after the current time
2. Wait 15 seconds in order for the transaction to be valid and then submit it
*/

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    let client;

    try {
        // Local node
        client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
            operatorId,
            operatorKey,
        );
    } catch (error) {
        throw new Error(
            "Environment variables HEDERA_NETWORK, OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }

    try {
        /**
         *     Example 1
         *
         * Step 1
         *
         * Create an account to whom to send tinybars
         */
        const newKey = PrivateKey.generate();

        console.log(`New account private key: ${newKey.toString()}`);
        console.log(`New account public key: ${newKey.publicKey.toString()}`);

        const accountCreateTx = await new AccountCreateTransaction()
            .setInitialBalance(new Hbar(10)) // 10 h
            .setKeyWithoutAlias(newKey.publicKey)
            .freezeWith(client)
            .execute(client);

        const newAccountId = (
            await accountCreateTx.getReceipt(client)
        ).accountId.toString();
        console.log(`New account id: ${newAccountId}`);

        /**
         * Step 2
         *
         * Make a thousand iterations of transfer transactions
         * with custom generated `transactionId`
         */
        const transactionsCount = 1000;
        let transactions = [];
        let nanosOffset = 1000000;
        for (let i = 0; i < transactionsCount; i++) {
            const seconds = Math.round(Date.now() / 1000);
            const validStart = new Timestamp(seconds, nanosOffset);
            nanosOffset += 10000;

            const transactionId = TransactionId.withValidStart(
                operatorId,
                validStart,
            );

            const transferHbar = new TransferTransaction()
                .setTransactionId(transactionId)
                .addHbarTransfer(operatorId, Hbar.fromTinybars(-1))
                .addHbarTransfer(newAccountId, Hbar.fromTinybars(1));

            transactions.push(transferHbar.execute(client));
        }
        const responsesResult = await Promise.all(transactions);

        /**
         * Step 3
         *
         * Await the receipts of every transaction
         */
        let count = 0;
        let receipts = [];
        for (let i = 0; i < responsesResult.length; i++) {
            receipts.push(responsesResult[i].getReceipt(client));
        }
        const receiptsResult = await Promise.all(receipts);

        /**
         * Step 4
         *
         * Check if the count of receipts with status `SUCCESS` equals the count of transactions (should be 1000)
         */
        receiptsResult.forEach((receipt) =>
            receipt.status.toString() == "SUCCESS"
                ? count++
                : console.log(`Failed with: ${receipt.status.toString()}`),
        );
        transactionsCount == count
            ? console.log(`All transactions are executed successfully`)
            : console.log(
                  `${transactionsCount - count} unsuccessful transactions`,
              );

        /**
         *     Example 2
         *
         * Step 1
         *
         * Create custom `transactionId` with valid start 10 seconds after the current time
         */
        const nowInSeconds = Math.floor(Date.now() / 1000);
        const secondsDelay = 10;
        const seconds = nowInSeconds + secondsDelay;
        const validStart = new Timestamp(seconds, 0);
        const transactionId = TransactionId.withValidStart(
            operatorId,
            validStart,
        );

        /**
         * Step 2
         *
         * Wait 15 seconds in order for the transaction to be valid and then submit it
         */
        await wait(15000);

        const transferHbar = await new TransferTransaction()
            .setTransactionId(transactionId)
            .addHbarTransfer(operatorId, Hbar.fromTinybars(-1))
            .addHbarTransfer(newAccountId, Hbar.fromTinybars(1))
            .execute(client);

        const status = (
            await transferHbar.getReceipt(client)
        ).status.toString();

        console.log(`STATUS: ${status}`);
    } catch (error) {
        console.log("ERROR", error);
    }

    client.close();
}

/**
 * @param {number} timeout
 * @returns {Promise<any>}
 */
function wait(timeout) {
    return new Promise((resolve) => {
        setTimeout(resolve, timeout);
    });
}

void main();
// Filename: examples/get-account-balance.js
import { Wallet, LocalProvider, AccountBalanceQuery } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        const balance = await new AccountBalanceQuery()
            .setAccountId(wallet.getAccountId())
            .executeWithSigner(wallet);

        console.log(
            `${wallet
                .getAccountId()
                .toString()} balance = ${balance.hbars.toString()}`,
        );
    } catch (error) {
        console.error(Error);
    }

    provider.close();
}

void main();
// Filename: examples/get-account-info.js
import { Wallet, LocalProvider, AccountInfoQuery, Hbar } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        const info = await new AccountInfoQuery()
            .setAccountId(wallet.getAccountId())
            .setQueryPayment(new Hbar(1))
            .executeWithSigner(wallet);

        console.log(
            `info.key                          = ${info.key.toString()}`,
        );

        console.log(
            `info.isReceiverSignatureRequired  =`,
            info.isReceiverSignatureRequired,
        );

        console.log(
            `info.expirationTime               = ${info.expirationTime
                .toDate()
                .toString()}`,
        );
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/get-address-book.js
import { Client, FileId, AddressBookQuery } from "@hashgraph/sdk";

import fs from "node:fs/promises";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (process.env.HEDERA_NETWORK == null) {
        throw new Error("Environment variable HEDERA_NETWORK is required.");
    }

    const client = Client.forName(process.env.HEDERA_NETWORK);

    if (process.env.HEDERA_NETWORK.toLowerCase() === "mainnet") {
        client
            .setMirrorNetwork(["mainnet-public.mirrornode.hedera.com:443"])
            .setTransportSecurity(true);
    }

    const addressBook = await new AddressBookQuery()
        .setFileId(FileId.ADDRESS_BOOK)
        .execute(client);

    console.log(JSON.stringify(addressBook.toJSON(), null, 2));

    await fs.writeFile("address-book.proto.bin", addressBook.toBytes());

    client.close();
}

void main();
// Filename: examples/get-exchangerates.js
import {
    Wallet,
    LocalProvider,
    FileContentsQuery,
    ExchangeRates,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );
    let resp;
    try {
        resp = await new FileContentsQuery()
            .setFileId("0.0.112")
            .executeWithSigner(wallet);
    } catch (error) {
        console.error(error);
    }

    const exchangeRates = ExchangeRates.fromBytes(resp);

    console.log(`Current numerator ${exchangeRates.currentRate.cents}`);
    console.log(`Current denominator ${exchangeRates.currentRate.hbars}`);
    console.log(
        `Current expiration time ${exchangeRates.currentRate.expirationTime.toString()}`,
    );
    console.log(
        `Current Exchange Rate ${exchangeRates.currentRate.exchangeRateInCents}`,
    );

    console.log(`Next numerator ${exchangeRates.nextRate.cents}`);
    console.log(`Next denominator ${exchangeRates.nextRate.hbars}`);
    console.log(
        `Next expiration time ${exchangeRates.nextRate.expirationTime.toString()}`,
    );
    console.log(
        `Next Exchange Rate ${exchangeRates.nextRate.exchangeRateInCents}`,
    );

    provider.close();
}

void main();
// Filename: examples/get-file-contents.js
import {
    PrivateKey,
    FileContentsQuery,
    Hbar,
    FileCreateTransaction,
    FileDeleteTransaction,
    Client,
    AccountId,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

dotenv.config();
/**
 * How to get file contents
 *
 */

async function main() {
    /**
     * Step 0:
     * Create and configure the SDK Client
     */
    if (
        !process.env.OPERATOR_ID ||
        !process.env.OPERATOR_KEY ||
        !process.env.HEDERA_NETWORK
    ) {
        console.error(
            "Environment variables OPERATOR_ID, OPERATOR_KEY, and HEDERA_NETWORK are required.",
        );
        throw new Error("Missing required environment variables.");
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    //  Create the client based on the HEDERA_NETWORK environment variable
    const client = Client.forName(process.env.HEDERA_NETWORK);

    client.setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    /**
     * Step 1: Submit the file create transaction
     */

    // Content to be stored in the file.
    const fileContents = Buffer.from("Hedera is great!", "utf-8");

    try {
        console.log("Creating new file...");

        // Create the transaction
        let transaction = new FileCreateTransaction()
            .setKeys([operatorKey.publicKey])
            .setContents(fileContents)
            .setMaxTransactionFee(new Hbar(2))
            .freezeWith(client);

        transaction = await transaction.sign(operatorKey);

        const response = await transaction.execute(client);

        const receipt = await response.getReceipt(client);

        // Get the file ID
        const newFileId = receipt.fileId;
        console.log(`Created new file with ID: ${newFileId.toString()}`);

        /**
         * Step 2: Get file contents and print them
         */

        const fileContentsQuery = await new FileContentsQuery()
            .setFileId(newFileId)
            .execute(client);

        console.log("File contents: " + fileContentsQuery.toString());

        // Clean up: Delete created file
        const fileDeleteTxResponse = await new FileDeleteTransaction()
            .setFileId(newFileId)
            .execute(client);

        await fileDeleteTxResponse.getReceipt(client);

        console.log("File deleted successfully");
    } catch (error) {
        console.error("Error occurred during file creation:", error);
    } finally {
        client.close();
        console.log("Get File Contents Example Complete!");
    }
}

void main();
// Filename: examples/hts-nftP1-fee-create-mint-burn-associate-transfer.js
import {
    AccountId,
    PrivateKey,
    Client,
    TokenCreateTransaction,
    TokenInfoQuery,
    TokenType,
    CustomRoyaltyFee,
    CustomFixedFee,
    Hbar,
    TokenSupplyType,
    TokenMintTransaction,
    TokenBurnTransaction,
    TransferTransaction,
    AccountBalanceQuery,
    AccountUpdateTransaction,
    TokenAssociateTransaction,
} from "@hashgraph/sdk";

/**
 * @typedef {import("@hashgraph/sdk").TokenInfo} TokenInfo
 * @typedef {import("@hashgraph/sdk").TransactionReceipt} TransactionReceipt
 */

import dotenv from "dotenv";

dotenv.config();

// Configure accounts and client, and generate needed keys
const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
const treasuryId = AccountId.fromString(process.env.TREASURY_ID);
const treasuryKey = PrivateKey.fromStringDer(process.env.TREASURY_KEY);
const aliceId = AccountId.fromString(process.env.ALICE_ID);
const aliceKey = PrivateKey.fromStringDer(process.env.ALICE_KEY);
const bobId = AccountId.fromString(process.env.BOB_ID);
const bobKey = PrivateKey.fromStringDer(process.env.BOB_KEY);
const nodes = {
    "127.0.0.1:50211": new AccountId(3),
};

const client = Client.forNetwork(nodes).setOperator(operatorId, operatorKey);

const supplyKey = PrivateKey.generate();
const adminKey = PrivateKey.generate();
const freezeKey = PrivateKey.generate();
const wipeKey = PrivateKey.generate();

async function main() {
    // DEFINE CUSTOM FEE SCHEDULE
    let nftCustomFee = new CustomRoyaltyFee()
        .setNumerator(5)
        .setDenominator(10)
        .setFeeCollectorAccountId(treasuryId)
        .setFallbackFee(new CustomFixedFee().setHbarAmount(new Hbar(200)));

    // IPFS CONTENT IDENTIFIERS FOR WHICH WE WILL CREATE NFTs
    const CID = [
        "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
        "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
        "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        "Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
        "QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw",
    ];

    try {
        // CREATE NFT WITH CUSTOM FEE
        let nftCreate = await new TokenCreateTransaction()
            .setTokenName("Fall Collection")
            .setTokenSymbol("LEAF")
            .setTokenType(TokenType.NonFungibleUnique)
            .setDecimals(0)
            .setInitialSupply(0)
            .setTreasuryAccountId(treasuryId)
            .setSupplyType(TokenSupplyType.Finite)
            .setMaxSupply(CID.length)
            .setCustomFees([nftCustomFee])
            .setAdminKey(adminKey)
            .setSupplyKey(supplyKey)
            .setFreezeKey(freezeKey)
            .setWipeKey(wipeKey)
            .freezeWith(client)
            .sign(treasuryKey);

        let nftCreateTxSign = await nftCreate.sign(adminKey);
        let nftCreateSubmit = await nftCreateTxSign.execute(client);
        let nftCreateRx = await nftCreateSubmit.getReceipt(client);
        let tokenId = nftCreateRx.tokenId;
        console.log(`Created NFT with Token ID: ${tokenId.toString()} \n`);

        // TOKEN QUERY TO CHECK THAT THE CUSTOM FEE SCHEDULE IS ASSOCIATED WITH NFT
        var tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.table(tokenInfo.customFees[0]);

        // MINT NEW BATCH OF NFTs
        const nftLeaf = [];
        for (var i = 0; i < CID.length; i++) {
            nftLeaf[i] = await tokenMinterFcn(CID[i]);
            console.log(
                `Created NFT ${tokenId.toString()} with serial: ${nftLeaf[
                    i
                ].serials[0].toString()}`,
            );
        }

        // BURN THE LAST NFT IN THE COLLECTION
        let tokenBurnTx = await new TokenBurnTransaction()
            .setTokenId(tokenId)
            .setSerials([CID.length])
            .freezeWith(client)
            .sign(supplyKey);
        let tokenBurnSubmit = await tokenBurnTx.execute(client);
        let tokenBurnRx = await tokenBurnSubmit.getReceipt(client);
        console.log(
            `\nBurn NFT with serial ${
                CID.length
            }: ${tokenBurnRx.status.toString()} \n`,
        );

        tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.log(
            `Current NFT supply: ${tokenInfo.totalSupply.toString()} \n`,
        );

        // AUTO-ASSOCIATION FOR ALICE'S ACCOUNT
        let associateTx = await new AccountUpdateTransaction()
            .setAccountId(aliceId)
            .setMaxAutomaticTokenAssociations(100)
            .freezeWith(client)
            .sign(aliceKey);
        let associateTxSubmit = await associateTx.execute(client);
        let associateRx = await associateTxSubmit.getReceipt(client);
        console.log(
            `Alice NFT Auto-Association: ${associateRx.status.toString()} \n`,
        );

        // MANUAL ASSOCIATION FOR BOB'S ACCOUNT
        let associateBobTx = await new TokenAssociateTransaction()
            .setAccountId(bobId)
            .setTokenIds([tokenId])
            .freezeWith(client)
            .sign(bobKey);
        let associateBobTxSubmit = await associateBobTx.execute(client);
        let associateBobRx = await associateBobTxSubmit.getReceipt(client);
        console.log(
            `Bob NFT Manual Association: ${associateBobRx.status.toString()} \n`,
        );

        // BALANCE CHECK 1
        let oB = await bCheckerFcn(treasuryId);
        let aB = await bCheckerFcn(aliceId);
        let bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // 1st TRANSFER NFT Treasury->Alice
        let tokenTransferTx = await new TransferTransaction()
            .addNftTransfer(tokenId, 2, treasuryId, aliceId)
            .freezeWith(client)
            .sign(treasuryKey);
        let tokenTransferSubmit = await tokenTransferTx.execute(client);
        let tokenTransferRx = await tokenTransferSubmit.getReceipt(client);
        console.log(
            `\n NFT transfer Treasury->Alice status: ${tokenTransferRx.status.toString()} \n`,
        );

        // BALANCE CHECK 2
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // 2nd NFT TRANSFER NFT Alice->Bob
        let tokenTransferTx2 = await new TransferTransaction()
            .addNftTransfer(tokenId, 2, aliceId, bobId)
            .addHbarTransfer(aliceId, 100)
            .addHbarTransfer(bobId, -100)
            .freezeWith(client)
            .sign(aliceKey);
        const tokenTransferTx2Sign = await tokenTransferTx2.sign(bobKey);
        let tokenTransferSubmit2 = await tokenTransferTx2Sign.execute(client);
        let tokenTransferRx2 = await tokenTransferSubmit2.getReceipt(client);
        console.log(
            `\n NFT transfer Alice->Bob status: ${tokenTransferRx2.status.toString()} \n`,
        );

        // BALANCE CHECK 3
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        /**
         * TOKEN MINTER FUNCTION
         * @param {string} CID
         * @returns {Promise<TransactionReceipt>}
         */
        async function tokenMinterFcn(CID) {
            const mintTx = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata([Buffer.from(CID)])
                .freezeWith(client);
            let mintTxSign = await mintTx.sign(supplyKey);
            let mintTxSubmit = await mintTxSign.execute(client);
            return mintTxSubmit.getReceipt(client);
        }

        // BALANCE CHECKER FUNCTION ==========================================
        /**
         * BALANCE CHECKER FUNCTION
         * @param {string | AccountId} id
         * @returns {Promise<Hbar>}
         */
        async function bCheckerFcn(id) {
            const balanceCheckTx = await new AccountBalanceQuery()
                .setAccountId(id)
                .execute(client);
            return balanceCheckTx.hbars;
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/hts-nftP2-kyc-upate-schedule.js
import {
    AccountBalanceQuery,
    AccountId,
    Client,
    CustomFixedFee,
    CustomRoyaltyFee,
    Hbar,
    PrivateKey,
    ScheduleCreateTransaction,
    ScheduleInfoQuery,
    ScheduleSignTransaction,
    TokenAssociateTransaction,
    TokenBurnTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
    TokenInfoQuery,
    TokenMintTransaction,
    TokenSupplyType,
    TokenType,
    TokenUpdateTransaction,
    TransferTransaction,
} from "@hashgraph/sdk";

/**
 * @typedef {import("@hashgraph/sdk").TokenInfo} TokenInfo
 * @typedef {import("@hashgraph/sdk").TransactionReceipt} TransactionReceipt
 */

import dotenv from "dotenv";

dotenv.config();

// Configure accounts and client, and generate needed keys
const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
const treasuryId = AccountId.fromString(process.env.TREASURY_ID);
const treasuryKey = PrivateKey.fromStringDer(process.env.TREASURY_KEY);
const aliceId = AccountId.fromString(process.env.ALICE_ID);
const aliceKey = PrivateKey.fromStringDer(process.env.ALICE_KEY);
const bobId = AccountId.fromString(process.env.BOB_ID);
const bobKey = PrivateKey.fromStringDer(process.env.BOB_KEY);
const nodes = {
    "127.0.0.1:50211": new AccountId(3),
};

const client = Client.forNetwork(nodes).setOperator(operatorId, operatorKey);

const supplyKey = PrivateKey.generate();
const adminKey = PrivateKey.generate();
const kycKey = PrivateKey.generate();
const newKycKey = PrivateKey.generate();
const pauseKey = PrivateKey.generate();
const freezeKey = PrivateKey.generate();
const wipeKey = PrivateKey.generate();

async function main() {
    // DEFINE CUSTOM FEE SCHEDULE
    let nftCustomFee = new CustomRoyaltyFee()
        .setNumerator(5)
        .setDenominator(10)
        .setFeeCollectorAccountId(treasuryId)
        .setFallbackFee(new CustomFixedFee().setHbarAmount(new Hbar(200)));

    // IPFS CONTENT IDENTIFIERS FOR WHICH WE WILL CREATE NFTs
    const CID = [
        "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
        "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
        "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        "Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
        "QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw",
    ];

    try {
        // CREATE NFT WITH CUSTOM FEE
        let nftCreate = await new TokenCreateTransaction()
            .setTokenName("Fall Collection")
            .setTokenSymbol("LEAF")
            .setTokenType(TokenType.NonFungibleUnique)
            .setDecimals(0)
            .setInitialSupply(0)
            .setTreasuryAccountId(treasuryId)
            .setSupplyType(TokenSupplyType.Finite)
            .setMaxSupply(CID.length)
            .setCustomFees([nftCustomFee])
            .setAdminKey(adminKey)
            .setSupplyKey(supplyKey)
            .setKycKey(kycKey)
            .setPauseKey(pauseKey)
            .setFreezeKey(freezeKey)
            .setWipeKey(wipeKey)
            .freezeWith(client)
            .sign(treasuryKey);

        let nftCreateTxSign = await nftCreate.sign(adminKey);
        let nftCreateSubmit = await nftCreateTxSign.execute(client);
        let nftCreateRx = await nftCreateSubmit.getReceipt(client);
        let tokenId = nftCreateRx.tokenId;
        console.log(`Created NFT with Token ID: ${tokenId.toString()} \n`);

        // TOKEN QUERY TO CHECK THAT THE CUSTOM FEE SCHEDULE IS ASSOCIATED WITH NFT
        let tokenInfo = await tQueryFcn();
        console.table(tokenInfo.customFees[0]);

        // MINT NEW BATCH OF NFTs
        const nftLeaf = [];
        for (var i = 0; i < CID.length; i++) {
            nftLeaf[i] = await tokenMinterFcn(CID[i]);
            console.log(
                `Created NFT ${tokenId.toString()} with serial: ${nftLeaf[
                    i
                ].serials[0].toString()}`,
            );
        }

        // BURN THE LAST NFT IN THE COLLECTION
        let tokenBurnTx = await new TokenBurnTransaction()
            .setTokenId(tokenId)
            .setSerials([CID.length])
            .freezeWith(client)
            .sign(supplyKey);
        let tokenBurnSubmit = await tokenBurnTx.execute(client);
        let tokenBurnRx = await tokenBurnSubmit.getReceipt(client);
        console.log(
            `\nBurn NFT with serial ${
                CID.length
            }: ${tokenBurnRx.status.toString()}`,
        );

        tokenInfo = await tQueryFcn();
        console.log(`Current NFT supply: ${tokenInfo.totalSupply.toString()}`);

        // MANUAL ASSOCIATION FOR ALICE'S ACCOUNT
        let associateAliceTx = await new TokenAssociateTransaction()
            .setAccountId(aliceId)
            .setTokenIds([tokenId])
            .freezeWith(client)
            .sign(aliceKey);
        let associateAliceTxSubmit = await associateAliceTx.execute(client);
        let associateAliceRx = await associateAliceTxSubmit.getReceipt(client);
        console.log(
            `\n- Alice NFT manual association: ${associateAliceRx.status.toString()}`,
        );

        // MANUAL ASSOCIATION FOR BOB'S ACCOUNT
        let associateBobTx = await new TokenAssociateTransaction()
            .setAccountId(bobId)
            .setTokenIds([tokenId])
            .freezeWith(client)
            .sign(bobKey);
        let associateBobTxSubmit = await associateBobTx.execute(client);
        let associateBobRx = await associateBobTxSubmit.getReceipt(client);
        console.log(
            `- Bob NFT manual association: ${associateBobRx.status.toString()}`,
        );

        // PART 2.1 STARTS ============================================================
        console.log(
            `\nPART 2.1 STARTS ============================================================\n`,
        );
        // ENABLE TOKEN KYC FOR ALICE AND BOB
        let aliceKyc = await kycEnableFcn(aliceId);
        let bobKyc = await kycEnableFcn(bobId);
        console.log(
            `- Enabling token KYC for Alice's account: ${aliceKyc.status.toString()}`,
        );
        console.log(
            `- Enabling token KYC for Bob's account: ${bobKyc.status.toString()}\n`,
        );

        // QUERY TO CHECK INTIAL KYC KEY
        tokenInfo = await tQueryFcn();
        console.log(
            `- KYC key for the NFT is: \n${tokenInfo.kycKey.toString()} \n`,
        );

        // UPDATE TOKEN PROPERTIES: NEW KYC KEY
        let tokenUpdateTx = await new TokenUpdateTransaction()
            .setTokenId(tokenId)
            .setKycKey(newKycKey)
            .freezeWith(client)
            .sign(adminKey);
        let tokenUpdateSubmitTx = await tokenUpdateTx.execute(client);
        let tokenUpdateRx = await tokenUpdateSubmitTx.getReceipt(client);
        console.log(
            `- Token update transaction (new KYC key): ${tokenUpdateRx.status.toString()} \n`,
        );

        // QUERY TO CHECK CHANGE IN KYC KEY
        tokenInfo = await tQueryFcn();
        console.log(
            `- KYC key for the NFT is: \n${tokenInfo.kycKey.toString()}`,
        );

        // PART 2.1 ENDS ============================================================
        console.log(
            `\nPART 2.1 ENDS ============================================================\n`,
        );

        // BALANCE CHECK 1
        let oB = await bCheckerFcn(treasuryId);
        let aB = await bCheckerFcn(aliceId);
        let bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // 1st TRANSFER NFT TREASURY -> ALICE
        let tokenTransferTx = await new TransferTransaction()
            .addNftTransfer(tokenId, 2, treasuryId, aliceId)
            .freezeWith(client)
            .sign(treasuryKey);
        let tokenTransferSubmit = await tokenTransferTx.execute(client);
        let tokenTransferRx = await tokenTransferSubmit.getReceipt(client);
        console.log(
            `\n NFT transfer Treasury -> Alice status: ${tokenTransferRx.status.toString()} \n`,
        );

        // BALANCE CHECK 2
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // 2nd NFT TRANSFER NFT ALICE -> BOB
        let tokenTransferTx2 = await new TransferTransaction()
            .addNftTransfer(tokenId, 2, aliceId, bobId)
            .addHbarTransfer(aliceId, 100)
            .addHbarTransfer(bobId, -100)
            .freezeWith(client)
            .sign(aliceKey);
        const tokenTransferTx2Sign = await tokenTransferTx2.sign(bobKey);
        let tokenTransferSubmit2 = await tokenTransferTx2Sign.execute(client);
        let tokenTransferRx2 = await tokenTransferSubmit2.getReceipt(client);
        console.log(
            `\n NFT transfer Alice -> Bob status: ${tokenTransferRx2.status.toString()} \n`,
        );

        // BALANCE CHECK 3
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // PART 2.2 STARTS ============================================================
        console.log(
            `\nPART 2.2 STARTS ============================================================\n`,
        );

        // CREATE THE NFT TRANSFER FROM BOB->ALICE TO BE SCHEDULED
        // REQUIRES ALICE'S AND BOB'S SIGNATURES
        let txToSchedule = new TransferTransaction()
            .addNftTransfer(tokenId, 2, bobId, aliceId)
            .addHbarTransfer(aliceId, -200)
            .addHbarTransfer(bobId, 200);

        // SCHEDULE THE NFT TRANSFER TRANSACTION CREATED IN THE LAST STEP
        let scheduleTx = await new ScheduleCreateTransaction()
            .setScheduledTransaction(txToSchedule)
            .execute(client);
        let scheduleRx = await scheduleTx.getReceipt(client);
        let scheduleId = scheduleRx.scheduleId;
        let scheduledTxId = scheduleRx.scheduledTransactionId;
        console.log(`- The schedule ID is: ${scheduleId.toString()}`);
        console.log(
            `- The scheduled transaction ID is: ${scheduledTxId.toString()} \n`,
        );

        // SUBMIT ALICE'S SIGNATURE FOR THE TRANSFER TRANSACTION
        let aliceSignTx = await new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(aliceKey);
        let aliceSignSubmit = await aliceSignTx.execute(client);
        let aliceSignRx = await aliceSignSubmit.getReceipt(client);
        console.log(
            `- Status of Alice's signature submission: ${aliceSignRx.status.toString()}`,
        );

        // QUERY TO CONFIRM IF THE SCHEDULE WAS TRIGGERED (SIGNATURES HAVE BEEN ADDED)
        let scheduleQuery = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        console.log(
            `- Schedule triggered (all required signatures received): ${(
                scheduleQuery.executed !== null
            ).toString()}`,
        );

        // SUBMIT BOB'S SIGNATURE FOR THE TRANSFER TRANSACTION
        let bobSignTx = await new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(bobKey);
        let bobSignSubmit = await bobSignTx.execute(client);
        let bobSignRx = await bobSignSubmit.getReceipt(client);
        console.log(
            `- Status of Bob's signature submission: ${bobSignRx.status.toString()}`,
        );

        // QUERY TO CONFIRM IF THE SCHEDULE WAS TRIGGERED (SIGNATURES HAVE BEEN ADDED)
        scheduleQuery = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        console.log(
            `- Schedule triggered (all required signatures received): ${(
                scheduleQuery.executed !== null
            ).toString()} \n`,
        );

        // VERIFY THAT THE SCHEDULED TRANSACTION (TOKEN TRANSFER) EXECUTED
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        /**
         * TOKEN MINTER FUNCTION
         * @param {string} CID
         * @returns {Promise<TransactionReceipt>}
         */
        async function tokenMinterFcn(CID) {
            const mintTx = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata([Buffer.from(CID)])
                .freezeWith(client);
            let mintTxSign = await mintTx.sign(supplyKey);
            let mintTxSubmit = await mintTxSign.execute(client);
            return mintTxSubmit.getReceipt(client);
        }

        /**
         * BALANCE CHECKER FUNCTION
         * @param {string | AccountId} id
         * @returns {Promise<Hbar>}
         */
        async function bCheckerFcn(id) {
            const balanceCheckTx = await new AccountBalanceQuery()
                .setAccountId(id)
                .execute(client);
            return balanceCheckTx.hbars;
        }

        /**
         * KYC ENABLE FUNCTION
         * @param {string | AccountId} id
         * @returns {Promise<TransactionReceipt>}
         */
        async function kycEnableFcn(id) {
            let kycEnableTx = await new TokenGrantKycTransaction()
                .setAccountId(id)
                .setTokenId(tokenId)
                .freezeWith(client)
                .sign(kycKey);
            let kycSubmitTx = await kycEnableTx.execute(client);
            return kycSubmitTx.getReceipt(client);
        }

        /**
         * TOKEN QUERY FUNCTION
         * @returns {Promise<TokenInfo>}
         */
        async function tQueryFcn() {
            return new TokenInfoQuery().setTokenId(tokenId).execute(client);
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/hts-nftP3-pause-freeze-wipe-delete.js
import {
    AccountBalanceQuery,
    AccountId,
    Client,
    CustomFixedFee,
    CustomRoyaltyFee,
    Hbar,
    PrivateKey,
    ScheduleCreateTransaction,
    ScheduleInfoQuery,
    ScheduleSignTransaction,
    TokenAssociateTransaction,
    TokenBurnTransaction,
    TokenCreateTransaction,
    TokenDeleteTransaction,
    TokenFreezeTransaction,
    TokenGrantKycTransaction,
    TokenInfoQuery,
    TokenMintTransaction,
    TokenPauseTransaction,
    TokenSupplyType,
    TokenType,
    TokenUnfreezeTransaction,
    TokenUnpauseTransaction,
    TokenUpdateTransaction,
    TokenWipeTransaction,
    TransferTransaction,
} from "@hashgraph/sdk";

/**
 * @typedef {import("@hashgraph/sdk").TokenInfo} TokenInfo
 * @typedef {import("@hashgraph/sdk").TransactionReceipt} TransactionReceipt
 */

import dotenv from "dotenv";

dotenv.config();

// Configure accounts and client, and generate needed keys
const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
const treasuryId = AccountId.fromString(process.env.TREASURY_ID);
const treasuryKey = PrivateKey.fromStringDer(process.env.TREASURY_KEY);
const aliceId = AccountId.fromString(process.env.ALICE_ID);
const aliceKey = PrivateKey.fromStringDer(process.env.ALICE_KEY);
const bobId = AccountId.fromString(process.env.BOB_ID);
const bobKey = PrivateKey.fromStringDer(process.env.BOB_KEY);
const nodes = {
    "127.0.0.1:50211": new AccountId(3),
};

const client = Client.forNetwork(nodes).setOperator(operatorId, operatorKey);

const supplyKey = PrivateKey.generate();
const adminKey = PrivateKey.generate();
const kycKey = PrivateKey.generate();
const newKycKey = PrivateKey.generate();
const pauseKey = PrivateKey.generate();
const freezeKey = PrivateKey.generate();
const wipeKey = PrivateKey.generate();

async function main() {
    // DEFINE CUSTOM FEE SCHEDULE
    let nftCustomFee = new CustomRoyaltyFee()
        .setNumerator(5)
        .setDenominator(10)
        .setFeeCollectorAccountId(treasuryId)
        .setFallbackFee(new CustomFixedFee().setHbarAmount(new Hbar(200)));

    // IPFS CONTENT IDENTIFIERS FOR WHICH WE WILL CREATE NFTs
    const CID = [
        "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
        "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
        "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        "Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
        "QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw",
    ];

    try {
        // CREATE NFT WITH CUSTOM FEE
        let nftCreate = await new TokenCreateTransaction()
            .setTokenName("Fall Collection")
            .setTokenSymbol("LEAF")
            .setTokenType(TokenType.NonFungibleUnique)
            .setDecimals(0)
            .setInitialSupply(0)
            .setTreasuryAccountId(treasuryId)
            .setSupplyType(TokenSupplyType.Finite)
            .setMaxSupply(CID.length)
            .setCustomFees([nftCustomFee])
            .setAdminKey(adminKey)
            .setSupplyKey(supplyKey)
            .setKycKey(kycKey)
            .setPauseKey(pauseKey)
            .setFreezeKey(freezeKey)
            .setWipeKey(wipeKey)
            .freezeWith(client)
            .sign(treasuryKey);

        let nftCreateTxSign = await nftCreate.sign(adminKey);
        let nftCreateSubmit = await nftCreateTxSign.execute(client);
        let nftCreateRx = await nftCreateSubmit.getReceipt(client);
        let tokenId = nftCreateRx.tokenId;
        console.log(`Created NFT with Token ID: ${tokenId.toString()} \n`);

        // TOKEN QUERY TO CHECK THAT THE CUSTOM FEE SCHEDULE IS ASSOCIATED WITH NFT
        let tokenInfo = await tQueryFcn();
        console.table(tokenInfo.customFees[0]);

        // MINT NEW BATCH OF NFTs
        const nftLeaf = [];
        for (var i = 0; i < CID.length; i++) {
            nftLeaf[i] = await tokenMinterFcn(CID[i]);
            console.log(
                `Created NFT ${tokenId.toString()} with serial: ${nftLeaf[
                    i
                ].serials[0].toString()}`,
            );
        }

        // BURN THE LAST NFT IN THE COLLECTION
        let tokenBurnTx = await new TokenBurnTransaction()
            .setTokenId(tokenId)
            .setSerials([CID.length])
            .freezeWith(client)
            .sign(supplyKey);
        let tokenBurnSubmit = await tokenBurnTx.execute(client);
        let tokenBurnRx = await tokenBurnSubmit.getReceipt(client);
        console.log(
            `\nBurn NFT with serial ${
                CID.length
            }: ${tokenBurnRx.status.toString()}`,
        );

        tokenInfo = await tQueryFcn();
        console.log(`Current NFT supply: ${tokenInfo.totalSupply.toString()}`);

        // MANUAL ASSOCIATION FOR ALICE'S ACCOUNT
        let associateAliceTx = await new TokenAssociateTransaction()
            .setAccountId(aliceId)
            .setTokenIds([tokenId])
            .freezeWith(client)
            .sign(aliceKey);
        let associateAliceTxSubmit = await associateAliceTx.execute(client);
        let associateAliceRx = await associateAliceTxSubmit.getReceipt(client);
        console.log(
            `\n- Alice NFT manual association: ${associateAliceRx.status.toString()}`,
        );

        // MANUAL ASSOCIATION FOR BOB'S ACCOUNT
        let associateBobTx = await new TokenAssociateTransaction()
            .setAccountId(bobId)
            .setTokenIds([tokenId])
            .freezeWith(client)
            .sign(bobKey);
        let associateBobTxSubmit = await associateBobTx.execute(client);
        let associateBobRx = await associateBobTxSubmit.getReceipt(client);
        console.log(
            `- Bob NFT manual association: ${associateBobRx.status.toString()}`,
        );

        // PART 2.1 STARTS ============================================================
        console.log(
            `\nPART 2.1 STARTS ============================================================\n`,
        );
        // ENABLE TOKEN KYC FOR ALICE AND BOB
        let aliceKyc = await kycEnableFcn(aliceId);
        let bobKyc = await kycEnableFcn(bobId);
        console.log(
            `- Enabling token KYC for Alice's account: ${aliceKyc.status.toString()}`,
        );
        console.log(
            `- Enabling token KYC for Bob's account: ${bobKyc.status.toString()}\n`,
        );

        // WE NEED TO COMMENT OUT BECAUSE OF THE CODE ON LINE 226, WE CANNOT TRANSFER TO ALICE WITHOUT KYC ENABLED -> // 1st TRANSFER NFT TREASURY -> ALICE
        // // DISABLE TOKEN KYC FOR ALICE
        // let kycDisableTx = await new TokenRevokeKycTransaction()
        //     .setAccountId(aliceId)
        //     .setTokenId(tokenId)
        //     .freezeWith(client)
        //     .sign(kycKey);
        // let kycDisableSubmitTx = await kycDisableTx.execute(client);
        // let kycDisableRx = await kycDisableSubmitTx.getReceipt(client);
        // console.log(
        //     `- Disabling token KYC for Alice's account: ${kycDisableRx.status.toString()} \n`
        // );

        // QUERY TO CHECK INTIAL KYC KEY
        tokenInfo = await tQueryFcn();
        console.log(
            `- KYC key for the NFT is: \n${tokenInfo.kycKey.toString()} \n`,
        );

        // UPDATE TOKEN PROPERTIES: NEW KYC KEY
        let tokenUpdateTx = await new TokenUpdateTransaction()
            .setTokenId(tokenId)
            .setKycKey(newKycKey)
            .freezeWith(client)
            .sign(adminKey);
        let tokenUpdateSubmitTx = await tokenUpdateTx.execute(client);
        let tokenUpdateRx = await tokenUpdateSubmitTx.getReceipt(client);
        console.log(
            `- Token update transaction (new KYC key): ${tokenUpdateRx.status.toString()} \n`,
        );

        // QUERY TO CHECK CHANGE IN KYC KEY
        tokenInfo = await tQueryFcn();
        console.log(
            `- KYC key for the NFT is: \n${tokenInfo.kycKey.toString()}`,
        );

        // PART 2.1 ENDS ============================================================
        console.log(
            `\nPART 2.1 ENDS ============================================================\n`,
        );

        // BALANCE CHECK 1
        let oB = await bCheckerFcn(treasuryId);
        let aB = await bCheckerFcn(aliceId);
        let bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // 1st TRANSFER NFT TREASURY -> ALICE
        let tokenTransferTx = await new TransferTransaction()
            .addNftTransfer(tokenId, 2, treasuryId, aliceId)
            .freezeWith(client)
            .sign(treasuryKey);
        let tokenTransferSubmit = await tokenTransferTx.execute(client);
        let tokenTransferRx = await tokenTransferSubmit.getReceipt(client);
        console.log(
            `\n NFT transfer Treasury -> Alice status: ${tokenTransferRx.status.toString()} \n`,
        );

        // BALANCE CHECK 2
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // 2nd NFT TRANSFER NFT ALICE -> BOB
        let tokenTransferTx2 = await new TransferTransaction()
            .addNftTransfer(tokenId, 2, aliceId, bobId)
            .addHbarTransfer(aliceId, 100)
            .addHbarTransfer(bobId, -100)
            .freezeWith(client)
            .sign(aliceKey);
        const tokenTransferTx2Sign = await tokenTransferTx2.sign(bobKey);
        let tokenTransferSubmit2 = await tokenTransferTx2Sign.execute(client);
        let tokenTransferRx2 = await tokenTransferSubmit2.getReceipt(client);
        console.log(
            `\n NFT transfer Alice -> Bob status: ${tokenTransferRx2.status.toString()} \n`,
        );

        // BALANCE CHECK 3
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // PART 2.2 STARTS ============================================================
        console.log(
            `\nPART 2.2 STARTS ============================================================\n`,
        );

        // CREATE THE NFT TRANSFER FROM BOB->ALICE TO BE SCHEDULED
        // REQUIRES ALICE'S AND BOB'S SIGNATURES
        let txToSchedule = new TransferTransaction()
            .addNftTransfer(tokenId, 2, bobId, aliceId)
            .addHbarTransfer(aliceId, -200)
            .addHbarTransfer(bobId, 200);

        // SCHEDULE THE NFT TRANSFER TRANSACTION CREATED IN THE LAST STEP
        let scheduleTx = await new ScheduleCreateTransaction()
            .setScheduledTransaction(txToSchedule)
            .execute(client);
        let scheduleRx = await scheduleTx.getReceipt(client);
        let scheduleId = scheduleRx.scheduleId;
        let scheduledTxId = scheduleRx.scheduledTransactionId;
        console.log(`- The schedule ID is: ${scheduleId.toString()}`);
        console.log(
            `- The scheduled transaction ID is: ${scheduledTxId.toString()} \n`,
        );

        // SUBMIT ALICE'S SIGNATURE FOR THE TRANSFER TRANSACTION
        let aliceSignTx = await new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(aliceKey);
        let aliceSignSubmit = await aliceSignTx.execute(client);
        let aliceSignRx = await aliceSignSubmit.getReceipt(client);
        console.log(
            `- Status of Alice's signature submission: ${aliceSignRx.status.toString()}`,
        );

        // QUERY TO CONFIRM IF THE SCHEDULE WAS TRIGGERED (SIGNATURES HAVE BEEN ADDED)
        let scheduleQuery = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        console.log(
            `- Schedule triggered (all required signatures received): ${(
                scheduleQuery.executed !== null
            ).toString()}`,
        );

        // SUBMIT BOB'S SIGNATURE FOR THE TRANSFER TRANSACTION
        let bobSignTx = await new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(bobKey);
        let bobSignSubmit = await bobSignTx.execute(client);
        let bobSignRx = await bobSignSubmit.getReceipt(client);
        console.log(
            `- Status of Bob's signature submission: ${bobSignRx.status.toString()}`,
        );

        // QUERY TO CONFIRM IF THE SCHEDULE WAS TRIGGERED (SIGNATURES HAVE BEEN ADDED)
        scheduleQuery = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        console.log(
            `- Schedule triggered (all required signatures received): ${(
                scheduleQuery.executed !== null
            ).toString()} \n`,
        );

        // VERIFY THAT THE SCHEDULED TRANSACTION (TOKEN TRANSFER) EXECUTED
        oB = await bCheckerFcn(treasuryId);
        aB = await bCheckerFcn(aliceId);
        bB = await bCheckerFcn(bobId);
        console.log(
            `- Treasury balance: ID:${tokenId.toString()} and ${oB.toString()}`,
        );
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );
        console.log(
            `- Bob balance: ID:${tokenId.toString()} and ${bB.toString()}`,
        );

        // PART 3 ============================================================
        console.log(
            `\nPART 3 ============================================================\n`,
        );

        // PAUSE ALL TOKEN OEPRATIONS
        let tokenPauseTx = await new TokenPauseTransaction()
            .setTokenId(tokenId)
            .freezeWith(client)
            .sign(pauseKey);
        let tokenPauseSubmitTx = await tokenPauseTx.execute(client);
        let tokenPauseRx = await tokenPauseSubmitTx.getReceipt(client);
        console.log(`- Token pause: ${tokenPauseRx.status.toString()}`);

        // TEST THE TOKEN PAUSE BY TRYING AN NFT TRANSFER (TREASURY -> ALICE)
        let tokenTransferTx3 = await new TransferTransaction()
            .addNftTransfer(tokenId, 3, treasuryId, aliceId)
            .freezeWith(client)
            .sign(treasuryKey);
        let tokenTransferSubmit3 = await tokenTransferTx3.execute(client);
        try {
            let tokenTransferRx3 =
                await tokenTransferSubmit3.getReceipt(client);
            console.log(
                `\n-NFT transfer Treasury->Alice status: ${tokenTransferRx3.status.toString()} \n`,
            );
        } catch {
            // TOKEN QUERY TO CHECK PAUSE
            tokenInfo = await tQueryFcn();
            console.log(
                `- NFT transfer unsuccessful: Token ${tokenId.toString()} is paused (${tokenInfo.pauseStatus.toString()})`,
            );
        }

        // PAUSE ALL TOKEN OEPRATIONS
        let tokenUnpauseTx = await new TokenUnpauseTransaction()
            .setTokenId(tokenId)
            .freezeWith(client)
            .sign(pauseKey);
        let tokenUnpauseSubmitTx = await tokenUnpauseTx.execute(client);
        let tokenUnpauseRx = await tokenUnpauseSubmitTx.getReceipt(client);
        console.log(`- Token unpause: ${tokenUnpauseRx.status.toString()}\n`);

        // FREEZE ALICE'S ACCOUNT FOR THIS TOKEN
        let tokenFreezeTx = await new TokenFreezeTransaction()
            .setTokenId(tokenId)
            .setAccountId(aliceId)
            .freezeWith(client)
            .sign(freezeKey);
        let tokenFreezeSubmit = await tokenFreezeTx.execute(client);
        let tokenFreezeRx = await tokenFreezeSubmit.getReceipt(client);
        console.log(
            `- Freeze Alice's account for token ${tokenId.toString()}: ${tokenFreezeRx.status.toString()}`,
        );

        // TEST THE TOKEN FREEZE FOR THE ACCOUNT BY TRYING A TRANSFER (ALICE -> BOB)
        try {
            let tokenTransferTx4 = await new TransferTransaction()
                .addNftTransfer(tokenId, 2, aliceId, bobId)
                .addHbarTransfer(aliceId, 100)
                .addHbarTransfer(bobId, -100)
                .freezeWith(client)
                .sign(aliceKey);
            let tokenTransferTx4Sign = await tokenTransferTx4.sign(bobKey);
            let tokenTransferSubmit4 =
                await tokenTransferTx4Sign.execute(client);
            let tokenTransferRx4 =
                await tokenTransferSubmit4.getReceipt(client);
            console.log(
                `\n-NFT transfer Alice->Bob status: ${tokenTransferRx4.status.toString()} \n`,
            );
        } catch {
            console.log(
                `- Operation unsuccessful: The account is frozen for this token`,
            );
        }
        // UNFREEZE ALICE'S ACCOUNT FOR THIS TOKEN
        let tokenUnfreezeTx = await new TokenUnfreezeTransaction()
            .setTokenId(tokenId)
            .setAccountId(aliceId)
            .freezeWith(client)
            .sign(freezeKey);
        let tokenUnfreezeSubmit = await tokenUnfreezeTx.execute(client);
        let tokenUnfreezeRx = await tokenUnfreezeSubmit.getReceipt(client);
        console.log(
            `- Unfreeze Alice's account for token ${tokenId.toString()}: ${tokenUnfreezeRx.status.toString()}\n`,
        );

        // WIPE THE TOKEN FROM ALICE'S ACCOUNT
        let tokenWipeTx = await new TokenWipeTransaction()
            .setAccountId(aliceId)
            .setTokenId(tokenId)
            .setSerials([2])
            .freezeWith(client)
            .sign(wipeKey);
        let tokenWipeSubmitTx = await tokenWipeTx.execute(client);
        let tokenWipeRx = await tokenWipeSubmitTx.getReceipt(client);
        console.log(
            `- Wipe token ${tokenId.toString()} from Alice's account: ${tokenWipeRx.status.toString()}`,
        );

        // CHECK ALICE'S BALANCE
        aB = await bCheckerFcn(aliceId);
        console.log(
            `- Alice balance: ID:${tokenId.toString()} and ${aB.toString()}`,
        );

        // TOKEN QUERY TO CHECK TOTAL TOKEN SUPPLY
        tokenInfo = await tQueryFcn();
        console.log(
            `- Current NFT supply: ${tokenInfo.totalSupply.toString()}`,
        );

        // DELETE THE TOKEN
        let tokenDeleteTx = new TokenDeleteTransaction()
            .setTokenId(tokenId)
            .freezeWith(client);
        let tokenDeleteSign = await tokenDeleteTx.sign(adminKey);
        let tokenDeleteSubmit = await tokenDeleteSign.execute(client);
        let tokenDeleteRx = await tokenDeleteSubmit.getReceipt(client);
        console.log(
            `\n- Delete token ${tokenId.toString()}: ${tokenDeleteRx.status.toString()}`,
        );

        // TOKEN QUERY TO CHECK DELETION
        tokenInfo = await tQueryFcn();
        console.log(
            `- Token ${tokenId.toString()} is deleted: ${tokenInfo.isDeleted.toString()}`,
        );

        /**
         * TOKEN MINTER FUNCTION
         * @param {string} CID
         * @returns {Promise<TransactionReceipt>}
         */
        async function tokenMinterFcn(CID) {
            const mintTx = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata([Buffer.from(CID)])
                .freezeWith(client);
            let mintTxSign = await mintTx.sign(supplyKey);
            let mintTxSubmit = await mintTxSign.execute(client);
            return mintTxSubmit.getReceipt(client);
        }

        /**
         * BALANCE CHECKER FUNCTION
         * @param {string | AccountId} id
         * @returns {Promise<Hbar>}
         */
        async function bCheckerFcn(id) {
            const balanceCheckTx = await new AccountBalanceQuery()
                .setAccountId(id)
                .execute(client);
            return balanceCheckTx.hbars;
        }

        /**
         * KYC ENABLE FUNCTION
         * @param {string | AccountId} id
         * @returns {Promise<TransactionReceipt>}
         */
        async function kycEnableFcn(id) {
            let kycEnableTx = await new TokenGrantKycTransaction()
                .setAccountId(id)
                .setTokenId(tokenId)
                .freezeWith(client)
                .sign(kycKey);
            let kycSubmitTx = await kycEnableTx.execute(client);
            return kycSubmitTx.getReceipt(client);
        }

        /**
         * TOKEN QUERY FUNCTION
         * @returns {Promise<TokenInfo>}
         */
        async function tQueryFcn() {
            return new TokenInfoQuery().setTokenId(tokenId).execute(client);
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/initialize-client-with-mirror-node-adress-book.js
import {
    AccountCreateTransaction,
    Client,
    PrivateKey,
    Hbar,
    AccountId,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

/**
 * @description Initialize a client with only mirror node network address and create account with it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();

    // Ensure that they are testnet variables
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const accountKey = PrivateKey.generate();

    // Initialize the client with the testnet mirror node. This will also get the address book from the mirror node and
    // use it to populate the Client's consensus network.
    const client = (
        await Client.forMirrorNetwork("testnet.mirrornode.hedera.com:443")
    ).setOperator(operatorId, operatorKey);

    try {
        let transaction = new AccountCreateTransaction()
            .setInitialBalance(new Hbar(1))
            .setKeyWithoutAlias(accountKey)
            .freezeWith(client);

        transaction = await transaction.sign(accountKey);

        const response = await transaction.execute(client);

        const receipt = await response.getReceipt(client);

        console.log(`account id = ${receipt.accountId.toString()}`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}
void main();
// Filename: examples/lazy-create-transfer-tx.js
import {
    AccountId,
    PrivateKey,
    Client,
    TransferTransaction,
    AccountInfoQuery,
    TransactionReceiptQuery,
    TopicCreateTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/*
Lazy-create a new account using a public-address via a `TransferTransaction`.

Reference: [HIP-583 Expand alias support in CryptoCreate & CryptoTransfer Transactions](https://hips.hedera.com/hip/hip-583)

## Example 2
- Create an ECSDA private key 
- Extract the ECDSA public key
- Extract the Ethereum public address
  - Add function to calculate the Ethereum Address to in SDK
  - Ethereum account address / public-address - This is the rightmost 20 bytes of the 32 byte Keccak-256 hash of the ECDSA public key of the account. This calculation is in the manner described by the Ethereum Yellow Paper.
- Use the `TransferTransaction` 
   - Populate the `FromAddress` with the sender Hedera AccountID
   - Populate the `ToAddress` with Ethereum public address
   - Note: Can transfer from public address to public address in the `TransferTransaction` for complete accounts. Transfers from hollow accounts will not work because the hollow account does not have a public key assigned to authorize transfers out of the account
- Sign the `TransferTransaction` transaction using an existing Hedera account and key paying for the transaction fee
- The `AccountCreateTransaction` is executed as a child transaction triggered by the `TransferTransaction`
- The Hedera Account that was created has a public address the user specified in the TransferTransaction ToAddress
       - Will not have a public key at this stage
       - Cannot do anything besides receive tokens or hbars
       - The alias property of the account does not have the public address
       - Referred to as a hollow account
- To get the new account ID ask for the child receipts or child records for the parent transaction ID of the `TransferTransaction`
- Get the `AccountInfo` and verify the account is a hollow account with the supplied public address (may need to verify with mirror node API)
- To enhance the hollow account to have a public key the hollow account needs to be specified as a transaction fee payer in a HAPI transaction
- Create a HAPI transaction and assign the new hollow account as the transaction fee payer
- Sign with the private key that corresponds to the public key on the hollow account
- Get the `AccountInfo` for the account and return the public key on the account to show it is a complete account
*/

async function main() {
    if (process.env.OPERATOR_ID == null || process.env.OPERATOR_KEY == null) {
        throw new Error(
            "Environment variables OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const nodes = {
        "127.0.0.1:50211": new AccountId(3),
    };

    const client = Client.forNetwork(nodes).setOperator(
        operatorId,
        operatorKey,
    );

    try {
        /**
         * Step 1
         *
         * Create an ECSDA private key
         */
        const privateKey = PrivateKey.generateECDSA();
        console.log(`Private key: ${privateKey.toStringDer()}`);

        /**
         * Step 2
         *
         * Extract the ECDSA public key
         */
        const publicKey = privateKey.publicKey;
        console.log(`Public key: ${publicKey.toStringDer()}`);

        /**
         *
         * Step 3
         *
         * Extract the Ethereum public address
         */
        const evmAddress = publicKey.toEvmAddress();
        console.log(`Corresponding evm address: ${evmAddress}`);

        /**
         *
         * Step 4
         *
         * Use the `TransferTransaction`
         *   - Populate the `FromAddress` with the sender Hedera AccountID
         *   - Populate the `ToAddress` with Ethereum public address
         */
        const transferTx = new TransferTransaction()
            .addHbarTransfer(operatorId, -10)
            .addHbarTransfer(evmAddress, 10)
            .freezeWith(client);

        /**
         *
         * Step 5
         *
         * Sign the `TransferTransaction` transaction using an existing Hedera account and key paying for the transaction fee
         */
        const transferTxSign = await transferTx.sign(operatorKey);
        const transferTxSubmit = await transferTxSign.execute(client);

        /**
         *
         * Step 6
         *
         * To get the new account ID ask for the child receipts or child records for the parent transaction ID of the `TransferTransaction`
         *     - The `AccountCreateTransaction` is executed as a child transaction triggered by the `TransferTransaction`
         */
        const receipt = await new TransactionReceiptQuery()
            .setTransactionId(transferTxSubmit.transactionId)
            .setIncludeChildren(true)
            .execute(client);

        const newAccountId = receipt.children[0].accountId.toString();
        console.log(`Account ID of the newly created account: ${newAccountId}`);

        /**
         *
         * Step 7
         *
         * Get the `AccountInfo` and verify the account is a hollow account with the supplied public address
         * 
         * The Hedera Account that was created has a public address the user specified in the TransferTransaction ToAddress
       - Will not have a public key at this stage
       - Cannot do anything besides receive tokens or hbars
       - The alias property of the account does not have the public address
       - Referred to as a hollow account
         */
        const hollowAccountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        console.log(`Check if it is a hollow account with 'AccountInfoQuery'`);
        hollowAccountInfo.aliasKey === null &&
        hollowAccountInfo.key._toProtobufKey().keyList.keys.length == 0 &&
        hollowAccountInfo.contractAccountId !== null
            ? console.log(`The newly created account is a hollow account`)
            : console.log(`Not a hollow account`);

        /**
         *
         * Step 8
         *
         * Create a HAPI transaction and assign the new hollow account as the transaction fee payer
         *     - To enhance the hollow account to have a public key the hollow account needs to be specified as a transaction fee payer in a HAPI transaction
         */

        // set the accound id of the hollow account and its private key as an operator
        // in order to be a transaction fee payer in a HAPI transaction
        client.setOperator(newAccountId, privateKey);

        let transaction = new TopicCreateTransaction()
            .setTopicMemo("HIP-583")
            .freezeWith(client);

        /**
         *
         * Step 9
         *
         * Sign with the private key that corresponds to the public key on the hollow account
         */
        const transactionSign = await transaction.sign(privateKey);
        const transactionSubmit = await transactionSign.execute(client);
        const status = (
            await transactionSubmit.getReceipt(client)
        ).status.toString();
        console.log(`HAPI transaction status: ${status}`);

        /**
         *
         * Step 10
         *
         * Get the `AccountInfo` for the account and return the public key on the account to show it is a complete account
         */
        const completeAccountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);
        completeAccountInfo.key !== null
            ? console.log(
                  `The public key of the newly created and now complete account: ${completeAccountInfo.key.toString()}`,
              )
            : console.log(`Account ${newAccountId} is still a hollow account`);
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/local-wallet-info-query.js
import { Wallet, LocalProvider } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        const info = await wallet.getAccountInfo();

        console.log(
            `info.key                          = ${info.key.toString()}`,
        );

        console.log(
            `info.isReceiverSignatureRequired  =`,
            info.isReceiverSignatureRequired,
        );

        console.log(
            `info.expirationTime               = ${info.expirationTime
                .toDate()
                .toString()}`,
        );
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/local-wallet-sign-transaction.js
import { Wallet, LocalProvider, TransferTransaction } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        let transaction = await new TransferTransaction()
            .addHbarTransfer("0.0.3", 1)
            .addHbarTransfer(wallet.getAccountId(), -1)
            .freezeWithSigner(wallet);

        transaction = await transaction.signWithSigner(wallet);
        const response = await transaction.executeWithSigner(wallet);
        const receipt = await wallet.getProvider().waitForReceipt(response);

        console.log(`status: ${receipt.status.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/logger-functionalities.js
import {
    Wallet,
    Client,
    LocalProvider,
    PrivateKey,
    Hbar,
    HbarUnit,
    AccountId,
    TransferTransaction,
    TopicCreateTransaction,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";

import dotenv from "dotenv";
dotenv.config();

/**
 * Main concept notes!
 *
 * If the logger on the request is not set, the logger in client will be applied
 * If the client does not have a previously set logger, there will be no logs
 * (Setting a logger to a transaction will have priority over the logger in the client)
 *
 *
 * If you change/enhance property or functionality of a given logger,
 * this will be applied in every other usage of the same logger
 *
 * A suggestion is to use different logger instance in the client
 * and in each different transaction for best experience
 */

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    let debugLogger = new Logger(LogLevel.Debug);
    let infoLogger = new Logger(LogLevel.Info);

    // Displays the different available log levels
    // namely: trace, debug, info, warn, error, fatal (weighted in that order)
    console.log(`Logger levels: ${JSON.stringify(debugLogger.levels)}`);

    const client = Client.forName(process.env.HEDERA_NETWORK)
        // Set the client's logger to `debugLogger` with debug mode
        .setLogger(debugLogger)
        .setOperator(operatorId, operatorKey);

    const provider = new LocalProvider();

    const wallet = new Wallet(client.operatorAccountId, operatorKey, provider);

    const privateKey = PrivateKey.generateED25519();
    const publicKey = privateKey.publicKey;
    const aliasAccountId = publicKey.toAccountId(0, 0);

    try {
        let transferTransaction = await new TransferTransaction()
            .addHbarTransfer(wallet.accountId, Hbar.from(-10, HbarUnit.Hbar))
            .addHbarTransfer(aliasAccountId, Hbar.from(10, HbarUnit.Hbar))
            .setTransactionMemo("")
            .freezeWithSigner(wallet);

        await transferTransaction.executeWithSigner(wallet);

        let topicTransaction = await new TopicCreateTransaction()
            .setLogger(infoLogger)
            .setTopicMemo("topic memo")
            .freezeWithSigner(wallet);

        await topicTransaction.executeWithSigner(wallet);

        // Set the level of the `infoLogger` from `info` to `warn`
        infoLogger.setLevel(LogLevel.Warn);

        // This should not display any logs because currently there are no `warn` logs predefined in the SDK
        let topicTransaction2 = await new TopicCreateTransaction()
            .setLogger(infoLogger)
            .setTopicMemo("topic memo")
            .freezeWithSigner(wallet);

        await topicTransaction2.executeWithSigner(wallet);

        // Silence the `debugLogger` - no logs should be shown
        // This can also be achieved by calling `.setLevel(LogLevel.Silent)`
        debugLogger.setSilent(true);

        let topicTransaction3 = await new TopicCreateTransaction()
            .setLogger(debugLogger)
            .setTopicMemo("topic memo")
            .freezeWithSigner(wallet);

        await topicTransaction3.executeWithSigner(wallet);

        // Unsilence the `debugLogger` - applies back the old log level before silencing
        debugLogger.setSilent(false);

        let topicTransaction4 = await new TopicCreateTransaction()
            .setLogger(debugLogger)
            .setTopicMemo("topic memo")
            .freezeWithSigner(wallet);

        await topicTransaction4.executeWithSigner(wallet);
    } catch (error) {
        console.error(error);
    }

    provider.close();
    client.close();
}

void main();
// Filename: examples/long-term-schedule-transaction.js
import {
    Client,
    AccountCreateTransaction,
    Hbar,
    PrivateKey,
    KeyList,
    TransferTransaction,
    ScheduleSignTransaction,
    ScheduleInfoQuery,
    AccountBalanceQuery,
    AccountUpdateTransaction,
    Timestamp,
} from "@hashgraph/sdk";

import dotenv from "dotenv";
dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    console.log("Long Term Scheduled Transaction Example Start!");

    // Step 0: Create and configure the SDK Client.
    const operatorId = process.env.OPERATOR_ID;
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const client = Client.forName(process.env.HEDERA_NETWORK || "testnet");
    client.setOperator(operatorId, operatorKey);

    // Step 1: Create key pairs
    const privateKey1 = PrivateKey.generateED25519();
    const privateKey2 = PrivateKey.generateED25519();
    const thresholdKey = new KeyList([
        privateKey1.publicKey,
        privateKey2.publicKey,
    ]);
    console.log("Created a Key List: ", thresholdKey);

    // Step 2: Create the account
    console.log("Creating new account...");
    const aliceId = (
        await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(thresholdKey)
                .setInitialBalance(new Hbar(2))
                .execute(client)
        ).getReceipt(client)
    ).accountId;
    console.log("Created new account with ID: ", aliceId.toString());

    // Step 3: Schedule a transfer transaction
    console.log("Creating new scheduled transaction with 1 day expiry");
    const transfer = new TransferTransaction()
        .addHbarTransfer(aliceId, new Hbar(-1))
        .addHbarTransfer(client.operatorAccountId, new Hbar(1));
    const hasJitter = false;

    const scheduleId = (
        await (
            await transfer
                .schedule()
                .setWaitForExpiry(false)
                .setExpirationTime(
                    Timestamp.generate(hasJitter).plusNanos(
                        86400 * 1_000_000_000,
                    ),
                ) // 1 day in milliseconds
                .execute(client)
        ).getReceipt(client)
    ).scheduleId;

    // Step 4: Sign the transaction with one key
    console.log("Signing the new scheduled transaction with 1 key");
    await (
        await (
            await new ScheduleSignTransaction()
                .setScheduleId(scheduleId)
                .freezeWith(client)
                .sign(privateKey1)
        ).execute(client)
    ).getReceipt(client);

    let info = await new ScheduleInfoQuery()
        .setScheduleId(scheduleId)
        .execute(client);
    let executedAt = info.executed ? info.executed : "none";
    console.log(
        "Scheduled transaction is not yet executed. Executed at: ",
        executedAt,
    );

    // Step 5: Sign the transaction with the other key
    let accountBalance = await new AccountBalanceQuery()
        .setAccountId(aliceId)
        .execute(client);
    console.log(
        "Alice's account balance before schedule transfer: ",
        accountBalance.hbars.toString(),
    );

    console.log("Signing the new scheduled transaction with the 2nd key");
    await (
        await (
            await new ScheduleSignTransaction()
                .setScheduleId(scheduleId)
                .freezeWith(client)
                .sign(privateKey2)
        ).execute(client)
    ).getReceipt(client);

    accountBalance = await new AccountBalanceQuery()
        .setAccountId(aliceId)
        .execute(client);
    console.log(
        "Alice's account balance after schedule transfer: ",
        accountBalance.hbars.toString(),
    );

    info = await new ScheduleInfoQuery()
        .setScheduleId(scheduleId)
        .execute(client);
    console.log(
        "Scheduled transaction is executed. Executed at: ",
        info.executed.toDate(),
    );

    // Step 6: Schedule another transfer transaction
    console.log("Creating new scheduled transaction with 10 seconds expiry");
    const transfer2 = new TransferTransaction()
        .addHbarTransfer(aliceId, new Hbar(-1))
        .addHbarTransfer(client.operatorAccountId, new Hbar(1));

    const scheduleId2 = (
        await (
            await transfer2
                .schedule()
                .setWaitForExpiry(true)
                .setExpirationTime(
                    Timestamp.generate(hasJitter).plusNanos(10 * 1_000_000_000),
                ) // 10 seconds in milliseconds
                .execute(client)
        ).getReceipt(client)
    ).scheduleId;

    // Step 7: Sign the transaction with one key
    console.log("Signing the new scheduled transaction with 1 key");
    await (
        await (
            await new ScheduleSignTransaction()
                .setScheduleId(scheduleId2)
                .freezeWith(client)
                .sign(privateKey1)
        ).execute(client)
    ).getReceipt(client);

    info = await new ScheduleInfoQuery()
        .setScheduleId(scheduleId2)
        .execute(client);
    executedAt = info.executed ? info.executed : "none";
    console.log(
        "Scheduled transaction is not yet executed. Executed at: ",
        executedAt,
    );

    // Step 8: Update the account’s key
    console.log("Updating Alice's key to be the 1st key");
    await (
        await (
            await (
                await new AccountUpdateTransaction()
                    .setAccountId(aliceId)
                    .setKey(privateKey1.publicKey)
                    .freezeWith(client)
                    .sign(privateKey1)
            ).sign(privateKey2)
        ).execute(client)
    ).getReceipt(client);

    // Step 9: Verify that the transfer successfully executes
    accountBalance = await new AccountBalanceQuery()
        .setAccountId(aliceId)
        .execute(client);
    console.log(
        "Alice's account balance before schedule transfer: ",
        accountBalance.hbars.toString(),
    );

    // Wait for the scheduled transaction to execute
    await new Promise((resolve) => setTimeout(resolve, 10000)); // Wait for 10 seconds

    accountBalance = await new AccountBalanceQuery()
        .setAccountId(aliceId)
        .execute(client);
    console.log(
        "Alice's account balance after schedule transfer: ",
        accountBalance.hbars.toString(),
    );

    console.log("Long Term Scheduled Transaction Example Complete!");
    client.close();
}

main().catch(console.error);
// Filename: examples/mint-big-number-of-units-of-token.js
import {
    AccountId,
    Client,
    PrivateKey,
    TokenCreateTransaction,
    TokenType,
    TokenMintTransaction,
    TokenInfoQuery,
    Long,
    Status,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

dotenv.config();

async function main() {
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        operatorId,
        operatorKey,
    );

    let tokenCreate = await new TokenCreateTransaction()
        .setTokenName("Token")
        .setTokenSymbol("T")
        .setTokenType(TokenType.FungibleCommon)
        .setDecimals(8)
        .setTreasuryAccountId(operatorId)
        .setSupplyKey(operatorKey)
        .execute(client);

    let tokenCreateReceipt = await tokenCreate.getReceipt(client);
    const tokenId = tokenCreateReceipt.tokenId;
    console.log(`TokenId is ${tokenId.toString()}.`);

    // If the number of tokens that should be minted is bigger
    // than Number.MAX_SAFE_INTEGER it should be passed as a Long number
    const amount = Long.fromValue("25817858423044461");
    console.log(`Token balance will be set to ${amount.toString()}.`);

    let tokenMint = await new TokenMintTransaction()
        .setTokenId(tokenId)
        .setAmount(amount)
        .execute(client);

    const tokenMintReciept = await tokenMint.getReceipt(client);
    if (tokenMintReciept.status === Status.Success) {
        console.log("Token has been minted!");
    } else {
        console.error("Token mint transaction failed.");
    }

    let tokenInfo = await new TokenInfoQuery()
        .setTokenId(tokenId)
        .execute(client);

    if (tokenInfo) {
        console.log(`Token Balance = ${tokenInfo.totalSupply.toString()}`);
    } else {
        console.error("Token query failed.");
    }

    client.close();
}

void main();
// Filename: examples/mirror-node-contract-queries-example.js
import ABI from "@ethersproject/abi";
import {
    PrivateKey,
    MirrorNodeContractCallQuery,
    MirrorNodeContractEstimateQuery,
    ContractCallQuery,
    Hbar,
    ContractCreateTransaction,
    Client,
    ContractFunctionParameters,
    AccountId,
    FileCreateTransaction,
    Long,
} from "@hashgraph/sdk";
import { setTimeout } from "timers/promises";
import dotenv from "dotenv";

dotenv.config();

const OPERATOR_ID = AccountId.fromString(process.env.OPERATOR_ID);
const OPERATOR_KEY = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
const HEDERA_NETWORK = process.env.HEDERA_NETWORK || "testnet";

async function main() {
    console.log("Mirror Node contract queries Example Start!");

    // Step 0: Create and configure the SDK Client.
    const client = Client.forName(HEDERA_NETWORK);
    client.setOperator(OPERATOR_ID, OPERATOR_KEY);

    const BYTECODE =
        "60806040526040518060400160405280600581526020017f68656c6c6f0000000000000000000000000000000000000000000000000000008152505f90816100479190610293565b50348015610053575f80fd5b50610362565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806100d457607f821691505b6020821081036100e7576100e6610090565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026101497fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261010e565b610153868361010e565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f61019761019261018d8461016b565b610174565b61016b565b9050919050565b5f819050919050565b6101b08361017d565b6101c46101bc8261019e565b84845461011a565b825550505050565b5f90565b6101d86101cc565b6101e38184846101a7565b505050565b5b81811015610206576101fb5f826101d0565b6001810190506101e9565b5050565b601f82111561024b5761021c816100ed565b610225846100ff565b81016020851015610234578190505b610248610240856100ff565b8301826101e8565b50505b505050565b5f82821c905092915050565b5f61026b5f1984600802610250565b1980831691505092915050565b5f610283838361025c565b9150826002028217905092915050565b61029c82610059565b67ffffffffffffffff8111156102b5576102b4610063565b5b6102bf82546100bd565b6102ca82828561020a565b5f60209050601f8311600181146102fb575f84156102e9578287015190505b6102f38582610278565b86555061035a565b601f198416610309866100ed565b5f5b828110156103305784890151825560018201915060208501945060208101905061030b565b8683101561034d5784890151610349601f89168261025c565b8355505b6001600288020188555050505b505050505050565b6102178061036f5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063ce6d41de1461002d575b5f80fd5b61003561004b565b6040516100429190610164565b60405180910390f35b60605f8054610059906101b1565b80601f0160208091040260200160405190810160405280929190818152602001828054610085906101b1565b80156100d05780601f106100a7576101008083540402835291602001916100d0565b820191905f5260205f20905b8154815290600101906020018083116100b357829003601f168201915b5050505050905090565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156101115780820151818401526020810190506100f6565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610136826100da565b61014081856100e4565b93506101508185602086016100f4565b6101598161011c565b840191505092915050565b5f6020820190508181035f83015261017c818461012c565b905092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806101c857607f821691505b6020821081036101db576101da610184565b5b5091905056fea26469706673582212202a86c27939bfab6d4a2c61ebbf096d8424e17e22dfdd42320f6e2654863581e964736f6c634300081a0033";

    // Step 1: Create a new file with the contract bytecode
    const { fileId } = await (
        await new FileCreateTransaction().setContents(BYTECODE).execute(client)
    ).getReceipt(client);

    const { contractId } = await (
        await new ContractCreateTransaction()
            .setBytecodeFileId(fileId)
            .setGas(200000)
            .execute(client)
    ).getReceipt(client);

    console.log("Created new contract with ID: " + contractId.toString());

    // Step 2: Wait for mirror node to import data
    await setTimeout(5000);

    const gasLimit = Long.fromNumber(30000);
    const gasPrice = Long.fromNumber(1234);

    // Step 3: Estimate the gas needed
    const gas = await new MirrorNodeContractEstimateQuery()
        .setContractId(contractId)
        .setSender(client.operatorAccountId)
        .setGasLimit(gasLimit)
        .setGasPrice(gasPrice)
        .setFunction("getMessage", new ContractFunctionParameters())
        .execute(client);

    // Step 4: Do the query against the consensus node using the estimated gas
    const callQuery = new ContractCallQuery()
        .setContractId(contractId)
        .setGas(gas)
        .setFunction("getMessage")
        .setQueryPayment(new Hbar(1));

    const result = await callQuery.execute(client);

    // Step 5: Simulate the transaction for free, using the mirror node
    const simulationResult = await new MirrorNodeContractCallQuery()
        .setContractId(contractId)
        .setSender(client.operatorAccountId)
        .setGasLimit(Long.fromString("30000"))
        .setBlockNumber(Long.fromString("10000"))
        .setGasPrice(Long.fromString("1234"))
        .setFunction("getMessage", new ContractFunctionParameters())
        .execute(client);

    // need to do this to remove the readonly property of the array
    /**
     * @type {string[]}
     */
    const decodedSimulationResult = ABI.defaultAbiCoder
        .decode(["string"], simulationResult)
        .concat();

    /**
     * @type {string}
     */
    const decodedStringMessage = decodedSimulationResult[0];
    console.log("Simulation result: " + decodedStringMessage);
    console.log("Contract call result: " + result.getString(0));

    client.close();
}

void main();
// Filename: examples/multi-node-multi-signature-remove.js
import {
    Client,
    PrivateKey,
    AccountCreateTransaction,
    Hbar,
    AccountId,
    KeyList,
    TransferTransaction,
    Transaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

let aliceKey;
let bobKey;

/**
 * @description Create a transaction with multiple nodes and multiple signatures
 * and remove one of the signatures from the transaction then add it back
 */

async function main() {
    /**
     *
     *  Step 1: Create Client
     *
     */

    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringED25519(process.env.OPERATOR_KEY),
    );

    /**
     *
     * Step 2: Create keys for two users
     *
     */

    aliceKey = PrivateKey.generate();
    bobKey = PrivateKey.generate();

    const keyList = new KeyList([aliceKey.publicKey, bobKey.publicKey]);

    /**
     *
     * Step 3: Create an account with the keyList
     *
     */

    const createAccountTransaction = new AccountCreateTransaction()
        .setInitialBalance(new Hbar(2))
        .setKeyWithoutAlias(keyList);

    const createResponse = await createAccountTransaction.execute(client);
    const createReceipt = await createResponse.getReceipt(client);

    /**
     *
     * Step 4: Create a transfer transaction with multiple nodes
     *
     */

    const transferTransaction = new TransferTransaction()
        .addHbarTransfer(createReceipt.accountId, new Hbar(-1))
        .addHbarTransfer("0.0.3", new Hbar(1))
        // Set multiple nodes
        .setNodeAccountIds([
            new AccountId(3),
            new AccountId(4),
            new AccountId(5),
        ])
        .freezeWith(client);

    /**
     *
     * Step 5:  Serialize the transaction
     *  & Collect multiple signatures (Uint8Array[]) from one key
     *
     */

    const transferTransactionBytes = transferTransaction.toBytes();

    const aliceSignatures = aliceKey.signTransaction(transferTransaction);
    const bobSignatures = bobKey.signTransaction(transferTransaction);

    /**
     *
     * Step 6:  Deserialize the transaction
     *  & Add the previously collected signatures
     *
     */
    const signedTransaction = Transaction.fromBytes(transferTransactionBytes);

    signedTransaction.addSignature(aliceKey.publicKey, aliceSignatures);
    signedTransaction.addSignature(bobKey.publicKey, bobSignatures);

    console.log("ADDED users signatures below: \n");

    if (Array.isArray(aliceSignatures) && Array.isArray(bobSignatures)) {
        console.log(
            "Alice Signatures =>",
            aliceSignatures.map((aliceSig) =>
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                PrivateKey.fromBytes(aliceSig).toStringDer(),
            ),
        );

        console.log(
            "Bob Signatures =>",
            bobSignatures.map((bobSig) =>
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                PrivateKey.fromBytes(bobSig).toStringDer(),
            ),
        );
    }

    const signaturesInTheTransactionBefore =
        getAllSignaturesFromTransaction(signedTransaction);

    console.log("\n\nSignatures in the transaction: ");
    console.log(signaturesInTheTransactionBefore);

    /**
     *
     * Step 7: Remove the signatures for Alice from the transaction
     *
     */
    const removedAliceSignatures = signedTransaction.removeSignature(
        aliceKey.publicKey,
    );

    console.log("\nREMOVED Alice signatures below: \n");

    if (Array.isArray(removedAliceSignatures)) {
        console.log(
            "Alice removed signatures =>",
            removedAliceSignatures.map((aliceSig) =>
                PrivateKey.fromBytes(aliceSig).toStringDer(),
            ),
        );
    }

    const signaturesInTheTransactionAfter =
        getAllSignaturesFromTransaction(signedTransaction);

    console.log("\n\nSignatures left in the transaction: ");
    console.log(signaturesInTheTransactionAfter);

    client.close();
}

void main();

/**
 * Extracts all signatures from a signed transaction.
 * @param {Transaction} signedTransaction - The signed transaction object containing the list of signed transactions.
 * @returns {string[]} An array of signatures in DER format.
 */
const getAllSignaturesFromTransaction = (signedTransaction) => {
    /** @type {string[]} */

    const signatures = [];

    signedTransaction._signedTransactions.list.forEach((transaction) => {
        if (transaction.sigMap?.sigPair) {
            transaction.sigMap.sigPair.forEach((sigPair) => {
                if (sigPair.ed25519) {
                    signatures.push(
                        PrivateKey.fromBytesED25519(
                            sigPair.ed25519,
                        ).toStringDer(),
                    );
                } else if (sigPair.ECDSASecp256k1) {
                    signatures.push(
                        PrivateKey.fromBytesECDSA(
                            sigPair.ECDSASecp256k1,
                        ).toStringDer(),
                    );
                }
            });
        }
    });

    return signatures;
};
// Filename: examples/multi-node-multi-signature-removeAll.js
/* eslint-disable ie11/no-loop-func */
import {
    Client,
    PrivateKey,
    AccountCreateTransaction,
    Hbar,
    AccountId,
    KeyList,
    TransferTransaction,
    Transaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

let aliceKey;
let bobKey;

const NODES = [new AccountId(3), new AccountId(4), new AccountId(5)];
/**
 * @description Create a transaction with multiple nodes and multiple signatures
 * and remove all of the signatures from the transaction
 */
async function main() {
    /**
     *
     *  Step 1: Create Client
     *
     */
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringED25519(process.env.OPERATOR_KEY),
    );

    /**
     *
     * Step 2: Create keys for two users
     *
     */
    aliceKey = PrivateKey.generate();
    bobKey = PrivateKey.generate();

    console.log("Alice public key:", aliceKey.publicKey.toStringDer());
    console.log("Bob public key:", bobKey.publicKey.toStringDer());

    const keyList = new KeyList([aliceKey.publicKey, bobKey.publicKey]);

    /**
     *
     * Step 3: Create an account with the keyList
     *
     */
    const createAccountTransaction = new AccountCreateTransaction()
        .setInitialBalance(new Hbar(2))
        .setKeyWithoutAlias(keyList);

    const createResponse = await createAccountTransaction.execute(client);
    const createReceipt = await createResponse.getReceipt(client);

    /**
     *
     * Step 4: Create a transfer transaction with multiple nodes
     *
     */
    const transferTransaction = new TransferTransaction()
        .addHbarTransfer(createReceipt.accountId, new Hbar(-1))
        .addHbarTransfer("0.0.3", new Hbar(1))
        // Set multiple nodes
        .setNodeAccountIds(NODES)
        .freezeWith(client);

    /**
     *
     * Step 5:  Serialize the transaction
     *  & Collect multiple signatures (Uint8Array[]) from one key
     *
     */
    const transferTransactionBytes = transferTransaction.toBytes();

    const aliceSignatures = aliceKey.signTransaction(transferTransaction);
    const bobSignatures = bobKey.signTransaction(transferTransaction);

    /**
     *
     * Step 6:  Deserialize the transaction
     *  & Add the previously collected signatures
     *
     */
    const signedTransaction = Transaction.fromBytes(transferTransactionBytes);

    signedTransaction.addSignature(aliceKey.publicKey, aliceSignatures);
    signedTransaction.addSignature(bobKey.publicKey, bobSignatures);

    console.log("\nADDED users signatures below: \n");

    if (Array.isArray(aliceSignatures) && Array.isArray(bobSignatures)) {
        /*console.log(
            "Alice Signatures =>",
            aliceSignatures.map((aliceSig) =>
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                PrivateKey.fromBytes(aliceSig).toStringDer(),
            ), 
        );*/
        /*
        console.log(
            "Bob Signatures =>",
            bobSignatures.map((bobSig) =>
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                PrivateKey.fromBytes(bobSig).toStringDer(),
            ),
        );
        */
    }

    const signaturesInTheTransactionBefore =
        getAllSignaturesFromTransaction(signedTransaction);

    console.log("\n\nSignatures in the transaction: ");
    console.log(signaturesInTheTransactionBefore);

    /**
     *
     * Step 7: Remove all signatures from the transaction and add them back
     *
     */
    const allSignaturesRemoved = signedTransaction.removeAllSignatures();

    const signaturesInTheTransactionAfter =
        getAllSignaturesFromTransaction(signedTransaction);

    console.log(
        "\nSignatures left in the transaction:",
        signaturesInTheTransactionAfter,
    );

    for (const [publicKey, signatures] of allSignaturesRemoved) {
        // Show the signatures for each publicKey
        console.log(`\nRemoved signatures for ${publicKey.toStringDer()}:`);
        if (Array.isArray(signatures)) {
            console.log(
                signatures.map((sig) => {
                    return PrivateKey.fromBytes(sig).toStringDer();
                }),
            );
        }
    }

    client.close();
}

void main();

/**
 * Extracts all signatures from a signed transaction.
 * @param {Transaction} signedTransaction - The signed transaction object containing the list of signed transactions.
 * @returns {string[]} An array of signatures in DER format.
 */

const getAllSignaturesFromTransaction = (signedTransaction) => {
    /** @type {string[]} */

    const signatures = [];

    signedTransaction._signedTransactions.list.forEach((transaction) => {
        if (transaction.sigMap?.sigPair) {
            transaction.sigMap.sigPair.forEach((sigPair) => {
                if (sigPair.ed25519) {
                    signatures.push(
                        PrivateKey.fromBytesED25519(
                            sigPair.ed25519,
                        ).toStringDer(),
                    );
                } else if (sigPair.ECDSASecp256k1) {
                    signatures.push(
                        PrivateKey.fromBytesECDSA(
                            sigPair.ECDSASecp256k1,
                        ).toStringDer(),
                    );
                }
            });
        }
    });

    return signatures;
};
// Filename: examples/multi-node-multi-signature.js
import {
    Client,
    PrivateKey,
    AccountCreateTransaction,
    Hbar,
    AccountId,
    KeyList,
    TransferTransaction,
    Transaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/**
 * @description Create a transaction with multiple nodes and multiple signatures
 */
async function main() {
    /**
     *
     *  Step 1: Create Client
     *
     */

    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringED25519(process.env.OPERATOR_KEY),
    );

    /**
     *
     * Step 2: Create keys for two users
     *
     */

    const aliceKey = PrivateKey.generate();
    const bobKey = PrivateKey.generate();

    const keyList = new KeyList([aliceKey.publicKey, bobKey.publicKey]);

    /**
     *
     * Step 3: Create an account with the keyList
     *
     */

    const createAccountTransaction = new AccountCreateTransaction()
        .setInitialBalance(new Hbar(2))
        .setKeyWithoutAlias(keyList);

    const createResponse = await createAccountTransaction.execute(client);
    const createReceipt = await createResponse.getReceipt(client);

    /**
     *
     * Step 4: Create a transfer transaction with multiple nodes
     *
     */
    const transferTransaction = new TransferTransaction()
        .addHbarTransfer(createReceipt.accountId, new Hbar(-1))
        .addHbarTransfer("0.0.3", new Hbar(1))
        // Set multiple nodes
        .setNodeAccountIds([
            new AccountId(3),
            new AccountId(4),
            new AccountId(5),
        ])
        .freezeWith(client);

    /**
     *
     * Step 5:  Serialize the transaction
     *  & Collect multiple signatures (Uint8Array[]) from one key
     *
     */

    const transferTransactionBytes = transferTransaction.toBytes();

    const aliceSignatures = aliceKey.signTransaction(transferTransaction);
    const bobSignatures = bobKey.signTransaction(transferTransaction);

    /**
     *
     * Step 6:  Deserialize the transaction
     *  & Add the previously collected signatures
     *
     */

    const signedTransaction = Transaction.fromBytes(transferTransactionBytes);

    signedTransaction.addSignature(aliceKey.publicKey, aliceSignatures);
    signedTransaction.addSignature(bobKey.publicKey, bobSignatures);

    console.log("ADDED users signatures below: \n");

    const aliceFlatSigs = aliceSignatures.getFlatSignatureList();
    console.log(
        "Alice Signatures =>",
        aliceFlatSigs.map((aliceSig) => {
            const aliceSigBytes = aliceSig.get(aliceKey.publicKey);
            return PrivateKey.fromBytes(aliceSigBytes).toStringDer();
        }),
    );

    const bobFlatSigs = bobSignatures.getFlatSignatureList();
    console.log(
        "Bob Signatures =>",
        bobFlatSigs.map((bobSig) => {
            const bobSigBytes = bobSig.get(bobKey.publicKey);
            return PrivateKey.fromBytes(bobSigBytes).toStringDer();
        }),
    );

    const signaturesInTheTransactionBefore =
        getAllSignaturesFromTransaction(signedTransaction);

    console.log("\n\nSignatures in the transaction: ");
    console.log(signaturesInTheTransactionBefore);

    /**
     *
     * Step 7: Execute and take the receipt
     *
     */

    const result = await signedTransaction.execute(client);

    const receipt = await result.getReceipt(client);

    console.log(`\n  \nTransaction status: ${receipt.status.toString()}`);

    client.close();
}

void main();

/**
 * Extracts all signatures from a signed transaction.
 * @param {Transaction} signedTransaction - The signed transaction object containing the list of signed transactions.
 * @returns {string[]} An array of signatures in DER format.
 */

const getAllSignaturesFromTransaction = (signedTransaction) => {
    /** @type {string[]} */

    const signatures = [];

    signedTransaction._signedTransactions.list.forEach((transaction) => {
        if (transaction.sigMap?.sigPair) {
            transaction.sigMap.sigPair.forEach((sigPair) => {
                if (sigPair.ed25519) {
                    signatures.push(
                        PrivateKey.fromBytesED25519(
                            sigPair.ed25519,
                        ).toStringDer(),
                    );
                } else if (sigPair.ECDSASecp256k1) {
                    signatures.push(
                        PrivateKey.fromBytesECDSA(
                            sigPair.ECDSASecp256k1,
                        ).toStringDer(),
                    );
                }
            });
        }
    });

    return signatures;
};
// Filename: examples/multi-sig-offline.js
import {
    Client,
    PrivateKey,
    AccountCreateTransaction,
    Hbar,
    AccountId,
    KeyList,
    TransferTransaction,
    Transaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/** @type {PrivateKey | undefined} */
let user1Key;

/** @type {PrivateKey | undefined} */
let user2Key;

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringDer(process.env.OPERATOR_KEY),
    );

    user1Key = PrivateKey.generate();
    user2Key = PrivateKey.generate();

    console.log(`private key for user 1= ${user1Key.toString()}`);
    console.log(`public key for user 1= ${user1Key.publicKey.toString()}`);
    console.log(`private key for user 2= ${user2Key.toString()}`);
    console.log(`public key for user 2= ${user2Key.publicKey.toString()}`);

    // create a multi-sig account
    const keyList = new KeyList([user1Key, user2Key]);

    const createAccountTransaction = new AccountCreateTransaction()
        .setInitialBalance(new Hbar(2)) // 5 h
        .setKeyWithoutAlias(keyList);

    const response = await createAccountTransaction.execute(client);

    let receipt = await response.getReceipt(client);

    console.log(`account id = ${receipt.accountId.toString()}`);

    // create a transfer from new account to 0.0.3
    const transferTransaction = new TransferTransaction()
        .setNodeAccountIds([new AccountId(3)])
        .addHbarTransfer(receipt.accountId, -1)
        .addHbarTransfer("0.0.3", 1)
        .freezeWith(client);

    // convert transaction to bytes to send to signatories
    const transactionBytes = transferTransaction.toBytes();
    const transactionToExecute = Transaction.fromBytes(transactionBytes);

    // ask users to sign and return signature
    const user1Signature = user1Key.signTransaction(transferTransaction);
    const user2Signature = user2Key.signTransaction(transferTransaction);

    try {
        // recreate the transaction from bytes
        await transactionToExecute.signWithOperator(client);
        transactionToExecute.addSignature(user1Key.publicKey, user1Signature);
        transactionToExecute.addSignature(user2Key.publicKey, user2Signature);

        const result = await transactionToExecute.execute(client);
        receipt = await result.getReceipt(client);
        console.log(`Status: ${receipt.status.toString()}`);
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/nft-add-remove-allowances.js
import {
    Client,
    PrivateKey,
    AccountId,
    NftId,
    Hbar,
    TransactionId,
    TokenType,
    TokenSupplyType,
    TransferTransaction,
    TokenCreateTransaction,
    TokenMintTransaction,
    TokenAssociateTransaction,
    AccountCreateTransaction,
    AccountAllowanceApproveTransaction,
    AccountAllowanceDeleteTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";
dotenv.config();

/*
Example for HIP-336.

### Show functionalities around approve/delete an allowance for:
1. single NFT serial numbers
2. all serial numbers at once
3. delegating spender obligations

Note that the concept around the ERC standard that Hedera implements in regards
to the allowances for NFTs does not allow users to:

1. approve allowance for all serials in a NFT collection, then remove allowance for individual serial of the NFT
2. approve allowance for individual serial of the NFT, then remove allowance for all serials in the NFT collection

*/

async function main() {
    if (process.env.OPERATOR_ID == null || process.env.OPERATOR_KEY == null) {
        throw new Error(
            "Environment variables OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
    const nodes = {
        "127.0.0.1:50211": new AccountId(3),
    };

    const client = Client.forNetwork(nodes).setOperator(
        operatorId,
        operatorKey,
    );

    try {
        // Example 1
        console.log(
            `\nExample 1: Approve/delete allowances for single serial numbers`,
        );

        const CID = [
            "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
            "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
            "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        ];

        let nftCreateTx = new TokenCreateTransaction()
            .setTokenName("NFT Token")
            .setTokenSymbol("NFTT")
            .setTokenType(TokenType.NonFungibleUnique)
            .setDecimals(0)
            .setInitialSupply(0)
            .setMaxSupply(CID.length)
            .setTreasuryAccountId(operatorId)
            .setSupplyType(TokenSupplyType.Finite)
            .setAdminKey(operatorKey)
            .setSupplyKey(operatorKey)
            .freezeWith(client);

        // Sign the transaction with the operator key
        let nftCreateTxSign = await nftCreateTx.sign(operatorKey);
        // Submit the transaction to the Hedera network
        let nftCreateSubmit = await nftCreateTxSign.execute(client);
        // Get transaction receipt information
        let nftCreateRx = await nftCreateSubmit.getReceipt(client);
        let nftTokenId = nftCreateRx.tokenId;
        console.log(`Created NFT with token id: ${nftTokenId.toString()}`);

        const nftCollection = [];
        for (var i = 0; i < CID.length; i++) {
            nftCollection[i] = await tokenMinterFcn(
                CID[i],
                nftTokenId.toString(),
            );

            console.log(
                `Created NFT ${nftTokenId.toString()} with serial: ${nftCollection[
                    i
                ].serials[0].toString()}`,
            );
        }

        // Create `spender` account
        const spenderKey = PrivateKey.generateECDSA();
        const createSpenderTx = await new AccountCreateTransaction()
            .setKeyWithoutAlias(spenderKey)
            .setInitialBalance(new Hbar(2))
            .execute(client);

        const spenderAccountId = (await createSpenderTx.getReceipt(client))
            .accountId;
        console.log(`spenderAccountId: ${spenderAccountId.toString()}`);

        // Create `receiver` account
        const receiverKey = PrivateKey.generateECDSA();
        const createReceiverTx = await new AccountCreateTransaction()
            .setKeyWithoutAlias(receiverKey)
            .setInitialBalance(new Hbar(2))
            .execute(client);
        const receiverAccountId = (await createReceiverTx.getReceipt(client))
            .accountId;
        console.log(`receiverAccountId: ${receiverAccountId.toString()}`);

        // Associate the `spender` with the NFT
        const spenderAssociateTx = new TokenAssociateTransaction()
            .setAccountId(spenderAccountId)
            .setTokenIds([nftTokenId])
            .freezeWith(client);

        const spenderSignAssociateTx =
            await spenderAssociateTx.sign(spenderKey);
        const spenderExecuteAssociateTx =
            await spenderSignAssociateTx.execute(client);

        const spenderAssociateReceipt =
            await spenderExecuteAssociateTx.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Spender associate TX status: ${spenderAssociateReceipt.status}`,
        );

        // Associate the `receiver` with the NFT
        const receiverAssociateTx = new TokenAssociateTransaction()
            .setAccountId(receiverAccountId)
            .setTokenIds([nftTokenId])
            .freezeWith(client);

        const receiverSignAssociateTx =
            await receiverAssociateTx.sign(receiverKey);
        const receiverExecuteAssociateTx =
            await receiverSignAssociateTx.execute(client);

        const receiverAssociateReceipt =
            await receiverExecuteAssociateTx.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Receiver associate TX status: ${receiverAssociateReceipt.status}`,
        );

        const nft1 = new NftId(nftTokenId, 1);
        const nft2 = new NftId(nftTokenId, 2);

        // Give `spender` allowance for NFT with serial numbers 1 and 2
        const receiverApproveTx = new AccountAllowanceApproveTransaction()
            .approveTokenNftAllowance(nft1, operatorId, spenderAccountId)
            .approveTokenNftAllowance(nft2, operatorId, spenderAccountId);

        const approveRx = await receiverApproveTx.execute(client);
        const approveReceipt = await approveRx.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Approve spender allowance for serials 1 and 2 - status: ${approveReceipt.status}`,
        );

        // Generate TransactionId from spender's account id in order
        // for the transaction to be to be executed on behalf of the spender
        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);

        // Sending NFT with serial number 1
        // `Spender` has an allowance to send, should end up with `SUCCESS`
        const approvedSendTx = new TransferTransaction()
            .addApprovedNftTransfer(nft1, operatorId, receiverAccountId)
            .setTransactionId(onBehalfOfTransactionId)
            .freezeWith(client);

        const approvedSendSigned = await approvedSendTx.sign(spenderKey);
        const approvedSendSubmit = await approvedSendSigned.execute(client);
        const approvedSendRx = await approvedSendSubmit.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Transfer serial 1 on behalf of the spender status: ${approvedSendRx.status}`,
        );

        // Remove `spender's` allowance for serial 2
        const accountDeleteAllowanceTx =
            new AccountAllowanceDeleteTransaction().deleteAllTokenNftAllowances(
                nft2,
                operatorId,
            );
        const deleteTx = await accountDeleteAllowanceTx.execute(client);
        const deleteAllowanceReceipt = await deleteTx.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Remove spender's allowance for serial 2 - status: ${deleteAllowanceReceipt.status}`,
        );

        const onBehalfOfTransactionId2 =
            TransactionId.generate(spenderAccountId);

        // Sending NFT with serial number 2
        // `Spender` does not have an allowance to send serial 2, should end up with `SPENDER_DOES_NOT_HAVE_ALLOWANCE`
        const approvedSendTx2 = new TransferTransaction()
            .addApprovedNftTransfer(nft2, operatorId, receiverAccountId)
            .setTransactionId(onBehalfOfTransactionId2)
            .freezeWith(client);

        const approvedSendSigned2 = await approvedSendTx2.sign(spenderKey);

        try {
            const approvedSendSubmit2 =
                await approvedSendSigned2.execute(client);
            await approvedSendSubmit2.getReceipt(client);
        } catch (error) {
            console.log("The transfer failed as expected.");
            console.log(
                `Transfer serial 2 on behalf of the spender - status: ${
                    /** @type {Error} */ (error).message
                }`,
            );
        }

        // Example 2
        console.log(
            `\nExample 2: Approve/delete allowances for ALL serial numbers at once`,
        );

        const CID2 = [
            "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
            "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
            "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        ];

        let nftCreateTx2 = new TokenCreateTransaction()
            .setTokenName("NFT Token")
            .setTokenSymbol("NFTT")
            .setTokenType(TokenType.NonFungibleUnique)
            .setDecimals(0)
            .setInitialSupply(0)
            .setMaxSupply(CID2.length)
            .setTreasuryAccountId(operatorId)
            .setSupplyType(TokenSupplyType.Finite)
            .setAdminKey(operatorKey)
            .setSupplyKey(operatorKey)
            .freezeWith(client);

        // Sign the transaction with the operator key
        let nftCreateTxSign2 = await nftCreateTx2.sign(operatorKey);
        // Submit the transaction to the Hedera network
        let nftCreateSubmit2 = await nftCreateTxSign2.execute(client);
        // Get transaction receipt information
        let nftCreateRx2 = await nftCreateSubmit2.getReceipt(client);
        let nftTokenId2 = nftCreateRx2.tokenId;
        console.log(`Created NFT with token id: ${nftTokenId2.toString()}`);

        const nftCollection2 = [];
        for (let i = 0; i < CID2.length; i++) {
            nftCollection2[i] = await tokenMinterFcn(
                CID2[i],
                nftTokenId2.toString(),
            );

            console.log(
                `Created NFT ${nftTokenId2.toString()} with serial: ${nftCollection2[
                    i
                ].serials[0].toString()}`,
            );
        }

        // Create `delegating spender` account
        const delegatingSpenderKey = PrivateKey.generateECDSA();
        const createDelegateSpenderTx = await new AccountCreateTransaction()
            .setKeyWithoutAlias(delegatingSpenderKey)
            .setInitialBalance(new Hbar(2))
            .execute(client);

        const delegatingSpenderAccountId = (
            await createDelegateSpenderTx.getReceipt(client)
        ).accountId;
        console.log(
            `delegatingSpenderAccountId: ${delegatingSpenderAccountId.toString()}`,
        );

        // Create `receiver` account
        const receiverKey2 = PrivateKey.generateECDSA();
        const createReceiverTx2 = await new AccountCreateTransaction()
            .setKeyWithoutAlias(receiverKey2)
            .setInitialBalance(new Hbar(2))
            .execute(client);
        const receiverAccountId2 = (await createReceiverTx2.getReceipt(client))
            .accountId;
        console.log(`receiverAccountId2: ${receiverAccountId2.toString()}`);

        // Associate the `delegating spender` with the NFT
        const delegateSpenderAssociateTx = new TokenAssociateTransaction()
            .setAccountId(delegatingSpenderAccountId)
            .setTokenIds([nftTokenId2])
            .freezeWith(client);

        const delegatingSpenderSignAssociateTx =
            await delegateSpenderAssociateTx.sign(delegatingSpenderKey);
        const delegatingSpenderExecuteAssociateTx =
            await delegatingSpenderSignAssociateTx.execute(client);

        const delegatingSpenderAssociateReceipt =
            await delegatingSpenderExecuteAssociateTx.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Spender associate TX status: ${delegatingSpenderAssociateReceipt.status}`,
        );

        // Associate the `receiver` with the NFT
        const receiverAssociateTx2 = new TokenAssociateTransaction()
            .setAccountId(receiverAccountId2)
            .setTokenIds([nftTokenId2])
            .freezeWith(client);

        const receiverSignAssociateTx2 =
            await receiverAssociateTx2.sign(receiverKey2);
        const receiverExecuteAssociateTx2 =
            await receiverSignAssociateTx2.execute(client);

        const receiverAssociateReceipt2 =
            await receiverExecuteAssociateTx2.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Receiver associate TX status: ${receiverAssociateReceipt2.status}`,
        );

        const example2Nft1 = new NftId(nftTokenId2, 1);
        const example2Nft2 = new NftId(nftTokenId2, 2);
        const example2Nft3 = new NftId(nftTokenId2, 3);

        // Give `delegating spender` allowance for all serial numbers of the NFT
        const delegatingSpenderApproveTx =
            new AccountAllowanceApproveTransaction().approveTokenNftAllowanceAllSerials(
                nftTokenId2,
                operatorId,
                delegatingSpenderAccountId,
            );

        const approveRx2 = await delegatingSpenderApproveTx.execute(client);
        const approveReceipt2 = await approveRx2.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Approve spender allowance for all serials - status: ${approveReceipt2.status}`,
        );

        // Create `spender` account
        const spenderKey2 = PrivateKey.generateECDSA();
        const createSpenderTx2 = await new AccountCreateTransaction()
            .setKeyWithoutAlias(spenderKey2)
            .setInitialBalance(new Hbar(2))
            .execute(client);

        const spenderAccountId2 = (await createSpenderTx2.getReceipt(client))
            .accountId;
        console.log(`spenderAccountId2: ${spenderAccountId2.toString()}`);

        // Set the operatorId and operatorKey to the delegating spender data so he can execute on behalf of transfer
        client.setOperator(delegatingSpenderAccountId, delegatingSpenderKey);

        // Give `spenderAccount2` allowance for NFT with serial number 3 on behalf of `delegatingSpender` account which has `approveForAll` rights
        const delegateSpenderAllowance =
            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowanceWithDelegatingSpender(
                    example2Nft3,
                    operatorId,
                    spenderAccountId2,
                    delegatingSpenderAccountId,
                )
                .freezeWith(client);

        const approveDelegateSpender =
            await delegateSpenderAllowance.execute(client);
        const approveDelegateAllowanceReceipt =
            await approveDelegateSpender.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Approve delegated spender allowance for serial 3 - status: ${approveDelegateAllowanceReceipt.status}`,
        );

        // Set the operatorId and operatorKey of the client back to the original ones
        client.setOperator(operatorId, operatorKey);

        // Generate TransactionId from spender's account id in order
        // for the transaction to be to be executed on behalf of the spender
        const delegatedOnBehalfOfTxId =
            TransactionId.generate(spenderAccountId2);

        // Sending NFT with serial number 1
        // `Delegated spender` has an allowance to send serial 3, should end up with `SUCCESS`
        const delegatedSendTx = new TransferTransaction()
            .addApprovedNftTransfer(
                example2Nft3,
                operatorId,
                receiverAccountId2,
            )
            .setTransactionId(delegatedOnBehalfOfTxId)
            .freezeWith(client);

        const delegatedSendSigned = await delegatedSendTx.sign(spenderKey2);
        const delegatedSendSubmit = await delegatedSendSigned.execute(client);
        const delegatedSendRx = await delegatedSendSubmit.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Transfer serial 3 on behalf of the delegated spender status: ${delegatedSendRx.status}`,
        );

        // Generate TransactionId from spender's account id in order
        // for the transaction to be to be executed on behalf of the spender
        const onBehalfOfTransactionId3 = TransactionId.generate(
            delegatingSpenderAccountId,
        );

        // Sending NFT with serial number 1
        // `Spender` has an allowance to send serial 1, should end up with `SUCCESS`
        const approvedSendTx3 = new TransferTransaction()
            .addApprovedNftTransfer(
                example2Nft1,
                operatorId,
                receiverAccountId2,
            )
            .setTransactionId(onBehalfOfTransactionId3)
            .freezeWith(client);

        const approvedSendSigned3 =
            await approvedSendTx3.sign(delegatingSpenderKey);
        const approvedSendSubmit3 = await approvedSendSigned3.execute(client);
        const approvedSendRx3 = await approvedSendSubmit3.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Transfer serial 1 on behalf of the spender status: ${approvedSendRx3.status}`,
        );

        // Remove `delegating spender's` allowance for ALL serials
        const accountDeleteAllowanceTx2 =
            new AccountAllowanceApproveTransaction().deleteTokenNftAllowanceAllSerials(
                nftTokenId2,
                operatorId,
                delegatingSpenderAccountId,
            );

        const deleteTx2 = await accountDeleteAllowanceTx2.execute(client);
        const deleteAllowanceReceipt2 = await deleteTx2.getReceipt(client);
        console.log(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `Remove spender's allowance for ALL serials - status: ${deleteAllowanceReceipt2.status}`,
        );

        // Generate TransactionId from delegating spender's account id in order
        // for the transaction to be to be executed on behalf of the spender
        const onBehalfOfTransactionId4 = TransactionId.generate(
            delegatingSpenderAccountId,
        );

        // Sending NFT with serial number 2
        // `Spender` does not have an allowance to send serial 2, should end up with `SPENDER_DOES_NOT_HAVE_ALLOWANCE`
        const approvedSendTx4 = new TransferTransaction()
            .addApprovedNftTransfer(
                example2Nft2,
                operatorId,
                receiverAccountId2,
            )
            .setTransactionId(onBehalfOfTransactionId4)
            .freezeWith(client);

        const approvedSendSigned4 =
            await approvedSendTx4.sign(delegatingSpenderKey);
        try {
            const approvedSendSubmit4 =
                await approvedSendSigned4.execute(client);
            await approvedSendSubmit4.getReceipt(client);
        } catch (error) {
            console.log("The transfer failed as expected.");
            console.log(
                `Transfer serial 2 on behalf of the spender status: ${
                    /** @type {Error} */ (error).message
                }`,
            );
        }

        /**
         * TOKEN MINTER FUNCTION
         * @param {string} CID
         * @param {string} nftTokenId
         * @returns {Promise<import("./hts-nftP1-fee-create-mint-burn-associate-transfer").TransactionReceipt>}
         */
        async function tokenMinterFcn(CID, nftTokenId) {
            const mintTx = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata([Buffer.from(CID)])
                .freezeWith(client);
            let mintTxSign = await mintTx.sign(operatorKey);
            let mintTxSubmit = await mintTxSign.execute(client);
            return mintTxSubmit.getReceipt(client);
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/prng-transaction.js
import { Wallet, LocalProvider, PrngTransaction } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    try {
        let transaction = await new PrngTransaction()
            .setRange(100)
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const response = await transaction.executeWithSigner(wallet);

        const record = await response.getRecordWithSigner(wallet);
        console.log(`The random number generated is: ${record.prngNumber}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/react-native-example/babel.config.js
module.exports = function (api) {
    api.cache(true);
    return {
        presets: ["babel-preset-expo"],
        plugins: [["module:react-native-dotenv"]],
    };
};
// Filename: examples/run-all-examples.js
import fs from "fs";
import path from "path";
import { spawnSync } from "child_process";
import dotenv from "dotenv";

dotenv.config();

const examplesDirectory = "./";
const excludedDirectories = [
    "./node_modules",
    "./precompile-example",
    "./react-native-example",
    "./simple_rest_signature_provider",
];
const excludedJSFile = [
    "run-all-examples.js",
    "consensus-pub-sub.js",
    "create-update-delete-node.js",
];
const cmd = process.env.NODE_COMMAND;

fs.readdir(examplesDirectory, (err, files) => {
    if (err) {
        console.error("Error reading directory:", err);
        return;
    }

    if (cmd === undefined) {
        throw new Error("Environment variable NODE_COMMAND is required.");
    }

    let completed = 0;
    let failed = 0;

    const isPathStartsWith = (
        /** @type {string} */ file,
        /** @type {string} */ directory,
    ) => path.join(examplesDirectory, file).startsWith(directory);

    const examples = files.filter(
        (file) =>
            file.endsWith(".js") &&
            !excludedJSFile.includes(file) &&
            excludedDirectories.some(
                (directory) => !isPathStartsWith(directory, file),
            ),
    );

    const total = examples.length;

    examples.forEach((file, index) => {
        console.log(`\n⏳ ${index + 1}. Running ${file}...`);
        const examplePath = path.join(examplesDirectory, file);

        const result = spawnSync(cmd, [examplePath], {
            stdio: "ignore",
        });

        if (result.status === 0) {
            completed += 1;
            console.log(`✅ Successfully executed.`);
        } else {
            failed += 1;
            throw new Error("Task failed");
        }
    });

    console.log(
        `\nTotal: [${total}] \n✅ Completed: [${completed}] \n❌ Failed: [${failed}] ${
            failed === 0 ? " \nGreat job! 🎉" : ""
        } `,
    );
});
// Filename: examples/schedule-example.js
import {
    AccountCreateTransaction,
    TransferTransaction,
    ScheduleInfoQuery,
    ScheduleSignTransaction,
    Timestamp,
    KeyList,
    Wallet,
    LocalProvider,
    PrivateKey,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const key1 = PrivateKey.generate();
    const key2 = PrivateKey.generate();

    console.log(`private key 1 = ${key1.toString()}`);
    console.log(`public key 1 = ${key1.publicKey.toString()}`);
    console.log(`private key 2 = ${key2.toString()}`);
    console.log(`public key 2 = ${key2.publicKey.toString()}`);

    try {
        let transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(KeyList.of(key1.publicKey, key2.publicKey))
            .setInitialBalance(20)
            .setStakedAccountId("0.0.3")
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const resp = await transaction.executeWithSigner(wallet);

        const transactionReceipt = await resp.getReceiptWithSigner(wallet);

        // The new account ID
        const newAccountId = transactionReceipt.accountId;

        console.log(`account id = ${newAccountId.toString()}`);

        let transferTransaction = await new TransferTransaction()
            .addHbarTransfer(newAccountId, -1)
            .addHbarTransfer(wallet.getAccountId(), 1)
            .schedule()
            // Set expiration time to be now + 24 hours
            .setExpirationTime(
                Timestamp.generate().plusNanos(24 * 60 * 60 * 1000000000),
            )
            // Set wait for expiry to true
            .setWaitForExpiry(true)
            .freezeWithSigner(wallet);
        transferTransaction = await transferTransaction.signWithSigner(wallet);
        const response = await transferTransaction.executeWithSigner(wallet);

        console.log(
            `scheduled transaction ID = ${response.transactionId.toString()}`,
        );

        const scheduleId = (await response.getReceiptWithSigner(wallet))
            .scheduleId;
        console.log(`schedule ID = ${scheduleId.toString()}`);

        const record = await response.getRecordWithSigner(wallet);
        console.log(`record = ${JSON.stringify(record)}`);

        try {
            await (
                await (
                    await (
                        await (
                            await new ScheduleSignTransaction()
                                .setScheduleId(scheduleId)
                                .freezeWithSigner(wallet)
                        ).sign(key1)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet)
            ).getReceiptWithSigner(wallet);

            const info = await new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .executeWithSigner(wallet);

            console.log(`schedule info = ${JSON.stringify(info)}`);

            await (
                await (
                    await (
                        await (
                            await new ScheduleSignTransaction()
                                .setScheduleId(scheduleId)
                                .freezeWithSigner(wallet)
                        ).sign(key2)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet)
            ).getReceiptWithSigner(wallet);
        } catch (error) {
            console.error(error);
        }

        const transactionId = response.transactionId;
        const validMirrorTransactionId = `${transactionId.accountId.toString()}-${transactionId.validStart.seconds.toString()}-${transactionId.validStart.nanos.toString()}`;

        console.log(
            "The following link should query the mirror node for the scheduled transaction",
        );

        const link = `https://${process.env.HEDERA_NETWORK}.mirrornode.hedera.com/api/v1/transactions/${validMirrorTransactionId}`;

        console.log(link);

        // Seem to be getting 404 at the moment even though the request does go through :/
        // const mirrorNodeResponse = await axios.get(link);
        // console.log(mirrorNodeResponse);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/scheduled-transaction-multi-sig-threshold.js
import {
    Wallet,
    LocalProvider,
    PrivateKey,
    KeyList,
    AccountCreateTransaction,
    Hbar,
    AccountBalanceQuery,
    TransferTransaction,
    ScheduleSignTransaction,
    ScheduleInfoQuery,
    TransactionRecordQuery,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/**
 * @typedef {import("@hashgraph/sdk").AccountBalance} AccountBalance
 * @typedef {import("@hashgraph/sdk").AccountId} AccountId
 */

async function main() {
    // set up wallet
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    // generate keys
    const privateKeyList = [];
    const publicKeyList = [];
    for (let i = 0; i < 4; i++) {
        const privateKey = PrivateKey.generate();
        const publicKey = privateKey.publicKey;
        privateKeyList.push(privateKey);
        publicKeyList.push(publicKey);
        console.log(`${i + 1}. public key: ${publicKey.toString()}`);
        console.log(`${i + 1}. private key: ${privateKey.toString()}`);
    }
    const thresholdKey = new KeyList(publicKeyList, 3);

    try {
        // create multi-sig account
        let transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(thresholdKey)
            .setInitialBalance(Hbar.fromTinybars(1))
            .setAccountMemo("3-of-4 multi-sig account")
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const txAccountCreate = await transaction.executeWithSigner(wallet);

        const txAccountCreateReceipt =
            await txAccountCreate.getReceiptWithSigner(wallet);
        const multiSigAccountId = txAccountCreateReceipt.accountId;
        console.log(
            `3-of-4 multi-sig account ID:  ${multiSigAccountId.toString()}`,
        );
        await queryBalance(multiSigAccountId, wallet);

        // schedule crypto transfer from multi-sig account to operator account
        const txSchedule = await (
            await (
                await (
                    await new TransferTransaction()
                        .addHbarTransfer(
                            multiSigAccountId,
                            Hbar.fromTinybars(-1),
                        )
                        .addHbarTransfer(
                            wallet.getAccountId(),
                            Hbar.fromTinybars(1),
                        )
                        .schedule() // create schedule
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).sign(privateKeyList[0])
        ) // add 1. signature
            .executeWithSigner(wallet);

        const txScheduleReceipt = await txSchedule.getReceiptWithSigner(wallet);
        console.log("Schedule status: " + txScheduleReceipt.status.toString());
        const scheduleId = txScheduleReceipt.scheduleId;
        console.log(`Schedule ID:  ${scheduleId.toString()}`);
        const scheduledTxId = txScheduleReceipt.scheduledTransactionId;
        console.log(`Scheduled tx ID:  ${scheduledTxId.toString()}`);

        // add 2. signature
        const txScheduleSign1 = await (
            await (
                await (
                    await new ScheduleSignTransaction()
                        .setScheduleId(scheduleId)
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).sign(privateKeyList[1])
        ).executeWithSigner(wallet);

        const txScheduleSign1Receipt =
            await txScheduleSign1.getReceiptWithSigner(wallet);
        console.log(
            "1. ScheduleSignTransaction status: " +
                txScheduleSign1Receipt.status.toString(),
        );
        await queryBalance(multiSigAccountId, wallet);

        // add 3. signature to trigger scheduled tx
        const txScheduleSign2 = await (
            await (
                await (
                    await new ScheduleSignTransaction()
                        .setScheduleId(scheduleId)
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).sign(privateKeyList[2])
        ).executeWithSigner(wallet);

        const txScheduleSign2Receipt =
            await txScheduleSign2.getReceiptWithSigner(wallet);
        console.log(
            "2. ScheduleSignTransaction status: " +
                txScheduleSign2Receipt.status.toString(),
        );
        await queryBalance(multiSigAccountId, wallet);

        // query schedule
        const scheduleInfo = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .executeWithSigner(wallet);
        console.log(scheduleInfo);

        // query triggered scheduled tx
        const recordScheduledTx = await new TransactionRecordQuery()
            .setTransactionId(scheduledTxId)
            .executeWithSigner(wallet);
        console.log(recordScheduledTx);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

/**
 * @param {AccountId} accountId
 * @param {Wallet} wallet
 * @returns {Promise<AccountBalance>}
 */
async function queryBalance(accountId, wallet) {
    const accountBalance = await new AccountBalanceQuery()
        .setAccountId(accountId)
        .executeWithSigner(wallet);
    console.log(
        `Balance of account ${accountId.toString()}: ${accountBalance.hbars
            .toTinybars()
            .toInt()} tinybar`,
    );
    return accountBalance;
}

void main();
// Filename: examples/serialize-deserialize-1.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Transaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize the so-called signed transaction, and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.ALICE_KEY ||
        !process.env.ALICE_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const aliceId = AccountId.fromString(process.env.ALICE_ID);
    const aliceKey = PrivateKey.fromStringED25519(process.env.ALICE_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // 1. Create transaction and freeze it
        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, new Hbar(-1))
            .addHbarTransfer(aliceId, new Hbar(1))
            .freezeWith(client);

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Sign and execute transaction
        const executedTransaction = await (
            await transactionFromBytes.sign(aliceKey)
        ).execute(client);

        // 5. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-10.js
import {
    AccountId,
    Wallet,
    PrivateKey,
    LocalProvider,
    Transaction,
    FileCreateTransaction,
    LogLevel,
    Logger,
    TransactionId,
    Timestamp,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction (chunked), set transaction id and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const provider = new LocalProvider();
    const infoLogger = new Logger(LogLevel.Info);
    provider.setLogger(infoLogger);
    const wallet = new Wallet(operatorId, operatorKey, provider);

    try {
        // 1. Create transaction
        const transaction = new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents("[e2e::FileCreateTransaction]");

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        let transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Set transaction id
        const validStart = new Timestamp(Math.floor(Date.now() / 1000), 0);
        const transactionId = new TransactionId(operatorId, validStart);
        transactionFromBytes.setTransactionId(transactionId);

        // 5. Freeze, sign and execute transaction
        const response = await (
            await (
                await transactionFromBytes.freezeWithSigner(wallet)
            ).signWithSigner(wallet)
        ).executeWithSigner(wallet);

        // 6. Get a receipt
        const receipt = await response.getReceiptWithSigner(wallet);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    provider.close();
}

void main();
// Filename: examples/serialize-deserialize-11.js
import {
    AccountId,
    Wallet,
    PrivateKey,
    LocalProvider,
    Transaction,
    FileCreateTransaction,
    LogLevel,
    Logger,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction (chunked), set node account ids and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const provider = new LocalProvider();
    const infoLogger = new Logger(LogLevel.Info);
    provider.setLogger(infoLogger);
    const wallet = new Wallet(operatorId, operatorKey, provider);

    try {
        // 1. Create transaction
        const transaction = new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents("[e2e::FileCreateTransaction]");

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        let transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Set node accoutn ids
        transactionFromBytes.setNodeAccountIds([new AccountId(3)]);

        // 5. Freeze, sign and execute transaction
        const response = await (
            await (
                await transactionFromBytes.freezeWithSigner(wallet)
            ).signWithSigner(wallet)
        ).executeWithSigner(wallet);

        // 6. Get a receipt
        const receipt = await response.getReceiptWithSigner(wallet);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    provider.close();
}

void main();
// Filename: examples/serialize-deserialize-12.js
import {
    AccountId,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Transaction,
    AccountUpdateTransaction,
    TransactionId,
    Timestamp,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Create, serialize and deserialize so-called incomplete transaction, then freeze it, serialize and deserialize it again, and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // Create transaction id
        const transactionId = new TransactionId(
            operatorId,
            Timestamp.fromDate(new Date()),
        );

        // 1. Create a transaction
        const transaction = new AccountUpdateTransaction()
            .setTransactionId(transactionId)
            .setAccountId(operatorId)
            .setAccountMemo("Hello");

        // 2. Serialize transaction
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Freeze transaction
        transactionFromBytes.freezeWith(client);

        // 5. Serialize transaction after being frozen
        const transactionBytesAfterBeingFrozen = transactionFromBytes.toBytes();

        // 6. Deserialize transaction again
        const transactionFromBytesAfterBeingFrozen = Transaction.fromBytes(
            transactionBytesAfterBeingFrozen,
        );

        // 7. Execute transaction
        const executedTransaction =
            await transactionFromBytesAfterBeingFrozen.execute(client);

        // 8. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-2.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Transaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize the so-called signed transaction after being signed, and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.ALICE_KEY ||
        !process.env.ALICE_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const aliceId = AccountId.fromString(process.env.ALICE_ID);
    const aliceKey = PrivateKey.fromStringED25519(process.env.ALICE_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // 1. Create transaction and freeze it
        let transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, new Hbar(-1))
            .addHbarTransfer(aliceId, new Hbar(1))
            .freezeWith(client);

        // 2. Sign transaction
        await transaction.sign(aliceKey);

        // 3. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 4. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 5. Execute transaction
        const executedTransaction = await transactionFromBytes.execute(client);

        // 6. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-3.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Transaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction, and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.ALICE_KEY ||
        !process.env.ALICE_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const aliceId = AccountId.fromString(process.env.ALICE_ID);
    const aliceKey = PrivateKey.fromStringED25519(process.env.ALICE_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // 1. Create transaction
        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, new Hbar(-1))
            .addHbarTransfer(aliceId, new Hbar(1));

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Freeze, sign and execute transaction
        const executedTransaction = await (
            await transactionFromBytes.freezeWith(client).sign(aliceKey)
        ).execute(client);

        // 5. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-4.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Transaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction, set node account ids and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.ALICE_KEY ||
        !process.env.ALICE_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const aliceId = AccountId.fromString(process.env.ALICE_ID);
    const aliceKey = PrivateKey.fromStringED25519(process.env.ALICE_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // 1. Create transaction
        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, new Hbar(-1))
            .addHbarTransfer(aliceId, new Hbar(1));

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        let transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Set node account ids
        transactionFromBytes.setNodeAccountIds([new AccountId(3)]);

        // 5. Freeze, sign and execute transaction
        const executedTransaction = await (
            await transactionFromBytes.freezeWith(client).sign(aliceKey)
        ).execute(client);

        // 6. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-5.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Timestamp,
    Transaction,
    TransactionId,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction, set transaction id and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.ALICE_KEY ||
        !process.env.ALICE_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const aliceId = AccountId.fromString(process.env.ALICE_ID);
    const aliceKey = PrivateKey.fromStringED25519(process.env.ALICE_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // 1. Create transaction
        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, new Hbar(-1))
            .addHbarTransfer(aliceId, new Hbar(1));

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        let transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Set transaction id
        const validStart = new Timestamp(Math.floor(Date.now() / 1000), 0);
        const transactionId = new TransactionId(operatorId, validStart);
        transactionFromBytes.setTransactionId(transactionId);

        // 5. Freeze, sign and execute transaction
        const executedTransaction = await (
            await transactionFromBytes.freezeWith(client).sign(aliceKey)
        ).execute(client);

        // 6. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-6.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    Client,
    PrivateKey,
    Logger,
    LogLevel,
    Transaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction, update and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.ALICE_KEY ||
        !process.env.ALICE_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const network = process.env.HEDERA_NETWORK;

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const aliceId = AccountId.fromString(process.env.ALICE_ID);
    const aliceKey = PrivateKey.fromStringED25519(process.env.ALICE_KEY);

    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Set logger
    const infoLogger = new Logger(LogLevel.Info);
    client.setLogger(infoLogger);

    try {
        // 1. Create transaction
        const transaction = new TransferTransaction().addHbarTransfer(
            operatorId,
            new Hbar(1).negated(),
        );

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Check the transaction type and use particular method of
        // the corresponding class in order to update the transaction
        if (transactionFromBytes instanceof TransferTransaction) {
            transactionFromBytes.addHbarTransfer(aliceId, new Hbar(1));
        }

        // 4. Freeze, sign and execute transaction
        const executedTransaction = await (
            await transactionFromBytes.freezeWith(client).sign(aliceKey)
        ).execute(client);

        // 5. Get a receipt
        const receipt = await executedTransaction.getReceipt(client);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/serialize-deserialize-7.js
import {
    AccountId,
    Wallet,
    PrivateKey,
    LocalProvider,
    Transaction,
    FileCreateTransaction,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called signed transaction (chunked), and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const provider = new LocalProvider();
    const infoLogger = new Logger(LogLevel.Info);
    provider.setLogger(infoLogger);
    const wallet = new Wallet(operatorId, operatorKey, provider);

    try {
        // 1. Create transaction and freeze it
        const transaction = await new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents("[e2e::FileCreateTransaction]")
            .freezeWithSigner(wallet);

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Sign and execute transaction
        const response = await (
            await transactionFromBytes.signWithSigner(wallet)
        ).executeWithSigner(wallet);

        // 5. Get a receipt
        const receipt = await response.getReceiptWithSigner(wallet);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    provider.close();
}

void main();
// Filename: examples/serialize-deserialize-8.js
import {
    AccountId,
    Wallet,
    PrivateKey,
    LocalProvider,
    Transaction,
    FileCreateTransaction,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction (chunked), and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const provider = new LocalProvider();
    const infoLogger = new Logger(LogLevel.Info);
    provider.setLogger(infoLogger);
    const wallet = new Wallet(operatorId, operatorKey, provider);

    try {
        // 1. Create transaction
        const transaction = new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents("[e2e::FileCreateTransaction]");

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Freeze, sign and execute transaction
        const response = await (
            await (
                await transactionFromBytes.freezeWithSigner(wallet)
            ).signWithSigner(wallet)
        ).executeWithSigner(wallet);

        // 5. Get a receipt
        const receipt = await response.getReceiptWithSigner(wallet);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    provider.close();
}

void main();
// Filename: examples/serialize-deserialize-9.js
import {
    AccountId,
    Wallet,
    PrivateKey,
    LocalProvider,
    Transaction,
    FileCreateTransaction,
    Logger,
    LogLevel,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

/**
 * @description Serialize and deserialize so-called incomplete transaction (chunked), update and execute it
 */

async function main() {
    // Ensure required environment variables are available
    dotenv.config();
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    // Configure client using environment variables
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);

    const provider = new LocalProvider();
    const infoLogger = new Logger(LogLevel.Info);
    provider.setLogger(infoLogger);
    const wallet = new Wallet(operatorId, operatorKey, provider);

    try {
        // 1. Create transaction
        const transaction = new FileCreateTransaction()
            .setKeys([wallet.getAccountKey()])
            .setContents("[e2e::FileCreateTransaction]");

        // 2. Serialize transaction into bytes
        const transactionBytes = transaction.toBytes();

        // 3. Deserialize transaction from bytes
        const transactionFromBytes = Transaction.fromBytes(transactionBytes);

        // 4. Check the transaction type and use particular method of
        // the corresponding class in order to update the transaction
        if (transactionFromBytes instanceof FileCreateTransaction) {
            transactionFromBytes.setFileMemo("Test");
        }

        // 5. Freeze, sign and execute transaction
        const response = await (
            await (
                await transactionFromBytes.freezeWithSigner(wallet)
            ).signWithSigner(wallet)
        ).executeWithSigner(wallet);

        // 6. Get a receipt
        const receipt = await response.getReceiptWithSigner(wallet);
        console.log(`Transaction status: ${receipt.status.toString()}!`);
    } catch (error) {
        console.log(error);
    }

    provider.close();
}

void main();
// Filename: examples/sign-transaction.js
import {
    Wallet,
    LocalProvider,
    PrivateKey,
    AccountCreateTransaction,
    Hbar,
    AccountId,
    KeyList,
    TransferTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

let user1Key;
let user2Key;

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    user1Key = PrivateKey.generate();
    user2Key = PrivateKey.generate();

    // create a multi-sig account
    const keyList = new KeyList([user1Key, user2Key]);

    try {
        let transaction = await new AccountCreateTransaction()
            .setInitialBalance(new Hbar(2)) // 5 h
            .setKeyWithoutAlias(keyList)
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const response = await transaction.executeWithSigner(wallet);

        let receipt = await response.getReceiptWithSigner(wallet);

        console.log(`account id = ${receipt.accountId.toString()}`);

        // create a transfer from new account to 0.0.3
        let trasnferTransaction = await new TransferTransaction()
            .setNodeAccountIds([new AccountId(3)])
            .addHbarTransfer(receipt.accountId, -1)
            .addHbarTransfer("0.0.3", 1)
            .freezeWithSigner(wallet);
        trasnferTransaction = await trasnferTransaction.signWithSigner(wallet);

        user1Key.signTransaction(trasnferTransaction);
        user2Key.signTransaction(trasnferTransaction);

        const result = await trasnferTransaction.executeWithSigner(wallet);
        receipt = await result.getReceiptWithSigner(wallet);

        console.log(`Status: ${receipt.status.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/simple_rest_signature_provider/src/client.js
import axios from "axios";
import {
    AccountBalance,
    AccountBalanceQuery,
    TransactionReceiptQuery,
    AccountId,
    AccountInfo,
    AccountInfoQuery,
    AccountRecordsQuery,
    Hbar,
    LedgerId,
    PublicKey,
    Transaction,
    TransactionId,
    TransactionReceipt,
    TransactionResponse,
    TransferTransaction,
} from "@hashgraph/sdk";

const instance = axios.create({
    baseURL: "http://127.0.0.1:3000/",
});

/**
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @typedef {import("@hashgraph/sdk").Executable<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
 */

/**
 * @typedef {import("@hashgraph/sdk").Signer} Signer
 * @typedef {import("@hashgraph/sdk").Provider} Provider
 * @typedef {import("@hashgraph/sdk").TransactionResponseJSON} TransactionResponseJSON
 * @typedef {import("@hashgraph/sdk").Key} Key
 * @typedef {import("@hashgraph/sdk").SignerSignature} SignerSignature
 * @typedef {import("@hashgraph/sdk").TransactionRecord} TransactionRecord
 */

/**
 * @typedef {object} LocalProviderResponse
 * @property {string} response
 * @property {string | undefined} error
 */

/**
 * @implements {Provider}
 */
export class SimpleRestProvider {
    /**
     * @param {LedgerId?} ledgerId
     * @param {{[key: string]: string}} network
     * @param {string[]} mirrorNetwork
     */
    constructor(ledgerId, network, mirrorNetwork) {
        this.ledgerId = ledgerId;
        this.network = network;
        this.mirrorNetwork = mirrorNetwork;
    }

    /**
     * @returns {LedgerId?}
     */
    getLedgerId() {
        return this.ledgerId;
    }

    /**
     * @returns {{[key: string]: string}}
     */
    getNetwork() {
        return this.network;
    }

    /**
     * @returns {string[]}
     */
    getMirrorNetwork() {
        return this.mirrorNetwork;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {Promise<AccountBalance>}
     */
    getAccountBalance(accountId) {
        return this.call(new AccountBalanceQuery().setAccountId(accountId));
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {Promise<AccountInfo>}
     */
    async getAccountInfo(accountId) {
        return this.call(new AccountInfoQuery().setAccountId(accountId));
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {Promise<TransactionRecord[]>}
     */
    getAccountRecords(accountId) {
        return this.call(new AccountRecordsQuery().setAccountId(accountId));
    }

    /**
     * @param {TransactionId | string} transactionId
     * @returns {Promise<TransactionReceipt>}
     */
    getTransactionReceipt(transactionId) {
        return this.call(
            new TransactionReceiptQuery().setTransactionId(transactionId),
        );
    }

    /**
     * @param {TransactionResponse} response
     * @returns {Promise<TransactionReceipt>}
     */
    waitForReceipt(response) {
        return this.call(
            new TransactionReceiptQuery().setTransactionId(
                response.transactionId,
            ),
        );
    }

    /**
     * @template RequestT
     * @template ResponseT
     * @template OutputT
     * @param {Executable<RequestT, ResponseT, OutputT>} request
     * @returns {Promise<OutputT>}
     */
    async call(request) {
        /** @type {{ response: string, error: string | undefined} | TransactionResponseJSON} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const response = (
            await instance.post("/request", {
                request: Buffer.from(request.toBytes()).toString("hex"),
            })
        ).data;

        if (Object.prototype.hasOwnProperty.call(response, "error")) {
            throw new Error(/** @type {{ error: string }} */ (response).error);
        }

        if (Object.prototype.hasOwnProperty.call(response, "response")) {
            const inner = /** @type {{response: string}} */ (response).response;
            const bytes = Buffer.from(inner, "hex");

            switch (request.constructor.name) {
                case "AccountBalanceQuery":
                    // @ts-ignore
                    return AccountBalance.fromBytes(bytes);
                case "AccountInfoQuery":
                    // @ts-ignore
                    return AccountInfo.fromBytes(bytes);
                case "TransactionReceipt":
                    // @ts-ignore
                    return TransactionReceipt.fromBytes(bytes);
                default:
                    throw new Error(
                        `unrecognzied request time ${request.constructor.name}`,
                    );
            }
        } else {
            // @ts-ignore
            return TransactionResponse.fromJSON(response);
        }
    }
}

/**
 * @implements {Signer}
 */
export class SimpleRestSigner {
    /**
     * @param {AccountId} accountId
     * @param {PublicKey} publicKey
     * @param {Provider} provider
     */
    constructor(accountId, publicKey, provider) {
        this.accountId = accountId;
        this.publicKey = publicKey;
        this.provider = provider;
    }

    /**
     * @param {(AccountId | string)=} accountId
     * @returns {Promise<SimpleRestSigner>}
     */
    static async connect(accountId) {
        /**
         * @type {{ accountId: string, publicKey: string, ledgerId: string, network: {[key: string]: string}, mirrorNetwork: string[], error: string | undefined }}
         */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const response = (
            await instance.post("/login", {
                accountId: accountId != null ? accountId.toString() : null,
            })
        ).data;

        if (response.error != null) {
            throw new Error(response.error);
        }

        const id = AccountId.fromString(response.accountId);
        const publicKey = PublicKey.fromString(response.publicKey);
        const ledgerId = LedgerId.fromString(response.ledgerId);
        const provider = new SimpleRestProvider(
            ledgerId,
            response.network,
            response.mirrorNetwork,
        );

        return new SimpleRestSigner(id, publicKey, provider);
    }

    /**
     * @returns {Provider=}
     */
    getProvider() {
        return this.provider;
    }

    /**
     * @abstract
     * @returns {AccountId}
     */
    getAccountId() {
        return this.accountId;
    }

    /**
     * @returns {Key}
     */
    getAccountKey() {
        return this.publicKey;
    }

    /**
     * @returns {LedgerId?}
     */
    getLedgerId() {
        return this.provider == null ? null : this.provider.getLedgerId();
    }

    /**
     * @abstract
     * @returns {{[key: string]: (string | AccountId)}}
     */
    getNetwork() {
        return this.provider == null ? {} : this.provider.getNetwork();
    }

    /**
     * @abstract
     * @returns {string[]}
     */
    getMirrorNetwork() {
        return this.provider == null ? [] : this.provider.getMirrorNetwork();
    }

    /**
     * @param {Uint8Array[]} messages
     * @returns {Promise<SignerSignature[]>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sign(messages) {
        return Promise.reject(new Error("not implemented"));
    }

    /**
     * @returns {Promise<AccountBalance>}
     */
    getAccountBalance() {
        return this.call(
            new AccountBalanceQuery().setAccountId(this.accountId),
        );
    }

    /**
     * @abstract
     * @returns {Promise<AccountInfo>}
     */
    getAccountInfo() {
        return this.call(new AccountInfoQuery().setAccountId(this.accountId));
    }

    /**
     * @abstract
     * @returns {Promise<TransactionRecord[]>}
     */
    getAccountRecords() {
        return this.call(
            new AccountRecordsQuery().setAccountId(this.accountId),
        );
    }

    /**
     * @template {Transaction} T
     * @param {T} transaction
     * @returns {Promise<T>}
     */
    async signTransaction(transaction) {
        /** @type {LocalProviderResponse} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const response = (
            await instance.post("/sign", {
                request: Buffer.from(transaction.toBytes()).toString("hex"),
            })
        ).data;

        if (Object.prototype.hasOwnProperty.call(response, "error")) {
            throw new Error(/** @type {{ error: string }} */ (response).error);
        }

        return /** @type {T} */ (
            Transaction.fromBytes(Buffer.from(response.response, "hex"))
        );
    }

    /**
     * @template {Transaction} T
     * @param {T} transaction
     * @returns {Promise<T>}
     */
    checkTransaction(transaction) {
        const transactionId = transaction.transactionId;
        if (
            transactionId != null &&
            transactionId.accountId != null &&
            transactionId.accountId.compare(this.accountId) != 0
        ) {
            throw new Error(
                "transaction's ID constructed with a different account ID",
            );
        }

        if (this.provider == null) {
            return Promise.resolve(transaction);
        }

        const nodeAccountIds = (
            transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []
        ).map((nodeAccountId) => nodeAccountId.toString());
        const network = Object.values(this.provider.getNetwork()).map(
            (nodeAccountId) => nodeAccountId.toString(),
        );

        if (
            !nodeAccountIds.reduce(
                (previous, current) => previous && network.includes(current),
                true,
            )
        ) {
            throw new Error(
                "Transaction already set node account IDs to values not within the current network",
            );
        }

        return Promise.resolve(transaction);
    }

    /**
     * @template {Transaction} T
     * @param {T} transaction
     * @returns {Promise<T>}
     */
    populateTransaction(transaction) {
        transaction.setTransactionId(TransactionId.generate(this.accountId));
        const network = Object.values(this.provider.getNetwork()).map(
            (nodeAccountId) =>
                typeof nodeAccountId === "string"
                    ? AccountId.fromString(nodeAccountId)
                    : new AccountId(nodeAccountId),
        );
        transaction.setNodeAccountIds(network);
        return Promise.resolve(transaction);
    }

    /**
     * @template RequestT
     * @template ResponseT
     * @template OutputT
     * @param {Executable<RequestT, ResponseT, OutputT>} request
     * @returns {Promise<OutputT>}
     */
    call(request) {
        if (this.provider == null) {
            throw new Error(
                "cannot send request with an wallet that doesn't contain a provider",
            );
        }

        return this.provider.call(request);
    }
}

/**
 *
 */
async function main() {
    const signer = await SimpleRestSigner.connect();

    // Free query
    const balance = await signer.getAccountBalance();
    console.log(`balance: ${balance.hbars.toString()}`);

    // Paid query
    const info = await signer.getAccountInfo();
    console.log(`key: ${info.key.toString()}`);

    // Transaction
    const transaction = await new TransferTransaction()
        .addHbarTransfer("0.0.3", Hbar.fromTinybars(1))
        .addHbarTransfer(signer.accountId, Hbar.fromTinybars(1).negated())
        .freezeWithSigner(signer);
    const response = await transaction.executeWithSigner(signer);
    const hash = Buffer.from(response.transactionHash).toString("hex");
    console.log(`hash: ${hash}`);
}

void main();
// Filename: examples/simple_rest_signature_provider/src/server.js
import express from "express";
import readline from "readline";
import { Wallet, LocalProvider, Transaction, Query } from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

if (process.env.OPERATOR_KEY == null || process.env.OPERATOR_ID == null) {
    throw new Error("`OPERATOR_KEY` and `OPERATOR_ID` required");
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

const app = express();
app.use(express.json());

const provider = new LocalProvider();

const wallet = new Wallet(
    process.env.OPERATOR_ID,
    process.env.OPERATOR_KEY,
    provider,
);

const ledgerId = provider.getLedgerId();
const network = provider.getNetwork();
Object.entries(network).map(([key, value]) => {
    network[key] = value.toString();
});
const mirrorNetwork = provider.getMirrorNetwork();

app.post("/login", function (req, res) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const request = /** @type {{ accountId: string | undefined }} */ (req.body);
    if (
        request.accountId != null &&
        request.accountId != wallet.accountId.toString()
    ) {
        res.json({ error: "invalid account ID" });
        return;
    }

    const accountId =
        request.accountId == null ? wallet.accountId : request.accountId;

    rl.question(`Login as ${accountId.toString()}?\n`, (name) => {
        switch (name) {
            case "y":
            case "yes":
                res.json({
                    accountId: wallet.accountId.toString(),
                    publicKey: wallet.publicKey.toString(),
                    ledgerId: ledgerId != null ? ledgerId.toString() : null,
                    network,
                    mirrorNetwork,
                });
                break;
            default:
                res.json({ error: "request denied" });
        }
    });
});

// eslint-disable-next-line @typescript-eslint/no-misused-promises
app.post("/request", async function (req, res) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const request = /** @type {{ request: string | undefined }} */ (req.body);
    if (request.request == null || request.request === "") {
        res.json({ error: "no request provided" });
        return;
    }

    const bytes = Buffer.from(request.request, "hex");

    try {
        const transaction = Transaction.fromBytes(bytes);
        await transaction.signWithSigner(wallet);
        const response = await wallet.call(transaction);
        res.json(response);
        return;
    } catch (_) {
        try {
            const query = Query.fromBytes(bytes);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const response = await wallet.call(query);
            res.json({
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-argument
                response: Buffer.from(response.toBytes()).toString("hex"),
            });
            return;
        } catch (error) {
            res.json({ error: /** @type {Error} */ (error).toString() });
            return;
        }
    }
});

// eslint-disable-next-line @typescript-eslint/no-misused-promises
app.post("/sign", async function (req, res) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const request = /** @type {{ request: string | undefined }} */ (req.body);
    if (request.request == null || request.request === "") {
        res.json({ error: "no request provided" });
        return;
    }

    const bytes = Buffer.from(request.request, "hex");

    try {
        const transaction = Transaction.fromBytes(bytes);
        await transaction.signWithSigner(wallet);
        res.json({
            response: Buffer.from(transaction.toBytes()).toString("hex"),
        });
        return;
    } catch (error) {
        res.json({ error: /** @type {Error} */ (error).toString() });
        return;
    }
});

app.listen(3000);
// Filename: examples/solidity-precompile-example.js
import * as hashgraph from "@hashgraph/sdk";
import ContractHelper from "./ContractHelper.js";
import contract from "./precompile-example/PrecompileExample.json" with { type: "json" };
import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new hashgraph.LocalProvider();

    const wallet = new hashgraph.Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const operatorPrivateKey = hashgraph.PrivateKey.fromStringED25519(
        process.env.OPERATOR_KEY,
    );
    const operatorPublicKey = operatorPrivateKey.publicKey;

    const operatorAccountId = hashgraph.AccountId.fromString(
        process.env.OPERATOR_ID,
    );

    const alicePrivateKey = hashgraph.PrivateKey.generateED25519();
    const alicePublicKey = alicePrivateKey.publicKey;

    try {
        let transaction = await new hashgraph.AccountCreateTransaction()
            .setKeyWithoutAlias(alicePublicKey)
            .setInitialBalance(hashgraph.Hbar.fromString("1000"))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        let response = await transaction.executeWithSigner(wallet);
        const aliceAccountId = (await response.getReceiptWithSigner(wallet))
            .accountId;

        const walletWithAlice = new hashgraph.Wallet(
            aliceAccountId,
            alicePrivateKey,
            provider,
        );

        // Instantiate ContractHelper

        // The contract bytecode is located on the `object` field
        const contractBytecode = /** @type {string} */ (
            contract.bytecode.object
        );

        const contractHelper = await ContractHelper.init(
            contractBytecode,
            new hashgraph.ContractFunctionParameters()
                .addAddress(wallet.getAccountId().toSolidityAddress())
                .addAddress(aliceAccountId.toSolidityAddress()),
            wallet,
        );

        // Update the signer to have contractId KeyList (this is by security requirement)
        let accountUpdateOpratorTransaction =
            await new hashgraph.AccountUpdateTransaction()
                .setAccountId(operatorAccountId)
                .setKey(
                    new hashgraph.KeyList(
                        [operatorPublicKey, contractHelper.contractId],
                        1,
                    ),
                )
                .freezeWithSigner(wallet);
        accountUpdateOpratorTransaction =
            await accountUpdateOpratorTransaction.signWithSigner(wallet);
        await accountUpdateOpratorTransaction.executeWithSigner(wallet);

        // Update the Alice account to have contractId KeyList (this is by security requirement)
        let accountUpdateAliceTransaction =
            await new hashgraph.AccountUpdateTransaction()
                .setAccountId(aliceAccountId)
                .setKey(
                    new hashgraph.KeyList(
                        [alicePublicKey, contractHelper.contractId],
                        1,
                    ),
                )
                .freezeWithSigner(walletWithAlice);
        accountUpdateAliceTransaction =
            await accountUpdateAliceTransaction.signWithSigner(walletWithAlice);
        await accountUpdateAliceTransaction.executeWithSigner(walletWithAlice);

        /**
         *
         * @param {string} tokenAddress
         * @returns {Promise<void>}
         */
        let additionalLogic = async function (tokenAddress) {
            let accountUpdateOpratorTransaction =
                await new hashgraph.TokenUpdateTransaction()
                    .setTokenId(
                        hashgraph.TokenId.fromSolidityAddress(tokenAddress),
                    )
                    .setAdminKey(
                        new hashgraph.KeyList(
                            [alicePublicKey, contractHelper.contractId],
                            1,
                        ),
                    )
                    .setSupplyKey(
                        new hashgraph.KeyList(
                            [alicePublicKey, contractHelper.contractId],
                            1,
                        ),
                    )
                    .freezeWithSigner(walletWithAlice);
            accountUpdateOpratorTransaction =
                await accountUpdateOpratorTransaction.signWithSigner(
                    walletWithAlice,
                );
            let accountUpdateOpratorTransactionResponce =
                await accountUpdateOpratorTransaction.executeWithSigner(
                    walletWithAlice,
                );

            console.log(
                "Status of Token Update Transactio:",
                (
                    await accountUpdateOpratorTransactionResponce.getReceiptWithSigner(
                        walletWithAlice,
                    )
                ).status.toString(),
            );
        };

        // Configure steps in ContracHelper

        contractHelper
            .setResultValidatorForStep(0, (contractFunctionResult) => {
                const bytes = Buffer.from(contractFunctionResult.getBytes32(0));
                console.log(
                    `getPseudoRandomSeed() returned ${bytes.toString("hex")}`,
                );
                return true;
            })
            .setPayableAmountForStep(1, new hashgraph.Hbar(20))
            // step 3 associates Alice with the token, which requires Alice's signature
            .addSignerForStep(3, alicePrivateKey)
            .addSignerForStep(5, alicePrivateKey)
            .setParameterSupplierForStep(11, () => {
                return (
                    new hashgraph.ContractFunctionParameters()
                        // when contracts work with a public key, they handle the raw bytes of the public key
                        .addBytes(alicePublicKey.toBytesRaw())
                );
            })
            .setPayableAmountForStep(11, new hashgraph.Hbar(40))
            // Because we're setting the adminKey for the created NFT token to Alice's key,
            // Alice must sign the ContractExecuteTransaction.
            .addSignerForStep(11, alicePrivateKey)
            .setStepLogic(11, additionalLogic)
            // and Alice must sign for minting because her key is the supply key.
            .addSignerForStep(12, alicePrivateKey)
            .setParameterSupplierForStep(12, () => {
                return (
                    new hashgraph.ContractFunctionParameters()
                        // add three metadatas
                        .addBytesArray([
                            new Uint8Array([0x01b]),
                            new Uint8Array([0x02b]),
                            new Uint8Array([0x03b]),
                        ])
                );
            }) // and alice must sign to become associated with the token.
            .addSignerForStep(13, alicePrivateKey)
            // Alice must sign to burn the token because her key is the supply key
            .addSignerForStep(16, alicePrivateKey);

        // step 0 tests pseudo random number generator (PRNG)
        // step 1 creates a fungible token
        // step 2 mints it
        // step 3 associates Alice with it
        // step 4 transfers it to Alice.
        // step 5 approves an allowance of the fungible token with operator as the owner and Alice as the spender
        // steps 6 - 10 test misc functions on the fungible token (see PrecompileExample.sol for details).
        // step 11 creates an NFT token with a custom fee, and with the admin and supply set to Alice's key
        // step 12 mints some NFTs
        // step 13 associates Alice with the NFT token
        // step 14 transfers some NFTs to Alice
        // step 15 approves an NFT allowance with operator as the owner and Alice as the spender
        // step 16 burn some NFTs

        await contractHelper.executeSteps(
            /* from step */ 0,
            /* to step */ 16,
            wallet,
        );

        console.log("All steps completed with valid results.");
    } catch (error) {
        console.error(error);
    } finally {
        provider.close();
    }
}

void main();
// Filename: examples/staking-example-1.js
import {
    AccountCreateTransaction,
    AccountUpdateTransaction,
    AccountInfoQuery,
    Wallet,
    LocalProvider,
    PrivateKey,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const newKey = PrivateKey.generate();

    console.log(`private key = ${newKey.toString()}`);
    console.log(`public key = ${newKey.publicKey.toString()}`);

    try {
        // Create an account and stake to an acount ID
        // In this case we're staking to account ID 3 which happens to be
        // the account ID of node 0, we're only doing this as an example.
        // If you really want to stake to node 0, you should use
        // `.setStakedNodeId()` instead
        let transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(newKey.publicKey)
            .setInitialBalance(20)
            .setStakedAccountId("0.0.3")
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const resp = await transaction.executeWithSigner(wallet);

        // If we get here we have successfully created an account that
        // is staked to account ID 0.0.3
        const transactionReceipt = await resp.getReceiptWithSigner(wallet);

        // The new account ID
        const newAccountId = transactionReceipt.accountId;

        console.log(`account id = ${newAccountId.toString()}`);

        // Show the required key used to sign the account update transaction to
        // stake the accounts hbar i.e. the fee payer key and key to authorize
        // changes to the account should be different
        console.log(
            `key required to update staking information: ${newKey.publicKey.toString()}`,
        );
        console.log(
            `fee payer aka operator key: ${wallet.getAccountKey().toString()}`,
        );

        // Query the account info, it should show the staked account ID
        // to be 0.0.3 just like what we set it to
        let info = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .executeWithSigner(wallet);

        console.log(`Staking info: ${info.stakingInfo.toString()}`);

        // Use the `AccountUpdateTransaction` to unstake the account's hbars
        //
        // If this succeeds then we should no longer have a staked account ID
        await (
            await (
                await (
                    await (
                        await new AccountUpdateTransaction()
                            .setAccountId(newAccountId)
                            .clearStakedAccountId()
                            .freezeWithSigner(wallet)
                    )
                        // Sign the transaction with the account key
                        .sign(newKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        // Query the account info, it should show the staked account ID
        // to be 0.0.3 just like what we set it to
        info = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .executeWithSigner(wallet);

        console.log(`Staking info: ${info.stakingInfo.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/staking-example-2.js
import {
    AccountCreateTransaction,
    AccountInfoQuery,
    Wallet,
    LocalProvider,
    PrivateKey,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const newKey = PrivateKey.generate();

    console.log(`private key = ${newKey.toString()}`);
    console.log(`public key = ${newKey.publicKey.toString()}`);

    try {
        // Create an account and stake to an acount ID
        // In this case we're staking to account ID 3 which happens to be
        // the account ID of node 0, we're only doing this as an example.
        // If you really want to stake to node 0, you should use
        // `.setStakedNodeId()` instead
        let transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(newKey.publicKey)
            .setInitialBalance(20)
            .setStakedAccountId("0.0.3")
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        const resp = await transaction.executeWithSigner(wallet);

        // If we get here we have successfully created an account that
        // is staked to account ID 0.0.3
        const transactionReceipt = await resp.getReceiptWithSigner(wallet);

        // The new account ID
        const newAccountId = transactionReceipt.accountId;

        console.log(`account id = ${newAccountId.toString()}`);

        // Show the required key used to sign the account update transaction to
        // stake the accounts hbar i.e. the fee payer key and key to authorize
        // changes to the account should be different
        console.log(
            `key required to update staking information: ${newKey.publicKey.toString()}`,
        );
        console.log(
            `fee payer aka operator key: ${wallet.getAccountKey().toString()}`,
        );

        // Query the account info, it should show the staked account ID
        // to be 0.0.3 just like what we set it to
        const info = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .executeWithSigner(wallet);

        console.log(`Staking info: ${info.stakingInfo.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/time-drift.js
import {
    Client,
    PrivateKey,
    AccountId,
    AccountCreateTransaction,
    Cache,
} from "@hashgraph/sdk";
import axios from "axios";

import dotenv from "dotenv";

dotenv.config();

async function sync() {
    // http://time.google.com:80 doesn't actually give us an NTP response, instead it returns
    // a 302 redirected response. However, it does contain a `date` header which we can use.
    //
    // Note, to use `https://time.google.com/` within a browser context you must add
    // https://time.google.com to CORS
    const response = await axios.head("https://time.google.com", {
        maxRedirects: 0,

        // By default a status of 302 is considered an erring status
        validateStatus: function (status) {
            return status < 500;
        },
    });

    const currentTime = Math.round(Date.now() / 1000);

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
    // strongly discourages us using `Date.parse()`, but I'm not sure what we should replace
    // it with without adding any new deps.
    //
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument
    const worldTime = Math.round(Date.parse(response.headers.date) / 1000);

    // Set the time drift value in the SDK Cache
    Cache.setTimeDrift(worldTime - currentTime);

    console.log(`Calculated time drift to be ${Cache.timeDrift}`);
}

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringDer(process.env.OPERATOR_KEY),
    );

    await sync();

    const newKey = PrivateKey.generate();

    console.log(`private key = ${newKey.toString()}`);
    console.log(`public key = ${newKey.publicKey.toString()}`);

    const response = await new AccountCreateTransaction()
        .setInitialBalance(10) // 10 h
        .setKeyWithoutAlias(newKey.publicKey)
        .execute(client);

    const receipt = await response.getReceipt(client);

    console.log(`account id = ${receipt.accountId.toString()}`);

    client.close();
}

void main();
// Filename: examples/token-airdrop-example.js
import {
    Client,
    PrivateKey,
    AccountId,
    AccountCreateTransaction,
    TokenAirdropTransaction,
    Hbar,
    TokenCreateTransaction,
    TokenType,
    TokenMintTransaction,
    AccountBalanceQuery,
    TokenClaimAirdropTransaction,
    TokenCancelAirdropTransaction,
    TokenRejectTransaction,
    NftId,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringDer(process.env.OPERATOR_KEY),
    );

    const CID = [
        "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
        "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
        "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        "Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
        "QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw",
    ];

    /**
     * STEP 1:
     * Create 4 accounts
     */

    const privateKey = PrivateKey.generateECDSA();
    const { accountId: accountId1 } = await (
        await new AccountCreateTransaction()
            .setECDSAKeyWithAlias(privateKey)
            .setInitialBalance(new Hbar(10))
            .setMaxAutomaticTokenAssociations(-1)
            .execute(client)
    ).getReceipt(client);

    const privateKey2 = PrivateKey.generateECDSA();
    const { accountId: accountId2 } = await (
        await new AccountCreateTransaction()
            .setECDSAKeyWithAlias(privateKey2)
            .setInitialBalance(new Hbar(10))
            .setMaxAutomaticTokenAssociations(1)
            .execute(client)
    ).getReceipt(client);

    const privateKey3 = PrivateKey.generateED25519();
    const { accountId: accountId3 } = await (
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(privateKey3)
            .setInitialBalance(new Hbar(10))
            .setMaxAutomaticTokenAssociations(0)
            .execute(client)
    ).getReceipt(client);

    const treasuryKey = PrivateKey.generateECDSA();
    const { accountId: treasuryAccount } = await (
        await new AccountCreateTransaction()
            .setECDSAKeyWithAlias(treasuryKey)
            .setInitialBalance(new Hbar(10))
            .setMaxAutomaticTokenAssociations(-1)
            .execute(client)
    ).getReceipt(client);

    /**
     * STEP 2:
     * Create FT and NFT mint
     */

    const INITIAL_SUPPLY = 300;

    const tokenCreateTx = await new TokenCreateTransaction()
        .setTokenName("Fungible Token")
        .setTokenSymbol("TFT")
        .setTokenMemo("Example memo")
        .setDecimals(3)
        .setInitialSupply(INITIAL_SUPPLY)
        .setTreasuryAccountId(treasuryAccount)
        .setAdminKey(client.operatorPublicKey)
        .setFreezeKey(client.operatorPublicKey)
        .setSupplyKey(client.operatorPublicKey)
        .setMetadataKey(client.operatorPublicKey)
        .setPauseKey(client.operatorPublicKey)
        .freezeWith(client)
        .sign(treasuryKey);

    const { tokenId } = await (
        await tokenCreateTx.execute(client)
    ).getReceipt(client);

    const { tokenId: nftId } = await (
        await (
            await new TokenCreateTransaction()
                .setTokenName("Test NFT")
                .setTokenSymbol("TNFT")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(treasuryAccount)
                .setAdminKey(client.operatorPublicKey)
                .setFreezeKey(client.operatorPublicKey)
                .setSupplyKey(client.operatorPublicKey)
                .setMetadataKey(client.operatorPublicKey)
                .setPauseKey(client.operatorPublicKey)
                .freezeWith(client)
                .sign(treasuryKey)
        ).execute(client)
    ).getReceipt(client);

    let serialsNfts = [];
    for (let i = 0; i < CID.length; i++) {
        const { serials } = await (
            await new TokenMintTransaction()
                .setTokenId(nftId)
                .addMetadata(Buffer.from("-"))
                .execute(client)
        ).getReceipt(client);

        serialsNfts.push(serials[0]);
    }
    /**
     * STEP 3:
     * Airdrop fungible tokens to 3 accounts
     */
    const AIRDROP_SUPPLY_PER_ACCOUNT = INITIAL_SUPPLY / 3;
    const airdropRecord = await (
        await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(
                    tokenId,
                    treasuryAccount,
                    -AIRDROP_SUPPLY_PER_ACCOUNT,
                )
                .addTokenTransfer(
                    tokenId,
                    accountId1,
                    AIRDROP_SUPPLY_PER_ACCOUNT,
                )
                .addTokenTransfer(
                    tokenId,
                    treasuryAccount,
                    -AIRDROP_SUPPLY_PER_ACCOUNT,
                )
                .addTokenTransfer(
                    tokenId,
                    accountId2,
                    AIRDROP_SUPPLY_PER_ACCOUNT,
                )
                .addTokenTransfer(
                    tokenId,
                    treasuryAccount,
                    -AIRDROP_SUPPLY_PER_ACCOUNT,
                )
                .addTokenTransfer(
                    tokenId,
                    accountId3,
                    AIRDROP_SUPPLY_PER_ACCOUNT,
                )
                .freezeWith(client)
                .sign(treasuryKey)
        ).execute(client)
    ).getRecord(client);

    /**
     *  STEP 4: Get the transaction record and see the pending airdrops
     */

    const { newPendingAirdrops } = airdropRecord;
    console.log("Pending airdrops length", newPendingAirdrops.length);
    console.log("Pending airdrop", newPendingAirdrops[0]);

    /**
     * STEP 5:
     * Query to verify account 1 and Account 2 have received the airdrops and Account 3 has not
     */
    let account1Balance = await new AccountBalanceQuery()
        .setAccountId(accountId1)
        .execute(client);

    let account2Balance = await new AccountBalanceQuery()
        .setAccountId(accountId2)
        .execute(client);

    let account3Balance = await new AccountBalanceQuery()
        .setAccountId(accountId3)
        .execute(client);

    console.log(
        "Account1 balance after airdrop: ",
        account1Balance.tokens.get(tokenId).toInt(),
    );
    console.log(
        "Account2 balance after airdrop: ",
        account2Balance.tokens.get(tokenId).toInt(),
    );
    console.log(
        "Account3 balance after airdrop: ",
        account3Balance.tokens.get(tokenId),
    );

    /**
     * Step 6: Claim the airdrop for Account 3
     */
    await (
        await (
            await new TokenClaimAirdropTransaction()
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .freezeWith(client)
                .sign(privateKey3)
        ).execute(client)
    ).getReceipt(client);

    const account3BalanceAfterClaim = await new AccountBalanceQuery()
        .setAccountId(accountId3)
        .execute(client);

    console.log(
        "Account3 balance after airdrop claim",
        account3BalanceAfterClaim.tokens.get(tokenId).toInt(),
    );

    /**
     * Step 7:
     * Airdrop the NFTs to the 3 accounts
     */
    const { newPendingAirdrops: newPendingAirdropsNfts } = await (
        await (
            await new TokenAirdropTransaction()
                .addNftTransfer(
                    nftId,
                    serialsNfts[0],
                    treasuryAccount,
                    accountId1,
                )
                .addNftTransfer(
                    nftId,
                    serialsNfts[1],
                    treasuryAccount,
                    accountId2,
                )
                .addNftTransfer(
                    nftId,
                    serialsNfts[2],
                    treasuryAccount,
                    accountId3,
                )
                .freezeWith(client)
                .sign(treasuryKey)
        ).execute(client)
    ).getRecord(client);

    /**
     * Step 8:
     * Get the transaction record and verify two pending airdrops (for Account 2 & 3)
     */
    console.log("Pending airdrops length", newPendingAirdropsNfts.length);
    console.log("Pending airdrop for Account 0:", newPendingAirdropsNfts[0]);
    console.log("Pending airdrop for Account 1:", newPendingAirdropsNfts[1]);

    /**
     * Step 9:
     * Query to verify Account 1 received the airdrop and Account 2 and Account 3 did not
     */
    account1Balance = await new AccountBalanceQuery()
        .setAccountId(accountId1)
        .execute(client);

    account2Balance = await new AccountBalanceQuery()
        .setAccountId(accountId2)
        .execute(client);

    console.log(
        "Account 1 NFT Balance after airdrop",
        account1Balance.tokens.get(nftId).toInt(),
    );
    console.log(
        "Account 2 NFT Balance after airdrop",
        account2Balance.tokens.get(nftId),
    );
    console.log(
        "Account 3 NFT Balance after airdrop",
        account3Balance.tokens.get(nftId),
    );

    /**
     * Step 10:
     * Claim the airdrop for Account 2
     */
    await (
        await (
            await new TokenClaimAirdropTransaction()
                .addPendingAirdropId(newPendingAirdropsNfts[0].airdropId)
                .freezeWith(client)
                .sign(privateKey2)
        ).execute(client)
    ).getReceipt(client);

    account2Balance = await new AccountBalanceQuery()
        .setAccountId(accountId2)
        .execute(client);

    console.log(
        "Account 2 nft balance after claim: ",
        account2Balance.tokens.get(nftId).toInt(),
    );

    /**
     * Step 11:
     * Cancel the airdrop for Account 3
     */
    console.log("Cancelling airdrop for account 3");
    await new TokenCancelAirdropTransaction()
        .addPendingAirdropId(newPendingAirdropsNfts[1].airdropId)
        .execute(client);

    account3Balance = await new AccountBalanceQuery()
        .setAccountId(accountId3)
        .execute(client);

    console.log(
        "Account 3 nft balance after cancel: ",
        account3Balance.tokens.get(nftId),
    );

    /**
     * Step 12:
     * Reject the NFT for Account 2
     */
    console.log("Rejecting NFT for account 2");
    await (
        await (
            await new TokenRejectTransaction()
                .setOwnerId(accountId2)
                .addNftId(new NftId(nftId, serialsNfts[1]))
                .freezeWith(client)
                .sign(privateKey2)
        ).execute(client)
    ).getReceipt(client);

    /**
     * Step 13:
     * Query to verify Account 2 no longer has the NFT
     */
    account2Balance = await new AccountBalanceQuery()
        .setAccountId(accountId2)
        .execute(client);
    console.log(
        "Account 2 nft balance after reject: ",
        account2Balance.tokens.get(nftId).toInt(),
    );

    /**
     * Step 14:
     * Query to verify treasury has received the NFT back
     */
    let treasuryBalance = await new AccountBalanceQuery()
        .setAccountId(treasuryAccount)
        .execute(client);
    console.log(
        "Treasury nft balance after reject: ",
        treasuryBalance.tokens.get(nftId).toInt(),
    );

    /**
     * Step 15:
     * Reject the fungible tokens for Account 3
     */
    console.log("Rejecting fungible tokens for account 3: ");
    await (
        await (
            await new TokenRejectTransaction()
                .setOwnerId(accountId3)
                .addTokenId(tokenId)
                .freezeWith(client)
                .sign(privateKey3)
        ).execute(client)
    ).getReceipt(client);

    account3Balance = await new AccountBalanceQuery()
        .setAccountId(accountId3)
        .execute(client);

    console.log(
        "Account 3 balance after reject: ",
        account3Balance.tokens.get(tokenId).toInt(),
    );

    treasuryBalance = await new AccountBalanceQuery()
        .setAccountId(treasuryAccount)
        .execute(client);

    console.log(
        "Treasury balance after reject: ",
        treasuryBalance.tokens.get(tokenId).toInt(),
    );
    client.close();
}

void main();
// Filename: examples/token-reject.js
import {
    AccountCreateTransaction,
    PrivateKey,
    TokenCreateTransaction,
    TransferTransaction,
    AccountId,
    Client,
    TokenType,
    TokenMintTransaction,
    TokenRejectTransaction,
    TokenRejectFlow,
    NftId,
    AccountBalanceQuery,
    TokenSupplyType,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }
    const CID = [
        "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
        "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
        "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
    ];
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringED25519(process.env.OPERATOR_KEY);
    const network = process.env.HEDERA_NETWORK;
    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // create a treasury account
    const treasuryPrivateKey = PrivateKey.generateED25519();
    const treasuryAccountId = (
        await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(treasuryPrivateKey)
                .setMaxAutomaticTokenAssociations(100)
                .execute(client)
        ).getReceipt(client)
    ).accountId;

    // create a receiver account with unlimited max auto associations
    const receiverPrivateKey = PrivateKey.generateED25519();
    const receiverAccountId = (
        await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(receiverPrivateKey)
                .setMaxAutomaticTokenAssociations(-1)
                .execute(client)
        ).getReceipt(client)
    ).accountId;

    // create a nft collection
    const nftCreationTx = await (
        await new TokenCreateTransaction()
            .setTokenType(TokenType.NonFungibleUnique)
            .setTokenName("Example Fungible Token")
            .setTokenSymbol("EFT")
            .setMaxSupply(CID.length)
            .setSupplyType(TokenSupplyType.Finite)
            .setSupplyKey(operatorKey)
            .setAdminKey(operatorKey)
            .setTreasuryAccountId(treasuryAccountId)
            .freezeWith(client)
            .sign(treasuryPrivateKey)
    ).execute(client);

    const nftId = (await nftCreationTx.getReceipt(client)).tokenId;
    console.log("NFT ID: ", nftId.toString());

    // create a fungible token
    const ftCreationTx = await (
        await new TokenCreateTransaction()
            .setTokenName("Example Fungible Token")
            .setTokenSymbol("EFT")
            .setInitialSupply(100000000)
            .setSupplyKey(operatorKey)
            .setAdminKey(operatorKey)
            .setTreasuryAccountId(treasuryAccountId)
            .freezeWith(client)
            .sign(treasuryPrivateKey)
    ).execute(client);

    const ftId = (await ftCreationTx.getReceipt(client)).tokenId;
    console.log("FT ID: ", ftId.toString());

    // mint 3 NFTs to treasury
    const nftSerialIds = [];
    for (let i = 0; i < CID.length; i++) {
        const { serials } = await (
            await new TokenMintTransaction()
                .setTokenId(nftId)
                .addMetadata(Buffer.from(CID[i]))
                .execute(client)
        ).getReceipt(client);
        const [serial] = serials;
        nftSerialIds.push(new NftId(nftId, serial));
    }

    // transfer nfts to receiver
    await (
        await (
            await new TransferTransaction()
                .addNftTransfer(
                    nftSerialIds[0],
                    treasuryAccountId,
                    receiverAccountId,
                )
                .addNftTransfer(
                    nftSerialIds[1],
                    treasuryAccountId,
                    receiverAccountId,
                )
                .addNftTransfer(
                    nftSerialIds[2],
                    treasuryAccountId,
                    receiverAccountId,
                )
                .freezeWith(client)
                .sign(treasuryPrivateKey)
        ).execute(client)
    ).getReceipt(client);

    // transfer fungible tokens to receiver
    await (
        await (
            await new TransferTransaction()
                .addTokenTransfer(ftId, treasuryAccountId, -1)
                .addTokenTransfer(ftId, receiverAccountId, 1)
                .freezeWith(client)
                .sign(treasuryPrivateKey)
        ).execute(client)
    ).getReceipt(client);

    console.log("=======================");
    console.log("Before Token Reject");
    console.log("=======================");
    const receiverFTBalanceBefore = (
        await new AccountBalanceQuery()
            .setAccountId(receiverAccountId)
            .execute(client)
    ).tokens.get(ftId);
    const treasuryFTBalanceBefore = (
        await new AccountBalanceQuery()
            .setAccountId(treasuryAccountId)
            .execute(client)
    ).tokens.get(ftId);
    const receiverNFTBalanceBefore = (
        await new AccountBalanceQuery()
            .setAccountId(receiverAccountId)
            .execute(client)
    ).tokens.get(nftId);
    const treasuryNFTBalanceBefore = (
        await new AccountBalanceQuery()
            .setAccountId(treasuryAccountId)
            .execute(client)
    ).tokens.get(nftId);
    console.log("Receiver FT balance: ", receiverFTBalanceBefore.toInt());
    console.log("Treasury FT balance: ", treasuryFTBalanceBefore.toInt());
    console.log(
        "Receiver NFT balance: ",
        receiverNFTBalanceBefore ? receiverNFTBalanceBefore.toInt() : 0,
    );
    console.log("Treasury NFT balance: ", treasuryNFTBalanceBefore.toInt());

    // reject fungible tokens back to treasury
    const tokenRejectResponse = await (
        await (
            await new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftId)
                .freezeWith(client)
                .sign(receiverPrivateKey)
        ).execute(client)
    ).getReceipt(client);

    // reject NFTs back to treasury
    const rejectFlowResponse = await (
        await new TokenRejectFlow()
            .setOwnerId(receiverAccountId)
            .setNftIds(nftSerialIds)
            .freezeWith(client)
            .sign(receiverPrivateKey)
            .execute(client)
    ).getReceipt(client);

    const tokenRejectStatus = tokenRejectResponse.status.toString();
    const tokenRejectFlowStatus = rejectFlowResponse.status.toString();

    console.log("=======================");
    console.log("After Token Reject Transaction and flow");
    console.log("=======================");

    const receiverFTBalanceAfter = (
        await new AccountBalanceQuery()
            .setAccountId(receiverAccountId)
            .execute(client)
    ).tokens.get(ftId);

    const treasuryFTBalanceAfter = (
        await new AccountBalanceQuery()
            .setAccountId(treasuryAccountId)
            .execute(client)
    ).tokens.get(ftId);

    const receiverNFTBalanceAfter = (
        await new AccountBalanceQuery()
            .setAccountId(receiverAccountId)
            .execute(client)
    ).tokens.get(nftId);

    const treasuryNFTBalanceAfter = (
        await new AccountBalanceQuery()
            .setAccountId(treasuryAccountId)
            .execute(client)
    ).tokens.get(nftId);

    console.log("TokenReject response:", tokenRejectStatus);
    console.log("TokenRejectFlow response:", tokenRejectFlowStatus);
    console.log("Receiver FT balance: ", receiverFTBalanceAfter.toInt());
    console.log("Treasury FT balance: ", treasuryFTBalanceAfter.toInt());
    console.log(
        "Receiver NFT balance: ",
        receiverNFTBalanceAfter ? receiverNFTBalanceAfter.toInt() : 0,
    );
    console.log("Treasury NFT balance: ", treasuryNFTBalanceAfter.toInt());

    client.close();
}

void main();
// Filename: examples/topic-message-submit-get-all-chunks-status.js
import {
    Client,
    PrivateKey,
    AccountId,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
    TransactionReceiptQuery,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    /* Source and context:https://github.com/hiero-ledger/hiero-sdk-js/issues/1333

        In when we are submiting a message to a topic ID, if this message is large, the SDK is separating it on chunks:
            -   The default max chunks are set to 20
            -   If the message is too large, the user needs to set the default max chunks
            -   If the user uses the execute, and get receipt, the receipt is only returned on the first transaction
            -   The user can use executeAll and then as showed in this example, to track every chunk transaction status. 
    */
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const client = Client.forName(process.env.HEDERA_NETWORK).setOperator(
        AccountId.fromString(process.env.OPERATOR_ID),
        PrivateKey.fromStringDer(process.env.OPERATOR_KEY),
    );

    try {
        const response = await new TopicCreateTransaction()
            .setTopicMemo("sdk example create_pub_sub.js")
            .execute(client);

        const receipt = await response.getReceipt(client);
        const topicId = receipt.topicId;

        console.log(`topicId = ${topicId.toString()}`);

        const txMessage = await new TopicMessageSubmitTransaction()
            .setNodeAccountIds([response.nodeId])
            .setTopicId(topicId)
            .setMessage(bigContents)
            .executeAll(client);

        for (let index = 0; index < txMessage.length; index++) {
            const txReceipt = await new TransactionReceiptQuery()
                .setTransactionId(txMessage[index].transactionId)
                .setIncludeChildren(true)
                .execute(client);

            console.log(
                `Status for transaction with ID ${
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    txMessage[index].transactionId
                } is ${txReceipt.status.toString()}`,
            );
        }
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();

const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`;
// Filename: examples/transfer-tokens.js
import {
    AccountCreateTransaction,
    AccountDeleteTransaction,
    Wallet,
    LocalProvider,
    PrivateKey,
    Hbar,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenDeleteTransaction,
    TokenGrantKycTransaction,
    TransferTransaction,
    TokenWipeTransaction,
    TransactionId,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

async function main() {
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }

    const provider = new LocalProvider();

    const wallet = new Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const newKey = PrivateKey.generate();

    console.log(`private key = ${newKey.toString()}`);
    console.log(`public key = ${newKey.publicKey.toString()}`);

    try {
        let transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(newKey.publicKey)
            .setInitialBalance(new Hbar(2))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);
        let resp = await transaction.executeWithSigner(wallet);

        const transactionReceipt = await resp.getReceiptWithSigner(wallet);
        const newAccountId = transactionReceipt.accountId;

        console.log(`account id = ${newAccountId.toString()}`);

        let tokenCreateTransaction = await new TokenCreateTransaction()
            .setNodeAccountIds([resp.nodeId])
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(100)
            .setTreasuryAccountId(wallet.getAccountId())
            .setAdminKey(wallet.getAccountKey())
            .setFreezeKey(wallet.getAccountKey())
            .setWipeKey(wallet.getAccountKey())
            .setKycKey(wallet.getAccountKey())
            .setSupplyKey(wallet.getAccountKey())
            .setFreezeDefault(false)
            .freezeWithSigner(wallet);
        tokenCreateTransaction =
            await tokenCreateTransaction.signWithSigner(wallet);
        resp = await tokenCreateTransaction.executeWithSigner(wallet);

        const tokenId = (await resp.getReceiptWithSigner(wallet)).tokenId;
        console.log(`token id = ${tokenId.toString()}`);

        await (
            await (
                await (
                    await (
                        await new TokenAssociateTransaction()
                            .setNodeAccountIds([resp.nodeId])
                            .setAccountId(newAccountId)
                            .setTokenIds([tokenId])
                            .freezeWithSigner(wallet)
                    ).sign(newKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(
            `Associated account ${newAccountId.toString()} with token ${tokenId.toString()}`,
        );

        await (
            await (
                await (
                    await new TokenGrantKycTransaction()
                        .setNodeAccountIds([resp.nodeId])
                        .setAccountId(newAccountId)
                        .setTokenId(tokenId)
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(
            `Granted KYC for account ${newAccountId.toString()} on token ${tokenId.toString()}`,
        );

        await (
            await (
                await (
                    await new TransferTransaction()
                        .setNodeAccountIds([resp.nodeId])
                        .addTokenTransfer(tokenId, wallet.getAccountId(), -10)
                        .addTokenTransfer(tokenId, newAccountId, 10)
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(
            `Sent 10 tokens from account ${wallet
                .getAccountId()
                .toString()} to account ${newAccountId.toString()} on token ${tokenId.toString()}`,
        );

        await (
            await (
                await (
                    await new TokenWipeTransaction()
                        .setNodeAccountIds([resp.nodeId])
                        .setTokenId(tokenId)
                        .setAccountId(newAccountId)
                        .setAmount(10)
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(`Wiped balance of account ${newAccountId.toString()}`);

        await (
            await (
                await (
                    await new TokenDeleteTransaction()
                        .setNodeAccountIds([resp.nodeId])
                        .setTokenId(tokenId)
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(`Deleted token ${tokenId.toString()}`);

        await (
            await (
                await (
                    await (
                        await new AccountDeleteTransaction()
                            .setNodeAccountIds([resp.nodeId])
                            .setAccountId(newAccountId)
                            .setTransferAccountId(wallet.getAccountId())
                            .setTransactionId(
                                TransactionId.generate(newAccountId),
                            )
                            .setMaxTransactionFee(new Hbar(1))
                            .freezeWithSigner(wallet)
                    ).sign(newKey)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet)
        ).getReceiptWithSigner(wallet);

        console.log(`Deleted account ${newAccountId.toString()}`);
    } catch (error) {
        console.error(error);
    }

    provider.close();
}

void main();
// Filename: examples/transfer-using-evm-address.js
import {
    AccountId,
    PrivateKey,
    Client,
    TransferTransaction,
    AccountInfoQuery,
    TransactionReceiptQuery,
    TopicCreateTransaction,
} from "@hashgraph/sdk";

import dotenv from "dotenv";

dotenv.config();

/* 
Transfer HBAR or tokens to a Hedera account using their public-address.

Reference: [HIP-583 Expand alias support in CryptoCreate & CryptoTransfer Transactions](https://hips.hedera.com/hip/hip-583)

## Example 1
- Create an ECSDA private key 
- Extract the ECDSA public key
- Extract the Ethereum public address
  - Add function to calculate the Ethereum Address to example in SDK
  - Ethereum account address / public-address - This is the rightmost 20 bytes of the 32 byte Keccak-256 hash of the ECDSA public key of the account. This calculation is in the manner described by the Ethereum Yellow Paper.
- Transfer tokens using the `TransferTransaction` to the Ethereum Account Address
- The From field should be a complete account that has a public address
- The To field should be to a public address (to create a new account)
- Get the child receipt or child record to return the Hedera Account ID for the new account that was created
- Get the `AccountInfo` on the new account and show it is a hollow account by not having a public key
- This is a hollow account in this state
- Use the hollow account as a transaction fee payer in a HAPI transaction
- Sign the transaction with ECDSA private key
- Get the `AccountInfo` of the account and show the account is now a complete account by returning the public key on the account
*/

async function main() {
    if (process.env.OPERATOR_ID == null || process.env.OPERATOR_KEY == null) {
        throw new Error(
            "Environment variables OPERATOR_ID, and OPERATOR_KEY are required.",
        );
    }
    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);

    const nodes = {
        "127.0.0.1:50211": new AccountId(3),
    };

    const client = Client.forNetwork(nodes).setOperator(
        operatorId,
        operatorKey,
    );

    try {
        /**
         * Step 1
         *
         * Create an ECSDA private key
         */
        const privateKey = PrivateKey.generateECDSA();
        console.log(`Private key: ${privateKey.toStringDer()}`);

        /**
         * Step 2
         *
         * Extract the ECDSA public key
         */
        const publicKey = privateKey.publicKey;
        console.log(`Public key: ${publicKey.toStringDer()}`);

        /**
         *
         * Step 3
         *
         * Extract the Ethereum public address
         */
        const evmAddress = publicKey.toEvmAddress();
        console.log(`Corresponding evm address: ${evmAddress}`);

        /**
         * Step 4
         *
         * Transfer tokens using the `TransferTransaction` to the Etherеum Account Address
         *    - The From field should be a complete account that has a public address
         *    - The To field should be to a public address (to create a new account)
         */
        const transferTx = new TransferTransaction()
            .addHbarTransfer(operatorId, -10)
            .addHbarTransfer(evmAddress, 10)
            .freezeWith(client);

        const transferTxSign = await transferTx.sign(operatorKey);
        const transferTxSubmit = await transferTxSign.execute(client);

        /**
         * Step 5
         *
         * Get the child receipt or child record to return the Hedera Account ID for the new account that was created
         */
        const receipt = await new TransactionReceiptQuery()
            .setTransactionId(transferTxSubmit.transactionId)
            .setIncludeChildren(true)
            .execute(client);

        const newAccountId = receipt.children[0].accountId.toString();
        console.log(`Account ID of the newly created account: ${newAccountId}`);

        /**
         * Step 6
         *
         * Get the `AccountInfo` on the new account and show it is a hollow account by not having a public key
         */
        const hollowAccountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        hollowAccountInfo.key._toProtobufKey().keyList.keys.length == 0
            ? console.log(
                  `Account ${newAccountId} does not have public key, therefore it is a hollow account`,
              )
            : console.log(
                  `Account ${newAccountId} has a public key, therefore it is not a hollow account`,
              );

        /**
         * Step 7
         *
         * Use the hollow account as a transaction fee payer in a HAPI transaction
         */

        // set the accound id of the hollow account and its private key as an operator
        // in order to be a transaction fee payer in a HAPI transaction
        client.setOperator(newAccountId, privateKey);

        let transaction = new TopicCreateTransaction()
            .setTopicMemo("HIP-583")
            .freezeWith(client);

        /**
         * Step 8
         *
         * Sign the transaction with ECDSA private key
         */
        const transactionSign = await transaction.sign(privateKey);
        const transactionSubmit = await transactionSign.execute(client);
        const status = (
            await transactionSubmit.getReceipt(client)
        ).status.toString();
        console.log(`HAPI transaction status: ${status}`);

        /**
         * Step 9
         *
         * Get the `AccountInfo` of the account and show the account is now a complete account by returning the public key on the account
         */
        const completeAccountInfo = await new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);
        completeAccountInfo.key !== null
            ? console.log(
                  `The public key of the newly created and now complete account: ${completeAccountInfo.key.toString()}`,
              )
            : console.log(`Account ${newAccountId} is still a hollow account`);
    } catch (error) {
        console.error(error);
    }

    client.close();
}

void main();
// Filename: examples/update-fungible-token-metadata-with-admin-key.js
import {
    TokenCreateTransaction,
    TokenInfoQuery,
    TokenType,
    PrivateKey,
    Client,
    AccountId,
    TokenUpdateTransaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

dotenv.config();

/**
 * @summary E2E-HIP-646 https://hips.hedera.com/hip/hip-646
 * @description Update fungible token metadata with admin key
 */
async function main() {
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
    const network = process.env.HEDERA_NETWORK;
    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Generate a admin key
    const adminKey = PrivateKey.generateED25519();
    // Initial metadata
    const metadata = new Uint8Array([1]);
    // New metadata
    const newMetadata = new Uint8Array([1, 2]);

    let tokenInfo;

    try {
        // Create a non fungible token
        let createTokenTx = new TokenCreateTransaction()
            .setTokenName("Test")
            .setTokenSymbol("T")
            .setMetadata(metadata)
            .setTokenType(TokenType.FungibleCommon) // The same flow can be executed with a TokenType.NON_FUNGIBLE_UNIQUE (i.e. HIP-765)
            .setDecimals(3)
            .setInitialSupply(10000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(adminKey)
            .freezeWith(client);

        // Sign and execute create token transaction
        const tokenCreateTxResponse = await (
            await createTokenTx.sign(adminKey)
        ).execute(client);

        // Get receipt for create token transaction
        const tokenCreateTxReceipt =
            await tokenCreateTxResponse.getReceipt(client);
        console.log(
            `Status of token create transction: ${tokenCreateTxReceipt.status.toString()}`,
        );

        // Get token id
        const tokenId = tokenCreateTxReceipt.tokenId;
        console.log(`Token id: ${tokenId.toString()}`);

        // Get token info
        tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.log(`Token metadata:`, tokenInfo.metadata);

        const tokenUpdateTx = new TokenUpdateTransaction()
            .setTokenId(tokenId)
            .setMetadata(newMetadata)
            .freezeWith(client);

        // Sign transactions with admin key and execute it
        const tokenUpdateTxResponse = await (
            await tokenUpdateTx.sign(adminKey)
        ).execute(client);

        // Get receipt for token update transaction
        const tokenUpdateTxReceipt =
            await tokenUpdateTxResponse.getReceipt(client);
        console.log(
            `Status of token update transction: ${tokenUpdateTxReceipt.status.toString()}`,
        );

        tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.log(`Token updated metadata:`, tokenInfo.metadata);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/update-fungible-token-metadata-with-metadata-key.js
import {
    TokenCreateTransaction,
    TokenInfoQuery,
    TokenType,
    PrivateKey,
    Client,
    AccountId,
    TokenUpdateTransaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

dotenv.config();

/**
 * @summary E2E-HIP-646 https://hips.hedera.com/hip/hip-646
 * @description Update fungible token metadata with metadata key
 */
async function main() {
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
    const network = process.env.HEDERA_NETWORK;
    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Generate a metadata key
    const metadataKey = PrivateKey.generateED25519();
    // Initial metadata
    const metadata = new Uint8Array([1]);
    // New metadata
    const newMetadata = new Uint8Array([1, 2]);

    let tokenInfo;

    try {
        // Create a non fungible token
        let createTokenTx = new TokenCreateTransaction()
            .setTokenName("Test")
            .setTokenSymbol("T")
            .setMetadata(metadata)
            .setTokenType(TokenType.FungibleCommon) // The same flow can be executed with a TokenType.NON_FUNGIBLE_UNIQUE (i.e. HIP-765)
            .setDecimals(3)
            .setInitialSupply(10000)
            .setTreasuryAccountId(operatorId)
            .setMetadataKey(metadataKey)
            .freezeWith(client);

        // Sign and execute create token transaction
        const tokenCreateTxResponse = await (
            await createTokenTx.sign(operatorKey)
        ).execute(client);

        // Get receipt for create token transaction
        const tokenCreateTxReceipt =
            await tokenCreateTxResponse.getReceipt(client);
        console.log(
            `Status of token create transction: ${tokenCreateTxReceipt.status.toString()}`,
        );

        // Get token id
        const tokenId = tokenCreateTxReceipt.tokenId;
        console.log(`Token id: ${tokenId.toString()}`);

        // Get token info
        tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.log(`Token metadata:`, tokenInfo.metadata);

        const tokenUpdateTx = new TokenUpdateTransaction()
            .setTokenId(tokenId)
            .setMetadata(newMetadata)
            .freezeWith(client);

        // Sign transactions with metadata key and execute it
        const tokenUpdateTxResponse = await (
            await tokenUpdateTx.sign(metadataKey)
        ).execute(client);

        // Get receipt for token update transaction
        const tokenUpdateTxReceipt =
            await tokenUpdateTxResponse.getReceipt(client);
        console.log(
            `Status of token update transction: ${tokenUpdateTxReceipt.status.toString()}`,
        );

        tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.log(`Token updated metadata:`, tokenInfo.metadata);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/update-nfts-metadata-of-non-fungible-token.js
import {
    TokenCreateTransaction,
    TokenInfoQuery,
    TokenType,
    PrivateKey,
    Client,
    AccountId,
    TokenMintTransaction,
    TokenUpdateNftsTransaction,
    TokenNftInfoQuery,
    NftId,
    AccountCreateTransaction,
    Hbar,
    TransferTransaction,
    TokenAssociateTransaction,
} from "@hashgraph/sdk";
import dotenv from "dotenv";

dotenv.config();

/**
 * @summary E2E-HIP-657 https://hips.hedera.com/hip/hip-657
 * @description Update nfts metadata of fungible token with metadata key
 */
async function main() {
    if (
        !process.env.OPERATOR_KEY ||
        !process.env.OPERATOR_ID ||
        !process.env.HEDERA_NETWORK
    ) {
        throw new Error("Please set required keys in .env file.");
    }

    const operatorId = AccountId.fromString(process.env.OPERATOR_ID);
    const operatorKey = PrivateKey.fromStringDer(process.env.OPERATOR_KEY);
    const network = process.env.HEDERA_NETWORK;
    const client = Client.forName(network).setOperator(operatorId, operatorKey);

    // Generate a metadata key
    const metadataKey = PrivateKey.generateED25519();
    // Generate a supply key
    const supplyKey = PrivateKey.generateED25519();
    // Initial metadata
    const metadata = new Uint8Array([1]);
    // New metadata
    const newMetadata = new Uint8Array([1, 2]);

    let tokenNftsInfo, nftInfo;

    try {
        // Create a non fungible token
        let createTokenTx = new TokenCreateTransaction()
            .setTokenName("Test")
            .setTokenSymbol("T")
            .setTokenType(TokenType.NonFungibleUnique)
            .setTreasuryAccountId(operatorId)
            .setSupplyKey(supplyKey)
            .setMetadataKey(metadataKey)
            .freezeWith(client);

        // Sign and execute create token transaction
        const tokenCreateTxResponse = await (
            await createTokenTx.sign(operatorKey)
        ).execute(client);

        // Get receipt for create token transaction
        const tokenCreateTxReceipt =
            await tokenCreateTxResponse.getReceipt(client);
        console.log(
            `Status of token create transction: ${tokenCreateTxReceipt.status.toString()}`,
        );

        // Get token id
        const tokenId = tokenCreateTxReceipt.tokenId;
        console.log(`Token id: ${tokenId.toString()}`);

        // Get token info
        const tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(client);
        console.log(`Token metadata key: ${tokenInfo.metadataKey?.toString()}`);

        // Mint token
        const tokenMintTx = new TokenMintTransaction()
            .setMetadata([metadata])
            .setTokenId(tokenId)
            .freezeWith(client);

        const tokenMintTxResponse = await (
            await tokenMintTx.sign(supplyKey)
        ).execute(client);
        const tokenMintTxReceipt = await tokenMintTxResponse.getReceipt(client);
        console.log(
            `Status of token mint transction: ${tokenMintTxReceipt.status.toString()}`,
        );

        const nftSerial = tokenMintTxReceipt.serials[0];

        // Get TokenNftInfo to show the metadata on the NFT created
        tokenNftsInfo = await new TokenNftInfoQuery()
            .setNftId(new NftId(tokenId, nftSerial))
            .execute(client);
        nftInfo = tokenNftsInfo[0];
        console.log(`Set token NFT metadata:`, nftInfo.metadata);

        // Create an account to transfer the NFT to
        const accountCreateTx = new AccountCreateTransaction()
            .setKeyWithoutAlias(operatorKey)
            .setMaxAutomaticTokenAssociations(10)
            .setInitialBalance(new Hbar(100))
            .freezeWith(client);

        const accountCreateTxResponse = await (
            await accountCreateTx.sign(operatorKey)
        ).execute(client);
        const accountCreateTxReceipt =
            await accountCreateTxResponse.getReceipt(client);
        const newAccountId = accountCreateTxReceipt.accountId;
        console.log(`New account id: ${newAccountId.toString()}`);

        const tokenAssociateTx = new TokenAssociateTransaction()
            .setAccountId(newAccountId)
            .setTokenIds([tokenId])
            .freezeWith(client);

        const tokenAssociateTxResponse = await (
            await tokenAssociateTx.sign(operatorKey)
        ).execute(client);
        const tokenAssociateTxReceipt =
            await tokenAssociateTxResponse.getReceipt(client);
        console.log(
            `Status of token associate transaction: ${tokenAssociateTxReceipt.status.toString()}`,
        );

        // Transfer nft to the new account
        const transferNftTx = new TransferTransaction()
            .addNftTransfer(tokenId, nftSerial, operatorId, newAccountId)
            .freezeWith(client);

        const transferNftTxResponse = await (
            await transferNftTx.sign(operatorKey)
        ).execute(client);
        const transferNftTxReceipt =
            await transferNftTxResponse.getReceipt(client);
        console.log(
            `Status of transfer NFT transaction: ${transferNftTxReceipt.status.toString()}`,
        );

        // Update nfts metadata
        const tokenUpdateNftsTx = new TokenUpdateNftsTransaction()
            .setTokenId(tokenId)
            .setSerialNumbers([nftSerial])
            .setMetadata(newMetadata)
            .freezeWith(client);

        const tokenUpdateNftsTxResponse = await (
            await tokenUpdateNftsTx.sign(metadataKey)
        ).execute(client);
        const tokenUpdateNftsTxReceipt =
            await tokenUpdateNftsTxResponse.getReceipt(client);
        console.log(
            `Status of token update nfts transction: ${tokenUpdateNftsTxReceipt.status.toString()}`,
        );

        // Get token nfts info in order to show the metadata on the NFT created
        tokenNftsInfo = await new TokenNftInfoQuery()
            .setNftId(new NftId(tokenId, nftSerial))
            .execute(client);
        nftInfo = tokenNftsInfo[0];
        console.log(`Updated token NFT metadata:`, nftInfo.metadata);
    } catch (error) {
        console.log(error);
    }

    client.close();
}

void main();
// Filename: examples/zeroTokenOperations.js
// This example is for HIP-564 described here: https://hips.hedera.com/hip/hip-564

import * as hashgraph from "@hashgraph/sdk";
import ContractHelper from "./ContractHelper.js";
import contract from "./precompile-example/ZeroTokenOperations.json" with { type: "json" };
import dotenv from "dotenv";

dotenv.config();

//Steps 1-5 are executed through ContractHelper and calling HIP564Example Contract.
//Step 6 is executed through the SDK

async function main() {
    // Keys should be ED25519
    // TODO: Fix the wallet to work with ECDSA
    if (
        process.env.OPERATOR_ID == null ||
        process.env.OPERATOR_KEY == null ||
        process.env.HEDERA_NETWORK == null
    ) {
        throw new Error(
            "Environment variables OPERATOR_ID, HEDERA_NETWORK, and OPERATOR_KEY are required.",
        );
    }
    const myAccountId = hashgraph.AccountId.fromString(process.env.OPERATOR_ID);

    const provider = new hashgraph.LocalProvider();
    const aliceProvider = new hashgraph.LocalProvider();

    const wallet = new hashgraph.Wallet(
        process.env.OPERATOR_ID,
        process.env.OPERATOR_KEY,
        provider,
    );

    const operatorPrivateKey = hashgraph.PrivateKey.fromStringDer(
        process.env.OPERATOR_KEY,
    );
    const operatorPublicKey = operatorPrivateKey.publicKey;

    const operatorAccountId = hashgraph.AccountId.fromString(
        process.env.OPERATOR_ID,
    );

    const alicePrivateKey = hashgraph.PrivateKey.generateED25519();
    const alicePublicKey = alicePrivateKey.publicKey;

    try {
        let transaction = await new hashgraph.AccountCreateTransaction()
            .setKeyWithoutAlias(alicePublicKey)
            .setInitialBalance(hashgraph.Hbar.fromString("10"))
            .freezeWithSigner(wallet);
        transaction = await transaction.signWithSigner(wallet);

        let response = await transaction.executeWithSigner(wallet);
        const aliceAccountId = (await response.getReceiptWithSigner(wallet))
            .accountId;

        const walletWithAlice = new hashgraph.Wallet(
            aliceAccountId,
            alicePrivateKey,
            aliceProvider,
        );

        // Instantiate ContractHelper

        // The contract bytecode is located on the `object` field
        const contractBytecode = /** @type {string} */ (
            contract.bytecode.object
        );

        const contractHelper = await ContractHelper.init(
            contractBytecode,
            new hashgraph.ContractFunctionParameters()
                .addAddress(wallet.getAccountId().toSolidityAddress())
                .addAddress(aliceAccountId.toSolidityAddress()),
            wallet,
        );

        // Update the signer to have contractId KeyList (this is by security requirement)
        let accountUpdateOpratorTransaction =
            await new hashgraph.AccountUpdateTransaction()
                .setAccountId(operatorAccountId)
                .setKey(
                    new hashgraph.KeyList(
                        [operatorPublicKey, contractHelper.contractId],
                        1,
                    ),
                )
                .freezeWithSigner(wallet);
        accountUpdateOpratorTransaction =
            await accountUpdateOpratorTransaction.signWithSigner(wallet);
        await accountUpdateOpratorTransaction.executeWithSigner(wallet);

        // Update the Alice account to have contractId KeyList (this is by security requirement)
        let accountUpdateAliceTransaction =
            await new hashgraph.AccountUpdateTransaction()
                .setAccountId(aliceAccountId)
                .setKey(
                    new hashgraph.KeyList(
                        [alicePublicKey, contractHelper.contractId],
                        1,
                    ),
                )
                .freezeWithSigner(walletWithAlice);
        accountUpdateAliceTransaction =
            await accountUpdateAliceTransaction.signWithSigner(walletWithAlice);
        await accountUpdateAliceTransaction.executeWithSigner(walletWithAlice);

        // Configure steps in ContracHelper
        contractHelper
            .setPayableAmountForStep(0, new hashgraph.Hbar(40))
            .addSignerForStep(1, alicePrivateKey);
        // step 0 creates a fungible token
        // step 1 Associate with account
        // step 2 transfer the token by passing a zero value
        // step 3 mint the token by passing a zero value
        // step 4 burn the token by passing a zero value
        // step 5 wipe the token by passing a zero value
        // step 6 use SDK and transfer passing a zero value

        await contractHelper.executeSteps(
            /* from step */ 0,
            /* to step */ 5,
            wallet,
        );

        // step 6 use SDK and transfer passing a zero value
        //Create Fungible Token
        console.log(`Attempting to execute step 6`);

        let tokenCreateTransaction =
            await new hashgraph.TokenCreateTransaction()
                .setTokenName("Black Sea LimeChain Token")
                .setTokenSymbol("BSL")
                .setTreasuryAccountId(myAccountId)
                .setInitialSupply(10000) // Total supply = 10000 / 10 ^ 2
                .setDecimals(2)
                .setAutoRenewAccountId(myAccountId)
                .freezeWithSigner(wallet);

        tokenCreateTransaction =
            await tokenCreateTransaction.signWithSigner(wallet);
        let responseTokenCreate =
            await tokenCreateTransaction.executeWithSigner(wallet);
        const tokenId = (await responseTokenCreate.getReceiptWithSigner(wallet))
            .tokenId;

        //Associate Token with Account
        // Accounts on hedera have to opt in to receive any types of token that aren't HBAR
        const tokenAssociateTransaction =
            await new hashgraph.TokenAssociateTransaction()
                .setAccountId(aliceAccountId)
                .setTokenIds([tokenId])
                .freezeWithSigner(walletWithAlice);

        const signedTxForAssociateToken =
            await tokenAssociateTransaction.signWithSigner(walletWithAlice);
        const txResponseAssociatedToken =
            await signedTxForAssociateToken.executeWithSigner(wallet);
        const status = (
            await txResponseAssociatedToken.getReceiptWithSigner(wallet)
        ).status;

        console.log("Associate Status", status.toString());

        //Transfer token
        const transferToken = await new hashgraph.TransferTransaction()
            .addTokenTransfer(tokenId, myAccountId, 0) // deduct 0 tokens
            .addTokenTransfer(tokenId, aliceAccountId, 0) // increase balance by 0
            .freezeWithSigner(wallet);

        const signedTransferTokenTX =
            await transferToken.signWithSigner(wallet);
        const txResponseTransferToken =
            await signedTransferTokenTX.executeWithSigner(wallet);

        //Verify the transaction reached consensus
        const transferReceipRecord =
            await txResponseTransferToken.getRecordWithSigner(wallet);

        console.log(
            `step 6 completed, and returned valid result. (TransactionId "${transferReceipRecord.transactionId.toString()}")`,
        );

        console.log("All steps completed with valid results.");
    } catch (error) {
        console.error(error);
    }

    provider.close();
    aliceProvider.close();
}

void main();
// Filename: packages/cryptography/src/BadKeyError.js
/**
 * Signals that a key could not be realized from the input.
 */
export default class BadKeyError extends Error {
    /**
     * @param {Error | string} messageOrCause
     */
    constructor(messageOrCause) {
        super(
            messageOrCause instanceof Error
                ? messageOrCause.message
                : messageOrCause,
        );

        this.name = "BadKeyError";

        if (messageOrCause instanceof Error) {
            /** @type {Error=} */
            this.cause = messageOrCause;
            this.stack = messageOrCause.stack;
        }
    }
}
// Filename: packages/cryptography/src/BadMnemonicError.js
/** @typedef {import("./Mnemonic.js").default} Mnemonic */
import BadMnemonicReason from "./BadMnemonicReason.js";

export default class BadMnemonicError extends Error {
    /**
     * @param {Mnemonic} mnemonic
     * @param {string} reason
     * @param {number[]} unknownWordIndices
     * @hideconstructor
     */
    constructor(mnemonic, reason, unknownWordIndices) {
        let reasonMessage;

        switch (reason) {
            case BadMnemonicReason.BadLength:
                reasonMessage = "mnemonic is of an unexpected number of words";
                break;

            case BadMnemonicReason.ChecksumMismatch:
                reasonMessage =
                    "checksum byte in mnemonic did not match the rest of the mnemonic";
                break;

            case BadMnemonicReason.UnknownWords:
                reasonMessage =
                    "mnemonic contained words that are not in the standard word list";
                break;

            default:
                throw new Error(
                    `unexpected value ${reason.toString()} for 'reason'`,
                );
        }

        super(`invalid mnemonic: ${reasonMessage}`);

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, BadMnemonicError);
        }

        this.name = "BadMnemonicError";

        /** The reason for which the mnemonic failed validation. */
        this.reason = reason;

        /** The mnemonic that failed validation. */
        this.mnemonic = mnemonic;

        /**
         * The indices in the mnemonic that were not found in the BIP-39
         * standard English word list.
         */
        this.unknownWordIndices = unknownWordIndices;
    }
}
// Filename: packages/cryptography/src/BadMnemonicReason.js
/**
 * Possible statuses for {@link Mnemonic#validate()}.
 * @readonly
 * @enum {string}
 */
const BadMnemonicReason = Object.freeze({
    /**
     * The mnemonic did not have a supported number of words (12 or 24 for regular and 22 for legacy).
     */
    BadLength: "BadLength",

    /**
     * The mnemonic contained words which were not found in the word list.
     */
    UnknownWords: "UnknownWords",

    /**
     * The checksum encoded in the mnemonic did not match the checksum we just calculated for
     * that mnemonic.
     *
     * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
     * after being calculated from it, before being encoded into words.
     *
     * This could happen if two or more of the words were entered out of the original order or
     * replaced with another from the standard word list (as this is only returned if all the words
     * exist in the word list).
     */
    ChecksumMismatch: "ChecksumMismatch",
});

export default BadMnemonicReason;
// Filename: packages/cryptography/src/Cache.js
/**
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 * @typedef {import("./Ed25519PrivateKey.js").default} Ed25519PrivateKey
 * @typedef {import("./EcdsaPrivateKey.js").default} EcdsaPrivateKey
 * @typedef {import("./Mnemonic.js").default} Mnemonic
 */

const CACHE = {
    /** @type {((key: Ed25519PrivateKey | EcdsaPrivateKey) => PrivateKey) | null} */
    privateKeyConstructor: null,

    /** @type {((bytes: Uint8Array) => PrivateKey) | null} */
    privateKeyFromBytes: null,

    /** @type {((words: string) => Mnemonic) | null} */
    mnemonicFromString: null,
};

export default CACHE;
// Filename: packages/cryptography/src/EcdsaPrivateKey.js
import EcdsaPublicKey from "./EcdsaPublicKey.js";
import * as hex from "./encoding/hex.js";
import * as ecdsa from "./primitive/ecdsa.js";
import * as bip32 from "./primitive/bip32.js";
import { arrayStartsWith } from "./util/array.js";

const derPrefix = "3030020100300706052b8104000a04220420";
const derPrefixBytes = hex.decode(derPrefix);

const derPrefix2 = "30540201010420";
const derPrefixBytes2 = hex.decode(derPrefix2);

/**
 * @typedef {object} KeyPair
 * @property {Uint8Array} publicKey
 * @property {Uint8Array} privateKey
 */

export default class EcdsaPrivateKey {
    /**
     * @hideconstructor
     * @internal
     * @param {KeyPair} keyPair
     * @param {(Uint8Array)=} chainCode
     */
    constructor(keyPair, chainCode) {
        /**
         * @type {KeyPair}
         * @readonly
         * @private
         */
        this._keyPair = keyPair;

        /**
         * @type {?Uint8Array}
         * @readonly
         */
        this._chainCode = chainCode != null ? chainCode : null;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "secp256k1";
    }

    /**
     * Generate a random ECDSA private key.
     * @returns {EcdsaPrivateKey}
     */
    static generate() {
        return new EcdsaPrivateKey(ecdsa.generate());
    }

    /**
     * Generate a random Ed25519 private key.
     * @returns {Promise<EcdsaPrivateKey>}
     */
    static async generateAsync() {
        return new EcdsaPrivateKey(await ecdsa.generateAsync());
    }

    /**
     * Construct a private key from bytes.
     * @param {Uint8Array} data
     * @returns {EcdsaPrivateKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 32:
                return EcdsaPrivateKey.fromBytesRaw(data);
            default:
                return EcdsaPrivateKey.fromBytesDer(data);
        }
    }

    /**
     * Construct a private key from bytes.
     * @param {Uint8Array} data
     * @returns {EcdsaPrivateKey}
     */
    static fromBytesDer(data) {
        /** @type {Uint8Array} */
        let ecdsaPrivateKeyBytes = new Uint8Array();

        if (arrayStartsWith(data, derPrefixBytes)) {
            ecdsaPrivateKeyBytes = data.subarray(derPrefixBytes.length);
        } else {
            // For now, we assume that if we get to the `else` statement
            // the lengths of all other bytePrefixes is equal, so we treat them equally
            ecdsaPrivateKeyBytes = data.subarray(
                derPrefixBytes2.length,
                derPrefixBytes2.length + 32,
            );
        }

        return new EcdsaPrivateKey(ecdsa.fromBytes(ecdsaPrivateKeyBytes));
    }

    /**
     * Construct a private key from bytes.
     * @param {Uint8Array} data
     * @returns {EcdsaPrivateKey}
     */
    static fromBytesRaw(data) {
        return new EcdsaPrivateKey(ecdsa.fromBytes(data));
    }

    /**
     * Construct a private key from a hex-encoded string.
     * @param {string} text
     * @returns {EcdsaPrivateKey}
     */
    static fromString(text) {
        return EcdsaPrivateKey.fromBytes(hex.decode(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     * @param {string} text
     * @returns {EcdsaPrivateKey}
     */
    static fromStringDer(text) {
        return EcdsaPrivateKey.fromBytesDer(hex.decode(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     * @param {string} text
     * @returns {EcdsaPrivateKey}
     */
    static fromStringRaw(text) {
        return EcdsaPrivateKey.fromBytesRaw(hex.decode(text));
    }

    /**
     * Construct a ECDSA private key from a Uint8Array seed.
     * @param {Uint8Array} seed
     * @returns {Promise<EcdsaPrivateKey>}
     */
    static async fromSeed(seed) {
        const { keyData, chainCode } = await bip32.fromSeed(seed);
        return new EcdsaPrivateKey(ecdsa.fromBytes(keyData), chainCode);
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     * @returns {EcdsaPublicKey}
     */
    get publicKey() {
        return new EcdsaPublicKey(this._keyPair.publicKey);
    }

    /**
     * Sign a message with this private key.
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return ecdsa.sign(this._keyPair.privateKey, bytes);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(derPrefixBytes.length + 32);
        const privateKey = this._keyPair.privateKey.subarray(0, 32);
        const leadingZeroes = 32 - privateKey.length;
        const privateKeyOffset = derPrefixBytes.length + leadingZeroes;
        bytes.set(derPrefixBytes, 0);
        bytes.set(privateKey, privateKeyOffset);
        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        const privateKey = this._keyPair.privateKey.subarray(-32); // Takes the last 32 bytes (or fewer if shorter)
        const leadingZeroes = 32 - privateKey.length;
        const bytes = new Uint8Array(32);
        bytes.set(privateKey, leadingZeroes);
        return bytes;
    }
}
// Filename: packages/cryptography/src/EcdsaPublicKey.js
import Key from "./Key.js";
import BadKeyError from "./BadKeyError.js";
import { arrayEqual } from "./util/array.js";
import * as hex from "./encoding/hex.js";
import * as ecdsa from "./primitive/ecdsa.js";
import { keccak256 } from "./primitive/keccak.js";
import elliptic from "elliptic";
const ec = new elliptic.ec("secp256k1");

const legacyDerPrefix = "302d300706052b8104000a032200";
const legacyDerPrefixBytes = hex.decode(legacyDerPrefix);

const derPrefix = "3036301006072a8648ce3d020106052b8104000a032200";
const derPrefixBytes = hex.decode(derPrefix);

/**
 * An public key on the Hedera™ network.
 */
export default class EcdsaPublicKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {Uint8Array} keyData
     */
    constructor(keyData) {
        super();

        /**
         * @type {Uint8Array}
         * @private
         * @readonly
         */
        this._keyData = keyData;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "secp256k1";
    }

    /**
     * @param {Uint8Array} data
     * @returns {EcdsaPublicKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 33:
                return EcdsaPublicKey.fromBytesRaw(data);
            default:
                return EcdsaPublicKey.fromBytesDer(data);
        }
    }

    /**
     * @param {Uint8Array} data
     * @returns {EcdsaPublicKey}
     */
    static fromBytesDer(data) {
        /** @type {Uint8Array} */
        let ecdsaPublicKeyBytes = new Uint8Array();

        switch (data.length) {
            case 47: // In the case of legace DER prefix
                ecdsaPublicKeyBytes = data.subarray(
                    legacyDerPrefixBytes.length,
                );
                break;
            case 56: // The lengths of all other bytePrefixes is equal, so we treat them equally
                ecdsaPublicKeyBytes = data.subarray(
                    derPrefixBytes.length,
                    derPrefixBytes.length + 33,
                );
                break;
            default: // In the case of uncompressed DER prefix public keys
                /* eslint-disable no-case-declarations */
                const keyPair = ec.keyFromPublic(
                    data.subarray(derPrefixBytes.length),
                    "der",
                );

                const pk = keyPair.getPublic();

                const compressedPublicKeyBytes = pk.encodeCompressed("hex");
                ecdsaPublicKeyBytes = hex.decode(compressedPublicKeyBytes);
                break;
            /* eslint-enable no-case-declarations */
        }
        if (ecdsaPublicKeyBytes.length == 0) {
            throw new BadKeyError(
                `cannot decode ECDSA private key data from DER format`,
            );
        }
        return new EcdsaPublicKey(ecdsaPublicKeyBytes);
    }

    /**
     * @param {Uint8Array} data
     * @returns {EcdsaPublicKey}
     */
    static fromBytesRaw(data) {
        if (data.length != 33) {
            throw new BadKeyError(
                `invalid public key length: ${data.length} bytes`,
            );
        }

        return new EcdsaPublicKey(data);
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     * @param {string} text
     * @returns {EcdsaPublicKey}
     */
    static fromString(text) {
        return EcdsaPublicKey.fromBytes(hex.decode(text));
    }

    /**
     * Verify a signature on a message with this public key.
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return ecdsa.verify(this._keyData, message, signature);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(
            legacyDerPrefixBytes.length + this._keyData.length,
        );

        bytes.set(legacyDerPrefixBytes, 0);
        bytes.set(this._keyData, legacyDerPrefixBytes.length);

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return new Uint8Array(this._keyData.subarray());
    }

    /**
     * @returns {string}
     */
    toEthereumAddress() {
        const hash = hex.decode(
            keccak256(
                `0x${hex.encode(
                    ecdsa.getFullPublicKey(this.toBytesRaw()).subarray(1),
                )}`,
            ),
        );
        return hex.encode(hash.subarray(12));
    }

    /**
     * @param {EcdsaPublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        return arrayEqual(this._keyData, other._keyData);
    }
}
// Filename: packages/cryptography/src/Ed25519PrivateKey.js
import BadKeyError from "./BadKeyError.js";
import Ed25519PublicKey from "./Ed25519PublicKey.js";
import nacl from "tweetnacl";
import * as hex from "./encoding/hex.js";
import * as random from "./primitive/random.js";
import * as slip10 from "./primitive/slip10.js";

export const derPrefix = "302e020100300506032b657004220420";
export const derPrefixBytes = hex.decode(derPrefix);

export default class Ed25519PrivateKey {
    /**
     * @hideconstructor
     * @internal
     * @param {nacl.SignKeyPair | Uint8Array} keyPair
     * @param {Uint8Array=} chainCode
     */
    constructor(keyPair, chainCode) {
        /**
         * @type {nacl.SignKeyPair}
         * @readonly
         * @private
         */
        this._keyPair =
            keyPair instanceof Uint8Array
                ? nacl.sign.keyPair.fromSeed(keyPair)
                : keyPair;

        /**
         * @type {?Uint8Array}
         * @readonly
         */
        this._chainCode = chainCode != null ? chainCode : null;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "ED25519";
    }

    /**
     * Generate a random Ed25519 private key.
     * @returns {Ed25519PrivateKey}
     */
    static generate() {
        // 32 bytes for the secret key
        // 32 bytes for the chain code (to support derivation)
        const entropy = random.bytes(64);

        return new Ed25519PrivateKey(
            nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
            entropy.subarray(32),
        );
    }

    /**
     * Generate a random Ed25519 private key.
     * @returns {Promise<Ed25519PrivateKey>}
     */
    static async generateAsync() {
        // 32 bytes for the secret key
        // 32 bytes for the chain code (to support derivation)
        const entropy = await random.bytesAsync(64);

        return new Ed25519PrivateKey(
            nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
            entropy.subarray(32),
        );
    }

    /**
     * Construct a private key from bytes.
     * @param {Uint8Array} data
     * @returns {Ed25519PrivateKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 48:
                return Ed25519PrivateKey.fromBytesDer(data);
            case 32:
            case 64:
                return Ed25519PrivateKey.fromBytesRaw(data);
            default:
                throw new BadKeyError(
                    `invalid private key length: ${data.length} bytes`,
                );
        }
    }

    /**
     * Construct a private key from bytes with DER header.
     * @param {Uint8Array} data
     * @returns {Ed25519PrivateKey}
     */
    static fromBytesDer(data) {
        /** * @type {Uint8Array} */
        let privateKey;
        try {
            const arr = new Uint8Array(data);
            const header = arr.subarray(0, data.length - 32);
            const isValidED25519 = header.every((byte, index) => {
                return derPrefixBytes[index] === byte;
            });

            if (!isValidED25519) {
                throw new BadKeyError(
                    `invalid DER prefix for ED25519 private key`,
                );
            }

            privateKey = arr.slice(data.length - 32);
        } catch (error) {
            const message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";
            throw new BadKeyError(
                `cannot decode ED25519 private key data from DER format: ${message}`,
            );
        }

        const keyPair = nacl.sign.keyPair.fromSeed(privateKey);
        return new Ed25519PrivateKey(keyPair);
    }

    /**
     * Construct a private key from bytes without DER header.
     * @param {Uint8Array} data
     * @returns {Ed25519PrivateKey}
     */
    static fromBytesRaw(data) {
        switch (data.length) {
            case 32:
                return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(data));

            case 64:
                // priv + pub key
                return new Ed25519PrivateKey(
                    nacl.sign.keyPair.fromSecretKey(data),
                );

            default:
        }

        throw new BadKeyError(
            `invalid private key length: ${data.length} bytes`,
        );
    }

    /**
     * Construct a private key from a hex-encoded string.
     * @param {string} text
     * @returns {Ed25519PrivateKey}
     */
    static fromString(text) {
        return Ed25519PrivateKey.fromBytes(hex.decode(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     * @param {string} text
     * @returns {Ed25519PrivateKey}
     */
    static fromStringDer(text) {
        return Ed25519PrivateKey.fromBytesDer(hex.decode(text));
    }

    /**
     * Construct a private key from a hex-encoded string.
     * @param {string} text
     * @returns {Ed25519PrivateKey}
     */
    static fromStringRaw(text) {
        return Ed25519PrivateKey.fromBytesRaw(hex.decode(text));
    }

    /**
     * Construct a ED25519 private key from a Uint8Array seed.
     * @param {Uint8Array} seed
     * @returns {Promise<Ed25519PrivateKey>}
     */
    static async fromSeed(seed) {
        const { keyData, chainCode } = await slip10.fromSeed(seed);
        return new Ed25519PrivateKey(keyData, chainCode);
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     * @returns {Ed25519PublicKey}
     */
    get publicKey() {
        return new Ed25519PublicKey(this._keyPair.publicKey);
    }

    /**
     * Sign a message with this private key.
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return nacl.sign.detached(bytes, this._keyPair.secretKey);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(derPrefixBytes.length + 32);
        const privateKey = this._keyPair.secretKey.subarray(0, 32);
        const leadingZeroes = 32 - privateKey.length;
        const privateKeyOffset = derPrefixBytes.length + leadingZeroes;

        bytes.set(derPrefixBytes, 0);
        bytes.set(privateKey, privateKeyOffset);

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        // copy the bytes so they can't be modified accidentally
        return this._keyPair.secretKey.slice(0, 32);
    }
}
// Filename: packages/cryptography/src/Ed25519PublicKey.js
import Key from "./Key.js";
import BadKeyError from "./BadKeyError.js";
import nacl from "tweetnacl";
import { arrayEqual } from "./util/array.js";
import * as hex from "./encoding/hex.js";

const derPrefix = "302a300506032b6570032100";
const derPrefixBytes = hex.decode(derPrefix);

/**
 * An public key on the Hedera™ network.
 */
export default class Ed25519PublicKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {Uint8Array} keyData
     */
    constructor(keyData) {
        super();

        /**
         * @type {Uint8Array}
         * @private
         * @readonly
         */
        this._keyData = keyData;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return "ED25519";
    }

    /**
     * @param {Uint8Array} data
     * @returns {Ed25519PublicKey}
     */
    static fromBytes(data) {
        switch (data.length) {
            case 32:
                return Ed25519PublicKey.fromBytesRaw(data);
            case 44:
                return Ed25519PublicKey.fromBytesDer(data);
            default:
                throw new BadKeyError(
                    `invalid public key length: ${data.length} bytes`,
                );
        }
    }

    /**
     * @param {Uint8Array} data
     * @returns {Ed25519PublicKey}
     */
    static fromBytesDer(data) {
        try {
            // Verify minimum length (44 bytes is standard for Ed25519 public key in DER)
            if (data.length !== 44) {
                throw new Error(`invalid length: ${data.length} bytes`);
            }

            const actualPrefix = data.subarray(0, 12);

            if (!actualPrefix.every((byte, i) => byte === derPrefixBytes[i])) {
                throw new Error("invalid DER prefix");
            }
            // Extract the public key (last 32 bytes)
            const publicKey = data.subarray(12);
            return new Ed25519PublicKey(publicKey);
        } catch (error) {
            throw new BadKeyError(
                `cannot decode ED25519 public key data from DER format: ${
                    error instanceof Error ? error.message : "unknown error"
                }`,
            );
        }
    }

    /**
     * @param {Uint8Array} data
     * @returns {Ed25519PublicKey}
     */
    static fromBytesRaw(data) {
        if (data.length != 32) {
            throw new BadKeyError(
                `invalid public key length: ${data.length} bytes`,
            );
        }

        return new Ed25519PublicKey(data);
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     * @param {string} text
     * @returns {Ed25519PublicKey}
     */
    static fromString(text) {
        return Ed25519PublicKey.fromBytes(hex.decode(text));
    }

    /**
     * Verify a signature on a message with this public key.
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return nacl.sign.detached.verify(message, signature, this._keyData);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        const bytes = new Uint8Array(derPrefixBytes.length + 32);

        bytes.set(derPrefixBytes, 0);
        bytes.set(this._keyData.subarray(0, 32), derPrefixBytes.length);

        return bytes;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._keyData.slice();
    }

    /**
     * @param {Ed25519PublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        return arrayEqual(this._keyData, other._keyData);
    }
}
// Filename: packages/cryptography/src/Key.js
export default class Key {}
// Filename: packages/cryptography/src/KeyList.js
import Key from "./Key.js";

/**
 * A list of Keys (`Key`) with an optional threshold.
 */
export default class KeyList extends Key {
    /**
     * @param {?Key[]} [keys]
     * @param {?number} [threshold]
     */
    constructor(keys, threshold) {
        super();

        /**
         * @private
         * @type {Key[]}
         */
        // @ts-ignore
        if (keys == null) this._keys = [];
        //checks if the value for `keys` is passed as a single key
        //rather than a list that contains just one key
        else if (keys instanceof Key) this._keys = [keys];
        else this._keys = keys;

        /**
         * @type {?number}
         */
        this._threshold = threshold == null ? null : threshold;
    }

    /**
     * @param {Key[]} keys
     * @returns {KeyList}
     */
    static of(...keys) {
        return new KeyList(keys, null);
    }

    /**
     * @template T
     * @param {ArrayLike<Key>} arrayLike
     * @param {((key: Key) => Key)} [mapFn]
     * @param {T} [thisArg]
     * @returns {KeyList}
     */
    static from(arrayLike, mapFn, thisArg) {
        if (mapFn == null) {
            return new KeyList(Array.from(arrayLike));
        }

        return new KeyList(Array.from(arrayLike, mapFn, thisArg));
    }

    /**
     * @returns {?number}
     */
    get threshold() {
        return this._threshold;
    }

    /**
     * @param {number} threshold
     * @returns {this}
     */
    setThreshold(threshold) {
        this._threshold = threshold;
        return this;
    }

    /**
     * @param {Key[]} keys
     * @returns {number}
     */
    push(...keys) {
        return this._keys.push(...keys);
    }

    /**
     * @param {number} start
     * @param {number} deleteCount
     * @param {Key[]} items
     * @returns {KeyList}
     */
    splice(start, deleteCount, ...items) {
        return new KeyList(
            this._keys.splice(start, deleteCount, ...items),
            this.threshold,
        );
    }

    /**
     * @param {number=} start
     * @param {number=} end
     * @returns {KeyList}
     */
    slice(start, end) {
        return new KeyList(this._keys.slice(start, end), this.threshold);
    }

    /**
     * @returns {Iterator<Key>}
     */
    [Symbol.iterator]() {
        return this._keys[Symbol.iterator]();
    }

    /**
     * @returns {Key[]}
     */
    toArray() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this._keys.slice();
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify({
            threshold: this._threshold,
            keys: this._keys.toString(),
        });
    }
}
// Filename: packages/cryptography/src/Mnemonic.js
import CACHE from "./Cache.js";
import Ed25519PrivateKey from "./Ed25519PrivateKey.js";
import BadMnemonicError from "./BadMnemonicError.js";
import BadMnemonicReason from "./BadMnemonicReason.js";
import legacyWords from "./words/legacy.js";
import bip39Words from "./words/bip39.js";
import nacl from "tweetnacl";
import * as sha256 from "./primitive/sha256.js";
import * as hmac from "./primitive/hmac.js";
import * as slip10 from "./primitive/slip10.js";
import * as bip32 from "./primitive/bip32.js";
import * as bip39 from "./primitive/bip39.js";
import * as entropy from "./util/entropy.js";
import * as random from "./primitive/random.js";
import EcdsaPrivateKey from "./EcdsaPrivateKey.js";
import PrivateKey from "./PrivateKey.js";
import * as ecdsa from "./primitive/ecdsa.js";

const ED25519_SEED_TEXT = "ed25519 seed";
const ECDSA_SEED_TEXT = "Bitcoin seed";

export const HARDENED = 0x80000000;

/// m/44'/3030'/0'/0' - All paths in EdDSA derivation are implicitly hardened.
export const HEDERA_PATH = [44, 3030, 0, 0];

/// m/44'/3030'/0'/0
export const SLIP44_ECDSA_HEDERA_PATH = [
    44 | HARDENED,
    3030 | HARDENED,
    0 | HARDENED,
    0,
];

/// m/44'/60'/0'/0
export const SLIP44_ECDSA_ETH_PATH = [
    44 | HARDENED,
    60 | HARDENED,
    0 | HARDENED,
    0,
    0,
];

/**
 * Multi-word mnemonic phrase (BIP-39).
 *
 * Compatible with the official Hedera mobile
 * wallets (24-words or 22-words) and BRD (12-words).
 */
export default class Mnemonic {
    /**
     * @param {object} props
     * @param {string[]} props.words
     * @throws {BadMnemonicError}
     * @hideconstructor
     * @private
     */
    constructor({ words }) {
        this.words = words;
    }

    /**
     * Returns a new random 24-word mnemonic from the BIP-39
     * standard English word list.
     * @returns {Promise<Mnemonic>}
     */
    static generate() {
        return Mnemonic._generate(24);
    }

    /**
     * Returns a new random 12-word mnemonic from the BIP-39
     * standard English word list.
     * @returns {Promise<Mnemonic>}
     */
    static generate12() {
        return Mnemonic._generate(12);
    }

    /**
     * @param {number} length
     * @returns {Promise<Mnemonic>}
     */
    static async _generate(length) {
        // only 12-word or 24-word lengths are supported
        let neededEntropy;

        if (length === 12) neededEntropy = 16;
        else if (length === 24) neededEntropy = 32;
        else {
            throw new Error(
                `unsupported phrase length ${length}, only 12 or 24 are supported`,
            );
        }

        // inlined from (ISC) with heavy alternations for modern crypto
        // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125
        const seed = await random.bytesAsync(neededEntropy);
        const entropyBits = bytesToBinary(Array.from(seed));
        const checksumBits = await deriveChecksumBits(seed);
        const bits = entropyBits + checksumBits;
        const chunks = bits.match(/(.{1,11})/g);

        const words = (chunks != null ? chunks : []).map(
            (binary) => bip39Words[binaryToByte(binary)],
        );

        return new Mnemonic({ words });
    }

    /**
     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
     *
     * An exception of BadMnemonicError will be thrown if the mnemonic
     * contains unknown words or fails the checksum. An invalid mnemonic
     * can still be used to create private keys, the exception will
     * contain the failing mnemonic in case you wish to ignore the
     * validation error and continue.
     * @param {string[]} words
     * @throws {BadMnemonicError}
     * @returns {Promise<Mnemonic>}
     */
    static fromWords(words) {
        return new Mnemonic({
            words,
        })._validate();
    }

    /**
     * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
     * Recover a private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    toPrivateKey(passphrase = "") {
        // eslint-disable-next-line deprecation/deprecation
        return this.toEd25519PrivateKey(passphrase);
    }

    /**
     * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
     * Recover an Ed25519 private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @param {number[]} [path]
     * @returns {Promise<PrivateKey>}
     */
    async toEd25519PrivateKey(passphrase = "", path = HEDERA_PATH) {
        let { keyData, chainCode } = await this._toKeyData(
            passphrase,
            ED25519_SEED_TEXT,
        );

        for (const index of path) {
            ({ keyData, chainCode } = await slip10.derive(
                keyData,
                chainCode,
                index,
            ));
        }

        const keyPair = nacl.sign.keyPair.fromSeed(keyData);

        if (CACHE.privateKeyConstructor == null) {
            throw new Error("PrivateKey not found in cache");
        }

        return CACHE.privateKeyConstructor(
            new Ed25519PrivateKey(keyPair, chainCode),
        );
    }

    /**
     * Recover an Ed25519 private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @param {number} [index]
     * @returns {Promise<PrivateKey>}
     */
    async toStandardEd25519PrivateKey(passphrase = "", index) {
        const seed = await Mnemonic.toSeed(this.words, passphrase);
        let derivedKey = await PrivateKey.fromSeedED25519(seed);
        index = index == null ? 0 : index;

        for (const currentIndex of [44, 3030, 0, 0, index]) {
            derivedKey = await derivedKey.derive(currentIndex);
        }

        return derivedKey;
    }

    /**
     * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
     * Recover an ECDSA private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @param {number[]} [path]
     * @returns {Promise<PrivateKey>}
     */
    async toEcdsaPrivateKey(passphrase = "", path = HEDERA_PATH) {
        let { keyData, chainCode } = await this._toKeyData(
            passphrase,
            ECDSA_SEED_TEXT,
        );

        for (const index of path) {
            ({ keyData, chainCode } = await bip32.derive(
                keyData,
                chainCode,
                index,
            ));
        }

        if (CACHE.privateKeyConstructor == null) {
            throw new Error("PrivateKey not found in cache");
        }

        return CACHE.privateKeyConstructor(
            new EcdsaPrivateKey(ecdsa.fromBytes(keyData), chainCode),
        );
    }

    /**
     * Recover an ECDSA private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @param {number} [index]
     * @returns {Promise<PrivateKey>}
     */
    async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
        const seed = await Mnemonic.toSeed(this.words, passphrase);
        let derivedKey = await PrivateKey.fromSeedECDSAsecp256k1(seed);
        index = index == null ? 0 : index;

        for (const currentIndex of [
            bip32.toHardenedIndex(44),
            bip32.toHardenedIndex(3030),
            bip32.toHardenedIndex(0),
            0,
            index,
        ]) {
            derivedKey = await derivedKey.derive(currentIndex);
        }

        return derivedKey;
    }

    /**
     * @param {string[]} words
     * @param {string} passphrase
     * @returns {Promise<Uint8Array>}
     */
    static async toSeed(words, passphrase) {
        return await bip39.toSeed(words, passphrase);
    }

    /**
     * @param {string} passphrase
     * @param {string} seedText
     * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>} seedText
     */
    async _toKeyData(passphrase, seedText) {
        const seed = await bip39.toSeed(this.words, passphrase);
        const digest = await hmac.hash(
            hmac.HashAlgorithm.Sha512,
            seedText,
            seed,
        );

        return {
            keyData: digest.subarray(0, 32),
            chainCode: digest.subarray(32),
        };
    }

    /**
     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
     * @param {string} mnemonic
     * @returns {Promise<Mnemonic>}
     */
    static async fromString(mnemonic) {
        return Mnemonic.fromWords(mnemonic.split(/\s|,/));
    }

    /**
     * @returns {Promise<Mnemonic>}
     * @private
     */
    async _validate() {
        //NOSONAR
        // Validate that this is a valid BIP-39 mnemonic
        // as generated by BIP-39's rules.

        // Technically, invalid mnemonics can still be used to generate valid private keys,
        // but if they became invalid due to user error then it will be difficult for the user
        // to tell the difference unless they compare the generated keys.

        // During validation, the following conditions are checked in order

        //  1)) 24 or 12 words

        //  2) All strings in {@link this.words} exist in the BIP-39
        //     standard English word list (no normalization is done)

        //  3) The calculated checksum for the mnemonic equals the
        //     checksum encoded in the mnemonic

        // If words count is 22, it means that this is a legacy private key
        if (this.words.length === 22) {
            const unknownWordIndices = this.words.reduce(
                (/** @type {number[]} */ unknowns, word, index) =>
                    legacyWords.includes(word.toLowerCase())
                        ? unknowns
                        : [...unknowns, index],
                [],
            );

            if (unknownWordIndices.length > 0) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.UnknownWords,
                    unknownWordIndices,
                );
            }

            const [seed, checksum] = entropy.legacy1(this.words, legacyWords);
            const newChecksum = entropy.crc8(seed);

            if (checksum !== newChecksum) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.ChecksumMismatch,
                    [],
                );
            }
        } else {
            if (!(this.words.length === 12 || this.words.length === 24)) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.BadLength,
                    [],
                );
            }

            const unknownWordIndices = this.words.reduce(
                (/** @type {number[]} */ unknowns, word, index) =>
                    bip39Words.includes(word) ? unknowns : [...unknowns, index],
                [],
            );

            if (unknownWordIndices.length > 0) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.UnknownWords,
                    unknownWordIndices,
                );
            }

            // FIXME: calculate checksum and compare
            // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112

            const bits = this.words
                .map((word) => {
                    return bip39Words
                        .indexOf(word)
                        .toString(2)
                        .padStart(11, "0");
                })
                .join("");

            const dividerIndex = Math.floor(bits.length / 33) * 32;
            const entropyBits = bits.slice(0, dividerIndex);
            const checksumBits = bits.slice(dividerIndex);
            const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
            const entropyBytes = /** @type {RegExpMatchArray} */ (
                entropyBitsRegex
            ).map(binaryToByte);

            const newChecksum = await deriveChecksumBits(
                Uint8Array.from(entropyBytes),
            );

            if (newChecksum !== checksumBits) {
                throw new BadMnemonicError(
                    this,
                    BadMnemonicReason.ChecksumMismatch,
                    [],
                );
            }
        }

        return this;
    }

    /**
     * @returns {Promise<PrivateKey>}
     */
    async toLegacyPrivateKey() {
        let seed;
        if (this.words.length === 22) {
            [seed] = entropy.legacy1(this.words, legacyWords);
        } else {
            seed = await entropy.legacy2(this.words, bip39Words);
        }

        if (CACHE.privateKeyFromBytes == null) {
            throw new Error("PrivateKey not found in cache");
        }

        return CACHE.privateKeyFromBytes(seed);
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.words.join(" ");
    }
}

/**
 * @param {string} bin
 * @returns {number}
 */
function binaryToByte(bin) {
    return parseInt(bin, 2);
}

/**
 * @param {number[]} bytes
 * @returns {string}
 */
function bytesToBinary(bytes) {
    return bytes.map((x) => x.toString(2).padStart(8, "0")).join("");
}

/**
 * @param {Uint8Array} entropyBuffer
 * @returns {Promise<string>}
 */
async function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = await sha256.digest(entropyBuffer);

    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
// Filename: packages/cryptography/src/PrivateKey.js
import BadKeyError from "./BadKeyError.js";
import Key from "./Key.js";
import Ed25519PrivateKey from "./Ed25519PrivateKey.js";
import EcdsaPrivateKey from "./EcdsaPrivateKey.js";
import PublicKey from "./PublicKey.js";
import { createKeystore, loadKeystore } from "./primitive/keystore.js";
import { read } from "./encoding/pem.js";
import * as hex from "./encoding/hex.js";
import * as slip10 from "./primitive/slip10.js";
import * as bip32 from "./primitive/bip32.js";
import * as derive from "./util/derive.js";
import * as ecdsa from "./primitive/ecdsa.js";
import CACHE from "./Cache.js";

/**
 * @typedef {object} ProtoSignaturePair
 * @property {(Uint8Array | null)=} pubKeyPrefix
 * @property {(Uint8Array | null)=} ed25519
 * @property {(Uint8Array | null)=} ECDSASecp256k1
 */

/**
 * @typedef {object} ProtoSigMap
 * @property {(ProtoSignaturePair[] | null)=} sigPair
 */

/**
 * @typedef {object} ProtoSignedTransaction
 * @property {(Uint8Array | null)=} bodyBytes
 * @property {(ProtoSigMap | null)=} sigMap
 */

/**
 * @typedef {object} Transaction
 * @property {() => boolean} isFrozen
 * @property {ProtoSignedTransaction[]} _signedTransactions
 * @property {Set<string>} _signerPublicKeys
 * @property {(publicKey: PublicKey, signature: Uint8Array) => Transaction} addSignature
 * @property {() => void} _requireFrozen
 * @property {() => Transaction} freeze
 */

/**
 * @typedef {import("./Mnemonic.js").default} Mnemonic
 */

/**
 * A private key on the Hedera™ network.
 */
export default class PrivateKey extends Key {
    /**
     * @hideconstructor
     * @internal
     * @param {Ed25519PrivateKey | EcdsaPrivateKey} key
     */
    constructor(key) {
        super();

        /**
         * @type {Ed25519PrivateKey | EcdsaPrivateKey}
         * @readonly
         * @private
         */
        this._key = key;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return this._key._type;
    }

    /**
     * @returns {Uint8Array | null}
     */
    get _chainCode() {
        return this._key._chainCode;
    }

    /**
     * Generate a random Ed25519 private key.
     * @returns {PrivateKey}
     */
    static generateED25519() {
        return new PrivateKey(Ed25519PrivateKey.generate());
    }

    /**
     * Generate a random EDSA private key.
     * @returns {PrivateKey}
     */
    static generateECDSA() {
        return new PrivateKey(EcdsaPrivateKey.generate());
    }

    /**
     * Depredated - Use `generateED25519()` instead
     * Generate a random Ed25519 private key.
     * @returns {PrivateKey}
     */
    static generate() {
        return PrivateKey.generateED25519();
    }

    /**
     * Depredated - Use `generateED25519Async()` instead
     * Generate a random Ed25519 private key.
     * @returns {Promise<PrivateKey>}
     */
    static async generateAsync() {
        return PrivateKey.generateED25519Async();
    }

    /**
     * Generate a random Ed25519 private key.
     * @returns {Promise<PrivateKey>}
     */
    static async generateED25519Async() {
        return new PrivateKey(await Ed25519PrivateKey.generateAsync());
    }

    /**
     * Generate a random ECDSA private key.
     * @returns {Promise<PrivateKey>}
     */
    static async generateECDSAAsync() {
        return new PrivateKey(await EcdsaPrivateKey.generateAsync());
    }

    /**
     * Construct a private key from bytes. Requires DER header.
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytes(data) {
        let message;

        if (data.length == 32) {
            console.warn(
                "WARNING: Consider using fromStringECDSA() or fromStringED25519() on a HEX-encoded string and fromStringDer() on a HEX-encoded string with DER prefix instead.",
            );
        }

        try {
            return new PrivateKey(Ed25519PrivateKey.fromBytes(data));
        } catch (error) {
            message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";
        }

        try {
            return new PrivateKey(EcdsaPrivateKey.fromBytes(data));
        } catch (error) {
            message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";
        }

        throw new BadKeyError(
            `private key cannot be decoded from bytes: ${message}`,
        );
    }

    /**
     * Construct a ECDSA private key from bytes.
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesECDSA(data) {
        return new PrivateKey(EcdsaPrivateKey.fromBytes(data));
    }

    /**
     * Construct a ED25519 private key from bytes.
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesED25519(data) {
        return new PrivateKey(Ed25519PrivateKey.fromBytes(data));
    }

    /**
     * Construct a private key from a hex-encoded string. Requires DER header.
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromString(text) {
        return PrivateKey.fromBytes(hex.decode(text));
    }

    /**
     * Construct a ECDSA private key from a hex-encoded string.
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringECDSA(text) {
        return PrivateKey.fromBytesECDSA(hex.decode(text));
    }

    /**
     * Construct a Ed25519 private key from a hex-encoded string.
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringED25519(text) {
        return PrivateKey.fromBytesED25519(hex.decode(text));
    }

    /**
     * Construct a Ed25519 private key from a Uint8Array seed.
     * @param {Uint8Array} seed
     * @returns {Promise<PrivateKey>}
     */
    static async fromSeedED25519(seed) {
        const ed25519Key = await Ed25519PrivateKey.fromSeed(seed);
        return new PrivateKey(ed25519Key);
    }

    /**
     * Construct a ECDSA private key from a Uint8Array seed.
     * @param {Uint8Array} seed
     * @returns {Promise<PrivateKey>}
     */
    static async fromSeedECDSAsecp256k1(seed) {
        const ecdsaKey = await EcdsaPrivateKey.fromSeed(seed);
        return new PrivateKey(ecdsaKey);
    }

    /**
     * @deprecated - Use `Mnemonic.from[Words|String]().toStandard[Ed25519|ECDSAsecp256k1]PrivateKey()` instead
     *
     * Recover a private key from a mnemonic phrase (and optionally a password).
     * @param {Mnemonic | string} mnemonic
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromMnemonic(mnemonic, passphrase = "") {
        if (CACHE.mnemonicFromString == null) {
            throw new Error("Mnemonic not found in cache");
        }

        return (
            (
                typeof mnemonic === "string"
                    ? CACHE.mnemonicFromString(mnemonic)
                    : mnemonic
            )
                // eslint-disable-next-line deprecation/deprecation
                .toEd25519PrivateKey(passphrase)
        );
    }

    /**
     * Recover a private key from a keystore, previously created by `.toKeystore()`.
     *
     * This key will _not_ support child key derivation.
     * @param {Uint8Array} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
     */
    static async fromKeystore(data, passphrase = "") {
        return PrivateKey.fromBytes(await loadKeystore(data, passphrase));
    }

    /**
     * Recover a private key from a pem string; the private key may be encrypted.
     *
     * This method assumes the .pem file has been converted to a string already.
     *
     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
     * section and decodes that as a DER-encoded  private key.
     * @param {string} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromPem(data, passphrase = "") {
        const pem = await read(data, passphrase);

        if (
            pem instanceof Ed25519PrivateKey ||
            pem instanceof EcdsaPrivateKey
        ) {
            return new PrivateKey(pem);
        }

        const isEcdsa = data.includes("BEGIN EC PRIVATE KEY") ? true : false;
        if (isEcdsa) {
            return new PrivateKey(EcdsaPrivateKey.fromBytes(pem));
        } else {
            return new PrivateKey(Ed25519PrivateKey.fromBytes(pem));
        }
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with from mnemonics; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation()`
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async derive(index) {
        if (this._key._chainCode == null) {
            throw new Error("this private key does not support key derivation");
        }

        if (this._key instanceof Ed25519PrivateKey) {
            const { keyData, chainCode } = await slip10.derive(
                this.toBytesRaw(),
                this._key._chainCode,
                index,
            );

            return new PrivateKey(new Ed25519PrivateKey(keyData, chainCode));
        } else {
            const { keyData, chainCode } = await bip32.derive(
                this.toBytesRaw(),
                this._key._chainCode,
                index,
            );

            return new PrivateKey(
                new EcdsaPrivateKey(ecdsa.fromBytes(keyData), chainCode),
            );
        }
    }

    /**
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async legacyDerive(index) {
        const keyBytes = await derive.legacy(
            this.toBytesRaw().subarray(0, 32),
            index,
        );

        /** @type {new (bytes: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */
        const constructor = /** @type {any} */ (this._key.constructor);

        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        return new PrivateKey(new constructor(keyBytes));
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     * @returns {PublicKey}
     */
    get publicKey() {
        return new PublicKey(this._key.publicKey);
    }

    /**
     * Sign a message with this private key.
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return this._key.sign(bytes);
    }

    /**
     * @param {Transaction} transaction
     * @returns {Uint8Array}
     */
    signTransaction(transaction) {
        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        if (transaction._signedTransactions.length != 1) {
            throw new Error(
                "`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set",
            );
        }

        const tx = /** @type {ProtoSignedTransaction} */ (
            transaction._signedTransactions[0]
        );

        const publicKeyHex = hex.encode(this.publicKey.toBytesRaw());

        if (tx.sigMap == null) {
            tx.sigMap = {};
        }

        if (tx.sigMap.sigPair == null) {
            tx.sigMap.sigPair = [];
        }

        for (const sigPair of tx.sigMap.sigPair) {
            if (
                sigPair.pubKeyPrefix != null &&
                hex.encode(sigPair.pubKeyPrefix) === publicKeyHex
            ) {
                switch (this._type) {
                    case "ED25519":
                        return /** @type {Uint8Array} */ (sigPair.ed25519);
                    case "secp256k1":
                        return /** @type {Uint8Array} */ (
                            sigPair.ECDSASecp256k1
                        );
                }
            }
        }

        const siganture = this.sign(
            tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array(),
        );

        /** @type {ProtoSignaturePair} */
        const protoSignature = {
            pubKeyPrefix: this.publicKey.toBytesRaw(),
        };

        switch (this._type) {
            case "ED25519":
                protoSignature.ed25519 = siganture;
                break;
            case "secp256k1":
                protoSignature.ECDSASecp256k1 = siganture;
                break;
        }

        tx.sigMap.sigPair.push(protoSignature);
        transaction._signerPublicKeys.add(publicKeyHex);

        return siganture;
    }

    /**
     * Check if `derive` can be called on this private key.
     *
     * This is only the case if the key was created from a mnemonic.
     * @returns {boolean}
     */
    isDerivable() {
        return this._key._chainCode != null;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        if (this._key instanceof Ed25519PrivateKey) {
            return this.toBytesRaw();
        } else {
            return this.toBytesDer();
        }
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return hex.encode(this.toBytesDer());
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return hex.encode(this.toBytesRaw());
    }

    /**
     * Create a keystore with a given passphrase.
     *
     * The key can be recovered later with `fromKeystore()`.
     *
     * Note that this will not retain the ancillary data used for
     * deriving child keys, thus `.derive()` on the restored key will
     * throw even if this instance supports derivation.
     * @param {string} [passphrase]
     * @returns {Promise<Uint8Array>}
     */
    toKeystore(passphrase = "") {
        return createKeystore(this.toBytesRaw(), passphrase);
    }
}

CACHE.privateKeyConstructor = (key) => new PrivateKey(key);
CACHE.privateKeyFromBytes = (bytes) => PrivateKey.fromBytes(bytes);
// Filename: packages/cryptography/src/PublicKey.js
import Key from "./Key.js";
import BadKeyError from "./BadKeyError.js";
import Ed25519PublicKey from "./Ed25519PublicKey.js";
import EcdsaPublicKey from "./EcdsaPublicKey.js";
import { arrayEqual } from "./util/array.js";
import * as hex from "./encoding/hex.js";

/**
 * @typedef {import("./PrivateKey.js").Transaction} Transaction
 */

/**
 * An public key on the Hedera™ network.
 */
export default class PublicKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {Ed25519PublicKey | EcdsaPublicKey} key
     */
    constructor(key) {
        super();

        /**
         * @type {Ed25519PublicKey | EcdsaPublicKey}
         * @private
         * @readonly
         */
        this._key = key;
    }

    /**
     * @returns {string}
     */
    get _type() {
        return this._key._type;
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytes(data) {
        let message;
        try {
            return new PublicKey(Ed25519PublicKey.fromBytes(data));
        } catch (error) {
            message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";
        }

        try {
            return new PublicKey(EcdsaPublicKey.fromBytes(data));
        } catch (error) {
            message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";
        }

        throw new BadKeyError(
            `public key cannot be decoded from bytes: ${message}`,
        );
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesED25519(data) {
        return new PublicKey(Ed25519PublicKey.fromBytes(data));
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesECDSA(data) {
        return new PublicKey(EcdsaPublicKey.fromBytes(data));
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromString(text) {
        return PublicKey.fromBytes(hex.decode(text));
    }

    /**
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromStringED25519(text) {
        return PublicKey.fromBytesED25519(hex.decode(text));
    }

    /**
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromStringECDSA(text) {
        return PublicKey.fromBytesECDSA(hex.decode(text));
    }

    /**
     * Verify a signature on a message with this public key.
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return this._key.verify(message, signature);
    }

    /**
     * @deprecated - use `@hashgraph/sdk`.PublicKey instead
     * @param {Transaction} transaction
     * @returns {boolean}
     */
    verifyTransaction(transaction) {
        //NOSONAR
        console.log("Deprecated: use `@hashgraph/sdk`.PublicKey instead");

        transaction._requireFrozen();

        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        for (const signedTransaction of transaction._signedTransactions) {
            if (
                signedTransaction.sigMap != null &&
                signedTransaction.sigMap.sigPair != null
            ) {
                let found = false;
                for (const sigPair of signedTransaction.sigMap.sigPair) {
                    const pubKeyPrefix = /** @type {Uint8Array} */ (
                        sigPair.pubKeyPrefix
                    );
                    if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {
                        found = true;
                        const bodyBytes = /** @type {Uint8Array} */ (
                            signedTransaction.bodyBytes
                        );
                        const signature =
                            sigPair.ed25519 != null
                                ? sigPair.ed25519
                                : /** @type {Uint8Array} */ (
                                      sigPair.ECDSASecp256k1
                                  );
                        if (!this.verify(bodyBytes, signature)) {
                            return false;
                        }
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        if (this._key instanceof Ed25519PublicKey) {
            return this.toBytesRaw();
        } else {
            return this.toBytesDer();
        }
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return hex.encode(this.toBytesDer());
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return hex.encode(this.toBytesRaw());
    }

    /**
     * @returns {string}
     */
    toEthereumAddress() {
        if (this._key instanceof EcdsaPublicKey) {
            return this._key.toEthereumAddress();
        } else {
            throw new Error("unsupported operation on Ed25519PublicKey");
        }
    }

    /**
     * @param {PublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        if (
            this._key instanceof Ed25519PublicKey &&
            other._key instanceof Ed25519PublicKey
        ) {
            return this._key.equals(other._key);
        } else if (
            this._key instanceof EcdsaPublicKey &&
            other._key instanceof EcdsaPublicKey
        ) {
            return this._key.equals(other._key);
        } else {
            return false;
        }
    }
}
// Filename: packages/cryptography/src/encoding/base64.browser.js
import { Buffer } from "buffer";

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    return Uint8Array.from(Buffer.from(text, "base64"));
}

/**
 * @param {Uint8Array} data
 * @returns {string};
 */
export function encode(data) {
    return Buffer.from(data).toString("base64");
}
// Filename: packages/cryptography/src/encoding/base64.js
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    return Buffer.from(text, "base64");
}

/**
 * @param {Uint8Array} data
 * @returns {string};
 */
export function encode(data) {
    return Buffer.from(data).toString("base64");
}
// Filename: packages/cryptography/src/encoding/base64.native.js
import { Buffer } from "buffer";

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    return Uint8Array.from(Buffer.from(text, "base64"));
}

/**
 * @param {Uint8Array} data
 * @returns {string};
 */
export function encode(data) {
    return Buffer.from(data).toString("base64");
}
// Filename: packages/cryptography/src/encoding/der.js
/**
 * @typedef {object} AsnSeq
 * @property {AsnType[]} seq
 */

/**
 * @typedef {object} AsnInt
 * @property {number} int
 */

/**
 * @typedef {object} AsnBytes
 * @property {Uint8Array} bytes
 */

/**
 * @typedef {object} AsnIdent
 * @property {string} ident
 */

/**
 * @typedef {{}} AsnNull
 */

/**
 * @typedef {AsnSeq | AsnInt | AsnBytes | AsnIdent | AsnNull} AsnType
 */

/**
 * Note: may throw weird errors on malformed input. Catch and rethrow with, e.g. `BadKeyError`.
 *@param {Uint8Array} data
 *@returns {AsnType}
 */
export function decode(data) {
    return decodeIncremental(data)[0];
}

/**
 * @param {Uint8Array} bytes
 * @returns {[AsnType, Uint8Array]}
 */
function decodeIncremental(bytes) {
    // slice off the initial tag byte, `decodeLength` returns a slice of the remaining data
    const [len, rem] = decodeLength(bytes.subarray(1));
    const data = rem.subarray(0, len);
    const tail = rem.subarray(len);

    switch (bytes[0]) {
        case 2:
            return [{ int: decodeInt(data) }, tail];
        case 4: // must always be primitive form in DER; for OCTET STRING this is literal bytes
            return [{ bytes: data }, tail];
        case 5: // empty
            return [{}, tail];
        case 6:
            return [{ ident: decodeObjectIdent(data) }, tail];
        case 48:
            return [{ seq: decodeSeq(data) }, tail];
        default:
            throw new Error(`unsupported DER type tag: ${bytes[0]}`);
    }
}

/**
 * @param {Uint8Array} seqBytes
 * @returns {AsnType[]}
 */
function decodeSeq(seqBytes) {
    let data = seqBytes;

    const seq = [];

    while (data.length !== 0) {
        const [decoded, remaining] = decodeIncremental(data);
        seq.push(decoded);
        data = remaining;
    }

    return seq;
}

/**
 * @param {Uint8Array} idBytes
 * @returns {string}
 */
function decodeObjectIdent(idBytes) {
    const id = [
        // first octet is 40 * value1 + value2
        Math.floor(idBytes[0] / 40),
        idBytes[0] % 40,
    ];

    // each following ID component is big-endian base128 where the MSB is set if another byte
    // follows for the same value
    let val = 0;

    for (const byte of idBytes.subarray(1)) {
        // shift the entire value left by 7 bits
        val *= 128;

        if (byte < 128) {
            // no more octets follow for this value, finish it off
            val += byte;
            id.push(val);
            val = 0;
        } else {
            // zero the MSB
            val += byte & 127;
        }
    }

    return id.join(".");
}

/**
 * @param {Uint8Array} lenBytes
 * @returns {[number, Uint8Array]}
 */
function decodeLength(lenBytes) {
    if (lenBytes[0] < 128) {
        // definite, short form
        return [lenBytes[0], lenBytes.subarray(1)];
    }

    const numBytes = lenBytes[0] - 128;

    const intBytes = lenBytes.subarray(1, numBytes + 1);
    const rem = lenBytes.subarray(numBytes + 1);

    return [decodeInt(intBytes), rem];
}

/**
 * @param {Uint8Array} intBytes
 * @returns {number}
 */
function decodeInt(intBytes) {
    const len = intBytes.length;
    if (len === 1) {
        return intBytes[0];
    }

    let view = new DataView(
        intBytes.buffer,
        intBytes.byteOffset,
        intBytes.byteLength,
    );

    if (len === 2) return view.getUint16(0, false);

    if (len === 3) {
        // prefix a zero byte and we'll treat it as a 32-bit int
        const data = Uint8Array.of(0, ...intBytes);
        view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    }

    if (len > 4) {
        // this probably means a bug in the decoding as this would mean a >4GB structure
        throw new Error(`unsupported DER integer length of ${len} bytes`);
    }

    return view.getUint32(0, false);
}
// Filename: packages/cryptography/src/encoding/hex.browser.js
/**
 * @type {string[]}
 */
const byteToHex = [];

for (let n = 0; n <= 0xff; n += 1) {
    byteToHex.push(n.toString(16).padStart(2, "0"));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encode(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHex[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    const result = str.match(/.{1,2}/gu);

    return new Uint8Array(
        (result == null ? [] : result).map((byte) => parseInt(byte, 16)),
    );
}

/**
 * Encode with a specified length. Supports zero padding if the most significant byte is 0
 *
 * https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
 * @param {Uint8Array} value
 * @param {number} length
 * @returns {string}
 */
export function hexZeroPadded(value, length) {
    const HexCharacters = "0123456789abcdef";

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L243
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
    if (result.length > 2 * length + 2) {
        console.log("result out of range", "result");
    }

    while (result.length < 2 * length + 2) {
        result = "0x0" + result.substring(2);
    }

    return result.substring(2);
}
// Filename: packages/cryptography/src/encoding/hex.js
/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encode(data) {
    return Buffer.from(data).toString("hex");
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    return Buffer.from(str, "hex");
}

/**
 * Encode with a specified length. Supports zero padding if the most significant byte is 0
 *
 * https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
 * @param {Uint8Array} value
 * @param {number} length
 * @returns {string}
 */
export function hexZeroPadded(value, length) {
    const HexCharacters = "0123456789abcdef";

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L243
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
    if (result.length > 2 * length + 2) {
        console.log("result out of range", "result");
    }

    while (result.length < 2 * length + 2) {
        result = "0x0" + result.substring(2);
    }

    return result.substring(2);
}
// Filename: packages/cryptography/src/encoding/hex.native.js
/**
 * @type {string[]}
 */
const byteToHex = [];

/**
 * @type {string[]}
 */
const byteToHexByteString = [
    "\x00",
    "\x01",
    "\x02",
    "\x03",
    "\x04",
    "\x05",
    "\x06",
    "\x07",
    "\x08",
    "\x09",
    "\x0A",
    "\x0B",
    "\x0C",
    "\x0D",
    "\x0E",
    "\x0F",
    "\x10",
    "\x11",
    "\x12",
    "\x13",
    "\x14",
    "\x15",
    "\x16",
    "\x17",
    "\x18",
    "\x19",
    "\x1A",
    "\x1B",
    "\x1C",
    "\x1D",
    "\x1E",
    "\x1F",
    "\x20",
    "\x21",
    "\x22",
    "\x23",
    "\x24",
    "\x25",
    "\x26",
    "\x27",
    "\x28",
    "\x29",
    "\x2A",
    "\x2B",
    "\x2C",
    "\x2D",
    "\x2E",
    "\x2F",
    "\x30",
    "\x31",
    "\x32",
    "\x33",
    "\x34",
    "\x35",
    "\x36",
    "\x37",
    "\x38",
    "\x39",
    "\x3A",
    "\x3B",
    "\x3C",
    "\x3D",
    "\x3E",
    "\x3F",
    "\x40",
    "\x41",
    "\x42",
    "\x43",
    "\x44",
    "\x45",
    "\x46",
    "\x47",
    "\x48",
    "\x49",
    "\x4A",
    "\x4B",
    "\x4C",
    "\x4D",
    "\x4E",
    "\x4F",
    "\x50",
    "\x51",
    "\x52",
    "\x53",
    "\x54",
    "\x55",
    "\x56",
    "\x57",
    "\x58",
    "\x59",
    "\x5A",
    "\x5B",
    "\x5C",
    "\x5D",
    "\x5E",
    "\x5F",
    "\x60",
    "\x61",
    "\x62",
    "\x63",
    "\x64",
    "\x65",
    "\x66",
    "\x67",
    "\x68",
    "\x69",
    "\x6A",
    "\x6B",
    "\x6C",
    "\x6D",
    "\x6E",
    "\x6F",
    "\x70",
    "\x71",
    "\x72",
    "\x73",
    "\x74",
    "\x75",
    "\x76",
    "\x77",
    "\x78",
    "\x79",
    "\x7A",
    "\x7B",
    "\x7C",
    "\x7D",
    "\x7E",
    "\x7F",
    "\x80",
    "\x81",
    "\x82",
    "\x83",
    "\x84",
    "\x85",
    "\x86",
    "\x87",
    "\x88",
    "\x89",
    "\x8A",
    "\x8B",
    "\x8C",
    "\x8D",
    "\x8E",
    "\x8F",
    "\x90",
    "\x91",
    "\x92",
    "\x93",
    "\x94",
    "\x95",
    "\x96",
    "\x97",
    "\x98",
    "\x99",
    "\x9A",
    "\x9B",
    "\x9C",
    "\x9D",
    "\x9E",
    "\x9F",
    "\xA0",
    "\xA1",
    "\xA2",
    "\xA3",
    "\xA4",
    "\xA5",
    "\xA6",
    "\xA7",
    "\xA8",
    "\xA9",
    "\xAA",
    "\xAB",
    "\xAC",
    "\xAD",
    "\xAE",
    "\xAF",
    "\xB0",
    "\xB1",
    "\xB2",
    "\xB3",
    "\xB4",
    "\xB5",
    "\xB6",
    "\xB7",
    "\xB8",
    "\xB9",
    "\xBA",
    "\xBB",
    "\xBC",
    "\xBD",
    "\xBE",
    "\xBF",
    "\xC0",
    "\xC1",
    "\xC2",
    "\xC3",
    "\xC4",
    "\xC5",
    "\xC6",
    "\xC7",
    "\xC8",
    "\xC9",
    "\xCA",
    "\xCB",
    "\xCC",
    "\xCD",
    "\xCE",
    "\xCF",
    "\xD0",
    "\xD1",
    "\xD2",
    "\xD3",
    "\xD4",
    "\xD5",
    "\xD6",
    "\xD7",
    "\xD8",
    "\xD9",
    "\xDA",
    "\xDB",
    "\xDC",
    "\xDD",
    "\xDE",
    "\xDF",
    "\xE0",
    "\xE1",
    "\xE2",
    "\xE3",
    "\xE4",
    "\xE5",
    "\xE6",
    "\xE7",
    "\xE8",
    "\xE9",
    "\xEA",
    "\xEB",
    "\xEC",
    "\xED",
    "\xEE",
    "\xEF",
    "\xF0",
    "\xF1",
    "\xF2",
    "\xF3",
    "\xF4",
    "\xF5",
    "\xF6",
    "\xF7",
    "\xF8",
    "\xF9",
    "\xFA",
    "\xFB",
    "\xFC",
    "\xFD",
    "\xFE",
    "\xFF",
];

for (let n = 0; n <= 0xff; n += 1) {
    byteToHex.push(n.toString(16).padStart(2, "0"));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encode(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHex[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    const result = str.match(/.{1,2}/gu);

    return new Uint8Array(
        (result == null ? [] : result).map((byte) => parseInt(byte, 16)),
    );
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encodeToByteString(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHexByteString[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decodeFromByteString(text) {
    const buffer = new Uint8Array(text.length);
    const view = new DataView(buffer.buffer);

    for (let i = 0; i < text.length; i++) {
        view.setUint8(i, text.charCodeAt(i));
    }

    return buffer;
}

/**
 * Encode with a specified length. Supports zero padding if the most significant byte is 0
 *
 * https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
 * @param {Uint8Array} value
 * @param {number} length
 * @returns {string}
 */
export function hexZeroPadded(value, length) {
    const HexCharacters = "0123456789abcdef";

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L243
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
    if (result.length > 2 * length + 2) {
        console.log("result out of range", "result");
    }

    while (result.length < 2 * length + 2) {
        result = "0x0" + result.substring(2);
    }

    return result.substring(2);
}
// Filename: packages/cryptography/src/encoding/pem.js
import BadKeyError from "../BadKeyError.js";
import { EncryptedPrivateKeyInfo } from "../primitive/pkcs.js";
import * as der from "./der.js";
import * as base64 from "./base64.js";
import Ed25519PrivateKey from "../Ed25519PrivateKey.js";
import EcdsaPrivateKey from "../EcdsaPrivateKey.js";
import * as asn1 from "asn1js";
// @ts-ignore
import pemForge from "forge-light/lib/pem.js";
import * as hex from "./hex.js";
import * as aes from "../primitive/aes.js";
import { Buffer } from "buffer";

const ID_ED25519 = "1.3.101.112";

/**
 * @param {string} pem
 * @param {string} [passphrase]
 * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
 */
export async function readPemED25519(pem, passphrase) {
    const pemKeyData = pem.replace(
        /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
        "",
    );

    const key = base64.decode(pemKeyData);
    if (passphrase) {
        let encrypted;

        try {
            encrypted = EncryptedPrivateKeyInfo.parse(key);
        } catch (error) {
            const message =
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                error != null && /** @type {Error} */ (error).message != null
                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                      /** @type {Error} */ (error).message
                    : "";

            throw new BadKeyError(
                `failed to parse encrypted private key: ${message}`,
            );
        }

        const decrypted = await encrypted.decrypt(passphrase);

        let privateKey = null;

        if (decrypted.algId.algIdent === ID_ED25519) {
            privateKey = Ed25519PrivateKey;
        } else {
            throw new BadKeyError(
                `unknown private key algorithm ${decrypted.algId.toString()}`,
            );
        }

        const keyData = der.decode(decrypted.privateKey);

        if (!("bytes" in keyData)) {
            throw new BadKeyError(
                `expected ASN bytes, got ${JSON.stringify(keyData)}`,
            );
        }

        return privateKey.fromBytes(keyData.bytes);
    }

    return key.subarray(16);
}

/**
 * @param {string} pem
 * @param {string} [passphrase]
 * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
 */
export async function readPemECDSA(pem, passphrase) {
    const pemKeyData = pem.replace(
        /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
        "",
    );
    const key = base64.decode(pemKeyData);

    if (passphrase) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
        const decodedPem = pemForge.decode(pem)[0];
        /** @type {string} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment
        const ivString = decodedPem.dekInfo.parameters;
        const iv = hex.decode(ivString);
        const pemLines = pem.split("\n");
        const key = await aes.messageDigest(passphrase, ivString);
        const dataToDecrypt = Buffer.from(
            pemLines.slice(4, pemLines.length - 1).join(""),
            "base64",
        );
        const keyDerBytes = await aes.createDecipheriv(
            aes.CipherAlgorithm.Aes128Cbc,
            key,
            iv,
            dataToDecrypt,
        );

        return EcdsaPrivateKey.fromBytesDer(keyDerBytes);
    } else {
        const asnData = asn1.fromBER(key);
        const parsedKey = asnData.result;

        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return
        return parsedKey.valueBlock.value[1].valueBlock.valueHexView;
    }
}

/**
 * @param {string} pem
 * @param {string} [passphrase]
 * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}
 */
export async function read(pem, passphrase) {
    // If not then it is ED25519 type
    const isEcdsa = pem.includes("BEGIN EC PRIVATE KEY") ? true : false;
    if (isEcdsa) {
        return readPemECDSA(pem, passphrase);
    } else {
        return readPemED25519(pem, passphrase);
    }
}
// Filename: packages/cryptography/src/encoding/utf8.browser.js
/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function decode(data) {
    // eslint-disable-next-line n/no-unsupported-features/node-builtins
    return new TextDecoder().decode(data);
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function encode(text) {
    // eslint-disable-next-line n/no-unsupported-features/node-builtins
    return new TextEncoder().encode(text);
}
// Filename: packages/cryptography/src/encoding/utf8.js
/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function decode(data) {
    return Buffer.from(data).toString("utf8");
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function encode(text) {
    return Buffer.from(text, "utf8");
}
// Filename: packages/cryptography/src/encoding/utf8.native.js
import utf8 from "utf8";
import * as hex from "./hex.native.js";

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function decode(data) {
    return utf8.decode(hex.encodeToByteString(data));
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function encode(text) {
    return hex.decodeFromByteString(utf8.encode(text));
}
// Filename: packages/cryptography/src/index.js
export { default as Key } from "./Key.js";
export { default as KeyList } from "./KeyList.js";
export { default as PrivateKey } from "./PrivateKey.js";
export { default as PublicKey } from "./PublicKey.js";
export {
    default as Mnemonic,
    HEDERA_PATH,
    SLIP44_ECDSA_ETH_PATH,
    SLIP44_ECDSA_HEDERA_PATH,
} from "./Mnemonic.js";
export { default as BadKeyError } from "./BadKeyError.js";
export { default as BadMnemonicError } from "./BadMnemonicError.js";
export { default as BadMnemonicReason } from "./BadMnemonicReason.js";
// Filename: packages/cryptography/src/index.native.js
// Add react-native environment cryptography polyfills
import "./polyfills.native.js";

export { default as Key } from "./Key.js";
export { default as KeyList } from "./KeyList.js";
export { default as PrivateKey } from "./PrivateKey.js";
export { default as PublicKey } from "./PublicKey.js";
export {
    default as Mnemonic,
    HEDERA_PATH,
    SLIP44_ECDSA_ETH_PATH,
    SLIP44_ECDSA_HEDERA_PATH,
} from "./Mnemonic.js";
export { default as BadKeyError } from "./BadKeyError.js";
export { default as BadMnemonicError } from "./BadMnemonicError.js";
export { default as BadMnemonicReason } from "./BadMnemonicReason.js";
// Filename: packages/cryptography/src/polyfills.native.js
import "react-native-get-random-values";
global.process.nextTick = setImmediate;
// Filename: packages/cryptography/src/primitive/aes.browser.js
import * as hex from "../encoding/hex.js";
import * as utf8 from "../encoding/utf8.js";
import SparkMD5 from "spark-md5";
import { Buffer } from "buffer";

// this will be executed in browser environment so we can use window.crypto
/* eslint-disable n/no-unsupported-features/node-builtins */

export const CipherAlgorithm = {
    Aes128Ctr: "AES-128-CTR",
    Aes128Cbc: "AES-128-CBC",
};

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export async function createCipheriv(algorithm, key, iv, data) {
    let algorithm_;

    switch (algorithm.toUpperCase()) {
        case CipherAlgorithm.Aes128Ctr:
            algorithm_ = {
                name: "AES-CTR",
                counter: iv,
                length: 128,
            };
            break;
        case CipherAlgorithm.Aes128Cbc:
            algorithm_ = {
                name: "AES-CBC",
                iv: iv,
            };
            break;
        default:
            throw new Error(
                "(BUG) non-exhaustive switch statement for CipherAlgorithm",
            );
    }

    const key_ = await window.crypto.subtle.importKey(
        "raw",
        key,
        algorithm_.name,
        false,
        ["encrypt"],
    );

    return new Uint8Array(
        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
        /** @type {ArrayBuffer} */ (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            await window.crypto.subtle.encrypt(algorithm_, key_, data)
        ),
    );
}

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export async function createDecipheriv(algorithm, key, iv, data) {
    let algorithm_;

    switch (algorithm.toUpperCase()) {
        case CipherAlgorithm.Aes128Ctr:
            algorithm_ = {
                name: "AES-CTR",
                counter: iv,
                length: 128,
            };
            break;
        case CipherAlgorithm.Aes128Cbc:
            algorithm_ = {
                name: "AES-CBC",
                iv,
            };
            break;
        default:
            throw new Error(
                "(BUG) non-exhaustive switch statement for CipherAlgorithm",
            );
    }

    const key_ = await window.crypto.subtle.importKey(
        "raw",
        key,
        algorithm_.name,
        false,
        ["decrypt"],
    );
    let decrypted;
    try {
        decrypted = await window.crypto.subtle.decrypt(algorithm_, key_, data);
    } catch (error) {
        const message =
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            error != null && /** @type {Error} */ (error).message != null
                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                  /** @type {Error} */ (error).message
                : "";

        throw new Error(`Unable to decrypt: ${message}`);
    }
    return new Uint8Array(
        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
        /** @type {ArrayBuffer} */ (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            decrypted
        ),
    );
}

/**
 * @param {string} passphrase
 * @param {string} iv
 * @returns {Promise<Uint8Array>}
 */
export async function messageDigest(passphrase, iv) {
    const pass = utf8.encode(passphrase);
    const sliced = hex.decode(iv).slice(0, 8);
    const result = SparkMD5.ArrayBuffer.hash(
        // @ts-ignore
        Buffer.concat([Buffer.from(pass), Buffer.from(sliced)]),
    );

    return Promise.resolve(hex.decode(result));
}
// Filename: packages/cryptography/src/primitive/aes.js
import crypto from "crypto";
import * as hex from "../encoding/hex.js";

export const CipherAlgorithm = {
    Aes128Ctr: "AES-128-CTR",
    Aes128Cbc: "AES-128-CBC",
};

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export function createCipheriv(algorithm, key, iv, data) {
    const cipher = crypto.createCipheriv(algorithm, key.slice(0, 16), iv);

    return Promise.resolve(
        Buffer.concat([cipher.update(data), cipher["final"]()]),
    );
}

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export function createDecipheriv(algorithm, key, iv, data) {
    const decipher = crypto.createDecipheriv(algorithm, key.slice(0, 16), iv);

    return Promise.resolve(
        Buffer.concat([decipher.update(data), decipher["final"]()]),
    );
}

/**
 * @param {string} passphrase
 * @param {string} iv
 * @returns {Promise<Uint8Array>}
 */
export function messageDigest(passphrase, iv) {
    return Promise.resolve(
        crypto
            .createHash("md5")
            .update(passphrase)
            .update(hex.decode(iv).slice(0, 8))
            .digest(),
    );
}
// Filename: packages/cryptography/src/primitive/aes.native.js
import CryptoJS from "crypto-js";
import * as hex from "../encoding/hex.js";
import * as utf8 from "../encoding/utf8.js";
import SparkMD5 from "spark-md5";
import { Buffer } from "buffer";

export const CipherAlgorithm = {
    Aes128Ctr: "AES-128-CTR",
    Aes128Cbc: "AES-128-CBC",
};

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export function createCipheriv(algorithm, key, iv, data) {
    let mode;

    switch (algorithm.toUpperCase()) {
        case CipherAlgorithm.Aes128Cbc:
            mode = CryptoJS.mode.CBC;
            break;

        case CipherAlgorithm.Aes128Ctr:
            mode = CryptoJS.mode.CTR;
            break;

        default:
            throw new Error("(BUG) non-exhaustive switch statement");
    }

    const data_ = CryptoJS.enc.Hex.parse(hex.encode(data));
    const key_ = CryptoJS.enc.Hex.parse(hex.encode(key.slice(0, 16)));
    const cfg_ = { iv: CryptoJS.enc.Hex.parse(hex.encode(iv)), mode };

    return Promise.resolve(
        hex.decode(
            CryptoJS.AES.encrypt(data_, key_, cfg_).toString(
                CryptoJS.format.Hex,
            ),
        ),
    );
}

/**
 * @param {string} algorithm
 * @param {Uint8Array} key
 * @param {Uint8Array} iv
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export function createDecipheriv(algorithm, key, iv, data) {
    let mode;
    switch (algorithm) {
        case CipherAlgorithm.Aes128Cbc:
            mode = CryptoJS.mode.CBC;
            break;

        case CipherAlgorithm.Aes128Ctr:
            mode = CryptoJS.mode.CTR;
            break;

        default:
            throw new Error("(BUG) non-exhaustive switch statement");
    }

    const key_ = CryptoJS.enc.Hex.parse(hex.encode(key.slice(0, 16)));
    const iv_ = CryptoJS.enc.Hex.parse(hex.encode(iv));

    const params = CryptoJS.lib.CipherParams.create({
        ciphertext: CryptoJS.enc.Hex.parse(hex.encode(data)),
        iv: iv_,
        key: key_,
        algorithm: CryptoJS.algo.AES,
        blockSize: 4,
    });

    return Promise.resolve(
        hex.decode(
            CryptoJS.AES.decrypt(params, key_, { iv: iv_, mode }).toString(
                CryptoJS.enc.Hex,
            ),
        ),
    );
}

/**
 * @param {string} passphrase
 * @param {string} iv
 * @returns {Promise<Uint8Array>}
 */
export async function messageDigest(passphrase, iv) {
    const pass = utf8.encode(passphrase);
    const sliced = hex.decode(iv).slice(0, 8);
    const result = SparkMD5.ArrayBuffer.hash(
        // @ts-ignore
        Buffer.concat([Buffer.from(pass), Buffer.from(sliced)]),
    );

    return Promise.resolve(hex.decode(result));
}
// Filename: packages/cryptography/src/primitive/bip32.browser.js
import * as hmac from "./hmac.js";
import * as hex from "../encoding/hex.js";
import elliptic from "elliptic";
import BN from "bn.js";

const secp256k1 = new elliptic.ec("secp256k1");

// https://github.com/ethers-io/ethers.js/blob/master/packages/hdnode/src.ts/index.ts#L23
const N = new BN(
    "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    "hex",
);
const HARDENED_BIT = 0x80000000;

/**
 * Mostly copied from https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts
 * We cannot use that library directly because it uses `Buffer` and we want to avoid
 * polyfills as much as possible. Also, we only need the `derive` function.
 * @param {Uint8Array} parentKey
 * @param {Uint8Array} chainCode
 * @param {number} index
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function derive(parentKey, chainCode, index) {
    const isHardened = isHardenedIndex(index);
    const data = new Uint8Array(37);

    const publicKey = hex.decode(
        secp256k1.keyFromPrivate(parentKey).getPublic(true, "hex"),
    );

    // Hardened child
    if (isHardened) {
        // data = 0x00 || ser256(kpar) || ser32(index)
        data[0] = 0x00;
        data.set(parentKey, 1);

        // Normal child
    } else {
        // data = serP(point(kpar)) || ser32(index)
        //      = serP(Kpar) || ser32(index)
        data.set(publicKey, 0);
    }

    new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(
        33,
        index,
        false,
    );

    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, data);
    const IL = I.subarray(0, 32);
    const IR = I.subarray(32);

    // if parse256(IL) >= n, proceed with the next value for i
    try {
        // ki = parse256(IL) + kpar (mod n)
        const ki = secp256k1
            .keyFromPrivate(parentKey)
            .getPrivate()
            .add(secp256k1.keyFromPrivate(IL).getPrivate())
            .mod(N);
        const hexZeroPadded = hex.hexZeroPadded(
            Uint8Array.from(ki.toArray()),
            32,
        );
        // const ki = Buffer.from(ecc.privateAdd(this.privateKey!, IL)!);

        // In case ki == 0, proceed with the next value for i
        if (ki.eqn(0)) {
            return derive(parentKey, chainCode, index + 1);
        }

        return {
            keyData: hex.decode(hexZeroPadded),
            chainCode: IR,
        };
    } catch {
        return derive(parentKey, chainCode, index + 1);
    }
}

/**
 * @param {Uint8Array} seed
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function fromSeed(seed) {
    if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
    if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");

    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, "Bitcoin seed", seed);

    const IL = I.subarray(0, 32);
    const IR = I.subarray(32);

    return { keyData: IL, chainCode: IR };
}

/**
 * Harden the index
 * @param {number} index         the derivation index
 * @returns {number}              the hardened index
 */
export function toHardenedIndex(index) {
    return index | HARDENED_BIT;
}

/**
 * Check if the index is hardened
 * @param {number} index         the derivation index
 * @returns {boolean}            true if the index is hardened
 */
export function isHardenedIndex(index) {
    return (index & HARDENED_BIT) !== 0;
}
// Filename: packages/cryptography/src/primitive/bip32.js
import * as hmac from "./hmac.js";
import * as hex from "../encoding/hex.js";
import elliptic from "elliptic";
import BN from "bn.js";

const secp256k1 = new elliptic.ec("secp256k1");

// https://github.com/ethers-io/ethers.js/blob/master/packages/hdnode/src.ts/index.ts#L23
const N = new BN(
    "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    "hex",
);
const HARDENED_BIT = 0x80000000;

/**
 * Mostly copied from https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts
 * We cannot use that library directly because it uses `Buffer` and we want to avoid
 * polyfills as much as possible. Also, we only need the `derive` function.
 * @param {Uint8Array} parentKey
 * @param {Uint8Array} chainCode
 * @param {number} index
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function derive(parentKey, chainCode, index) {
    const isHardened = isHardenedIndex(index);
    const data = new Uint8Array(37);

    const publicKey = hex.decode(
        secp256k1.keyFromPrivate(parentKey).getPublic(true, "hex"),
    );

    // Hardened child
    if (isHardened) {
        // data = 0x00 || ser256(kpar) || ser32(index)
        data[0] = 0x00;
        data.set(parentKey, 1);

        // Normal child
    } else {
        // data = serP(point(kpar)) || ser32(index)
        //      = serP(Kpar) || ser32(index)
        data.set(publicKey, 0);
    }

    new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(
        33,
        index,
        false,
    );

    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, data);
    const IL = I.subarray(0, 32);
    const IR = I.subarray(32);

    // if parse256(IL) >= n, proceed with the next value for i
    try {
        // ki = parse256(IL) + kpar (mod n)
        const ki = secp256k1
            .keyFromPrivate(parentKey)
            .getPrivate()
            .add(secp256k1.keyFromPrivate(IL).getPrivate())
            .mod(N);
        const hexZeroPadded = hex.hexZeroPadded(ki.toBuffer(), 32);
        // const ki = Buffer.from(ecc.privateAdd(this.privateKey!, IL)!);

        // In case ki == 0, proceed with the next value for i
        if (ki.eqn(0)) {
            return derive(parentKey, chainCode, index + 1);
        }

        return {
            keyData: hex.decode(hexZeroPadded),
            chainCode: IR,
        };
    } catch {
        return derive(parentKey, chainCode, index + 1);
    }
}

/**
 * @param {Uint8Array} seed
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function fromSeed(seed) {
    if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
    if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");

    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, "Bitcoin seed", seed);

    const IL = I.subarray(0, 32);
    const IR = I.subarray(32);

    return { keyData: IL, chainCode: IR };
}

/**
 * Harden the index
 * @param {number} index         the derivation index
 * @returns {number}              the hardened index
 */
export function toHardenedIndex(index) {
    return index | HARDENED_BIT;
}

/**
 * Check if the index is hardened
 * @param {number} index         the derivation index
 * @returns {boolean}            true if the index is hardened
 */
export function isHardenedIndex(index) {
    return (index & HARDENED_BIT) !== 0;
}
// Filename: packages/cryptography/src/primitive/bip32.native.js
import * as hmac from "./hmac.js";
import * as hex from "../encoding/hex.js";
import elliptic from "elliptic";
import BN from "bn.js";

const secp256k1 = new elliptic.ec("secp256k1");

// https://github.com/ethers-io/ethers.js/blob/master/packages/hdnode/src.ts/index.ts#L23
const N = new BN(
    "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    "hex",
);
const HARDENED_BIT = 0x80000000;

/**
 * Mostly copied from https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts
 * We cannot use that library directly because it uses `Buffer` and we want to avoid
 * polyfills as much as possible. Also, we only need the `derive` function.
 * @param {Uint8Array} parentKey
 * @param {Uint8Array} chainCode
 * @param {number} index
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function derive(parentKey, chainCode, index) {
    const isHardened = isHardenedIndex(index);
    const data = new Uint8Array(37);

    const publicKey = hex.decode(
        secp256k1.keyFromPrivate(parentKey).getPublic(true, "hex"),
    );

    // Hardened child
    if (isHardened) {
        // data = 0x00 || ser256(kpar) || ser32(index)
        data[0] = 0x00;
        data.set(parentKey, 1);

        // Normal child
    } else {
        // data = serP(point(kpar)) || ser32(index)
        //      = serP(Kpar) || ser32(index)
        data.set(publicKey, 0);
    }

    new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(
        33,
        index,
        false,
    );

    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, data);
    const IL = I.subarray(0, 32);
    const IR = I.subarray(32);

    // if parse256(IL) >= n, proceed with the next value for i
    try {
        // ki = parse256(IL) + kpar (mod n)
        const ki = secp256k1
            .keyFromPrivate(parentKey)
            .getPrivate()
            .add(secp256k1.keyFromPrivate(IL).getPrivate())
            .mod(N);
        const hexZeroPadded = hex.hexZeroPadded(
            Uint8Array.from(ki.toArray()),
            32,
        );
        // const ki = Buffer.from(ecc.privateAdd(this.privateKey!, IL)!);

        // In case ki == 0, proceed with the next value for i
        if (ki.eqn(0)) {
            return derive(parentKey, chainCode, index + 1);
        }

        return {
            keyData: hex.decode(hexZeroPadded),
            chainCode: IR,
        };
    } catch {
        return derive(parentKey, chainCode, index + 1);
    }
}

/**
 * @param {Uint8Array} seed
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function fromSeed(seed) {
    if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
    if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");

    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, "Bitcoin seed", seed);

    const IL = I.subarray(0, 32);
    const IR = I.subarray(32);

    return { keyData: IL, chainCode: IR };
}

/**
 * Harden the index
 * @param {number} index         the derivation index
 * @returns {number}              the hardened index
 */
export function toHardenedIndex(index) {
    return index | HARDENED_BIT;
}

/**
 * Check if the index is hardened
 * @param {number} index         the derivation index
 * @returns {boolean}            true if the index is hardened
 */
export function isHardenedIndex(index) {
    return (index & HARDENED_BIT) !== 0;
}
// Filename: packages/cryptography/src/primitive/bip39.js
import * as hmac from "../primitive/hmac.js";
import * as pbkdf2 from "./pbkdf2.js";

/**
 * @param {string[]} words
 * @param {string} passphrase
 * @returns {Promise<Uint8Array>}
 */
export async function toSeed(words, passphrase) {
    const input = words.join(" ");
    const salt = `mnemonic${passphrase}`.normalize("NFKD");

    return pbkdf2.deriveKey(hmac.HashAlgorithm.Sha512, input, salt, 2048, 64);
}
// Filename: packages/cryptography/src/primitive/ecdsa.js
import { keccak256 } from "./keccak.js";
import * as hex from "../encoding/hex.js";
import elliptic from "elliptic";

const secp256k1 = new elliptic.ec("secp256k1");

/**
 * @typedef {import("../EcdsaPrivateKey.js").KeyPair} KeyPair
 */

/**
 * @returns {KeyPair}
 */
export function generate() {
    const keypair = secp256k1.genKeyPair();

    return {
        privateKey: hex.decode(keypair.getPrivate("hex")),
        publicKey: hex.decode(keypair.getPublic(true, "hex")),
    };
}

/**
 * @returns {Promise<KeyPair>}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export async function generateAsync() {
    return Promise.resolve(generate());
}

/**
 * @param {Uint8Array} data
 * @returns {KeyPair}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function fromBytes(data) {
    const keypair = secp256k1.keyFromPrivate(data);

    return {
        privateKey: hex.decode(keypair.getPrivate("hex")),
        publicKey: hex.decode(keypair.getPublic(true, "hex")),
    };
}

/**
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function getFullPublicKey(data) {
    const keypair = secp256k1.keyFromPublic(data);

    return hex.decode(keypair.getPublic(false, "hex"));
}

/**
 * @param {Uint8Array} keydata
 * @param {Uint8Array} message
 * @returns {Uint8Array}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function sign(keydata, message) {
    const msg = hex.encode(message);
    const data = hex.decode(keccak256(`0x${msg}`));
    const keypair = secp256k1.keyFromPrivate(keydata);
    const signature = keypair.sign(data);

    const r = signature.r.toArray("be", 32);
    const s = signature.s.toArray("be", 32);

    const result = new Uint8Array(64);
    result.set(r, 0);
    result.set(s, 32);
    return result;
}

/**
 * @param {Uint8Array} keydata
 * @param {Uint8Array} message
 * @param {Uint8Array} signature
 * @returns {boolean}
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function verify(keydata, message, signature) {
    const msg = hex.encode(message);
    const data = hex.decode(keccak256(`0x${msg}`));
    const keypair = secp256k1.keyFromPublic(keydata);

    return keypair.verify(data, {
        r: signature.subarray(0, 32),
        s: signature.subarray(32, 64),
    });
}
// Filename: packages/cryptography/src/primitive/hmac.browser.js
import * as utf8 from "../encoding/utf8.js";

// this will be executed in browser environment so we can use window.crypto
/* eslint-disable n/no-unsupported-features/node-builtins */

/**
 * @enum {string}
 */
export const HashAlgorithm = {
    Sha256: "SHA-256",
    Sha384: "SHA-384",
    Sha512: "SHA-512",
};

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} secretKey
 * @param {Uint8Array | string} data
 * @returns {Promise<Uint8Array>}
 */
export async function hash(algorithm, secretKey, data) {
    const key =
        typeof secretKey === "string" ? utf8.encode(secretKey) : secretKey;
    const value = typeof data === "string" ? utf8.encode(data) : data;

    try {
        const key_ = await window.crypto.subtle.importKey(
            "raw",
            key,
            {
                name: "HMAC",
                hash: algorithm,
            },
            false,
            ["sign"],
        );

        return new Uint8Array(
            await window.crypto.subtle.sign("HMAC", key_, value),
        );
    } catch {
        throw new Error("Fallback if SubtleCrypto fails is not implemented");
    }
}
// Filename: packages/cryptography/src/primitive/hmac.js
import crypto from "crypto";
import * as utf8 from "../encoding/utf8.js";

/**
 * @enum {string}
 */
export const HashAlgorithm = {
    Sha256: "SHA-256",
    Sha384: "SHA-384",
    Sha512: "SHA-512",
};

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} secretKey
 * @param {Uint8Array | string} data
 * @returns {Promise<Uint8Array>}
 */
export function hash(algorithm, secretKey, data) {
    const key =
        typeof secretKey === "string" ? utf8.encode(secretKey) : secretKey;
    const value = typeof data === "string" ? utf8.encode(data) : data;

    switch (algorithm) {
        case HashAlgorithm.Sha256:
            return Promise.resolve(
                crypto.createHmac("SHA256", key).update(value).digest(),
            );
        case HashAlgorithm.Sha384:
            return Promise.resolve(
                crypto.createHmac("SHA384", key).update(value).digest(),
            );
        case HashAlgorithm.Sha512:
            return Promise.resolve(
                crypto.createHmac("SHA512", key).update(value).digest(),
            );
        default:
            throw new Error(
                "(BUG) Non-Exhaustive switch statement for algorithms",
            );
    }
}
// Filename: packages/cryptography/src/primitive/hmac.native.js
import CryptoJS from "crypto-js";
import * as utf8 from "../encoding/utf8.js";
import * as hex from "../encoding/hex.js";

/**
 * @enum {string}
 */
export const HashAlgorithm = {
    Sha256: "SHA-256",
    Sha384: "SHA-384",
    Sha512: "SHA-512",
};

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} secretKey
 * @param {Uint8Array | string} data
 * @returns {Promise<Uint8Array>}
 */
export function hash(algorithm, secretKey, data) {
    const key =
        typeof secretKey === "string" ? utf8.encode(secretKey) : secretKey;
    const value = typeof data === "string" ? utf8.encode(data) : data;

    const key_ = CryptoJS.enc.Hex.parse(hex.encode(key));
    const value_ = CryptoJS.enc.Hex.parse(hex.encode(value));

    switch (algorithm) {
        case HashAlgorithm.Sha256:
            return Promise.resolve(
                hex.decode(
                    CryptoJS.HmacSHA256(value_, key_).toString(
                        CryptoJS.enc.Hex,
                    ),
                ),
            );
        case HashAlgorithm.Sha384:
            return Promise.resolve(
                hex.decode(
                    CryptoJS.HmacSHA384(value_, key_).toString(
                        CryptoJS.enc.Hex,
                    ),
                ),
            );
        case HashAlgorithm.Sha512:
            return Promise.resolve(
                hex.decode(
                    CryptoJS.HmacSHA512(value_, key_).toString(
                        CryptoJS.enc.Hex,
                    ),
                ),
            );
        default:
            throw new Error(
                "(BUG) Non-Exhaustive switch statement for algorithms",
            );
    }
}
// Filename: packages/cryptography/src/primitive/keccak.js
// Originally sourced from:
// https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
//  - added type declarations
//  - switched to es6 module syntax
//
// Disable linting for entire file because it's nearly all pure JS
// eslint-disable

const HEX_CHARS = "0123456789abcdef".split("");
const KECCAK_PADDING = [1, 256, 65536, 16777216];
const SHIFT = [0, 8, 16, 24];
const RC = [
    1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
    2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
    2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
    2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
    2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648,
    2147483649, 0, 2147516424, 2147483648,
];

/**
 * @typedef {object} KeccakT
 * @property {number[]} blocks
 * @property {number} blockCount
 * @property {number} outputBlocks
 * @property {number[]} s
 * @property {number} start
 * @property {number} block
 * @property {boolean} reset
 * @property {number=} lastByteIndex
 */

/** @type {(bits: number) => KeccakT} */
const Keccak = (bits) => ({
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    blockCount: (1600 - (bits << 1)) >> 5,
    outputBlocks: bits >> 5,
    // @ts-ignore
    s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
});

/** @type {(state: KeccakT, message: string | number[]) => string} */
const update = (state, /** @type {string | number[]} */ message) => {
    var length = message.length,
        blocks = state.blocks,
        byteCount = state.blockCount << 2,
        blockCount = state.blockCount,
        outputBlocks = state.outputBlocks,
        s = state.s,
        index = 0,
        i,
        code;

    // update
    while (index < length) {
        if (state.reset) {
            state.reset = false;
            blocks[0] = state.block;
            for (i = 1; i < blockCount + 1; ++i) {
                blocks[i] = 0;
            }
        }
        if (typeof message !== "string") {
            for (i = state.start; index < length && i < byteCount; ++index) {
                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
        } else {
            for (i = state.start; index < length && i < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 0x80) {
                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 0x800) {
                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                } else if (code < 0xd800 || code >= 0xe000) {
                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                } else {
                    code =
                        0x10000 +
                        (((code & 0x3ff) << 10) |
                            (message.charCodeAt(++index) & 0x3ff));
                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                }
            }
        }
        state.lastByteIndex = i;
        if (i >= byteCount) {
            state.start = i - byteCount;
            state.block = blocks[blockCount];
            for (i = 0; i < blockCount; ++i) {
                s[i] ^= blocks[i];
            }
            f(s);
            state.reset = true;
        } else {
            state.start = i;
        }
    }

    // finalize
    i = state.lastByteIndex;
    // @ts-ignore
    blocks[i >> 2] |= KECCAK_PADDING[i & 3];
    if (state.lastByteIndex === byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
        }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
    }
    f(s);

    // toString
    var hex = "";
    var block;
    var j = 0;
    i = 0;
    while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            block = s[i];
            hex +=
                HEX_CHARS[(block >> 4) & 0x0f] +
                HEX_CHARS[block & 0x0f] +
                HEX_CHARS[(block >> 12) & 0x0f] +
                HEX_CHARS[(block >> 8) & 0x0f] +
                HEX_CHARS[(block >> 20) & 0x0f] +
                HEX_CHARS[(block >> 16) & 0x0f] +
                HEX_CHARS[(block >> 28) & 0x0f] +
                HEX_CHARS[(block >> 24) & 0x0f];
        }
        if (j % blockCount === 0) {
            f(s);
            i = 0;
        }
    }
    // @ts-ignore
    return "0x" + hex;
};

/** @type {(s: number[]) => void} */
const f = (s) => {
    var h,
        l,
        n,
        c0,
        c1,
        c2,
        c3,
        c4,
        c5,
        c6,
        c7,
        c8,
        c9,
        b0,
        b1,
        b2,
        b3,
        b4,
        b5,
        b6,
        b7,
        b8,
        b9,
        b10,
        b11,
        b12,
        b13,
        b14,
        b15,
        b16,
        b17,
        b18,
        b19,
        b20,
        b21,
        b22,
        b23,
        b24,
        b25,
        b26,
        b27,
        b28,
        b29,
        b30,
        b31,
        b32,
        b33,
        b34,
        b35,
        b36,
        b37,
        b38,
        b39,
        b40,
        b41,
        b42,
        b43,
        b44,
        b45,
        b46,
        b47,
        b48,
        b49;

    for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

        h = c8 ^ ((c2 << 1) | (c3 >>> 31));
        l = c9 ^ ((c3 << 1) | (c2 >>> 31));
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ ((c4 << 1) | (c5 >>> 31));
        l = c1 ^ ((c5 << 1) | (c4 >>> 31));
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ ((c6 << 1) | (c7 >>> 31));
        l = c3 ^ ((c7 << 1) | (c6 >>> 31));
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ ((c8 << 1) | (c9 >>> 31));
        l = c5 ^ ((c9 << 1) | (c8 >>> 31));
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ ((c0 << 1) | (c1 >>> 31));
        l = c7 ^ ((c1 << 1) | (c0 >>> 31));
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;

        b0 = s[0];
        b1 = s[1];
        b32 = (s[11] << 4) | (s[10] >>> 28);
        b33 = (s[10] << 4) | (s[11] >>> 28);
        b14 = (s[20] << 3) | (s[21] >>> 29);
        b15 = (s[21] << 3) | (s[20] >>> 29);
        b46 = (s[31] << 9) | (s[30] >>> 23);
        b47 = (s[30] << 9) | (s[31] >>> 23);
        b28 = (s[40] << 18) | (s[41] >>> 14);
        b29 = (s[41] << 18) | (s[40] >>> 14);
        b20 = (s[2] << 1) | (s[3] >>> 31);
        b21 = (s[3] << 1) | (s[2] >>> 31);
        b2 = (s[13] << 12) | (s[12] >>> 20);
        b3 = (s[12] << 12) | (s[13] >>> 20);
        b34 = (s[22] << 10) | (s[23] >>> 22);
        b35 = (s[23] << 10) | (s[22] >>> 22);
        b16 = (s[33] << 13) | (s[32] >>> 19);
        b17 = (s[32] << 13) | (s[33] >>> 19);
        b48 = (s[42] << 2) | (s[43] >>> 30);
        b49 = (s[43] << 2) | (s[42] >>> 30);
        b40 = (s[5] << 30) | (s[4] >>> 2);
        b41 = (s[4] << 30) | (s[5] >>> 2);
        b22 = (s[14] << 6) | (s[15] >>> 26);
        b23 = (s[15] << 6) | (s[14] >>> 26);
        b4 = (s[25] << 11) | (s[24] >>> 21);
        b5 = (s[24] << 11) | (s[25] >>> 21);
        b36 = (s[34] << 15) | (s[35] >>> 17);
        b37 = (s[35] << 15) | (s[34] >>> 17);
        b18 = (s[45] << 29) | (s[44] >>> 3);
        b19 = (s[44] << 29) | (s[45] >>> 3);
        b10 = (s[6] << 28) | (s[7] >>> 4);
        b11 = (s[7] << 28) | (s[6] >>> 4);
        b42 = (s[17] << 23) | (s[16] >>> 9);
        b43 = (s[16] << 23) | (s[17] >>> 9);
        b24 = (s[26] << 25) | (s[27] >>> 7);
        b25 = (s[27] << 25) | (s[26] >>> 7);
        b6 = (s[36] << 21) | (s[37] >>> 11);
        b7 = (s[37] << 21) | (s[36] >>> 11);
        b38 = (s[47] << 24) | (s[46] >>> 8);
        b39 = (s[46] << 24) | (s[47] >>> 8);
        b30 = (s[8] << 27) | (s[9] >>> 5);
        b31 = (s[9] << 27) | (s[8] >>> 5);
        b12 = (s[18] << 20) | (s[19] >>> 12);
        b13 = (s[19] << 20) | (s[18] >>> 12);
        b44 = (s[29] << 7) | (s[28] >>> 25);
        b45 = (s[28] << 7) | (s[29] >>> 25);
        b26 = (s[38] << 8) | (s[39] >>> 24);
        b27 = (s[39] << 8) | (s[38] >>> 24);
        b8 = (s[48] << 14) | (s[49] >>> 18);
        b9 = (s[49] << 14) | (s[48] >>> 18);

        s[0] = b0 ^ (~b2 & b4);
        s[1] = b1 ^ (~b3 & b5);
        s[10] = b10 ^ (~b12 & b14);
        s[11] = b11 ^ (~b13 & b15);
        s[20] = b20 ^ (~b22 & b24);
        s[21] = b21 ^ (~b23 & b25);
        s[30] = b30 ^ (~b32 & b34);
        s[31] = b31 ^ (~b33 & b35);
        s[40] = b40 ^ (~b42 & b44);
        s[41] = b41 ^ (~b43 & b45);
        s[2] = b2 ^ (~b4 & b6);
        s[3] = b3 ^ (~b5 & b7);
        s[12] = b12 ^ (~b14 & b16);
        s[13] = b13 ^ (~b15 & b17);
        s[22] = b22 ^ (~b24 & b26);
        s[23] = b23 ^ (~b25 & b27);
        s[32] = b32 ^ (~b34 & b36);
        s[33] = b33 ^ (~b35 & b37);
        s[42] = b42 ^ (~b44 & b46);
        s[43] = b43 ^ (~b45 & b47);
        s[4] = b4 ^ (~b6 & b8);
        s[5] = b5 ^ (~b7 & b9);
        s[14] = b14 ^ (~b16 & b18);
        s[15] = b15 ^ (~b17 & b19);
        s[24] = b24 ^ (~b26 & b28);
        s[25] = b25 ^ (~b27 & b29);
        s[34] = b34 ^ (~b36 & b38);
        s[35] = b35 ^ (~b37 & b39);
        s[44] = b44 ^ (~b46 & b48);
        s[45] = b45 ^ (~b47 & b49);
        s[6] = b6 ^ (~b8 & b0);
        s[7] = b7 ^ (~b9 & b1);
        s[16] = b16 ^ (~b18 & b10);
        s[17] = b17 ^ (~b19 & b11);
        s[26] = b26 ^ (~b28 & b20);
        s[27] = b27 ^ (~b29 & b21);
        s[36] = b36 ^ (~b38 & b30);
        s[37] = b37 ^ (~b39 & b31);
        s[46] = b46 ^ (~b48 & b40);
        s[47] = b47 ^ (~b49 & b41);
        s[8] = b8 ^ (~b0 & b2);
        s[9] = b9 ^ (~b1 & b3);
        s[18] = b18 ^ (~b10 & b12);
        s[19] = b19 ^ (~b11 & b13);
        s[28] = b28 ^ (~b20 & b22);
        s[29] = b29 ^ (~b21 & b23);
        s[38] = b38 ^ (~b30 & b32);
        s[39] = b39 ^ (~b31 & b33);
        s[48] = b48 ^ (~b40 & b42);
        s[49] = b49 ^ (~b41 & b43);

        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
    }
};

const keccak = (/** @type {number} */ bits) => (/** @type {string} */ str) => {
    var msg;
    if (str.slice(0, 2) === "0x") {
        msg = [];
        for (var i = 2, l = str.length; i < l; i += 2)
            msg.push(parseInt(str.slice(i, i + 2), 16));
    } else {
        msg = str;
    }
    // @ts-ignore
    return update(Keccak(bits), msg);
};

/**
 * @type {(message: string) => string}
 */
export const keccak256 = keccak(256);
// Filename: packages/cryptography/src/primitive/keystore.js
import BadKeyError from "../BadKeyError.js";
import * as crypto from "./aes.js";
import * as hex from "../encoding/hex.js";
import * as utf8 from "../encoding/utf8.js";
import * as hmac from "./hmac.js";
import * as pbkdf2 from "./pbkdf2.js";
import * as random from "./random.js";

const HMAC_SHA256 = "hmac-sha256";

/**
 * @typedef {object} KeystoreKdfParams
 * @property {number} dkLen
 * @property {string} salt
 * @property {number} c
 * @property {string} prf
 */

/**
 * @typedef {object} KeystoreCipherParams
 * @property {string} iv
 */

/**
 * @typedef {object} KeystoreCrypto
 * @property {string} ciphertext
 * @property {KeystoreCipherParams} cipherparams
 * @property {string} cipher
 * @property {string} kdf
 * @property {KeystoreKdfParams} kdfparams
 * @property {string} mac
 */

/**
 * @typedef {object} Keystore
 * @property {number} version
 * @property {KeystoreCrypto} crypto
 */

/**
 * @param {Uint8Array} privateKey
 * @param {string} passphrase
 * @returns {Promise<Uint8Array>}
 */
export async function createKeystore(privateKey, passphrase) {
    // all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25
    const dkLen = 32;
    const c = 262144;
    const saltLen = 32;
    const salt = await random.bytesAsync(saltLen);

    const key = await pbkdf2.deriveKey(
        hmac.HashAlgorithm.Sha256,
        passphrase,
        salt,
        c,
        dkLen,
    );

    const iv = await random.bytesAsync(16);

    // AES-128-CTR with the first half of the derived key and a random IV
    const cipherText = await crypto.createCipheriv(
        crypto.CipherAlgorithm.Aes128Ctr,
        key.slice(0, 16),
        iv,
        privateKey,
    );

    const mac = await hmac.hash(
        hmac.HashAlgorithm.Sha384,
        key.slice(16),
        cipherText,
    );

    /**
     * @type {Keystore}
     */
    const keystore = {
        version: 1,
        crypto: {
            ciphertext: hex.encode(cipherText),
            cipherparams: { iv: hex.encode(iv) },
            cipher: crypto.CipherAlgorithm.Aes128Ctr,
            kdf: "pbkdf2",
            kdfparams: {
                dkLen,
                salt: hex.encode(salt),
                c,
                prf: HMAC_SHA256,
            },
            mac: hex.encode(mac),
        },
    };

    return utf8.encode(JSON.stringify(keystore));
}

/**
 * @param {Uint8Array} keystoreBytes
 * @param {string} passphrase
 * @returns {Promise<Uint8Array>}
 */
export async function loadKeystore(keystoreBytes, passphrase) {
    /**
     * @type {Keystore}
     */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const keystore = JSON.parse(utf8.decode(keystoreBytes));

    if (keystore.version !== 1) {
        throw new BadKeyError(
            `unsupported keystore version: ${keystore.version}`,
        );
    }

    const {
        ciphertext,
        cipherparams: { iv },
        cipher,
        kdf,
        kdfparams: { dkLen, salt, c, prf },
        mac,
    } = keystore.crypto;

    if (kdf !== "pbkdf2") {
        throw new BadKeyError(`unsupported key derivation function:" + ${kdf}`);
    }

    if (prf !== HMAC_SHA256) {
        throw new BadKeyError(
            `unsupported key derivation hash function: ${prf}`,
        );
    }

    const saltBytes = hex.decode(salt);
    const ivBytes = hex.decode(iv);
    const cipherBytes = hex.decode(ciphertext);

    const key = await pbkdf2.deriveKey(
        hmac.HashAlgorithm.Sha256,
        passphrase,
        saltBytes,
        c,
        dkLen,
    );

    const macHex = hex.decode(mac);
    const verifyHmac = await hmac.hash(
        hmac.HashAlgorithm.Sha384,
        key.slice(16),
        cipherBytes,
    );

    // compare that these two Uint8Arrays are equivalent
    if (!macHex.every((b, i) => b === verifyHmac[i])) {
        throw new BadKeyError("HMAC mismatch; passphrase is incorrect");
    }

    return crypto.createDecipheriv(
        cipher,
        key.slice(0, 16),
        ivBytes,
        cipherBytes,
    );
}
// Filename: packages/cryptography/src/primitive/pbkdf2.browser.js
import * as utf8 from "../encoding/utf8.js";

// this will be executed in browser environment so we can use window.crypto
/* eslint-disable n/no-unsupported-features/node-builtins */

/**
 * @typedef {import("./hmac.js").HashAlgorithm} HashAlgorithm
 */

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} password
 * @param {Uint8Array | string} salt
 * @param {number} iterations
 * @param {number} length
 * @returns {Promise<Uint8Array>}
 */
export async function deriveKey(algorithm, password, salt, iterations, length) {
    const pass =
        typeof password === "string"
            ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
              // should be fine if only valid ASCII characters are used in the password
              utf8.encode(password)
            : password;

    const nacl = typeof salt === "string" ? utf8.encode(salt) : salt;

    try {
        const key = await window.crypto.subtle.importKey(
            "raw",
            pass,
            {
                name: "PBKDF2",
                hash: algorithm,
            },
            false,
            ["deriveBits"],
        );

        return new Uint8Array(
            await window.crypto.subtle.deriveBits(
                {
                    name: "PBKDF2",
                    hash: algorithm,
                    salt: nacl,
                    iterations,
                },
                key,
                length << 3,
            ),
        );
    } catch {
        throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
    }
}
// Filename: packages/cryptography/src/primitive/pbkdf2.js
import { HashAlgorithm } from "./hmac.js";
import * as utf8 from "../encoding/utf8.js";
import util from "util";
import crypto from "crypto";

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} password
 * @param {Uint8Array | string} salt
 * @param {number} iterations
 * @param {number} length
 * @returns {Promise<Uint8Array>}
 */
export async function deriveKey(algorithm, password, salt, iterations, length) {
    const pass =
        typeof password === "string"
            ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
              // should be fine if only valid ASCII characters are used in the password
              utf8.encode(password)
            : password;

    const nacl = typeof salt === "string" ? utf8.encode(salt) : salt;

    const pbkdf2 = util.promisify(crypto.pbkdf2);

    switch (algorithm) {
        case HashAlgorithm.Sha256:
            return pbkdf2(pass, nacl, iterations, length, "sha256");
        case HashAlgorithm.Sha384:
            return pbkdf2(pass, nacl, iterations, length, "sha384");
        case HashAlgorithm.Sha512:
            return pbkdf2(pass, nacl, iterations, length, "sha512");
        default:
            throw new Error(
                "(BUG) Non-Exhaustive switch statement for algorithms",
            );
    }
}
// Filename: packages/cryptography/src/primitive/pbkdf2.native.js
import { HashAlgorithm } from "./hmac.js";
import * as utf8 from "../encoding/utf8.js";
import * as hex from "../encoding/hex.js";
import CryptoJS from "crypto-js";

/**
 * @param {HashAlgorithm} algorithm
 * @param {Uint8Array | string} password
 * @param {Uint8Array | string} salt
 * @param {number} iterations
 * @param {number} length
 * @returns {Promise<Uint8Array>}
 */
export async function deriveKey(algorithm, password, salt, iterations, length) {
    const pass =
        typeof password === "string"
            ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
              // should be fine if only valid ASCII characters are used in the password
              utf8.encode(password)
            : password;

    const nacl = typeof salt === "string" ? utf8.encode(salt) : salt;

    const password_ = CryptoJS.enc.Hex.parse(hex.encode(pass));
    const nacl_ = CryptoJS.enc.Hex.parse(hex.encode(nacl));

    let hasher;
    switch (algorithm) {
        case HashAlgorithm.Sha256:
            hasher = CryptoJS.algo.SHA256;
            break;
        case HashAlgorithm.Sha384:
            hasher = CryptoJS.algo.SHA384;
            break;
        case HashAlgorithm.Sha512:
            hasher = CryptoJS.algo.SHA512;
            break;
        default:
            throw new Error(
                "(BUG) Non-Exhaustive switch statement for algorithms",
            );
    }

    const cfg = {
        keySize: length / 4,
        hasher,
        iterations,
    };

    return Promise.resolve(
        hex.decode(
            CryptoJS.PBKDF2(password_, nacl_, cfg).toString(CryptoJS.enc.Hex),
        ),
    );
}
// Filename: packages/cryptography/src/primitive/pkcs.js
import * as crypto from "./aes.js";
import * as der from "../encoding/der.js";
import * as pbkdf2 from "./pbkdf2.js";
import * as hmac from "./hmac.js";

export class AlgorithmIdentifier {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
            /**
             * @type {string}
             */
            this.algIdent = asn.seq[0].ident;

            /**
             * @type {import("../encoding/der.js").AsnType | undefined}
             */
            this.parameters = asn.seq[1];
        } else {
            throw new Error(
                `error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`,
            );
        }
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this);
    }
}

class PBES2Params {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length === 2) {
            /**
             * @type {AlgorithmIdentifier}
             */
            this.kdf = new AlgorithmIdentifier(asn.seq[0]);

            /**
             * @type {AlgorithmIdentifier}
             */
            this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
        } else {
            throw new Error(
                `error parsing PBES2Params from ${JSON.stringify(asn)}`,
            );
        }
    }
}

class PBKDF2Params {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if (
            "seq" in asn &&
            asn.seq.length >= 2 &&
            "bytes" in asn.seq[0] &&
            "int" in asn.seq[1]
        ) {
            /**
             * @type {Uint8Array}
             */
            this.salt = asn.seq[0].bytes;

            /**
             * @type {number}
             */
            this.iterCount = asn.seq[1]["int"];

            if (asn.seq.length > 2) {
                if ("seq" in asn.seq[2]) {
                    this.prf = new AlgorithmIdentifier(asn.seq[2]);
                    return;
                } else if ("int" in asn.seq[2]) {
                    /**
                     * @type {number | undefined}
                     */
                    this.keyLength = asn.seq[2]["int"];
                }

                if (asn.seq.length === 4) {
                    /**
                     * @type {AlgorithmIdentifier | undefined}
                     */
                    this.prf = new AlgorithmIdentifier(asn.seq[3]);
                }

                return;
            }
        }

        throw new Error(
            `error parsing PBKDF2Params from ${JSON.stringify(asn)}`,
        );
    }
}

export class PrivateKeyInfo {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length === 3) {
            if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
                /**
                 * @type {number}
                 */
                this.version = 0;
            } else {
                throw new Error(
                    `expected version = 0, got ${JSON.stringify(asn.seq[0])}`,
                );
            }

            /**
             * @type {AlgorithmIdentifier}
             */
            this.algId = new AlgorithmIdentifier(asn.seq[1]);

            if ("bytes" in asn.seq[2]) {
                /**
                 * @type {Uint8Array}
                 */
                this.privateKey = asn.seq[2].bytes;
            } else {
                throw new Error(
                    `expected octet string as 3rd element, got ${JSON.stringify(
                        asn.seq[2],
                    )}`,
                );
            }

            return;
        }

        throw new Error(
            `error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`,
        );
    }

    /**
     * @param {Uint8Array} encoded
     * @returns {PrivateKeyInfo}
     */
    static parse(encoded) {
        return new PrivateKeyInfo(der.decode(encoded));
    }
}

export class EncryptedPrivateKeyInfo {
    /**
     * @param {import("../encoding/der.js").AsnType} asn
     */
    constructor(asn) {
        if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
            /**
             * @type {AlgorithmIdentifier}
             */
            this.algId = new AlgorithmIdentifier(asn.seq[0]);

            /**
             * @type {Uint8Array}
             */
            this.data = asn.seq[1].bytes;
            return;
        }

        throw new Error(
            `error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`,
        );
    }

    /**
     * @param {Uint8Array} encoded
     * @returns {EncryptedPrivateKeyInfo}
     */
    static parse(encoded) {
        return new EncryptedPrivateKeyInfo(der.decode(encoded));
    }

    /**
     * @param {string} passphrase
     * @returns {Promise<PrivateKeyInfo>}
     */
    async decrypt(passphrase) {
        if (
            this.algId.algIdent !== "1.2.840.113549.1.5.13" ||
            !this.algId.parameters
        ) {
            // PBES2
            throw new Error(
                `unsupported key encryption algorithm: ${this.algId.toString()}`,
            );
        }

        const pbes2Params = new PBES2Params(this.algId.parameters);

        if (
            pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" ||
            !pbes2Params.kdf.parameters
        ) {
            // PBKDF2
            throw new Error(
                `unsupported key derivation function: ${pbes2Params.kdf.toString()}`,
            );
        }

        const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);

        if (!pbkdf2Params.prf) {
            throw new Error("unsupported PRF HMAC-SHA-1");
        } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
            // HMAC-SHA-256
            throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
        }

        if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
            // AES-128-CBC
            throw new Error(
                `unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`,
            );
        }

        if (
            !pbes2Params.encScheme.parameters ||
            !("bytes" in pbes2Params.encScheme.parameters)
        ) {
            throw new Error(
                "expected IV as bytes for AES-128-CBC, " +
                    `got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`,
            );
        }

        const keyLen = pbkdf2Params.keyLength || 16;
        const iv = pbes2Params.encScheme.parameters.bytes;

        const key = await pbkdf2.deriveKey(
            hmac.HashAlgorithm.Sha256,
            passphrase,
            pbkdf2Params.salt,
            pbkdf2Params.iterCount,
            keyLen,
        );

        const decrypted = await crypto.createDecipheriv(
            crypto.CipherAlgorithm.Aes128Cbc,
            key,
            iv,
            this.data,
        );

        return PrivateKeyInfo.parse(decrypted);
    }
}
// Filename: packages/cryptography/src/primitive/random.js
import nacl from "tweetnacl";

/**
 * @param {number} count
 * @returns {Uint8Array}
 */
export function bytes(count) {
    return nacl.randomBytes(count);
}

/**
 * @param {number} count
 * @returns {Promise<Uint8Array>}
 */
export function bytesAsync(count) {
    return Promise.resolve(nacl.randomBytes(count));
}
// Filename: packages/cryptography/src/primitive/sha256.browser.js
// this will be executed in browser environment so we can use window.crypto
/* eslint-disable n/no-unsupported-features/node-builtins */

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export async function digest(data) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
    return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
}
// Filename: packages/cryptography/src/primitive/sha256.js
import crypto from "crypto";

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
// eslint-disable-next-line @typescript-eslint/require-await
export async function digest(data) {
    // fallback to trying node-crypto which could be polyfilled by the browser environment
    return crypto.createHash("sha256").update(data).digest();
}
// Filename: packages/cryptography/src/primitive/sha256.native.js
import CryptoJS from "crypto-js";
import * as hex from "../encoding/hex.js";

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
// eslint-disable-next-line @typescript-eslint/require-await
export async function digest(data) {
    return Promise.resolve(
        hex.decode(
            CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hex.encode(data))).toString(
                CryptoJS.enc.Hex,
            ),
        ),
    );
}
// Filename: packages/cryptography/src/primitive/slip10.js
import * as hmac from "../primitive/hmac.js";
import * as bip32 from "../primitive/bip32.js";

/**
 * @param {Uint8Array} parentKey
 * @param {Uint8Array} chainCode
 * @param {number} index
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function derive(parentKey, chainCode, index) {
    if (bip32.isHardenedIndex(index)) {
        throw new Error("the index should not be pre-hardened");
    }

    const input = new Uint8Array(37);

    // 0x00 + parentKey + index(BE)
    input[0] = 0;
    input.set(parentKey, 1);
    new DataView(input.buffer, input.byteOffset, input.byteLength).setUint32(
        33,
        index,
        false,
    );

    // set the index to hardened
    input[33] |= 128;

    const digest = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, input);

    return { keyData: digest.subarray(0, 32), chainCode: digest.subarray(32) };
}

/**
 * @param {Uint8Array} seed
 * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}
 */
export async function fromSeed(seed) {
    const digest = await hmac.hash(
        hmac.HashAlgorithm.Sha512,
        "ed25519 seed",
        seed,
    );

    return { keyData: digest.subarray(0, 32), chainCode: digest.subarray(32) };
}
// Filename: packages/cryptography/src/util/array.js
/**
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
export function arrayEqual(array1, array2) {
    if (array1 === array2) {
        return true;
    }

    if (array1.byteLength !== array2.byteLength) {
        return false;
    }

    const view1 = new DataView(
        array1.buffer,
        array1.byteOffset,
        array1.byteLength,
    );
    const view2 = new DataView(
        array2.buffer,
        array2.byteOffset,
        array2.byteLength,
    );

    let i = array1.byteLength;

    while (i--) {
        if (view1.getUint8(i) !== view2.getUint8(i)) {
            return false;
        }
    }

    return true;
}

/**
 * @param {Uint8Array} array
 * @param {Uint8Array} arrayPrefix
 * @returns {boolean}
 */
export function arrayStartsWith(array, arrayPrefix) {
    if (array.byteLength < arrayPrefix.byteLength) {
        return false;
    }

    let i = arrayPrefix.byteLength;

    while (i--) {
        if (array[i] !== arrayPrefix[i]) {
            return false;
        }
    }

    return true;
}
// Filename: packages/cryptography/src/util/derive.js
import * as pbkdf2 from "../primitive/pbkdf2.js";
import * as hmac from "../primitive/hmac.js";

/**
 * @param {Uint8Array} seed
 * @param {number} index
 * @returns {Promise<Uint8Array>}
 */
export function legacy(seed, index) {
    const password = new Uint8Array(seed.length + 8);
    password.set(seed, 0);

    const view = new DataView(
        password.buffer,
        password.byteOffset,
        password.byteLength,
    );

    if (index === 0xffffffffff) {
        view.setInt32(seed.length + 0, 0xff);
        view.setInt32(seed.length + 4, -1); // 0xffffffff
    } else {
        view.setInt32(seed.length + 0, index < 0 ? -1 : 0);
        view.setInt32(seed.length + 4, index);
    }

    const salt = Uint8Array.from([0xff]);
    return pbkdf2.deriveKey(
        hmac.HashAlgorithm.Sha512,
        password,
        salt,
        2048,
        32,
    );
}
// Filename: packages/cryptography/src/util/entropy.js
import BigNumber from "bignumber.js";
import * as sha256 from "../primitive/sha256.js";

/**
 * @param {string[]} words
 * @param {string[]} wordlist
 * @returns {[Uint8Array, number]}
 */
export function legacy1(words, wordlist) {
    const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));

    const data = convertRadix(indicies, wordlist.length, 256, 33);
    const checksum = data[data.length - 1];
    const result = new Uint8Array(data.length - 1);

    for (let i = 0; i < data.length - 1; i += 1) {
        result[i] = data[i] ^ checksum;
    }

    return [result, checksum];
}

/**
 * @param {string[]} words
 * @param {string[]} wordlist
 * @returns {Promise<Uint8Array>}
 */
export async function legacy2(words, wordlist) {
    const concatBitsLen = words.length * 11;
    /** @type {boolean[]} */
    const concatBits = [];
    concatBits.fill(false, 0, concatBitsLen);

    for (const [wordIndex, word] of words.entries()) {
        const index = wordlist.indexOf(word.toLowerCase());

        if (index < 0) {
            throw new Error(`Word not found in wordlist: ${word}`);
        }

        for (let i = 0; i < 11; i += 1) {
            concatBits[wordIndex * 11 + i] = (index & (1 << (10 - i))) !== 0;
        }
    }

    const checksumBitsLen = concatBitsLen / 33;
    const entropyBitsLen = concatBitsLen - checksumBitsLen;
    const entropy = new Uint8Array(entropyBitsLen / 8);

    for (let i = 0; i < entropy.length; i += 1) {
        for (let j = 0; j < 8; j += 1) {
            if (concatBits[i * 8 + j]) {
                entropy[i] |= 1 << (7 - j);
            }
        }
    }

    // Checksum validation
    const hash = await sha256.digest(entropy);
    const hashBits = bytesToBits(hash);

    for (let i = 0; i < checksumBitsLen; i += 1) {
        if (concatBits[entropyBitsLen + i] !== hashBits[i]) {
            throw new Error("Checksum mismatch");
        }
    }

    return entropy;
}

/**
 * @param {Uint8Array} data
 * @returns {number}
 */
export function crc8(data) {
    let crc = 0xff;

    for (let i = 0; i < data.length - 1; i += 1) {
        crc ^= data[i];
        for (let j = 0; j < 8; j += 1) {
            crc = (crc >>> 1) ^ ((crc & 1) === 0 ? 0 : 0xb2);
        }
    }

    return crc ^ 0xff;
}

/**
 * @param {number[]} nums
 * @param {number} fromRadix
 * @param {number} toRadix
 * @param {number} toLength
 * @returns {Uint8Array}
 */
export function convertRadix(nums, fromRadix, toRadix, toLength) {
    let num = new BigNumber(0);

    for (const element of nums) {
        num = num.times(fromRadix);
        num = num.plus(element);
    }

    const result = new Uint8Array(toLength);

    for (let i = toLength - 1; i >= 0; i -= 1) {
        const tem = num.dividedToIntegerBy(toRadix);
        const rem = num.modulo(toRadix);
        num = tem;
        result[i] = rem.toNumber();
    }

    return result;
}

/**
 * @param {Uint8Array} data
 * @returns {boolean[]}
 */
export function bytesToBits(data) {
    /** @type {boolean[]} */
    const bits = [];
    bits.fill(false, 0, data.length * 8);

    for (let i = 0; i < data.length; i += 1) {
        for (let j = 0; j < 8; j += 1) {
            bits[i * 8 + j] = (data[i] & (1 << (7 - j))) !== 0;
        }
    }

    return bits;
}
// Filename: packages/cryptography/src/words/bip39.js
export default [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo",
];
// Filename: packages/cryptography/src/words/legacy.js
export default [
    "aback",
    "abbey",
    "abbot",
    "abide",
    "ablaze",
    "able",
    "aboard",
    "abode",
    "abort",
    "abound",
    "about",
    "above",
    "abroad",
    "abrupt",
    "absent",
    "absorb",
    "absurd",
    "abuse",
    "accent",
    "accept",
    "access",
    "accord",
    "accuse",
    "ace",
    "ache",
    "aching",
    "acid",
    "acidic",
    "acorn",
    "acre",
    "across",
    "act",
    "action",
    "active",
    "actor",
    "actual",
    "acute",
    "adam",
    "adapt",
    "add",
    "added",
    "addict",
    "adept",
    "adhere",
    "adjust",
    "admire",
    "admit",
    "adobe",
    "adopt",
    "adrift",
    "adult",
    "adverb",
    "advice",
    "aerial",
    "afar",
    "affair",
    "affect",
    "afford",
    "afghan",
    "afield",
    "afloat",
    "afraid",
    "afresh",
    "after",
    "again",
    "age",
    "agency",
    "agenda",
    "agent",
    "aghast",
    "agile",
    "ago",
    "agony",
    "agree",
    "agreed",
    "ahead",
    "aid",
    "aide",
    "aim",
    "air",
    "airman",
    "airy",
    "akin",
    "alarm",
    "alaska",
    "albeit",
    "album",
    "ale",
    "alert",
    "alibi",
    "alice",
    "alien",
    "alight",
    "align",
    "alike",
    "alive",
    "alkali",
    "all",
    "alley",
    "allied",
    "allow",
    "alloy",
    "ally",
    "almond",
    "almost",
    "aloft",
    "alone",
    "along",
    "aloof",
    "aloud",
    "alpha",
    "alpine",
    "also",
    "altar",
    "alter",
    "always",
    "amaze",
    "amazon",
    "amber",
    "ambush",
    "amen",
    "amend",
    "amid",
    "amidst",
    "amiss",
    "among",
    "amount",
    "ample",
    "amuse",
    "anchor",
    "and",
    "andrew",
    "anew",
    "angel",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "annoy",
    "annual",
    "answer",
    "anthem",
    "any",
    "anyhow",
    "anyway",
    "apart",
    "apathy",
    "apex",
    "apiece",
    "appeal",
    "appear",
    "apple",
    "apply",
    "april",
    "apron",
    "arab",
    "arcade",
    "arcane",
    "arch",
    "arctic",
    "ardent",
    "are",
    "area",
    "argue",
    "arid",
    "arise",
    "ark",
    "arm",
    "armful",
    "army",
    "aroma",
    "around",
    "arouse",
    "array",
    "arrest",
    "arrive",
    "arrow",
    "arson",
    "art",
    "artery",
    "artful",
    "artist",
    "ascent",
    "ash",
    "ashen",
    "ashore",
    "aside",
    "ask",
    "asleep",
    "aspect",
    "assay",
    "assent",
    "assert",
    "assess",
    "asset",
    "assign",
    "assist",
    "assume",
    "assure",
    "asthma",
    "astute",
    "asylum",
    "ate",
    "athens",
    "atlas",
    "atom",
    "atomic",
    "attach",
    "attack",
    "attain",
    "attend",
    "attic",
    "auburn",
    "audio",
    "audit",
    "august",
    "aunt",
    "auntie",
    "aura",
    "austin",
    "author",
    "auto",
    "autumn",
    "avail",
    "avenge",
    "avenue",
    "avert",
    "avid",
    "avoid",
    "await",
    "awake",
    "awaken",
    "award",
    "aware",
    "awash",
    "away",
    "awful",
    "awhile",
    "axe",
    "axes",
    "axiom",
    "axis",
    "axle",
    "aye",
    "babe",
    "baby",
    "bach",
    "back",
    "backup",
    "bacon",
    "bad",
    "badge",
    "badly",
    "bag",
    "baggy",
    "bail",
    "bait",
    "bake",
    "baker",
    "bakery",
    "bald",
    "ball",
    "ballad",
    "ballet",
    "ballot",
    "baltic",
    "bamboo",
    "ban",
    "banal",
    "banana",
    "band",
    "bang",
    "bank",
    "bar",
    "barber",
    "bare",
    "barely",
    "barge",
    "bark",
    "barley",
    "barn",
    "baron",
    "barrel",
    "barren",
    "basalt",
    "base",
    "basic",
    "basil",
    "basin",
    "basis",
    "basket",
    "bass",
    "bat",
    "batch",
    "bath",
    "baton",
    "battle",
    "bay",
    "beach",
    "beacon",
    "beak",
    "beam",
    "bean",
    "bear",
    "beard",
    "beast",
    "beat",
    "beauty",
    "become",
    "bed",
    "beech",
    "beef",
    "beefy",
    "beep",
    "beer",
    "beet",
    "beetle",
    "before",
    "beg",
    "beggar",
    "begin",
    "behalf",
    "behave",
    "behind",
    "beige",
    "being",
    "belief",
    "bell",
    "belly",
    "belong",
    "below",
    "belt",
    "bench",
    "bend",
    "benign",
    "bent",
    "berlin",
    "berry",
    "berth",
    "beset",
    "beside",
    "best",
    "bestow",
    "bet",
    "beta",
    "betray",
    "better",
    "beware",
    "beyond",
    "bias",
    "biceps",
    "bicker",
    "bid",
    "big",
    "bigger",
    "bike",
    "bile",
    "bill",
    "bin",
    "binary",
    "bind",
    "biopsy",
    "birch",
    "bird",
    "birdie",
    "birth",
    "bishop",
    "bit",
    "bitch",
    "bite",
    "bitter",
    "black",
    "blade",
    "blame",
    "bland",
    "blast",
    "blaze",
    "bleak",
    "blend",
    "bless",
    "blew",
    "blind",
    "blink",
    "blip",
    "bliss",
    "blitz",
    "block",
    "blond",
    "blood",
    "bloody",
    "bloom",
    "blot",
    "blouse",
    "blow",
    "blue",
    "bluff",
    "blunt",
    "blur",
    "blush",
    "boar",
    "board",
    "boast",
    "boat",
    "bob",
    "bodily",
    "body",
    "bogus",
    "boil",
    "bold",
    "bolt",
    "bomb",
    "bombay",
    "bond",
    "bone",
    "bonn",
    "bonnet",
    "bonus",
    "bony",
    "book",
    "boom",
    "boost",
    "boot",
    "booth",
    "booze",
    "border",
    "bore",
    "borrow",
    "bosom",
    "boss",
    "boston",
    "both",
    "bother",
    "bottle",
    "bottom",
    "bought",
    "bounce",
    "bound",
    "bounty",
    "bout",
    "bovine",
    "bow",
    "bowel",
    "bowl",
    "box",
    "boy",
    "boyish",
    "brace",
    "brain",
    "brainy",
    "brake",
    "bran",
    "branch",
    "brand",
    "brandy",
    "brass",
    "brave",
    "bravo",
    "brazil",
    "breach",
    "bread",
    "break",
    "breast",
    "breath",
    "bred",
    "breed",
    "breeze",
    "brew",
    "bribe",
    "brick",
    "bride",
    "bridge",
    "brief",
    "bright",
    "brim",
    "brine",
    "bring",
    "brink",
    "brisk",
    "broad",
    "broke",
    "broken",
    "bronze",
    "brook",
    "broom",
    "brown",
    "bruise",
    "brush",
    "brutal",
    "brute",
    "bubble",
    "buck",
    "bucket",
    "buckle",
    "budget",
    "buffet",
    "buggy",
    "build",
    "bulb",
    "bulge",
    "bulk",
    "bulky",
    "bull",
    "bullet",
    "bully",
    "bump",
    "bumpy",
    "bunch",
    "bundle",
    "bunk",
    "bunny",
    "burden",
    "bureau",
    "burial",
    "buried",
    "burly",
    "burn",
    "burnt",
    "burrow",
    "burst",
    "bury",
    "bus",
    "bush",
    "bust",
    "bustle",
    "busy",
    "but",
    "butler",
    "butt",
    "butter",
    "button",
    "buy",
    "buyer",
    "buzz",
    "bye",
    "byte",
    "cab",
    "cabin",
    "cable",
    "cache",
    "cactus",
    "caesar",
    "cage",
    "cairo",
    "cajun",
    "cajole",
    "cake",
    "calf",
    "call",
    "caller",
    "calm",
    "calmly",
    "came",
    "camel",
    "camera",
    "camp",
    "campus",
    "can",
    "canada",
    "canal",
    "canary",
    "cancel",
    "cancer",
    "candid",
    "candle",
    "candy",
    "cane",
    "canine",
    "canoe",
    "canopy",
    "canvas",
    "canyon",
    "cap",
    "cape",
    "car",
    "carbon",
    "card",
    "care",
    "career",
    "caress",
    "cargo",
    "carl",
    "carnal",
    "carol",
    "carp",
    "carpet",
    "carrot",
    "carry",
    "cart",
    "cartel",
    "case",
    "cash",
    "cask",
    "cast",
    "castle",
    "casual",
    "cat",
    "catch",
    "cater",
    "cattle",
    "caught",
    "causal",
    "cause",
    "cave",
    "cease",
    "celery",
    "cell",
    "cellar",
    "celtic",
    "cement",
    "censor",
    "census",
    "cent",
    "cereal",
    "chain",
    "chair",
    "chalk",
    "chalky",
    "champ",
    "chance",
    "change",
    "chant",
    "chaos",
    "chap",
    "chapel",
    "charge",
    "charm",
    "chart",
    "chase",
    "chat",
    "cheap",
    "cheat",
    "check",
    "cheek",
    "cheeky",
    "cheer",
    "cheery",
    "cheese",
    "chef",
    "cheque",
    "cherry",
    "chess",
    "chest",
    "chew",
    "chic",
    "chick",
    "chief",
    "child",
    "chile",
    "chill",
    "chilly",
    "chin",
    "china",
    "chip",
    "choice",
    "choir",
    "choose",
    "chop",
    "choppy",
    "chord",
    "chorus",
    "chose",
    "chosen",
    "chris",
    "chrome",
    "chunk",
    "chunky",
    "church",
    "cider",
    "cigar",
    "cinema",
    "circa",
    "circle",
    "circus",
    "cite",
    "city",
    "civic",
    "civil",
    "clad",
    "claim",
    "clammy",
    "clan",
    "clap",
    "clash",
    "clasp",
    "class",
    "clause",
    "claw",
    "clay",
    "clean",
    "clear",
    "clergy",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climax",
    "climb",
    "clinch",
    "cling",
    "clinic",
    "clip",
    "cloak",
    "clock",
    "clone",
    "close",
    "closer",
    "closet",
    "cloth",
    "cloud",
    "cloudy",
    "clout",
    "clown",
    "club",
    "clue",
    "clumsy",
    "clung",
    "clutch",
    "coach",
    "coal",
    "coarse",
    "coast",
    "coat",
    "coax",
    "cobalt",
    "cobra",
    "coca",
    "cock",
    "cocoa",
    "code",
    "coffee",
    "coffin",
    "cohort",
    "coil",
    "coin",
    "coke",
    "cold",
    "collar",
    "colon",
    "colony",
    "colt",
    "column",
    "comb",
    "combat",
    "come",
    "comedy",
    "comic",
    "commit",
    "common",
    "compel",
    "comply",
    "concur",
    "cone",
    "confer",
    "congo",
    "consul",
    "convex",
    "convey",
    "convoy",
    "cook",
    "cool",
    "cope",
    "copper",
    "copy",
    "coral",
    "cord",
    "core",
    "cork",
    "corn",
    "corner",
    "corps",
    "corpse",
    "corpus",
    "cortex",
    "cosmic",
    "cosmos",
    "cost",
    "costly",
    "cotton",
    "couch",
    "cough",
    "could",
    "count",
    "county",
    "coup",
    "couple",
    "coupon",
    "course",
    "court",
    "cousin",
    "cove",
    "cover",
    "covert",
    "cow",
    "coward",
    "cowboy",
    "cozy",
    "crab",
    "crack",
    "cradle",
    "craft",
    "crafty",
    "crag",
    "crane",
    "crash",
    "crate",
    "crater",
    "crawl",
    "crazy",
    "creak",
    "cream",
    "creamy",
    "create",
    "credit",
    "creed",
    "creek",
    "creep",
    "creepy",
    "crept",
    "crest",
    "crew",
    "cried",
    "crime",
    "crisis",
    "crisp",
    "critic",
    "crook",
    "crop",
    "cross",
    "crow",
    "crowd",
    "crown",
    "crude",
    "cruel",
    "cruise",
    "crunch",
    "crush",
    "crust",
    "crux",
    "cry",
    "crypt",
    "cuba",
    "cube",
    "cubic",
    "cuckoo",
    "cuff",
    "cult",
    "cup",
    "curb",
    "cure",
    "curfew",
    "curl",
    "curry",
    "curse",
    "cursor",
    "curve",
    "cuss",
    "custom",
    "cut",
    "cute",
    "cycle",
    "cyclic",
    "cynic",
    "czech",
    "dad",
    "daddy",
    "dagger",
    "daily",
    "dairy",
    "daisy",
    "dale",
    "dam",
    "damage",
    "damp",
    "dampen",
    "dance",
    "danger",
    "danish",
    "dare",
    "dark",
    "darken",
    "darn",
    "dart",
    "dash",
    "data",
    "date",
    "david",
    "dawn",
    "day",
    "dead",
    "deadly",
    "deaf",
    "deal",
    "dealer",
    "dean",
    "dear",
    "death",
    "debate",
    "debit",
    "debris",
    "debt",
    "debtor",
    "decade",
    "decay",
    "decent",
    "decide",
    "deck",
    "decor",
    "decree",
    "deduce",
    "deed",
    "deep",
    "deeply",
    "deer",
    "defeat",
    "defect",
    "defend",
    "defer",
    "define",
    "defy",
    "degree",
    "deity",
    "delay",
    "delete",
    "delhi",
    "delta",
    "demand",
    "demise",
    "demo",
    "demure",
    "denial",
    "denote",
    "dense",
    "dental",
    "deny",
    "depart",
    "depend",
    "depict",
    "deploy",
    "depot",
    "depth",
    "deputy",
    "derive",
    "desert",
    "design",
    "desire",
    "desist",
    "desk",
    "detail",
    "detect",
    "deter",
    "detest",
    "detour",
    "device",
    "devise",
    "devoid",
    "devote",
    "devour",
    "dial",
    "diana",
    "diary",
    "dice",
    "dictum",
    "did",
    "die",
    "diesel",
    "diet",
    "differ",
    "dig",
    "digest",
    "digit",
    "dine",
    "dinghy",
    "dinner",
    "diode",
    "dip",
    "dire",
    "direct",
    "dirt",
    "dirty",
    "disc",
    "disco",
    "dish",
    "disk",
    "dismal",
    "dispel",
    "ditch",
    "dive",
    "divert",
    "divide",
    "divine",
    "dizzy",
    "docile",
    "dock",
    "doctor",
    "dog",
    "dogma",
    "dole",
    "doll",
    "dollar",
    "dolly",
    "domain",
    "dome",
    "domino",
    "donate",
    "done",
    "donkey",
    "donor",
    "doom",
    "door",
    "dorsal",
    "dose",
    "dot",
    "double",
    "doubt",
    "dough",
    "dour",
    "dove",
    "down",
    "dozen",
    "draft",
    "drag",
    "dragon",
    "drain",
    "drama",
    "drank",
    "draw",
    "drawer",
    "dread",
    "dream",
    "dreary",
    "dress",
    "drew",
    "dried",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "driver",
    "drop",
    "drove",
    "drown",
    "drug",
    "drum",
    "drunk",
    "dry",
    "dual",
    "duck",
    "duct",
    "due",
    "duel",
    "duet",
    "duke",
    "dull",
    "duly",
    "dumb",
    "dummy",
    "dump",
    "dune",
    "dung",
    "duress",
    "during",
    "dusk",
    "dust",
    "dusty",
    "dutch",
    "duty",
    "dwarf",
    "dwell",
    "dyer",
    "dying",
    "dynamo",
    "each",
    "eager",
    "eagle",
    "ear",
    "earl",
    "early",
    "earn",
    "earth",
    "ease",
    "easel",
    "easily",
    "east",
    "easter",
    "easy",
    "eat",
    "eaten",
    "eater",
    "echo",
    "eddy",
    "eden",
    "edge",
    "edible",
    "edict",
    "edit",
    "editor",
    "eel",
    "eerie",
    "eerily",
    "effect",
    "effort",
    "egg",
    "ego",
    "eight",
    "eighth",
    "eighty",
    "either",
    "elbow",
    "elder",
    "eldest",
    "elect",
    "eleven",
    "elicit",
    "elite",
    "else",
    "elude",
    "elves",
    "embark",
    "emblem",
    "embryo",
    "emerge",
    "emit",
    "empire",
    "employ",
    "empty",
    "enable",
    "enamel",
    "end",
    "endure",
    "enemy",
    "energy",
    "engage",
    "engine",
    "enjoy",
    "enlist",
    "enough",
    "ensure",
    "entail",
    "enter",
    "entire",
    "entry",
    "envoy",
    "envy",
    "enzyme",
    "epic",
    "epoch",
    "equal",
    "equate",
    "equip",
    "equity",
    "era",
    "erect",
    "eric",
    "erode",
    "erotic",
    "errant",
    "error",
    "escape",
    "escort",
    "essay",
    "essex",
    "estate",
    "esteem",
    "ethic",
    "ethnic",
    "europe",
    "evade",
    "eve",
    "even",
    "event",
    "ever",
    "every",
    "evict",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "exam",
    "exceed",
    "excel",
    "except",
    "excess",
    "excise",
    "excite",
    "excuse",
    "exempt",
    "exert",
    "exile",
    "exist",
    "exit",
    "exodus",
    "exotic",
    "expand",
    "expect",
    "expert",
    "expire",
    "export",
    "expose",
    "extend",
    "extra",
    "eye",
    "eyed",
    "fabric",
    "face",
    "facial",
    "fact",
    "factor",
    "fade",
    "fail",
    "faint",
    "fair",
    "fairly",
    "fairy",
    "faith",
    "fake",
    "falcon",
    "fall",
    "false",
    "falter",
    "fame",
    "family",
    "famine",
    "famous",
    "fan",
    "fancy",
    "far",
    "farce",
    "fare",
    "farm",
    "farmer",
    "fast",
    "fasten",
    "faster",
    "fat",
    "fatal",
    "fate",
    "father",
    "fatty",
    "fault",
    "faulty",
    "fauna",
    "fear",
    "feast",
    "feat",
    "fed",
    "fee",
    "feeble",
    "feed",
    "feel",
    "feet",
    "fell",
    "fellow",
    "felt",
    "female",
    "fence",
    "fend",
    "ferry",
    "fetal",
    "fetch",
    "feudal",
    "fever",
    "few",
    "fewer",
    "fiasco",
    "fiddle",
    "field",
    "fiend",
    "fierce",
    "fiery",
    "fifth",
    "fifty",
    "fig",
    "fight",
    "figure",
    "file",
    "fill",
    "filled",
    "filler",
    "film",
    "filter",
    "filth",
    "filthy",
    "final",
    "finale",
    "find",
    "fine",
    "finery",
    "finger",
    "finish",
    "finite",
    "fire",
    "firm",
    "firmly",
    "first",
    "fiscal",
    "fish",
    "fisher",
    "fist",
    "fit",
    "fitful",
    "five",
    "fix",
    "flag",
    "flair",
    "flak",
    "flame",
    "flank",
    "flap",
    "flare",
    "flash",
    "flask",
    "flat",
    "flavor",
    "flaw",
    "fled",
    "flee",
    "fleece",
    "fleet",
    "flesh",
    "fleshy",
    "flew",
    "flick",
    "flight",
    "flimsy",
    "flint",
    "flirt",
    "float",
    "flock",
    "flood",
    "floor",
    "floppy",
    "flora",
    "floral",
    "flour",
    "flow",
    "flower",
    "fluent",
    "fluffy",
    "fluid",
    "flung",
    "flurry",
    "flush",
    "flute",
    "flux",
    "fly",
    "flyer",
    "foal",
    "foam",
    "focal",
    "focus",
    "fog",
    "foil",
    "fold",
    "folk",
    "follow",
    "folly",
    "fond",
    "fondly",
    "font",
    "food",
    "fool",
    "foot",
    "for",
    "forbid",
    "force",
    "ford",
    "forest",
    "forge",
    "forget",
    "fork",
    "form",
    "formal",
    "format",
    "former",
    "fort",
    "forth",
    "forty",
    "forum",
    "fossil",
    "foster",
    "foul",
    "found",
    "four",
    "fourth",
    "fox",
    "foyer",
    "frail",
    "frame",
    "franc",
    "france",
    "frank",
    "fraud",
    "fred",
    "free",
    "freed",
    "freely",
    "freeze",
    "french",
    "frenzy",
    "fresh",
    "friar",
    "friday",
    "fridge",
    "fried",
    "friend",
    "fright",
    "fringe",
    "frock",
    "frog",
    "from",
    "front",
    "frost",
    "frosty",
    "frown",
    "frozen",
    "frugal",
    "fruit",
    "fry",
    "fudge",
    "fuel",
    "full",
    "fully",
    "fumes",
    "fun",
    "fund",
    "funny",
    "fur",
    "furry",
    "fury",
    "fuse",
    "fusion",
    "fuss",
    "fussy",
    "futile",
    "future",
    "fuzzy",
    "gadget",
    "gain",
    "gala",
    "galaxy",
    "gale",
    "gall",
    "galley",
    "gallon",
    "gallop",
    "gamble",
    "game",
    "gamma",
    "gandhi",
    "gang",
    "gap",
    "garage",
    "garden",
    "garlic",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaunt",
    "gave",
    "gaze",
    "gear",
    "geese",
    "gem",
    "gemini",
    "gender",
    "gene",
    "geneva",
    "genial",
    "genius",
    "genre",
    "gentle",
    "gently",
    "gentry",
    "genus",
    "george",
    "germ",
    "get",
    "ghetto",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "gill",
    "gilt",
    "ginger",
    "girl",
    "give",
    "given",
    "glad",
    "glade",
    "glance",
    "gland",
    "glare",
    "glass",
    "glassy",
    "gleam",
    "glee",
    "glide",
    "global",
    "globe",
    "gloom",
    "gloomy",
    "gloria",
    "glory",
    "gloss",
    "glossy",
    "glove",
    "glow",
    "glue",
    "gnat",
    "gnu",
    "goal",
    "goat",
    "gold",
    "golden",
    "golf",
    "gone",
    "gong",
    "goo",
    "good",
    "goose",
    "gore",
    "gorge",
    "gory",
    "gosh",
    "gospel",
    "gossip",
    "got",
    "gothic",
    "govern",
    "gown",
    "grab",
    "grace",
    "grade",
    "grail",
    "grain",
    "grand",
    "grant",
    "grape",
    "graph",
    "grasp",
    "grass",
    "grassy",
    "grate",
    "grave",
    "gravel",
    "gravy",
    "grease",
    "greasy",
    "great",
    "greece",
    "greed",
    "greedy",
    "greek",
    "green",
    "greet",
    "grew",
    "grey",
    "grid",
    "grief",
    "grill",
    "grim",
    "grin",
    "grind",
    "grip",
    "grit",
    "gritty",
    "groan",
    "groin",
    "groom",
    "groove",
    "gross",
    "ground",
    "group",
    "grove",
    "grow",
    "grown",
    "growth",
    "grudge",
    "grunt",
    "guard",
    "guess",
    "guest",
    "guide",
    "guild",
    "guilt",
    "guilty",
    "guise",
    "guitar",
    "gulf",
    "gully",
    "gun",
    "gunman",
    "guru",
    "gut",
    "guy",
    "gypsy",
    "habit",
    "hack",
    "had",
    "hail",
    "hair",
    "hairy",
    "haiti",
    "hale",
    "half",
    "hall",
    "halt",
    "hamlet",
    "hammer",
    "hand",
    "handle",
    "handy",
    "hang",
    "hangar",
    "hanoi",
    "happen",
    "happy",
    "harass",
    "harbor",
    "hard",
    "harder",
    "hardly",
    "hare",
    "harem",
    "harm",
    "harp",
    "harry",
    "harsh",
    "has",
    "hash",
    "hassle",
    "haste",
    "hasten",
    "hasty",
    "hat",
    "hatch",
    "hate",
    "haul",
    "haunt",
    "havana",
    "have",
    "haven",
    "havoc",
    "hawaii",
    "hawk",
    "hay",
    "hazard",
    "haze",
    "hazel",
    "hazy",
    "head",
    "heal",
    "health",
    "heap",
    "hear",
    "heard",
    "heart",
    "hearth",
    "hearty",
    "heat",
    "heater",
    "heaven",
    "heavy",
    "hebrew",
    "heck",
    "hectic",
    "hedge",
    "heel",
    "hefty",
    "height",
    "heir",
    "held",
    "helium",
    "helix",
    "hell",
    "hello",
    "helm",
    "helmet",
    "help",
    "hemp",
    "hence",
    "henry",
    "her",
    "herald",
    "herb",
    "herd",
    "here",
    "hereby",
    "hermes",
    "hernia",
    "hero",
    "heroic",
    "heroin",
    "hey",
    "heyday",
    "hick",
    "hidden",
    "hide",
    "high",
    "higher",
    "highly",
    "hill",
    "him",
    "hind",
    "hinder",
    "hint",
    "hippie",
    "hire",
    "his",
    "hiss",
    "hit",
    "hive",
    "hoard",
    "hoarse",
    "hobby",
    "hockey",
    "hold",
    "holder",
    "hole",
    "hollow",
    "holly",
    "holy",
    "home",
    "honest",
    "honey",
    "hood",
    "hook",
    "hope",
    "horn",
    "horrid",
    "horror",
    "horse",
    "hose",
    "host",
    "hot",
    "hotel",
    "hound",
    "hour",
    "house",
    "hover",
    "how",
    "huge",
    "hull",
    "human",
    "humane",
    "humble",
    "humid",
    "hung",
    "hunger",
    "hungry",
    "hunt",
    "hurdle",
    "hurl",
    "hurry",
    "hurt",
    "hush",
    "hut",
    "hybrid",
    "hymn",
    "hyphen",
    "ice",
    "icing",
    "icon",
    "idaho",
    "idea",
    "ideal",
    "idiom",
    "idiot",
    "idle",
    "idly",
    "idol",
    "ignite",
    "ignore",
    "ill",
    "image",
    "immune",
    "impact",
    "imply",
    "import",
    "impose",
    "inca",
    "incest",
    "inch",
    "income",
    "incur",
    "indeed",
    "index",
    "india",
    "indian",
    "indoor",
    "induce",
    "inept",
    "inert",
    "infant",
    "infect",
    "infer",
    "influx",
    "inform",
    "inject",
    "injure",
    "injury",
    "ink",
    "inlaid",
    "inland",
    "inlet",
    "inmate",
    "inn",
    "innate",
    "inner",
    "input",
    "insane",
    "insect",
    "insert",
    "inset",
    "inside",
    "insist",
    "insult",
    "insure",
    "intact",
    "intake",
    "intend",
    "inter",
    "into",
    "invade",
    "invent",
    "invest",
    "invite",
    "invoke",
    "inward",
    "iowa",
    "iran",
    "iraq",
    "irish",
    "iron",
    "ironic",
    "irony",
    "isaac",
    "isabel",
    "island",
    "isle",
    "israel",
    "issue",
    "italy",
    "itch",
    "item",
    "itself",
    "ivan",
    "ivory",
    "jack",
    "jacket",
    "jacob",
    "jade",
    "jaguar",
    "jail",
    "james",
    "jane",
    "japan",
    "jargon",
    "java",
    "jaw",
    "jazz",
    "jeep",
    "jelly",
    "jerky",
    "jest",
    "jet",
    "jewel",
    "jewish",
    "jim",
    "job",
    "jock",
    "jockey",
    "joe",
    "john",
    "join",
    "joint",
    "joke",
    "jolly",
    "jolt",
    "jordan",
    "joseph",
    "joy",
    "joyful",
    "joyous",
    "judge",
    "judy",
    "juice",
    "juicy",
    "july",
    "jumble",
    "jumbo",
    "jump",
    "june",
    "jungle",
    "junior",
    "junk",
    "junta",
    "jury",
    "just",
    "kansas",
    "karate",
    "karl",
    "keel",
    "keen",
    "keep",
    "keeper",
    "kenya",
    "kept",
    "kernel",
    "kettle",
    "key",
    "khaki",
    "kick",
    "kid",
    "kidnap",
    "kidney",
    "kill",
    "killer",
    "kin",
    "kind",
    "kindly",
    "king",
    "kiss",
    "kite",
    "kitten",
    "knack",
    "knee",
    "kneel",
    "knew",
    "knife",
    "knight",
    "knit",
    "knob",
    "knock",
    "knot",
    "know",
    "known",
    "koran",
    "korea",
    "kuwait",
    "label",
    "lace",
    "lack",
    "lad",
    "ladder",
    "laden",
    "lady",
    "lagoon",
    "laity",
    "lake",
    "lamb",
    "lame",
    "lamp",
    "lance",
    "land",
    "lane",
    "lap",
    "lapse",
    "large",
    "larval",
    "laser",
    "last",
    "latch",
    "late",
    "lately",
    "latent",
    "later",
    "latest",
    "latin",
    "latter",
    "laugh",
    "launch",
    "lava",
    "lavish",
    "law",
    "lawful",
    "lawn",
    "lawyer",
    "lay",
    "layer",
    "layman",
    "lazy",
    "lead",
    "leader",
    "leaf",
    "leafy",
    "league",
    "leak",
    "leaky",
    "lean",
    "leap",
    "learn",
    "lease",
    "leash",
    "least",
    "leave",
    "led",
    "ledge",
    "left",
    "leg",
    "legacy",
    "legal",
    "legend",
    "legion",
    "lemon",
    "lend",
    "length",
    "lens",
    "lent",
    "leo",
    "leper",
    "lesion",
    "less",
    "lessen",
    "lesser",
    "lesson",
    "lest",
    "let",
    "lethal",
    "letter",
    "level",
    "lever",
    "levy",
    "lewis",
    "liable",
    "liar",
    "libel",
    "libya",
    "lice",
    "lick",
    "lid",
    "lie",
    "lied",
    "lier",
    "life",
    "lift",
    "light",
    "like",
    "likely",
    "limb",
    "lime",
    "limit",
    "limp",
    "line",
    "linear",
    "linen",
    "linger",
    "link",
    "lint",
    "lion",
    "lip",
    "liquid",
    "liquor",
    "list",
    "listen",
    "lit",
    "live",
    "lively",
    "liver",
    "liz",
    "lizard",
    "load",
    "loaf",
    "loan",
    "lobby",
    "lobe",
    "local",
    "locate",
    "lock",
    "locus",
    "lodge",
    "loft",
    "lofty",
    "log",
    "logic",
    "logo",
    "london",
    "lone",
    "lonely",
    "long",
    "longer",
    "look",
    "loop",
    "loose",
    "loosen",
    "loot",
    "lord",
    "lorry",
    "lose",
    "loss",
    "lost",
    "lot",
    "lotion",
    "lotus",
    "loud",
    "loudly",
    "lounge",
    "lousy",
    "love",
    "lovely",
    "lover",
    "low",
    "lower",
    "lowest",
    "loyal",
    "lucid",
    "luck",
    "lucky",
    "lucy",
    "lull",
    "lump",
    "lumpy",
    "lunacy",
    "lunar",
    "lunch",
    "lung",
    "lure",
    "lurid",
    "lush",
    "lust",
    "lute",
    "luther",
    "luxury",
    "lying",
    "lymph",
    "lynch",
    "lyric",
    "macho",
    "macro",
    "mad",
    "madam",
    "made",
    "mafia",
    "magic",
    "magma",
    "magnet",
    "magnum",
    "magpie",
    "maid",
    "maiden",
    "mail",
    "main",
    "mainly",
    "major",
    "make",
    "maker",
    "male",
    "malice",
    "mall",
    "malt",
    "mammal",
    "manage",
    "mane",
    "mania",
    "manic",
    "manner",
    "manor",
    "mantle",
    "manual",
    "manure",
    "many",
    "map",
    "maple",
    "marble",
    "march",
    "mare",
    "margin",
    "maria",
    "marina",
    "mark",
    "market",
    "marry",
    "mars",
    "marsh",
    "martin",
    "martyr",
    "mary",
    "mask",
    "mason",
    "mass",
    "mast",
    "master",
    "mat",
    "match",
    "mate",
    "matrix",
    "matter",
    "mature",
    "maxim",
    "may",
    "maybe",
    "mayor",
    "maze",
    "mead",
    "meadow",
    "meal",
    "mean",
    "meant",
    "meat",
    "medal",
    "media",
    "median",
    "medic",
    "medium",
    "meet",
    "mellow",
    "melody",
    "melon",
    "melt",
    "member",
    "memo",
    "memory",
    "menace",
    "mend",
    "mental",
    "mentor",
    "menu",
    "mercy",
    "mere",
    "merely",
    "merge",
    "merger",
    "merit",
    "merry",
    "mesh",
    "mess",
    "messy",
    "met",
    "metal",
    "meter",
    "method",
    "methyl",
    "metric",
    "metro",
    "mexico",
    "miami",
    "mickey",
    "mid",
    "midday",
    "middle",
    "midst",
    "midway",
    "might",
    "mighty",
    "mild",
    "mildew",
    "mile",
    "milk",
    "milky",
    "mill",
    "mimic",
    "mince",
    "mind",
    "mine",
    "mini",
    "mink",
    "minor",
    "mint",
    "minus",
    "minute",
    "mire",
    "mirror",
    "mirth",
    "misery",
    "miss",
    "mist",
    "misty",
    "mite",
    "mix",
    "moan",
    "moat",
    "mob",
    "mobile",
    "mock",
    "mode",
    "model",
    "modem",
    "modern",
    "modest",
    "modify",
    "module",
    "moist",
    "molar",
    "mold",
    "mole",
    "molten",
    "moment",
    "monday",
    "money",
    "monk",
    "monkey",
    "month",
    "mood",
    "moody",
    "moon",
    "moor",
    "moral",
    "morale",
    "morbid",
    "more",
    "morgue",
    "mortal",
    "mortar",
    "mosaic",
    "moscow",
    "moses",
    "mosque",
    "moss",
    "most",
    "mostly",
    "moth",
    "mother",
    "motion",
    "motive",
    "motor",
    "mount",
    "mourn",
    "mouse",
    "mouth",
    "move",
    "movie",
    "mrs",
    "much",
    "muck",
    "mucus",
    "mud",
    "muddle",
    "muddy",
    "mule",
    "mummy",
    "munich",
    "murder",
    "murky",
    "murmur",
    "muscle",
    "museum",
    "music",
    "mussel",
    "must",
    "mutant",
    "mute",
    "mutiny",
    "mutter",
    "mutton",
    "mutual",
    "muzzle",
    "myopic",
    "myriad",
    "myself",
    "mystic",
    "myth",
    "nadir",
    "nail",
    "naked",
    "name",
    "namely",
    "nape",
    "napkin",
    "naples",
    "narrow",
    "nasal",
    "nasty",
    "nathan",
    "nation",
    "native",
    "nature",
    "nausea",
    "naval",
    "nave",
    "navy",
    "near",
    "nearer",
    "nearly",
    "neat",
    "neatly",
    "neck",
    "need",
    "needle",
    "needy",
    "negate",
    "neon",
    "nepal",
    "nephew",
    "nerve",
    "nest",
    "net",
    "neural",
    "never",
    "newly",
    "next",
    "nice",
    "nicely",
    "niche",
    "nickel",
    "niece",
    "night",
    "nile",
    "nimble",
    "nine",
    "ninety",
    "ninth",
    "nobel",
    "noble",
    "nobody",
    "node",
    "noise",
    "noisy",
    "none",
    "noon",
    "nor",
    "norm",
    "normal",
    "north",
    "norway",
    "nose",
    "nosy",
    "not",
    "note",
    "notice",
    "notify",
    "notion",
    "noun",
    "novel",
    "novice",
    "now",
    "nozzle",
    "null",
    "numb",
    "number",
    "nurse",
    "nut",
    "nylon",
    "nymph",
    "oak",
    "oar",
    "oasis",
    "oath",
    "obese",
    "obey",
    "object",
    "oblige",
    "oboe",
    "obtain",
    "obtuse",
    "occult",
    "occupy",
    "occur",
    "ocean",
    "octave",
    "odd",
    "off",
    "offend",
    "offer",
    "office",
    "offset",
    "often",
    "ohio",
    "oil",
    "oily",
    "okay",
    "old",
    "older",
    "oldest",
    "olive",
    "omega",
    "omen",
    "omit",
    "once",
    "one",
    "onion",
    "only",
    "onset",
    "onto",
    "onus",
    "onward",
    "opaque",
    "open",
    "openly",
    "opera",
    "opium",
    "oppose",
    "optic",
    "option",
    "oracle",
    "oral",
    "orange",
    "orbit",
    "orchid",
    "ordeal",
    "order",
    "organ",
    "orgasm",
    "orient",
    "origin",
    "ornate",
    "orphan",
    "oscar",
    "other",
    "otter",
    "ought",
    "ounce",
    "our",
    "out",
    "outer",
    "output",
    "outset",
    "oval",
    "oven",
    "over",
    "overt",
    "owe",
    "owing",
    "owl",
    "own",
    "owner",
    "oxford",
    "oxide",
    "oxygen",
    "oyster",
    "ozone",
    "pace",
    "pack",
    "packet",
    "pact",
    "pad",
    "paddle",
    "paddy",
    "pagan",
    "page",
    "paid",
    "pain",
    "paint",
    "pair",
    "palace",
    "pale",
    "palm",
    "pan",
    "panama",
    "panel",
    "panic",
    "papa",
    "papal",
    "paper",
    "parade",
    "parcel",
    "pardon",
    "parent",
    "paris",
    "parish",
    "park",
    "parody",
    "parrot",
    "part",
    "partly",
    "party",
    "pascal",
    "pass",
    "past",
    "paste",
    "pastel",
    "pastor",
    "pastry",
    "pat",
    "patch",
    "patent",
    "path",
    "patio",
    "patrol",
    "patron",
    "paul",
    "pause",
    "pave",
    "paw",
    "pawn",
    "pay",
    "peace",
    "peach",
    "peak",
    "pear",
    "pearl",
    "pedal",
    "peel",
    "peer",
    "peking",
    "pelvic",
    "pelvis",
    "pen",
    "penal",
    "pence",
    "pencil",
    "penny",
    "people",
    "pepper",
    "per",
    "perch",
    "peril",
    "period",
    "perish",
    "permit",
    "person",
    "peru",
    "pest",
    "pet",
    "peter",
    "petite",
    "petrol",
    "petty",
    "phase",
    "philip",
    "phone",
    "photo",
    "phrase",
    "piano",
    "pick",
    "picket",
    "picnic",
    "pie",
    "piece",
    "pier",
    "pierce",
    "piety",
    "pig",
    "pigeon",
    "piggy",
    "pike",
    "pile",
    "pill",
    "pillar",
    "pillow",
    "pilot",
    "pin",
    "pinch",
    "pine",
    "pink",
    "pint",
    "pious",
    "pipe",
    "pirate",
    "piss",
    "pistol",
    "piston",
    "pit",
    "pitch",
    "pity",
    "pivot",
    "pixel",
    "pizza",
    "place",
    "placid",
    "plague",
    "plain",
    "plan",
    "plane",
    "planet",
    "plank",
    "plant",
    "plasma",
    "plate",
    "play",
    "player",
    "plea",
    "plead",
    "please",
    "pledge",
    "plenty",
    "plight",
    "plot",
    "plough",
    "ploy",
    "plug",
    "plum",
    "plump",
    "plunge",
    "plural",
    "plus",
    "plush",
    "pocket",
    "poem",
    "poet",
    "poetic",
    "poetry",
    "point",
    "poison",
    "poland",
    "polar",
    "pole",
    "police",
    "policy",
    "polish",
    "polite",
    "poll",
    "pollen",
    "polo",
    "pond",
    "ponder",
    "pony",
    "pool",
    "poor",
    "poorly",
    "pop",
    "poppy",
    "pore",
    "pork",
    "port",
    "portal",
    "pose",
    "posh",
    "post",
    "postal",
    "pot",
    "potato",
    "potent",
    "pouch",
    "pound",
    "pour",
    "powder",
    "power",
    "praise",
    "pray",
    "prayer",
    "preach",
    "prefer",
    "prefix",
    "press",
    "pretty",
    "price",
    "pride",
    "priest",
    "primal",
    "prime",
    "prince",
    "print",
    "prior",
    "prism",
    "prison",
    "privy",
    "prize",
    "probe",
    "profit",
    "prompt",
    "prone",
    "proof",
    "propel",
    "proper",
    "prose",
    "proton",
    "proud",
    "prove",
    "proven",
    "proxy",
    "prune",
    "pry",
    "psalm",
    "pseudo",
    "psyche",
    "pub",
    "public",
    "puff",
    "pull",
    "pulp",
    "pulpit",
    "pulsar",
    "pulse",
    "pump",
    "punch",
    "punish",
    "punk",
    "pupil",
    "puppet",
    "puppy",
    "pure",
    "purely",
    "purge",
    "purify",
    "purple",
    "purse",
    "pursue",
    "push",
    "pushy",
    "put",
    "putt",
    "puzzle",
    "quaint",
    "quake",
    "quarry",
    "quart",
    "quartz",
    "quebec",
    "queen",
    "queer",
    "query",
    "quest",
    "queue",
    "quick",
    "quid",
    "quiet",
    "quilt",
    "quirk",
    "quit",
    "quite",
    "quiver",
    "quiz",
    "quota",
    "quote",
    "rabbit",
    "race",
    "racial",
    "racism",
    "rack",
    "racket",
    "radar",
    "radio",
    "radish",
    "radius",
    "raffle",
    "raft",
    "rage",
    "raid",
    "rail",
    "rain",
    "rainy",
    "raise",
    "rake",
    "rally",
    "ramp",
    "random",
    "range",
    "rank",
    "ransom",
    "rape",
    "rapid",
    "rare",
    "rarely",
    "rarity",
    "rash",
    "rat",
    "rate",
    "rather",
    "ratify",
    "ratio",
    "rattle",
    "rave",
    "raven",
    "raw",
    "ray",
    "razor",
    "reach",
    "react",
    "read",
    "reader",
    "ready",
    "real",
    "really",
    "realm",
    "reap",
    "rear",
    "reason",
    "rebel",
    "recall",
    "recent",
    "recess",
    "recipe",
    "reckon",
    "record",
    "recoup",
    "rector",
    "red",
    "redeem",
    "redo",
    "reduce",
    "reed",
    "reef",
    "reek",
    "refer",
    "reform",
    "refuge",
    "refuse",
    "regal",
    "regard",
    "regent",
    "regime",
    "region",
    "regret",
    "reign",
    "reject",
    "relate",
    "relax",
    "relay",
    "relic",
    "relief",
    "relish",
    "rely",
    "remain",
    "remark",
    "remedy",
    "remind",
    "remit",
    "remote",
    "remove",
    "renal",
    "render",
    "rent",
    "rental",
    "repair",
    "repeal",
    "repeat",
    "repent",
    "reply",
    "report",
    "rescue",
    "resent",
    "reside",
    "resign",
    "resin",
    "resist",
    "resort",
    "rest",
    "result",
    "resume",
    "retail",
    "retain",
    "retina",
    "retire",
    "return",
    "reveal",
    "review",
    "revise",
    "revive",
    "revolt",
    "reward",
    "rex",
    "rhine",
    "rhino",
    "rhyme",
    "rhythm",
    "ribbon",
    "rice",
    "rich",
    "rick",
    "rid",
    "ride",
    "rider",
    "ridge",
    "rife",
    "rifle",
    "rift",
    "right",
    "rigid",
    "rile",
    "rim",
    "ring",
    "rinse",
    "riot",
    "ripe",
    "ripen",
    "ripple",
    "rise",
    "risk",
    "risky",
    "rite",
    "ritual",
    "ritz",
    "rival",
    "river",
    "road",
    "roar",
    "roast",
    "rob",
    "robe",
    "robert",
    "robin",
    "robot",
    "robust",
    "rock",
    "rocket",
    "rocky",
    "rod",
    "rode",
    "rodent",
    "rogue",
    "role",
    "roll",
    "roman",
    "rome",
    "roof",
    "room",
    "root",
    "rope",
    "rose",
    "rosy",
    "rot",
    "rotate",
    "rotor",
    "rotten",
    "rouge",
    "rough",
    "round",
    "route",
    "rover",
    "row",
    "royal",
    "rub",
    "rubber",
    "rubble",
    "ruby",
    "rudder",
    "rude",
    "rug",
    "rugby",
    "ruin",
    "rule",
    "ruler",
    "rumble",
    "rump",
    "run",
    "rune",
    "rung",
    "runway",
    "rural",
    "rush",
    "russia",
    "rust",
    "rustic",
    "rusty",
    "sack",
    "sacred",
    "sad",
    "saddle",
    "sadism",
    "sadly",
    "safari",
    "safe",
    "safely",
    "safer",
    "safety",
    "saga",
    "sage",
    "sahara",
    "said",
    "sail",
    "sailor",
    "saint",
    "sake",
    "salad",
    "salary",
    "sale",
    "saline",
    "saliva",
    "salmon",
    "saloon",
    "salt",
    "salty",
    "salute",
    "sam",
    "same",
    "sample",
    "sand",
    "sandy",
    "sane",
    "sash",
    "satin",
    "satire",
    "saturn",
    "sauce",
    "saucer",
    "saudi",
    "sauna",
    "savage",
    "save",
    "saw",
    "say",
    "scale",
    "scalp",
    "scan",
    "scant",
    "scar",
    "scarce",
    "scare",
    "scarf",
    "scary",
    "scene",
    "scenic",
    "scent",
    "school",
    "scold",
    "scope",
    "score",
    "scorn",
    "scotch",
    "scott",
    "scout",
    "scrap",
    "scrape",
    "scream",
    "screen",
    "screw",
    "script",
    "scroll",
    "scrub",
    "scum",
    "sea",
    "seal",
    "seam",
    "seaman",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "sect",
    "sector",
    "secure",
    "see",
    "seed",
    "seeing",
    "seek",
    "seem",
    "seize",
    "seldom",
    "select",
    "self",
    "sell",
    "seller",
    "semi",
    "senate",
    "send",
    "senile",
    "senior",
    "sense",
    "sensor",
    "sent",
    "sentry",
    "seoul",
    "sequel",
    "serene",
    "serial",
    "series",
    "sermon",
    "serum",
    "serve",
    "server",
    "set",
    "settle",
    "seven",
    "severe",
    "sew",
    "sewage",
    "shabby",
    "shade",
    "shadow",
    "shady",
    "shaft",
    "shaggy",
    "shah",
    "shake",
    "shaky",
    "shall",
    "sham",
    "shame",
    "shape",
    "share",
    "shark",
    "sharp",
    "shawl",
    "she",
    "shear",
    "sheen",
    "sheep",
    "sheer",
    "sheet",
    "shelf",
    "shell",
    "sherry",
    "shield",
    "shift",
    "shine",
    "shiny",
    "ship",
    "shire",
    "shirk",
    "shirt",
    "shiver",
    "shock",
    "shoe",
    "shook",
    "shoot",
    "shop",
    "shore",
    "short",
    "shot",
    "should",
    "shout",
    "show",
    "shower",
    "shrank",
    "shrewd",
    "shrill",
    "shrimp",
    "shrine",
    "shrink",
    "shrub",
    "shrug",
    "shut",
    "shy",
    "shyly",
    "sick",
    "side",
    "siege",
    "sigh",
    "sight",
    "sigma",
    "sign",
    "signal",
    "silent",
    "silk",
    "silken",
    "silky",
    "sill",
    "silly",
    "silo",
    "silver",
    "simple",
    "simply",
    "since",
    "sinful",
    "sing",
    "singer",
    "single",
    "sink",
    "sir",
    "sire",
    "siren",
    "sister",
    "sit",
    "site",
    "sitter",
    "six",
    "sixth",
    "sixty",
    "size",
    "sketch",
    "skill",
    "skin",
    "skinny",
    "skip",
    "skirt",
    "skull",
    "sky",
    "slab",
    "slack",
    "slain",
    "slam",
    "slang",
    "slap",
    "slat",
    "slate",
    "slave",
    "sleek",
    "sleep",
    "sleepy",
    "sleeve",
    "slice",
    "slick",
    "slid",
    "slide",
    "slight",
    "slim",
    "slimy",
    "sling",
    "slip",
    "slit",
    "slogan",
    "slope",
    "sloppy",
    "slot",
    "slow",
    "slowly",
    "slug",
    "slum",
    "slump",
    "smack",
    "small",
    "smart",
    "smash",
    "smear",
    "smell",
    "smelly",
    "smelt",
    "smile",
    "smite",
    "smoke",
    "smoky",
    "smooth",
    "smug",
    "snack",
    "snail",
    "snake",
    "snap",
    "snatch",
    "sneak",
    "snow",
    "snowy",
    "snug",
    "soak",
    "soap",
    "sober",
    "soccer",
    "social",
    "sock",
    "socket",
    "socks",
    "soda",
    "sodden",
    "sodium",
    "sofa",
    "soft",
    "soften",
    "softly",
    "soggy",
    "soil",
    "solar",
    "sold",
    "sole",
    "solely",
    "solemn",
    "solid",
    "solo",
    "solve",
    "some",
    "son",
    "sonar",
    "sonata",
    "song",
    "sonic",
    "sony",
    "soon",
    "sooner",
    "soot",
    "soothe",
    "sordid",
    "sore",
    "sorrow",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "sour",
    "source",
    "soviet",
    "sow",
    "space",
    "spade",
    "spain",
    "span",
    "spare",
    "spark",
    "sparse",
    "spasm",
    "spat",
    "spate",
    "speak",
    "spear",
    "speech",
    "speed",
    "speedy",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spicy",
    "spider",
    "spiky",
    "spill",
    "spin",
    "spinal",
    "spine",
    "spiral",
    "spirit",
    "spit",
    "spite",
    "splash",
    "split",
    "spoil",
    "spoke",
    "sponge",
    "spoon",
    "sport",
    "spot",
    "spouse",
    "spray",
    "spread",
    "spree",
    "spring",
    "sprint",
    "spur",
    "squad",
    "square",
    "squash",
    "squat",
    "squid",
    "stab",
    "stable",
    "stack",
    "staff",
    "stage",
    "stain",
    "stair",
    "stairs",
    "stake",
    "stale",
    "stall",
    "stamp",
    "stance",
    "stand",
    "staple",
    "star",
    "starch",
    "stare",
    "stark",
    "start",
    "starve",
    "state",
    "static",
    "statue",
    "status",
    "stay",
    "stead",
    "steady",
    "steak",
    "steal",
    "steam",
    "steel",
    "steep",
    "steer",
    "stem",
    "stench",
    "step",
    "stereo",
    "stern",
    "stew",
    "stick",
    "sticky",
    "stiff",
    "stifle",
    "stigma",
    "still",
    "sting",
    "stint",
    "stir",
    "stitch",
    "stock",
    "stocky",
    "stone",
    "stony",
    "stool",
    "stop",
    "store",
    "storm",
    "stormy",
    "story",
    "stout",
    "stove",
    "stow",
    "strain",
    "strait",
    "strand",
    "strap",
    "strata",
    "straw",
    "stray",
    "streak",
    "stream",
    "street",
    "stress",
    "strict",
    "stride",
    "strife",
    "strike",
    "string",
    "strip",
    "stripe",
    "strive",
    "stroke",
    "stroll",
    "strong",
    "stud",
    "studio",
    "study",
    "stuff",
    "stuffy",
    "stunt",
    "stupid",
    "sturdy",
    "style",
    "submit",
    "subtle",
    "subtly",
    "suburb",
    "such",
    "sudden",
    "sue",
    "suez",
    "suffer",
    "sugar",
    "suit",
    "suite",
    "suitor",
    "sullen",
    "sultan",
    "sum",
    "summer",
    "summit",
    "summon",
    "sun",
    "sunday",
    "sunny",
    "sunset",
    "super",
    "superb",
    "supper",
    "supple",
    "supply",
    "sure",
    "surely",
    "surf",
    "surge",
    "survey",
    "suture",
    "swamp",
    "swan",
    "swap",
    "swarm",
    "sway",
    "swear",
    "sweat",
    "sweaty",
    "sweden",
    "sweep",
    "sweet",
    "swell",
    "swift",
    "swim",
    "swine",
    "swing",
    "swirl",
    "swiss",
    "switch",
    "sword",
    "swore",
    "sydney",
    "symbol",
    "synod",
    "syntax",
    "syria",
    "syrup",
    "system",
    "table",
    "tablet",
    "taboo",
    "tacit",
    "tackle",
    "tact",
    "tactic",
    "tail",
    "tailor",
    "taiwan",
    "take",
    "tale",
    "talent",
    "talk",
    "tall",
    "tally",
    "tame",
    "tampa",
    "tan",
    "tandem",
    "tangle",
    "tank",
    "tap",
    "tape",
    "target",
    "tariff",
    "tarp",
    "tart",
    "tarzan",
    "task",
    "taste",
    "tasty",
    "tattoo",
    "taurus",
    "taut",
    "tavern",
    "tax",
    "taxi",
    "tea",
    "teach",
    "teak",
    "team",
    "tear",
    "tease",
    "tech",
    "teeth",
    "tell",
    "temper",
    "temple",
    "tempo",
    "tempt",
    "ten",
    "tenant",
    "tend",
    "tender",
    "tendon",
    "tennis",
    "tenor",
    "tense",
    "tent",
    "tenth",
    "tenure",
    "teresa",
    "term",
    "terror",
    "terse",
    "test",
    "texas",
    "text",
    "thank",
    "thaw",
    "them",
    "theme",
    "thence",
    "theory",
    "there",
    "these",
    "thesis",
    "they",
    "thick",
    "thief",
    "thigh",
    "thin",
    "thing",
    "think",
    "third",
    "thirst",
    "thirty",
    "this",
    "thomas",
    "thorn",
    "those",
    "though",
    "thread",
    "threat",
    "three",
    "thrill",
    "thrive",
    "throat",
    "throne",
    "throng",
    "throw",
    "thrust",
    "thud",
    "thug",
    "thumb",
    "thus",
    "thyme",
    "tibet",
    "tick",
    "ticket",
    "tidal",
    "tide",
    "tidy",
    "tie",
    "tier",
    "tiger",
    "tight",
    "tile",
    "till",
    "tilt",
    "timber",
    "time",
    "timid",
    "tin",
    "tiny",
    "tip",
    "tire",
    "tissue",
    "title",
    "toad",
    "toast",
    "today",
    "toe",
    "toilet",
    "token",
    "tokyo",
    "told",
    "toll",
    "tom",
    "tomato",
    "tomb",
    "tonal",
    "tone",
    "tongue",
    "tonic",
    "too",
    "took",
    "tool",
    "tooth",
    "top",
    "topaz",
    "topic",
    "torch",
    "torque",
    "torso",
    "tort",
    "toss",
    "total",
    "touch",
    "tough",
    "tour",
    "toward",
    "towel",
    "tower",
    "town",
    "toxic",
    "toxin",
    "toy",
    "trace",
    "track",
    "tract",
    "trade",
    "tragic",
    "trail",
    "train",
    "trait",
    "tram",
    "trance",
    "trap",
    "trauma",
    "travel",
    "tray",
    "tread",
    "treat",
    "treaty",
    "treble",
    "tree",
    "trek",
    "tremor",
    "trench",
    "trend",
    "trendy",
    "trial",
    "tribal",
    "tribe",
    "trick",
    "tricky",
    "tried",
    "trifle",
    "trim",
    "trio",
    "trip",
    "triple",
    "troop",
    "trophy",
    "trot",
    "trough",
    "trout",
    "truce",
    "truck",
    "true",
    "truly",
    "trunk",
    "trust",
    "truth",
    "try",
    "tube",
    "tumble",
    "tuna",
    "tundra",
    "tune",
    "tunic",
    "tunnel",
    "turban",
    "turf",
    "turk",
    "turkey",
    "turn",
    "turtle",
    "tutor",
    "tweed",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "tycoon",
    "tying",
    "type",
    "tyrant",
    "ugly",
    "ulcer",
    "ultra",
    "umpire",
    "unable",
    "uncle",
    "under",
    "uneasy",
    "unfair",
    "unify",
    "union",
    "unique",
    "unit",
    "unite",
    "unity",
    "unlike",
    "unrest",
    "unruly",
    "until",
    "update",
    "upheld",
    "uphill",
    "uphold",
    "upon",
    "upper",
    "uproar",
    "upset",
    "upshot",
    "uptake",
    "upturn",
    "upward",
    "urban",
    "urge",
    "urgent",
    "urging",
    "urine",
    "usable",
    "usage",
    "use",
    "useful",
    "user",
    "usual",
    "utmost",
    "utter",
    "vacant",
    "vacuum",
    "vague",
    "vain",
    "valet",
    "valid",
    "valley",
    "value",
    "valve",
    "van",
    "vanish",
    "vanity",
    "vary",
    "vase",
    "vast",
    "vat",
    "vault",
    "vector",
    "veil",
    "vein",
    "velvet",
    "vendor",
    "veneer",
    "venice",
    "venom",
    "vent",
    "venue",
    "venus",
    "verb",
    "verbal",
    "verge",
    "verify",
    "verity",
    "verse",
    "versus",
    "very",
    "vessel",
    "vest",
    "vet",
    "veto",
    "via",
    "viable",
    "vicar",
    "vice",
    "victim",
    "victor",
    "video",
    "vienna",
    "view",
    "vigil",
    "viking",
    "vile",
    "villa",
    "vine",
    "vinyl",
    "viola",
    "violet",
    "violin",
    "viral",
    "virgo",
    "virtue",
    "virus",
    "visa",
    "vision",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "vodka",
    "vogue",
    "voice",
    "void",
    "volley",
    "volume",
    "vote",
    "vowel",
    "voyage",
    "vulgar",
    "wade",
    "wage",
    "waist",
    "wait",
    "waiter",
    "wake",
    "walk",
    "walker",
    "wall",
    "wallet",
    "walnut",
    "wander",
    "want",
    "war",
    "warden",
    "warm",
    "warmth",
    "warn",
    "warp",
    "warsaw",
    "wary",
    "was",
    "wash",
    "wasp",
    "waste",
    "watch",
    "water",
    "watery",
    "wave",
    "wax",
    "way",
    "weak",
    "weaken",
    "wealth",
    "weapon",
    "wear",
    "weary",
    "weave",
    "wedge",
    "wee",
    "weed",
    "week",
    "weekly",
    "weep",
    "weigh",
    "weight",
    "weird",
    "well",
    "were",
    "west",
    "wet",
    "whale",
    "wharf",
    "what",
    "wheat",
    "wheel",
    "when",
    "whence",
    "where",
    "which",
    "whiff",
    "while",
    "whim",
    "whip",
    "whisky",
    "white",
    "who",
    "whole",
    "wholly",
    "whom",
    "whose",
    "why",
    "wicked",
    "wide",
    "widely",
    "widen",
    "wider",
    "widow",
    "width",
    "wife",
    "wig",
    "wild",
    "wildly",
    "will",
    "willow",
    "wily",
    "win",
    "wind",
    "window",
    "windy",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wipe",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "wit",
    "witch",
    "with",
    "within",
    "witty",
    "wizard",
    "woke",
    "wolf",
    "wolves",
    "woman",
    "womb",
    "won",
    "wonder",
    "wood",
    "wooden",
    "woods",
    "woody",
    "wool",
    "word",
    "work",
    "worker",
    "world",
    "worm",
    "worry",
    "worse",
    "worst",
    "worth",
    "worthy",
    "would",
    "wound",
    "wrap",
    "wrath",
    "wreath",
    "wreck",
    "wring",
    "wrist",
    "writ",
    "write",
    "writer",
    "wrong",
    "xerox",
    "yacht",
    "yale",
    "yard",
    "yarn",
    "yeah",
    "year",
    "yeard",
    "yeast",
    "yellow",
    "yet",
    "yield",
    "yogurt",
    "yolk",
    "you",
    "young",
    "your",
    "youth",
    "zaire",
    "zeal",
    "zebra",
    "zenith",
    "zero",
    "zeus",
    "zigzag",
    "zinc",
    "zombie",
    "zone",
];
// Filename: packages/cryptography/test/browser.test.js
import { test, expect } from "@playwright/test";

test("can execute @hashgraph/cryptography within browser", async function ({
    page,
}) {
    page.on("pageerror", async (message) => {
        throw new Error(message);
    });

    await page.goto("http://localhost:9001/");

    await new Promise((resolve) => setTimeout(resolve, 3000));
    const tests = await page.evaluate(() => {
        return Array.from(document.querySelectorAll(".test")).map((test) => {
            const error = test.querySelector(".error");
            return {
                name: [].reduce.call(
                    test.querySelector("h2").childNodes,
                    function (a, b) {
                        return a + (b.nodeType === 3 ? b.textContent : "");
                    },
                    ""
                ),
                error: error != null ? error.innerText.trim() : null,
            };
        });
    });

    expect(tests.length).toBeGreaterThan(0);
    for (const t of tests) {
        expect(t.error).toBeNull();
    }
});
// Filename: packages/cryptography/test/unit/EcdsaPrivateKey.js
import EcdsaPrivateKey from "../../src/EcdsaPrivateKey.js";
import * as hex from "../../src/encoding/hex.js";
import * as utf8 from "../../src/encoding/utf8.js";

const RAW_KEY =
    "8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048";

describe("EcdsaPrivateKey", function () {
    it("generate should return Ecdsa object", function () {
        EcdsaPrivateKey.generate();
    });

    it("generateAsync should return Ecdsa object", async function () {
        await EcdsaPrivateKey.generateAsync();
    });

    it("toBytesDer and toBytesRaw work", function () {
        EcdsaPrivateKey.generate();
    });

    it("fromStringRaw and fromStringDer work", function () {
        EcdsaPrivateKey.fromStringDer(
            hex.encode(EcdsaPrivateKey.fromStringRaw(RAW_KEY).toBytesDer()),
        );
    });

    it("can sign and verify", function () {
        const key = EcdsaPrivateKey.fromStringRaw(RAW_KEY);
        const message = utf8.encode("hello world");
        const signature = key.sign(message);

        expect(signature.length).to.be.equal(64);
        expect(hex.encode(signature)).to.be.equal(
            "f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414cf791c8e859afd3c12009ecf2cb20dacf01636d80823bcdbd9ec1ce59afe008f0",
        );
        expect(key.publicKey.verify(message, signature)).to.be.true;
        expect(key.publicKey.toBytesRaw().length).to.be.equal(33);
    });

    it("can sign and verify body bytes", function () {
        const key = EcdsaPrivateKey.fromStringRaw(RAW_KEY);
        const message = hex.decode(
            "0a0e0a0408011001120608001000180412060800100018031880c2d72f220208783200721a0a180a0a0a0608001000180410130a0a0a060800100018051014",
        );
        const signature = key.sign(message);

        expect(signature.length).to.be.equal(64);
        expect(hex.encode(signature)).to.be.equal(
            "63201532040178a60e2738bdaaa00d628004b15d109162fa42e066fcb6720190bc7b8c440eaa028009404d56bebeea7f9c94d4dc07042c63cb0bcf0cab0ee737",
        );
        expect(key.publicKey.verify(message, signature)).to.be.true;
        expect(key.publicKey.toBytesRaw().length).to.be.equal(33);
    });
});
// Filename: packages/cryptography/test/unit/KeyList.js
import PublicKey from "../../src/PublicKey.js";
import KeyList from "../../src/KeyList.js";

describe("KeyList", function () {
    it("KeyList.toString()", async function () {
        const key1 = PublicKey.fromString(
            "302a300506032b65700321008f41f9476ded1bfb887ef49b40b2a33c97c9a90324e79ce53465e15968bb4503",
        );
        const key2 = PublicKey.fromString(
            "302a300506032b6570032100bbb3991523f8145f1cf4b90c7b57bfa60f42d07547aaf979fddd69388d210f6c",
        );
        const key3 = PublicKey.fromString(
            "302a300506032b6570032100f169271fe46f43ba29a786c170359e71c69eb34354e90d0b8c1e2b4b317cc650",
        );

        const keys = KeyList.of(key1, key2, key3);

        const string =
            '{"threshold":null,"keys":"302a300506032b65700321008f41f9476ded1bfb887ef49b40b2a33c97c9a90324e79ce53465e15968bb4503,302a300506032b6570032100bbb3991523f8145f1cf4b90c7b57bfa60f42d07547aaf979fddd69388d210f6c,302a300506032b6570032100f169271fe46f43ba29a786c170359e71c69eb34354e90d0b8c1e2b4b317cc650"}';

        expect(keys.toString()).to.be.equal(string);
    });
});
// Filename: packages/cryptography/test/unit/Mnemonic.js
import Mnemonic from "../../src/Mnemonic.js";
import PrivateKey from "../../src/PrivateKey.js";
import BadMnemonicError from "../../src/BadMnemonicError.js";
import BadMnemonicReason from "../../src/BadMnemonicReason.js";

describe("Mnemonic", function () {
    it("should generate 24 words", async function () {
        const m = await Mnemonic.generate();

        expect(m.words).to.have.length(24);

        // noinspection JSAccessibilityCheck
        await m._validate();
    });

    it("should generate 12 words", async function () {
        const m = await Mnemonic.generate12();

        expect(m.words).to.have.length(12);

        // noinspection JSAccessibilityCheck
        await m._validate();
    });

    it("12 words from string", async function () {
        const m = await Mnemonic.fromString(
            "spy,base,tired,useless,rug,riot,ticket,enroll,disorder,kiwi,client,impulse",
        );

        expect(m.words).to.have.length(12);

        // noinspection JSAccessibilityCheck
        await m._validate();
    });

    it("should detect an invalid checksum", async function () {
        const m = await Mnemonic.generate();

        // swap words so the checksum will be invalid
        m.words[m.words.length - 1] = m.words[0];

        await Mnemonic.fromWords(m.words).catch((err) => {
            expect(err).to.be.instanceOf(BadMnemonicError);
            expect(err.reason).to.eql(BadMnemonicReason.ChecksumMismatch);
        });
    });

    it("should produce the expected private key", async function () {
        // generated by [hiero-keygen-java], not used anywhere
        const mnemonic = await Mnemonic.fromString(
            "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home",
        );

        const expectedKey =
            "302e020100300506032b657004220420853f15aecd22706b105da1d709b4ac05b4906170c2b9c7495dff9af49e1391da";

        const key = await mnemonic.toEd25519PrivateKey();

        expect(key.toString()).to.eql(expectedKey);
    });

    it("should produce the expected private key with ecdsa", async function () {
        const mnemonic = await Mnemonic.fromString(
            "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat",
        );

        // test vector from https://gist.github.com/poma/6b503eead48628a03088fd270a68e369
        const path = [44 | 0x80000000, 60 | 0x80000000, 0 | 0x80000000, 0];

        const rootKey = await mnemonic.toEcdsaPrivateKey("", path);

        expect(rootKey.toStringRaw()).to.eql(
            "c4d1decb7eb3679f1adafa9795ee019f2480626554b80f058f063dfb84acb227",
        );
        const childKeys = [
            "c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3",
            "ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f",
            "0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1",
            "c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c",
            "388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418",
            "659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63",
            "82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8",
            "aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7",
            "0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4",
            "8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5",
        ];

        for (const i in childKeys) {
            expect((await rootKey.derive(i)).toStringRaw()).to.eql(
                childKeys[i],
            );
        }
    });

    it("should produce the expected legacy private key", async function () {
        // root key generated by the iOS wallet, not used anywhere
        const legacyMnemonic = await Mnemonic.fromString(
            "jolly,kidnap,Tom,lawn,drunk,chick,optic,lust,mutter,mole,bride,galley,dense,member,sage,neural,widow,decide,curb,aboard,margin,manure",
        );

        expect(legacyMnemonic.words).to.have.length(22);

        const expectedLegacyKey =
            "302e020100300506032b657004220420882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf";

        expect(
            (
                await (
                    await legacyMnemonic.toLegacyPrivateKey()
                ).legacyDerive(-1)
            ).toString(),
        ).to.eql(expectedLegacyKey);
    });

    it("legacy2 mnemonic should work", async function () {
        const legacyMnemonic = await Mnemonic.fromString(
            "obvious,favorite,remain,caution,remove,laptop,base,vacant,increase,video,erase,pass,sniff,sausage,knock,grid,argue,salt,romance,way,alone,fever,slush,dune",
        );
        const legacyPrivateKey = await (
            await legacyMnemonic.toLegacyPrivateKey()
        ).legacyDerive(0);

        const expectedLegacyKey =
            "302e020100300506032b6570042204202b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb";

        expect(legacyPrivateKey.toString()).to.eql(expectedLegacyKey);
    });

    it("should match MyHbarWallet v1", async function () {
        let mnemonic;

        try {
            mnemonic = await Mnemonic.fromString(
                "jolly kidnap Tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure",
            );
        } catch (err) {
            if (err instanceof BadMnemonicError) {
                mnemonic = err.mnemonic;
            } else {
                throw err;
            }
        }

        const rootPrivateKey = await mnemonic.toLegacyPrivateKey();
        const privateKeyMhw = await rootPrivateKey.legacyDerive(1099511627775);

        expect(privateKeyMhw.publicKey.toString()).to.eql(
            "302a300506032b657003210045f3a673984a0b4ee404a1f4404ed058475ecd177729daa042e437702f7791e9",
        );
    });

    it("should match hiero-keygen-java for a 22-word legacy phrase", async function () {
        const mnemonic = await Mnemonic.fromString(
            "jolly,kidnap,tom,lawn,drunk,chick,optic,lust,mutter,mole,bride,galley,dense,member,sage,neural,widow,decide,curb,aboard,margin,manure",
        );

        const rootPrivateKey = await mnemonic.toLegacyPrivateKey();

        const privateKey0 = await rootPrivateKey.legacyDerive(0);
        const privateKeyNeg1 = await rootPrivateKey.legacyDerive(-1);

        expect(privateKey0.toString()).to.eql(
            "302e020100300506032b657004220420fae0002d2716ea3a60c9cd05ee3c4bb88723b196341b68a02d20975f9d049dc6",
        );
        expect(privateKeyNeg1.toString()).to.eql(
            "302e020100300506032b657004220420882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf",
        );
    });

    it("should match hiero-keygen-java for a 24-word legacy phrase", async function () {
        const mnemonic = await Mnemonic.fromString(
            "obvious,favorite,remain,caution,remove,laptop,base,vacant,increase,video,erase,pass,sniff,sausage,knock,grid,argue,salt,romance,way,alone,fever,slush,dune",
        );

        const rootPrivateKey = await mnemonic.toLegacyPrivateKey();

        const privateKey0 = await rootPrivateKey.legacyDerive(0);
        const privateKeyNeg1 = await rootPrivateKey.legacyDerive(-1);

        expect(privateKey0.toString()).to.eql(
            "302e020100300506032b6570042204202b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb",
        );
        expect(privateKeyNeg1.toString()).to.eql(
            "302e020100300506032b657004220420caffc03fdb9853e6a91a5b3c57a5c0031d164ce1c464dea88f3114786b5199e5",
        );
    });

    it("default derivation path should match correct derivation path", async function () {
        const mnemonic = await Mnemonic.fromString(
            "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat",
        );

        /* const defaultPath = [
            44 | 0x80000000,
            3030 | 0x80000000,
            0 | 0x80000000,
            0,
        ]; */

        const keyFromDefault =
            await mnemonic.toStandardECDSAsecp256k1PrivateKey("", 0);
        const keyFromCorrectPath =
            await mnemonic.toStandardECDSAsecp256k1PrivateKey("", 0);

        expect(keyFromDefault.toStringRaw()).to.eql(
            keyFromCorrectPath.toStringRaw(),
        );
    });

    it("generate EcdsaPrivateKey from Mnemonic, parse it to string, then return it fromString and check if it is the same", async function () {
        const mnemonic = await Mnemonic.fromString(
            "hamster produce dry base sunny bubble disease throw cricket garden beyond script",
        );
        const privateKey = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            "",
            0,
        );

        const privateKeyString = privateKey.toStringRaw();
        const publicKeyString = privateKey.publicKey.toStringRaw();

        // Restore from string
        const restoredPrivateKey = PrivateKey.fromStringECDSA(privateKeyString);
        const restoredPrivateKeyString = privateKey.toStringRaw();
        const restoredPublicKeyString =
            restoredPrivateKey.publicKey.toStringRaw();

        expect(privateKeyString).to.be.equal(restoredPrivateKeyString);
        expect(publicKeyString).to.be.equal(restoredPublicKeyString);
    });

    it("generate ethereum ECDSA private key from Mnemonic phrase", async function () {
        const mnemonic = await Mnemonic.fromString(
            "radar blur cabbage chef fix engine embark joy scheme fiction master release",
        );

        // default ethereum accounts derivation path
        const path = [44 | 0x80000000, 60 | 0x80000000, 0 | 0x80000000, 0, 0];

        const rootKey = await mnemonic.toEcdsaPrivateKey("", path);

        // https://github.com/ethers-io/ethers.js/blob/master/packages/tests/src.ts/test-hdnode.ts
        expect(rootKey.toStringRaw()).to.eql(
            "b96e9ccb774cc33213cbcb2c69d3cdae17b0fe4888a1ccd343cbd1a17fd98b18",
        );
    });
});
// Filename: packages/cryptography/test/unit/PublicKey.js
import PrivateKey from "../../src/PrivateKey.js";
import PublicKey from "../../src/PublicKey.js";
import * as hex from "../../src/encoding/hex.js";

const RAW_KEY =
    "033a514176466fa815ed481ffad09110a2d344f6c9b78c1d14afc351c3a51be33d";
const RAW_KEY_BYTES = hex.decode(RAW_KEY);

const TRUFFLE_KEY =
    "03af80b90d25145da28c583359beb47b21796b2fe1a23c1511e443e7a64dfdb27d";
const TRUFFLE_KEY_BYTES = hex.decode(TRUFFLE_KEY);
const TRUFFLE_ADDRESS = "627306090abab3a6e1400e9345bc60c78a8bef57";

const ECDSA_PRIVATE_RAW =
    "4c6c731ed7123a213eaf37dd72f19220b7005d243cfd52d080708ec5fe032b36";
const ECDSA_PRIVATE_DER =
    "3030020100300706052b8104000a042204204c6c731ed7123a213eaf37dd72f19220b7005d243cfd52d080708ec5fe032b36";
const ED25519_PRIVATE_RAW =
    "ee417dd399722ef8920b2c8ec047cf0c51d6c7d3413e9a660ca28205a5f249cd";
const ED25519_PRIVATE_DER =
    "302e020100300506032b657004220420ee417dd399722ef8920b2c8ec047cf0c51d6c7d3413e9a660ca28205a5f249cd";

const ECDSA_PUBLIC_RAW =
    "038592559824a68150512e5c23736885208382859ac5aad7a73adc48226fe122b5";
const ECDSA_PUBLIC_DER =
    "302d300706052b8104000a032200038592559824a68150512e5c23736885208382859ac5aad7a73adc48226fe122b5";
const ED25519_PUBLIC_RAW =
    "6efd7f7de3ce5caadc830818a8a0bbab7da2c2cdfa6778e9b351c8f519801ae2";
const ED25519_PUBLIC_DER =
    "302a300506032b65700321006efd7f7de3ce5caadc830818a8a0bbab7da2c2cdfa6778e9b351c8f519801ae2";

describe("PublicKey", function () {
    it("ECDSA serializes to same string as Java", function () {
        const key = PublicKey.fromBytesECDSA(RAW_KEY_BYTES);

        expect(key.toString()).to.be.equal(
            "302d300706052b8104000a032200033a514176466fa815ed481ffad09110a2d344f6c9b78c1d14afc351c3a51be33d",
        );
    });

    it("ECDSA public key to ethereum address", function () {
        const key = PublicKey.fromBytesECDSA(TRUFFLE_KEY_BYTES);

        expect(key.toEthereumAddress()).to.be.equal(TRUFFLE_ADDRESS);
    });

    it("equals", async function () {
        const ed25519 = PrivateKey.generate().publicKey;
        const ed25519Copy = PublicKey.fromString(ed25519.toStringRaw());
        const ecdsa = PrivateKey.generateECDSA().publicKey;

        expect(ed25519.toStringRaw()).to.be.equal(ed25519Copy.toStringRaw());

        expect(ed25519.equals(ed25519Copy)).to.be.true;
        expect(ed25519.equals(ecdsa)).to.be.false;
    });

    it("ECDSA consistent toString", function () {
        const key = PrivateKey.fromString(ECDSA_PRIVATE_DER);
        const publicKey = PublicKey.fromString(key.publicKey.toString());

        expect(key.toString()).to.be.equal(ECDSA_PRIVATE_DER);
        expect(key.toStringDer()).to.be.equal(ECDSA_PRIVATE_DER);
        expect(key.toStringRaw()).to.be.equal(ECDSA_PRIVATE_RAW);

        expect(publicKey.toString()).to.be.equal(ECDSA_PUBLIC_DER);
        expect(publicKey.toStringDer()).to.be.equal(ECDSA_PUBLIC_DER);
        expect(publicKey.toStringRaw()).to.be.equal(ECDSA_PUBLIC_RAW);
    });

    it("ED25519 consistent toString", function () {
        const key = PrivateKey.fromString(ED25519_PRIVATE_DER);
        const publicKey = PublicKey.fromString(key.publicKey.toString());

        expect(key.toString()).to.be.equal(ED25519_PRIVATE_DER);
        expect(key.toStringDer()).to.be.equal(ED25519_PRIVATE_DER);
        expect(key.toStringRaw()).to.be.equal(ED25519_PRIVATE_RAW);

        expect(publicKey.toString()).to.be.equal(ED25519_PUBLIC_DER);
        expect(publicKey.toStringDer()).to.be.equal(ED25519_PUBLIC_DER);
        expect(publicKey.toStringRaw()).to.be.equal(ED25519_PUBLIC_RAW);
    });
});
// Filename: packages/cryptography/test/unit/bip39.js
//import Mnemonic from "../../src/Mnemonic.js";
import * as bip39 from "../../src/primitive/bip39.js";
import * as hex from "../../src/encoding/hex.js";

describe("bip39", function () {
    it("generates correct seed", async function () {
        const words = [
            "radar",
            "blur",
            "cabbage",
            "chef",
            "fix",
            "engine",
            "embark",
            "joy",
            "scheme",
            "fiction",
            "master",
            "release",
        ];
        const passphrase = "";
        const seed = await bip39.toSeed(words, passphrase);

        expect(hex.encode(seed)).to.be.equal(
            "ed37b3442b3d550d0fbb6f01f20aac041c245d4911e13452cac7b1676a070eda66771b71c0083b34cc57ca9c327c459a0ec3600dbaf7f238ff27626c8430a806",
        );
    });

    it("mnemonic passphrase NFKD normalization compliant test", async function () {
        const words = [
            "inmate",
            "flip",
            "alley",
            "wear",
            "offer",
            "often",
            "piece",
            "magnet",
            "surge",
            "toddler",
            "submit",
            "right",
            "radio",
            "absent",
            "pear",
            "floor",
            "belt",
            "raven",
            "price",
            "stove",
            "replace",
            "reduce",
            "plate",
            "home",
        ];

        const unicodePassphrase =
            "\u0070\u0061\u0073\u0073\u0070\u0068\u0072\u0061\u0073\u0065";
        const expectedPrivateKey =
            "1ed95521b3406aa1e34db78be696db32f09d9f8ec3115fc12314082a44a3e8d6d4551a1905758b45bc315430f7d9c095da93645f1b0004c393370e0a878dfd4c";

        const seed = await bip39.toSeed(words, unicodePassphrase);

        expect(hex.encode(seed)).to.be.equal(expectedPrivateKey);
    });
});
// Filename: packages/cryptography/test/unit/encoding/base64.js
import * as base64 from "../../../src/encoding/base64.js";
import * as utf8 from "../../../src/encoding/utf8.js";

// from RFC 4648
const vectors = [
    ["", ""],
    ["f", "Zg=="],
    ["fo", "Zm8="],
    ["foo", "Zm9v"],
    ["foob", "Zm9vYg=="],
    ["fooba", "Zm9vYmE="],
    ["foobar", "Zm9vYmFy"],
];

describe("encoding/base64", function () {
    it("should encode", function () {
        for (const [decoded, encoded] of vectors) {
            expect(base64.encode(utf8.encode(decoded))).to.equal(encoded);
        }
    });

    it("should decode", function () {
        for (const [decoded, encoded] of vectors) {
            expect(utf8.decode(base64.decode(encoded))).to.equal(decoded);
        }
    });
});
// Filename: packages/cryptography/test/unit/encoding/der.js
import * as der from "../../../src/encoding/der.js";
import * as base64 from "../../../src/encoding/base64.js";
import * as hex from "../../../src/encoding/hex.js";

describe("encoding/der", function () {
    it("should decode ed25519 private key", function () {
        // taken from Keys.test.js
        const privateKey =
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";
        const rawPrivKey =
            "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";

        const privKeyBytes = hex.decode(privateKey);
        const rawPrivKeyBytes = hex.decode(rawPrivKey);

        const decoded = der.decode(privKeyBytes);

        expect(decoded).to.deep.equal({
            seq: [
                { int: 0 },
                {
                    seq: [{ ident: "1.3.101.112" }],
                },
                // in PKCS `PrivateKeyInfo` the key data is an opaque byte string
                // for Ed25519 the contents is another tagged DER `OCTET STRING`, kind of redundant
                // but for other key types this could be a complex structure
                { bytes: Uint8Array.of(4, 32, ...rawPrivKeyBytes) },
            ],
        });
    });

    it("should decode EncryptedPrivateKeyInfo", function () {
        const base64Encoded =
            "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw" +
            "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x" +
            "R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV" +
            "9hlo4YEh3uEaCmfJzWM=";

        // otherwise the types produced by `.subarray()` won't match
        const data = base64.decode(base64Encoded);

        const decoded = der.decode(data);

        expect(decoded).to.deep.equal({
            seq: [
                {
                    seq: [
                        // algorithm: PBES2
                        { ident: "1.2.840.113549.1.5.13" },
                        // parameters
                        {
                            seq: [
                                {
                                    seq: [
                                        // PBKDF2
                                        { ident: "1.2.840.113549.1.5.12" },
                                        {
                                            seq: [
                                                // salt
                                                {
                                                    bytes: hex.decode(
                                                        "bc598ec6cb6b5385"
                                                    ),
                                                },
                                                // iterations
                                                { int: 2048 },
                                                {
                                                    seq: [
                                                        // HMAC-SHA-256
                                                        {
                                                            ident: "1.2.840.113549.2.9",
                                                        },
                                                        // no parameters
                                                        {},
                                                    ],
                                                },
                                            ],
                                        },
                                    ],
                                },
                                {
                                    seq: [
                                        // AES-128-CBC
                                        { ident: "2.16.840.1.101.3.4.1.2" },
                                        // IV
                                        {
                                            bytes: hex.decode(
                                                "eab8e8d3ecb39f1c85b8d49f6d0da0ad"
                                            ),
                                        },
                                    ],
                                },
                            ],
                        },
                    ],
                },
                // encrypted key data
                {
                    bytes: hex.decode(
                        "6d7147cf212177160ce102b6d3d3365317589b7b5ae7e6d58c0189baf1982ab5" +
                            "432908c93621cb54d9332c723f19585ba695f61968e18121dee11a0a67c9cd63"
                    ),
                },
            ],
        });
    });
});
// Filename: packages/cryptography/test/unit/encoding/hex-native.js
import * as hex from "../../../src/encoding/hex.native.js";

const bytes = new Uint8Array([
    -37, 72, 75, -126, -114, 100, -78, -40, -15, 44, -29, -64, -96, -23, 58, 11,
    -116, -50, 122, -15, -69, -113, 57, -55, 119, 50, 57, 68, -126, 83, -114,
    16,
]);

const string =
    "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";

describe("encoding/hex", function () {
    it("should encode", function () {
        expect(hex.encode(bytes)).to.deep.equal(string);
    });

    it("should decode", function () {
        expect(hex.decode(string)).to.deep.equal(bytes);
    });
});
// Filename: packages/cryptography/test/unit/encoding/hex.js
import * as hex from "../../../src/encoding/hex.js";

const bytes = new Uint8Array([
    -37, 72, 75, -126, -114, 100, -78, -40, -15, 44, -29, -64, -96, -23, 58, 11,
    -116, -50, 122, -15, -69, -113, 57, -55, 119, 50, 57, 68, -126, 83, -114,
    16,
]);

const string =
    "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";

describe("encoding/hex", function () {
    it("should encode", function () {
        expect(hex.encode(bytes)).to.deep.equal(string);
    });

    it("should decode", function () {
        expect(hex.decode(string)).to.deep.equal(bytes);
    });
});
// Filename: packages/cryptography/test/unit/encoding/utf8-native.js
import * as utf8 from "../../../src/encoding/utf8.native.js";

const string =
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus consectetur ex diam, et faucibus libero ultricies id. Cras consectetur velit lacus, vel pulvinar mauris dignissim sit amet. Nulla ut molestie massa, quis vulputate erat. Vivamus a mauris quam. Nulla vulputate consectetur convallis. Curabitur ut tempor lacus. Morbi auctor velit et nibh faucibus maximus. Vestibulum eu tortor ultricies, condimentum felis vel, suscipit leo. Vestibulum laoreet, orci ut suscipit sollicitudin, nisi sapien aliquet enim, eu varius risus magna vitae nisl. Donec mauris lacus, pharetra nec varius eget, scelerisque scelerisque purus. Pellentesque porta volutpat enim vitae blandit.";

const bytes = new Uint8Array([
    76, 111, 114, 101, 109, 32, 105, 112, 115, 117, 109, 32, 100, 111, 108, 111,
    114, 32, 115, 105, 116, 32, 97, 109, 101, 116, 44, 32, 99, 111, 110, 115,
    101, 99, 116, 101, 116, 117, 114, 32, 97, 100, 105, 112, 105, 115, 99, 105,
    110, 103, 32, 101, 108, 105, 116, 46, 32, 80, 104, 97, 115, 101, 108, 108,
    117, 115, 32, 99, 111, 110, 115, 101, 99, 116, 101, 116, 117, 114, 32, 101,
    120, 32, 100, 105, 97, 109, 44, 32, 101, 116, 32, 102, 97, 117, 99, 105, 98,
    117, 115, 32, 108, 105, 98, 101, 114, 111, 32, 117, 108, 116, 114, 105, 99,
    105, 101, 115, 32, 105, 100, 46, 32, 67, 114, 97, 115, 32, 99, 111, 110,
    115, 101, 99, 116, 101, 116, 117, 114, 32, 118, 101, 108, 105, 116, 32, 108,
    97, 99, 117, 115, 44, 32, 118, 101, 108, 32, 112, 117, 108, 118, 105, 110,
    97, 114, 32, 109, 97, 117, 114, 105, 115, 32, 100, 105, 103, 110, 105, 115,
    115, 105, 109, 32, 115, 105, 116, 32, 97, 109, 101, 116, 46, 32, 78, 117,
    108, 108, 97, 32, 117, 116, 32, 109, 111, 108, 101, 115, 116, 105, 101, 32,
    109, 97, 115, 115, 97, 44, 32, 113, 117, 105, 115, 32, 118, 117, 108, 112,
    117, 116, 97, 116, 101, 32, 101, 114, 97, 116, 46, 32, 86, 105, 118, 97,
    109, 117, 115, 32, 97, 32, 109, 97, 117, 114, 105, 115, 32, 113, 117, 97,
    109, 46, 32, 78, 117, 108, 108, 97, 32, 118, 117, 108, 112, 117, 116, 97,
    116, 101, 32, 99, 111, 110, 115, 101, 99, 116, 101, 116, 117, 114, 32, 99,
    111, 110, 118, 97, 108, 108, 105, 115, 46, 32, 67, 117, 114, 97, 98, 105,
    116, 117, 114, 32, 117, 116, 32, 116, 101, 109, 112, 111, 114, 32, 108, 97,
    99, 117, 115, 46, 32, 77, 111, 114, 98, 105, 32, 97, 117, 99, 116, 111, 114,
    32, 118, 101, 108, 105, 116, 32, 101, 116, 32, 110, 105, 98, 104, 32, 102,
    97, 117, 99, 105, 98, 117, 115, 32, 109, 97, 120, 105, 109, 117, 115, 46,
    32, 86, 101, 115, 116, 105, 98, 117, 108, 117, 109, 32, 101, 117, 32, 116,
    111, 114, 116, 111, 114, 32, 117, 108, 116, 114, 105, 99, 105, 101, 115, 44,
    32, 99, 111, 110, 100, 105, 109, 101, 110, 116, 117, 109, 32, 102, 101, 108,
    105, 115, 32, 118, 101, 108, 44, 32, 115, 117, 115, 99, 105, 112, 105, 116,
    32, 108, 101, 111, 46, 32, 86, 101, 115, 116, 105, 98, 117, 108, 117, 109,
    32, 108, 97, 111, 114, 101, 101, 116, 44, 32, 111, 114, 99, 105, 32, 117,
    116, 32, 115, 117, 115, 99, 105, 112, 105, 116, 32, 115, 111, 108, 108, 105,
    99, 105, 116, 117, 100, 105, 110, 44, 32, 110, 105, 115, 105, 32, 115, 97,
    112, 105, 101, 110, 32, 97, 108, 105, 113, 117, 101, 116, 32, 101, 110, 105,
    109, 44, 32, 101, 117, 32, 118, 97, 114, 105, 117, 115, 32, 114, 105, 115,
    117, 115, 32, 109, 97, 103, 110, 97, 32, 118, 105, 116, 97, 101, 32, 110,
    105, 115, 108, 46, 32, 68, 111, 110, 101, 99, 32, 109, 97, 117, 114, 105,
    115, 32, 108, 97, 99, 117, 115, 44, 32, 112, 104, 97, 114, 101, 116, 114,
    97, 32, 110, 101, 99, 32, 118, 97, 114, 105, 117, 115, 32, 101, 103, 101,
    116, 44, 32, 115, 99, 101, 108, 101, 114, 105, 115, 113, 117, 101, 32, 115,
    99, 101, 108, 101, 114, 105, 115, 113, 117, 101, 32, 112, 117, 114, 117,
    115, 46, 32, 80, 101, 108, 108, 101, 110, 116, 101, 115, 113, 117, 101, 32,
    112, 111, 114, 116, 97, 32, 118, 111, 108, 117, 116, 112, 97, 116, 32, 101,
    110, 105, 109, 32, 118, 105, 116, 97, 101, 32, 98, 108, 97, 110, 100, 105,
    116, 46,
]);

describe("encoding/utf8", function () {
    it("should encode", function () {
        expect(utf8.encode(string)).to.deep.equal(bytes);
    });

    it("should decode", function () {
        expect(utf8.decode(bytes)).to.deep.equal(string);
    });
});
// Filename: packages/cryptography/test/unit/encoding/utf8.js
import * as utf8 from "../../../src/encoding/utf8.js";

const string =
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus consectetur ex diam, et faucibus libero ultricies id. Cras consectetur velit lacus, vel pulvinar mauris dignissim sit amet. Nulla ut molestie massa, quis vulputate erat. Vivamus a mauris quam. Nulla vulputate consectetur convallis. Curabitur ut tempor lacus. Morbi auctor velit et nibh faucibus maximus. Vestibulum eu tortor ultricies, condimentum felis vel, suscipit leo. Vestibulum laoreet, orci ut suscipit sollicitudin, nisi sapien aliquet enim, eu varius risus magna vitae nisl. Donec mauris lacus, pharetra nec varius eget, scelerisque scelerisque purus. Pellentesque porta volutpat enim vitae blandit.";

const bytes = new Uint8Array([
    76, 111, 114, 101, 109, 32, 105, 112, 115, 117, 109, 32, 100, 111, 108, 111,
    114, 32, 115, 105, 116, 32, 97, 109, 101, 116, 44, 32, 99, 111, 110, 115,
    101, 99, 116, 101, 116, 117, 114, 32, 97, 100, 105, 112, 105, 115, 99, 105,
    110, 103, 32, 101, 108, 105, 116, 46, 32, 80, 104, 97, 115, 101, 108, 108,
    117, 115, 32, 99, 111, 110, 115, 101, 99, 116, 101, 116, 117, 114, 32, 101,
    120, 32, 100, 105, 97, 109, 44, 32, 101, 116, 32, 102, 97, 117, 99, 105, 98,
    117, 115, 32, 108, 105, 98, 101, 114, 111, 32, 117, 108, 116, 114, 105, 99,
    105, 101, 115, 32, 105, 100, 46, 32, 67, 114, 97, 115, 32, 99, 111, 110,
    115, 101, 99, 116, 101, 116, 117, 114, 32, 118, 101, 108, 105, 116, 32, 108,
    97, 99, 117, 115, 44, 32, 118, 101, 108, 32, 112, 117, 108, 118, 105, 110,
    97, 114, 32, 109, 97, 117, 114, 105, 115, 32, 100, 105, 103, 110, 105, 115,
    115, 105, 109, 32, 115, 105, 116, 32, 97, 109, 101, 116, 46, 32, 78, 117,
    108, 108, 97, 32, 117, 116, 32, 109, 111, 108, 101, 115, 116, 105, 101, 32,
    109, 97, 115, 115, 97, 44, 32, 113, 117, 105, 115, 32, 118, 117, 108, 112,
    117, 116, 97, 116, 101, 32, 101, 114, 97, 116, 46, 32, 86, 105, 118, 97,
    109, 117, 115, 32, 97, 32, 109, 97, 117, 114, 105, 115, 32, 113, 117, 97,
    109, 46, 32, 78, 117, 108, 108, 97, 32, 118, 117, 108, 112, 117, 116, 97,
    116, 101, 32, 99, 111, 110, 115, 101, 99, 116, 101, 116, 117, 114, 32, 99,
    111, 110, 118, 97, 108, 108, 105, 115, 46, 32, 67, 117, 114, 97, 98, 105,
    116, 117, 114, 32, 117, 116, 32, 116, 101, 109, 112, 111, 114, 32, 108, 97,
    99, 117, 115, 46, 32, 77, 111, 114, 98, 105, 32, 97, 117, 99, 116, 111, 114,
    32, 118, 101, 108, 105, 116, 32, 101, 116, 32, 110, 105, 98, 104, 32, 102,
    97, 117, 99, 105, 98, 117, 115, 32, 109, 97, 120, 105, 109, 117, 115, 46,
    32, 86, 101, 115, 116, 105, 98, 117, 108, 117, 109, 32, 101, 117, 32, 116,
    111, 114, 116, 111, 114, 32, 117, 108, 116, 114, 105, 99, 105, 101, 115, 44,
    32, 99, 111, 110, 100, 105, 109, 101, 110, 116, 117, 109, 32, 102, 101, 108,
    105, 115, 32, 118, 101, 108, 44, 32, 115, 117, 115, 99, 105, 112, 105, 116,
    32, 108, 101, 111, 46, 32, 86, 101, 115, 116, 105, 98, 117, 108, 117, 109,
    32, 108, 97, 111, 114, 101, 101, 116, 44, 32, 111, 114, 99, 105, 32, 117,
    116, 32, 115, 117, 115, 99, 105, 112, 105, 116, 32, 115, 111, 108, 108, 105,
    99, 105, 116, 117, 100, 105, 110, 44, 32, 110, 105, 115, 105, 32, 115, 97,
    112, 105, 101, 110, 32, 97, 108, 105, 113, 117, 101, 116, 32, 101, 110, 105,
    109, 44, 32, 101, 117, 32, 118, 97, 114, 105, 117, 115, 32, 114, 105, 115,
    117, 115, 32, 109, 97, 103, 110, 97, 32, 118, 105, 116, 97, 101, 32, 110,
    105, 115, 108, 46, 32, 68, 111, 110, 101, 99, 32, 109, 97, 117, 114, 105,
    115, 32, 108, 97, 99, 117, 115, 44, 32, 112, 104, 97, 114, 101, 116, 114,
    97, 32, 110, 101, 99, 32, 118, 97, 114, 105, 117, 115, 32, 101, 103, 101,
    116, 44, 32, 115, 99, 101, 108, 101, 114, 105, 115, 113, 117, 101, 32, 115,
    99, 101, 108, 101, 114, 105, 115, 113, 117, 101, 32, 112, 117, 114, 117,
    115, 46, 32, 80, 101, 108, 108, 101, 110, 116, 101, 115, 113, 117, 101, 32,
    112, 111, 114, 116, 97, 32, 118, 111, 108, 117, 116, 112, 97, 116, 32, 101,
    110, 105, 109, 32, 118, 105, 116, 97, 101, 32, 98, 108, 97, 110, 100, 105,
    116, 46,
]);

describe("encoding/utf8", function () {
    it("should encode", function () {
        expect(utf8.encode(string)).to.deep.equal(bytes);
    });

    it("should decode", function () {
        expect(utf8.decode(bytes)).to.deep.equal(string);
    });
});
// Filename: packages/cryptography/test/unit/key.js
import PrivateKey from "../../src/PrivateKey.js";
import PublicKey from "../../src/PublicKey.js";
import * as utf8 from "../../src/encoding/utf8.js";
import * as hex from "../../src/encoding/hex.js";
import Mnemonic from "../../src/Mnemonic.js";
import BadKeyError from "../../src/BadKeyError.js";
import { keystoreV1 } from "./keystore.js";

const keystorePassword = "Harriet Porber And The Bad Boy Parasaurolophus";
const privateKeystore =
    "302e020100300506032b6570042204204072d365d02199b5103336cf6a187578ffb6eba4ad6f8b2383c5cc54d00c4409";

// key from hiero-sdk-java tests, not used anywhere
const privKeyBytes = Uint8Array.of(
    -37,
    72,
    75,
    -126,
    -114,
    100,
    -78,
    -40,
    -15,
    44,
    -29,
    -64,
    -96,
    -23,
    58,
    11,
    -116,
    -50,
    122,
    -15,
    -69,
    -113,
    57,
    -55,
    119,
    50,
    57,
    68,
    -126,
    83,
    -114,
    16,
);

const privateKey = PrivateKey.fromBytes(privKeyBytes);

const privKeyStr =
    "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";
const privAndPubKeyStr =
    "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7";
const rawPrivKeyStr =
    "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";

const pubKeyBytes = Uint8Array.of(
    -32,
    -56,
    -20,
    39,
    88,
    -91,
    -121,
    -97,
    -6,
    -62,
    38,
    -95,
    60,
    12,
    81,
    107,
    121,
    -98,
    114,
    -29,
    81,
    65,
    -96,
    -35,
    -126,
    -113,
    -108,
    -45,
    121,
    -120,
    -92,
    -73,
);

const message = utf8.encode("hello, world");

const signature = new Uint8Array([
    157, 4, 191, 237, 123, 170, 151, 200, 13, 41, 166, 174, 72, 192, 216, 150,
    206, 132, 99, 167, 234, 12, 22, 25, 125, 85, 165, 99, 199, 57, 150, 239, 6,
    43, 42, 223, 80, 127, 65, 108, 16, 132, 34, 192, 49, 15, 198, 251, 33, 136,
    110, 17, 206, 61, 227, 233, 81, 215, 165, 96, 73, 116, 63, 7,
]);

// root key generated by the iOS wallet, not used anywhere
const iosWalletMnemonic =
    "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle";

// private key for "default account", should be index 0
const iosWalletPrivKey =
    "5f66a51931e8c99089472e0d70516b6272b94dd772b967f8221e1077f966dbda2b60cf7ee8cf10ecd5a076bffad9a7c7b97df370ad758c0f1dd4ef738e04ceb6";

const iosWalletKeyBytes = hex.decode(iosWalletPrivKey);
const iosWalletPrivKeyBytes = iosWalletKeyBytes.subarray(0, 32);
const iosWalletPubKeyBytes = iosWalletKeyBytes.subarray(32);

// root key generated by the Android wallet, also not used anywhere
const androidWalletMnemonic =
    "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track";

// private key for "default account", should be index 0
const androidWalletPrivKey =
    "c284c25b3a1458b59423bc289e83703b125c8eefec4d5aa1b393c2beb9f2bae66188a344ba75c43918ab12fa2ea4a92960eca029a2320d8c6a1c3b94e06c9985";

const androidWalletKeyBytes = hex.decode(androidWalletPrivKey);
const androidWalletPrivKeyBytes = androidWalletKeyBytes.subarray(0, 32);
const androidWalletPubKeyBytes = androidWalletKeyBytes.subarray(32);

const passphrase = "asdf1234";

const pemString =
    "-----BEGIN PRIVATE KEY-----\n" +
    "MC4CAQAwBQYDK2VwBCIEINtIS4KOZLLY8SzjwKDpOguMznrxu485yXcyOUSCU44Q\n" +
    "-----END PRIVATE KEY-----\n";

const encryptedPem =
    "-----BEGIN ENCRYPTED PRIVATE KEY-----\n" +
    "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw\n" +
    "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x\n" +
    "R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV\n" +
    "9hlo4YEh3uEaCmfJzWM=\n" +
    "-----END ENCRYPTED PRIVATE KEY-----\n";

const pemPassphrase = "this is a passphrase";

describe("PrivateKey", function () {
    it("should be able to sign message", function () {
        expect(privateKey.sign(message)).to.deep.eq(signature);
    });

    it("should correctly verify signature", function () {
        expect(privateKey.publicKey.verify(message, signature)).to.be.true;
    });

    it("should produce correctly encoded string when toString() is called", function () {
        expect(privateKey.toString()).to.deep.equal(privKeyStr);
    });

    it("should produce same publicKey", function () {
        expect(privateKey.publicKey.toBytesRaw()).to.deep.equal(pubKeyBytes);
    });

    it("should return correct value when using fromString", function () {
        const privateKey = PrivateKey.fromString(privKeyStr);
        expect(privateKey.toBytesRaw()).to.deep.equal(privKeyBytes);

        const privateKey2 = PrivateKey.fromString(privAndPubKeyStr);
        expect(privateKey2.toBytesRaw()).to.deep.equal(privKeyBytes);

        const privateKey3 = PrivateKey.fromString(rawPrivKeyStr);
        expect(privateKey3.toBytesRaw()).to.deep.equal(privKeyBytes);

        const privateKey4 = PrivateKey.fromString(iosWalletPrivKey);
        expect(privateKey4.toBytesRaw()).to.deep.equal(iosWalletPrivKeyBytes);
        expect(privateKey4.publicKey.toBytesRaw()).to.deep.equal(
            iosWalletPubKeyBytes,
        );

        const privateKey5 = PrivateKey.fromString(androidWalletPrivKey);
        expect(privateKey5.toBytesRaw()).to.deep.equal(
            androidWalletPrivKeyBytes,
        );
        expect(privateKey5.publicKey.toBytesRaw()).to.deep.equal(
            androidWalletPubKeyBytes,
        );
    });

    it("toKeystore() creates loadable keystores", async function () {
        const keystoreBytes = await privateKey.toKeystore(passphrase);
        const key = await PrivateKey.fromKeystore(keystoreBytes, passphrase);

        expect(privateKey.toBytes()).to.deep.equal(key.toBytes());

        await PrivateKey.fromKeystore(
            keystoreBytes,
            "some random password",
        ).catch((err) => {
            expect(err).to.be.instanceOf(BadKeyError);
            expect(err).to.have.property(
                "message",
                "HMAC mismatch; passphrase is incorrect",
            );
        });
    });

    it("keystore works correctly", async function () {
        const keystoreBytesFromFile = utf8.encode(keystoreV1);

        const key = await PrivateKey.fromKeystore(
            keystoreBytesFromFile,
            keystorePassword,
        );

        expect(privateKeystore).to.deep.equal(key.toString());
    });

    it("derive() produces correct value", async function () {
        const iosMnemonic = await Mnemonic.fromString(iosWalletMnemonic);
        const iosKey = await iosMnemonic.toStandardEd25519PrivateKey("", 0);

        expect(iosKey.toBytesRaw()).to.deep.equal(iosWalletPrivKeyBytes);
        expect(iosKey.publicKey.toBytesRaw()).to.deep.equal(
            iosWalletPubKeyBytes,
        );

        const androidMnemonic = await Mnemonic.fromString(
            androidWalletMnemonic,
        );
        const androidKey = await androidMnemonic.toStandardEd25519PrivateKey(
            "",
            0,
        );

        expect(androidKey.toBytesRaw()).to.deep.equal(
            androidWalletPrivKeyBytes,
        );
        expect(androidKey.publicKey.toBytesRaw()).to.deep.equal(
            androidWalletPubKeyBytes,
        );
    });

    it("fromPem() produces a correct value", async function () {
        const key = await PrivateKey.fromPem(pemString);
        expect(key.toString()).to.deep.equal(privKeyStr);
    });

    it("fromPem() with passphrase produces a correct value", async function () {
        const key = await PrivateKey.fromPem(encryptedPem, pemPassphrase);
        expect(key.toString()).to.deep.equal(privKeyStr);
    });

    it("PublicKey.fromString() should work", async function () {
        let err = false;

        try {
            PublicKey.fromString(PrivateKey.generate().publicKey.toString());
        } catch (error) {
            err = true;
        }

        expect(err).to.be.false;
    });
});
// Filename: packages/cryptography/test/unit/keystore.js
export const keystoreV1 = `{"version":1,"crypto":{"ciphertext":"92e133ced8d2d0a5b13334e24c436145f182d7d3188799dab73348577aa6b525c8f5a39550ef08a956968c2a515ac6be131c0281e8e48914a1c89fbfa381c420","cipherparams":{"iv":"d17926abd3fbd429ecaaf8cfd285ee63"},"cipher":"aes-128-ctr","kdf":"pbkdf2","kdfparams":{"dkLen":32,"salt":"7d1f4b77d8ad55a2903171ed324cf1cd032f105a9495af15994f3a4cf6cd4361","c":262144,"prf":"hmac-sha256"},"mac":"b2daf12be1b3d5326b1cd8c72f51781ef155054b4c8c3087489d78a3330e2f28b86e6d3967982ad1823eab00cb6c6763"}}`;
// Filename: packages/cryptography/test/unit/primitive/pkcs.js
import { EncryptedPrivateKeyInfo } from "../../../src/primitive/pkcs.js";
import PrivateKey from "../../../src/PrivateKey.js";
import * as der from "../../../src/encoding/der.js";
import * as base64 from "../../../src/encoding/base64.js";
import * as hex from "../../../src/encoding/hex.js";

const base64Encoded =
    "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw" +
    "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x" +
    "R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV" +
    "9hlo4YEh3uEaCmfJzWM=";

const passphrase = "this is a passphrase";

const keyStr =
    "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";

// otherwise the types produced by `.subarray()` won't match
const data = base64.decode(base64Encoded);

describe("primitive/pkcs", function () {
    it("decodes EncryptedPrivateKeyInfo", function () {
        const privateKeyInfo = EncryptedPrivateKeyInfo.parse(data);
        expect(privateKeyInfo).to.deep.equal(
            new EncryptedPrivateKeyInfo({
                seq: [
                    {
                        seq: [
                            // algorithm: PBES2
                            { ident: "1.2.840.113549.1.5.13" },
                            // parameters
                            {
                                seq: [
                                    {
                                        seq: [
                                            // PBKDF2
                                            { ident: "1.2.840.113549.1.5.12" },
                                            {
                                                seq: [
                                                    // salt
                                                    {
                                                        bytes: hex.decode(
                                                            "bc598ec6cb6b5385"
                                                        ),
                                                    },
                                                    // iterations
                                                    { int: 2048 },
                                                    {
                                                        seq: [
                                                            // HMAC-SHA-256
                                                            {
                                                                ident: "1.2.840.113549.2.9",
                                                            },
                                                            // no parameters
                                                            {},
                                                        ],
                                                    },
                                                ],
                                            },
                                        ],
                                    },
                                    {
                                        seq: [
                                            // AES-128-CBC
                                            { ident: "2.16.840.1.101.3.4.1.2" },
                                            // IV
                                            {
                                                bytes: hex.decode(
                                                    "eab8e8d3ecb39f1c85b8d49f6d0da0ad"
                                                ),
                                            },
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                    // encrypted key data
                    {
                        bytes: hex.decode(
                            "6d7147cf212177160ce102b6d3d3365317589b7b5ae7e6d58c0189baf1982ab5" +
                                "432908c93621cb54d9332c723f19585ba695f61968e18121dee11a0a67c9cd63"
                        ),
                    },
                ],
            })
        );
    });

    it("decrypts the proper private key", async function () {
        const encrypted = EncryptedPrivateKeyInfo.parse(data);
        const decrypted = await encrypted.decrypt(passphrase);

        expect(decrypted.algId.algIdent).to.deep.equal("1.3.101.112");

        // for  the private key data is a DER encoded octet string
        const keyData = der.decode(decrypted.privateKey);
        expect("bytes" in keyData).to.be.true;

        // @ts-ignore Typescript doesn't see that we just checked `keyData`
        expect(PrivateKey.fromBytes(keyData.bytes).toString()).to.deep.equal(
            keyStr
        );
    });
});
// Filename: packages/cryptography/vite.config.js
/** @type {import('vite').UserConfig} */
export default {
    server: {
        hmr: false,
    },
    envDir: "./",
    build: {
        polyfillDynamicImport: false,
    },
    optimizeDeps: {
        force: true,
        entries: [
            "./test/unit/encoding/hex.js",
            "./test/unit/encoding/utf8.js",
            "./test/unit/encoding/der.js",
            "./test/unit/encoding/base64.js",
            "./test/unit/encoding/pkcs.js",
            "./test/unit/Mnemonic.js",
            "./test/unit/key.js",
        ],
    },
    resolve: {
        alias: {
            // redirect src/ to src/browser
            // note that this is NOT needed when consuming this package as the browser field in package.json
            // will take care of this
            "../../../src/primitive/aes.js": "../../../src/primitive/aes.browser.js",
            "../../../src/encoding/base64.js": "../../../src/encoding/base64.browser.js",
            "../../../src/encoding/hex.js": "../../../src/encoding/hex.browser.js",
            "../../../src/primitive/hmac.js": "../../../src/primitive/hmac.browser.js",
            "../../../src/primitive/pbkdf2.js": "../../../src/primitive/pbkdf2.browser.js",
            "../../../src/primitive/sha256.js": "../../../src/primitive/sha256.browser.js",
            "../../../src/encoding/utf8.js": "../../../src/encoding/utf8.browser.js",
            "../../src/primitive/aes.js": "../../src/primitive/aes.browser.js",
            "../../src/encoding/base64.js": "../../src/encoding/base64.browser.js",
            "../../src/encoding/hex.js": "../../src/encoding/hex.browser.js",
            "../../src/primitive/hmac.js": "../../src/primitive/hmac.browser.js",
            "../../src/primitive/pbkdf2.js": "../../src/primitive/pbkdf2.browser.js",
            "../../src/primitive/sha256.js": "../../src/primitive/sha256.browser.js",
            "../../src/encoding/utf8.js": "../../src/encoding/utf8.browser.js",
            "../src/primitive/aes.js": "../src/primitive/aes.browser.js",
            "../src/encoding/base64.js": "../src/encoding/base64.browser.js",
            "../src/encoding/hex.js": "../src/encoding/hex.browser.js",
            "../src/primitive/hmac.js": "../src/primitive/hmac.browser.js",
            "../src/primitive/pbkdf2.js": "../src/primitive/pbkdf2.browser.js",
            "../src/primitive/sha256.js": "../src/primitive/sha256.browser.js",
            "../src/encoding/utf8.js": "../src/encoding/utf8.browser.js",
            "./src/primitive/aes.js": "./src/primitive/aes.browser.js",
            "./src/encoding/base64.js": "./src/encoding/base64.browser.js",
            "./src/encoding/hex.js": "./src/encoding/hex.browser.js",
            "./src/primitive/hmac.js": "./src/primitive/hmac.browser.js",
            "./src/primitive/pbkdf2.js": "./src/primitive/pbkdf2.browser.js",
            "./src/primitive/sha256.js": "./src/primitive/sha256.browser.js",
            "./src/encoding/utf8.js": "./src/encoding/utf8.browser.js",
            "./primitive/aes.js": "./primitive/aes.browser.js",
            "./encoding/base64.js": "./encoding/base64.browser.js",
            "./encoding/hex.js": "./encoding/hex.browser.js",
            "./primitive/hmac.js": "./primitive/hmac.browser.js",
            "./primitive/pbkdf2.js": "./primitive/pbkdf2.browser.js",
            "./primitive/sha256.js": "./primitive/sha256.browser.js",
            "./encoding/utf8.js": "./encoding/utf8.browser.js",
            "../primitive/aes.js": "../primitive/aes.browser.js",
            "../encoding/base64.js": "../encoding/base64.browser.js",
            "../encoding/hex.js": "../encoding/hex.browser.js",
            "../primitive/hmac.js": "../primitive/hmac.browser.js",
            "../primitive/pbkdf2.js": "../primitive/pbkdf2.browser.js",
            "../primitive/sha256.js": "../primitive/sha256.browser.js",
            "../encoding/utf8.js": "../encoding/utf8.browser.js",
            "./aes.js": "./aes.browser.js",
            "./base64.js": "./base64.browser.js",
            "./hex.js": "./hex.browser.js",
            "./hmac.js": "./hmac.browser.js",
            "./pbkdf2.js": "./pbkdf2.browser.js",
            "./sha256.js": "./sha256.browser.js",
            "./utf8.js": "./utf8.browser.js",
        },
    },
};
// Filename: packages/proto/src/index.js
import * as $protobuf from "protobufjs/minimal.js";
import Long from "long";

import * as $proto from "./proto.js";

/**
 * Patch protobuf race condition between loading protobuf and Long.js libraries.
 */
(() => {
    var $util = $protobuf.util;

    if ($util.Long == null) {
        console.log(`Patching Protobuf Long.js instance...`);
        $util.Long = Long;

        if ($protobuf.Reader._configure != null) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            $protobuf.Reader._configure($protobuf.BufferReader);
        }
    }
})();

export const Reader = $protobuf.Reader;
export const Writer = $protobuf.Writer;

export const proto = $proto.proto;
export const com = $proto.com;
export const google = $proto.google;
// Filename: packages/proto/vite.config.js
module.exports = {
    optimizeDeps: {
        allowNodeBuiltins: [
            "@hashgraph/cryptography"
        ]
    }
}
// Filename: playwright.config.js
import { devices } from '@playwright/test';

/**
 * @type {import("@playwright/test").PlaywrightTestConfig}
 */
const config = {
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  use: {
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
  ],
};

if (process.platform === "darwin") {
    config.projects.push({
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    });
}

export default config;
// Filename: rollup.config.js
import terser from "@rollup/plugin-terser";
import alias from "@rollup/plugin-alias";

const browserAliases = {
    entries: [
        {
            find: "../src/encoding/hex.js",
            replacement: "../src/encoding/hex.browser.js",
        },
        {
            find: "../../src/encoding/hex.js",
            replacement: "../../src/encoding/hex.browser.js",
        },
        {
            find: "../../../src/encoding/hex.js",
            replacement: "../../../src/encoding/hex.browser.js",
        },
        {
            find: "src/encoding/hex.js",
            replacement: "src/encoding/hex.browser.js",
        },
        {
            find: "../encoding/hex.js",
            replacement: "../encoding/hex.browser.js",
        },
        { find: "./encoding/hex.js", replacement: "./encoding/hex.browser.js" },
        {
            find: "../src/encoding/utf8.js",
            replacement: "../src/encoding/utf8.browser.js",
        },
        {
            find: "../../src/encoding/utf8.js",
            replacement: "../../src/encoding/utf8.browser.js",
        },
        {
            find: "../encoding/utf8.js",
            replacement: "../encoding/utf8.browser.js",
        },
        {
            find: "../src/cryptography/sha384.js",
            replacement: "../src/cryptography/sha384.browser.js",
        },
        {
            find: "../cryptography/sha384.js",
            replacement: "../cryptography/sha384.browser.js",
        },
        {
            find: "./client/NodeIntegrationTestEnv.js",
            replacement: "./client/WebIntegrationTestEnv.js",
        },
        {
            find: "../integration/client/NodeIntegrationTestEnv.js",
            replacement: "../integration/client/WebIntegrationTestEnv.js",
        },
        {
            find: "../../src/client/NodeClient.js",
            replacement: "../../src/client/WebClient.js",
        },
        // Add the index.js redirects
        { find: "../../src/index.js", replacement: "../../src/browser.js" },
        { find: "../src/index.js", replacement: "../src/browser.js" },
    ],
};

const nativeAliases = {
    entries: [
        { find: "../src/index.js", replacement: "../src/native.js" },
        {
            find: "../src/encoding/hex.js",
            replacement: "../src/encoding/hex.native.js",
        },
        {
            find: "../src/encoding/utf8.js",
            replacement: "../src/encoding/utf8.native.js",
        },
        {
            find: "../src/cryptography/sha384.js",
            replacement: "../src/cryptography/sha384.native.js",
        },
    ],
};

export default [
    {
        input: "src/browser.js",
        plugins: [alias(browserAliases), terser()],
        output: {
            dir: "lib/",
            format: "esm",
            sourcemap: true,
            preserveModules: true,
        },
    },
    {
        input: "src/native.js",
        plugins: [terser(), alias(nativeAliases)],
        output: {
            dir: "lib/",
            format: "esm",
            sourcemap: true,
            preserveModules: true,
        },
    },
    {
        input: "src/index.js",
        plugins: [terser()],
        output: {
            dir: "lib/",
            format: "esm",
            sourcemap: true,
            preserveModules: true,
        },
    },
];
// Filename: scripts/update-address-books.js
import { Client, FileId, AddressBookQuery } from "../src/index.js";

import fs from "node:fs/promises";

async function main() {
    const networks = [
        { name: "previewnet" },
        { name: "testnet" },
        { name: "mainnet", url: "mainnet-public.mirrornode.hedera.com:443" },
    ];

    for (const network of networks) {
        const client = Client.forName(network.name, {
            scheduleNetworkUpdate: false,
        });

        if (network.url != null) {
            client.setMirrorNetwork([network.url]).setTransportSecurity(true);
        }

        const addressBook = await new AddressBookQuery()
            .setFileId(FileId.ADDRESS_BOOK)
            .execute(client);

        await fs.writeFile(
            `./src/client/addressbooks/${network.name}.js`,
            `export const addressBook =
    "${Buffer.from(addressBook.toBytes()).toString("hex")}";\n`,
        );
    }
}

void main();
// Filename: src/BadEntityIdError.js
// SPDX-License-Identifier: Apache-2.0

export default class BadEntityIdError extends Error {
    /**
     * @param {Long} shard
     * @param {Long} realm
     * @param {Long} num
     * @param {string} presentChecksum
     * @param {string} expectedChecksum
     */
    constructor(shard, realm, num, presentChecksum, expectedChecksum) {
        super(
            `Entity ID ${shard.toString()}.${realm.toString()}.${num.toString()}-${presentChecksum} was incorrect.`,
        );

        this.name = "BadEntityIdException";

        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.presentChecksum = presentChecksum;
        this.expectedChecksum = expectedChecksum;
    }
}
// Filename: src/Cache.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./contract/ContractId.js").default} ContractId
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./KeyList.js").default} KeyList
 * @typedef {import("./PublicKey.js").default} PublicKey
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 * @typedef {import("./Mnemonic.js").default} Mnemonic
 * @typedef {import("./EvmAddress.js").default} EvmAddress
 * @typedef {import("./EthereumTransactionData.js").default} EthereumTransactionData
 * @typedef {import("./transaction/TransactionReceiptQuery.js").default} TransactionReceiptQuery
 * @typedef {import("./transaction/TransactionRecordQuery.js").default} TransactionRecordQuery
 * @typedef {import("./network/AddressBookQuery.js").default} AddressBookQuery
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 * @typedef {import("@hashgraph/proto").proto.IKeyList} HieroProto.proto.IKeyList
 * @typedef {import("@hashgraph/proto").proto.IThresholdKey} HieroProto.proto.IThresholdKey
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 */

/**
 * @namespace cryptography
 * @typedef {import("@hashgraph/cryptography").PrivateKey} cryptography.PrivateKey
 * @typedef {import("@hashgraph/cryptography").Mnemonic} cryptography.Mnemonic
 */

/**
 * @template {object} ProtobufT
 * @template {object} SdkT
 * @typedef {{ (proto: ProtobufT): SdkT }} FromProtobufKeyFuncT
 */

/**
 * Cache class is designed to prevent cyclic dependencies in the Hiero JavaScript SDK.
 * It stores various conversion functions and configuration values that are used across
 * different parts of the SDK.
 */
class Cache {
    constructor() {
        /** @type {number} */
        this._timeDrift = 0;

        /** @type {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId> | null} */
        this._contractId = null;

        /** @type {FromProtobufKeyFuncT<HieroProto.proto.IKeyList, KeyList> | null} */
        this._keyList = null;

        /** @type {FromProtobufKeyFuncT<HieroProto.proto.IThresholdKey, KeyList> | null} */
        this._thresholdKey = null;

        /** @type {FromProtobufKeyFuncT<Uint8Array, PublicKey> | null} */
        this._publicKeyED25519 = null;

        /** @type {FromProtobufKeyFuncT<Uint8Array, PublicKey> | null} */
        this._publicKeyECDSA = null;

        /** @type {((key: cryptography.PrivateKey) => PrivateKey) | null} */
        this._privateKeyConstructor = null;

        /** @type {((key: cryptography.Mnemonic) => Mnemonic) | null} */
        this._mnemonicFromString = null;

        /** @type {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId) | null} */
        this._accountIdConstructor = null;

        /** @type {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId> | null} */
        this._delegateContractId = null;

        /** @type {FromProtobufKeyFuncT<Uint8Array, EvmAddress> | null} */
        this._evmAddress = null;

        /** @type {((bytes: Uint8Array) => EthereumTransactionData) | null} */
        this._ethereumTransactionDataLegacyFromBytes = null;

        /** @type {((bytes: Uint8Array) => EthereumTransactionData) | null} */
        this._ethereumTransactionDataEip1559FromBytes = null;

        /** @type {((bytes: Uint8Array) => EthereumTransactionData) | null} */
        this._ethereumTransactionDataEip2930FromBytes = null;

        /** @type {(() => TransactionReceiptQuery) | null} */
        this._transactionReceiptQueryConstructor = null;

        /** @type {(() => TransactionRecordQuery) | null} */
        this._transactionRecordQueryConstructor = null;
    }

    /**
     * @param {number} timeDrift
     */
    setTimeDrift(timeDrift) {
        this._timeDrift = timeDrift;
    }

    /**
     * @returns {number}
     */
    get timeDrift() {
        if (this._timeDrift == null) {
            throw new Error("Cache.timeDrift was used before it was set");
        }

        return this._timeDrift;
    }

    /**
     * @param {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>} contractId
     */
    setContractId(contractId) {
        this._contractId = contractId;
    }

    /**
     * @returns {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>}
     */
    get contractId() {
        if (this._contractId == null) {
            throw new Error("Cache.contractId was used before it was set");
        }

        return this._contractId;
    }

    /**
     * @param {FromProtobufKeyFuncT<HieroProto.proto.IKeyList, KeyList>} keyList
     */
    setKeyList(keyList) {
        this._keyList = keyList;
    }

    /**
     * @returns {FromProtobufKeyFuncT<HieroProto.proto.IKeyList, KeyList>}
     */
    get keyList() {
        if (this._keyList == null) {
            throw new Error("Cache.keyList was used before it was set");
        }

        return this._keyList;
    }

    /**
     * @param {FromProtobufKeyFuncT<HieroProto.proto.IThresholdKey, KeyList>} thresholdKey
     */
    setThresholdKey(thresholdKey) {
        this._thresholdKey = thresholdKey;
    }

    /**
     * @returns {FromProtobufKeyFuncT<HieroProto.proto.IThresholdKey, KeyList>}
     */
    get thresholdKey() {
        if (this._thresholdKey == null) {
            throw new Error("Cache.thresholdKey was used before it was set");
        }

        return this._thresholdKey;
    }

    /**
     * @param {FromProtobufKeyFuncT<Uint8Array, PublicKey>} publicKeyED25519
     */
    setPublicKeyED25519(publicKeyED25519) {
        this._publicKeyED25519 = publicKeyED25519;
    }

    /**
     * @returns {FromProtobufKeyFuncT<Uint8Array, PublicKey>}
     */
    get publicKeyED25519() {
        if (this._publicKeyED25519 == null) {
            throw new Error(
                "Cache.publicKeyED25519 was used before it was set",
            );
        }

        return this._publicKeyED25519;
    }

    /**
     * @param {FromProtobufKeyFuncT<Uint8Array, PublicKey>} publicKeyECDSA
     */
    setPublicKeyECDSA(publicKeyECDSA) {
        this._publicKeyECDSA = publicKeyECDSA;
    }

    /**
     * @returns {FromProtobufKeyFuncT<Uint8Array, PublicKey>}
     */
    get publicKeyECDSA() {
        if (this._publicKeyECDSA == null) {
            throw new Error("Cache.publicKeyECDSA was used before it was set");
        }

        return this._publicKeyECDSA;
    }

    /**
     * @param {((key: cryptography.PrivateKey) => PrivateKey)} privateKeyConstructor
     */
    setPrivateKeyConstructor(privateKeyConstructor) {
        this._privateKeyConstructor = privateKeyConstructor;
    }

    /**
     * @returns {((key: cryptography.PrivateKey) => PrivateKey)}
     */
    get privateKeyConstructor() {
        if (this._privateKeyConstructor == null) {
            throw new Error(
                "Cache.privateKeyConstructor was used before it was set",
            );
        }

        return this._privateKeyConstructor;
    }

    /**
     * @param {((key: cryptography.Mnemonic) => Mnemonic)} mnemonicFromString
     */
    setMnemonicFromString(mnemonicFromString) {
        this._mnemonicFromString = mnemonicFromString;
    }

    /**
     * @returns {((key: cryptography.PrivateKey) => PrivateKey)}
     */
    get mnemonicFromString() {
        if (this._mnemonicFromString == null) {
            throw new Error(
                "Cache.mnemonicFromString was used before it was set",
            );
        }

        return this.mnemonicFromString;
    }

    /**
     * @param {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId)} accountIdConstructor
     */
    setAccountIdConstructor(accountIdConstructor) {
        this._accountIdConstructor = accountIdConstructor;
    }

    /**
     * @returns {((shard: Long | number, realm: Long | number, key: PublicKey) => AccountId)}
     */
    get accountIdConstructor() {
        if (this._accountIdConstructor == null) {
            throw new Error(
                "Cache.accountIdConstructor was used before it was set",
            );
        }

        return this._accountIdConstructor;
    }

    /**
     * @param {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>} delegateContractId
     */
    setDelegateContractId(delegateContractId) {
        this._delegateContractId = delegateContractId;
    }

    /**
     * @returns {FromProtobufKeyFuncT<HieroProto.proto.IContractID, ContractId>}
     */
    get delegateContractId() {
        if (this._delegateContractId == null) {
            throw new Error(
                "Cache.delegateContractId was used before it was set",
            );
        }

        return this._delegateContractId;
    }

    /**
     * @param {FromProtobufKeyFuncT<Uint8Array, EvmAddress>} evmAddress
     */
    setEvmAddress(evmAddress) {
        this._evmAddress = evmAddress;
    }

    /**
     * @returns {FromProtobufKeyFuncT<Uint8Array, EvmAddress>}
     */
    get evmAddress() {
        if (this._evmAddress == null) {
            throw new Error("Cache.evmAddress was used before it was set");
        }

        return this._evmAddress;
    }

    /**
     * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataLegacyFromBytes
     */
    setEthereumTransactionDataLegacyFromBytes(
        ethereumTransactionDataLegacyFromBytes,
    ) {
        this._ethereumTransactionDataLegacyFromBytes =
            ethereumTransactionDataLegacyFromBytes;
    }

    /**
     * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
     */
    get ethereumTransactionDataLegacyFromBytes() {
        if (this._ethereumTransactionDataLegacyFromBytes == null) {
            throw new Error(
                "Cache.ethereumTransactionDataLegacyFromBytes was used before it was set",
            );
        }

        return this._ethereumTransactionDataLegacyFromBytes;
    }

    /**
     * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataEip1559FromBytes
     */
    setEthereumTransactionDataEip1559FromBytes(
        ethereumTransactionDataEip1559FromBytes,
    ) {
        this._ethereumTransactionDataEip1559FromBytes =
            ethereumTransactionDataEip1559FromBytes;
    }

    /**
     * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
     */
    get ethereumTransactionDataEip1559FromBytes() {
        if (this._ethereumTransactionDataEip1559FromBytes == null) {
            throw new Error(
                "Cache.ethereumTransactionDataEip1559FromBytes was used before it was set",
            );
        }

        return this._ethereumTransactionDataEip1559FromBytes;
    }

    /**
     * @param {((bytes: Uint8Array) => EthereumTransactionData)} ethereumTransactionDataEip2930FromBytes
     */
    setEthereumTransactionDataEip2930FromBytes(
        ethereumTransactionDataEip2930FromBytes,
    ) {
        this._ethereumTransactionDataEip2930FromBytes =
            ethereumTransactionDataEip2930FromBytes;
    }

    /**
     * @returns {((bytes: Uint8Array) => EthereumTransactionData)}
     */
    get ethereumTransactionDataEip2930FromBytes() {
        if (this._ethereumTransactionDataEip2930FromBytes == null) {
            throw new Error(
                "Cache.ethereumTransactionDataEip2930FromBytes was used before it was set",
            );
        }

        return this._ethereumTransactionDataEip2930FromBytes;
    }

    /**
     * @param {(() => TransactionReceiptQuery)} transactionReceiptQueryConstructor
     */
    setTransactionReceiptQueryConstructor(transactionReceiptQueryConstructor) {
        this._transactionReceiptQueryConstructor =
            transactionReceiptQueryConstructor;
    }

    /**
     * @returns {(() => TransactionReceiptQuery)}
     */
    get transactionReceiptQueryConstructor() {
        if (this._transactionReceiptQueryConstructor == null) {
            throw new Error(
                "Cache.transactionReceiptQueryConstructor was used before it was set",
            );
        }

        return this._transactionReceiptQueryConstructor;
    }

    /**
     * @param {(() => TransactionRecordQuery)} transactionRecordQueryConstructor
     */
    setTransactionRecordQueryConstructor(transactionRecordQueryConstructor) {
        this._transactionRecordQueryConstructor =
            transactionRecordQueryConstructor;
    }

    /**
     * @returns {(() => TransactionRecordQuery)}
     */
    get transactionRecordQueryConstructor() {
        if (this._transactionRecordQueryConstructor == null) {
            throw new Error(
                "Cache.transactionRecordQueryConstructor was used before it was set",
            );
        }

        return this._transactionRecordQueryConstructor;
    }

    /**
     * @param {() => AddressBookQuery} addressBookQueryConstructor
     */
    setAddressBookQueryConstructor(addressBookQueryConstructor) {
        this._addressBookQueryConstructor = addressBookQueryConstructor;
    }

    /**
     * @returns {() => AddressBookQuery}
     */
    get addressBookQueryConstructor() {
        if (this._addressBookQueryConstructor == null) {
            throw new Error(
                "Cache.addressBookQueryConstructor was used before it was set",
            );
        }

        return this._addressBookQueryConstructor;
    }
}

/**
 * This variable is strictly designed to prevent cyclic dependencies.
 */
const CACHE = new Cache();

export default CACHE;
// Filename: src/Duration.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IDuration} HieroProto.proto.IDuration
 */

/**
 * A duration type.
 *
 * The main point of this tyope is for encapsulating the `[to|from]Protobuf()` implementations
 */
export default class Duration {
    /**
     * @param {Long | number} seconds
     */
    constructor(seconds) {
        /**
         * @readonly
         * @type {Long}
         */
        this.seconds =
            seconds instanceof Long ? seconds : Long.fromNumber(seconds);

        Object.freeze(this);
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IDuration}
     */
    _toProtobuf() {
        return {
            seconds: this.seconds,
        };
    }

    /**
     * @internal
     * @param {HieroProto.proto.IDuration} duration
     * @returns {Duration}
     */
    static _fromProtobuf(duration) {
        return new Duration(/** @type {Long} */ (duration.seconds));
    }
}
// Filename: src/EntityIdHelper.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import * as hex from "./encoding/hex.js";
import BadEntityIdError from "./BadEntityIdError.js";
import * as util from "./util.js";
import base32 from "./base32.js";
import * as HieroProto from "@hashgraph/proto";
import PublicKey from "./PublicKey.js";
import { arrayify } from "@ethersproject/bytes";

/**
 * @typedef {import("./client/Client.js").default<*, *>} Client
 */

/**
 * @typedef {object} IEntityId
 * @property {number | Long} num
 * @property {(number | Long)=} shard
 * @property {(number | Long)=} realm
 */

/**
 * @typedef {object} IEntityIdResult
 * @property {Long} shard
 * @property {Long} realm
 * @property {Long} num
 */

/**
 * @typedef {object} IEntityIdParts
 * @property {string?} shard
 * @property {string?} realm
 * @property {string} numOrHex
 * @property {string?} checksum
 */

/**
 * @typedef {object} IEntityIdResultWithChecksum
 * @property {Long} shard
 * @property {Long} realm
 * @property {Long} num
 * @property {string | null} checksum
 */

const regex =
    /"^(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))(?:-([a-z]{5}))?$/;

/**
 * This regex supports entity IDs
 *  - as stand alone nubmers
 *  - as shard.realm.num
 *  - as shard.realm.hex
 *  - can optionally provide checksum for any of the above
 */
const ENTITY_ID_REGEX = /^(\d+)(?:\.(\d+)\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;

/**
 * This method is called by most entity ID constructors. It's purpose is to
 * deduplicate the constuctors.
 *
 * @param {number | Long | IEntityId} props
 * @param {(number | null | Long)=} realmOrNull
 * @param {(number | null | Long)=} numOrNull
 * @returns {IEntityIdResult}
 */
export function constructor(props, realmOrNull, numOrNull) {
    // Make sure either both the second and third parameter are
    // set or not set; we shouldn't have one set, but the other not set.
    //
    //NOSONAR
    if (
        (realmOrNull == null && numOrNull != null) ||
        (realmOrNull != null && numOrNull == null)
    ) {
        throw new Error("invalid entity ID");
    }

    // If the first parameter is a number then we need to convert the
    // first, second, and third parameters into numbers. Otherwise,
    // we should look at the fields `shard`, `realm`, and `num` on
    // `props`
    const [shard, realm, num] =
        typeof props === "number" || Long.isLong(props)
            ? [
                  numOrNull != null
                      ? Long.fromValue(/** @type {Long | number} */ (props))
                      : Long.ZERO,
                  realmOrNull != null ? Long.fromValue(realmOrNull) : Long.ZERO,
                  numOrNull != null
                      ? Long.fromValue(numOrNull)
                      : Long.fromValue(/** @type {Long | number} */ (props)),
              ]
            : [
                  props.shard != null ? Long.fromValue(props.shard) : Long.ZERO,
                  props.realm != null ? Long.fromValue(props.realm) : Long.ZERO,
                  Long.fromValue(props.num),
              ];

    // Make sure none of the numbers are negative
    if (shard.isNegative() || realm.isNegative() || num.isNegative()) {
        throw new Error("negative numbers are not allowed in IDs");
    }

    return {
        shard,
        realm,
        num,
    };
}

/**
 * A simple comparison function for comparing entity IDs
 *
 * @param {[Long, Long, Long]} a
 * @param {[Long, Long, Long]} b
 * @returns {number}
 */
export function compare(a, b) {
    let comparison = a[0].compare(b[0]);
    if (comparison != 0) {
        return comparison;
    }

    comparison = a[1].compare(b[1]);
    if (comparison != 0) {
        return comparison;
    }

    return a[2].compare(b[2]);
}

/**
 * This type is part of the entity ID checksums feature which
 * is responsible for checking if an entity ID was created on
 * the same ledger ID as the client is currently using.
 *
 * @typedef {object} ParseAddressResult
 * @property {number} status
 * @property {Long} [num1]
 * @property {Long} [num2]
 * @property {Long} [num3]
 * @property {string} [correctChecksum]
 * @property {string} [givenChecksum]
 * @property {string} [noChecksumFormat]
 * @property {string} [withChecksumFormat]
 */

/**
 * @param {string} text
 * @returns {IEntityIdParts}
 */
export function fromStringSplitter(text) {
    const match = ENTITY_ID_REGEX.exec(text);

    if (match == null) {
        throw new Error(`failed to parse entity id: ${text}`);
    }

    if (match[2] == null && match[3] == null) {
        return {
            shard: "0",
            realm: "0",
            numOrHex: match[1],
            checksum: match[4],
        };
    } else {
        return {
            shard: match[1],
            realm: match[2],
            numOrHex: match[3],
            checksum: match[4],
        };
    }
}

/**
 * @param {string} text
 * @returns {IEntityIdResultWithChecksum}
 */
export function fromString(text) {
    const result = fromStringSplitter(text);

    if (
        Number.isNaN(result.shard) ||
        Number.isNaN(result.realm) ||
        Number.isNaN(result.numOrHex)
    ) {
        throw new Error("invalid format for entity ID");
    }

    return {
        shard: result.shard != null ? Long.fromString(result.shard) : Long.ZERO,
        realm: result.realm != null ? Long.fromString(result.realm) : Long.ZERO,
        num: Long.fromString(result.numOrHex),
        checksum: result.checksum,
    };
}

/**
 * Return the shard, realm, and num from a solidity address.
 *
 * Solidity addresses are 20 bytes long and hex encoded, where the first 4
 * bytes represent the shard, the next 8 bytes represent the realm, and
 * the last 8 bytes represent the num. All in Big Endian format
 *
 * @param {string} address
 * @returns {[Long, Long, Long]}
 */
export function fromSolidityAddress(address) {
    const addr = address.startsWith("0x")
        ? hex.decode(address.slice(2))
        : hex.decode(address);

    if (addr.length !== 20) {
        throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${address.length}`);
    }

    const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);
    const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));
    const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));

    return [shard, realm, num];
}

/**
 * Convert shard, realm, and num into a solidity address.
 *
 * See `fromSolidityAddress()` for more documentation.
 *
 * @param {[Long,Long,Long] | [number,number,number]} address
 * @returns {string}
 */
export function toSolidityAddress(address) {
    const buffer = new Uint8Array(20);
    const view = util.safeView(buffer);
    const [shard, realm, num] = address;

    view.setUint32(0, util.convertToNumber(shard));
    view.setUint32(8, util.convertToNumber(realm));
    view.setUint32(16, util.convertToNumber(num));

    return hex.encode(buffer);
}

/**
 * Parse the address string addr and return an object with the results (8 fields).
 * The first four fields are numbers, which could be implemented as signed 32 bit
 * integers, and the last four are strings.
 *
 *   status;  //the status of the parsed address
 *            //   0 = syntax error
 *            //   1 = an invalid with-checksum address (bad checksum)
 *            //   2 = a valid no-checksum address
 *            //   3 = a valid with-checksum address
 *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed
 *   num2;
 *   num3;
 *   correctchecksum;    //the correct checksum
 *   givenChecksum;      //the checksum in the address that was parsed
 *   noChecksumFormat;   //the address in no-checksum format
 *   withChecksumFormat; //the address in with-checksum format
 *
 * @param {Uint8Array} ledgerId
 * @param {string} addr
 * @returns {ParseAddressResult}
 */
export function _parseAddress(ledgerId, addr) {
    let match = regex.exec(addr);
    if (match === null) {
        let result = { status: 0 }; // When status == 0, the rest of the fields should be ignored
        return result;
    }
    let a = [
        Long.fromString(match[1]),
        Long.fromString(match[2]),
        Long.fromString(match[3]),
    ];
    let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;
    let c = _checksum(ledgerId, ad);
    let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //NOSONAR
    return {
        status: s,
        num1: a[0],
        num2: a[1],
        num3: a[2],
        givenChecksum: match[4],
        correctChecksum: c,
        noChecksumFormat: ad,
        withChecksumFormat: `${ad}-${c}`,
    };
}

/**
 * Given an address like "0.0.123", return a checksum like "laujm"
 *
 * @param {Uint8Array} ledgerId
 * @param {string} addr
 * @returns {string}
 */
export function _checksum(ledgerId, addr) {
    let answer = "";
    let d = []; // Digits with 10 for ".", so if addr == "0.0.123" then d == [0, 10, 0, 10, 1, 2, 3]
    let s0 = 0; // Sum of even positions (mod 11)
    let s1 = 0; // Sum of odd positions (mod 11)
    let s = 0; // Weighted sum of all positions (mod p3)
    let sh = 0; // Hash of the ledger ID
    let c = 0; // The checksum, as a single number
    const p3 = 26 * 26 * 26; // 3 digits in base 26
    const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26
    const ascii_a = "a".charCodeAt(0); // 97
    const m = 1000003; // Min prime greater than a million. Used for the final permutation.
    const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.

    let h = new Uint8Array(ledgerId.length + 6);
    h.set(ledgerId, 0);
    h.set([0, 0, 0, 0, 0, 0], ledgerId.length);
    for (let i = 0; i < addr.length; i++) {
        //NOSONAR
        d.push(addr[i] === "." ? 10 : parseInt(addr[i], 10));
    }
    for (let i = 0; i < d.length; i++) {
        s = (w * s + d[i]) % p3;
        if (i % 2 === 0) {
            s0 = (s0 + d[i]) % 11;
        } else {
            s1 = (s1 + d[i]) % 11;
        }
    }
    for (let i = 0; i < h.length; i++) {
        sh = (w * sh + h[i]) % p5;
    }
    c = ((((addr.length % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
    c = (c * m) % p5;

    for (let i = 0; i < 5; i++) {
        answer = String.fromCharCode(ascii_a + (c % 26)) + answer;
        c /= 26;
    }

    return answer;
}

/**
 * Validate an entity ID checksum against a client
 *
 * @param {Long} shard
 * @param {Long} realm
 * @param {Long} num
 * @param {string | null} checksum
 * @param {Client} client
 */
export function validateChecksum(shard, realm, num, checksum, client) {
    if (client._network._ledgerId == null || checksum == null) {
        return;
    }

    const expectedChecksum = _checksum(
        client._network._ledgerId._ledgerId,
        `${shard.toString()}.${realm.toString()}.${num.toString()}`,
    );

    if (checksum != expectedChecksum) {
        throw new BadEntityIdError(
            shard,
            realm,
            num,
            checksum,
            expectedChecksum,
        );
    }
}

/**
 * Stringify the entity ID with a checksum.
 *
 * @param {string} string
 * @param {Client} client
 * @returns {string}
 */
export function toStringWithChecksum(string, client) {
    if (client == null) {
        throw new Error("client cannot be null");
    }

    if (client._network._ledgerId == null) {
        throw new Error(
            "cannot calculate checksum with a client that does not contain a recognzied ledger ID",
        );
    }

    const checksum = _checksum(client._network._ledgerId._ledgerId, string);

    return `${string}-${checksum}`;
}

/**
 * Append Buffers.
 * @param {Uint8Array} buffer1
 * @param {Uint8Array} buffer2
 * @returns {Uint8Array}
 */
function appendBuffer(buffer1, buffer2) {
    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
    tmp.set(new Uint8Array(buffer1), 0);
    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
    return tmp;
}

/**
 * Convert bytes to hex string.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function toHexString(bytes) {
    var s = "0x";
    bytes.forEach(function (byte) {
        s += ("0" + (byte & 0xff).toString(16)).slice(-2);
    });
    return s;
}

/**
 * Deserialize the alias to public key.
 * Alias is created from ed25519 or ECDSASecp256k1 types of accounts. If hollow account is used, the alias is created from evm address.
 * For hollow accounts, please use aliasToEvmAddress.
 *
 * @param {string} alias
 * @returns {PublicKey | null}
 */
export function aliasToPublicKey(alias) {
    const bytes = base32.decode(alias);
    if (!bytes) {
        return null;
    }
    let key;
    try {
        key = HieroProto.proto.Key.decode(bytes);
    } catch (e) {
        throw new Error(
            "The alias is created with hollow account. Please use aliasToEvmAddress!",
        );
    }

    if (key.ed25519 != null && key.ed25519.byteLength > 0) {
        return PublicKey.fromBytes(key.ed25519);
    }

    if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
        return PublicKey.fromBytes(key.ECDSASecp256k1);
    }

    return null;
}

/**
 * Deserialize the alias to evm address.
 * Alias is created from hollow account.
 * For ed25519 or ECDSASecp256k1 accounts, please use aliasToPublicKey.
 *
 * @param {string} alias
 * @returns {string | null}
 */
export function aliasToEvmAddress(alias) {
    const bytes = base32.decode(alias);
    if (!bytes) {
        return null;
    }
    try {
        HieroProto.proto.Key.decode(bytes);
        throw new Error(
            "The alias is created with ed25519 or ECDSASecp256k1 account. Please use aliasToPublicKey!",
        );
    } catch (e) {
        return toHexString(bytes);
    }
}

/**
 * Serialize the public key to alias.
 * Alias is created from ed25519 or ECDSASecp256k1 types of accounts. If hollow account is used, the alias is created from evm address.
 *
 * @param {string | PublicKey} publicKey
 * @returns {string | null}
 */
export function publicKeyToAlias(publicKey) {
    if (
        typeof publicKey === "string" &&
        ((publicKey.startsWith("0x") && publicKey.length == 42) ||
            publicKey.length == 40)
    ) {
        if (!publicKey.startsWith("0x")) {
            publicKey = `0x${publicKey}`;
        }

        const bytes = arrayify(publicKey);
        if (!bytes) {
            return null;
        }
        return base32.encode(bytes);
    }

    const publicKeyRaw =
        typeof publicKey === "string"
            ? PublicKey.fromString(publicKey)
            : publicKey;
    let publicKeyHex = publicKeyRaw.toStringRaw();
    let leadingHex = "";

    if (publicKeyRaw._key._type === "secp256k1") {
        leadingHex = "0x3A21"; // LEADING BYTES FROM PROTOBUFS
    }

    if (publicKeyRaw._key._type === "ED25519") {
        leadingHex = "0x1220"; // LEADING BYTES FROM PROTOBUFS
    }

    if (!publicKeyHex.startsWith("0x")) {
        publicKeyHex = `0x${publicKeyHex}`;
    }

    const leadingBytes = arrayify(leadingHex);
    const publicKeyBytes = arrayify(publicKeyHex);
    const publicKeyInBytes = appendBuffer(leadingBytes, publicKeyBytes);
    const alias = base32.encode(publicKeyInBytes);
    return alias;
}
// Filename: src/EthereumFlow.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "./Hbar.js";
import EthereumTransaction from "./EthereumTransaction.js";
import EthereumTransactionData from "./EthereumTransactionData.js";
import FileCreateTransaction from "./file/FileCreateTransaction.js";
import FileAppendTransaction from "./file/FileAppendTransaction.js";
import * as hex from "./encoding/hex.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IEthereumTransactionBody} HieroProto.proto.IEthereumTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./file/FileId.js").default} FileId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./client/Client.js").default<*, *>} Client
 * @typedef {import("./Timestamp.js").default} Timestamp
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("long")} Long
 */

/**
 * Create a new Hedera™ transaction wrapped ethereum transaction.
 */
export default class EthereumFlow {
    /**
     * @param {object} [props]
     * @param {Uint8Array} [props.ethereumData]
     * @param {FileId} [props.callData]
     * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]
     */
    constructor(props = {}) {
        /**
         * @private
         * @type {?EthereumTransactionData}
         */
        this._ethereumData = null;

        /**
         * @private
         * @type {?FileId}
         */
        this._callDataFileId = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._maxGasAllowance = null;

        if (props.ethereumData != null) {
            this.setEthereumData(props.ethereumData);
        }

        if (props.maxGasAllowance != null) {
            this.setMaxGasAllowanceHbar(props.maxGasAllowance);
        }

        this._maxChunks = null;
    }

    /**
     * @returns {number | null}
     */
    get maxChunks() {
        return this._maxChunks;
    }

    /**
     * @param {number} maxChunks
     * @returns {this}
     */
    setMaxChunks(maxChunks) {
        this._maxChunks = maxChunks;
        return this;
    }

    /**
     * @returns {?EthereumTransactionData}
     */
    get ethereumData() {
        return this._ethereumData;
    }

    /**
     * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
     * unless the callData field is set.
     *
     * @param {EthereumTransactionData | Uint8Array} ethereumData
     * @returns {this}
     */
    setEthereumData(ethereumData) {
        this._ethereumData =
            ethereumData instanceof Uint8Array
                ? EthereumTransactionData.fromBytes(ethereumData)
                : ethereumData;
        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get maxGasAllowance() {
        return this._maxGasAllowance;
    }

    /**
     * @deprecated - use masGasAllowanceHbar instead.
     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
     * @returns {this}
     */
    setMaxGasAllowance(maxGasAllowance) {
        return this.setMaxGasAllowanceHbar(maxGasAllowance);
    }

    /**
     * The maximum amount, in tinybars, that the payer of the hedera transaction
     * is willing to pay to complete the transaction.
     *
     * Ordinarily the account with the ECDSA alias corresponding to the public
     * key that is extracted from the ethereum_data signature is responsible for
     * fees that result from the execution of the transaction. If that amount of
     * authorized fees is not sufficient then the payer of the transaction can be
     * charged, up to but not exceeding this amount. If the ethereum_data
     * transaction authorized an amount that was insufficient then the payer will
     * only be charged the amount needed to make up the difference. If the gas
     * price in the transaction was set to zero then the payer will be assessed
     * the entire fee.
     *
     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
     * @returns {this}
     */
    setMaxGasAllowanceHbar(maxGasAllowance) {
        this._maxGasAllowance =
            maxGasAllowance instanceof Hbar
                ? maxGasAllowance
                : new Hbar(maxGasAllowance);
        return this;
    }

    /**
     * @template {Channel} ChannelT
     * @template {MirrorChannel} MirrorChannelT
     * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client) {
        if (this._ethereumData == null) {
            throw new Error(
                "cannot submit ethereum transaction with no ethereum data",
            );
        }

        const ethereumTransaction = new EthereumTransaction();
        const ethereumTransactionDataBytes = this._ethereumData.toBytes();

        if (this._maxGasAllowance != null) {
            ethereumTransaction.setMaxGasAllowanceHbar(this._maxGasAllowance);
        }

        if (this._callDataFileId != null) {
            if (this._ethereumData.callData.length === 0) {
                throw new Error(
                    "call data file ID provided, but ethereum data already contains call data",
                );
            }

            ethereumTransaction
                .setEthereumData(ethereumTransactionDataBytes)
                .setCallDataFileId(this._callDataFileId);
        } else if (ethereumTransactionDataBytes.length <= 5120) {
            ethereumTransaction.setEthereumData(ethereumTransactionDataBytes);
        } else {
            const fileId = await createFile(
                this._ethereumData.callData,
                client,
                this._maxChunks,
            );

            this._ethereumData.callData = new Uint8Array();

            ethereumTransaction
                .setEthereumData(this._ethereumData.toBytes())
                .setCallDataFileId(fileId);
        }

        return ethereumTransaction.execute(client);
    }
}

/**
 * @template {Channel} ChannelT
 * @template {MirrorChannel} MirrorChannelT
 * @param {Uint8Array} callData
 * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
 * @param {?number} maxChunks
 * @returns {Promise<FileId>}
 */
async function createFile(callData, client, maxChunks) {
    const hexedCallData = hex.encode(callData);

    const fileId = /** @type {FileId} */ (
        (
            await (
                await new FileCreateTransaction()
                    .setContents(hexedCallData.substring(0, 4096))
                    .setKeys(
                        client.operatorPublicKey
                            ? [client.operatorPublicKey]
                            : [],
                    )
                    .execute(client)
            ).getReceipt(client)
        ).fileId
    );

    if (callData.length > 4096) {
        let fileAppendTransaction = new FileAppendTransaction()
            .setFileId(fileId)
            .setContents(hexedCallData.substring(4096, hexedCallData.length));
        if (maxChunks != null) {
            fileAppendTransaction.setMaxChunks(maxChunks);
        }

        await (await fileAppendTransaction.execute(client)).getReceipt(client);
    }

    return fileId;
}
// Filename: src/EthereumTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "./Hbar.js";
import FileId from "./file/FileId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "./transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IEthereumTransactionBody} HieroProto.proto.IEthereumTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./client/Client.js").default<*, *>} Client
 * @typedef {import("./Timestamp.js").default} Timestamp
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("long")} Long
 */

/**
 * Create a new Hedera™ transaction wrapped ethereum transaction.
 */
export default class EthereumTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Uint8Array} [props.ethereumData]
     * @param {FileId} [props.callData]
     * @param {FileId} [props.callDataFileId]
     * @param {number | string | Long | BigNumber | Hbar} [props.maxGasAllowance]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._ethereumData = null;

        /**
         * @private
         * @type {?FileId}
         */
        this._callDataFileId = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._maxGasAllowance = null;

        if (props.ethereumData != null) {
            this.setEthereumData(props.ethereumData);
        }

        if (props.callData != null) {
            this.setCallDataFileId(props.callData);
        }

        if (props.callDataFileId != null) {
            this.setCallDataFileId(props.callDataFileId);
        }

        if (props.maxGasAllowance != null) {
            this.setMaxGasAllowanceHbar(props.maxGasAllowance);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {EthereumTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const transaction =
            /** @type {HieroProto.proto.IEthereumTransactionBody} */ (
                body.ethereumTransaction
            );

        return Transaction._fromProtobufTransactions(
            new EthereumTransaction({
                ethereumData:
                    transaction.ethereumData != null
                        ? transaction.ethereumData
                        : undefined,
                callData:
                    transaction.callData != null
                        ? FileId._fromProtobuf(transaction.callData)
                        : undefined,
                maxGasAllowance:
                    transaction.maxGasAllowance != null
                        ? Hbar.fromTinybars(transaction.maxGasAllowance)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?(Uint8Array | FileId)}
     */
    get ethereumData() {
        return this._ethereumData;
    }

    /**
     * The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
     * unless the callData field is set.
     *
     * @param {Uint8Array} ethereumData
     * @returns {this}
     */
    setEthereumData(ethereumData) {
        this._requireNotFrozen();
        this._ethereumData = ethereumData;
        return this;
    }

    /**
     * @deprecated - Use `callDataFileId` instead
     * @returns {?FileId}
     */
    get callData() {
        return this.callDataFileId;
    }

    /**
     * @deprecated - Use `setCallDataFileId()` instead
     *
     * For large transactions (for example contract create) this is the callData
     * of the callData. The data in the callData will be re-written with
     * the callData element as a zero length string with the original contents in
     * the referenced file at time of execution. The callData will need to be
     * "rehydrated" with the callData for signature validation to pass.
     * @param {FileId} callDataFileId
     * @returns {this}
     */
    setCallData(callDataFileId) {
        return this.setCallDataFileId(callDataFileId);
    }

    /**
     * @returns {?FileId}
     */
    get callDataFileId() {
        return this._callDataFileId;
    }

    /**
     * For large transactions (for example contract create) this is the callData
     * of the callData. The data in the callData will be re-written with
     * the callData element as a zero length string with the original contents in
     * the referenced file at time of execution. The callData will need to be
     * "rehydrated" with the callData for signature validation to pass.
     *
     * @param {FileId} callDataFileId
     * @returns {this}
     */
    setCallDataFileId(callDataFileId) {
        this._requireNotFrozen();
        this._callDataFileId = callDataFileId;
        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get maxGasAllowance() {
        return this._maxGasAllowance;
    }

    /**
     * @deprecated -- use setMaxGasAllowanceHbar instead
     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
     * @returns {this}
     */
    setMaxGasAllowance(maxGasAllowance) {
        return this.setMaxGasAllowanceHbar(maxGasAllowance);
    }

    /**
     * The maximum amount, in tinybars, that the payer of the hedera transaction
     * is willing to pay to complete the transaction.
     *
     * Ordinarily the account with the ECDSA alias corresponding to the public
     * key that is extracted from the ethereum_data signature is responsible for
     * fees that result from the execution of the transaction. If that amount of
     * authorized fees is not sufficient then the payer of the transaction can be
     * charged, up to but not exceeding this amount. If the ethereum_data
     * transaction authorized an amount that was insufficient then the payer will
     * only be charged the amount needed to make up the difference. If the gas
     * price in the transaction was set to zero then the payer will be assessed
     * the entire fee.
     *
     * @param {number | string | Long | BigNumber | Hbar} maxGasAllowance
     * @returns {this}
     */
    setMaxGasAllowanceHbar(maxGasAllowance) {
        this._requireNotFrozen();
        this._maxGasAllowance =
            maxGasAllowance instanceof Hbar
                ? maxGasAllowance
                : new Hbar(maxGasAllowance);
        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (
            this._ethereumData != null &&
            this._ethereumData instanceof FileId
        ) {
            this._ethereumData.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.callEthereum(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "ethereumTransaction";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IEthereumTransactionBody}
     */
    _makeTransactionData() {
        return {
            ethereumData: this._ethereumData,
            callData:
                this._callDataFileId != null
                    ? this._callDataFileId._toProtobuf()
                    : null,
            maxGasAllowance:
                this._maxGasAllowance != null
                    ? this._maxGasAllowance.toTinybars()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("./Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `EthereumTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "ethereumTransaction",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    EthereumTransaction._fromProtobuf,
);
// Filename: src/EthereumTransactionData.js
import CACHE from "./Cache.js";

/**
 * Represents the base class for Ethereum transaction data.
 * This class provides the foundation for different types of Ethereum transactions
 * including Legacy, EIP-1559, and EIP-2930 transactions.
 */
export default class EthereumTransactionData {
    /**
     * @protected
     * @param {object} props
     * @param {Uint8Array} props.callData
     */
    constructor(props) {
        this.callData = props.callData;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {EthereumTransactionData}
     */
    static fromBytes(bytes) {
        if (bytes.length === 0) {
            throw new Error("empty bytes");
        }

        switch (bytes[0]) {
            case 1:
                return CACHE.ethereumTransactionDataEip2930FromBytes(bytes);
            case 2:
                return CACHE.ethereumTransactionDataEip1559FromBytes(bytes);
            default:
                return CACHE.ethereumTransactionDataLegacyFromBytes(bytes);
        }
    }

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        throw new Error("not implemented");
    }

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * @returns {string}
     */
    toString() {
        throw new Error("not implemented");
    }

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * @returns {{[key: string]: any}}
     */
    toJSON() {
        throw new Error("not implemented");
    }
}
// Filename: src/EthereumTransactionDataEip1559.js
import * as rlp from "@ethersproject/rlp";
import * as hex from "./encoding/hex.js";
import EthereumTransactionData from "./EthereumTransactionData.js";
import CACHE from "./Cache.js";

/**
 * @typedef {object} EthereumTransactionDataEip1559JSON
 * @property {string} chainId
 * @property {string} nonce
 * @property {string} maxPriorityGas
 * @property {string} maxGas
 * @property {string} gasLimit
 * @property {string} to
 * @property {string} value
 * @property {string} callData
 * @property {string[]} accessList
 * @property {string} recId
 * @property {string} r
 * @property {string} s
 */

export default class EthereumTransactionDataEip1559 extends EthereumTransactionData {
    /**
     * @private
     * @param {object} props
     * @param {Uint8Array} props.chainId
     * @param {Uint8Array} props.nonce
     * @param {Uint8Array} props.maxPriorityGas
     * @param {Uint8Array} props.maxGas
     * @param {Uint8Array} props.gasLimit
     * @param {Uint8Array} props.to
     * @param {Uint8Array} props.value
     * @param {Uint8Array} props.callData
     * @param {Uint8Array[]} props.accessList
     * @param {Uint8Array} props.recId
     * @param {Uint8Array} props.r
     * @param {Uint8Array} props.s
     */
    constructor(props) {
        super(props);

        this.chainId = props.chainId;
        this.nonce = props.nonce;
        this.maxPriorityGas = props.maxPriorityGas;
        this.maxGas = props.maxGas;
        this.gasLimit = props.gasLimit;
        this.to = props.to;
        this.value = props.value;
        this.accessList = props.accessList;
        this.recId = props.recId;
        this.r = props.r;
        this.s = props.s;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {EthereumTransactionData}
     */
    static fromBytes(bytes) {
        if (bytes.length === 0) {
            throw new Error("empty bytes");
        }

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const decoded = /** @type {string[]} */ (rlp.decode(bytes.subarray(1)));

        if (!Array.isArray(decoded)) {
            throw new Error("ethereum data is not a list");
        }

        if (decoded.length != 12) {
            throw new Error("invalid ethereum transaction data");
        }

        // TODO
        return new EthereumTransactionDataEip1559({
            chainId: hex.decode(/** @type {string} */ (decoded[0])),
            nonce: hex.decode(/** @type {string} */ (decoded[1])),
            maxPriorityGas: hex.decode(/** @type {string} */ (decoded[2])),
            maxGas: hex.decode(/** @type {string} */ (decoded[3])),
            gasLimit: hex.decode(/** @type {string} */ (decoded[4])),
            to: hex.decode(/** @type {string} */ (decoded[5])),
            value: hex.decode(/** @type {string} */ (decoded[6])),
            callData: hex.decode(/** @type {string} */ (decoded[7])),
            // @ts-ignore
            accessList: /** @type {string[]} */ (decoded[8]).map((v) =>
                hex.decode(v),
            ),
            recId: hex.decode(/** @type {string} */ (decoded[9])),
            r: hex.decode(/** @type {string} */ (decoded[10])),
            s: hex.decode(/** @type {string} */ (decoded[11])),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const encoded = rlp.encode([
            this.chainId,
            this.nonce,
            this.maxPriorityGas,
            this.maxGas,
            this.gasLimit,
            this.to,
            this.value,
            this.callData,
            this.accessList,
            this.recId,
            this.r,
            this.s,
        ]);
        return hex.decode("02" + encoded.substring(2));
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON(), null, 2);
    }

    /**
     * @returns {EthereumTransactionDataEip1559JSON}
     */
    toJSON() {
        return {
            chainId: hex.encode(this.chainId),
            nonce: hex.encode(this.nonce),
            maxPriorityGas: hex.encode(this.maxPriorityGas),
            maxGas: hex.encode(this.maxGas),
            gasLimit: hex.encode(this.gasLimit),
            to: hex.encode(this.to),
            value: hex.encode(this.value),
            callData: hex.encode(this.callData),
            accessList: this.accessList.map((v) => hex.encode(v)),
            recId: hex.encode(this.recId),
            r: hex.encode(this.r),
            s: hex.encode(this.s),
        };
    }
}

CACHE.setEthereumTransactionDataEip1559FromBytes((bytes) =>
    EthereumTransactionDataEip1559.fromBytes(bytes),
);
// Filename: src/EthereumTransactionDataEip2930.js
import * as rlp from "@ethersproject/rlp";
import * as hex from "./encoding/hex.js";
import EthereumTransactionData from "./EthereumTransactionData.js";
import CACHE from "./Cache.js";

/**
 * @typedef {object} EthereumTransactionDataEip2930JSON
 * @property {string} chainId
 * @property {string} nonce
 * @property {string} gasPrice
 * @property {string} gasLimit
 * @property {string} to
 * @property {string} value
 * @property {string} callData
 * @property {string[]} accessList
 * @property {string} recId
 * @property {string} r
 * @property {string} s
 */

export default class EthereumTransactionDataEip2930 extends EthereumTransactionData {
    /**
     * @private
     * @param {object} props
     * @param {Uint8Array} props.chainId
     * @param {Uint8Array} props.nonce
     * @param {Uint8Array} props.gasPrice
     * @param {Uint8Array} props.gasLimit
     * @param {Uint8Array} props.to
     * @param {Uint8Array} props.value
     * @param {Uint8Array} props.callData
     * @param {Uint8Array[]} props.accessList
     * @param {Uint8Array} props.recId
     * @param {Uint8Array} props.r
     * @param {Uint8Array} props.s
     */
    constructor(props) {
        super(props);

        this.chainId = props.chainId;
        this.nonce = props.nonce;
        this.gasPrice = props.gasPrice;
        this.gasLimit = props.gasLimit;
        this.to = props.to;
        this.value = props.value;
        this.accessList = props.accessList;
        this.recId = props.recId;
        this.r = props.r;
        this.s = props.s;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {EthereumTransactionData}
     */
    static fromBytes(bytes) {
        if (bytes.length === 0) {
            throw new Error("empty bytes");
        }

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const decoded = /** @type {string[]} */ (rlp.decode(bytes.subarray(1)));

        if (!Array.isArray(decoded)) {
            throw new Error("ethereum data is not a list");
        }

        if (decoded.length !== 11) {
            throw new Error("invalid ethereum transaction data");
        }

        // TODO
        return new EthereumTransactionDataEip2930({
            chainId: hex.decode(/** @type {string} */ (decoded[0])),
            nonce: hex.decode(/** @type {string} */ (decoded[1])),
            gasPrice: hex.decode(/** @type {string} */ (decoded[2])),
            gasLimit: hex.decode(/** @type {string} */ (decoded[3])),
            to: hex.decode(/** @type {string} */ (decoded[4])),
            value: hex.decode(/** @type {string} */ (decoded[5])),
            callData: hex.decode(/** @type {string} */ (decoded[6])),
            // @ts-ignore
            accessList: /** @type {string[]} */ (decoded[7]).map((v) =>
                hex.decode(v),
            ),
            recId: hex.decode(/** @type {string} */ (decoded[8])),
            r: hex.decode(/** @type {string} */ (decoded[9])),
            s: hex.decode(/** @type {string} */ (decoded[10])),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        const encoded = rlp.encode([
            this.chainId,
            this.nonce,
            this.gasPrice,
            this.gasLimit,
            this.to,
            this.value,
            this.callData,
            this.accessList,
            this.recId,
            this.r,
            this.s,
        ]);
        return hex.decode("01" + encoded.substring(2));
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON(), null, 2);
    }

    /**
     * @returns {EthereumTransactionDataEip2930JSON}
     */
    toJSON() {
        return {
            chainId: hex.encode(this.chainId),
            nonce: hex.encode(this.nonce),
            gasPrice: hex.encode(this.gasPrice),
            gasLimit: hex.encode(this.gasLimit),
            to: hex.encode(this.to),
            value: hex.encode(this.value),
            callData: hex.encode(this.callData),
            accessList: this.accessList.map((v) => hex.encode(v)),
            recId: hex.encode(this.recId),
            r: hex.encode(this.r),
            s: hex.encode(this.s),
        };
    }
}

CACHE.setEthereumTransactionDataEip2930FromBytes((bytes) =>
    EthereumTransactionDataEip2930.fromBytes(bytes),
);
// Filename: src/EthereumTransactionDataLegacy.js
import * as rlp from "@ethersproject/rlp";
import * as hex from "./encoding/hex.js";
import EthereumTransactionData from "./EthereumTransactionData.js";
import CACHE from "./Cache.js";

/**
 * @typedef {object} EthereumTransactionDataLegacyJSON
 * @property {string} nonce
 * @property {string} gasPrice
 * @property {string} gasLimit
 * @property {string} to
 * @property {string} value
 * @property {string} callData
 * @property {string} v
 * @property {string} r
 * @property {string} s
 */

export default class EthereumTransactionDataLegacy extends EthereumTransactionData {
    /**
     * @private
     * @param {object} props
     * @param {Uint8Array} props.nonce
     * @param {Uint8Array} props.gasPrice
     * @param {Uint8Array} props.gasLimit
     * @param {Uint8Array} props.to
     * @param {Uint8Array} props.value
     * @param {Uint8Array} props.callData
     * @param {Uint8Array} props.v
     * @param {Uint8Array} props.r
     * @param {Uint8Array} props.s
     */
    constructor(props) {
        super(props);

        this.nonce = props.nonce;
        this.gasPrice = props.gasPrice;
        this.gasLimit = props.gasLimit;
        this.to = props.to;
        this.value = props.value;
        this.v = props.v;
        this.r = props.r;
        this.s = props.s;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {EthereumTransactionData}
     */
    static fromBytes(bytes) {
        if (bytes.length === 0) {
            throw new Error("empty bytes");
        }

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const decoded = /** @type {string[]} */ (rlp.decode(bytes));

        if (decoded.length != 9) {
            throw new Error("invalid ethereum transaction data");
        }

        return new EthereumTransactionDataLegacy({
            nonce: hex.decode(/** @type {string} */ (decoded[0])),
            gasPrice: hex.decode(/** @type {string} */ (decoded[1])),
            gasLimit: hex.decode(/** @type {string} */ (decoded[2])),
            to: hex.decode(/** @type {string} */ (decoded[3])),
            value: hex.decode(/** @type {string} */ (decoded[4])),
            callData: hex.decode(/** @type {string} */ (decoded[5])),
            v: hex.decode(/** @type {string} */ (decoded[6])),
            r: hex.decode(/** @type {string} */ (decoded[7])),
            s: hex.decode(/** @type {string} */ (decoded[8])),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return hex.decode(
            rlp.encode([
                this.nonce,
                this.gasPrice,
                this.gasLimit,
                this.to,
                this.value,
                this.callData,
                this.v,
                this.r,
                this.s,
            ]),
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON(), null, 2);
    }

    /**
     * @returns {EthereumTransactionDataLegacyJSON}
     */
    toJSON() {
        return {
            nonce: hex.encode(this.nonce),
            gasPrice: hex.encode(this.gasPrice),
            gasLimit: hex.encode(this.gasLimit),
            to: hex.encode(this.to),
            value: hex.encode(this.value),
            callData: hex.encode(this.callData),
            v: hex.encode(this.v),
            r: hex.encode(this.r),
            s: hex.encode(this.s),
        };
    }
}

CACHE.setEthereumTransactionDataLegacyFromBytes((bytes) =>
    EthereumTransactionDataLegacy.fromBytes(bytes),
);
// Filename: src/EvmAddress.js
// SPDX-License-Identifier: Apache-2.0

import Key from "./Key.js";
import * as hex from "./encoding/hex.js";
import { arrayEqual } from "./util.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 */

/**
 * @typedef {import("./client/Client.js").default<*, *>} Client
 */

/**
 *  Represents an Ethereum Virtual Machine (EVM) address.
 * This class extends the Key class and provides functionality for handling EVM addresses.
 */
export default class EvmAddress extends Key {
    /**
     * @internal
     * @param {Uint8Array} bytes
     */
    constructor(bytes) {
        super();
        this._bytes = bytes;
    }

    /**
     * @param {string} text
     * @returns {EvmAddress}
     */
    static fromString(text) {
        return new EvmAddress(hex.decode(text));
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {EvmAddress}
     */
    static fromBytes(bytes) {
        return new EvmAddress(bytes);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._bytes;
    }

    /**
     * @returns {string}
     */
    toString() {
        return hex.encode(this._bytes);
    }

    /**
     * @param {EvmAddress} other
     * @returns {boolean}
     */
    equals(other) {
        return arrayEqual(this._bytes, other._bytes);
    }
}
// Filename: src/ExchangeRate.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";

/**
 * @typedef {object} ExchangeRateJSON
 * @property {number} hbars
 * @property {number} cents
 * @property {Date} expirationTime
 * @property {number} exchangeRateInCents
 */

/**
 * Represents an exchange rate between hbars and cents (USD).
 * This class provides functionality for handling and converting exchange rates
 * between Hedera's native HBAR currency and US cents.
 */
export default class ExchangeRate {
    /**
     * @private
     * @param {object} props
     * @param {number} props.hbars
     * @param {number} props.cents
     * @param {Date} props.expirationTime
     */
    constructor(props) {
        /**
         * Denotes Hbar equivalent to cents (USD)
         *
         * @readonly
         * @type {number}
         */
        this.hbars = props.hbars;

        /**
         * Denotes cents (USD) equivalent to Hbar
         *
         * @readonly
         * @type {number}
         */
        this.cents = props.cents;

        /**
         * Expiration time of this exchange rate
         *
         * @readonly
         * @type {Date}
         */
        this.expirationTime = props.expirationTime;

        /**
         * Calculated exchange rate
         *
         * @readonly
         * @type {number}
         */
        this.exchangeRateInCents = props.cents / props.hbars;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {import("@hashgraph/proto").proto.IExchangeRate} rate
     * @returns {ExchangeRate}
     */
    static _fromProtobuf(rate) {
        return new ExchangeRate({
            hbars: /** @type {number} */ (rate.hbarEquiv),
            cents: /** @type {number} */ (rate.centEquiv),
            expirationTime: new Date(
                rate.expirationTime != null
                    ? rate.expirationTime.seconds != null
                        ? Long.isLong(rate.expirationTime.seconds)
                            ? rate.expirationTime.seconds.toInt() * 1000
                            : rate.expirationTime.seconds
                        : 0
                    : 0,
            ),
        });
    }

    /**
     * @internal
     * @returns {import("@hashgraph/proto").proto.IExchangeRate}
     */
    _toProtobuf() {
        return {
            hbarEquiv: this.hbars,
            centEquiv: this.cents,
            expirationTime: {
                seconds: Long.fromNumber(
                    Math.trunc(this.expirationTime.getTime() / 1000),
                ),
            },
        };
    }

    /**
     * @returns {ExchangeRateJSON}
     */
    toJSON() {
        return {
            hbars: this.hbars,
            cents: this.cents,
            expirationTime: this.expirationTime,
            exchangeRateInCents: this.exchangeRateInCents,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
// Filename: src/ExchangeRates.js
// SPDX-License-Identifier: Apache-2.0

import ExchangeRate from "./ExchangeRate.js";
import * as HieroProto from "@hashgraph/proto";

const { proto } = HieroProto;

/**
 *  Represents a pair of exchange rates for HBAR to USD cents conversion.
 * Contains both the current exchange rate and the next exchange rate that will take effect.
 */
export default class ExchangeRates {
    /**
     * @private
     * @param {object} props
     * @param {ExchangeRate} props.currentRate
     * @param {ExchangeRate} props.nextRate
     */
    constructor(props) {
        /**
         * @readonly
         */
        this.currentRate = props.currentRate;

        /**
         * @readonly
         */
        this.nextRate = props.nextRate;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IExchangeRateSet} rateSet
     * @returns {ExchangeRates}
     */
    static _fromProtobuf(rateSet) {
        return new ExchangeRates({
            currentRate: ExchangeRate._fromProtobuf(
                /** @type {HieroProto.proto.IExchangeRate} */ (
                    rateSet.currentRate
                ),
            ),
            nextRate: ExchangeRate._fromProtobuf(
                /** @type {HieroProto.proto.IExchangeRate} */ (
                    rateSet.nextRate
                ),
            ),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IExchangeRateSet}
     */
    _toProtobuf() {
        return {
            currentRate: this.currentRate._toProtobuf(),
            nextRate: this.nextRate._toProtobuf(),
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ExchangeRates}
     */
    static fromBytes(bytes) {
        return ExchangeRates._fromProtobuf(proto.ExchangeRateSet.decode(bytes));
    }
}
// Filename: src/Executable.js
// SPDX-License-Identifier: Apache-2.0

import GrpcServiceError from "./grpc/GrpcServiceError.js";
import GrpcStatus from "./grpc/GrpcStatus.js";
import List from "./transaction/List.js";
import * as hex from "./encoding/hex.js";
import HttpError from "./http/HttpError.js";
import Status from "./Status.js";
import MaxAttemptsOrTimeoutError from "./MaxAttemptsOrTimeoutError.js";

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("./Signer.js").Signer} Signer
 * @typedef {import("./PublicKey.js").default} PublicKey
 * @typedef {import("./logger/Logger.js").default} Logger
 */

/**
 * @enum {string}
 */
export const ExecutionState = {
    Finished: "Finished",
    Retry: "Retry",
    Error: "Error",
};

export const RST_STREAM = /\brst[^0-9a-zA-Z]stream\b/i;
export const DEFAULT_MAX_ATTEMPTS = 10;

/**
 * @abstract
 * @internal
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 */
export default class Executable {
    constructor() {
        /**
         * The number of times we can retry the grpc call
         *
         * @internal
         * @type {number}
         */
        this._maxAttempts = DEFAULT_MAX_ATTEMPTS;

        /**
         * List of node account IDs for each transaction that has been
         * built.
         *
         * @internal
         * @type {List<AccountId>}
         */
        this._nodeAccountIds = new List();

        /**
         * List of the transaction node account IDs to check if
         * the node account ID of the request is in the list
         *
         * @protected
         * @type {Array<string>}
         */
        this.transactionNodeIds = [];

        /**
         * @internal
         */
        this._signOnDemand = false;

        /**
         * This is the request's min backoff
         *
         * @internal
         * @type {number | null}
         */
        this._minBackoff = null;

        /**
         * This is the request's max backoff
         *
         * @internal
         * @type {number}
         */
        this._maxBackoff = 8000;

        /**
         * The operator that was used to execute this request.
         * The reason we save the operator in the request is because of the signing on
         * demand feature. This feature requires us to sign new request on each attempt
         * meaning if a client with an operator was used we'd need to sign with the operator
         * on each attempt.
         *
         * @internal
         * @type {ClientOperator | null}
         */
        this._operator = null;

        /**
         * The complete timeout for running the `execute()` method
         *
         * @internal
         * @type {number | null}
         */
        this._requestTimeout = null;

        /**
         * The grpc request timeout aka deadline.
         *
         * The reason we have this is because there were times that consensus nodes held the grpc
         * connection, but didn't return anything; not error nor regular response. This resulted
         * in some weird behavior in the SDKs. To fix this we've added a grpc deadline to prevent
         * nodes from stalling the executing of a request.
         *
         * @internal
         * @type {number | null}
         */
        this._grpcDeadline = null;

        /**
         * Logger
         *
         * @protected
         * @type {Logger | null}
         */
        this._logger = null;
    }

    /**
     * Get the list of node account IDs on the request. If no nodes are set, then null is returned.
     * The reasoning for this is simply "legacy behavior".
     *
     * @returns {?AccountId[]}
     */
    get nodeAccountIds() {
        if (this._nodeAccountIds.isEmpty) {
            return null;
        } else {
            this._nodeAccountIds.setLocked();
            return this._nodeAccountIds.list;
        }
    }

    /**
     * Set the node account IDs on the request
     *
     * @param {AccountId[]} nodeIds
     * @returns {this}
     */
    setNodeAccountIds(nodeIds) {
        // Set the node account IDs, and lock the list. This will require `execute`
        // to use these nodes instead of random nodes from the network.
        this._nodeAccountIds.setList(nodeIds).setLocked();
        return this;
    }

    /**
     * @deprecated
     * @returns {number}
     */
    get maxRetries() {
        console.warn("Deprecated: use maxAttempts instead");
        return this.maxAttempts;
    }

    /**
     * @param {number} maxRetries
     * @returns {this}
     */
    setMaxRetries(maxRetries) {
        console.warn("Deprecated: use setMaxAttempts() instead");
        return this.setMaxAttempts(maxRetries);
    }

    /**
     * Get the max attempts on the request
     *
     * @returns {number}
     */
    get maxAttempts() {
        return this._maxAttempts;
    }

    /**
     * Set the max attempts on the request
     *
     * @param {number} maxAttempts
     * @returns {this}
     */
    setMaxAttempts(maxAttempts) {
        this._maxAttempts = maxAttempts;

        return this;
    }

    /**
     * Get the grpc deadline
     *
     * @returns {?number}
     */
    get grpcDeadline() {
        return this._grpcDeadline;
    }

    /**
     * Set the grpc deadline
     *
     * @param {number} grpcDeadline
     * @returns {this}
     */
    setGrpcDeadline(grpcDeadline) {
        this._grpcDeadline = grpcDeadline;

        return this;
    }

    /**
     * Set the min backoff for the request
     *
     * @param {number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        // Honestly we shouldn't be checking for null since that should be TypeScript's job.
        // Also verify that min backoff is not greater than max backoff.
        if (minBackoff == null) {
            throw new Error("minBackoff cannot be null.");
        } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {
            throw new Error("minBackoff cannot be larger than maxBackoff.");
        }
        this._minBackoff = minBackoff;
        return this;
    }

    /**
     * Get the min backoff
     *
     * @returns {number | null}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * Set the max backoff for the request
     *
     * @param {?number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        // Honestly we shouldn't be checking for null since that should be TypeScript's job.
        // Also verify that max backoff is not less than min backoff.
        if (maxBackoff == null) {
            throw new Error("maxBackoff cannot be null.");
        } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {
            throw new Error("maxBackoff cannot be smaller than minBackoff.");
        }
        this._maxBackoff = maxBackoff;
        return this;
    }

    /**
     * Get the max backoff
     *
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * This method is responsible for doing any work before the executing process begins.
     * For paid queries this will result in executing a cost query, for transactions this
     * will make sure we save the operator and sign any requests that need to be signed
     * in case signing on demand is disabled.
     *
     * @abstract
     * @protected
     * @param {import("./client/Client.js").default<Channel, *>} client
     * @returns {Promise<void>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _beforeExecute(client) {
        throw new Error("not implemented");
    }

    /**
     * Create a protobuf request which will be passed into the `_execute()` method
     *
     * @abstract
     * @protected
     * @returns {Promise<RequestT>}
     */
    _makeRequestAsync() {
        throw new Error("not implemented");
    }

    /**
     * This name is a bit wrong now, but the purpose of this method is to map the
     * request and response into an error. This method will only be called when
     * `_shouldRetry` returned `ExecutionState.Error`
     *
     * @abstract
     * @internal
     * @param {RequestT} request
     * @param {ResponseT} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response, nodeId) {
        throw new Error("not implemented");
    }

    /**
     * Map the request, response, and the node account ID used for this attempt into a response.
     * This method will only be called when `_shouldRetry` returned `ExecutionState.Finished`
     *
     * @abstract
     * @protected
     * @param {ResponseT} response
     * @param {AccountId} nodeAccountId
     * @param {RequestT} request
     * @returns {Promise<OutputT>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        throw new Error("not implemented");
    }

    /**
     * Perform a single grpc call with the given request. Each request has it's own
     * required service so we just pass in channel, and it'$ the request's responsiblity
     * to use the right service and call the right grpc method.
     *
     * @abstract
     * @internal
     * @param {Channel} channel
     * @param {RequestT} request
     * @returns {Promise<ResponseT>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _execute(channel, request) {
        throw new Error("not implemented");
    }

    /**
     * Return the current transaction ID for the request. All requests which are
     * use the same transaction ID for each node, but the catch is that `Transaction`
     * implicitly supports chunked transactions. Meaning there could be multiple
     * transaction IDs stored in the request, and a different transaction ID will be used
     * on subsequent calls to `execute()`
     *
     * FIXME: This method can most likely be removed, although some further inspection
     * is required.
     *
     * @abstract
     * @protected
     * @returns {TransactionId}
     */
    _getTransactionId() {
        throw new Error("not implemented");
    }

    /**
     * Return the log ID for this particular request
     *
     * Log IDs are simply a string constructed to make it easy to track each request's
     * execution even when mulitple requests are executing in parallel. Typically, this
     * method returns the format of `[<request type>.<timestamp of the transaction ID>]`
     *
     * Maybe we should deduplicate this using ${this.consturtor.name}
     *
     * @abstract
     * @internal
     * @returns {string}
     */
    _getLogId() {
        throw new Error("not implemented");
    }

    /**
     * Serialize the request into bytes
     *
     * @abstract
     * @param {RequestT} request
     * @returns {Uint8Array}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _requestToBytes(request) {
        throw new Error("not implemented");
    }

    /**
     * Serialize the response into bytes
     *
     * @abstract
     * @param {ResponseT} response
     * @returns {Uint8Array}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _responseToBytes(response) {
        throw new Error("not implemented");
    }

    /**
     * Determine if we should continue the execution process, error, or finish.
     *
     * FIXME: This method should really be called something else. Initially it returned
     * a boolean so `shouldRetry` made sense, but now it returns an enum, so the name
     * no longer makes sense.
     *
     * @abstract
     * @protected
     * @param {RequestT} request
     * @param {ResponseT} response
     * @returns {[Status, ExecutionState]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        throw new Error("not implemented");
    }

    /**
     * Determine if we should error based on the gRPC status
     *
     * Unlike `shouldRetry` this method does in fact still return a boolean
     *
     * @protected
     * @param {Error} error
     * @returns {boolean}
     */
    _shouldRetryExceptionally(error) {
        if (error instanceof GrpcServiceError) {
            return (
                error.status._code === GrpcStatus.Timeout._code ||
                error.status._code === GrpcStatus.Unavailable._code ||
                error.status._code === GrpcStatus.ResourceExhausted._code ||
                error.status._code === GrpcStatus.GrpcWeb._code ||
                (error.status._code === GrpcStatus.Internal._code &&
                    RST_STREAM.test(error.message))
            );
        } else {
            // if we get to the 'else' statement, the 'error' is instanceof 'HttpError'
            // and in this case, we have to retry always
            return true;
        }
    }

    /**
     * A helper method for setting the operator on the request
     *
     * @internal
     * @param {AccountId} accountId
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    _setOperatorWith(accountId, publicKey, transactionSigner) {
        this._operator = {
            transactionSigner,
            accountId,
            publicKey,
        };
        return this;
    }

    /**
     * Execute this request using the signer
     *
     * This method is part of the signature providers feature
     * https://hips.hedera.com/hip/hip-338
     *
     * @param {Signer} signer
     * @returns {Promise<OutputT>}
     */
    async executeWithSigner(signer) {
        return signer.call(this);
    }

    /**
     * Execute the request using a client and an optional request timeout
     *
     * @template {Channel} ChannelT
     * @template {MirrorChannel} MirrorChannelT
     * @param {import("./client/Client.js").default<ChannelT, MirrorChannelT>} client
     * @param {number=} requestTimeout
     * @returns {Promise<OutputT>}
     */
    async execute(client, requestTimeout) {
        // we check if its local node then backoff mechanism should be disabled
        // and we increase the retry attempts
        const isLocalNode = client.network["127.0.0.1:50211"] != null;

        // If the logger on the request is not set, use the logger in client
        // (if set, otherwise do not use logger)
        this._logger =
            this._logger == null
                ? client._logger != null
                    ? client._logger
                    : null
                : this._logger;

        // If the request timeout is set on the request we'll prioritize that instead
        // of the parameter provided, and if the parameter isn't provided we'll
        // use the default request timeout on client
        if (this._requestTimeout == null) {
            this._requestTimeout =
                requestTimeout != null ? requestTimeout : client.requestTimeout;
        }

        // Some request need to perform additional requests before the executing
        // such as paid queries need to fetch the cost of the query before
        // finally executing the actual query.
        await this._beforeExecute(client);

        // If the max backoff on the request is not set, use the default value in client
        if (this._maxBackoff == null) {
            this._maxBackoff = client.maxBackoff;
        }

        // If the min backoff on the request is not set, use the default value in client
        if (this._minBackoff == null) {
            this._minBackoff = client.minBackoff;
        }

        // Save the start time to be used later with request timeout
        const startTime = Date.now();

        // Saves each error we get so when we err due to max attempts exceeded we'll have
        // the last error that was returned by the consensus node
        let persistentError = null;

        // If the max attempts on the request is not set, use the default value in client
        // If the default value in client is not set, use a default of 10.
        //
        // FIXME: current implementation is wrong, update to follow comment above.
        // ... existing code ...
        const LOCAL_NODE_ATTEMPTS = 1000;
        const maxAttempts = isLocalNode
            ? LOCAL_NODE_ATTEMPTS
            : (client._maxAttempts ?? this._maxAttempts);

        // Checks if has a valid nodes to which the TX can be sent
        if (this.transactionNodeIds.length) {
            const nodeAccountIds = this._nodeAccountIds.list.map((nodeId) =>
                nodeId.toString(),
            );

            const hasValidNodes = this.transactionNodeIds.some((nodeId) =>
                nodeAccountIds.includes(nodeId),
            );

            if (!hasValidNodes) {
                const displayNodeAccountIds =
                    nodeAccountIds.length > 2
                        ? `${nodeAccountIds.slice(0, 2).join(", ")} ...`
                        : nodeAccountIds.join(", ");
                const isSingleNode = nodeAccountIds.length === 1;

                throw new Error(
                    `Attempting to execute a transaction against node${isSingleNode ? "" : "s"} ${displayNodeAccountIds}, ` +
                        `which ${isSingleNode ? "is" : "are"} not included in the Client's node list. Please review your Client configuration.`,
                );
            }
        }

        // The retry loop
        for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
            // Determine if we've exceeded request timeout
            if (
                this._requestTimeout != null &&
                startTime + this._requestTimeout <= Date.now()
            ) {
                throw new MaxAttemptsOrTimeoutError(
                    `timeout exceeded`,
                    this._nodeAccountIds.isEmpty
                        ? "No node account ID set"
                        : this._nodeAccountIds.current.toString(),
                );
            }

            let nodeAccountId;
            let node;

            if (this._nodeAccountIds.isEmpty) {
                node = client._network.getNode();
                nodeAccountId = node.accountId;
                this._nodeAccountIds.setList([nodeAccountId]);
            } else {
                nodeAccountId = this._nodeAccountIds.current;
                node = client._network.getNode(nodeAccountId);
            }

            if (node == null) {
                throw new Error(
                    `NodeAccountId not recognized: ${nodeAccountId.toString()}`,
                );
            }

            if (this.transactionNodeIds.length) {
                const isNodeAccountIdValid = this.transactionNodeIds.includes(
                    nodeAccountId.toString(),
                );

                if (!isNodeAccountIdValid) {
                    console.error(
                        `Attempting to execute a transaction against node ${nodeAccountId.toString()}, which is not included in the Client's node list. Please review your Client configuration.`,
                    );

                    this._nodeAccountIds.advance();
                    continue;
                }
            }

            // Get the log ID for the request.
            const logId = this._getLogId();
            if (this._logger) {
                this._logger.debug(
                    `[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`,
                );
            }

            const channel = node.getChannel();
            const request = await this._makeRequestAsync();

            let response;

            if (!node.isHealthy()) {
                const isLastNode =
                    this._nodeAccountIds.index ===
                    this._nodeAccountIds.list.length - 1;

                if (isLastNode || this._nodeAccountIds.length <= 1) {
                    throw new Error(
                        `Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(", ")}`,
                    );
                }

                if (this._logger) {
                    this._logger.debug(
                        `[${logId}] Node is not healthy, trying the next node.`,
                    );
                }

                this._nodeAccountIds.advance();
                continue;
            }

            this._nodeAccountIds.advance();

            try {
                // Race the execution promise against the grpc timeout to prevent grpc connections
                // from blocking this request
                const promises = [];

                // If a grpc deadline is est, we should race it, otherwise the only thing in the
                // list of promises will be the execution promise.
                if (this._grpcDeadline != null) {
                    promises.push(
                        // eslint-disable-next-line ie11/no-loop-func
                        new Promise((_, reject) =>
                            setTimeout(
                                // eslint-disable-next-line ie11/no-loop-func
                                () =>
                                    reject(new Error("grpc deadline exceeded")),
                                /** @type {number=} */ (this._grpcDeadline),
                            ),
                        ),
                    );
                }
                if (this._logger) {
                    this._logger.trace(
                        `[${this._getLogId()}] sending protobuf ${hex.encode(
                            this._requestToBytes(request),
                        )}`,
                    );
                }

                promises.push(this._execute(channel, request));
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                response = /** @type {ResponseT} */ (
                    await Promise.race(promises)
                );
            } catch (err) {
                // If we received a grpc status error we need to determine if
                // we should retry on this error, or err from the request entirely.
                const error = GrpcServiceError._fromResponse(
                    /** @type {Error} */ (err),
                );

                // Save the error in case we retry
                persistentError = error;
                if (this._logger) {
                    this._logger.debug(
                        `[${logId}] received error ${JSON.stringify(error)}`,
                    );
                }

                if (
                    (error instanceof GrpcServiceError ||
                        error instanceof HttpError) &&
                    this._shouldRetryExceptionally(error) &&
                    attempt <= maxAttempts
                ) {
                    // Increase the backoff for the particular node and remove it from
                    // the healthy node list
                    if (this._logger) {
                        this._logger.debug(
                            `[${this._getLogId()}] node with accountId: ${node.accountId.toString()} and proxy IP: ${node.address.toString()} is unhealthy`,
                        );
                    }

                    client._network.increaseBackoff(node);
                    continue;
                }

                throw err;
            }
            if (this._logger) {
                this._logger.trace(
                    `[${this._getLogId()}] sending protobuf ${hex.encode(
                        this._responseToBytes(response),
                    )}`,
                );
            }

            // If we didn't receive an error we should decrease the current nodes backoff
            // in case it is a recovering node
            client._network.decreaseBackoff(node);

            // Determine what execution state we're in by the response
            // For transactions this would be as simple as checking the response status is `OK`
            // while for _most_ queries it would check if the response status is `SUCCESS`
            // The only odd balls are `TransactionReceiptQuery` and `TransactionRecordQuery`
            const [status, shouldRetry] = this._shouldRetry(request, response);
            if (
                status.toString() !== Status.Ok.toString() &&
                status.toString() !== Status.Success.toString()
            ) {
                persistentError = status;
            }

            // Determine by the executing state what we should do
            switch (shouldRetry) {
                case ExecutionState.Retry:
                    await delayForAttempt(
                        isLocalNode,
                        attempt,
                        this._minBackoff,
                        this._maxBackoff,
                    );
                    continue;
                case ExecutionState.Finished:
                    return this._mapResponse(response, nodeAccountId, request);
                case ExecutionState.Error:
                    throw this._mapStatusError(
                        request,
                        response,
                        nodeAccountId,
                    );
                default:
                    throw new Error(
                        "(BUG) non-exhaustive switch statement for `ExecutionState`",
                    );
            }
        }

        // We'll only get here if we've run out of attempts, so we return an error wrapping the
        // persistent error we saved before.

        throw new MaxAttemptsOrTimeoutError(
            `max attempts of ${maxAttempts.toString()} was reached for request with last error being: ${
                persistentError != null ? persistentError.toString() : ""
            }`,
            this._nodeAccountIds.current.toString(),
        );
    }

    /**
     * The current purpose of this method is to easily support signature providers since
     * signature providers need to serialize _any_ request into bytes. `Query` and `Transaction`
     * already implement `toBytes()` so it only made sense to make it available here too.
     *
     * @abstract
     * @returns {Uint8Array}
     */
    toBytes() {
        throw new Error("not implemented");
    }

    /**
     * Set logger
     *
     * @param {Logger} logger
     * @returns {this}
     */
    setLogger(logger) {
        this._logger = logger;
        return this;
    }

    /**
     * Get logger if set
     *
     * @returns {?Logger}
     */
    get logger() {
        return this._logger;
    }
}

/**
 * A simple function that returns a promise timeout for a specific period of time
 *
 * @param {boolean} isLocalNode
 * @param {number} attempt
 * @param {number} minBackoff
 * @param {number} maxBackoff
 * @returns {Promise<void>}
 */
function delayForAttempt(isLocalNode, attempt, minBackoff, maxBackoff) {
    if (isLocalNode) {
        return new Promise((resolve) => setTimeout(resolve, minBackoff));
    }

    // 0.1s, 0.2s, 0.4s, 0.8s, ...
    const ms = Math.min(
        Math.floor(minBackoff * Math.pow(2, attempt)),
        maxBackoff,
    );
    return new Promise((resolve) => setTimeout(resolve, ms));
}
// Filename: src/FeeComponents.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Long from "long";

/**
 * A set of values the nodes use in determining transaction and query fees, and
 * constants involved in fee calculations.
 */
export default class FeeComponents {
    /**
     * @param {object} [props]
     * @param {Long} [props.min]
     * @param {Long} [props.max]
     * @param {Long} [props.constant]
     * @param {Long} [props.transactionBandwidthByte]
     * @param {Long} [props.transactionVerification]
     * @param {Long} [props.transactionRamByteHour]
     * @param {Long} [props.transactionStorageByteHour]
     * @param {Long} [props.contractTransactionGas]
     * @param {Long} [props.transferVolumeHbar]
     * @param {Long} [props.responseMemoryByte]
     * @param {Long} [props.responseDiskByte]
     */
    constructor(props = {}) {
        /*
         * A minimum, the calculated fee must be greater than this value
         *
         * @type {Long}
         */
        this.min = props.min;

        /*
         * A maximum, the calculated fee must be less than this value
         *
         * @type {Long}
         */
        this.max = props.max;

        /*
         * A constant contribution to the fee
         *
         * @type {Long}
         */
        this.constant = props.constant;

        /*
         * The price of bandwidth consumed by a transaction, measured in bytes
         *
         * @type {Long}
         */
        this.transactionBandwidthByte = props.transactionBandwidthByte;

        /*
         * The price per signature verification for a transaction
         *
         * @type {Long}
         */
        this.transactionVerification = props.transactionVerification;

        /*
         * The price of RAM consumed by a transaction, measured in byte-hours
         *
         * @type {Long}
         */
        this.transactionRamByteHour = props.transactionRamByteHour;

        /*
         * The price of storage consumed by a transaction, measured in byte-hours
         *
         * @type {Long}
         */
        this.transactionStorageByteHour = props.transactionStorageByteHour;

        /*
         * The price of computation for a smart contract transaction, measured in gas
         *
         * @type {Long}
         */
        this.contractTransactionGas = props.contractTransactionGas;

        /*
         * The price per hbar transferred for a transfer
         *
         * @type {Long}
         */
        this.transferVolumeHbar = props.transferVolumeHbar;

        /*
         * The price of bandwidth for data retrieved from memory for a response, measured in bytes
         *
         * @type {Long}
         */
        this.responseMemoryByte = props.responseMemoryByte;

        /*
         * The price of bandwidth for data retrieved from disk for a response, measured in bytes
         *
         * @type {Long}
         */
        this.responseDiskByte = props.responseDiskByte;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FeeComponents}
     */
    static fromBytes(bytes) {
        return FeeComponents._fromProtobuf(
            HieroProto.proto.FeeComponents.decode(bytes),
        );
    }

    /**
     * @internal
     * @param {HieroProto.proto.IFeeComponents} feeComponents
     * @returns {FeeComponents}
     */
    static _fromProtobuf(feeComponents) {
        return new FeeComponents({
            min: feeComponents.min != null ? feeComponents.min : undefined,
            max: feeComponents.max != null ? feeComponents.max : undefined,
            constant:
                feeComponents.constant != null
                    ? feeComponents.constant
                    : undefined,
            transactionBandwidthByte:
                feeComponents.bpt != null ? feeComponents.bpt : undefined,
            transactionVerification:
                feeComponents.vpt != null ? feeComponents.vpt : undefined,
            transactionRamByteHour:
                feeComponents.rbh != null ? feeComponents.rbh : undefined,
            transactionStorageByteHour:
                feeComponents.sbh != null ? feeComponents.sbh : undefined,
            contractTransactionGas:
                feeComponents.gas != null ? feeComponents.gas : undefined,
            transferVolumeHbar:
                feeComponents.tv != null ? feeComponents.tv : undefined,
            responseMemoryByte:
                feeComponents.bpr != null ? feeComponents.bpr : undefined,
            responseDiskByte:
                feeComponents.sbpr != null ? feeComponents.sbpr : undefined,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IFeeComponents}
     */
    _toProtobuf() {
        return {
            min: this.min != null ? this.min : undefined,
            max: this.max != null ? this.max : undefined,
            constant: this.constant != null ? this.constant : undefined,
            bpt:
                this.transactionBandwidthByte != null
                    ? this.transactionBandwidthByte
                    : undefined,
            vpt:
                this.transactionVerification != null
                    ? this.transactionVerification
                    : undefined,
            rbh:
                this.transactionRamByteHour != null
                    ? this.transactionRamByteHour
                    : undefined,
            sbh:
                this.transactionStorageByteHour != null
                    ? this.transactionStorageByteHour
                    : undefined,
            gas:
                this.contractTransactionGas != null
                    ? this.contractTransactionGas
                    : undefined,
            tv:
                this.transferVolumeHbar != null
                    ? this.transferVolumeHbar
                    : undefined,
            bpr:
                this.responseMemoryByte != null
                    ? this.responseMemoryByte
                    : undefined,
            sbpr:
                this.responseDiskByte != null
                    ? this.responseDiskByte
                    : undefined,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.FeeComponents.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/FeeData.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import FeeComponents from "./FeeComponents.js";
import FeeDataType from "./FeeDataType.js";

/**
 * A total fee, in component amounts charged for a transaction.
 *
 * Total fees are composed of three sets of components.
 * - Node data, components that compensate the specific node that submitted
 *   the transaction.
 * - Network data, components that compensate the Hedera network for gossiping
 *   the transaction and determining the consensus timestamp.
 * - Service data, components that compensate the Hedera network for the ongoing
 *   maintenance and operation of the network, as well as ongoing development
 *   of network services.
 *
 * Fee components are recorded in thousandths of a tiny cent, and the network
 * exchange rate converts these to tinybar amounts, which are what the network
 * charges for transactions and what the network reports in the record stream.
 */
export default class FeeData {
    /**
     * @param {object} [props]
     * @param {FeeComponents} [props.nodedata]
     * @param {FeeComponents} [props.networkdata]
     * @param {FeeComponents} [props.servicedata]
     * @param {FeeDataType} [props.feeDataType]
     */
    constructor(props = {}) {
        /*
         * Fee paid to the submitting node
         *
         * @type {FeeComponents}
         */
        this.nodedata = props.nodedata;

        /*
         * Fee paid to the network for processing a transaction into consensus
         *
         * @type {FeeComponents}
         */
        this.networkdata = props.networkdata;

        /*
         * Fee paid to the network for providing the service associated with the transaction; for instance, storing a file
         *
         * @type {FeeComponents}
         */
        this.servicedata = props.servicedata;

        /*
         * SubType distinguishing between different types of FeeData, correlating to the same HederaFunctionality
         *
         * @type {SubType}
         */
        this.feeDataType = props.feeDataType;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FeeData}
     */
    static fromBytes(bytes) {
        return FeeData._fromProtobuf(HieroProto.proto.FeeData.decode(bytes));
    }

    /**
     * @internal
     * @param {HieroProto.proto.IFeeData} feeData
     * @returns {FeeData}
     */
    static _fromProtobuf(feeData) {
        return new FeeData({
            nodedata:
                feeData.nodedata != null
                    ? FeeComponents._fromProtobuf(feeData.nodedata)
                    : undefined,
            networkdata:
                feeData.networkdata != null
                    ? FeeComponents._fromProtobuf(feeData.networkdata)
                    : undefined,
            servicedata:
                feeData.servicedata != null
                    ? FeeComponents._fromProtobuf(feeData.servicedata)
                    : undefined,
            feeDataType:
                feeData.subType != null
                    ? FeeDataType._fromCode(feeData.subType)
                    : undefined,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IFeeData}
     */
    _toProtobuf() {
        return {
            nodedata:
                this.nodedata != null ? this.nodedata._toProtobuf() : undefined,

            networkdata:
                this.networkdata != null
                    ? this.networkdata._toProtobuf()
                    : undefined,

            servicedata:
                this.servicedata != null
                    ? this.servicedata._toProtobuf()
                    : undefined,

            subType:
                this.feeDataType != null
                    ? this.feeDataType.valueOf()
                    : undefined,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.FeeData.encode(this._toProtobuf()).finish();
    }
}
// Filename: src/FeeDataType.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.SubType} HieroProto.proto.SubType
 */

export default class FeeDataType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case FeeDataType.Default:
                return "DEFAULT";
            case FeeDataType.TokenFungibleCommon:
                return "TOKEN_FUNGIBLE_COMMON";
            case FeeDataType.TokenNonFungibleUnique:
                return "TOKEN_NON_FUNGIBLE_UNIQUE";
            case FeeDataType.TokenFungibleCommonWithCustomFees:
                return "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES";
            case FeeDataType.TokenNonFungibleUniqueWithCustomFees:
                return "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES";
            case FeeDataType.ScheduleCreateContractCall:
                return "SCHEDULE_CREATE_CONTRACT_CALL";
            case FeeDataType.TopicCreateWithCustomFees:
                return "TOPIC_CREATE_WITH_CUSTOM_FEES";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {FeeDataType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return FeeDataType.Default;
            case 1:
                return FeeDataType.TokenFungibleCommon;
            case 2:
                return FeeDataType.TokenNonFungibleUnique;
            case 3:
                return FeeDataType.TokenFungibleCommonWithCustomFees;
            case 4:
                return FeeDataType.TokenNonFungibleUniqueWithCustomFees;
            case 5:
                return FeeDataType.ScheduleCreateContractCall;
            case 6:
                return FeeDataType.TopicCreateWithCustomFees;
        }

        throw new Error(
            `(BUG) SubType.fromCode() does not handle code: ${code}`,
        );
    }

    /**
     * @returns {HieroProto.proto.SubType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * The resource prices have no special scope
 */
FeeDataType.Default = new FeeDataType(0);

/**
 * The resource prices are scoped to an operation on a fungible common token
 */
FeeDataType.TokenFungibleCommon = new FeeDataType(1);

/**
 * The resource prices are scoped to an operation on a non-fungible unique token
 */
FeeDataType.TokenNonFungibleUnique = new FeeDataType(2);

/**
 * The resource prices are scoped to an operation on a fungible common token with a custom fee schedule
 */
FeeDataType.TokenFungibleCommonWithCustomFees = new FeeDataType(3);

/**
 * The resource prices are scoped to an operation on a non-fungible unique token with a custom fee schedule
 */
FeeDataType.TokenNonFungibleUniqueWithCustomFees = new FeeDataType(4);

/**
 * The resource prices are scoped to a ScheduleCreate containing a ContractCall.
 */
FeeDataType.ScheduleCreateContractCall = new FeeDataType(5);

/**
 * The resource cost for the transaction type includes a TopicCreate
 * with custom fees.
 */
FeeDataType.TopicCreateWithCustomFees = new FeeDataType(6);
// Filename: src/FeeSchedule.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import TransactionFeeSchedule from "./TransactionFeeSchedule.js";
import Timestamp from "./Timestamp.js";

/**
 * A set of fee schedules covering all transaction types and query types, along
 * with a specific time at which this fee schedule will expire.
 */
export default class FeeSchedule {
    /**
     * @param {object} [props]
     * @param {TransactionFeeSchedule[]} [props.transactionFeeSchedule]
     * @param {Timestamp} [props.expirationTime]
     */
    constructor(props = {}) {
        /*
         * List of price coefficients for network resources
         *
         * @type {TransactionFeeSchedule}
         */
        this.transactionFeeSchedule = props.transactionFeeSchedule;

        /*
         * FeeSchedule expiry time
         *
         * @type {Timestamp}
         */
        this.expirationTime = props.expirationTime;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FeeSchedule}
     */
    static fromBytes(bytes) {
        return FeeSchedule._fromProtobuf(
            HieroProto.proto.FeeSchedule.decode(bytes),
        );
    }

    /**
     * @internal
     * @param {HieroProto.proto.IFeeSchedule} feeSchedule
     * @returns {FeeSchedule}
     */
    static _fromProtobuf(feeSchedule) {
        return new FeeSchedule({
            transactionFeeSchedule:
                feeSchedule.transactionFeeSchedule != null
                    ? feeSchedule.transactionFeeSchedule.map((schedule) =>
                          TransactionFeeSchedule._fromProtobuf(schedule),
                      )
                    : undefined,
            expirationTime:
                feeSchedule.expiryTime != null
                    ? Timestamp._fromProtobuf(feeSchedule.expiryTime)
                    : undefined,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IFeeSchedule}
     */
    _toProtobuf() {
        return {
            transactionFeeSchedule:
                this.transactionFeeSchedule != null
                    ? this.transactionFeeSchedule.map((transaction) =>
                          transaction._toProtobuf(),
                      )
                    : undefined,
            expiryTime:
                this.expirationTime != null
                    ? this.expirationTime._toProtobuf()
                    : undefined,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.FeeSchedule.encode(this._toProtobuf()).finish();
    }
}
// Filename: src/FeeSchedules.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import FeeSchedule from "./FeeSchedule.js";

/**
 * Represents a pair of fee schedules on the Hedera network - the currently active fee schedule
 * and the next upcoming fee schedule. This structure allows for transparent fee updates by making
 * future fee changes visible before they take effect.
 */
export default class FeeSchedules {
    /**
     * @param {object} [props]
     * @param {FeeSchedule} [props.currentFeeSchedule]
     * @param {FeeSchedule} [props.nextFeeSchedule]
     */
    constructor(props = {}) {
        /*
         * Contains current Fee Schedule
         *
         * @type {FeeSchedule}
         */
        this.current = props.currentFeeSchedule;

        /*
         * Contains next Fee Schedule
         *
         * @type {FeeSchedule}
         */
        this.next = props.nextFeeSchedule;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FeeSchedules}
     */
    static fromBytes(bytes) {
        return FeeSchedules._fromProtobuf(
            HieroProto.proto.CurrentAndNextFeeSchedule.decode(bytes),
        );
    }

    /**
     * @internal
     * @param {HieroProto.proto.ICurrentAndNextFeeSchedule} feeSchedules
     * @returns {FeeSchedules}
     */
    static _fromProtobuf(feeSchedules) {
        return new FeeSchedules({
            currentFeeSchedule:
                feeSchedules.currentFeeSchedule != null
                    ? FeeSchedule._fromProtobuf(feeSchedules.currentFeeSchedule)
                    : undefined,
            nextFeeSchedule:
                feeSchedules.nextFeeSchedule != null
                    ? FeeSchedule._fromProtobuf(feeSchedules.nextFeeSchedule)
                    : undefined,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ICurrentAndNextFeeSchedule}
     */
    _toProtobuf() {
        return {
            currentFeeSchedule:
                this.current != null ? this.current._toProtobuf() : undefined,
            nextFeeSchedule:
                this.next != null ? this.next._toProtobuf() : undefined,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.CurrentAndNextFeeSchedule.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/FreezeType.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.FreezeType} HieroProto.proto.FreezeType
 */

export default class FreezeType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case FreezeType.UnknownFreezeType:
                return "UNKNOWN_FREEZE_TYPE";
            case FreezeType.FreezeOnly:
                return "FREEZE_ONLY";
            case FreezeType.PrepareUpgrade:
                return "PREPARE_UPGRADE";
            case FreezeType.FreezeUpgrade:
                return "FREEZE_UPGRADE";
            case FreezeType.FreezeAbort:
                return "FREEZE_ABORT";
            case FreezeType.TelemetryUpgrade:
                return "TELEMETRY_UPGRADE";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {FreezeType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return FreezeType.UnknownFreezeType;
            case 1:
                return FreezeType.FreezeOnly;
            case 2:
                return FreezeType.PrepareUpgrade;
            case 3:
                return FreezeType.FreezeUpgrade;
            case 4:
                return FreezeType.FreezeAbort;
            case 5:
                return FreezeType.TelemetryUpgrade;
            default:
                throw new Error(
                    `(BUG) Status.fromCode() does not handle code: ${code}`,
                );
        }
    }

    /**
     * @returns {HieroProto.proto.FreezeType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * An (invalid) default value for this enum, to ensure the client explicitly sets
 * the intended type of freeze transaction.
 */
FreezeType.UnknownFreezeType = new FreezeType(0);

/**
 * Freezes the network at the specified time. The start_time field must be provided and
 * must reference a future time. Any values specified for the update_file and file_hash
 * fields will be ignored. This transaction does not perform any network changes or
 * upgrades and requires manual intervention to restart the network.
 */
FreezeType.FreezeOnly = new FreezeType(1);

/**
 * A non-freezing operation that initiates network wide preparation in advance of a
 * scheduled freeze upgrade. The update_file and file_hash fields must be provided and
 * valid. The start_time field may be omitted and any value present will be ignored.
 */
FreezeType.PrepareUpgrade = new FreezeType(2);

/**
 * Freezes the network at the specified time and performs the previously prepared
 * automatic upgrade across the entire network.
 */
FreezeType.FreezeUpgrade = new FreezeType(3);

/**
 * Aborts a pending network freeze operation.
 */
FreezeType.FreezeAbort = new FreezeType(4);

/**
 * Performs an immediate upgrade on auxilary services and containers providing
 * telemetry/metrics. Does not impact network operations.
 */
FreezeType.TelemetryUpgrade = new FreezeType(5);
// Filename: src/Hbar.js
// SPDX-License-Identifier: Apache-2.0

import BigNumber from "bignumber.js";
import { valueToLong } from "./long.js";
import HbarUnit from "./HbarUnit.js";

import Long from "long";

/**
 * @typedef {import("./long.js").LongObject} LongObject
 */

/**
 * Represents a quantity of hbar (ℏ), the native currency of the Hedera network.
 * Provides utilities for handling different hbar denominations and conversions.
 */
export default class Hbar {
    /**
     * @param {number | string | Long | LongObject | BigNumber} amount
     * @param {HbarUnit=} unit
     */
    constructor(amount, unit = HbarUnit.Hbar) {
        if (unit === HbarUnit.Tinybar) {
            this._valueInTinybar = valueToLong(amount);
        } else {
            /** @type {BigNumber} */
            let bigAmount;

            if (Long.isLong(amount)) {
                bigAmount = new BigNumber(amount.toString(10));
            } else if (
                BigNumber.isBigNumber(amount) ||
                typeof amount === "string" ||
                typeof amount === "number"
            ) {
                bigAmount = new BigNumber(amount);
            } else {
                bigAmount = new BigNumber(0);
            }

            /**
             * @type {BigNumber}
             */
            this._valueInTinybar = bigAmount.multipliedBy(unit._tinybar);
        }
        if (!this._valueInTinybar.isInteger()) {
            throw new Error("Hbar in tinybars contains decimals");
        }
    }

    /**
     * @param {number | Long | BigNumber} amount
     * @param {HbarUnit} unit
     * @returns {Hbar}
     */
    static from(amount, unit) {
        return new Hbar(amount, unit);
    }

    /**
     * @param {number | Long | string | BigNumber} amount
     * @returns {Hbar}
     */
    static fromTinybars(amount) {
        if (typeof amount === "string") {
            return this.fromString(amount, HbarUnit.Tinybar);
        }
        return new Hbar(amount, HbarUnit.Tinybar);
    }

    /**
     * @param {string} str
     * @param {HbarUnit=} unit
     * @returns {Hbar}
     */
    static fromString(str, unit = HbarUnit.Hbar) {
        const pattern = /^((?:\+|-)?\d+(?:\.\d+)?)(?: (tℏ|μℏ|mℏ|ℏ|kℏ|Mℏ|Gℏ))?$/;
        if (pattern.test(str)) {
            let [amount, symbol] = str.split(" ");
            if (symbol != null) {
                unit = HbarUnit.fromString(symbol);
            }
            return new Hbar(new BigNumber(amount), unit);
        } else {
            throw new Error("invalid argument provided");
        }
    }

    /**
     * @param {HbarUnit} unit
     * @returns {BigNumber}
     */
    to(unit) {
        return this._valueInTinybar.dividedBy(unit._tinybar);
    }

    /**
     * @returns {BigNumber}
     */
    toBigNumber() {
        return this.to(HbarUnit.Hbar);
    }

    /**
     * @returns {Long}
     */
    toTinybars() {
        return Long.fromValue(this._valueInTinybar.toFixed());
    }

    /**
     * @returns {Hbar}
     */
    negated() {
        return Hbar.fromTinybars(this._valueInTinybar.negated());
    }

    /**
     * @returns {boolean}
     */
    isNegative() {
        return this._valueInTinybar.isNegative();
    }

    /**
     * @param {HbarUnit=} unit
     * @returns {string}
     */
    toString(unit) {
        if (unit != null) {
            return `${this._valueInTinybar
                .dividedBy(unit._tinybar)
                .toString()} ${unit._symbol}`;
        }

        if (
            this._valueInTinybar.isLessThan(10000) &&
            this._valueInTinybar.isGreaterThan(-10000)
        ) {
            return `${this._valueInTinybar.toFixed()} ${
                HbarUnit.Tinybar._symbol
            }`;
        }

        return `${this.to(HbarUnit.Hbar).toString()} ${HbarUnit.Hbar._symbol}`;
    }
}
// Filename: src/HbarUnit.js
// SPDX-License-Identifier: Apache-2.0

import BigNumber from "bignumber.js";

/**
 * Represents a unit of HBAR currency measurement in the Hedera network.
 * Defines the various denominations of HBAR (tinybar, microbar, millibar, hbar, kilobar, megabar, gigabar)
 * and provides utilities for converting between these units. Each unit has a name, symbol, and conversion
 * rate to tinybar (the smallest unit of HBAR).
 */
export default class HbarUnit {
    /**
     * @internal
     * @param {string} name
     * @param {string} symbol
     * @param {BigNumber} tinybar
     */
    constructor(name, symbol, tinybar) {
        /**
         * @internal
         * @readonly
         */
        this._name = name;

        /**
         * @internal
         * @readonly
         */
        this._symbol = symbol;

        /**
         * @internal
         * @readonly
         */
        this._tinybar = tinybar;

        Object.freeze(this);
    }

    /**
     * @param {string} unit
     * @returns {HbarUnit}
     */
    static fromString(unit) {
        switch (unit) {
            case HbarUnit.Hbar._symbol:
                return HbarUnit.Hbar;
            case HbarUnit.Tinybar._symbol:
                return HbarUnit.Tinybar;
            case HbarUnit.Microbar._symbol:
                return HbarUnit.Microbar;
            case HbarUnit.Millibar._symbol:
                return HbarUnit.Millibar;
            case HbarUnit.Kilobar._symbol:
                return HbarUnit.Kilobar;
            case HbarUnit.Megabar._symbol:
                return HbarUnit.Megabar;
            case HbarUnit.Gigabar._symbol:
                return HbarUnit.Gigabar;
            default:
                throw new Error("Unknown unit.");
        }
    }
}

HbarUnit.Tinybar = new HbarUnit("tinybar", "tℏ", new BigNumber(1));

HbarUnit.Microbar = new HbarUnit("microbar", "μℏ", new BigNumber(100));

HbarUnit.Millibar = new HbarUnit("millibar", "mℏ", new BigNumber(100000));

HbarUnit.Hbar = new HbarUnit("hbar", "ℏ", new BigNumber("100000000"));

HbarUnit.Kilobar = new HbarUnit(
    "kilobar",
    "kℏ",
    new BigNumber(1000).multipliedBy(new BigNumber("100000000")),
);

HbarUnit.Megabar = new HbarUnit(
    "megabar",
    "Mℏ",
    new BigNumber(1000000).multipliedBy(new BigNumber("100000000")),
);

HbarUnit.Gigabar = new HbarUnit(
    "gigabar",
    "Gℏ",
    new BigNumber("1000000000").multipliedBy(new BigNumber("100000000")),
);
// Filename: src/Key.js
// SPDX-License-Identifier: Apache-2.0

import CACHE from "./Cache.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 */

export default class Key {
    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.IKey}
     */
    // eslint-disable-next-line jsdoc/require-returns-check
    _toProtobufKey() {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @param {HieroProto.proto.IKey} key
     * @returns {Key}
     */
    static _fromProtobufKey(key) {
        if (key.contractID != null) {
            return CACHE.contractId(key.contractID);
        }

        if (key.delegatableContractId != null) {
            return CACHE.delegateContractId(key.delegatableContractId);
        }

        if (key.ed25519 != null && key.ed25519.byteLength > 0) {
            return CACHE.publicKeyED25519(key.ed25519);
        }

        if (key.ECDSASecp256k1 != null && key.ECDSASecp256k1.byteLength > 0) {
            return CACHE.publicKeyECDSA(key.ECDSASecp256k1);
        }

        if (key.thresholdKey != null && key.thresholdKey.threshold != null) {
            return CACHE.thresholdKey(key.thresholdKey);
        }

        if (key.keyList != null) {
            return CACHE.keyList(key.keyList);
        }

        // @ts-ignore
        return null;

        /* throw new Error(
            `(BUG) keyFromProtobuf: not implemented key case: ${JSON.stringify(
                key
            )}`
        ); */
    }
}
// Filename: src/KeyList.js
// SPDX-License-Identifier: Apache-2.0

import Key from "./Key.js";
import CACHE from "./Cache.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 * @typedef {import("@hashgraph/proto").proto.IKeyList} HieroProto.proto.IKeyList
 * @typedef {import("@hashgraph/proto").proto.IThresholdKey} HieroProto.proto.IThresholdKey
 */

/**
 * A list of Keys (`Key`) with an optional threshold.
 */
export default class KeyList extends Key {
    /**
     * @param {?Key[]} [keys]
     * @param {?number} [threshold]
     */
    constructor(keys, threshold) {
        super();

        /**
         * @private
         * @type {Key[]}
         */
        // @ts-ignore
        if (keys == null) this._keys = [];
        //checks if the value for `keys` is passed as a single key
        //rather than a list that contains just one key
        else if (keys instanceof Key) this._keys = [keys];
        else this._keys = keys;

        /**
         * @type {?number}
         */
        this._threshold = threshold == null ? null : threshold;
    }

    /**
     * @param {Key[]} keys
     * @returns {KeyList}
     */
    static of(...keys) {
        return new KeyList(keys, null);
    }

    /**
     * @template T
     * @param {ArrayLike<Key>} arrayLike
     * @param {((key: Key) => Key)} [mapFn]
     * @param {T} [thisArg]
     * @returns {KeyList}
     */
    static from(arrayLike, mapFn, thisArg) {
        if (mapFn == null) {
            return new KeyList(Array.from(arrayLike));
        }

        return new KeyList(Array.from(arrayLike, mapFn, thisArg));
    }

    /**
     * @returns {?number}
     */
    get threshold() {
        return this._threshold;
    }

    /**
     * @param {number} threshold
     * @returns {this}
     */
    setThreshold(threshold) {
        this._threshold = threshold;
        return this;
    }

    /**
     * @param {Key[]} keys
     * @returns {number}
     */
    push(...keys) {
        return this._keys.push(...keys);
    }

    /**
     * @param {number} start
     * @param {number} deleteCount
     * @param {Key[]} items
     * @returns {KeyList}
     */
    splice(start, deleteCount, ...items) {
        return new KeyList(
            this._keys.splice(start, deleteCount, ...items),
            this.threshold,
        );
    }

    /**
     * @param {number=} start
     * @param {number=} end
     * @returns {KeyList}
     */
    slice(start, end) {
        return new KeyList(this._keys.slice(start, end), this.threshold);
    }

    /**
     * @returns {Iterator<Key>}
     */
    [Symbol.iterator]() {
        return this._keys[Symbol.iterator]();
    }

    /**
     * @returns {Key[]}
     */
    toArray() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this._keys.slice();
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify({
            threshold: this._threshold,
            keys: this._keys.toString(),
        });
    }

    /**
     * @returns {HieroProto.proto.IKey}
     */
    _toProtobufKey() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return
        const keys = this._keys.map((key) => key._toProtobufKey());

        if (this.threshold == null) {
            return { keyList: { keys } };
        } else {
            return {
                thresholdKey: {
                    threshold: this.threshold,
                    keys: { keys },
                },
            };
        }
    }

    /**
     * @param {HieroProto.proto.IKeyList} key
     * @returns {KeyList}
     */
    static __fromProtobufKeyList(key) {
        const keys = (key.keys != null ? key.keys : []).map((key) =>
            Key._fromProtobufKey(key),
        );
        return new KeyList(keys);
    }

    /**
     * @param {HieroProto.proto.IThresholdKey} key
     * @returns {KeyList}
     */
    static __fromProtobufThresoldKey(key) {
        const list = KeyList.__fromProtobufKeyList(
            key.keys != null ? key.keys : {},
        );
        list.setThreshold(key.threshold != null ? key.threshold : 0);
        return list;
    }
}

CACHE.setKeyList((key) => KeyList.__fromProtobufKeyList(key));
CACHE.setThresholdKey((key) => KeyList.__fromProtobufThresoldKey(key));
// Filename: src/LedgerId.js
// SPDX-License-Identifier: Apache-2.0

import * as hex from "./encoding/hex.js";

/**
 * Represents the ID of a network.
 */
export default class LedgerId {
    /**
     * @hideconstructor
     * @internal
     * @param {Uint8Array} ledgerId
     */
    constructor(ledgerId) {
        /**
         * @readonly
         * @type {Uint8Array}
         */
        this._ledgerId = ledgerId;

        Object.freeze(this);
    }

    /**
     * @param {string} ledgerId
     * @returns {LedgerId}
     */
    static fromString(ledgerId) {
        switch (ledgerId) {
            case NETNAMES[0]:
            case "0":
                return LedgerId.MAINNET;
            case NETNAMES[1]:
            case "1":
                return LedgerId.TESTNET;
            case NETNAMES[2]:
            case "2":
                return LedgerId.PREVIEWNET;
            case NETNAMES[3]:
            case "3":
                return LedgerId.LOCAL_NODE;
            default: {
                let ledgerIdDecoded = hex.decode(ledgerId);
                if (ledgerIdDecoded.length == 0 && ledgerId.length != 0) {
                    throw new Error("Default reached for fromString");
                } else {
                    return new LedgerId(ledgerIdDecoded);
                }
            }
        }
    }

    /**
     * If the ledger ID is a known value such as `[0]`, `[1]`, `[2]` this method
     * will instead return "mainnet", "testnet", or "previewnet", otherwise it will
     * hex encode the bytes.
     *
     * @returns {string}
     */
    toString() {
        if (this._ledgerId.length == 1) {
            switch (this._ledgerId[0]) {
                case 0:
                    return NETNAMES[0];
                case 1:
                    return NETNAMES[1];
                case 2:
                    return NETNAMES[2];
                case 3:
                    return NETNAMES[3];
                default:
                    return hex.encode(this._ledgerId);
            }
        } else {
            return hex.encode(this._ledgerId);
        }
    }

    /**
     * Using the UTF-8 byte representation of "mainnet", "testnet",
     * or "previewnet" is NOT supported.
     *
     * @param {Uint8Array} bytes
     * @returns {LedgerId}
     */
    static fromBytes(bytes) {
        return new LedgerId(bytes);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._ledgerId;
    }

    /**
     * @returns {boolean}
     */
    isMainnet() {
        return this.toString() == NETNAMES[0];
    }

    /**
     * @returns {boolean}
     */
    isTestnet() {
        return this.toString() == NETNAMES[1];
    }

    /**
     * @returns {boolean}
     */
    isPreviewnet() {
        return this.toString() == NETNAMES[2];
    }

    /**
     * @returns {boolean}
     */
    isLocalNode() {
        return this.toString() == NETNAMES[3];
    }
}

const NETNAMES = ["mainnet", "testnet", "previewnet", "local-node"];

LedgerId.MAINNET = new LedgerId(new Uint8Array([0]));

LedgerId.TESTNET = new LedgerId(new Uint8Array([1]));

LedgerId.PREVIEWNET = new LedgerId(new Uint8Array([2]));

LedgerId.LOCAL_NODE = new LedgerId(new Uint8Array([3]));
// Filename: src/LocalProvider.js
// SPDX-License-Identifier: Apache-2.0

import Client from "./client/NodeClient.js";
import AccountBalanceQuery from "./account/AccountBalanceQuery.js";
import AccountInfoQuery from "./account/AccountInfoQuery.js";
import AccountRecordsQuery from "./account/AccountRecordsQuery.js";
import TransactionReceiptQuery from "./transaction/TransactionReceiptQuery.js";

/**
 * @typedef {import("./Provider.js").Provider} Provider
 * @typedef {import("./LedgerId.js").default} LedgerId
 * @typedef {import("./Key.js").default} Key
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./account/AccountBalance.js").default} AccountBalance
 * @typedef {import("./account/AccountInfo.js").default} AccountInfo
 * @typedef {import("./logger/Logger.js").default} Logger
 */

/**
 * @template {any} O
 * @typedef {import("./query/Query.js").default<O>} Query<O>
 */

/**
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
 */

/**
 * @implements {Provider}
 */
export default class LocalProvider {
    /**
     * @param {object} props
     * @param {Client} [props.client]
     */
    constructor(props = {}) {
        if (props != null && props.client != null) {
            this._client = props.client;
            return;
        }

        if (process.env.HEDERA_NETWORK == null) {
            throw new Error(
                "LocalProvider requires the `HEDERA_NETWORK` environment variable to be set",
            );
        }

        this._client = Client.forName(process.env.HEDERA_NETWORK);
    }

    /**
     * @param {Client} client
     * @returns {LocalProvider}
     */
    static fromClient(client) {
        return new LocalProvider({ client });
    }

    /**
     * @returns {LedgerId?}
     */
    getLedgerId() {
        return this._client.ledgerId;
    }

    /**
     * @returns {{[key: string]: (string | AccountId)}}
     */
    getNetwork() {
        return this._client.network;
    }

    /**
     * @returns {string[]}
     */
    getMirrorNetwork() {
        return this._client.mirrorNetwork;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {Promise<AccountBalance>}
     */
    getAccountBalance(accountId) {
        return new AccountBalanceQuery()
            .setAccountId(accountId)
            .execute(this._client);
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {Promise<AccountInfo>}
     */
    getAccountInfo(accountId) {
        return new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(this._client);
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {Promise<TransactionRecord[]>}
     */
    getAccountRecords(accountId) {
        return new AccountRecordsQuery()
            .setAccountId(accountId)
            .execute(this._client);
    }

    /**
     * @param {TransactionId | string} transactionId
     * @returns {Promise<TransactionReceipt>}
     */
    getTransactionReceipt(transactionId) {
        return new TransactionReceiptQuery()
            .setTransactionId(transactionId)
            .execute(this._client);
    }

    /**
     * @param {TransactionResponse} response
     * @returns {Promise<TransactionReceipt>}
     */
    waitForReceipt(response) {
        return new TransactionReceiptQuery()
            .setNodeAccountIds([response.nodeId])
            .setTransactionId(response.transactionId)
            .execute(this._client);
    }

    /**
     * @template RequestT
     * @template ResponseT
     * @template OutputT
     * @param {Executable<RequestT, ResponseT, OutputT>} request
     * @returns {Promise<OutputT>}
     */
    call(request) {
        return request.execute(this._client);
    }

    /**
     * @returns {void}
     */
    close() {
        this._client.close();
    }

    /**
     * Set logger
     *
     * @param {Logger} logger
     */
    setLogger(logger) {
        this._client.setLogger(logger);
    }
}
// Filename: src/ManagedNode.js
// SPDX-License-Identifier: Apache-2.0

import ManagedNodeAddress from "./ManagedNodeAddress.js";

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @typedef {object} NewNode
 * @property {string | ManagedNodeAddress} address
 * @property {(address: string, cert?: string) => ChannelT} channelInitFunction
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @typedef {object} CloneNode
 * @property {ManagedNode<ChannelT>} node
 * @property {ManagedNodeAddress} address
 */

/**
 * @abstract
 * @template {Channel | MirrorChannel} ChannelT
 */
export default class ManagedNode {
    /**
     * @param {object} props
     * @param {NewNode<ChannelT>=} [props.newNode]
     * @param {CloneNode<ChannelT>=} [props.cloneNode]
     */
    constructor(props = {}) {
        if (props.newNode != null) {
            this._address =
                typeof props.newNode.address === "string"
                    ? ManagedNodeAddress.fromString(props.newNode.address)
                    : props.newNode.address;

            /** @type {string=} */
            this._cert = undefined;

            /** @type {ChannelT | null} */
            this._channel = null;

            /** @type {(address: string, cert?: string) => ChannelT} */
            this._channelInitFunction = props.newNode.channelInitFunction;

            this._lastUsed = Date.now();
            this._readmitTime = Date.now();
            this._useCount = 0;
            this._badGrpcStatusCount = 0;
            this._minBackoff = 8000;
            this._maxBackoff = 1000 * 60 * 60;
            this._currentBackoff = this._minBackoff;
        } else if (props.cloneNode != null) {
            /** @type {ManagedNodeAddress} */
            this._address = props.cloneNode.address;

            /** @type {string=} */
            this._cert = props.cloneNode.node._cert;

            /** @type {ChannelT | null} */
            this._channel = props.cloneNode.node._channel;

            /** @type {(address: string, cert?: string) => ChannelT} */
            this._channelInitFunction =
                props.cloneNode.node._channelInitFunction;

            /** @type {number} */
            this._currentBackoff = props.cloneNode.node._currentBackoff;

            /** @type {number} */
            this._lastUsed = props.cloneNode.node._lastUsed;

            /** @type {number} */
            this._readmitTime = props.cloneNode.node._readmitTime;

            /** @type {number} */
            this._useCount = props.cloneNode.node._useCount;

            /** @type {number} */
            this._badGrpcStatusCount = props.cloneNode.node._badGrpcStatusCount;

            /** @type {number} */
            this._minBackoff = props.cloneNode.node._minBackoff;

            /** @type {number} */
            this._maxBackoff = props.cloneNode.node._minBackoff;
        } else {
            throw new Error(
                `failed to create ManagedNode: ${JSON.stringify(props)}`,
            );
        }
    }

    /**
     * @abstract
     * @returns {string}
     */
    // eslint-disable-next-line jsdoc/require-returns-check
    getKey() {
        throw new Error("not implemented");
    }

    /**
     * @param {string} ledgerId
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCert(ledgerId) {
        return this;
    }

    /**
     * @returns {ManagedNodeAddress}
     */
    get address() {
        return this._address;
    }

    /**
     * @returns {number}
     */
    get attempts() {
        return this._badGrpcStatusCount;
    }

    /**
     * @returns {number}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        if (this._currentBackoff <= minBackoff) {
            this._currentBackoff = minBackoff;
        }

        this._minBackoff = minBackoff;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @param {number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        if (this._currentBackoff <= maxBackoff) {
            this._currentBackoff = maxBackoff;
        }

        this._maxBackoff = maxBackoff;
        return this;
    }

    getChannel() {
        this._useCount++;
        this.__lastUsed = Date.now();

        if (this._channel != null) {
            return this._channel;
        }

        this._channel = this._channelInitFunction(
            this.address.toString(),
            this._cert,
        );
        return this._channel;
    }

    /**
     * Determines if this node is healthy by checking if this node hasn't been
     * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`
     * and that value is only set in the `wait()` method, any node that has not
     * returned a bad gRPC status will always be considered healthy.
     *
     * @returns {boolean}
     */
    isHealthy() {
        return this._readmitTime <= Date.now();
    }

    increaseBackoff() {
        this._currentBackoff = Math.min(
            this._currentBackoff * 2,
            this._maxBackoff,
        );
        this._readmitTime = Date.now() + this._currentBackoff;
    }

    decreaseBackoff() {
        this._currentBackoff = Math.max(
            this._currentBackoff / 2,
            this._minBackoff,
        );
    }

    /**
     * @returns {number}
     */
    getRemainingTime() {
        return this._readmitTime - this._lastUsed;
    }

    /**
     * This is only ever called if the node itself is down.
     * A node returning a transaction with a bad status code does not indicate
     * the node is down, and hence this method will not be called.
     *
     * @returns {Promise<void>}
     */
    backoff() {
        return new Promise((resolve) =>
            setTimeout(resolve, this.getRemainingTime()),
        );
    }

    /**
     * @param {ManagedNode<*>} node
     * @returns {number}
     */
    compare(node) {
        let comparison = this.getRemainingTime() - node.getRemainingTime();
        if (comparison != 0) {
            return comparison;
        }

        comparison = this._currentBackoff - node._currentBackoff;
        if (comparison != 0) {
            return comparison;
        }

        comparison = this._badGrpcStatusCount - node._badGrpcStatusCount;
        if (comparison != 0) {
            return comparison;
        }

        comparison = this._useCount - node._useCount;
        if (comparison != 0) {
            return comparison;
        }

        return this._lastUsed - node._lastUsed;
    }

    close() {
        if (this._channel != null) {
            this._channel.close();
        }

        this._channel = null;
    }
}
// Filename: src/ManagedNodeAddress.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
 */

export const HOST_AND_PORT = /^(\S+):(\d+)$/;

export default class ManagedNodeAddress {
    /**
     * @param {object} props
     * @param {string} [props.address]
     * @param {string} [props.host]
     * @param {number | null} [props.port]
     */
    constructor(props = {}) {
        if (props.address != null) {
            const hostAndPortResult = HOST_AND_PORT.exec(props.address);

            if (hostAndPortResult == null) {
                throw new Error(`failed to parse address: ${props.address}`);
            }

            /** @type {string} */
            this._address = /** @type {string} */ (hostAndPortResult[1]);

            /** @type {number | null} */
            this._port =
                hostAndPortResult[2] != null
                    ? parseInt(/** @type {string }*/ (hostAndPortResult[2]))
                    : null;
        } else if (props.host != null && props.port != null) {
            /** @type {string} */
            this._address = props.host;

            /** @type {number | null} */
            this._port = props.port;
        } else {
            throw new Error(
                `failed to create a managed node address: ${JSON.stringify(
                    props,
                )}`,
            );
        }

        Object.freeze(this);
    }

    /**
     * @param {string} address
     * @returns {ManagedNodeAddress};
     */
    static fromString(address) {
        return new ManagedNodeAddress({ address });
    }

    toInsecure() {
        let port = this.port === 50212 ? 50211 : this.port;
        return new ManagedNodeAddress({ host: this.address, port });
    }

    toSecure() {
        let port = this.port === 50211 ? 50212 : this.port;
        return new ManagedNodeAddress({ host: this.address, port });
    }

    /**
     * @returns {string}
     */
    get address() {
        return this._address;
    }

    /**
     * @returns {number | null}
     */
    get port() {
        return this._port;
    }

    /**
     * @returns {boolean}
     */
    isTransportSecurity() {
        return this._port == 50212 || this._port == 443;
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this.port == null) {
            return this.address;
        } else {
            return `${this.address}:${this.port}`;
        }
    }
}
// Filename: src/MaxAttemptsOrTimeoutError.js
// SPDX-License-Identifier: Apache-2.0
/**
 * @typedef {object} MaxAttemptsOrTimeoutErrorJSON
 * @property {string} message
 * @property {string} nodeAccountId
 *
 */

export default class MaxAttemptsOrTimeoutError extends Error {
    /**
     * @param {string} message
     * @param {string} nodeAccountId
     */
    constructor(message, nodeAccountId) {
        // Call the Error constructor with the message
        super(message);

        // Assign the nodeAccountId as a custom property
        this.nodeAccountId = nodeAccountId;
    }

    toJSON() {
        return {
            message: this.message,
            nodeAccountId: this.nodeAccountId,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {MaxAttemptsOrTimeoutErrorJSON}
     */
    valueOf() {
        return this.toJSON();
    }
}
// Filename: src/MaxQueryPaymentExceeded.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./Hbar.js").default} Hbar
 */

/**
 * Error thrown when a query's cost exceeds the maximum payment amount set on the client.
 *
 * This error is used to prevent unexpectedly expensive queries from being automatically executed.
 * When this error occurs, the user can either:
 * 1. Increase the maximum query payment on the client
 * 2. Explicitly approve the higher cost for this specific query
 */
export default class MaxQueryPaymentExceeded extends Error {
    /**
     * @param {Hbar} queryCost
     * @param {Hbar} maxQueryPayment
     */
    constructor(queryCost, maxQueryPayment) {
        super();

        this.message = `query cost of ${queryCost.toString()} HBAR exceeds max set on client: ${maxQueryPayment.toString()} HBAR`;
        this.name = "MaxQueryPaymentExceededError";
        this.queryCost = queryCost;
        this.maxQueryPayment = maxQueryPayment;
    }
}
// Filename: src/MirrorNode.js
// SPDX-License-Identifier: Apache-2.0

import ManagedNode from "./ManagedNode.js";

/**
 * @typedef {import("./channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("./ManagedNodeAddress.js").default} ManagedNodeAddress
 */

/**
 * @typedef {object} NewNode
 * @property {string} address
 * @property {(address: string, cert?: string) => MirrorChannel} channelInitFunction
 */

/**
 * @typedef {object} CloneNode
 * @property {MirrorNode} node
 * @property {ManagedNodeAddress} address
 */

/**
 * @augments {ManagedNode<MirrorChannel>}
 */
export default class MirrorNode extends ManagedNode {
    /**
     * @param {object} props
     * @param {NewNode=} [props.newNode]
     * @param {CloneNode=} [props.cloneNode]
     */
    constructor(props = {}) {
        super(props);
    }

    /**
     * @returns {string}
     */
    getKey() {
        return this._address.toString();
    }
}
// Filename: src/Mnemonic.js
// SPDX-License-Identifier: Apache-2.0

import { Mnemonic as MnemonicCryptography } from "@hashgraph/cryptography";
import CACHE from "./Cache.js";

/**
 * @typedef {import("./PrivateKey.js").default} PrivateKey
 */

const HARDENED_BIT = 0x80000000;

/**
 * Multi-word mnemonic phrase (BIP-39).
 *
 * Compatible with the official Hiero mobile
 * wallets (24-words or 22-words) and BRD (12-words).
 */
export default class Mnemonic {
    /**
     * @param {MnemonicCryptography} mnemonic
     * @hideconstructor
     * @private
     */
    constructor(mnemonic) {
        this._mnemonic = mnemonic;
    }

    /**
     * Returns a new random 24-word mnemonic from the BIP-39
     * standard English word list.
     *
     * @returns {Promise<Mnemonic>}
     */
    static async generate() {
        return new Mnemonic(await MnemonicCryptography._generate(24));
    }

    /**
     * Returns a new random 12-word mnemonic from the BIP-39
     * standard English word list.
     *
     * @returns {Promise<Mnemonic>}
     */
    static async generate12() {
        return new Mnemonic(await MnemonicCryptography._generate(12));
    }

    /**
     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
     *
     * An exception of BadMnemonicError will be thrown if the mnemonic
     * contains unknown words or fails the checksum. An invalid mnemonic
     * can still be used to create private keys, the exception will
     * contain the failing mnemonic in case you wish to ignore the
     * validation error and continue.
     *
     * @param {string[]} words
     * @throws {cryptography.BadMnemonicError}
     * @returns {Promise<Mnemonic>}
     */
    static async fromWords(words) {
        return new Mnemonic(await MnemonicCryptography.fromWords(words));
    }

    /**
     * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
     * Recover a private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    async toPrivateKey(passphrase = "") {
        return CACHE.privateKeyConstructor(
            // eslint-disable-next-line deprecation/deprecation
            await this._mnemonic.toPrivateKey(passphrase),
        );
    }

    /**
     * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
     * Recover an Ed25519 private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @param {number[]} [path]
     * @returns {Promise<PrivateKey>}
     */
    async toEd25519PrivateKey(passphrase = "", path) {
        return CACHE.privateKeyConstructor(
            // eslint-disable-next-line deprecation/deprecation
            await this._mnemonic.toEd25519PrivateKey(passphrase, path),
        );
    }

    /**
     * Recover an Ed25519 private key from this mnemonic phrase, with an
     * optional passphrase.
     *
     * @param {string} [passphrase]
     * @param {number} [index]
     * @returns {Promise<PrivateKey>}
     */
    async toStandardEd25519PrivateKey(passphrase = "", index) {
        return CACHE.privateKeyConstructor(
            await this._mnemonic.toStandardEd25519PrivateKey(passphrase, index),
        );
    }

    /**
     * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
     * Recover an ECDSA private key from this mnemonic phrase, with an
     * optional passphrase.
     * @param {string} [passphrase]
     * @param {number[]} [path]
     * @returns {Promise<PrivateKey>}
     */
    async toEcdsaPrivateKey(passphrase = "", path) {
        return CACHE.privateKeyConstructor(
            // eslint-disable-next-line deprecation/deprecation
            await this._mnemonic.toEcdsaPrivateKey(passphrase, path),
        );
    }

    /**
     * Converts a derivation path from string to an array of integers.
     * Note that this expects precisely 5 components in the derivation path,
     * as per BIP-44:
     * `m / purpose' / coin_type' / account' / change / address_index`
     * Takes into account `'` for hardening as per BIP-32,
     * and does not prescribe which components should be hardened.
     *
     * @param {string} derivationPath    the derivation path in BIP-44 format,
     *                                   e.g. "m/44'/60'/0'/0/0"
     * @returns {Array<number>} to be used with PrivateKey#derive
     */
    calculateDerivationPathValues(derivationPath) {
        // Parse the derivation path from string into values
        const pattern = /m\/(\d+'?)\/(\d+'?)\/(\d+'?)\/(\d+'?)\/(\d+'?)/;
        const matches = pattern.exec(derivationPath);
        const values = new Array(5); // as Array<Number>;
        if (matches) {
            // Extract numbers and use apostrophe to select if is hardened
            for (let i = 1; i <= 5; i++) {
                let value = matches[i];
                if (value.endsWith("'")) {
                    value = value.substring(0, value.length - 1);
                    values[i - 1] = parseInt(value, 10) | HARDENED_BIT;
                } else {
                    values[i - 1] = parseInt(value, 10);
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return values;
    }

    /**
     * Common implementation for both `toStandardECDSAsecp256k1PrivateKey`
     * functions.
     *
     * @param {string} passphrase  the passphrase used to protect the
     *                             mnemonic, use "" for none
     * @param {Array<number>} derivationPathValues derivation path as an
     *                             integer array,
     *                             see: `calculateDerivationPathValues`
     * @returns {Promise<PrivateKey>}  a private key
     */
    async toStandardECDSAsecp256k1PrivateKeyImpl(
        passphrase,
        derivationPathValues,
    ) {
        // eslint-disable-next-line deprecation/deprecation
        return await this.toEcdsaPrivateKey(passphrase, derivationPathValues);
    }

    /**
     * Recover an ECDSA private key from this mnemonic phrase, with an
     * optional passphrase.
     *
     * @param {string} [passphrase]
     * @param {number} [index]
     * @returns {Promise<PrivateKey>}
     */
    async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
        return CACHE.privateKeyConstructor(
            await this._mnemonic.toStandardECDSAsecp256k1PrivateKey(
                passphrase,
                index,
            ),
        );
    }

    /**
     * Recover an ECDSAsecp256k1 private key from this mnemonic phrase and
     * derivation path, with an optional passphrase
     *
     * @param {string} passphrase      the passphrase used to protect the mnemonic,
     *                                 use "" for none
     * @param {string} derivationPath  the derivation path in BIP-44 format,
     *                                 e.g. "m/44'/60'/0'/0/0"
     * @returns {Promise<PrivateKey>}  the private key
     */
    async toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
        passphrase = "",
        derivationPath,
    ) {
        const derivationPathValues =
            this.calculateDerivationPathValues(derivationPath);
        return await this.toStandardECDSAsecp256k1PrivateKeyImpl(
            passphrase,
            derivationPathValues,
        );
    }

    /**
     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
     *
     * @param {string} mnemonic
     * @returns {Promise<Mnemonic>}
     */
    static async fromString(mnemonic) {
        return new Mnemonic(await MnemonicCryptography.fromString(mnemonic));
    }

    /**
     * @returns {Promise<PrivateKey>}
     */
    async toLegacyPrivateKey() {
        return CACHE.privateKeyConstructor(
            await this._mnemonic.toLegacyPrivateKey(),
        );
    }

    /**
     * @param {string} passphrase
     * @returns {Promise<Uint8Array>}
     */
    async toSeed(passphrase) {
        return await MnemonicCryptography.toSeed(
            this._mnemonic.words,
            passphrase,
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._mnemonic.toString();
    }
}
// Filename: src/Node.js
// SPDX-License-Identifier: Apache-2.0

import ManagedNode from "./ManagedNode.js";

/**
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./address_book/NodeAddress.js").default} NodeAddress
 * @typedef {import("./channel/Channel.js").default} Channel
 * @typedef {import("./ManagedNodeAddress.js").default} ManagedNodeAddress
 * @typedef {import("./LedgerId.js").default} LedgerId
 */

/**
 * @typedef {object} NewNode
 * @property {AccountId} accountId
 * @property {string} address
 * @property {(address: string) => Channel} channelInitFunction
 */

/**
 * @typedef {object} CloneNode
 * @property {Node} node
 * @property {ManagedNodeAddress} address
 */

/**
 * @augments {ManagedNode<Channel>}
 */
export default class Node extends ManagedNode {
    /**
     * @param {object} props
     * @param {NewNode=} [props.newNode]
     * @param {CloneNode=} [props.cloneNode]
     */
    constructor(props = {}) {
        super(props);

        if (props.newNode != null) {
            /** @type {AccountId} */
            this._accountId = props.newNode.accountId;

            /** @type {NodeAddress | null} */
            this._nodeAddress = null;
        } else if (props.cloneNode != null) {
            /** @type {AccountId} */
            this._accountId = props.cloneNode.node._accountId;

            /** @type {NodeAddress | null} */
            this._nodeAddress = props.cloneNode.node._nodeAddress;
        } else {
            throw new Error(`failed to create node: ${JSON.stringify(props)}`);
        }
    }

    /**
     * @returns {string}
     */
    getKey() {
        return this._accountId.toString();
    }

    /**
     * @returns {ManagedNode<Channel>}
     */
    toInsecure() {
        return /** @type {this} */ (
            new Node({
                cloneNode: { node: this, address: this._address.toInsecure() },
            })
        );
    }

    /**
     * @returns {ManagedNode<Channel>}
     */
    toSecure() {
        return /** @type {this} */ (
            new Node({
                cloneNode: { node: this, address: this._address.toSecure() },
            })
        );
    }

    /**
     * @returns {AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @returns {NodeAddress | null}
     */
    get nodeAddress() {
        return this._nodeAddress;
    }

    /**
     * @param {NodeAddress} nodeAddress
     * @returns {this}
     */
    setNodeAddress(nodeAddress) {
        this._nodeAddress = nodeAddress;
        return this;
    }
}
// Filename: src/ObjectMap.js
// SPDX-License-Identifier: Apache-2.0

/**
 * A simple "map" type that allows indexing by objects other than
 * strings, numbers, or booleans, and doesn't use the object pointer.
 *
 * @abstract
 * @template {{ toString(): string }} KeyT
 * @template {any} ValueT
 */
export default class ObjectMap {
    /**
     * @param {(s: string) => KeyT} fromString
     */
    constructor(fromString) {
        /**
         * This map is from the stringified version of the key, to the value
         *
         * @type {Map<string, ValueT>}
         */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this._map = new Map();

        /**
         * This map is from the key, to the value
         *
         * @type {Map<KeyT, ValueT>}
         */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.__map = new Map();

        /**
         * A function pointer to convert a key into a string. So we can set each
         * value in both maps.
         */
        this._fromString = fromString;
    }

    /**
     * Get a value by key or string.
     *
     * This is the main benefit of this class. If a user provides a `KeyT` we
     * implicitly serialize it to a string and use the string version. Otherwise
     * the user will get `undefined` even for a key that exists in the map since
     * the `KeyT` the provided has a different pointer than the one we have stored.
     * The string version doesn't have this issue since JS hashes the string and
     * that would result in both `KeyT` hitting the same value even if they're
     * different pointers.
     *
     * @param {KeyT | string} key
     * @returns {?ValueT}
     */
    get(key) {
        const k = typeof key === "string" ? key : key.toString();

        const value = this._map.get(k);
        return value != null ? value : null;
    }

    /**
     * Set the key to a value in both maps
     *
     * @internal
     * @param {KeyT} key
     * @param {ValueT} value
     */
    _set(key, value) {
        const k = typeof key === "string" ? key : key.toString();

        this._map.set(k, value);
        this.__map.set(key, value);
    }

    /**
     * Create iterator of values
     *
     * @returns {IterableIterator<ValueT>}
     */
    values() {
        return this._map.values();
    }

    /**
     * Get the size of the map
     *
     * @returns {number}
     */
    get size() {
        return this._map.size;
    }

    /**
     * Get the keys of the map.
     *
     * @returns {IterableIterator<KeyT>}
     */
    keys() {
        return this.__map.keys();
    }

    /**
     * Create an iterator over key, value pairs
     *
     * @returns {IterableIterator<[KeyT, ValueT]>}
     */
    [Symbol.iterator]() {
        return this.__map[Symbol.iterator]();
    }

    /**
     * Stringify the map into _something_ readable.
     * **NOTE**: This implementation is not stable and can change.
     *
     * @returns {string}
     */
    toString() {
        /** @type {{[key: string]: any}} */
        const map = {};

        for (const [key, value] of this._map) {
            map[key] = value;
        }

        return JSON.stringify(map);
    }

    toJSON() {
        const obj = {};

        this._map.forEach((value, key) => {
            // @ts-ignore
            obj[key] = value;
        });

        return obj;
    }
}
// Filename: src/PrecheckStatusError.js
// SPDX-License-Identifier: Apache-2.0

import StatusError from "./StatusError.js";

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./contract/ContractFunctionResult.js").default} ContractFunctionResult
 * @typedef {import("./account/AccountId.js").default} AccountId
 */

/**
 * @typedef {object} PrecheckStatusErrorJSON
 * @property {string} name
 * @property {string} status
 * @property {string} transactionId
 * @property {?string | null} nodeId
 * @property {string} message
 * @property {?ContractFunctionResult} contractFunctionResult
 */

/**
 * Represents an error that occurs during the pre-check phase of a transaction
 * on the Hedera network. The `PrecheckStatusError` class extends the base
 * `StatusError` class and provides additional context specific to pre-check
 * failures, such as the transaction ID, status, and any associated messages.
 *
 * This error is typically thrown when a transaction fails to meet the necessary
 * conditions before being processed, allowing developers to handle such errors
 * gracefully in their applications. The error includes details about the failure,
 * making it easier to diagnose issues related to transaction submissions.
 */
export default class PrecheckStatusError extends StatusError {
    /**
     * @param {object} props
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     * @param {AccountId} props.nodeId
     * @param {?ContractFunctionResult} props.contractFunctionResult
     */
    constructor(props) {
        super(
            props,
            `transaction ${props.transactionId.toString()} failed precheck with status ${props.status.toString()} against node account id ${props.nodeId.toString()}`,
        );

        /**
         * @type {?ContractFunctionResult}
         * @readonly
         */
        this.contractFunctionResult = props.contractFunctionResult;

        /**
         * @type {AccountId}
         * @readonly
         */
        this.nodeId = props.nodeId;
    }

    /**
     * @returns {PrecheckStatusErrorJSON}
     */
    toJSON() {
        return {
            name: this.name,
            status: this.status.toString(),
            transactionId: this.transactionId.toString(),
            nodeId: this.nodeId.toString(),
            message: this.message,
            contractFunctionResult: this.contractFunctionResult,
        };
    }
}
// Filename: src/PrivateKey.js
// SPDX-License-Identifier: Apache-2.0

import { PrivateKey as PrivateKeyCrypto } from "@hashgraph/cryptography";
import Mnemonic from "./Mnemonic.js";
import PublicKey from "./PublicKey.js";
import Key from "./Key.js";
import CACHE from "./Cache.js";
import SignatureMap from "./transaction/SignatureMap.js";

import AccountId from "./account/AccountId.js";
import TransactionId from "./transaction/TransactionId.js";
import { proto } from "@hashgraph/proto";

/**
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignaturePair} HieroProto.proto.ISignaturePair
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 */

export default class PrivateKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {PrivateKeyCrypto} key
     */
    constructor(key) {
        super();

        this._key = key;
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {PrivateKey}
     */
    static generateED25519() {
        return new PrivateKey(PrivateKeyCrypto.generateED25519());
    }

    /**
     * Generate a random EDSA private key.
     *
     * @returns {PrivateKey}
     */
    static generateECDSA() {
        return new PrivateKey(PrivateKeyCrypto.generateECDSA());
    }

    /**
     * Depredated - Use `generateED25519()` instead
     * Generate a random Ed25519 private key.
     *
     * @returns {PrivateKey}
     */
    static generate() {
        return PrivateKey.generateED25519();
    }

    /**
     * Depredated - Use `generateED25519Async()` instead
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateAsync() {
        return new PrivateKey(await PrivateKeyCrypto.generateAsync());
    }

    /**
     * Generate a random Ed25519 private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateED25519Async() {
        return new PrivateKey(await PrivateKeyCrypto.generateED25519Async());
    }

    /**
     * Generate a random ECDSA private key.
     *
     * @returns {Promise<PrivateKey>}
     */
    static async generateECDSAAsync() {
        return new PrivateKey(await PrivateKeyCrypto.generateECDSAAsync());
    }

    /**
     * Construct a private key from bytes. Requires DER header.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytes(data) {
        return new PrivateKey(PrivateKeyCrypto.fromBytes(data));
    }

    /**
     * Construct a ECDSA private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesECDSA(data) {
        return new PrivateKey(PrivateKeyCrypto.fromBytesECDSA(data));
    }

    /**
     * Construct a ED25519 private key from bytes.
     *
     * @param {Uint8Array} data
     * @returns {PrivateKey}
     */
    static fromBytesED25519(data) {
        return new PrivateKey(PrivateKeyCrypto.fromBytesED25519(data));
    }

    /**
     * @deprecated - Use fromStringECDSA() or fromStringED2551() on a HEX-encoded string
     * and fromStringDer() on a HEX-encoded string with DER prefix instead.
     * Construct a private key from a hex-encoded string. Requires DER header.
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromString(text) {
        return new PrivateKey(PrivateKeyCrypto.fromString(text));
    }

    /**
     * Construct a private key from a HEX-encoded string with a der prefix
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringDer(text) {
        return new PrivateKey(PrivateKeyCrypto.fromString(text));
    }

    /**
     * Construct a ECDSA private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringECDSA(text) {
        return new PrivateKey(PrivateKeyCrypto.fromStringECDSA(text));
    }

    /**
     * Construct a Ed25519 private key from a hex-encoded string.
     *
     * @param {string} text
     * @returns {PrivateKey}
     */
    static fromStringED25519(text) {
        return new PrivateKey(PrivateKeyCrypto.fromStringED25519(text));
    }

    /**
     * Construct a Ed25519 private key from a Uint8Array seed.
     *
     * @param {Uint8Array} seed
     * @returns {Promise<PrivateKey>}
     */
    static async fromSeedED25519(seed) {
        return new PrivateKey(await PrivateKeyCrypto.fromSeedED25519(seed));
    }

    /**
     * Construct a Ed25519 private key from a Uint8Array seed.
     *
     * @param {Uint8Array} seed
     * @returns {Promise<PrivateKey>}
     */
    static async fromSeedECDSAsecp256k1(seed) {
        return new PrivateKey(
            await PrivateKeyCrypto.fromSeedECDSAsecp256k1(seed),
        );
    }

    /**
     * @deprecated - Use `Mnemonic.from[Words|String]().to[Ed25519|Ecdsa]PrivateKey()` instead
     *
     * Recover a private key from a mnemonic phrase (and optionally a password).
     * @param {Mnemonic  | string} mnemonic
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromMnemonic(mnemonic, passphrase = "") {
        if (mnemonic instanceof Mnemonic) {
            return new PrivateKey(
                // eslint-disable-next-line deprecation/deprecation
                await PrivateKeyCrypto.fromMnemonic(
                    mnemonic._mnemonic,
                    passphrase,
                ),
            );
        }

        return new PrivateKey(
            // eslint-disable-next-line deprecation/deprecation
            await PrivateKeyCrypto.fromMnemonic(mnemonic, passphrase),
        );
    }

    /**
     * Recover a private key from a keystore, previously created by `.toKeystore()`.
     *
     * This key will _not_ support child key derivation.
     *
     * @param {Uint8Array} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     * @throws {cryptography.BadKeyError} If the passphrase is incorrect or the hash fails to validate.
     */
    static async fromKeystore(data, passphrase = "") {
        return new PrivateKey(
            await PrivateKeyCrypto.fromKeystore(data, passphrase),
        );
    }

    /**
     * Recover a private key from a pem string; the private key may be encrypted.
     *
     * This method assumes the .pem file has been converted to a string already.
     *
     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
     * section and decodes that as a DER-encoded  private key.
     *
     * @param {string} data
     * @param {string} [passphrase]
     * @returns {Promise<PrivateKey>}
     */
    static async fromPem(data, passphrase = "") {
        return new PrivateKey(await PrivateKeyCrypto.fromPem(data, passphrase));
    }

    /**
     * Derive a new private key at the given wallet index.
     *
     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw
     * an error.
     *
     * You can check if a key supports derivation with `.supportsDerivation()`
     *
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async derive(index) {
        return new PrivateKey(await this._key.derive(index));
    }

    /**
     * @param {number} index
     * @returns {Promise<PrivateKey>}
     * @throws If this key does not support derivation.
     */
    async legacyDerive(index) {
        return new PrivateKey(await this._key.legacyDerive(index));
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     *
     * @returns {PublicKey}
     */
    get publicKey() {
        return new PublicKey(this._key.publicKey);
    }

    /**
     * Get the public key associated with this private key.
     *
     * The public key can be freely given and used by other parties to verify
     * the signatures generated by this private key.
     *
     * @returns {?Uint8Array}
     */
    get chainCode() {
        return this._key._chainCode;
    }

    /**
     * Sign a message with this private key.
     *
     * @param {Uint8Array} bytes
     * @returns {Uint8Array} - The signature bytes without the message
     */
    sign(bytes) {
        return this._key.sign(bytes);
    }

    /**
     * @param {Transaction} transaction
     * @returns {SignatureMap}
     */
    signTransaction(transaction) {
        const sigMap = new SignatureMap();

        for (const signedTx of transaction._signedTransactions.list) {
            const bodyBytes = signedTx.bodyBytes;
            if (!bodyBytes) throw new Error("Body bytes are missing");

            const body = proto.TransactionBody.decode(bodyBytes);
            if (!body.transactionID || !body.nodeAccountID) {
                throw new Error(
                    "Transaction ID or Node Account ID not found in the signed transaction",
                );
            }

            const nodeId = AccountId._fromProtobuf(body.nodeAccountID);
            const transactionId = TransactionId._fromProtobuf(
                body.transactionID,
            );
            const sig = this._key.sign(bodyBytes);
            sigMap.addSignature(nodeId, transactionId, this.publicKey, sig);
        }

        transaction.addSignature(this.publicKey, sigMap);
        return sigMap;
    }
    /**
     * Check if `derive` can be called on this private key.
     *
     * This is only the case if the key was created from a mnemonic.
     *
     * @returns {boolean}
     */
    isDerivable() {
        return this._key.isDerivable();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._key.toBytes();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._key.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return this._key.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return this._key.toStringRaw();
    }

    /**
     * Create a keystore with a given passphrase.
     *
     * The key can be recovered later with `fromKeystore()`.
     *
     * Note that this will not retain the ancillary data used for
     * deriving child keys, thus `.derive()` on the restored key will
     * throw even if this instance supports derivation.
     *
     * @param {string} [passphrase]
     * @returns {Promise<Uint8Array>}
     */
    toKeystore(passphrase = "") {
        return this._key.toKeystore(passphrase);
    }

    /**
     * @returns {HieroProto.proto.IKey}
     */
    _toProtobufKey() {
        return this.publicKey._toProtobufKey();
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @returns {AccountId}
     */
    toAccountId(shard, realm) {
        return this.publicKey.toAccountId(shard, realm);
    }

    /**
     * @returns {string}
     */
    get type() {
        return this._key._type;
    }
}

CACHE.setPrivateKeyConstructor((key) => new PrivateKey(key));
// Filename: src/PrngTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "./transaction/Transaction.js";
import { isNumber } from "./util.js";

/**
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.Transaction} HieroProto.proto.Transaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.SignedTransaction} HieroProto.proto.SignedTransaction
 * @typedef {import("@hashgraph/proto").proto.IUtilPrngTransactionBody } HieroProto.proto.IUtilPrngTransactionBody
 * @typedef {import("@hashgraph/proto").proto.UtilPrngTransactionBody} HieroProto.proto.UtilPrngTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.TransactionResponse
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {import("./client/Client.js").default<*, *>} Client
 *  @typedef {import("./channel/Channel.js").default} Channel
 */

/**
 * Gets a pseudorandom 32-bit number. Not cryptographically secure. See HIP-351 https://hips.hedera.com/hip/hip-351
 */
export default class PrngTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {?number } [props.range]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?number}
         */
        this._range = null;

        if (props.range != null) {
            this.setRange(props.range);
        }
    }

    /**
     * @param {number} newRange
     * @returns {this}
     */
    setRange(newRange) {
        this._range = newRange;
        return this;
    }

    get range() {
        return this._range;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._range != null && isNumber(this._range)) {
            this._validateChecksums(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.TransactionResponse>}
     */
    _execute(channel, request) {
        return channel.util.prng(request);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {PrngTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = /** @type {HieroProto.proto.ITransactionBody} */ (
            bodies[0]
        );
        const transactionRange =
            /** @type {HieroProto.proto.IUtilPrngTransactionBody} */ (
                body.utilPrng
            );
        return Transaction._fromProtobufTransactions(
            new PrngTransaction({
                range: transactionRange.range,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "utilPrng";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IUtilPrngTransactionBody}
     */
    _makeTransactionData() {
        return {
            range: this.range,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("./Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `RandomGenerate:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "utilPrng",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    PrngTransaction._fromProtobuf,
);
// Filename: src/Provider.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./LedgerId.js").default} LedgerId
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./account/AccountBalance.js").default} AccountBalance
 * @typedef {import("./account/AccountInfo.js").default} AccountInfo
 */

/**
 * @template O
 * @typedef {import("./query/Query.js").default<O>} Query<O>
 */

/**
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
 */

/**
 * @typedef {object} Provider
 * @property {() => LedgerId?} getLedgerId
 * @property {() => {[key: string]: (string | AccountId)}} getNetwork
 * @property {() => string[]} getMirrorNetwork
 * @property {(accountId: AccountId | string) => Promise<AccountBalance>} getAccountBalance
 * @property {(accountId: AccountId | string) => Promise<AccountInfo>} getAccountInfo
 * @property {(accountId: AccountId | string) => Promise<TransactionRecord[]>} getAccountRecords
 * @property {(transactionId: TransactionId | string) => Promise<TransactionReceipt>} getTransactionReceipt
 * @property {(response: TransactionResponse) => Promise<TransactionReceipt>} waitForReceipt
 * @property {<RequestT, ResponseT, OutputT>(request: Executable<RequestT, ResponseT, OutputT>) => Promise<OutputT>} call
 */

export default {};
// Filename: src/PublicKey.js
// SPDX-License-Identifier: Apache-2.0

import { PublicKey as PublicKeyCrypto } from "@hashgraph/cryptography";
import { arrayEqual } from "./array.js";
import Key from "./Key.js";
import CACHE from "./Cache.js";

/**
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./account/AccountId.js").default} AccountId
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignaturePair} HieroProto.proto.ISignaturePair
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 */

export default class PublicKey extends Key {
    /**
     * @internal
     * @hideconstructor
     * @param {PublicKeyCrypto} key
     */
    constructor(key) {
        super();

        this._key = key;
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytes(data) {
        return new PublicKey(PublicKeyCrypto.fromBytes(data));
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesED25519(data) {
        return new PublicKey(PublicKeyCrypto.fromBytesED25519(data));
    }

    /**
     * @param {Uint8Array} data
     * @returns {PublicKey}
     */
    static fromBytesECDSA(data) {
        return new PublicKey(PublicKeyCrypto.fromBytesECDSA(data));
    }

    /**
     * Parse a public key from a string of hexadecimal digits.
     *
     * The public key may optionally be prefixed with
     * the DER header.
     *
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromString(text) {
        return new PublicKey(PublicKeyCrypto.fromString(text));
    }

    /**
     * Parse an ECDSA public key from a string of hexadecimal digits.
     *
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromStringECDSA(text) {
        return new PublicKey(PublicKeyCrypto.fromStringECDSA(text));
    }

    /**
     * Parse an ED25519 public key from a string of hexadecimal digits.
     *
     * @param {string} text
     * @returns {PublicKey}
     */
    static fromStringED25519(text) {
        return new PublicKey(PublicKeyCrypto.fromStringED25519(text));
    }

    /**
     * Verify a signature on a message with this public key.
     *
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {boolean}
     */
    verify(message, signature) {
        return this._key.verify(message, signature);
    }

    /**
     * @param {Transaction} transaction
     * @returns {boolean}
     */
    verifyTransaction(transaction) {
        transaction._requireFrozen();

        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        for (const signedTransaction of transaction._signedTransactions.list) {
            if (
                signedTransaction.sigMap != null &&
                signedTransaction.sigMap.sigPair != null
            ) {
                let found = false;
                for (const sigPair of signedTransaction.sigMap.sigPair) {
                    const pubKeyPrefix = /** @type {Uint8Array} */ (
                        sigPair.pubKeyPrefix
                    );
                    if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {
                        found = true;

                        const bodyBytes = /** @type {Uint8Array} */ (
                            signedTransaction.bodyBytes
                        );

                        let signature = null;
                        if (sigPair.ed25519 != null) {
                            signature = sigPair.ed25519;
                        } else if (sigPair.ECDSASecp256k1 != null) {
                            signature = sigPair.ECDSASecp256k1;
                        }

                        if (signature == null) {
                            continue;
                        }

                        if (!this.verify(bodyBytes, signature)) {
                            return false;
                        }
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return this._key.toBytes();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesDer() {
        return this._key.toBytesDer();
    }

    /**
     * @returns {Uint8Array}
     */
    toBytesRaw() {
        return this._key.toBytesRaw();
    }

    /**
     * @deprecated Use `toEvmAddress()` instead.
     * @returns {string}
     */
    toEthereumAddress() {
        return this._key.toEthereumAddress();
    }

    /**
     * @returns {string}
     */
    toEvmAddress() {
        return this._key.toEthereumAddress();
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._key.toString();
    }

    /**
     * @returns {string}
     */
    toStringDer() {
        return this._key.toStringDer();
    }

    /**
     * @returns {string}
     */
    toStringRaw() {
        return this._key.toStringRaw();
    }

    /**
     * @param {PublicKey} other
     * @returns {boolean}
     */
    equals(other) {
        return this._key.equals(other._key);
    }

    /**
     * @returns {HieroProto.proto.IKey}
     */
    _toProtobufKey() {
        switch (this._key._type) {
            case "ED25519":
                return {
                    ed25519: this._key.toBytesRaw(),
                };
            case "secp256k1":
                return {
                    ECDSASecp256k1: this._key.toBytesRaw(),
                };
            default:
                throw new Error(`unrecognized key type ${this._key._type}`);
        }
    }

    /**
     * @param {Uint8Array} signature
     * @returns {HieroProto.proto.ISignaturePair}
     */
    _toProtobufSignature(signature) {
        switch (this._key._type) {
            case "ED25519":
                return {
                    pubKeyPrefix: this._key.toBytesRaw(),
                    ed25519: signature,
                };
            case "secp256k1":
                return {
                    pubKeyPrefix: this._key.toBytesRaw(),
                    ECDSASecp256k1: signature,
                };
            default:
                throw new Error(`unrecognized key type ${this._key._type}`);
        }
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @returns {AccountId}
     */
    toAccountId(shard, realm) {
        return CACHE.accountIdConstructor(shard, realm, this);
    }

    /**
     * Returns an "unusable" public key.
     * “Unusable” refers to a key such as an Ed25519 0x00000... public key,
     * since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes of zeros.
     *
     * @returns {PublicKey}
     */
    static unusableKey() {
        return PublicKey.fromStringED25519(
            "0000000000000000000000000000000000000000000000000000000000000000",
        );
    }
}

CACHE.setPublicKeyED25519((key) => PublicKey.fromBytesED25519(key));
CACHE.setPublicKeyECDSA((key) => PublicKey.fromBytesECDSA(key));
// Filename: src/ReceiptStatusError.js
// SPDX-License-Identifier: Apache-2.0

import StatusError from "./StatusError.js";

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 */

/**
 * Represents an error that occurs when a transaction receipt indicates a failure
 * on the Hedera network. The `ReceiptStatusError` class extends the base
 * `StatusError` class and provides additional context specific to receipt-related
 * failures, such as the transaction ID, status, and any associated messages.
 *
 * This error is typically thrown when a transaction has been processed, but the
 * receipt indicates that it did not complete successfully. It allows developers to
 * handle such errors effectively in their applications by providing detailed
 * information about the failure.
 */
export default class ReceiptStatusError extends StatusError {
    /**
     * @param {object} props
     * @param {TransactionReceipt} props.transactionReceipt
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     */
    constructor(props) {
        super(
            props,
            `receipt for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`,
        );

        /**
         * @type {TransactionReceipt}
         * @readonly
         */
        this.transactionReceipt = props.transactionReceipt;
    }
}
// Filename: src/RecordStatusError.js
// SPDX-License-Identifier: Apache-2.0

import StatusError from "./StatusError.js";

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/TransactionRecord").default} TransactionRecord
 */

export default class RecordStatusError extends StatusError {
    /**
     * @param {object} props
     * @param {TransactionRecord} props.transactionRecord
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     */
    constructor(props) {
        super(
            props,
            `Record for transaction ${props.transactionId.toString()} contained error status ${props.status.toString()}`,
        );

        /**
         * @type {TransactionRecord}
         * @readonly
         */
        this.transactionRecord = props.transactionRecord;
    }
}
// Filename: src/RequestType.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.HederaFunctionality} HieroProto.proto.HederaFunctionality
 */

export default class RequestType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case RequestType.None:
                return "NONE";
            case RequestType.CryptoTransfer:
                return "CryptoTransfer";
            case RequestType.CryptoUpdate:
                return "CryptoUpdate";
            case RequestType.CryptoDelete:
                return "CryptoDelete";
            case RequestType.CryptoAddLiveHash:
                return "CryptoAddLiveHash";
            case RequestType.CryptoDeleteLiveHash:
                return "CryptoDeleteLiveHash";
            case RequestType.ContractCall:
                return "ContractCall";
            case RequestType.ContractCreate:
                return "ContractCreate";
            case RequestType.ContractUpdate:
                return "ContractUpdate";
            case RequestType.FileCreate:
                return "FileCreate";
            case RequestType.FileAppend:
                return "FileAppend";
            case RequestType.FileUpdate:
                return "FileUpdate";
            case RequestType.FileDelete:
                return "FileDelete";
            case RequestType.CryptoGetAccountBalance:
                return "CryptoGetAccountBalance";
            case RequestType.CryptoGetAccountRecords:
                return "CryptoGetAccountRecords";
            case RequestType.CryptoGetInfo:
                return "CryptoGetInfo";
            case RequestType.ContractCallLocal:
                return "ContractCallLocal";
            case RequestType.ContractGetInfo:
                return "ContractGetInfo";
            case RequestType.ContractGetBytecode:
                return "ContractGetBytecode";
            case RequestType.GetBySolidityID:
                return "GetBySolidityID";
            case RequestType.GetByKey:
                return "GetByKey";
            case RequestType.CryptoGetLiveHash:
                return "CryptoGetLiveHash";
            case RequestType.CryptoGetStakers:
                return "CryptoGetStakers";
            case RequestType.FileGetContents:
                return "FileGetContents";
            case RequestType.FileGetInfo:
                return "FileGetInfo";
            case RequestType.TransactionGetRecord:
                return "TransactionGetRecord";
            case RequestType.ContractGetRecords:
                return "ContractGetRecords";
            case RequestType.CryptoCreate:
                return "CryptoCreate";
            case RequestType.SystemDelete:
                return "SystemDelete";
            case RequestType.SystemUndelete:
                return "SystemUndelete";
            case RequestType.ContractDelete:
                return "ContractDelete";
            case RequestType.Freeze:
                return "Freeze";
            case RequestType.CreateTransactionRecord:
                return "CreateTransactionRecord";
            case RequestType.CryptoAccountAutoRenew:
                return "CryptoAccountAutoRenew";
            case RequestType.ContractAutoRenew:
                return "ContractAutoRenew";
            case RequestType.GetVersionInfo:
                return "GetVersionInfo";
            case RequestType.TransactionGetReceipt:
                return "TransactionGetReceipt";
            case RequestType.ConsensusCreateTopic:
                return "ConsensusCreateTopic";
            case RequestType.ConsensusUpdateTopic:
                return "ConsensusUpdateTopic";
            case RequestType.ConsensusDeleteTopic:
                return "ConsensusDeleteTopic";
            case RequestType.ConsensusGetTopicInfo:
                return "ConsensusGetTopicInfo";
            case RequestType.ConsensusSubmitMessage:
                return "ConsensusSubmitMessage";
            case RequestType.UncheckedSubmit:
                return "UncheckedSubmit";
            case RequestType.TokenCreate:
                return "TokenCreate";
            case RequestType.TokenGetInfo:
                return "TokenGetInfo";
            case RequestType.TokenFreezeAccount:
                return "TokenFreezeAccount";
            case RequestType.TokenUnfreezeAccount:
                return "TokenUnfreezeAccount";
            case RequestType.TokenGrantKycToAccount:
                return "TokenGrantKycToAccount";
            case RequestType.TokenRevokeKycFromAccount:
                return "TokenRevokeKycFromAccount";
            case RequestType.TokenDelete:
                return "TokenDelete";
            case RequestType.TokenUpdate:
                return "TokenUpdate";
            case RequestType.TokenMint:
                return "TokenMint";
            case RequestType.TokenBurn:
                return "TokenBurn";
            case RequestType.TokenAccountWipe:
                return "TokenAccountWipe";
            case RequestType.TokenAssociateToAccount:
                return "TokenAssociateToAccount";
            case RequestType.TokenDissociateFromAccount:
                return "TokenDissociateFromAccount";
            case RequestType.ScheduleCreate:
                return "ScheduleCreate";
            case RequestType.ScheduleDelete:
                return "ScheduleDelete";
            case RequestType.ScheduleSign:
                return "ScheduleSign";
            case RequestType.ScheduleGetInfo:
                return "ScheduleGetInfo";
            case RequestType.TokenGetAccountNftInfos:
                return "TokenGetAccountNftInfos";
            case RequestType.TokenGetNftInfo:
                return "TokenGetNftInfo";
            case RequestType.TokenGetNftInfos:
                return "TokenGetNftInfos";
            case RequestType.TokenFeeScheduleUpdate:
                return "TokenFeeScheduleUpdate";
            case RequestType.NetworkGetExecutionTime:
                return "NetworkGetExecutionTime";
            case RequestType.TokenPause:
                return "TokenPause";
            case RequestType.TokenUnpause:
                return "TokenUnpause";
            case RequestType.CryptoApproveAllowance:
                return "CryptoApproveAllowance";
            case RequestType.CryptoDeleteAllowance:
                return "CryptoDeleteAllowance";
            case RequestType.GetAccountDetails:
                return "GetAccountDetails";
            case RequestType.EthereumTransaction:
                return "EthereumTransaction";
            case RequestType.NodeStakeUpdate:
                return "NodeStakeUpdate";
            case RequestType.Prng:
                return "UtilPrng";
            case RequestType.TransactionGetFastRecord:
                return "TransactionGetFastRecord";
            case RequestType.TokenUpdateNfts:
                return "TokenUpdateNfts";
            case RequestType.NodeCreate:
                return "NodeCreate";
            case RequestType.NodeUpdate:
                return "NodeUpdate";
            case RequestType.NodeDelete:
                return "NodeDelete";
            case RequestType.TokenReject:
                return "TokenReject";
            case RequestType.TokenAirdrop:
                return "TokenAirdrop";
            case RequestType.TokenCancelAirdrop:
                return "TokenCancelAirdrop";
            case RequestType.TokenClaimAirdrop:
                return "TokenClaimAirdrop";
            case RequestType.TssMessage:
                return "TssMessage";
            case RequestType.TssVote:
                return "TssVote";
            case RequestType.TssShareSignature:
                return "TssShareSignature";
            case RequestType.TssEncryptionKey:
                return "TssEncryptionKey";
            case RequestType.StateSignatureTransaction:
                return "StateSignatureTransaction";
            case RequestType.HistoryAssemblySignature:
                return "HistoryAssemblySignature";
            case RequestType.HistoryProofKeyPublication:
                return "HistoryProofKeyPublication";
            case RequestType.HistoryProofVote:
                return "HistoryProofVote";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {RequestType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return RequestType.None;
            case 1:
                return RequestType.CryptoTransfer;
            case 2:
                return RequestType.CryptoUpdate;
            case 3:
                return RequestType.CryptoDelete;
            case 4:
                return RequestType.CryptoAddLiveHash;
            case 5:
                return RequestType.CryptoDeleteLiveHash;
            case 6:
                return RequestType.ContractCall;
            case 7:
                return RequestType.ContractCreate;
            case 8:
                return RequestType.ContractUpdate;
            case 9:
                return RequestType.FileCreate;
            case 10:
                return RequestType.FileAppend;
            case 11:
                return RequestType.FileUpdate;
            case 12:
                return RequestType.FileDelete;
            case 13:
                return RequestType.CryptoGetAccountBalance;
            case 14:
                return RequestType.CryptoGetAccountRecords;
            case 15:
                return RequestType.CryptoGetInfo;
            case 16:
                return RequestType.ContractCallLocal;
            case 17:
                return RequestType.ContractGetInfo;
            case 18:
                return RequestType.ContractGetBytecode;
            case 19:
                return RequestType.GetBySolidityID;
            case 20:
                return RequestType.GetByKey;
            case 21:
                return RequestType.CryptoGetLiveHash;
            case 22:
                return RequestType.CryptoGetStakers;
            case 23:
                return RequestType.FileGetContents;
            case 24:
                return RequestType.FileGetInfo;
            case 25:
                return RequestType.TransactionGetRecord;
            case 26:
                return RequestType.ContractGetRecords;
            case 27:
                return RequestType.CryptoCreate;
            case 28:
                return RequestType.SystemDelete;
            case 29:
                return RequestType.SystemUndelete;
            case 30:
                return RequestType.ContractDelete;
            case 31:
                return RequestType.Freeze;
            case 32:
                return RequestType.CreateTransactionRecord;
            case 33:
                return RequestType.CryptoAccountAutoRenew;
            case 34:
                return RequestType.ContractAutoRenew;
            case 35:
                return RequestType.GetVersionInfo;
            case 36:
                return RequestType.TransactionGetReceipt;
            case 50:
                return RequestType.ConsensusCreateTopic;
            case 51:
                return RequestType.ConsensusUpdateTopic;
            case 52:
                return RequestType.ConsensusDeleteTopic;
            case 53:
                return RequestType.ConsensusGetTopicInfo;
            case 54:
                return RequestType.ConsensusSubmitMessage;
            case 55:
                return RequestType.UncheckedSubmit;
            case 56:
                return RequestType.TokenCreate;
            case 58:
                return RequestType.TokenGetInfo;
            case 59:
                return RequestType.TokenFreezeAccount;
            case 60:
                return RequestType.TokenUnfreezeAccount;
            case 61:
                return RequestType.TokenGrantKycToAccount;
            case 62:
                return RequestType.TokenRevokeKycFromAccount;
            case 63:
                return RequestType.TokenDelete;
            case 64:
                return RequestType.TokenUpdate;
            case 65:
                return RequestType.TokenMint;
            case 66:
                return RequestType.TokenBurn;
            case 67:
                return RequestType.TokenAccountWipe;
            case 68:
                return RequestType.TokenAssociateToAccount;
            case 69:
                return RequestType.TokenDissociateFromAccount;
            case 70:
                return RequestType.ScheduleCreate;
            case 71:
                return RequestType.ScheduleDelete;
            case 72:
                return RequestType.ScheduleSign;
            case 73:
                return RequestType.ScheduleGetInfo;
            case 74:
                return RequestType.TokenGetAccountNftInfos;
            case 75:
                return RequestType.TokenGetNftInfo;
            case 76:
                return RequestType.TokenGetNftInfos;
            case 77:
                return RequestType.TokenFeeScheduleUpdate;
            case 78:
                return RequestType.NetworkGetExecutionTime;
            case 79:
                return RequestType.TokenPause;
            case 80:
                return RequestType.TokenUnpause;
            case 81:
                return RequestType.CryptoApproveAllowance;
            case 82:
                return RequestType.CryptoDeleteAllowance;
            case 83:
                return RequestType.GetAccountDetails;
            case 84:
                return RequestType.EthereumTransaction;
            case 85:
                return RequestType.NodeStakeUpdate;
            case 86:
                return RequestType.Prng;
            case 87:
                return RequestType.TransactionGetFastRecord;
            case 88:
                return RequestType.TokenUpdateNfts;
            case 89:
                return RequestType.NodeCreate;
            case 90:
                return RequestType.NodeUpdate;
            case 91:
                return RequestType.NodeDelete;
            case 92:
                return RequestType.TokenReject;
            case 93:
                return RequestType.TokenAirdrop;
            case 94:
                return RequestType.TokenCancelAirdrop;
            case 95:
                return RequestType.TokenClaimAirdrop;
            case 96:
                return RequestType.TssMessage;
            case 97:
                return RequestType.TssVote;
            case 98:
                return RequestType.TssShareSignature;
            case 99:
                return RequestType.TssEncryptionKey;
            case 100:
                return RequestType.StateSignatureTransaction;
            case 104:
                return RequestType.HistoryAssemblySignature;
            case 105:
                return RequestType.HistoryProofKeyPublication;
            case 106:
                return RequestType.HistoryProofVote;
        }

        throw new Error(
            `(BUG) RequestType.fromCode() does not handle code: ${code}`,
        );
    }

    /**
     * @returns {HieroProto.proto.HederaFunctionality}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
 * not parsed (0 is ignored by parser)
 */
RequestType.None = new RequestType(0);

/**
 * crypto transfer
 */
RequestType.CryptoTransfer = new RequestType(1);

/**
 * crypto update account
 */
RequestType.CryptoUpdate = new RequestType(2);

/**
 * crypto delete account
 */
RequestType.CryptoDelete = new RequestType(3);

/**
 * Add a livehash to a crypto account
 */
RequestType.CryptoAddLiveHash = new RequestType(4);

/**
 * Delete a livehash from a crypto account
 */
RequestType.CryptoDeleteLiveHash = new RequestType(5);

/**
 * Smart Contract Call
 */
RequestType.ContractCall = new RequestType(6);

/**
 * Smart Contract Create Contract
 */
RequestType.ContractCreate = new RequestType(7);

/**
 * Smart Contract update contract
 */
RequestType.ContractUpdate = new RequestType(8);

/**
 * File Operation create file
 */
RequestType.FileCreate = new RequestType(9);

/**
 * File Operation append file
 */
RequestType.FileAppend = new RequestType(10);

/**
 * File Operation update file
 */
RequestType.FileUpdate = new RequestType(11);

/**
 * File Operation delete file
 */
RequestType.FileDelete = new RequestType(12);

/**
 * crypto get account balance
 */
RequestType.CryptoGetAccountBalance = new RequestType(13);

/**
 * crypto get account record
 */
RequestType.CryptoGetAccountRecords = new RequestType(14);

/**
 * Crypto get info
 */
RequestType.CryptoGetInfo = new RequestType(15);

/**
 * Smart Contract Call
 */
RequestType.ContractCallLocal = new RequestType(16);

/**
 * Smart Contract get info
 */
RequestType.ContractGetInfo = new RequestType(17);

/**
 * Smart Contract, get the runtime code
 */
RequestType.ContractGetBytecode = new RequestType(18);

/**
 * Smart Contract, get by solidity ID
 */
RequestType.GetBySolidityID = new RequestType(19);

/**
 * Smart Contract, get by key
 */
RequestType.GetByKey = new RequestType(20);

/**
 * Get a live hash from a crypto account
 */
RequestType.CryptoGetLiveHash = new RequestType(21);

/**
 * Crypto, get the stakers for the node
 */
RequestType.CryptoGetStakers = new RequestType(22);

/**
 * File Operations get file contents
 */
RequestType.FileGetContents = new RequestType(23);

/**
 * File Operations get the info of the file
 */
RequestType.FileGetInfo = new RequestType(24);

/**
 * Crypto get the transaction records
 */
RequestType.TransactionGetRecord = new RequestType(25);

/**
 * Contract get the transaction records
 */
RequestType.ContractGetRecords = new RequestType(26);

/**
 * crypto create account
 */
RequestType.CryptoCreate = new RequestType(27);

/**
 * system delete file
 */
RequestType.SystemDelete = new RequestType(28);

/**
 * system undelete file
 */
RequestType.SystemUndelete = new RequestType(29);

/**
 * delete contract
 */
RequestType.ContractDelete = new RequestType(30);

/**
 * freeze
 */
RequestType.Freeze = new RequestType(31);

/**
 * Create Tx Record
 */
RequestType.CreateTransactionRecord = new RequestType(32);

/**
 * Crypto Auto Renew
 */
RequestType.CryptoAccountAutoRenew = new RequestType(33);

/**
 * Contract Auto Renew
 */
RequestType.ContractAutoRenew = new RequestType(34);

/**
 * Get Version
 */
RequestType.GetVersionInfo = new RequestType(35);

/**
 * Transaction Get Receipt
 */
RequestType.TransactionGetReceipt = new RequestType(36);

/**
 * Create Topic
 */
RequestType.ConsensusCreateTopic = new RequestType(50);

/**
 * Update Topic
 */
RequestType.ConsensusUpdateTopic = new RequestType(51);

/**
 * Delete Topic
 */
RequestType.ConsensusDeleteTopic = new RequestType(52);

/**
 * Get Topic information
 */
RequestType.ConsensusGetTopicInfo = new RequestType(53);

/**
 * Submit message to topic
 */
RequestType.ConsensusSubmitMessage = new RequestType(54);

RequestType.UncheckedSubmit = new RequestType(55);
/**
 * Create Token
 */
RequestType.TokenCreate = new RequestType(56);

/**
 * Get Token information
 */
RequestType.TokenGetInfo = new RequestType(58);

/**
 * Freeze Account
 */
RequestType.TokenFreezeAccount = new RequestType(59);

/**
 * Unfreeze Account
 */
RequestType.TokenUnfreezeAccount = new RequestType(60);

/**
 * Grant KYC to Account
 */
RequestType.TokenGrantKycToAccount = new RequestType(61);

/**
 * Revoke KYC from Account
 */
RequestType.TokenRevokeKycFromAccount = new RequestType(62);

/**
 * Delete Token
 */
RequestType.TokenDelete = new RequestType(63);

/**
 * Update Token
 */
RequestType.TokenUpdate = new RequestType(64);

/**
 * Mint tokens to treasury
 */
RequestType.TokenMint = new RequestType(65);

/**
 * Burn tokens from treasury
 */
RequestType.TokenBurn = new RequestType(66);

/**
 * Wipe token amount from Account holder
 */
RequestType.TokenAccountWipe = new RequestType(67);

/**
 * Associate tokens to an account
 */
RequestType.TokenAssociateToAccount = new RequestType(68);

/**
 * Dissociate tokens from an account
 */
RequestType.TokenDissociateFromAccount = new RequestType(69);

/**
 * Create Scheduled Transaction
 */
RequestType.ScheduleCreate = new RequestType(70);

/**
 * Delete Scheduled Transaction
 */
RequestType.ScheduleDelete = new RequestType(71);

/**
 * Sign Scheduled Transaction
 */
RequestType.ScheduleSign = new RequestType(72);

/**
 * Get Scheduled Transaction Information
 */
RequestType.ScheduleGetInfo = new RequestType(73);

/**
 * Get Token Account Nft Information
 */
RequestType.TokenGetAccountNftInfos = new RequestType(74);

/**
 * Get Token Nft Information
 */
RequestType.TokenGetNftInfo = new RequestType(75);

/**
 * Get Token Nft List Information
 */
RequestType.TokenGetNftInfos = new RequestType(76);

/**
 * Update a token's custom fee schedule, if permissible
 */
RequestType.TokenFeeScheduleUpdate = new RequestType(77);

/**
 * Get execution time(s) by TransactionID, if available
 */
RequestType.NetworkGetExecutionTime = new RequestType(78);

/**
 * Pause the Token
 */
RequestType.TokenPause = new RequestType(79);

/**
 * Unpause the Token
 */
RequestType.TokenUnpause = new RequestType(80);

/**
 * Approve allowance for a spender relative to the owner account
 */
RequestType.CryptoApproveAllowance = new RequestType(81);

/**
 * Deletes granted allowances on owner account
 */
RequestType.CryptoDeleteAllowance = new RequestType(82);

/**
 * Gets all the information about an account, including balance and allowances. This does not get the list of
 * account records.
 */
RequestType.GetAccountDetails = new RequestType(83);

/**
 * Ethereum Transaction
 */
RequestType.EthereumTransaction = new RequestType(84);

/**
 * Updates the staking info at the end of staking period to indicate new staking period has started.
 */
RequestType.NodeStakeUpdate = new RequestType(85);

/**
 * Generates a pseudorandom number.
 */
RequestType.Prng = new RequestType(86);

/**
 * Get a record for a transaction (lasts 180 seconds)
 */
RequestType.TransactionGetFastRecord = new RequestType(87);

/**
 * Update the metadata of one or more NFT's of a specific token type.
 */
RequestType.TokenUpdateNfts = new RequestType(88);

/**
 * A transaction body for a `createNode` request.
 */
RequestType.NodeCreate = new RequestType(89);

/**
 * A transaction body for an `updateNode` request.
 */
RequestType.NodeUpdate = new RequestType(90);

/**
 * A transaction body for a `deleteNode` request.
 */
RequestType.NodeDelete = new RequestType(91);

/**
 * Transfer one or more token balances held by the requesting account to the treasury for each token type.
 */
RequestType.TokenReject = new RequestType(92);

/**
 * Airdrop one or more tokens to one or more accounts.
 */
RequestType.TokenAirdrop = new RequestType(93);

/**
 * Remove one or more pending airdrops from state on behalf of the sender(s) for each airdrop.
 */
RequestType.TokenCancelAirdrop = new RequestType(94);

/**
 * Claim one or more pending airdrops
 */
RequestType.TokenClaimAirdrop = new RequestType(95);

/**
 * (TSS) Messages for a candidate roster.
 */
RequestType.TssMessage = new RequestType(96);

/**
 * Vote on the validity of Threshold Signature Scheme (TSS)
 */
RequestType.TssVote = new RequestType(97);

/**
 * Communicates a node's signature of a block hash
 * using its private share within the TSS process
 */
RequestType.TssShareSignature = new RequestType(98);

/**
 * Submit a node public tss encryption key as part of the Threshold Signature Scheme (TSS).
 */
RequestType.TssEncryptionKey = new RequestType(99);

/**
 * Submit a signature of a state root hash gossiped to other nodes
 */
RequestType.StateSignatureTransaction = new RequestType(100);

/**
 * Sign a particular history assembly.
 */
RequestType.HistoryAssemblySignature = new RequestType(104);

/**
 * Publish a roster history proof key to the network.
 */
RequestType.HistoryProofKeyPublication = new RequestType(105);

/**
 * Vote for a particular history proof.
 */
RequestType.HistoryProofVote = new RequestType(106);
// Filename: src/Signer.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./LedgerId.js").default} LedgerId
 * @typedef {import("./SignerSignature.js").default} SignerSignature
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
 * @typedef {import("./account/AccountId.js").default} AccountId
 * @typedef {import("./account/AccountBalance.js").default} AccountBalance
 * @typedef {import("./account/AccountInfo.js").default} AccountInfo
 * @typedef {import("./Key.js").default} Key
 */

/**
 * @template {any} O
 * @typedef {import("./query/Query.js").default<O>} Query<O>
 */

/**
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
 */

/**
 * @typedef {object} Signer
 * @property {() => LedgerId?} getLedgerId
 * @property {() => AccountId} getAccountId
 * @property {() => Key} [getAccountKey]
 * @property {() => {[key: string]: (string | AccountId)}} getNetwork
 * @property {() => string[]} getMirrorNetwork
 * @property {(messages: Uint8Array[]) => Promise<SignerSignature[]>} sign
 * @property {() => Promise<AccountBalance>} getAccountBalance
 * @property {() => Promise<AccountInfo>} getAccountInfo
 * @property {() => Promise<TransactionRecord[]>} getAccountRecords
 * @property {<T extends Transaction>(transaction: T) => Promise<T>} signTransaction
 * @property {<T extends Transaction>(transaction: T) => Promise<T>} checkTransaction
 * @property {<T extends Transaction>(transaction: T) => Promise<T>} populateTransaction
 * @property {<RequestT, ResponseT, OutputT>(request: Executable<RequestT, ResponseT, OutputT>) => Promise<OutputT>} call
 */

export default {};
// Filename: src/SignerSignature.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./PublicKey.js").default} PublicKey
 * @typedef {import("./account/AccountId.js").default} AccountId
 */

/**
 * Represents a signature associated with a signer in the Hedera network.
 *
 * The `SignerSignature` class encapsulates the public key, signature, and account ID
 * of a signer. It is used to manage and validate signatures in transactions, ensuring
 * that the correct signers are associated with the transaction data.
 */
export default class SignerSignature {
    /**
     * @param {object} props
     * @param {PublicKey} props.publicKey
     * @param {Uint8Array} props.signature
     * @param {AccountId} props.accountId
     */
    constructor(props) {
        this.publicKey = props.publicKey;
        this.signature = props.signature;
        this.accountId = props.accountId;
    }
}
// Filename: src/StakingInfo.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./account/AccountId.js";
import Hbar from "./Hbar.js";
import Timestamp from "./Timestamp.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("long")} Long
 */

/**
 * @typedef {object} StakingInfoJson
 * @property {boolean} declineStakingReward
 * @property {?string} stakePeriodStart
 * @property {?string} pendingReward
 * @property {?string} stakedToMe
 * @property {?string} stakedAccountId
 * @property {?string} stakedNodeId
 */

/**
 * Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
 */
export default class StakingInfo {
    /**
     * @private
     * @param {object} props
     * @param {boolean} props.declineStakingReward
     * @param {?Timestamp} props.stakePeriodStart
     * @param {?Hbar} props.pendingReward
     * @param {?Hbar} props.stakedToMe
     * @param {?AccountId} props.stakedAccountId
     * @param {?Long} props.stakedNodeId
     */
    constructor(props) {
        /**
         * If true, this account or contract declined to receive a staking reward.
         *
         * @readonly
         */
        this.declineStakingReward = props.declineStakingReward;

        /**
         * The staking period during which either the staking settings for this
         * account or contract changed (such as starting staking or changing
         * staked_node_id) or the most recent reward was earned, whichever is
         * later. If this account or contract is not currently staked to a
         * node, then this field is not set.
         *
         * @readonly
         */
        this.stakePeriodStart = props.stakePeriodStart;

        /**
         * The amount in tinybars that will be received in the next reward
         * situation.
         *
         * @readonly
         */
        this.pendingReward = props.pendingReward;

        /**
         * The total of balance of all accounts staked to this account or contract.
         *
         * @readonly
         */
        this.stakedToMe = props.stakedToMe;

        /**
         * The account to which this account or contract is staking.
         *
         * @readonly
         */
        this.stakedAccountId = props.stakedAccountId;

        /**
         * The ID of the node this account or contract is staked to.
         *
         * @readonly
         */
        this.stakedNodeId = props.stakedNodeId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IStakingInfo} info
     * @returns {StakingInfo}
     */
    static _fromProtobuf(info) {
        return new StakingInfo({
            declineStakingReward: info.declineReward == true,
            stakePeriodStart:
                info.stakePeriodStart != null
                    ? Timestamp._fromProtobuf(info.stakePeriodStart)
                    : null,
            pendingReward:
                info.pendingReward != null
                    ? Hbar.fromTinybars(info.pendingReward)
                    : null,
            stakedToMe:
                info.stakedToMe != null
                    ? Hbar.fromTinybars(info.stakedToMe)
                    : null,
            stakedAccountId:
                info.stakedAccountId != null
                    ? AccountId._fromProtobuf(info.stakedAccountId)
                    : null,
            stakedNodeId: info.stakedNodeId != null ? info.stakedNodeId : null,
        });
    }

    /**
     * @returns {HieroProto.proto.IStakingInfo}
     */
    _toProtobuf() {
        return {
            declineReward: this.declineStakingReward,
            stakePeriodStart:
                this.stakePeriodStart != null
                    ? this.stakePeriodStart._toProtobuf()
                    : null,
            pendingReward:
                this.pendingReward != null
                    ? this.pendingReward.toTinybars()
                    : null,
            stakedToMe:
                this.stakedToMe != null ? this.stakedToMe.toTinybars() : null,
            stakedAccountId:
                this.stakedAccountId != null
                    ? this.stakedAccountId._toProtobuf()
                    : null,
            stakedNodeId: this.stakedNodeId,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {StakingInfo}
     */
    static fromBytes(bytes) {
        return StakingInfo._fromProtobuf(
            HieroProto.proto.StakingInfo.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.StakingInfo.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {StakingInfoJson}
     */
    toJSON() {
        return {
            declineStakingReward: this.declineStakingReward,
            stakePeriodStart:
                this.stakePeriodStart != null
                    ? this.stakePeriodStart.toString()
                    : null,
            pendingReward:
                this.pendingReward != null
                    ? this.pendingReward.toString()
                    : null,
            stakedToMe:
                this.stakedToMe != null ? this.stakedToMe.toString() : null,
            stakedAccountId:
                this.stakedAccountId != null
                    ? this.stakedAccountId.toString()
                    : null,
            stakedNodeId:
                this.stakedNodeId != null ? this.stakedNodeId.toString() : null,
        };
    }
}
// Filename: src/Status.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ResponseCodeEnum} HieroProto.proto.ResponseCodeEnum
 */

export default class Status {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case Status.Ok:
                return "OK";
            case Status.InvalidTransaction:
                return "INVALID_TRANSACTION";
            case Status.PayerAccountNotFound:
                return "PAYER_ACCOUNT_NOT_FOUND";
            case Status.InvalidNodeAccount:
                return "INVALID_NODE_ACCOUNT";
            case Status.TransactionExpired:
                return "TRANSACTION_EXPIRED";
            case Status.InvalidTransactionStart:
                return "INVALID_TRANSACTION_START";
            case Status.InvalidTransactionDuration:
                return "INVALID_TRANSACTION_DURATION";
            case Status.InvalidSignature:
                return "INVALID_SIGNATURE";
            case Status.MemoTooLong:
                return "MEMO_TOO_LONG";
            case Status.InsufficientTxFee:
                return "INSUFFICIENT_TX_FEE";
            case Status.InsufficientPayerBalance:
                return "INSUFFICIENT_PAYER_BALANCE";
            case Status.DuplicateTransaction:
                return "DUPLICATE_TRANSACTION";
            case Status.Busy:
                return "BUSY";
            case Status.NotSupported:
                return "NOT_SUPPORTED";
            case Status.InvalidFileId:
                return "INVALID_FILE_ID";
            case Status.InvalidAccountId:
                return "INVALID_ACCOUNT_ID";
            case Status.InvalidContractId:
                return "INVALID_CONTRACT_ID";
            case Status.InvalidTransactionId:
                return "INVALID_TRANSACTION_ID";
            case Status.ReceiptNotFound:
                return "RECEIPT_NOT_FOUND";
            case Status.RecordNotFound:
                return "RECORD_NOT_FOUND";
            case Status.InvalidSolidityId:
                return "INVALID_SOLIDITY_ID";
            case Status.Unknown:
                return "UNKNOWN";
            case Status.Success:
                return "SUCCESS";
            case Status.FailInvalid:
                return "FAIL_INVALID";
            case Status.FailFee:
                return "FAIL_FEE";
            case Status.FailBalance:
                return "FAIL_BALANCE";
            case Status.KeyRequired:
                return "KEY_REQUIRED";
            case Status.BadEncoding:
                return "BAD_ENCODING";
            case Status.InsufficientAccountBalance:
                return "INSUFFICIENT_ACCOUNT_BALANCE";
            case Status.InvalidSolidityAddress:
                return "INVALID_SOLIDITY_ADDRESS";
            case Status.InsufficientGas:
                return "INSUFFICIENT_GAS";
            case Status.ContractSizeLimitExceeded:
                return "CONTRACT_SIZE_LIMIT_EXCEEDED";
            case Status.LocalCallModificationException:
                return "LOCAL_CALL_MODIFICATION_EXCEPTION";
            case Status.ContractRevertExecuted:
                return "CONTRACT_REVERT_EXECUTED";
            case Status.ContractExecutionException:
                return "CONTRACT_EXECUTION_EXCEPTION";
            case Status.InvalidReceivingNodeAccount:
                return "INVALID_RECEIVING_NODE_ACCOUNT";
            case Status.MissingQueryHeader:
                return "MISSING_QUERY_HEADER";
            case Status.AccountUpdateFailed:
                return "ACCOUNT_UPDATE_FAILED";
            case Status.InvalidKeyEncoding:
                return "INVALID_KEY_ENCODING";
            case Status.NullSolidityAddress:
                return "NULL_SOLIDITY_ADDRESS";
            case Status.ContractUpdateFailed:
                return "CONTRACT_UPDATE_FAILED";
            case Status.InvalidQueryHeader:
                return "INVALID_QUERY_HEADER";
            case Status.InvalidFeeSubmitted:
                return "INVALID_FEE_SUBMITTED";
            case Status.InvalidPayerSignature:
                return "INVALID_PAYER_SIGNATURE";
            case Status.KeyNotProvided:
                return "KEY_NOT_PROVIDED";
            case Status.InvalidExpirationTime:
                return "INVALID_EXPIRATION_TIME";
            case Status.NoWaclKey:
                return "NO_WACL_KEY";
            case Status.FileContentEmpty:
                return "FILE_CONTENT_EMPTY";
            case Status.InvalidAccountAmounts:
                return "INVALID_ACCOUNT_AMOUNTS";
            case Status.EmptyTransactionBody:
                return "EMPTY_TRANSACTION_BODY";
            case Status.InvalidTransactionBody:
                return "INVALID_TRANSACTION_BODY";
            case Status.InvalidSignatureTypeMismatchingKey:
                return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";
            case Status.InvalidSignatureCountMismatchingKey:
                return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";
            case Status.EmptyLiveHashBody:
                return "EMPTY_LIVE_HASH_BODY";
            case Status.EmptyLiveHash:
                return "EMPTY_LIVE_HASH";
            case Status.EmptyLiveHashKeys:
                return "EMPTY_LIVE_HASH_KEYS";
            case Status.InvalidLiveHashSize:
                return "INVALID_LIVE_HASH_SIZE";
            case Status.EmptyQueryBody:
                return "EMPTY_QUERY_BODY";
            case Status.EmptyLiveHashQuery:
                return "EMPTY_LIVE_HASH_QUERY";
            case Status.LiveHashNotFound:
                return "LIVE_HASH_NOT_FOUND";
            case Status.AccountIdDoesNotExist:
                return "ACCOUNT_ID_DOES_NOT_EXIST";
            case Status.LiveHashAlreadyExists:
                return "LIVE_HASH_ALREADY_EXISTS";
            case Status.InvalidFileWacl:
                return "INVALID_FILE_WACL";
            case Status.SerializationFailed:
                return "SERIALIZATION_FAILED";
            case Status.TransactionOversize:
                return "TRANSACTION_OVERSIZE";
            case Status.TransactionTooManyLayers:
                return "TRANSACTION_TOO_MANY_LAYERS";
            case Status.ContractDeleted:
                return "CONTRACT_DELETED";
            case Status.PlatformNotActive:
                return "PLATFORM_NOT_ACTIVE";
            case Status.KeyPrefixMismatch:
                return "KEY_PREFIX_MISMATCH";
            case Status.PlatformTransactionNotCreated:
                return "PLATFORM_TRANSACTION_NOT_CREATED";
            case Status.InvalidRenewalPeriod:
                return "INVALID_RENEWAL_PERIOD";
            case Status.InvalidPayerAccountId:
                return "INVALID_PAYER_ACCOUNT_ID";
            case Status.AccountDeleted:
                return "ACCOUNT_DELETED";
            case Status.FileDeleted:
                return "FILE_DELETED";
            case Status.AccountRepeatedInAccountAmounts:
                return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";
            case Status.SettingNegativeAccountBalance:
                return "SETTING_NEGATIVE_ACCOUNT_BALANCE";
            case Status.ObtainerRequired:
                return "OBTAINER_REQUIRED";
            case Status.ObtainerSameContractId:
                return "OBTAINER_SAME_CONTRACT_ID";
            case Status.ObtainerDoesNotExist:
                return "OBTAINER_DOES_NOT_EXIST";
            case Status.ModifyingImmutableContract:
                return "MODIFYING_IMMUTABLE_CONTRACT";
            case Status.FileSystemException:
                return "FILE_SYSTEM_EXCEPTION";
            case Status.AutorenewDurationNotInRange:
                return "AUTORENEW_DURATION_NOT_IN_RANGE";
            case Status.ErrorDecodingBytestring:
                return "ERROR_DECODING_BYTESTRING";
            case Status.ContractFileEmpty:
                return "CONTRACT_FILE_EMPTY";
            case Status.ContractBytecodeEmpty:
                return "CONTRACT_BYTECODE_EMPTY";
            case Status.InvalidInitialBalance:
                return "INVALID_INITIAL_BALANCE";
            case Status.InvalidReceiveRecordThreshold:
                return "INVALID_RECEIVE_RECORD_THRESHOLD";
            case Status.InvalidSendRecordThreshold:
                return "INVALID_SEND_RECORD_THRESHOLD";
            case Status.AccountIsNotGenesisAccount:
                return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";
            case Status.PayerAccountUnauthorized:
                return "PAYER_ACCOUNT_UNAUTHORIZED";
            case Status.InvalidFreezeTransactionBody:
                return "INVALID_FREEZE_TRANSACTION_BODY";
            case Status.FreezeTransactionBodyNotFound:
                return "FREEZE_TRANSACTION_BODY_NOT_FOUND";
            case Status.TransferListSizeLimitExceeded:
                return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
            case Status.ResultSizeLimitExceeded:
                return "RESULT_SIZE_LIMIT_EXCEEDED";
            case Status.NotSpecialAccount:
                return "NOT_SPECIAL_ACCOUNT";
            case Status.ContractNegativeGas:
                return "CONTRACT_NEGATIVE_GAS";
            case Status.ContractNegativeValue:
                return "CONTRACT_NEGATIVE_VALUE";
            case Status.InvalidFeeFile:
                return "INVALID_FEE_FILE";
            case Status.InvalidExchangeRateFile:
                return "INVALID_EXCHANGE_RATE_FILE";
            case Status.InsufficientLocalCallGas:
                return "INSUFFICIENT_LOCAL_CALL_GAS";
            case Status.EntityNotAllowedToDelete:
                return "ENTITY_NOT_ALLOWED_TO_DELETE";
            case Status.AuthorizationFailed:
                return "AUTHORIZATION_FAILED";
            case Status.FileUploadedProtoInvalid:
                return "FILE_UPLOADED_PROTO_INVALID";
            case Status.FileUploadedProtoNotSavedToDisk:
                return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";
            case Status.FeeScheduleFilePartUploaded:
                return "FEE_SCHEDULE_FILE_PART_UPLOADED";
            case Status.ExchangeRateChangeLimitExceeded:
                return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";
            case Status.MaxContractStorageExceeded:
                return "MAX_CONTRACT_STORAGE_EXCEEDED";
            case Status.TransferAccountSameAsDeleteAccount:
                return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";
            case Status.TotalLedgerBalanceInvalid:
                return "TOTAL_LEDGER_BALANCE_INVALID";
            case Status.ExpirationReductionNotAllowed:
                return "EXPIRATION_REDUCTION_NOT_ALLOWED";
            case Status.MaxGasLimitExceeded:
                return "MAX_GAS_LIMIT_EXCEEDED";
            case Status.MaxFileSizeExceeded:
                return "MAX_FILE_SIZE_EXCEEDED";
            case Status.ReceiverSigRequired:
                return "RECEIVER_SIG_REQUIRED";
            case Status.InvalidTopicId:
                return "INVALID_TOPIC_ID";
            case Status.InvalidAdminKey:
                return "INVALID_ADMIN_KEY";
            case Status.InvalidSubmitKey:
                return "INVALID_SUBMIT_KEY";
            case Status.Unauthorized:
                return "UNAUTHORIZED";
            case Status.InvalidTopicMessage:
                return "INVALID_TOPIC_MESSAGE";
            case Status.InvalidAutorenewAccount:
                return "INVALID_AUTORENEW_ACCOUNT";
            case Status.AutorenewAccountNotAllowed:
                return "AUTORENEW_ACCOUNT_NOT_ALLOWED";
            case Status.TopicExpired:
                return "TOPIC_EXPIRED";
            case Status.InvalidChunkNumber:
                return "INVALID_CHUNK_NUMBER";
            case Status.InvalidChunkTransactionId:
                return "INVALID_CHUNK_TRANSACTION_ID";
            case Status.AccountFrozenForToken:
                return "ACCOUNT_FROZEN_FOR_TOKEN";
            case Status.TokensPerAccountLimitExceeded:
                return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";
            case Status.InvalidTokenId:
                return "INVALID_TOKEN_ID";
            case Status.InvalidTokenDecimals:
                return "INVALID_TOKEN_DECIMALS";
            case Status.InvalidTokenInitialSupply:
                return "INVALID_TOKEN_INITIAL_SUPPLY";
            case Status.InvalidTreasuryAccountForToken:
                return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";
            case Status.InvalidTokenSymbol:
                return "INVALID_TOKEN_SYMBOL";
            case Status.TokenHasNoFreezeKey:
                return "TOKEN_HAS_NO_FREEZE_KEY";
            case Status.TransfersNotZeroSumForToken:
                return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";
            case Status.MissingTokenSymbol:
                return "MISSING_TOKEN_SYMBOL";
            case Status.TokenSymbolTooLong:
                return "TOKEN_SYMBOL_TOO_LONG";
            case Status.AccountKycNotGrantedForToken:
                return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";
            case Status.TokenHasNoKycKey:
                return "TOKEN_HAS_NO_KYC_KEY";
            case Status.InsufficientTokenBalance:
                return "INSUFFICIENT_TOKEN_BALANCE";
            case Status.TokenWasDeleted:
                return "TOKEN_WAS_DELETED";
            case Status.TokenHasNoSupplyKey:
                return "TOKEN_HAS_NO_SUPPLY_KEY";
            case Status.TokenHasNoWipeKey:
                return "TOKEN_HAS_NO_WIPE_KEY";
            case Status.InvalidTokenMintAmount:
                return "INVALID_TOKEN_MINT_AMOUNT";
            case Status.InvalidTokenBurnAmount:
                return "INVALID_TOKEN_BURN_AMOUNT";
            case Status.TokenNotAssociatedToAccount:
                return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";
            case Status.CannotWipeTokenTreasuryAccount:
                return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";
            case Status.InvalidKycKey:
                return "INVALID_KYC_KEY";
            case Status.InvalidWipeKey:
                return "INVALID_WIPE_KEY";
            case Status.InvalidFreezeKey:
                return "INVALID_FREEZE_KEY";
            case Status.InvalidSupplyKey:
                return "INVALID_SUPPLY_KEY";
            case Status.MissingTokenName:
                return "MISSING_TOKEN_NAME";
            case Status.TokenNameTooLong:
                return "TOKEN_NAME_TOO_LONG";
            case Status.InvalidWipingAmount:
                return "INVALID_WIPING_AMOUNT";
            case Status.TokenIsImmutable:
                return "TOKEN_IS_IMMUTABLE";
            case Status.TokenAlreadyAssociatedToAccount:
                return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";
            case Status.TransactionRequiresZeroTokenBalances:
                return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";
            case Status.AccountIsTreasury:
                return "ACCOUNT_IS_TREASURY";
            case Status.TokenIdRepeatedInTokenList:
                return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";
            case Status.TokenTransferListSizeLimitExceeded:
                return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
            case Status.EmptyTokenTransferBody:
                return "EMPTY_TOKEN_TRANSFER_BODY";
            case Status.EmptyTokenTransferAccountAmounts:
                return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";
            case Status.InvalidScheduleId:
                return "INVALID_SCHEDULE_ID";
            case Status.ScheduleIsImmutable:
                return "SCHEDULE_IS_IMMUTABLE";
            case Status.InvalidSchedulePayerId:
                return "INVALID_SCHEDULE_PAYER_ID";
            case Status.InvalidScheduleAccountId:
                return "INVALID_SCHEDULE_ACCOUNT_ID";
            case Status.NoNewValidSignatures:
                return "NO_NEW_VALID_SIGNATURES";
            case Status.UnresolvableRequiredSigners:
                return "UNRESOLVABLE_REQUIRED_SIGNERS";
            case Status.ScheduledTransactionNotInWhitelist:
                return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST";
            case Status.SomeSignaturesWereInvalid:
                return "SOME_SIGNATURES_WERE_INVALID";
            case Status.TransactionIdFieldNotAllowed:
                return "TRANSACTION_ID_FIELD_NOT_ALLOWED";
            case Status.IdenticalScheduleAlreadyCreated:
                return "IDENTICAL_SCHEDULE_ALREADY_CREATED";
            case Status.InvalidZeroByteInString:
                return "INVALID_ZERO_BYTE_IN_STRING";
            case Status.ScheduleAlreadyDeleted:
                return "SCHEDULE_ALREADY_DELETED";
            case Status.ScheduleAlreadyExecuted:
                return "SCHEDULE_ALREADY_EXECUTED";
            case Status.MessageSizeTooLarge:
                return "MESSAGE_SIZE_TOO_LARGE";
            case Status.OperationRepeatedInBucketGroups:
                return "OPERATION_REPEATED_IN_BUCKET_GROUPS";
            case Status.BucketCapacityOverflow:
                return "BUCKET_CAPACITY_OVERFLOW";
            case Status.NodeCapacityNotSufficientForOperation:
                return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION";
            case Status.BucketHasNoThrottleGroups:
                return "BUCKET_HAS_NO_THROTTLE_GROUPS";
            case Status.ThrottleGroupHasZeroOpsPerSec:
                return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC";
            case Status.SuccessButMissingExpectedOperation:
                return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION";
            case Status.UnparseableThrottleDefinitions:
                return "UNPARSEABLE_THROTTLE_DEFINITIONS";
            case Status.InvalidThrottleDefinitions:
                return "INVALID_THROTTLE_DEFINITIONS";
            case Status.AccountExpiredAndPendingRemoval:
                return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL";
            case Status.InvalidTokenMaxSupply:
                return "INVALID_TOKEN_MAX_SUPPLY";
            case Status.InvalidTokenNftSerialNumber:
                return "INVALID_TOKEN_NFT_SERIAL_NUMBER";
            case Status.InvalidNftId:
                return "INVALID_NFT_ID";
            case Status.MetadataTooLong:
                return "METADATA_TOO_LONG";
            case Status.BatchSizeLimitExceeded:
                return "BATCH_SIZE_LIMIT_EXCEEDED";
            case Status.InvalidQueryRange:
                return "INVALID_QUERY_RANGE";
            case Status.FractionDividesByZero:
                return "FRACTION_DIVIDES_BY_ZERO";
            case Status.InsufficientPayerBalanceForCustomFee:
                return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE";
            case Status.CustomFeesListTooLong:
                return "CUSTOM_FEES_LIST_TOO_LONG";
            case Status.InvalidCustomFeeCollector:
                return "INVALID_CUSTOM_FEE_COLLECTOR";
            case Status.InvalidTokenIdInCustomFees:
                return "INVALID_TOKEN_ID_IN_CUSTOM_FEES";
            case Status.TokenNotAssociatedToFeeCollector:
                return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR";
            case Status.TokenMaxSupplyReached:
                return "TOKEN_MAX_SUPPLY_REACHED";
            case Status.SenderDoesNotOwnNftSerialNo:
                return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO";
            case Status.CustomFeeNotFullySpecified:
                return "CUSTOM_FEE_NOT_FULLY_SPECIFIED";
            case Status.CustomFeeMustBePositive:
                return "CUSTOM_FEE_MUST_BE_POSITIVE";
            case Status.TokenHasNoFeeScheduleKey:
                return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY";
            case Status.CustomFeeOutsideNumericRange:
                return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE";
            case Status.RoyaltyFractionCannotExceedOne:
                return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE";
            case Status.FractionalFeeMaxAmountLessThanMinAmount:
                return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT";
            case Status.CustomScheduleAlreadyHasNoFees:
                return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES";
            case Status.CustomFeeDenominationMustBeFungibleCommon:
                return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON";
            case Status.CustomFractionalFeeOnlyAllowedForFungibleCommon:
                return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
            case Status.InvalidCustomFeeScheduleKey:
                return "INVALID_CUSTOM_FEE_SCHEDULE_KEY";
            case Status.InvalidTokenMintMetadata:
                return "INVALID_TOKEN_MINT_METADATA";
            case Status.InvalidTokenBurnMetadata:
                return "INVALID_TOKEN_BURN_METADATA";
            case Status.CurrentTreasuryStillOwnsNfts:
                return "CURRENT_TREASURY_STILL_OWNS_NFTS";
            case Status.AccountStillOwnsNfts:
                return "ACCOUNT_STILL_OWNS_NFTS";
            case Status.TreasuryMustOwnBurnedNft:
                return "TREASURY_MUST_OWN_BURNED_NFT";
            case Status.AccountDoesNotOwnWipedNft:
                return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT";
            case Status.AccountAmountTransfersOnlyAllowedForFungibleCommon:
                return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
            case Status.MaxNftsInPriceRegimeHaveBeenMinted:
                return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED";
            case Status.PayerAccountDeleted:
                return "PAYER_ACCOUNT_DELETED";
            case Status.CustomFeeChargingExceededMaxRecursionDepth:
                return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH";
            case Status.CustomFeeChargingExceededMaxAccountAmounts:
                return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS";
            case Status.InsufficientSenderAccountBalanceForCustomFee:
                return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE";
            case Status.SerialNumberLimitReached:
                return "SERIAL_NUMBER_LIMIT_REACHED";
            case Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
                return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
            case Status.NoRemainingAutomaticAssociations:
                return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS";
            case Status.ExistingAutomaticAssociationsExceedGivenLimit:
                return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT";
            case Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit:
                return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT";
            case Status.TokenIsPaused:
                return "TOKEN_IS_PAUSED";
            case Status.TokenHasNoPauseKey:
                return "TOKEN_HAS_NO_PAUSE_KEY";
            case Status.InvalidPauseKey:
                return "INVALID_PAUSE_KEY";
            case Status.FreezeUpdateFileDoesNotExist:
                return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST";
            case Status.FreezeUpdateFileHashDoesNotMatch:
                return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH";
            case Status.NoUpgradeHasBeenPrepared:
                return "NO_UPGRADE_HAS_BEEN_PREPARED";
            case Status.NoFreezeIsScheduled:
                return "NO_FREEZE_IS_SCHEDULED";
            case Status.UpdateFileHashChangedSincePrepareUpgrade:
                return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE";
            case Status.FreezeStartTimeMustBeFuture:
                return "FREEZE_START_TIME_MUST_BE_FUTURE";
            case Status.PreparedUpdateFileIsImmutable:
                return "PREPARED_UPDATE_FILE_IS_IMMUTABLE";
            case Status.FreezeAlreadyScheduled:
                return "FREEZE_ALREADY_SCHEDULED";
            case Status.FreezeUpgradeInProgress:
                return "FREEZE_UPGRADE_IN_PROGRESS";
            case Status.UpdateFileIdDoesNotMatchPrepared:
                return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED";
            case Status.UpdateFileHashDoesNotMatchPrepared:
                return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED";
            case Status.ConsensusGasExhausted:
                return "CONSENSUS_GAS_EXHAUSTED";
            case Status.RevertedSuccess:
                return "REVERTED_SUCCESS";
            case Status.MaxStorageInPriceRegimeHasBeenUsed:
                return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED";
            case Status.InvalidAliasKey:
                return "INVALID_ALIAS_KEY";
            case Status.UnexpectedTokenDecimals:
                return "UNEXPECTED_TOKEN_DECIMALS";
            case Status.InvalidProxyAccountId:
                return "INVALID_PROXY_ACCOUNT_ID";
            case Status.InvalidTransferAccountId:
                return "INVALID_TRANSFER_ACCOUNT_ID";
            case Status.InvalidFeeCollectorAccountId:
                return "INVALID_FEE_COLLECTOR_ACCOUNT_ID";
            case Status.AliasIsImmutable:
                return "ALIAS_IS_IMMUTABLE";
            case Status.SpenderAccountSameAsOwner:
                return "SPENDER_ACCOUNT_SAME_AS_OWNER";
            case Status.AmountExceedsTokenMaxSupply:
                return "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY";
            case Status.NegativeAllowanceAmount:
                return "NEGATIVE_ALLOWANCE_AMOUNT";
            case Status.CannotApproveForAllFungibleCommon:
                return "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON";
            case Status.SpenderDoesNotHaveAllowance:
                return "SPENDER_DOES_NOT_HAVE_ALLOWANCE";
            case Status.AmountExceedsAllowance:
                return "AMOUNT_EXCEEDS_ALLOWANCE";
            case Status.MaxAllowancesExceeded:
                return "MAX_ALLOWANCES_EXCEEDED";
            case Status.EmptyAllowances:
                return "EMPTY_ALLOWANCES";
            case Status.SpenderAccountRepeatedInAllowances:
                return "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES";
            case Status.RepeatedSerialNumsInNftAllowances:
                return "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES";
            case Status.FungibleTokenInNftAllowances:
                return "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES";
            case Status.NftInFungibleTokenAllowances:
                return "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES";
            case Status.InvalidAllowanceOwnerId:
                return "INVALID_ALLOWANCE_OWNER_ID";
            case Status.InvalidAllowanceSpenderId:
                return "INVALID_ALLOWANCE_SPENDER_ID";
            case Status.RepeatedAllowancesToDelete:
                return "REPEATED_ALLOWANCES_TO_DELETE";
            case Status.InvalidDelegatingSpender:
                return "INVALID_DELEGATING_SPENDER";
            case Status.DelegatingSpenderCannotGrantApproveForAll:
                return "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL";
            case Status.DelegatingSpenderDoesNotHaveApproveForAll:
                return "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL";
            case Status.ScheduleExpirationTimeTooFarInFuture:
                return "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE";
            case Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime:
                return "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME";
            case Status.ScheduleFutureThrottleExceeded:
                return "SCHEDULE_FUTURE_THROTTLE_EXCEEDED";
            case Status.ScheduleFutureGasLimitExceeded:
                return "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED";
            case Status.InvalidEthereumTransaction:
                return "INVALID_ETHEREUM_TRANSACTION";
            case Status.WrongChainId:
                return "WRONG_CHAIN_ID";
            case Status.WrongNonce:
                return "WRONG_NONCE";
            case Status.AccessListUnsupported:
                return "ACCESS_LIST_UNSUPPORTED";
            case Status.SchedulePendingExpiration:
                return "SCHEDULE_PENDING_EXPIRATION";
            case Status.ContractIsTokenTreasury:
                return "CONTRACT_IS_TOKEN_TREASURY";
            case Status.ContractHasNonZeroTokenBalances:
                return "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES";
            case Status.ContractExpiredAndPendingRemoval:
                return "CONTRACT_EXPIRED_AND_PENDING_REMOVAL";
            case Status.ContractHasNoAutoRenewAccount:
                return "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT";
            case Status.PermanentRemovalRequiresSystemInitiation:
                return "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION";
            case Status.ProxyAccountIdFieldIsDeprecated:
                return "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED";
            case Status.SelfStakingIsNotAllowed:
                return "SELF_STAKING_IS_NOT_ALLOWED";
            case Status.InvalidStakingId:
                return "INVALID_STAKING_ID";
            case Status.StakingNotEnabled:
                return "STAKING_NOT_ENABLED";
            case Status.InvalidPrngRange:
                return "INVALID_PRNG_RANGE";
            case Status.MaxEntitiesInPriceRegimeHaveBeenCreated:
                return "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED";
            case Status.InvalidFullPrefixSignatureForPrecompile:
                return "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE";
            case Status.InsufficientBalancesForStorageRent:
                return "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT";
            case Status.MaxChildRecordsExceeded:
                return "MAX_CHILD_RECORDS_EXCEEDED";
            case Status.InsufficientBalancesForRenewalFees:
                return "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES";
            case Status.TransactionHasUnknownFields:
                return "TRANSACTION_HAS_UNKNOWN_FIELDS";
            case Status.AccountIsImmutable:
                return "ACCOUNT_IS_IMMUTABLE";
            case Status.AliasAlreadyAssigned:
                return "ALIAS_ALREADY_ASSIGNED";
            case Status.InvalidMetadataKey:
                return "INVALID_METADATA_KEY";
            case Status.TokenHasNoMetadataKey:
                return "TOKEN_HAS_NO_METADATA_KEY";
            case Status.MissingTokenMetadata:
                return "MISSING_TOKEN_METADATA";
            case Status.MissingSerialNumbers:
                return "MISSING_SERIAL_NUMBERS";
            case Status.TokenHasNoAdminKey:
                return "TOKEN_HAS_NO_ADMIN_KEY";
            case Status.NodeDeleted:
                return "NODE_DELETED";
            case Status.InvalidNodeId:
                return "INVALID_NODE_ID";
            case Status.InvalidGossipEndpoint:
                return "INVALID_GOSSIP_ENDPOINT";
            case Status.InvalidNodeAccountId:
                return "INVALID_NODE_ACCOUNT_ID";
            case Status.InvalidNodeDescription:
                return "INVALID_NODE_DESCRIPTION";
            case Status.InvalidServiceEndpoint:
                return "INVALID_SERVICE_ENDPOINT";
            case Status.InvalidGossipCaCertificate:
                return "INVALID_GOSSIP_CA_CERTIFICATE";
            case Status.InvalidGrpcCertificate:
                return "INVALID_GRPC_CERTIFICATE";
            case Status.InvalidMaxAutoAssociations:
                return "INVALID_MAX_AUTO_ASSOCIATIONS";
            case Status.MaxNodesCreated:
                return "MAX_NODES_CREATED";
            case Status.IpFqdnCannotBeSetForSameEndpoint:
                return "IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT";
            case Status.GossipEndpointCannotHaveFqdn:
                return "GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN";
            case Status.FqdnSizeTooLarge:
                return "FQDN_SIZE_TOO_LARGE";
            case Status.InvalidEndpoint:
                return "INVALID_ENDPOINT";
            case Status.GossipEndpointsExceededLimit:
                return "GOSSIP_ENDPOINTS_EXCEEDED_LIMIT";
            case Status.ServiceEndpointsExceededLimit:
                return "SERVICE_ENDPOINTS_EXCEEDED_LIMIT";
            case Status.InvalidIpv4Address:
                return "INVALID_IPV4_ADDRESS";
            case Status.TokenReferenceRepeated:
                return "TOKEN_REFERENCE_REPEATED";
            case Status.InvalidOwnerId:
                return "INVALID_OWNER_ID";
            case Status.TokenReferenceListSizeLimitExceeded:
                return "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED";
            case Status.EmptyTokenReferenceList:
                return "EMPTY_TOKEN_REFERENCE_LIST";
            case Status.UpdateNodeAccountNotAllowed:
                return "UPDATE_NODE_ACCOUNT_NOT_ALLOWED";
            case Status.TokenHasNoMetadataOrSupplyKey:
                return "TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY";
            case Status.EmptyPendingAirdropIdList:
                return "EMPTY_PENDING_AIRDROP_ID_LIST";
            case Status.PendingAirdropIdRepeated:
                return "PENDING_AIRDROP_ID_REPEATED";
            case Status.MaxPendingAirdropIdExceeded:
                return "PENDING_AIRDROP_ID_LIST_TOO_LONG";
            case Status.PendingNftAirdropAlreadyExists:
                return "PENDING_NFT_AIRDROP_ALREADY_EXISTS";
            case Status.AccountHasPendingAirdrops:
                return "ACCOUNT_HAS_PENDING_AIRDROPS";
            case Status.ThrottledAtConsensus:
                return "THROTTLED_AT_CONSENSUS";
            case Status.InvalidPendingAirdropId:
                return "INVALID_PENDING_AIRDROP_ID";
            case Status.TokenAirdropWithFallbackRoyalty:
                return "TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY";
            case Status.InvalidTokenInPendingAirdrop:
                return "INVALID_TOKEN_IN_PENDING_AIRDROP";
            case Status.ScheduleExpiryIsBusy:
                return "SCHEDULE_EXPIRY_IS_BUSY";
            case Status.InvalidGrpcCertificateHash:
                return "INVALID_GRPC_CERTIFICATE_HASH";
            case Status.MissingExpiryTime:
                return "MISSING_EXPIRY_TIME";
            case Status.NoSchedulingAllowedAfterScheduledRecursion:
                return "NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION";
            case Status.RecursiveSchedulingLimitReached:
                return "RECURSIVE_SCHEDULING_LIMIT_REACHED";
            case Status.WaitingForLedgerId:
                return "WAITING_FOR_LEDGER_ID";
            case Status.MaxEntriesForFeeExemptKeyListExceeded:
                return "MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED";
            case Status.FeeExemptKeyListContainsDuplicatedKeys:
                return "FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS";
            case Status.InvalidKeyInFeeExemptKeyList:
                return "INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST";
            case Status.InvalidFeeScheduleKey:
                return "INVALID_FEE_SCHEDULE_KEY";
            case Status.FeeScheduleKeyCannotBeUpdated:
                return "FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED";
            case Status.FeeScheduleKeyNotSet:
                return "FEE_SCHEDULE_KEY_NOT_SET";
            case Status.MaxCustomFeeLimitExceeded:
                return "MAX_CUSTOM_FEE_LIMIT_EXCEEDED";
            case Status.NoValidMaxCustomFee:
                return "NO_VALID_MAX_CUSTOM_FEE";
            case Status.InvalidMaxCustomFees:
                return "INVALID_MAX_CUSTOM_FEES";
            case Status.DuplicateDenominationInMaxCustomFeeList:
                return "DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST";
            case Status.DuplicateAccountIdInMaxCustomFeeList:
                return "DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST";
            case Status.MaxCustomFeesIsNotSupported:
                return "MAX_CUSTOM_FEES_IS_NOT_SUPPORTED";

            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {Status}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return Status.Ok;
            case 1:
                return Status.InvalidTransaction;
            case 2:
                return Status.PayerAccountNotFound;
            case 3:
                return Status.InvalidNodeAccount;
            case 4:
                return Status.TransactionExpired;
            case 5:
                return Status.InvalidTransactionStart;
            case 6:
                return Status.InvalidTransactionDuration;
            case 7:
                return Status.InvalidSignature;
            case 8:
                return Status.MemoTooLong;
            case 9:
                return Status.InsufficientTxFee;
            case 10:
                return Status.InsufficientPayerBalance;
            case 11:
                return Status.DuplicateTransaction;
            case 12:
                return Status.Busy;
            case 13:
                return Status.NotSupported;
            case 14:
                return Status.InvalidFileId;
            case 15:
                return Status.InvalidAccountId;
            case 16:
                return Status.InvalidContractId;
            case 17:
                return Status.InvalidTransactionId;
            case 18:
                return Status.ReceiptNotFound;
            case 19:
                return Status.RecordNotFound;
            case 20:
                return Status.InvalidSolidityId;
            case 21:
                return Status.Unknown;
            case 22:
                return Status.Success;
            case 23:
                return Status.FailInvalid;
            case 24:
                return Status.FailFee;
            case 25:
                return Status.FailBalance;
            case 26:
                return Status.KeyRequired;
            case 27:
                return Status.BadEncoding;
            case 28:
                return Status.InsufficientAccountBalance;
            case 29:
                return Status.InvalidSolidityAddress;
            case 30:
                return Status.InsufficientGas;
            case 31:
                return Status.ContractSizeLimitExceeded;
            case 32:
                return Status.LocalCallModificationException;
            case 33:
                return Status.ContractRevertExecuted;
            case 34:
                return Status.ContractExecutionException;
            case 35:
                return Status.InvalidReceivingNodeAccount;
            case 36:
                return Status.MissingQueryHeader;
            case 37:
                return Status.AccountUpdateFailed;
            case 38:
                return Status.InvalidKeyEncoding;
            case 39:
                return Status.NullSolidityAddress;
            case 40:
                return Status.ContractUpdateFailed;
            case 41:
                return Status.InvalidQueryHeader;
            case 42:
                return Status.InvalidFeeSubmitted;
            case 43:
                return Status.InvalidPayerSignature;
            case 44:
                return Status.KeyNotProvided;
            case 45:
                return Status.InvalidExpirationTime;
            case 46:
                return Status.NoWaclKey;
            case 47:
                return Status.FileContentEmpty;
            case 48:
                return Status.InvalidAccountAmounts;
            case 49:
                return Status.EmptyTransactionBody;
            case 50:
                return Status.InvalidTransactionBody;
            case 51:
                return Status.InvalidSignatureTypeMismatchingKey;
            case 52:
                return Status.InvalidSignatureCountMismatchingKey;
            case 53:
                return Status.EmptyLiveHashBody;
            case 54:
                return Status.EmptyLiveHash;
            case 55:
                return Status.EmptyLiveHashKeys;
            case 56:
                return Status.InvalidLiveHashSize;
            case 57:
                return Status.EmptyQueryBody;
            case 58:
                return Status.EmptyLiveHashQuery;
            case 59:
                return Status.LiveHashNotFound;
            case 60:
                return Status.AccountIdDoesNotExist;
            case 61:
                return Status.LiveHashAlreadyExists;
            case 62:
                return Status.InvalidFileWacl;
            case 63:
                return Status.SerializationFailed;
            case 64:
                return Status.TransactionOversize;
            case 65:
                return Status.TransactionTooManyLayers;
            case 66:
                return Status.ContractDeleted;
            case 67:
                return Status.PlatformNotActive;
            case 68:
                return Status.KeyPrefixMismatch;
            case 69:
                return Status.PlatformTransactionNotCreated;
            case 70:
                return Status.InvalidRenewalPeriod;
            case 71:
                return Status.InvalidPayerAccountId;
            case 72:
                return Status.AccountDeleted;
            case 73:
                return Status.FileDeleted;
            case 74:
                return Status.AccountRepeatedInAccountAmounts;
            case 75:
                return Status.SettingNegativeAccountBalance;
            case 76:
                return Status.ObtainerRequired;
            case 77:
                return Status.ObtainerSameContractId;
            case 78:
                return Status.ObtainerDoesNotExist;
            case 79:
                return Status.ModifyingImmutableContract;
            case 80:
                return Status.FileSystemException;
            case 81:
                return Status.AutorenewDurationNotInRange;
            case 82:
                return Status.ErrorDecodingBytestring;
            case 83:
                return Status.ContractFileEmpty;
            case 84:
                return Status.ContractBytecodeEmpty;
            case 85:
                return Status.InvalidInitialBalance;
            case 86:
                return Status.InvalidReceiveRecordThreshold;
            case 87:
                return Status.InvalidSendRecordThreshold;
            case 88:
                return Status.AccountIsNotGenesisAccount;
            case 89:
                return Status.PayerAccountUnauthorized;
            case 90:
                return Status.InvalidFreezeTransactionBody;
            case 91:
                return Status.FreezeTransactionBodyNotFound;
            case 92:
                return Status.TransferListSizeLimitExceeded;
            case 93:
                return Status.ResultSizeLimitExceeded;
            case 94:
                return Status.NotSpecialAccount;
            case 95:
                return Status.ContractNegativeGas;
            case 96:
                return Status.ContractNegativeValue;
            case 97:
                return Status.InvalidFeeFile;
            case 98:
                return Status.InvalidExchangeRateFile;
            case 99:
                return Status.InsufficientLocalCallGas;
            case 100:
                return Status.EntityNotAllowedToDelete;
            case 101:
                return Status.AuthorizationFailed;
            case 102:
                return Status.FileUploadedProtoInvalid;
            case 103:
                return Status.FileUploadedProtoNotSavedToDisk;
            case 104:
                return Status.FeeScheduleFilePartUploaded;
            case 105:
                return Status.ExchangeRateChangeLimitExceeded;
            case 106:
                return Status.MaxContractStorageExceeded;
            case 107:
                return Status.TransferAccountSameAsDeleteAccount;
            case 108:
                return Status.TotalLedgerBalanceInvalid;
            case 110:
                return Status.ExpirationReductionNotAllowed;
            case 111:
                return Status.MaxGasLimitExceeded;
            case 112:
                return Status.MaxFileSizeExceeded;
            case 113:
                return Status.ReceiverSigRequired;
            case 150:
                return Status.InvalidTopicId;
            case 155:
                return Status.InvalidAdminKey;
            case 156:
                return Status.InvalidSubmitKey;
            case 157:
                return Status.Unauthorized;
            case 158:
                return Status.InvalidTopicMessage;
            case 159:
                return Status.InvalidAutorenewAccount;
            case 160:
                return Status.AutorenewAccountNotAllowed;
            case 162:
                return Status.TopicExpired;
            case 163:
                return Status.InvalidChunkNumber;
            case 164:
                return Status.InvalidChunkTransactionId;
            case 165:
                return Status.AccountFrozenForToken;
            case 166:
                return Status.TokensPerAccountLimitExceeded;
            case 167:
                return Status.InvalidTokenId;
            case 168:
                return Status.InvalidTokenDecimals;
            case 169:
                return Status.InvalidTokenInitialSupply;
            case 170:
                return Status.InvalidTreasuryAccountForToken;
            case 171:
                return Status.InvalidTokenSymbol;
            case 172:
                return Status.TokenHasNoFreezeKey;
            case 173:
                return Status.TransfersNotZeroSumForToken;
            case 174:
                return Status.MissingTokenSymbol;
            case 175:
                return Status.TokenSymbolTooLong;
            case 176:
                return Status.AccountKycNotGrantedForToken;
            case 177:
                return Status.TokenHasNoKycKey;
            case 178:
                return Status.InsufficientTokenBalance;
            case 179:
                return Status.TokenWasDeleted;
            case 180:
                return Status.TokenHasNoSupplyKey;
            case 181:
                return Status.TokenHasNoWipeKey;
            case 182:
                return Status.InvalidTokenMintAmount;
            case 183:
                return Status.InvalidTokenBurnAmount;
            case 184:
                return Status.TokenNotAssociatedToAccount;
            case 185:
                return Status.CannotWipeTokenTreasuryAccount;
            case 186:
                return Status.InvalidKycKey;
            case 187:
                return Status.InvalidWipeKey;
            case 188:
                return Status.InvalidFreezeKey;
            case 189:
                return Status.InvalidSupplyKey;
            case 190:
                return Status.MissingTokenName;
            case 191:
                return Status.TokenNameTooLong;
            case 192:
                return Status.InvalidWipingAmount;
            case 193:
                return Status.TokenIsImmutable;
            case 194:
                return Status.TokenAlreadyAssociatedToAccount;
            case 195:
                return Status.TransactionRequiresZeroTokenBalances;
            case 196:
                return Status.AccountIsTreasury;
            case 197:
                return Status.TokenIdRepeatedInTokenList;
            case 198:
                return Status.TokenTransferListSizeLimitExceeded;
            case 199:
                return Status.EmptyTokenTransferBody;
            case 200:
                return Status.EmptyTokenTransferAccountAmounts;
            case 201:
                return Status.InvalidScheduleId;
            case 202:
                return Status.ScheduleIsImmutable;
            case 203:
                return Status.InvalidSchedulePayerId;
            case 204:
                return Status.InvalidScheduleAccountId;
            case 205:
                return Status.NoNewValidSignatures;
            case 206:
                return Status.UnresolvableRequiredSigners;
            case 207:
                return Status.ScheduledTransactionNotInWhitelist;
            case 208:
                return Status.SomeSignaturesWereInvalid;
            case 209:
                return Status.TransactionIdFieldNotAllowed;
            case 210:
                return Status.IdenticalScheduleAlreadyCreated;
            case 211:
                return Status.InvalidZeroByteInString;
            case 212:
                return Status.ScheduleAlreadyDeleted;
            case 213:
                return Status.ScheduleAlreadyExecuted;
            case 214:
                return Status.MessageSizeTooLarge;
            case 215:
                return Status.OperationRepeatedInBucketGroups;
            case 216:
                return Status.BucketCapacityOverflow;
            case 217:
                return Status.NodeCapacityNotSufficientForOperation;
            case 218:
                return Status.BucketHasNoThrottleGroups;
            case 219:
                return Status.ThrottleGroupHasZeroOpsPerSec;
            case 220:
                return Status.SuccessButMissingExpectedOperation;
            case 221:
                return Status.UnparseableThrottleDefinitions;
            case 222:
                return Status.InvalidThrottleDefinitions;
            case 223:
                return Status.AccountExpiredAndPendingRemoval;
            case 224:
                return Status.InvalidTokenMaxSupply;
            case 225:
                return Status.InvalidTokenNftSerialNumber;
            case 226:
                return Status.InvalidNftId;
            case 227:
                return Status.MetadataTooLong;
            case 228:
                return Status.BatchSizeLimitExceeded;
            case 229:
                return Status.InvalidQueryRange;
            case 230:
                return Status.FractionDividesByZero;
            case 231:
                return Status.InsufficientPayerBalanceForCustomFee;
            case 232:
                return Status.CustomFeesListTooLong;
            case 233:
                return Status.InvalidCustomFeeCollector;
            case 234:
                return Status.InvalidTokenIdInCustomFees;
            case 235:
                return Status.TokenNotAssociatedToFeeCollector;
            case 236:
                return Status.TokenMaxSupplyReached;
            case 237:
                return Status.SenderDoesNotOwnNftSerialNo;
            case 238:
                return Status.CustomFeeNotFullySpecified;
            case 239:
                return Status.CustomFeeMustBePositive;
            case 240:
                return Status.TokenHasNoFeeScheduleKey;
            case 241:
                return Status.CustomFeeOutsideNumericRange;
            case 242:
                return Status.RoyaltyFractionCannotExceedOne;
            case 243:
                return Status.FractionalFeeMaxAmountLessThanMinAmount;
            case 244:
                return Status.CustomScheduleAlreadyHasNoFees;
            case 245:
                return Status.CustomFeeDenominationMustBeFungibleCommon;
            case 246:
                return Status.CustomFractionalFeeOnlyAllowedForFungibleCommon;
            case 247:
                return Status.InvalidCustomFeeScheduleKey;
            case 248:
                return Status.InvalidTokenMintMetadata;
            case 249:
                return Status.InvalidTokenBurnMetadata;
            case 250:
                return Status.CurrentTreasuryStillOwnsNfts;
            case 251:
                return Status.AccountStillOwnsNfts;
            case 252:
                return Status.TreasuryMustOwnBurnedNft;
            case 253:
                return Status.AccountDoesNotOwnWipedNft;
            case 254:
                return Status.AccountAmountTransfersOnlyAllowedForFungibleCommon;
            case 255:
                return Status.MaxNftsInPriceRegimeHaveBeenMinted;
            case 256:
                return Status.PayerAccountDeleted;
            case 257:
                return Status.CustomFeeChargingExceededMaxRecursionDepth;
            case 258:
                return Status.CustomFeeChargingExceededMaxAccountAmounts;
            case 259:
                return Status.InsufficientSenderAccountBalanceForCustomFee;
            case 260:
                return Status.SerialNumberLimitReached;
            case 261:
                return Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique;
            case 262:
                return Status.NoRemainingAutomaticAssociations;
            case 263:
                return Status.ExistingAutomaticAssociationsExceedGivenLimit;
            case 264:
                return Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit;
            case 265:
                return Status.TokenIsPaused;
            case 266:
                return Status.TokenHasNoPauseKey;
            case 267:
                return Status.InvalidPauseKey;
            case 268:
                return Status.FreezeUpdateFileDoesNotExist;
            case 269:
                return Status.FreezeUpdateFileHashDoesNotMatch;
            case 270:
                return Status.NoUpgradeHasBeenPrepared;
            case 271:
                return Status.NoFreezeIsScheduled;
            case 272:
                return Status.UpdateFileHashChangedSincePrepareUpgrade;
            case 273:
                return Status.FreezeStartTimeMustBeFuture;
            case 274:
                return Status.PreparedUpdateFileIsImmutable;
            case 275:
                return Status.FreezeAlreadyScheduled;
            case 276:
                return Status.FreezeUpgradeInProgress;
            case 277:
                return Status.UpdateFileIdDoesNotMatchPrepared;
            case 278:
                return Status.UpdateFileHashDoesNotMatchPrepared;
            case 279:
                return Status.ConsensusGasExhausted;
            case 280:
                return Status.RevertedSuccess;
            case 281:
                return Status.MaxStorageInPriceRegimeHasBeenUsed;
            case 282:
                return Status.InvalidAliasKey;
            case 283:
                return Status.UnexpectedTokenDecimals;
            case 284:
                return Status.InvalidProxyAccountId;
            case 285:
                return Status.InvalidTransferAccountId;
            case 286:
                return Status.InvalidFeeCollectorAccountId;
            case 287:
                return Status.AliasIsImmutable;
            case 288:
                return Status.SpenderAccountSameAsOwner;
            case 289:
                return Status.AmountExceedsTokenMaxSupply;
            case 290:
                return Status.NegativeAllowanceAmount;
            case 291:
                return Status.CannotApproveForAllFungibleCommon;
            case 292:
                return Status.SpenderDoesNotHaveAllowance;
            case 293:
                return Status.AmountExceedsAllowance;
            case 294:
                return Status.MaxAllowancesExceeded;
            case 295:
                return Status.EmptyAllowances;
            case 296:
                return Status.SpenderAccountRepeatedInAllowances;
            case 297:
                return Status.RepeatedSerialNumsInNftAllowances;
            case 298:
                return Status.FungibleTokenInNftAllowances;
            case 299:
                return Status.NftInFungibleTokenAllowances;
            case 300:
                return Status.InvalidAllowanceOwnerId;
            case 301:
                return Status.InvalidAllowanceSpenderId;
            case 302:
                return Status.RepeatedAllowancesToDelete;
            case 303:
                return Status.InvalidDelegatingSpender;
            case 304:
                return Status.DelegatingSpenderCannotGrantApproveForAll;
            case 305:
                return Status.DelegatingSpenderDoesNotHaveApproveForAll;
            case 306:
                return Status.ScheduleExpirationTimeTooFarInFuture;
            case 307:
                return Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime;
            case 308:
                return Status.ScheduleFutureThrottleExceeded;
            case 309:
                return Status.ScheduleFutureGasLimitExceeded;
            case 310:
                return Status.InvalidEthereumTransaction;
            case 311:
                return Status.WrongChainId;
            case 312:
                return Status.WrongNonce;
            case 313:
                return Status.AccessListUnsupported;
            case 314:
                return Status.SchedulePendingExpiration;
            case 315:
                return Status.ContractIsTokenTreasury;
            case 316:
                return Status.ContractHasNonZeroTokenBalances;
            case 317:
                return Status.ContractExpiredAndPendingRemoval;
            case 318:
                return Status.ContractHasNoAutoRenewAccount;
            case 319:
                return Status.PermanentRemovalRequiresSystemInitiation;
            case 320:
                return Status.ProxyAccountIdFieldIsDeprecated;
            case 321:
                return Status.SelfStakingIsNotAllowed;
            case 322:
                return Status.InvalidStakingId;
            case 323:
                return Status.StakingNotEnabled;
            case 324:
                return Status.InvalidPrngRange;
            case 325:
                return Status.MaxEntitiesInPriceRegimeHaveBeenCreated;
            case 326:
                return Status.InvalidFullPrefixSignatureForPrecompile;
            case 327:
                return Status.InsufficientBalancesForStorageRent;
            case 328:
                return Status.MaxChildRecordsExceeded;
            case 329:
                return Status.InsufficientBalancesForRenewalFees;
            case 330:
                return Status.TransactionHasUnknownFields;
            case 331:
                return Status.AccountIsImmutable;
            case 332:
                return Status.AliasAlreadyAssigned;
            case 333:
                return Status.InvalidMetadataKey;
            case 334:
                return Status.TokenHasNoMetadataKey;
            case 335:
                return Status.MissingTokenMetadata;
            case 336:
                return Status.MissingSerialNumbers;
            case 337:
                return Status.TokenHasNoAdminKey;
            case 338:
                return Status.NodeDeleted;
            case 339:
                return Status.InvalidNodeId;
            case 340:
                return Status.InvalidGossipEndpoint;
            case 341:
                return Status.InvalidNodeAccountId;
            case 342:
                return Status.InvalidNodeDescription;
            case 343:
                return Status.InvalidServiceEndpoint;
            case 344:
                return Status.InvalidGossipCaCertificate;
            case 345:
                return Status.InvalidGrpcCertificate;
            case 346:
                return Status.InvalidMaxAutoAssociations;
            case 347:
                return Status.MaxNodesCreated;
            case 348:
                return Status.IpFqdnCannotBeSetForSameEndpoint;
            case 349:
                return Status.GossipEndpointCannotHaveFqdn;
            case 350:
                return Status.FqdnSizeTooLarge;
            case 351:
                return Status.InvalidEndpoint;
            case 352:
                return Status.GossipEndpointsExceededLimit;
            case 353:
                return Status.TokenReferenceRepeated;
            case 354:
                return Status.InvalidOwnerId;
            case 355:
                return Status.TokenReferenceListSizeLimitExceeded;
            case 356:
                return Status.ServiceEndpointsExceededLimit;
            case 357:
                return Status.InvalidIpv4Address;
            case 358:
                return Status.EmptyTokenReferenceList;
            case 359:
                return Status.UpdateNodeAccountNotAllowed;
            case 360:
                return Status.TokenHasNoMetadataOrSupplyKey;
            case 361:
                return Status.EmptyPendingAirdropIdList;
            case 362:
                return Status.PendingAirdropIdRepeated;
            case 363:
                return Status.MaxPendingAirdropIdExceeded;
            case 364:
                return Status.PendingNftAirdropAlreadyExists;
            case 365:
                return Status.AccountHasPendingAirdrops;
            case 366:
                return Status.ThrottledAtConsensus;
            case 367:
                return Status.InvalidPendingAirdropId;
            case 368:
                return Status.TokenAirdropWithFallbackRoyalty;
            case 369:
                return Status.InvalidTokenInPendingAirdrop;
            case 370:
                return Status.ScheduleExpiryIsBusy;
            case 371:
                return Status.InvalidGrpcCertificateHash;
            case 372:
                return Status.MissingExpiryTime;
            case 373:
                return Status.NoSchedulingAllowedAfterScheduledRecursion;
            case 374:
                return Status.RecursiveSchedulingLimitReached;
            case 375:
                return Status.WaitingForLedgerId;
            case 376:
                return Status.MaxEntriesForFeeExemptKeyListExceeded;
            case 377:
                return Status.FeeExemptKeyListContainsDuplicatedKeys;
            case 378:
                return Status.InvalidKeyInFeeExemptKeyList;
            case 379:
                return Status.InvalidFeeScheduleKey;
            case 380:
                return Status.FeeScheduleKeyCannotBeUpdated;
            case 381:
                return Status.FeeScheduleKeyNotSet;
            case 382:
                return Status.MaxCustomFeeLimitExceeded;
            case 383:
                return Status.NoValidMaxCustomFee;
            case 384:
                return Status.InvalidMaxCustomFees;
            case 385:
                return Status.DuplicateDenominationInMaxCustomFeeList;
            case 386:
                return Status.DuplicateAccountIdInMaxCustomFeeList;
            case 387:
                return Status.MaxCustomFeesIsNotSupported;
            default:
                throw new Error(
                    `(BUG) Status.fromCode() does not handle code: ${code}`,
                );
        }
    }

    /**
     * @returns {HieroProto.proto.ResponseCodeEnum}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * The transaction passed the precheck validations.
 */
Status.Ok = new Status(0);

/**
 * For any error not handled by specific error codes listed below.
 */
Status.InvalidTransaction = new Status(1);

/**
 * Payer account does not exist.
 */
Status.PayerAccountNotFound = new Status(2);

/**
 * Node Account provided does not match the node account of the node the transaction was submitted
 * to.
 */
Status.InvalidNodeAccount = new Status(3);

/**
 * Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
 * consensus time.
 */
Status.TransactionExpired = new Status(4);

/**
 * Transaction start time is greater than current consensus time
 */
Status.InvalidTransactionStart = new Status(5);

/**
 * The given transactionValidDuration was either non-positive, or greater than the maximum
 * valid duration of 180 secs.
 *
 */
Status.InvalidTransactionDuration = new Status(6);

/**
 * The transaction signature is not valid
 */
Status.InvalidSignature = new Status(7);

/**
 * Transaction memo size exceeded 100 bytes
 */
Status.MemoTooLong = new Status(8);

/**
 * The fee provided in the transaction is insufficient for this type of transaction
 */
Status.InsufficientTxFee = new Status(9);

/**
 * The payer account has insufficient cryptocurrency to pay the transaction fee
 */
Status.InsufficientPayerBalance = new Status(10);

/**
 * This transaction ID is a duplicate of one that was submitted to this node or reached consensus
 * in the last 180 seconds (receipt period)
 */
Status.DuplicateTransaction = new Status(11);

/**
 * If API is throttled out
 */
Status.Busy = new Status(12);

/**
 * The API is not currently supported
 */
Status.NotSupported = new Status(13);

/**
 * The file id is invalid or does not exist
 */
Status.InvalidFileId = new Status(14);

/**
 * The account id is invalid or does not exist
 */
Status.InvalidAccountId = new Status(15);

/**
 * The contract id is invalid or does not exist
 */
Status.InvalidContractId = new Status(16);

/**
 * Transaction id is not valid
 */
Status.InvalidTransactionId = new Status(17);

/**
 * Receipt for given transaction id does not exist
 */
Status.ReceiptNotFound = new Status(18);

/**
 * Record for given transaction id does not exist
 */
Status.RecordNotFound = new Status(19);

/**
 * The solidity id is invalid or entity with this solidity id does not exist
 */
Status.InvalidSolidityId = new Status(20);

/**
 * The responding node has submitted the transaction to the network. Its final status is still
 * unknown.
 */
Status.Unknown = new Status(21);

/**
 * The transaction succeeded
 */
Status.Success = new Status(22);

/**
 * There was a system error and the transaction failed because of invalid request parameters.
 */
Status.FailInvalid = new Status(23);

/**
 * There was a system error while performing fee calculation, reserved for future.
 */
Status.FailFee = new Status(24);

/**
 * There was a system error while performing balance checks, reserved for future.
 */
Status.FailBalance = new Status(25);

/**
 * Key not provided in the transaction body
 */
Status.KeyRequired = new Status(26);

/**
 * Unsupported algorithm/encoding used for keys in the transaction
 */
Status.BadEncoding = new Status(27);

/**
 * When the account balance is not sufficient for the transfer
 */
Status.InsufficientAccountBalance = new Status(28);

/**
 * During an update transaction when the system is not able to find the Users Solidity address
 */
Status.InvalidSolidityAddress = new Status(29);

/**
 * Not enough gas was supplied to execute transaction
 */
Status.InsufficientGas = new Status(30);

/**
 * contract byte code size is over the limit
 */
Status.ContractSizeLimitExceeded = new Status(31);

/**
 * local execution (query) is requested for a function which changes state
 */
Status.LocalCallModificationException = new Status(32);

/**
 * Contract REVERT OPCODE executed
 */
Status.ContractRevertExecuted = new Status(33);

/**
 * For any contract execution related error not handled by specific error codes listed above.
 */
Status.ContractExecutionException = new Status(34);

/**
 * In Query validation, account with +ve(amount) value should be Receiving node account, the
 * receiver account should be only one account in the list
 */
Status.InvalidReceivingNodeAccount = new Status(35);

/**
 * Header is missing in Query request
 */
Status.MissingQueryHeader = new Status(36);

/**
 * The update of the account failed
 */
Status.AccountUpdateFailed = new Status(37);

/**
 * Provided key encoding was not supported by the system
 */
Status.InvalidKeyEncoding = new Status(38);

/**
 * null solidity address
 */
Status.NullSolidityAddress = new Status(39);

/**
 * update of the contract failed
 */
Status.ContractUpdateFailed = new Status(40);

/**
 * the query header is invalid
 */
Status.InvalidQueryHeader = new Status(41);

/**
 * Invalid fee submitted
 */
Status.InvalidFeeSubmitted = new Status(42);

/**
 * Payer signature is invalid
 */
Status.InvalidPayerSignature = new Status(43);

/**
 * The keys were not provided in the request.
 */
Status.KeyNotProvided = new Status(44);

/**
 * Expiration time provided in the transaction was invalid.
 */
Status.InvalidExpirationTime = new Status(45);

/**
 * WriteAccess Control Keys are not provided for the file
 */
Status.NoWaclKey = new Status(46);

/**
 * The contents of file are provided as empty.
 */
Status.FileContentEmpty = new Status(47);

/**
 * The crypto transfer credit and debit do not sum equal to 0
 */
Status.InvalidAccountAmounts = new Status(48);

/**
 * Transaction body provided is empty
 */
Status.EmptyTransactionBody = new Status(49);

/**
 * Invalid transaction body provided
 */
Status.InvalidTransactionBody = new Status(50);

/**
 * the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
 * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
 */
Status.InvalidSignatureTypeMismatchingKey = new Status(51);

/**
 * the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
 * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
 * signatureList should also have 3 base signatures.
 */
Status.InvalidSignatureCountMismatchingKey = new Status(52);

/**
 * the livehash body is empty
 */
Status.EmptyLiveHashBody = new Status(53);

/**
 * the livehash data is missing
 */
Status.EmptyLiveHash = new Status(54);

/**
 * the keys for a livehash are missing
 */
Status.EmptyLiveHashKeys = new Status(55);

/**
 * the livehash data is not the output of a SHA-384 digest
 */
Status.InvalidLiveHashSize = new Status(56);

/**
 * the query body is empty
 */
Status.EmptyQueryBody = new Status(57);

/**
 * the crypto livehash query is empty
 */
Status.EmptyLiveHashQuery = new Status(58);

/**
 * the livehash is not present
 */
Status.LiveHashNotFound = new Status(59);

/**
 * the account id passed has not yet been created.
 */
Status.AccountIdDoesNotExist = new Status(60);

/**
 * the livehash already exists for a given account
 */
Status.LiveHashAlreadyExists = new Status(61);

/**
 * File WACL keys are invalid
 */
Status.InvalidFileWacl = new Status(62);

/**
 * Serialization failure
 */
Status.SerializationFailed = new Status(63);

/**
 * The size of the Transaction is greater than transactionMaxBytes
 */
Status.TransactionOversize = new Status(64);

/**
 * The Transaction has more than 50 levels
 */
Status.TransactionTooManyLayers = new Status(65);

/**
 * Contract is marked as deleted
 */
Status.ContractDeleted = new Status(66);

/**
 * the platform node is either disconnected or lagging behind.
 */
Status.PlatformNotActive = new Status(67);

/**
 * one public key matches more than one prefixes on the signature map
 */
Status.KeyPrefixMismatch = new Status(68);

/**
 * transaction not created by platform due to large backlog
 */
Status.PlatformTransactionNotCreated = new Status(69);

/**
 * auto renewal period is not a positive number of seconds
 */
Status.InvalidRenewalPeriod = new Status(70);

/**
 * the response code when a smart contract id is passed for a crypto API request
 */
Status.InvalidPayerAccountId = new Status(71);

/**
 * the account has been marked as deleted
 */
Status.AccountDeleted = new Status(72);

/**
 * the file has been marked as deleted
 */
Status.FileDeleted = new Status(73);

/**
 * same accounts repeated in the transfer account list
 */
Status.AccountRepeatedInAccountAmounts = new Status(74);

/**
 * attempting to set negative balance value for crypto account
 */
Status.SettingNegativeAccountBalance = new Status(75);

/**
 * when deleting smart contract that has crypto balance either transfer account or transfer smart
 * contract is required
 */
Status.ObtainerRequired = new Status(76);

/**
 * when deleting smart contract that has crypto balance you can not use the same contract id as
 * transferContractId as the one being deleted
 */
Status.ObtainerSameContractId = new Status(77);

/**
 * transferAccountId or transferContractId specified for contract delete does not exist
 */
Status.ObtainerDoesNotExist = new Status(78);

/**
 * attempting to modify (update or delete a immutable smart contract, i.e. one created without a
 * admin key)
 */
Status.ModifyingImmutableContract = new Status(79);

/**
 * Unexpected exception thrown by file system functions
 */
Status.FileSystemException = new Status(80);

/**
 * the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
 */
Status.AutorenewDurationNotInRange = new Status(81);

/**
 * Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
 * string.
 */
Status.ErrorDecodingBytestring = new Status(82);

/**
 * File to create a smart contract was of length zero
 */
Status.ContractFileEmpty = new Status(83);

/**
 * Bytecode for smart contract is of length zero
 */
Status.ContractBytecodeEmpty = new Status(84);

/**
 * Attempt to set negative initial balance
 */
Status.InvalidInitialBalance = new Status(85);

/**
 * [Deprecated]. attempt to set negative receive record threshold
 */
Status.InvalidReceiveRecordThreshold = new Status(86);

/**
 * [Deprecated]. attempt to set negative send record threshold
 */
Status.InvalidSendRecordThreshold = new Status(87);

/**
 * Special Account Operations should be performed by only Genesis account, return this code if it
 * is not Genesis Account
 */
Status.AccountIsNotGenesisAccount = new Status(88);

/**
 * The fee payer account doesn't have permission to submit such Transaction
 */
Status.PayerAccountUnauthorized = new Status(89);

/**
 * FreezeTransactionBody is invalid
 */
Status.InvalidFreezeTransactionBody = new Status(90);

/**
 * FreezeTransactionBody does not exist
 */
Status.FreezeTransactionBodyNotFound = new Status(91);

/**
 * Exceeded the number of accounts (both from and to) allowed for crypto transfer list
 */
Status.TransferListSizeLimitExceeded = new Status(92);

/**
 * Smart contract result size greater than specified maxResultSize
 */
Status.ResultSizeLimitExceeded = new Status(93);

/**
 * The payer account is not a special account(account 0.0.55)
 */
Status.NotSpecialAccount = new Status(94);

/**
 * Negative gas was offered in smart contract call
 */
Status.ContractNegativeGas = new Status(95);

/**
 * Negative value / initial balance was specified in a smart contract call / create
 */
Status.ContractNegativeValue = new Status(96);

/**
 * Failed to update fee file
 */
Status.InvalidFeeFile = new Status(97);

/**
 * Failed to update exchange rate file
 */
Status.InvalidExchangeRateFile = new Status(98);

/**
 * Payment tendered for contract local call cannot cover both the fee and the gas
 */
Status.InsufficientLocalCallGas = new Status(99);

/**
 * Entities with Entity ID below 1000 are not allowed to be deleted
 */
Status.EntityNotAllowedToDelete = new Status(100);

/**
 * Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
 * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
 * A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed
 * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
 * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
 * (0.0.112).
 */
Status.AuthorizationFailed = new Status(101);

/**
 * Fee Schedule Proto uploaded but not valid (append or update is required)
 */
Status.FileUploadedProtoInvalid = new Status(102);

/**
 * Fee Schedule Proto uploaded but not valid (append or update is required)
 */
Status.FileUploadedProtoNotSavedToDisk = new Status(103);

/**
 * Fee Schedule Proto File Part uploaded
 */
Status.FeeScheduleFilePartUploaded = new Status(104);

/**
 * The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
 */
Status.ExchangeRateChangeLimitExceeded = new Status(105);

/**
 * Contract permanent storage exceeded the currently allowable limit
 */
Status.MaxContractStorageExceeded = new Status(106);

/**
 * Transfer Account should not be same as Account to be deleted
 */
Status.TransferAccountSameAsDeleteAccount = new Status(107);

Status.TotalLedgerBalanceInvalid = new Status(108);
/**
 * The expiration date/time on a smart contract may not be reduced
 */
Status.ExpirationReductionNotAllowed = new Status(110);

/**
 * Gas exceeded currently allowable gas limit per transaction
 */
Status.MaxGasLimitExceeded = new Status(111);

/**
 * File size exceeded the currently allowable limit
 */
Status.MaxFileSizeExceeded = new Status(112);

/**
 * When a valid signature is not provided for operations on account with receiverSigRequired=true
 */
Status.ReceiverSigRequired = new Status(113);

/**
 * The Topic ID specified is not in the system.
 */
Status.InvalidTopicId = new Status(150);

/**
 * A provided admin key was invalid.
 */
Status.InvalidAdminKey = new Status(155);

/**
 * A provided submit key was invalid.
 */
Status.InvalidSubmitKey = new Status(156);

/**
 * An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
 */
Status.Unauthorized = new Status(157);

/**
 * A ConsensusService message is empty.
 */
Status.InvalidTopicMessage = new Status(158);

/**
 * The autoRenewAccount specified is not a valid, active account.
 */
Status.InvalidAutorenewAccount = new Status(159);

/**
 * An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
 */
Status.AutorenewAccountNotAllowed = new Status(160);

/**
 * The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
 * topic will be deleted unrecoverably. This error response code will not be returned until
 * autoRenew functionality is supported by HAPI.
 */
Status.TopicExpired = new Status(162);

/**
 * chunk number must be from 1 to total (chunks) inclusive.
 */
Status.InvalidChunkNumber = new Status(163);

/**
 * For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.
 */
Status.InvalidChunkTransactionId = new Status(164);

/**
 * Account is frozen and cannot transact with the token
 */
Status.AccountFrozenForToken = new Status(165);

/**
 * An involved account already has more than <tt>tokens.maxPerAccount</tt> associations with non-deleted tokens.
 */
Status.TokensPerAccountLimitExceeded = new Status(166);

/**
 * The token is invalid or does not exist
 */
Status.InvalidTokenId = new Status(167);

/**
 * Invalid token decimals
 */
Status.InvalidTokenDecimals = new Status(168);

/**
 * Invalid token initial supply
 */
Status.InvalidTokenInitialSupply = new Status(169);

/**
 * Treasury Account does not exist or is deleted
 */
Status.InvalidTreasuryAccountForToken = new Status(170);

/**
 * Token Symbol is not UTF-8 capitalized alphabetical string
 */
Status.InvalidTokenSymbol = new Status(171);

/**
 * Freeze key is not set on token
 */
Status.TokenHasNoFreezeKey = new Status(172);

/**
 * Amounts in transfer list are not net zero
 */
Status.TransfersNotZeroSumForToken = new Status(173);

/**
 * A token symbol was not provided
 */
Status.MissingTokenSymbol = new Status(174);

/**
 * The provided token symbol was too long
 */
Status.TokenSymbolTooLong = new Status(175);

/**
 * KYC must be granted and account does not have KYC granted
 */
Status.AccountKycNotGrantedForToken = new Status(176);

/**
 * KYC key is not set on token
 */
Status.TokenHasNoKycKey = new Status(177);

/**
 * Token balance is not sufficient for the transaction
 */
Status.InsufficientTokenBalance = new Status(178);

/**
 * Token transactions cannot be executed on deleted token
 */
Status.TokenWasDeleted = new Status(179);

/**
 * Supply key is not set on token
 */
Status.TokenHasNoSupplyKey = new Status(180);

/**
 * Wipe key is not set on token
 */
Status.TokenHasNoWipeKey = new Status(181);

/**
 * The requested token mint amount would cause an invalid total supply
 */
Status.InvalidTokenMintAmount = new Status(182);

/**
 * The requested token burn amount would cause an invalid total supply
 */
Status.InvalidTokenBurnAmount = new Status(183);

/**
 * A required token-account relationship is missing
 */
Status.TokenNotAssociatedToAccount = new Status(184);

/**
 * The target of a wipe operation was the token treasury account
 */
Status.CannotWipeTokenTreasuryAccount = new Status(185);

/**
 * The provided KYC key was invalid.
 */
Status.InvalidKycKey = new Status(186);

/**
 * The provided wipe key was invalid.
 */
Status.InvalidWipeKey = new Status(187);

/**
 * The provided freeze key was invalid.
 */
Status.InvalidFreezeKey = new Status(188);

/**
 * The provided supply key was invalid.
 */
Status.InvalidSupplyKey = new Status(189);

/**
 * Token Name is not provided
 */
Status.MissingTokenName = new Status(190);

/**
 * Token Name is too long
 */
Status.TokenNameTooLong = new Status(191);

/**
 * The provided wipe amount must not be negative, zero or bigger than the token holder balance
 */
Status.InvalidWipingAmount = new Status(192);

/**
 * Token does not have Admin key set, thus update/delete transactions cannot be performed
 */
Status.TokenIsImmutable = new Status(193);

/**
 * An <tt>associateToken</tt> operation specified a token already associated to the account
 */
Status.TokenAlreadyAssociatedToAccount = new Status(194);

/**
 * An attempted operation is invalid until all token balances for the target account are zero
 */
Status.TransactionRequiresZeroTokenBalances = new Status(195);

/**
 * An attempted operation is invalid because the account is a treasury
 */
Status.AccountIsTreasury = new Status(196);

/**
 * Same TokenIDs present in the token list
 */
Status.TokenIdRepeatedInTokenList = new Status(197);

/**
 * Exceeded the number of token transfers (both from and to) allowed for token transfer list
 */
Status.TokenTransferListSizeLimitExceeded = new Status(198);

/**
 * TokenTransfersTransactionBody has no TokenTransferList
 */
Status.EmptyTokenTransferBody = new Status(199);

/**
 * TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts
 */
Status.EmptyTokenTransferAccountAmounts = new Status(200);

/**
 * The Scheduled entity does not exist; or has now expired, been deleted, or been executed
 */
Status.InvalidScheduleId = new Status(201);

/**
 * The Scheduled entity cannot be modified. Admin key not set
 */
Status.ScheduleIsImmutable = new Status(202);

/**
 * The provided Scheduled Payer does not exist
 */
Status.InvalidSchedulePayerId = new Status(203);

/**
 * The Schedule Create Transaction TransactionID account does not exist
 */
Status.InvalidScheduleAccountId = new Status(204);

/**
 * The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
 */
Status.NoNewValidSignatures = new Status(205);

/**
 * The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted
 */
Status.UnresolvableRequiredSigners = new Status(206);

/**
 * Only whitelisted transaction types may be scheduled
 */
Status.ScheduledTransactionNotInWhitelist = new Status(207);

/**
 * At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
 */
Status.SomeSignaturesWereInvalid = new Status(208);

/**
 * The scheduled field in the TransactionID may not be set to true
 */
Status.TransactionIdFieldNotAllowed = new Status(209);

/**
 * A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)
 */
Status.IdenticalScheduleAlreadyCreated = new Status(210);

/**
 * A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
 */
Status.InvalidZeroByteInString = new Status(211);

/**
 * A schedule being signed or deleted has already been deleted
 */
Status.ScheduleAlreadyDeleted = new Status(212);

/**
 * A schedule being signed or deleted has already been executed
 */
Status.ScheduleAlreadyExecuted = new Status(213);

/**
 * ConsensusSubmitMessage request's message size is larger than allowed.
 */
Status.MessageSizeTooLarge = new Status(214);

/**
 * An operation was assigned to more than one throttle group in a given bucket
 */
Status.OperationRepeatedInBucketGroups = new Status(215);

/**
 * The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
 */
Status.BucketCapacityOverflow = new Status(216);

/**
 * Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased
 */
Status.NodeCapacityNotSufficientForOperation = new Status(217);

/**
 * A bucket was defined without any throttle groups
 */
Status.BucketHasNoThrottleGroups = new Status(218);

/**
 * A throttle group was granted zero opsPerSec
 */
Status.ThrottleGroupHasZeroOpsPerSec = new Status(219);

/**
 * The throttle definitions file was updated, but some supported operations were not assigned a bucket
 */
Status.SuccessButMissingExpectedOperation = new Status(220);

/**
 * The new contents for the throttle definitions system file were not valid protobuf
 */
Status.UnparseableThrottleDefinitions = new Status(221);

/**
 * The new throttle definitions system file were invalid, and no more specific error could be divined
 */
Status.InvalidThrottleDefinitions = new Status(222);

/**
 * The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities
 */
Status.AccountExpiredAndPendingRemoval = new Status(223);

/**
 * Invalid token max supply
 */
Status.InvalidTokenMaxSupply = new Status(224);

/**
 * Invalid token nft serial number
 */
Status.InvalidTokenNftSerialNumber = new Status(225);

/**
 * Invalid nft id
 */
Status.InvalidNftId = new Status(226);

/**
 * Nft metadata is too long
 */
Status.MetadataTooLong = new Status(227);

/**
 * Repeated operations count exceeds the limit
 */
Status.BatchSizeLimitExceeded = new Status(228);

/**
 * The range of data to be gathered is out of the set boundaries
 */
Status.InvalidQueryRange = new Status(229);

/**
 * A custom fractional fee set a denominator of zero
 */
Status.FractionDividesByZero = new Status(230);

/**
 * The transaction payer could not afford a custom fee
 */
Status.InsufficientPayerBalanceForCustomFee = new Status(231);

/**
 * More than 10 custom fees were specified
 */
Status.CustomFeesListTooLong = new Status(232);

/**
 * Any of the feeCollector accounts for customFees is invalid
 */
Status.InvalidCustomFeeCollector = new Status(233);

/**
 * Any of the token Ids in customFees is invalid
 */
Status.InvalidTokenIdInCustomFees = new Status(234);

/**
 * Any of the token Ids in customFees are not associated to feeCollector
 */
Status.TokenNotAssociatedToFeeCollector = new Status(235);

/**
 * A token cannot have more units minted due to its configured supply ceiling
 */
Status.TokenMaxSupplyReached = new Status(236);

/**
 * The transaction attempted to move an NFT serial number from an account other than its owner
 */
Status.SenderDoesNotOwnNftSerialNo = new Status(237);

/**
 * A custom fee schedule entry did not specify either a fixed or fractional fee
 */
Status.CustomFeeNotFullySpecified = new Status(238);

/**
 * Only positive fees may be assessed at this time
 */
Status.CustomFeeMustBePositive = new Status(239);

/**
 * Fee schedule key is not set on token
 */
Status.TokenHasNoFeeScheduleKey = new Status(240);

/**
 * A fractional custom fee exceeded the range of a 64-bit signed integer
 */
Status.CustomFeeOutsideNumericRange = new Status(241);

/**
 * A royalty cannot exceed the total fungible value exchanged for an NFT
 */
Status.RoyaltyFractionCannotExceedOne = new Status(242);

/**
 * Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
 */
Status.FractionalFeeMaxAmountLessThanMinAmount = new Status(243);

/**
 * A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
 */
Status.CustomScheduleAlreadyHasNoFees = new Status(244);

/**
 * Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
 */
Status.CustomFeeDenominationMustBeFungibleCommon = new Status(245);

/**
 * Only tokens of type FUNGIBLE_COMMON can have fractional fees
 */
Status.CustomFractionalFeeOnlyAllowedForFungibleCommon = new Status(246);

/**
 * The provided custom fee schedule key was invalid
 */
Status.InvalidCustomFeeScheduleKey = new Status(247);

/**
 * The requested token mint metadata was invalid
 */
Status.InvalidTokenMintMetadata = new Status(248);

/**
 * The requested token burn metadata was invalid
 */
Status.InvalidTokenBurnMetadata = new Status(249);

/**
 * The treasury for a unique token cannot be changed until it owns no NFTs
 */
Status.CurrentTreasuryStillOwnsNfts = new Status(250);

/**
 * An account cannot be dissociated from a unique token if it owns NFTs for the token
 */
Status.AccountStillOwnsNfts = new Status(251);

/**
 * A NFT can only be burned when owned by the unique token's treasury
 */
Status.TreasuryMustOwnBurnedNft = new Status(252);

/**
 * An account did not own the NFT to be wiped
 */
Status.AccountDoesNotOwnWipedNft = new Status(253);

/**
 * An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
 */
Status.AccountAmountTransfersOnlyAllowedForFungibleCommon = new Status(254);

/**
 * All the NFTs allowed in the current price regime have already been minted
 */
Status.MaxNftsInPriceRegimeHaveBeenMinted = new Status(255);

/**
 * The payer account has been marked as deleted
 */
Status.PayerAccountDeleted = new Status(256);

/**
 * The reference chain of custom fees for a transferred token exceeded the maximum length of 2
 */
Status.CustomFeeChargingExceededMaxRecursionDepth = new Status(257);

/**
 * More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
 */
Status.CustomFeeChargingExceededMaxAccountAmounts = new Status(258);

/**
 * The sender account in the token transfer transaction could not afford a custom fee
 */
Status.InsufficientSenderAccountBalanceForCustomFee = new Status(259);

/**
 * Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
 */
Status.SerialNumberLimitReached = new Status(260);

/**
 * Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
 */
Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = new Status(261);

/**
 * The account has reached the limit on the automatic associations count.
 */
Status.NoRemainingAutomaticAssociations = new Status(262);

/**
 * Already existing automatic associations are more than the new maximum automatic associations.
 */
Status.ExistingAutomaticAssociationsExceedGivenLimit = new Status(263);

/**
 * Cannot set the number of automatic associations for an account more than the maximum allowed
 * token associations <tt>tokens.maxPerAccount</tt>.
 */
Status.RequestedNumAutomaticAssociationsExceedsAssociationLimit = new Status(
    264,
);

/**
 * Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
 */
Status.TokenIsPaused = new Status(265);

/**
 * Pause key is not set on token
 */
Status.TokenHasNoPauseKey = new Status(266);

/**
 * The provided pause key was invalid
 */
Status.InvalidPauseKey = new Status(267);

/**
 * The update file in a freeze transaction body must exist.
 */
Status.FreezeUpdateFileDoesNotExist = new Status(268);

/**
 * The hash of the update file in a freeze transaction body must match the in-memory hash.
 */
Status.FreezeUpdateFileHashDoesNotMatch = new Status(269);

/**
 * A FREEZE_UPGRADE transaction was handled with no previous update prepared.
 */
Status.NoUpgradeHasBeenPrepared = new Status(270);

/**
 * A FREEZE_ABORT transaction was handled with no scheduled freeze.
 */
Status.NoFreezeIsScheduled = new Status(271);

/**
 * The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
 * hash at the time of handling the PREPARE_UPGRADE transaction.
 */
Status.UpdateFileHashChangedSincePrepareUpgrade = new Status(272);

/**
 * The given freeze start time was in the (consensus) past.
 */
Status.FreezeStartTimeMustBeFuture = new Status(273);

/**
 * The prepared update file cannot be updated or appended until either the upgrade has
 * been completed, or a FREEZE_ABORT has been handled.
 */
Status.PreparedUpdateFileIsImmutable = new Status(274);

/**
 * Once a freeze is scheduled, it must be aborted before any other type of freeze can
 * can be performed.
 */
Status.FreezeAlreadyScheduled = new Status(275);

/**
 * If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
 * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
 */
Status.FreezeUpgradeInProgress = new Status(276);

/**
 * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
 * confirm the id of the file to be used in the upgrade.
 */
Status.UpdateFileIdDoesNotMatchPrepared = new Status(277);

/**
 * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
 * confirm the hash of the file to be used in the upgrade.
 */
Status.UpdateFileHashDoesNotMatchPrepared = new Status(278);

/**
 * Consensus throttle did not allow execution of this transaction. System is throttled at
 * consensus level.
 */
Status.ConsensusGasExhausted = new Status(279);

/**
 * A precompiled contract succeeded, but was later reverted.
 */
Status.RevertedSuccess = new Status(280);

/**
 * All contract storage allocated to the current price regime has been consumed.
 */
Status.MaxStorageInPriceRegimeHasBeenUsed = new Status(281);

/**
 * An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
 * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
 * unknown protobuf fields.
 */
Status.InvalidAliasKey = new Status(282);

/**
 * A fungible token transfer expected a different number of decimals than the involved
 * type actually has.
 */
Status.UnexpectedTokenDecimals = new Status(283);

/**
 * The proxy account id is invalid or does not exist.
 */
Status.InvalidProxyAccountId = new Status(284);

/**
 * The transfer account id in CryptoDelete transaction is invalid or does not exist.
 */
Status.InvalidTransferAccountId = new Status(285);

/**
 * The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
 */
Status.InvalidFeeCollectorAccountId = new Status(286);

/**
 * The alias already set on an account cannot be updated using CryptoUpdate transaction.
 */
Status.AliasIsImmutable = new Status(287);

/**
 * An approved allowance specifies a spender account that is the same as the hbar/token
 * owner account.
 */
Status.SpenderAccountSameAsOwner = new Status(288);

/**
 * The establishment or adjustment of an approved allowance cause the token allowance
 * to exceed the token maximum supply.
 */
Status.AmountExceedsTokenMaxSupply = new Status(289);

/**
 * The specified amount for an approved allowance cannot be negative.
 */
Status.NegativeAllowanceAmount = new Status(290);

/**
 * The approveForAll flag cannot be set for a fungible token.
 */
Status.CannotApproveForAllFungibleCommon = new Status(291);

/**
 * The spender does not have an existing approved allowance with the hbar/token owner.
 */
Status.SpenderDoesNotHaveAllowance = new Status(292);

/**
 * The transfer amount exceeds the current approved allowance for the spender account.
 */
Status.AmountExceedsAllowance = new Status(293);

/**
 * The payer account of an approveAllowances or adjustAllowance transaction is attempting
 * to go beyond the maximum allowed number of allowances.
 */
Status.MaxAllowancesExceeded = new Status(294);

/**
 * No allowances have been specified in the approval/adjust transaction.
 */
Status.EmptyAllowances = new Status(295);

/**
 * Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
 * CryptoApproveAllowance or CryptoAdjustAllowance transaction.
 */
Status.SpenderAccountRepeatedInAllowances = new Status(296);

/**
 * Serial numbers are repeated in nft allowance for a single spender account
 */
Status.RepeatedSerialNumsInNftAllowances = new Status(297);

/**
 * Fungible common token used in NFT allowances
 */
Status.FungibleTokenInNftAllowances = new Status(298);

/**
 * Non fungible token used in fungible token allowances
 */
Status.NftInFungibleTokenAllowances = new Status(299);

/**
 * The account id specified as the owner is invalid or does not exist.
 */
Status.InvalidAllowanceOwnerId = new Status(300);

/**
 * The account id specified as the spender is invalid or does not exist.
 */
Status.InvalidAllowanceSpenderId = new Status(301);

/**
 * If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.
 */
Status.RepeatedAllowancesToDelete = new Status(302);

/**
 * If the account Id specified as the delegating spender is invalid or does not exist.
 */
Status.InvalidDelegatingSpender = new Status(303);

/**
 * The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
 */
Status.DelegatingSpenderCannotGrantApproveForAll = new Status(304);

/**
 * The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
 * granted on token-owner.
 */
Status.DelegatingSpenderDoesNotHaveApproveForAll = new Status(305);

/**
 * The scheduled transaction could not be created because it's expiration_time was too far in the future.
 */
Status.ScheduleExpirationTimeTooFarInFuture = new Status(306);

/**
 * The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus time.
 */
Status.ScheduleExpirationTimeMustBeHigherThanConsensusTime = new Status(307);

/**
 * The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.
 */
Status.ScheduleFutureThrottleExceeded = new Status(308);

/**
 * The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.
 */
Status.ScheduleFutureGasLimitExceeded = new Status(309);

/**
 * The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.
 */
Status.InvalidEthereumTransaction = new Status(310);

/**
 * EthereumTransaction was signed against a chainId that this network does not support.
 */
Status.WrongChainId = new Status(311);

/**
 * This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
 */
Status.WrongNonce = new Status(312);

/**
 * The ethereum transaction specified an access list, which the network does not support.
 */
Status.AccessListUnsupported = new Status(313);

/**
 * The scheduled transaction is pending expiration.
 */
Status.SchedulePendingExpiration = new Status(314);

/**
 * A selfdestruct or ContractDelete targeted a contract that is a token treasury.
 */
Status.ContractIsTokenTreasury = new Status(315);

/**
 * A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
 */
Status.ContractHasNonZeroTokenBalances = new Status(316);

/**
 * A contract referenced by a transaction is "detached"; that is, expired and lacking any
 * hbar funds for auto-renewal payment---but still within its post-expiry grace period.
 */
Status.ContractExpiredAndPendingRemoval = new Status(317);

/**
 * A ContractUpdate requested removal of a contract's auto-renew account, but that contract has
 * no auto-renew account.
 */
Status.ContractHasNoAutoRenewAccount = new Status(318);

/**
 * A delete transaction submitted via HAPI set permanent_removal=true
 */
Status.PermanentRemovalRequiresSystemInitiation = new Status(319);

/*
 * A CryptoCreate or ContractCreate used the deprecated proxyAccountID field.
 */
Status.ProxyAccountIdFieldIsDeprecated = new Status(320);

/**
 * An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
 */
Status.SelfStakingIsNotAllowed = new Status(321);

/**
 * The staking account id or staking node id given is invalid or does not exist.
 */
Status.InvalidStakingId = new Status(322);

/**
 * Native staking, while implemented, has not yet enabled by the council.
 */
Status.StakingNotEnabled = new Status(323);

/**
 * The range provided in PRNG transaction is negative.
 */
Status.InvalidPrngRange = new Status(324);

/**
 * The maximum number of entities allowed in the current price regime have been created.
 */
Status.MaxEntitiesInPriceRegimeHaveBeenCreated = new Status(325);

/**
 * The full prefix signature for precompile is not valid
 */
Status.InvalidFullPrefixSignatureForPrecompile = new Status(326);

/**
 * The combined balances of a contract and its auto-renew account (if any) did not cover
 * the rent charged for net new storage used in a transaction.
 */
Status.InsufficientBalancesForStorageRent = new Status(327);

/**
 * A contract transaction tried to use more than the allowed number of child records, via
 * either system contract records or internal contract creations.
 */
Status.MaxChildRecordsExceeded = new Status(328);

/**
 * The combined balances of a contract and its auto-renew account (if any) or balance of an account did not cover
 * the auto-renewal fees in a transaction.
 */
Status.InsufficientBalancesForRenewalFees = new Status(329);

/**
 * A transaction's protobuf message includes unknown fields; could mean that a client
 * expects not-yet-released functionality to be available.
 */
Status.TransactionHasUnknownFields = new Status(330);

/**
 * The account cannot be modified. Account's key is not set
 */
Status.AccountIsImmutable = new Status(331);

/**
 * An alias that is assigned to an account or contract cannot be assigned to another account or contract.
 */
Status.AliasAlreadyAssigned = new Status(332);

/**
 * A provided metadata key was invalid. Verification includes, for example, checking the size of Ed25519 and ECDSA(secp256k1) public keys.
 */
Status.InvalidMetadataKey = new Status(333);

/**
 * Metadata key is not set on token
 */
Status.TokenHasNoMetadataKey = new Status(334);

/**
 * Token Metadata is not provided
 */
Status.MissingTokenMetadata = new Status(335);

/**
 * NFT serial numbers are missing in the TokenUpdateNftsTransactionBody
 */
Status.MissingSerialNumbers = new Status(336);

/**
 * Admin key is not set on token
 */
Status.TokenHasNoAdminKey = new Status(337);

/**
 * The node has been marked as deleted
 */
Status.NodeDeleted = new Status(338);

/**
 * A node is not found during update and delete node transaction
 */
Status.InvalidNodeId = new Status(339);

/**
 * gossip_endpoint has a fully qualified domain name instead of ip
 */
Status.InvalidGossipEndpoint = new Status(340);

/**
 * The node account_id is invalid
 */
Status.InvalidNodeAccountId = new Status(341);

/**
 * The node description is invalid
 */
Status.InvalidNodeDescription = new Status(342);

/**
 * service_endpoint is invalid
 */
Status.InvalidServiceEndpoint = new Status(343);

/**
 * gossip_ca_certificate is invalid
 */
Status.InvalidGossipCaCertificate = new Status(344);

/**
 * grpc_certificate_hash is invalid
 */
Status.InvalidGrpcCertificate = new Status(345);

/**
 * The maximum automatic associations value is not valid.
 * The most common cause for this error is a value less than `-1`.
 */
Status.InvalidMaxAutoAssociations = new Status(346);

/**
 * The maximum number of nodes allowed in the address book have been created.
 */
Status.MaxNodesCreated = new Status(347);

/**
 * In ServiceEndpoint, domain_name and ipAddressV4 are mutually exclusive
 */
Status.IpFqdnCannotBeSetForSameEndpoint = new Status(348);

/**
 * Fully qualified domain name is not allowed in gossip_endpoint
 */
Status.GossipEndpointCannotHaveFqdn = new Status(349);

/**
 * In ServiceEndpoint, domain_name size too large
 */
Status.FqdnSizeTooLarge = new Status(350);

/**
 * ServiceEndpoint is invalid
 */
Status.InvalidEndpoint = new Status(351);

/**
 * The number of gossip endpoints exceeds the limit
 */
Status.GossipEndpointsExceededLimit = new Status(352);

/**
 * The transaction attempted to use duplicate `TokenReference`.<br/>
 * This affects `TokenReject` attempting to reject same token reference more than once.
 */
Status.TokenReferenceRepeated = new Status(353);

/**
 * The account id specified as the owner in `TokenReject` is invalid or does not exist.
 */
Status.InvalidOwnerId = new Status(354);

/**
 * The transaction attempted to use more than the allowed number of `TokenReference`.
 */
Status.TokenReferenceListSizeLimitExceeded = new Status(355);

/**
 * The number of service endpoints exceeds the limit
 */
Status.ServiceEndpointsExceededLimit = new Status(356);

/*
 * The IPv4 address is invalid
 */
Status.InvalidIpv4Address = new Status(357);

/**
 * The transaction attempted to use empty `TokenReference` list.
 */
Status.EmptyTokenReferenceList = new Status(358);

/*
 * The node account is not allowed to be updated
 */
Status.UpdateNodeAccountNotAllowed = new Status(359);

/*
 * The token has no metadata or supply key
 */
Status.TokenHasNoMetadataOrSupplyKey = new Status(360);

/**
 * The transaction attempted to the use an empty List of `PendingAirdropId`.
 */
Status.EmptyPendingAirdropIdList = new Status(361);

/**
 * The transaction attempted to the same `PendingAirdropId` twice.
 */
Status.PendingAirdropIdRepeated = new Status(362);

/**
 * The transaction attempted to use more than the allowed number of `PendingAirdropId`.
 */
Status.MaxPendingAirdropIdExceeded = new Status(363);

/*
 * A pending airdrop already exists for the specified NFT.
 */
Status.PendingNftAirdropAlreadyExists = new Status(364);

/*
 * The identified account is sender for one or more pending airdrop(s)
 * and cannot be deleted.<br/>
 * Requester should cancel all pending airdrops before resending
 * this transaction.
 */
Status.AccountHasPendingAirdrops = new Status(365);

/**
 * Consensus throttle did not allow execution of this transaction.<br/>
 * The transaction should be retried after a modest delay.
 */
Status.ThrottledAtConsensus = new Status(366);

/**
 * The provided pending airdrop id is invalid.<br/>
 * This pending airdrop MAY already be claimed or cancelled.
 * <p>
 * The client SHOULD query a mirror node to determine the current status of
 * the pending airdrop.
 */
Status.InvalidPendingAirdropId = new Status(367);

/**
 * The token to be airdropped has a fallback royalty fee and cannot be
 * sent or claimed via an airdrop transaction.
 */
Status.TokenAirdropWithFallbackRoyalty = new Status(368);

/**
 * This airdrop claim is for a pending airdrop with an invalid token.<br/>
 * The token might be deleted, or the sender may not have enough tokens
 * to fulfill the offer.
 * <p>
 * The client SHOULD query mirror node to determine the status of the pending
 * airdrop and whether the sender can fulfill the offer.
 */
Status.InvalidTokenInPendingAirdrop = new Status(369);

/**
 * A scheduled transaction configured to wait for expiry to execute was given
 * an expiry time at which there is already too many transactions scheduled to
 * expire; its creation must be retried with a different expiry.
 */
Status.ScheduleExpiryIsBusy = new Status(370);

/**
 * The provided gRPC certificate hash is invalid.
 */
Status.InvalidGrpcCertificateHash = new Status(371);

/**
 * A scheduled transaction configured to wait for expiry to execute was not
 * given an explicit expiration time.
 */
Status.MissingExpiryTime = new Status(372);

/**
 * A contract operation attempted to schedule another transaction after it
 * had already scheduled a recursive contract call.
 */
Status.NoSchedulingAllowedAfterScheduledRecursion = new Status(373);

/**
 * A contract can schedule recursive calls a finite number of times (this is
 * approximately four million times with typical network configuration.)
 */
Status.RecursiveSchedulingLimitReached = new Status(374);

/**
 * The target network is waiting for the ledger ID to be set, which is a
 * side effect of finishing the network's TSS construction.
 */
Status.WaitingForLedgerId = new Status(375);

/**
 * The provided fee exempt key list size exceeded the limit.
 */
Status.MaxEntriesForFeeExemptKeyListExceeded = new Status(376);

/**
 * The provided fee exempt key list contains duplicated keys.
 */
Status.FeeExemptKeyListContainsDuplicatedKeys = new Status(377);

/**
 * The provided fee exempt key list contains an invalid key.
 */
Status.InvalidKeyInFeeExemptKeyList = new Status(378);

/**
 * The provided fee schedule key contains an invalid key.
 */
Status.InvalidFeeScheduleKey = new Status(379);

/**
 * If a fee schedule key is not set when we create a topic
 * we cannot add it on update.
 */
Status.FeeScheduleKeyCannotBeUpdated = new Status(380);

/**
 * If the topic's custom fees are updated the topic SHOULD have a
 * fee schedule key
 */
Status.FeeScheduleKeyNotSet = new Status(381);

/**
 * The fee amount is exceeding the amount that the payer
 * is willing to pay.
 */
Status.MaxCustomFeeLimitExceeded = new Status(382);

/**
 * There are no corresponding custom fees.
 */
Status.NoValidMaxCustomFee = new Status(383);

/**
 * The provided list contains invalid max custom fee.
 */
Status.InvalidMaxCustomFees = new Status(384);

/**
 * The provided max custom fee list contains fees with
 * duplicate denominations.
 */
Status.DuplicateDenominationInMaxCustomFeeList = new Status(385);

/**
 * The provided max custom fee list contains fees with
 * duplicate account id.
 */
Status.DuplicateAccountIdInMaxCustomFeeList = new Status(386);

/**
 * Max custom fees list is not supported for this operation.
 */
Status.MaxCustomFeesIsNotSupported = new Status(387);
// Filename: src/StatusError.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {import("./Status.js").default} Status
 * @typedef {import("./transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} StatusErrorJSON
 * @property {string} name
 * @property {string} status
 * @property {string} transactionId
 * @property {string} message
 */

export default class StatusError extends Error {
    /**
     * @param {object} props
     * @param {Status} props.status
     * @param {TransactionId} props.transactionId
     * @param {string} message
     */
    constructor(props, message) {
        super(message);

        this.name = "StatusError";

        this.status = props.status;

        this.transactionId = props.transactionId;

        this.message = message;

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, StatusError);
        }
    }

    /**
     * @returns {StatusErrorJSON}
     */
    toJSON() {
        return {
            name: this.name,
            status: this.status.toString(),
            transactionId: this.transactionId.toString(),
            message: this.message,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {StatusErrorJSON}
     */
    valueOf() {
        return this.toJSON();
    }
}
// Filename: src/Timestamp.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import Cache from "./Cache.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
 */

const MAX_NS = Long.fromNumber(1000000000);
const generatedIds = new Set();

/**
 * Represents a point in time with seconds and nanoseconds precision.
 *
 * The `Timestamp` class provides methods for creating, manipulating, and converting
 * timestamps. It supports operations such as addition of nanoseconds, conversion to
 * JavaScript Date objects, and generation of timestamps based on the current time.
 */
export default class Timestamp {
    /**
     * @param {Long | number} seconds
     * @param {Long | number} nanos
     */
    constructor(seconds, nanos) {
        /**
         * @readonly
         * @type {Long}
         */
        this.seconds =
            seconds instanceof Long ? seconds : Long.fromNumber(seconds);

        /**
         * @readonly
         * @type {Long}
         */
        this.nanos = nanos instanceof Long ? nanos : Long.fromNumber(nanos);

        Object.freeze(this);
    }

    /**
     * @param {boolean} hasJitter
     * @returns {Timestamp}
     */
    static generate(hasJitter = true) {
        let jitter;
        if (hasJitter) {
            jitter = Math.floor(Math.random() * 5000) + 3000;
        } else {
            jitter = 0;
        }
        const now = Date.now() - jitter;
        const seconds = Math.floor(now / 1000) + Cache.timeDrift;
        const nanos =
            Math.floor(now % 1000) * 1000000 +
            Math.floor(Math.random() * 1000000);

        const timestamp = new Timestamp(seconds, nanos);
        if (generatedIds.has(timestamp.toString())) {
            return this.generate();
        } else {
            generatedIds.add(timestamp.toString());
            return timestamp;
        }
    }

    /**
     * @param {string | number | Date} date
     * @returns {Timestamp}
     */
    static fromDate(date) {
        let nanos;

        if (typeof date === "number") {
            nanos = Long.fromNumber(date);
        } else if (typeof date === "string") {
            nanos = Long.fromNumber(Date.parse(date)).mul(1000000);
        } else if (date instanceof Date) {
            nanos = Long.fromNumber(date.getTime()).mul(1000000);
        } else {
            throw new TypeError(
                `invalid type '${typeof date}' for 'data', expected 'Date'`,
            );
        }

        return new Timestamp(0, 0).plusNanos(nanos);
    }

    /**
     * @returns {Date}
     */
    toDate() {
        return new Date(
            this.seconds.toInt() * 1000 +
                Math.floor(this.nanos.toInt() / 1000000),
        );
    }

    /**
     * @param {Long | number} nanos
     * @returns {Timestamp}
     */
    plusNanos(nanos) {
        const ns = this.nanos.add(nanos);

        return new Timestamp(this.seconds.add(ns.div(MAX_NS)), ns.mod(MAX_NS));
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITimestamp}
     */
    _toProtobuf() {
        return {
            seconds: this.seconds,
            nanos: this.nanos.toInt(),
        };
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITimestamp} timestamp
     * @returns {Timestamp}
     */
    static _fromProtobuf(timestamp) {
        return new Timestamp(
            timestamp.seconds instanceof Long
                ? timestamp.seconds.toInt()
                : timestamp.seconds != null
                  ? timestamp.seconds
                  : 0,

            timestamp.nanos != null ? timestamp.nanos : 0,
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        const zeroPaddedNanos = String(this.nanos).padStart(9, "0");
        return `${this.seconds.toString()}.${zeroPaddedNanos}`;
    }

    /**
     * @param {Timestamp} other
     * @returns {number}
     */
    compare(other) {
        const comparison = this.seconds.compare(other.seconds);

        if (comparison != 0) {
            return comparison;
        }

        return this.nanos.compare(other.nanos);
    }
}
// Filename: src/TransactionFeeSchedule.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import RequestType from "./RequestType.js";
import FeeData from "./FeeData.js";

export default class TransactionFeeSchedule {
    /**
     * @param {object} [props]
     * @param {RequestType} [props.hederaFunctionality]
     * @param {FeeData} [props.feeData]
     * @param {FeeData[]} [props.fees]
     */
    constructor(props = {}) {
        /*
         * A particular transaction or query
         *
         * @type {RequestType}
         */
        this.hederaFunctionality = props.hederaFunctionality;

        /*
         * Resource price coefficients
         *
         * @type {FeeData}
         */
        this.feeData = props.feeData;

        /*
         * Resource price coefficients
         *
         * @type {FeeData[]}
         */
        this.fees = props.fees;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionFeeSchedule}
     */
    static fromBytes(bytes) {
        return TransactionFeeSchedule._fromProtobuf(
            HieroProto.proto.TransactionFeeSchedule.decode(bytes),
        );
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransactionFeeSchedule} transactionFeeSchedule
     * @returns {TransactionFeeSchedule}
     */
    static _fromProtobuf(transactionFeeSchedule) {
        return new TransactionFeeSchedule({
            hederaFunctionality:
                transactionFeeSchedule.hederaFunctionality != null
                    ? RequestType._fromCode(
                          transactionFeeSchedule.hederaFunctionality,
                      )
                    : undefined,
            feeData:
                transactionFeeSchedule.feeData != null
                    ? FeeData._fromProtobuf(transactionFeeSchedule.feeData)
                    : undefined,
            fees:
                transactionFeeSchedule.fees != null
                    ? transactionFeeSchedule.fees.map((fee) =>
                          FeeData._fromProtobuf(fee),
                      )
                    : undefined,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITransactionFeeSchedule}
     */
    _toProtobuf() {
        return {
            hederaFunctionality:
                this.hederaFunctionality != null
                    ? this.hederaFunctionality.valueOf()
                    : undefined,
            feeData:
                this.feeData != null ? this.feeData._toProtobuf() : undefined,
            fees:
                this.fees != null
                    ? this.fees.map((fee) => fee._toProtobuf())
                    : undefined,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TransactionFeeSchedule.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/Transfer.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./account/AccountId.js";
import Hbar from "./Hbar.js";

/**
 * @typedef {object} TransferJSON
 * @property {string} accountId
 * @property {string} amount
 * @property {boolean} isApproved
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("long")} Long
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency transfer.
 */
export default class Transfer {
    /**
     * @internal
     * @param {object} props
     * @param {AccountId | string} props.accountId
     * @param {number | string | Long | BigNumber | Hbar} props.amount
     * @param {boolean} props.isApproved
     */
    constructor(props) {
        /**
         * The Account ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.accountId =
            props.accountId instanceof AccountId
                ? props.accountId
                : AccountId.fromString(props.accountId);

        /**
         * The amount of tinybars that the account sends(negative) or receives(positive).
         */
        this.amount =
            props.amount instanceof Hbar
                ? props.amount
                : new Hbar(props.amount);

        this.isApproved = props.isApproved;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IAccountAmount[]} accountAmounts
     * @returns {Transfer[]}
     */
    static _fromProtobuf(accountAmounts) {
        const transfers = [];

        for (const transfer of accountAmounts) {
            transfers.push(
                new Transfer({
                    accountId: AccountId._fromProtobuf(
                        /** @type {HieroProto.proto.IAccountID} */ (
                            transfer.accountID
                        ),
                    ),
                    amount: Hbar.fromTinybars(
                        transfer.amount != null ? transfer.amount : 0,
                    ),
                    isApproved: /** @type {boolean} */ (transfer.isApproval),
                }),
            );
        }

        return transfers;
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IAccountAmount}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            amount: this.amount.toTinybars(),
            isApproval: this.isApproved,
        };
    }

    /**
     * @returns {TransferJSON}
     */
    toJSON() {
        return {
            accountId: this.accountId.toString(),
            amount: this.amount.toTinybars().toString(),
            isApproved: this.isApproved,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
// Filename: src/Wallet.js
// SPDX-License-Identifier: Apache-2.0

import PrivateKey from "./PrivateKey.js";
import AccountId from "./account/AccountId.js";
import SignerSignature from "./SignerSignature.js";
import AccountBalanceQuery from "./account/AccountBalanceQuery.js";
import AccountInfoQuery from "./account/AccountInfoQuery.js";
import AccountRecordsQuery from "./account/AccountRecordsQuery.js";
import TransactionId from "./transaction/TransactionId.js";
import * as util from "./util.js";

/**
 * @template RequestT
 * @template ResponseT
 * @template OutputT
 * @typedef {import("./Executable.js").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>
 */

/**
 * @typedef {import("./Signer.js").Signer} Signer
 * @typedef {import("./Provider.js").Provider} Provider
 * @typedef {import("./LedgerId.js").default} LedgerId
 * @typedef {import("./Key.js").default} Key
 * @typedef {import("./transaction/Transaction.js").default} Transaction
 * @typedef {import("./transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("./transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./transaction/TransactionRecord.js").default} TransactionRecord
 * @typedef {import("./account/AccountBalance.js").default} AccountBalance
 * @typedef {import("./account/AccountInfo.js").default} AccountInfo
 */

/**
 * @template {any} O
 * @typedef {import("./query/Query.js").default<O>} Query<O>
 */

/**
 * @implements {Signer}
 */
export default class Wallet {
    /**
     * NOTE: When using string for private key, the string needs to contain DER headers
     *
     * @param {AccountId | string} accountId
     * @param {PrivateKey | string} privateKey
     * @param {Provider=} provider
     */
    constructor(accountId, privateKey, provider) {
        const key =
            typeof privateKey === "string"
                ? PrivateKey.fromStringDer(privateKey)
                : privateKey;

        this.publicKey = key.publicKey;
        /**
         * @type {(message: Uint8Array) => Promise<Uint8Array>}
         */
        this.signer = (message) => Promise.resolve(key.sign(message));
        this.provider = provider;
        this.accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;
    }

    /**
     * @returns {Promise<Wallet>}
     * @deprecated
     */
    static createRandomED25519() {
        const privateKey = PrivateKey.generateED25519();
        const publicKey = privateKey.publicKey;
        const accountId = publicKey.toAccountId(0, 0);
        return Promise.resolve(new Wallet(accountId, privateKey));
    }

    /**
     * @returns {Promise<Wallet>}
     * @deprecated
     */
    static createRandomECDSA() {
        const privateKey = PrivateKey.generateECDSA();
        const publicKey = privateKey.publicKey;
        const accountId = publicKey.toAccountId(0, 0);
        return Promise.resolve(new Wallet(accountId, privateKey));
    }

    /**
     * @returns {Provider=}
     */
    getProvider() {
        return this.provider;
    }

    /**
     * @abstract
     * @returns {AccountId}
     */
    getAccountId() {
        return this.accountId;
    }

    /**
     * @returns {Key}
     */
    getAccountKey() {
        return this.publicKey;
    }

    /**
     * @returns {LedgerId?}
     */
    getLedgerId() {
        return this.provider == null ? null : this.provider.getLedgerId();
    }

    /**
     * @abstract
     * @returns {{[key: string]: (string | AccountId)}}
     */
    getNetwork() {
        return this.provider == null ? {} : this.provider.getNetwork();
    }

    /**
     * @abstract
     * @returns {string[]}
     */
    getMirrorNetwork() {
        return this.provider == null ? [] : this.provider.getMirrorNetwork();
    }

    /**
     * @param {Uint8Array[]} messages
     * @returns {Promise<SignerSignature[]>}
     */
    async sign(messages) {
        const sigantures = [];

        for (const message of messages) {
            sigantures.push(
                new SignerSignature({
                    publicKey: this.publicKey,
                    signature: await this.signer(message),
                    accountId: this.accountId,
                }),
            );
        }

        return sigantures;
    }

    /**
     * @returns {Promise<AccountBalance>}
     */
    getAccountBalance() {
        return this.call(
            new AccountBalanceQuery().setAccountId(this.accountId),
        );
    }

    /**
     * @abstract
     * @returns {Promise<AccountInfo>}
     */
    getAccountInfo() {
        return this.call(new AccountInfoQuery().setAccountId(this.accountId));
    }

    /**
     * @abstract
     * @returns {Promise<TransactionRecord[]>}
     */
    getAccountRecords() {
        return this.call(
            new AccountRecordsQuery().setAccountId(this.accountId),
        );
    }

    /**
     * @template {Transaction} T
     * @param {T} transaction
     * @returns {Promise<T>}
     */
    signTransaction(transaction) {
        return transaction.signWith(this.publicKey, this.signer);
    }

    /**
     * @template {Transaction} T
     * @param {T} transaction
     * @returns {Promise<T>}
     */
    checkTransaction(transaction) {
        const transactionId = transaction.transactionId;
        if (
            transactionId != null &&
            transactionId.accountId != null &&
            transactionId.accountId.compare(this.accountId) != 0
        ) {
            throw new Error(
                "transaction's ID constructed with a different account ID",
            );
        }

        if (this.provider == null) {
            return Promise.resolve(transaction);
        }

        const nodeAccountIds = (
            transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []
        ).map((nodeAccountId) => nodeAccountId.toString());
        const network = Object.values(this.provider.getNetwork()).map(
            (nodeAccountId) => nodeAccountId.toString(),
        );

        if (
            !nodeAccountIds.reduce(
                (previous, current) => previous && network.includes(current),
                true,
            )
        ) {
            throw new Error(
                "Transaction already set node account IDs to values not within the current network",
            );
        }

        return Promise.resolve(transaction);
    }

    /**
     * @template {Transaction} T
     * @param {T} transaction
     * @returns {Promise<T>}
     */
    populateTransaction(transaction) {
        transaction._freezeWithAccountId(this.accountId);

        if (transaction.transactionId == null) {
            transaction.setTransactionId(
                TransactionId.generate(this.accountId),
            );
        }

        if (
            transaction.nodeAccountIds != null &&
            transaction.nodeAccountIds.length != 0
        ) {
            return Promise.resolve(transaction.freeze());
        }

        if (this.provider == null) {
            return Promise.resolve(transaction);
        }

        const nodeAccountIds = Object.values(this.provider.getNetwork()).map(
            (id) => (typeof id === "string" ? AccountId.fromString(id) : id),
        );
        util.shuffle(nodeAccountIds);
        transaction.setNodeAccountIds(
            nodeAccountIds.slice(0, (nodeAccountIds.length + 3 - 1) / 3),
        );

        return Promise.resolve(transaction.freeze());
    }

    /**
     * @template RequestT
     * @template ResponseT
     * @template OutputT
     * @param {Executable<RequestT, ResponseT, OutputT>} request
     * @returns {Promise<OutputT>}
     */
    call(request) {
        if (this.provider == null) {
            throw new Error(
                "cannot send request with an wallet that doesn't contain a provider",
            );
        }

        return this.provider.call(
            request._setOperatorWith(
                this.accountId,
                this.publicKey,
                this.signer,
            ),
        );
    }
}
// Filename: src/account/AccountAllowanceAdjustTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction from "../transaction/Transaction.js";
import AccountId from "./AccountId.js";
import ContractId from "../contract/ContractId.js";
import TokenId from "../token/TokenId.js";
import NftId from "../token/NftId.js";
import Long from "long";
import Hbar from "../Hbar.js";
import HbarAllowance from "./HbarAllowance.js";
import TokenAllowance from "./TokenAllowance.js";
import TokenNftAllowance from "./TokenNftAllowance.js";
import * as util from "../util.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../long.js").LongObject} LongObject
 */

/**
 * @deprecated - No longer supported via Hedera Protobufs
 * Change properties for the given account.
 */
export default class AccountAllowanceAdjustTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {HbarAllowance[]} [props.hbarAllowances]
     * @param {TokenAllowance[]} [props.tokenAllowances]
     * @param {TokenNftAllowance[]} [props.nftAllowances]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {HbarAllowance[]}
         */
        this._hbarAllowances =
            props.hbarAllowances != null ? props.hbarAllowances : [];

        /**
         * @private
         * @type {TokenAllowance[]}
         */
        this._tokenAllowances =
            props.tokenAllowances != null ? props.tokenAllowances : [];

        /**
         * @private
         * @type {TokenNftAllowance[]}
         */
        this._nftAllowances =
            props.nftAllowances != null ? props.nftAllowances : [];
    }

    /**
     * @returns {HbarAllowance[]}
     */
    get hbarAllowances() {
        return this._hbarAllowances;
    }

    /**
     * @deprecated
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addHbarAllowance(spenderAccountId, amount) {
        const value = amount instanceof Hbar ? amount : new Hbar(amount);
        return this._adjustHbarAllowance(
            null,
            spenderAccountId,
            util.requireNotNegative(value),
        );
    }

    /**
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._hbarAllowances.push(
            new HbarAllowance({
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toSolidityAddress(),
                            )
                          : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toSolidityAddress(),
                            )
                          : ownerAccountId,
                amount: amount,
            }),
        );

        return this;
    }

    /**
     * @deprecated
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        const value = amount instanceof Hbar ? amount : new Hbar(amount);
        return this._adjustHbarAllowance(
            ownerAccountId,
            spenderAccountId,
            util.requireNotNegative(value),
        );
    }

    /**
     * @deprecated
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        const value = amount instanceof Hbar ? amount : new Hbar(amount);
        return this._adjustHbarAllowance(
            ownerAccountId,
            spenderAccountId,
            util.requireNotNegative(value).negated(),
        );
    }

    /**
     * @returns {TokenAllowance[]}
     */
    get tokenAllowances() {
        return this._tokenAllowances;
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addTokenAllowance(tokenId, spenderAccountId, amount) {
        return this._adjustTokenAllowance(
            tokenId,
            null,
            spenderAccountId,
            util.requireNotNegative(Long.fromValue(amount)),
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._tokenAllowances.push(
            new TokenAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toSolidityAddress(),
                            )
                          : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toSolidityAddress(),
                            )
                          : ownerAccountId,
                amount:
                    typeof amount === "number"
                        ? Long.fromNumber(amount)
                        : amount,
            }),
        );

        return this;
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        return this._adjustTokenAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            util.requireNotNegative(Long.fromValue(amount)),
        );
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        return this._adjustTokenAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            util.requireNotNegative(Long.fromValue(amount)),
        );
    }

    /**
     * @deprecated
     * @param {NftId | string} nftId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addTokenNftAllowance(nftId, spenderAccountId) {
        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
        return this._adjustTokenNftAllowance(id, null, spenderAccountId);
    }

    /**
     * @param {NftId} nftId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        this._requireNotFrozen();

        const spender =
            typeof spenderAccountId === "string"
                ? AccountId.fromString(spenderAccountId)
                : spenderAccountId instanceof ContractId
                  ? AccountId.fromEvmAddress(
                        spenderAccountId.shard,
                        spenderAccountId.realm,
                        spenderAccountId.toSolidityAddress(),
                    )
                  : spenderAccountId;
        const owner =
            typeof ownerAccountId === "string"
                ? AccountId.fromString(ownerAccountId)
                : ownerAccountId instanceof ContractId
                  ? AccountId.fromEvmAddress(
                        ownerAccountId.shard,
                        ownerAccountId.realm,
                        ownerAccountId.toSolidityAddress(),
                    )
                  : ownerAccountId;
        let found = false;

        for (const allowance of this._nftAllowances) {
            if (
                allowance.tokenId.compare(nftId.tokenId) === 0 &&
                allowance.spenderAccountId != null &&
                allowance.spenderAccountId.compare(spender) === 0
            ) {
                if (allowance.serialNumbers != null) {
                    allowance.serialNumbers.push(nftId.serial);
                }
                found = true;
                break;
            }
        }

        if (!found) {
            this._nftAllowances.push(
                new TokenNftAllowance({
                    tokenId: nftId.tokenId,
                    spenderAccountId: spender,
                    serialNumbers: [nftId.serial],
                    ownerAccountId: owner,
                    allSerials: false,
                    delegatingSpender: null,
                }),
            );
        }

        return this;
    }

    /**
     * @deprecated
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        util.requireNotNegative(id.serial);

        return this._adjustTokenNftAllowance(
            id,
            ownerAccountId,
            spenderAccountId,
        );
    }

    /**
     * @deprecated
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        util.requireNotNegative(id.serial);
        return this._adjustTokenNftAllowance(
            new NftId(id.tokenId, id.serial.negate()),
            ownerAccountId,
            spenderAccountId,
        );
    }

    /**
     * @deprecated - use `grantTokenNftAllowanceAllSerials()` instead
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    addAllTokenNftAllowance(tokenId, spenderAccountId) {
        return this._adjustTokenNftAllowanceAllSerials(
            tokenId,
            null,
            spenderAccountId,
            true,
        );
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    grantTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId,
    ) {
        return this._adjustTokenNftAllowanceAllSerials(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            true,
        );
    }

    /**
     * @deprecated
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceAdjustTransaction}
     */
    revokeTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId,
    ) {
        return this._adjustTokenNftAllowanceAllSerials(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            false,
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {boolean} allSerials
     * @returns {AccountAllowanceAdjustTransaction}
     */
    _adjustTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId,
        allSerials,
    ) {
        this._requireNotFrozen();

        this._nftAllowances.push(
            new TokenNftAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                ownerAccountId:
                    ownerAccountId != null
                        ? typeof ownerAccountId === "string"
                            ? AccountId.fromString(ownerAccountId)
                            : ownerAccountId instanceof ContractId
                              ? AccountId.fromEvmAddress(
                                    ownerAccountId.shard,
                                    ownerAccountId.realm,
                                    ownerAccountId.toSolidityAddress(),
                                )
                              : ownerAccountId
                        : null,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toSolidityAddress(),
                            )
                          : spenderAccountId,
                serialNumbers: null,
                allSerials,
                delegatingSpender: null,
            }),
        );

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this._hbarAllowances.map((allowance) =>
            allowance._validateChecksums(client),
        );
        this._tokenAllowances.map((allowance) =>
            allowance._validateChecksums(client),
        );
        this._nftAllowances.map((allowance) =>
            allowance._validateChecksums(client),
        );
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _execute(channel, request) {
        return Promise.reject(
            new Error("This feature has been deprecated for this class."),
        );
    }

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * @deprecated
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        throw new Error("This feature has been deprecated for this class.");
    }

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * @override
     * @protected
     * @returns {object}
     */
    _makeTransactionData() {
        throw new Error("This feature has been deprecated.");
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountAllowanceAdjustTransaction:${timestamp.toString()}`;
    }
}
// Filename: src/account/AccountAllowanceApproveTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "./AccountId.js";
import ContractId from "../contract/ContractId.js";
import TokenId from "../token/TokenId.js";
import NftId from "../token/NftId.js";
import Long from "long";
import Hbar from "../Hbar.js";
import HbarAllowance from "./HbarAllowance.js";
import TokenAllowance from "./TokenAllowance.js";
import TokenNftAllowance from "./TokenNftAllowance.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoApproveAllowanceTransactionBody} HieroProto.proto.ICryptoApproveAllowanceTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../long.js").LongObject} LongObject
 */

/**
 * Change properties for the given account.
 */
export default class AccountAllowanceApproveTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {HbarAllowance[]} [props.hbarApprovals]
     * @param {TokenAllowance[]} [props.tokenApprovals]
     * @param {TokenNftAllowance[]} [props.nftApprovals]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {HbarAllowance[]}
         */
        this._hbarApprovals =
            props.hbarApprovals != null ? props.hbarApprovals : [];

        /**
         * @private
         * @type {TokenAllowance[]}
         */
        this._tokenApprovals =
            props.tokenApprovals != null ? props.tokenApprovals : [];

        /**
         * @private
         * @type {TokenNftAllowance[]}
         */
        this._nftApprovals =
            props.nftApprovals != null ? props.nftApprovals : [];
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {AccountAllowanceApproveTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const allowanceApproval =
            /** @type {HieroProto.proto.ICryptoApproveAllowanceTransactionBody} */ (
                body.cryptoApproveAllowance
            );

        return Transaction._fromProtobufTransactions(
            new AccountAllowanceApproveTransaction({
                hbarApprovals: (allowanceApproval.cryptoAllowances != null
                    ? allowanceApproval.cryptoAllowances
                    : []
                ).map((approval) => HbarAllowance._fromProtobuf(approval)),
                tokenApprovals: (allowanceApproval.tokenAllowances != null
                    ? allowanceApproval.tokenAllowances
                    : []
                ).map((approval) => TokenAllowance._fromProtobuf(approval)),
                nftApprovals: (allowanceApproval.nftAllowances != null
                    ? allowanceApproval.nftAllowances
                    : []
                ).map((approval) => TokenNftAllowance._fromProtobuf(approval)),
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {HbarAllowance[]}
     */
    get hbarApprovals() {
        return this._hbarApprovals;
    }

    /**
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveHbarAllowance(ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._hbarApprovals.push(
            new HbarAllowance({
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toSolidityAddress(),
                            )
                          : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toSolidityAddress(),
                            )
                          : ownerAccountId,
                amount: amount instanceof Hbar ? amount : new Hbar(amount),
            }),
        );

        return this;
    }

    /**
     * @deprecated - Use `approveHbarAllowance()` instead
     * @param {AccountId | string} spenderAccountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    addHbarAllowance(spenderAccountId, amount) {
        this._requireNotFrozen();

        this._hbarApprovals.push(
            new HbarAllowance({
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                amount: amount instanceof Hbar ? amount : new Hbar(amount),
                ownerAccountId: null,
            }),
        );

        return this;
    }

    /**
     * @returns {TokenAllowance[]}
     */
    get tokenApprovals() {
        return this._tokenApprovals;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenAllowance(tokenId, ownerAccountId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._tokenApprovals.push(
            new TokenAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toSolidityAddress(),
                            )
                          : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toSolidityAddress(),
                            )
                          : ownerAccountId,
                amount:
                    typeof amount === "number"
                        ? Long.fromNumber(amount)
                        : amount,
            }),
        );

        return this;
    }

    /**
     * @deprecated - Use `approveTokenAllowance()` instead
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} spenderAccountId
     * @param {Long | number} amount
     * @returns {AccountAllowanceApproveTransaction}
     */
    addTokenAllowance(tokenId, spenderAccountId, amount) {
        this._requireNotFrozen();

        this._tokenApprovals.push(
            new TokenAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId,
                amount:
                    typeof amount === "number"
                        ? Long.fromNumber(amount)
                        : amount,
                ownerAccountId: null,
            }),
        );

        return this;
    }

    /**
     * @deprecated - Use `approveTokenNftAllowance()` instead
     * @param {NftId | string} nftId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    addTokenNftAllowance(nftId, spenderAccountId) {
        return this._approveTokenNftAllowance(
            nftId,
            null,
            spenderAccountId,
            null,
        );
    }

    /**
     * @returns {TokenNftAllowance[]}
     */
    get tokenNftApprovals() {
        return this._nftApprovals;
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {AccountId | string | null} delegatingSpender
     * @returns {AccountAllowanceApproveTransaction}
     */
    _approveTokenNftAllowance(
        nftId,
        ownerAccountId,
        spenderAccountId,
        delegatingSpender,
    ) {
        this._requireNotFrozen();

        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;
        const spender =
            typeof spenderAccountId === "string"
                ? AccountId.fromString(spenderAccountId)
                : spenderAccountId instanceof ContractId
                  ? AccountId.fromEvmAddress(
                        spenderAccountId.shard,
                        spenderAccountId.realm,
                        spenderAccountId.toSolidityAddress(),
                    )
                  : spenderAccountId;
        let found = false;

        for (const allowance of this._nftApprovals) {
            if (
                allowance.tokenId.compare(id.tokenId) === 0 &&
                allowance.spenderAccountId != null &&
                allowance.spenderAccountId.compare(spender) === 0
            ) {
                if (allowance.serialNumbers != null) {
                    allowance.serialNumbers.push(id.serial);
                }
                found = true;
                break;
            }
        }

        if (!found) {
            this._nftApprovals.push(
                new TokenNftAllowance({
                    tokenId: id.tokenId,
                    spenderAccountId: spender,
                    ownerAccountId:
                        typeof ownerAccountId === "string"
                            ? AccountId.fromString(ownerAccountId)
                            : ownerAccountId instanceof ContractId
                              ? AccountId.fromEvmAddress(
                                    ownerAccountId.shard,
                                    ownerAccountId.realm,
                                    ownerAccountId.toSolidityAddress(),
                                )
                              : ownerAccountId,
                    serialNumbers: [id.serial],
                    allSerials: false,
                    delegatingSpender:
                        typeof delegatingSpender === "string"
                            ? AccountId.fromString(delegatingSpender)
                            : delegatingSpender,
                }),
            );
        }

        return this;
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenNftAllowance(nftId, ownerAccountId, spenderAccountId) {
        return this._approveTokenNftAllowance(
            nftId,
            ownerAccountId,
            spenderAccountId,
            null,
        );
    }

    /**
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {AccountId | string} delegatingSpender
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenNftAllowanceWithDelegatingSpender(
        nftId,
        ownerAccountId,
        spenderAccountId,
        delegatingSpender,
    ) {
        return this._approveTokenNftAllowance(
            nftId,
            ownerAccountId,
            spenderAccountId,
            delegatingSpender,
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string | null} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @param {boolean} allSerials
     * @returns {AccountAllowanceApproveTransaction}
     */
    _approveAllTokenNftAllowance(
        tokenId,
        ownerAccountId,
        spenderAccountId,
        allSerials,
    ) {
        this._requireNotFrozen();

        this._nftApprovals.push(
            new TokenNftAllowance({
                tokenId:
                    typeof tokenId === "string"
                        ? TokenId.fromString(tokenId)
                        : tokenId,
                spenderAccountId:
                    typeof spenderAccountId === "string"
                        ? AccountId.fromString(spenderAccountId)
                        : spenderAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                spenderAccountId.shard,
                                spenderAccountId.realm,
                                spenderAccountId.toSolidityAddress(),
                            )
                          : spenderAccountId,
                ownerAccountId:
                    typeof ownerAccountId === "string"
                        ? AccountId.fromString(ownerAccountId)
                        : ownerAccountId instanceof ContractId
                          ? AccountId.fromEvmAddress(
                                ownerAccountId.shard,
                                ownerAccountId.realm,
                                ownerAccountId.toSolidityAddress(),
                            )
                          : ownerAccountId,
                serialNumbers: null,
                allSerials,
                delegatingSpender: null,
            }),
        );

        return this;
    }

    /**
     * @deprecated - Use `approveTokenNftAllowanceAllSerials()` instead
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    addAllTokenNftAllowance(tokenId, ownerAccountId, spenderAccountId) {
        return this._approveAllTokenNftAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            true,
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    approveTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId,
    ) {
        return this._approveAllTokenNftAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            true,
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} ownerAccountId
     * @param {AccountId | ContractId | string} spenderAccountId
     * @returns {AccountAllowanceApproveTransaction}
     */
    deleteTokenNftAllowanceAllSerials(
        tokenId,
        ownerAccountId,
        spenderAccountId,
    ) {
        return this._approveAllTokenNftAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            false,
        );
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this._hbarApprovals.map((approval) =>
            approval._validateChecksums(client),
        );
        this._tokenApprovals.map((approval) =>
            approval._validateChecksums(client),
        );
        this._nftApprovals.map((approval) =>
            approval._validateChecksums(client),
        );
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.approveAllowances(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoApproveAllowance";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoApproveAllowanceTransactionBody}
     */
    _makeTransactionData() {
        return {
            cryptoAllowances: this._hbarApprovals.map((approval) =>
                approval._toProtobuf(),
            ),
            tokenAllowances: this._tokenApprovals.map((approval) =>
                approval._toProtobuf(),
            ),
            nftAllowances: this._nftApprovals.map((approval) =>
                approval._toProtobuf(),
            ),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountAllowanceApproveTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoApproveAllowance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountAllowanceApproveTransaction._fromProtobuf,
);
// Filename: src/account/AccountAllowanceDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "./AccountId.js";
import NftId from "../token/NftId.js";
import TokenNftAllowance from "./TokenNftAllowance.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoDeleteAllowanceTransactionBody} HieroProto.proto.ICryptoDeleteAllowanceTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("./HbarAllowance.js").default} HbarAllowance
 * @typedef {import("./TokenAllowance.js").default} TokenAllowance
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../long.js").LongObject} LongObject
 */

/**
 * Change properties for the given account.
 */
export default class AccountAllowanceDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {HbarAllowance[]} [props.hbarAllowances]
     * @param {TokenAllowance[]} [props.tokenAllowances]
     * @param {TokenNftAllowance[]} [props.nftAllowances]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {TokenNftAllowance[]}
         */
        this._nftAllowances =
            props.nftAllowances != null ? props.nftAllowances : [];
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {AccountAllowanceDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const allowance =
            /** @type {HieroProto.proto.ICryptoDeleteAllowanceTransactionBody} */ (
                body.cryptoDeleteAllowance
            );

        return Transaction._fromProtobufTransactions(
            new AccountAllowanceDeleteTransaction({
                nftAllowances: (allowance.nftAllowances != null
                    ? allowance.nftAllowances
                    : []
                ).map((allowance) =>
                    TokenNftAllowance._fromProtobuf(allowance),
                ),
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {TokenNftAllowance[]}
     */
    get tokenNftAllowanceDeletions() {
        return this._nftAllowances;
    }

    /**
     * @description If you want to remove allowance for all serials of a NFT
     *      - use AccountAllowanceApproveTransaction().deleteTokenNftAllowanceAllSerials()
     * @param {NftId | string} nftId
     * @param {AccountId | string} ownerAccountId
     * @returns {AccountAllowanceDeleteTransaction}
     */
    deleteAllTokenNftAllowances(nftId, ownerAccountId) {
        this._requireNotFrozen();

        const id = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        const owner =
            typeof ownerAccountId === "string"
                ? AccountId.fromString(ownerAccountId)
                : ownerAccountId;
        let found = false;

        for (const allowance of this._nftAllowances) {
            if (allowance.tokenId.compare(id.tokenId) === 0) {
                if (allowance.serialNumbers != null) {
                    allowance.serialNumbers.push(id.serial);
                }
                found = true;
                break;
            }
        }

        if (!found) {
            this._nftAllowances.push(
                new TokenNftAllowance({
                    tokenId: id.tokenId,
                    spenderAccountId: null,
                    serialNumbers: [id.serial],
                    ownerAccountId: owner,
                    allSerials: false,
                    delegatingSpender: null,
                }),
            );
        }

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this._nftAllowances.map((allowance) =>
            allowance._validateChecksums(client),
        );
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.deleteAllowances(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoDeleteAllowance";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoDeleteAllowanceTransactionBody}
     */
    _makeTransactionData() {
        return {
            nftAllowances: this._nftAllowances.map((allowance) =>
                allowance._toProtobuf(),
            ),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountAllowanceDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoDeleteAllowance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountAllowanceDeleteTransaction._fromProtobuf,
);
// Filename: src/account/AccountBalance.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import Hbar from "../Hbar.js";
import TokenId from "../token/TokenId.js";
import TokenBalanceMap from "./TokenBalanceMap.js";
import TokenDecimalMap from "./TokenDecimalMap.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {object} TokenBalanceJson
 * @property {string} tokenId
 * @property {string} balance
 * @property {number} decimals
 */

/**
 * @typedef {object} AccountBalanceJson
 * @property {string} hbars
 * @property {TokenBalanceJson[]} tokens
 */

/**
 * Represents the balance of an account on the Hedera network, including both HBAR and token balances.
 */
export default class AccountBalance {
    /**
     * @private
     * @param {object} props
     * @param {Hbar} props.hbars
     * @param {?TokenBalanceMap} props.tokens
     * @param {?TokenDecimalMap} props.tokenDecimals
     */
    constructor(props) {
        /**
         * The Hbar balance of the account
         *
         * @readonly
         */
        this.hbars = props.hbars;

        this.tokens = props.tokens;

        this.tokenDecimals = props.tokenDecimals;

        Object.freeze(this);
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {AccountBalance}
     */
    static fromBytes(bytes) {
        return AccountBalance._fromProtobuf(
            HieroProto.proto.CryptoGetAccountBalanceResponse.decode(bytes),
        );
    }

    /**
     * @internal
     * @param {HieroProto.proto.ICryptoGetAccountBalanceResponse} accountBalance
     * @returns {AccountBalance}
     */
    static _fromProtobuf(accountBalance) {
        const tokenBalances = new TokenBalanceMap();
        const tokenDecimals = new TokenDecimalMap();

        if (accountBalance.tokenBalances != null) {
            for (const balance of accountBalance.tokenBalances) {
                const tokenId = TokenId._fromProtobuf(
                    /** @type {HieroProto.proto.ITokenID} */ (balance.tokenId),
                );

                tokenDecimals._set(
                    tokenId,
                    balance.decimals != null ? balance.decimals : 0,
                );
                tokenBalances._set(
                    tokenId,
                    Long.fromValue(/** @type {Long} */ (balance.balance)),
                );
            }
        }

        return new AccountBalance({
            hbars: Hbar.fromTinybars(
                /** @type {Long} */ (accountBalance.balance),
            ),
            tokens: tokenBalances,
            tokenDecimals,
        });
    }

    /**
     * @returns {HieroProto.proto.ICryptoGetAccountBalanceResponse}
     */
    _toProtobuf() {
        /** @type {HieroProto.proto.ITokenBalance[]} */
        const list = [];

        // eslint-disable-next-line deprecation/deprecation
        for (const [key, value] of this.tokens != null ? this.tokens : []) {
            list.push({
                tokenId: key._toProtobuf(),
                balance: value,
                decimals:
                    // eslint-disable-next-line deprecation/deprecation
                    this.tokenDecimals != null
                        ? // eslint-disable-next-line deprecation/deprecation
                          this.tokenDecimals.get(key)
                        : null,
            });
        }

        return {
            balance: this.hbars.toTinybars(),
            tokenBalances: list,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.CryptoGetAccountBalanceResponse.encode(
            this._toProtobuf(),
        ).finish();
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {AccountBalanceJson}
     */
    toJSON() {
        const tokens = [];
        // eslint-disable-next-line deprecation/deprecation
        for (const [key, value] of this.tokens != null ? this.tokens : []) {
            const decimals =
                // eslint-disable-next-line deprecation/deprecation
                this.tokenDecimals != null ? this.tokenDecimals.get(key) : null;

            tokens.push({
                tokenId: key.toString(),
                balance: value.toString(),
                decimals: decimals != null ? decimals : 0,
            });
        }

        return {
            hbars: this.hbars.toString(),
            tokens,
        };
    }
}
// Filename: src/account/AccountBalanceQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import AccountId from "./AccountId.js";
import ContractId from "../contract/ContractId.js";
import AccountBalance from "./AccountBalance.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountBalanceQuery} HieroProto.proto.ICryptoGetAccountBalanceQuery
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountBalanceResponse} HieroProto.proto.ICryptoGetAccountBalanceResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get the balance of a Hedera™ crypto-currency account.
 *
 * This returns only the balance, so its a smaller and faster reply
 * than AccountInfoQuery.
 *
 * This query is free.
 *
 * @augments {Query<AccountBalance>}
 */
export default class AccountBalanceQuery extends Query {
    /**
     * @param {object} [props]
     * @param {AccountId | string} [props.accountId]
     * @param {ContractId | string} [props.contractId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        /**
         * @type {?ContractId}
         * @private
         */
        this._contractId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {AccountBalanceQuery}
     */
    static _fromProtobuf(query) {
        const balance =
            /** @type {HieroProto.proto.ICryptoGetAccountBalanceQuery} */ (
                query.cryptogetAccountBalance
            );

        return new AccountBalanceQuery({
            accountId:
                balance.accountID != null
                    ? AccountId._fromProtobuf(balance.accountID)
                    : undefined,
            contractId:
                balance.contractID != null
                    ? ContractId._fromProtobuf(balance.contractID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the balance is being requested.
     *
     * This is mutually exclusive with `setContractId`.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the balance is being requested.
     *
     * This is mutually exclusive with `setAccountId`.
     *
     * @param {ContractId | string} contractId
     * @returns {this}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @protected
     * @override
     * @returns {boolean}
     */
    _isPaymentRequired() {
        return false;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.cryptoGetBalance(request);
    }

    /**
     * @override
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptogetAccountBalance =
            /** @type {HieroProto.proto.ICryptoGetAccountBalanceResponse} */ (
                response.cryptogetAccountBalance
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            cryptogetAccountBalance.header
        );
    }

    /**
     * @override
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<AccountBalance>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const cryptogetAccountBalance =
            /** @type {HieroProto.proto.ICryptoGetAccountBalanceResponse} */ (
                response.cryptogetAccountBalance
            );
        return Promise.resolve(
            AccountBalance._fromProtobuf(cryptogetAccountBalance),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptogetAccountBalance: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        return `AccountBalanceQuery:${this._timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "cryptogetAccountBalance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountBalanceQuery._fromProtobuf,
);
// Filename: src/account/AccountCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import * as HieroProto from "@hashgraph/proto";
import Hbar from "../Hbar.js";
import AccountId from "./AccountId.js";
import Transaction, {
    DEFAULT_AUTO_RENEW_PERIOD,
    DEFAULT_RECORD_THRESHOLD,
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Duration from "../Duration.js";
import Long from "long";
import Key from "../Key.js";
import PrivateKey from "../PrivateKey.js";
import EvmAddress from "../EvmAddress.js";

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera™ crypto-currency account.
 */
export default class AccountCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Key} [props.key]
     * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
     * @param {boolean} [props.receiverSignatureRequired]
     * @param {AccountId} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.accountMemo]
     * @param {Long | number} [props.maxAutomaticTokenAssociations]
     * @param {AccountId | string} [props.stakedAccountId]
     * @param {Long | number} [props.stakedNodeId]
     * @param {boolean} [props.declineStakingReward]
     * @param {EvmAddress} [props.alias]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key}
         */
        this._key = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._initialBalance = null;

        /**
         * @private
         * @type {Hbar}
         */
        this._sendRecordThreshold = DEFAULT_RECORD_THRESHOLD;

        /**
         * @private
         * @type {Hbar}
         */
        this._receiveRecordThreshold = DEFAULT_RECORD_THRESHOLD;

        /**
         * @private
         * @type {boolean}
         */
        this._receiverSignatureRequired = false;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?string}
         */
        this._accountMemo = null;

        /**
         * @private
         * @type {?Long}
         */
        this._maxAutomaticTokenAssociations = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._stakedAccountId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._stakedNodeId = null;

        /**
         * @private
         * @type {boolean}
         */
        this._declineStakingReward = false;

        /**
         * @private
         * @type {?EvmAddress}
         */
        this._alias = null;

        if (props.key != null) {
            this.setKeyWithoutAlias(props.key);
        }

        if (props.receiverSignatureRequired != null) {
            this.setReceiverSignatureRequired(props.receiverSignatureRequired);
        }

        if (props.initialBalance != null) {
            this.setInitialBalance(props.initialBalance);
        }

        if (props.proxyAccountId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.accountMemo != null) {
            this.setAccountMemo(props.accountMemo);
        }

        if (props.maxAutomaticTokenAssociations != null) {
            this.setMaxAutomaticTokenAssociations(
                props.maxAutomaticTokenAssociations,
            );
        }

        if (props.stakedAccountId != null) {
            this.setStakedAccountId(props.stakedAccountId);
        }

        if (props.stakedNodeId != null) {
            this.setStakedNodeId(props.stakedNodeId);
        }

        if (props.declineStakingReward != null) {
            this.setDeclineStakingReward(props.declineStakingReward);
        }

        if (props.alias != null) {
            this.setAlias(props.alias);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {AccountCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const create =
            /** @type {HieroProto.proto.ICryptoCreateTransactionBody} */ (
                body.cryptoCreateAccount
            );

        let alias = undefined;
        if (create.alias != null && create.alias.length > 0) {
            if (create.alias.length === 20) {
                alias = EvmAddress.fromBytes(create.alias);
            }
        }

        return Transaction._fromProtobufTransactions(
            new AccountCreateTransaction({
                key:
                    create.key != null
                        ? Key._fromProtobufKey(create.key)
                        : undefined,
                initialBalance:
                    create.initialBalance != null
                        ? Hbar.fromTinybars(create.initialBalance)
                        : undefined,
                receiverSignatureRequired:
                    create.receiverSigRequired != null
                        ? create.receiverSigRequired
                        : undefined,
                proxyAccountId:
                    create.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  create.proxyAccountID
                              ),
                          )
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? create.autoRenewPeriod.seconds != null
                            ? create.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                accountMemo: create.memo != null ? create.memo : undefined,
                maxAutomaticTokenAssociations:
                    create.maxAutomaticTokenAssociations != null
                        ? create.maxAutomaticTokenAssociations
                        : undefined,
                stakedAccountId:
                    create.stakedAccountId != null
                        ? AccountId._fromProtobuf(create.stakedAccountId)
                        : undefined,
                stakedNodeId:
                    create.stakedNodeId != null
                        ? create.stakedNodeId
                        : undefined,
                declineStakingReward: create.declineReward == true,
                alias,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?Key}
     */
    get key() {
        return this._key;
    }

    /**
     * Set the key for this account.
     *
     * This is the key that must sign each transfer out of the account.
     *
     * If `receiverSignatureRequired` is true, then the key must also sign
     * any transfer into the account.
     *
     * @deprecated Use `setKeyWithoutAlias` instead.
     * @param {Key} key
     * @returns {this}
     */
    setKey(key) {
        this._requireNotFrozen();
        this._key = key;

        return this;
    }

    /**
     * Sets an ECDSA private key and a derived alias from this key in the background.
     * @param {PrivateKey} key - An ECDSA private key used for signing transactions and alias derivation.
     * @returns {this}
     */
    setECDSAKeyWithAlias(key) {
        this.setKeyWithoutAlias(key);

        if (!(key instanceof PrivateKey) || key.type !== "secp256k1") {
            throw new Error(
                "'key' must be an ECDSA private key when 'aliasKey' is not provided.",
            );
        }
        this.setAlias(key.publicKey.toEvmAddress());

        return this;
    }

    /**
     * Sets an account key and an alias derived from a separate ECDSA key.
     * The transaction must be signed by both keys.
     * @param {Key} key - The primary account key used for signing transactions.
     * @param {PrivateKey} aliasKey - The ECDSA private key used to derive the EVM address.
     * @returns {this}
     */
    setKeyWithAlias(key, aliasKey) {
        this.setKeyWithoutAlias(key);

        if (
            !(aliasKey instanceof PrivateKey) ||
            aliasKey.type !== "secp256k1"
        ) {
            throw new Error(
                "'aliasKey' must be an ECDSA private key when provided.",
            );
        }
        this.setAlias(aliasKey.publicKey.toEvmAddress());

        return this;
    }

    /**
     * Set the key for this account without an alias.
     *
     * This is the key that must sign each transfer out of the account.
     *
     * If `receiverSignatureRequired` is true, then the key must also sign
     * any transfer into the account.
     *
     *
     * @param {Key} key
     * @returns {this}
     */
    setKeyWithoutAlias(key) {
        this._requireNotFrozen();
        this._key = key;

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get initialBalance() {
        return this._initialBalance;
    }

    /**
     * Set the initial amount to transfer into this account.
     *
     * @param {number | string | Long | BigNumber | Hbar} initialBalance
     * @returns {this}
     */
    setInitialBalance(initialBalance) {
        this._requireNotFrozen();
        this._initialBalance =
            initialBalance instanceof Hbar
                ? initialBalance
                : new Hbar(initialBalance);

        return this;
    }

    /**
     * @returns {boolean}
     */
    get receiverSignatureRequired() {
        return this._receiverSignatureRequired;
    }

    /**
     * Set to true to require the key for this account to sign any transfer of
     * hbars to this account.
     *
     * @param {boolean} receiverSignatureRequired
     * @returns {this}
     */
    setReceiverSignatureRequired(receiverSignatureRequired) {
        this._requireNotFrozen();
        this._receiverSignatureRequired = receiverSignatureRequired;

        return this;
    }

    /**
     * @deprecated
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @deprecated
     *
     * Set the ID of the account to which this account is proxy staked.
     * @param {AccountId} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId = proxyAccountId;

        return this;
    }

    /**
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?string}
     */
    get accountMemo() {
        return this._accountMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setAccountMemo(memo) {
        this._requireNotFrozen();
        this._accountMemo = memo;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get maxAutomaticTokenAssociations() {
        return this._maxAutomaticTokenAssociations;
    }

    /**
     * @param {Long | number} maxAutomaticTokenAssociations
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
        this._requireNotFrozen();
        this._maxAutomaticTokenAssociations =
            typeof maxAutomaticTokenAssociations === "number"
                ? Long.fromNumber(maxAutomaticTokenAssociations)
                : maxAutomaticTokenAssociations;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get stakedAccountId() {
        return this._stakedAccountId;
    }

    /**
     * @param {AccountId | string} stakedAccountId
     * @returns {this}
     */
    setStakedAccountId(stakedAccountId) {
        this._requireNotFrozen();
        this._stakedAccountId =
            typeof stakedAccountId === "string"
                ? AccountId.fromString(stakedAccountId)
                : stakedAccountId;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get stakedNodeId() {
        return this._stakedNodeId;
    }

    /**
     * @param {Long | number} stakedNodeId
     * @returns {this}
     */
    setStakedNodeId(stakedNodeId) {
        this._requireNotFrozen();
        this._stakedNodeId = Long.fromValue(stakedNodeId);

        return this;
    }

    /**
     * @returns {boolean}
     */
    get declineStakingRewards() {
        return this._declineStakingReward;
    }

    /**
     * @param {boolean} declineStakingReward
     * @returns {this}
     */
    setDeclineStakingReward(declineStakingReward) {
        this._requireNotFrozen();
        this._declineStakingReward = declineStakingReward;

        return this;
    }

    /**
     * The bytes to be used as the account's alias.
     *
     * The bytes must be formatted as the calcluated last 20 bytes of the
     * keccak-256 of the ECDSA primitive key.
     *
     * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
     * delegatable_contract_id, are not supported.
     *
     * At most only one account can ever have a given alias on the network.
     *
     * @returns {?EvmAddress}
     */
    get alias() {
        return this._alias;
    }

    /**
     * The bytes to be used as the account's alias.
     *
     * The bytes must be formatted as the calcluated last 20 bytes of the
     * keccak-256 of the ECDSA primitive key.
     *
     * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
     * delegatable_contract_id, are not supported.
     *
     * At most only one account can ever have a given alias on the network.
     *
     * @param {string | EvmAddress} alias
     * @returns {this}
     */
    setAlias(alias) {
        if (typeof alias === "string") {
            if (
                (alias.startsWith("0x") && alias.length == 42) ||
                alias.length == 40
            ) {
                this._alias = EvmAddress.fromString(alias);
            } else {
                throw new Error(
                    'evmAddress must be a valid EVM address with or without "0x" prefix',
                );
            }
        } else {
            this._alias = alias;
        }

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.createAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoCreateAccount";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoCreateTransactionBody}
     */
    _makeTransactionData() {
        let alias = null;
        if (this._alias != null) {
            alias = this._alias.toBytes();
        }

        return {
            key: this._key != null ? this._key._toProtobufKey() : null,
            initialBalance:
                this._initialBalance != null
                    ? this._initialBalance.toTinybars()
                    : null,
            autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(),
            sendRecordThreshold: this._sendRecordThreshold.toTinybars(),
            receiverSigRequired: this._receiverSignatureRequired,
            memo: this._accountMemo,
            maxAutomaticTokenAssociations:
                this._maxAutomaticTokenAssociations != null
                    ? this._maxAutomaticTokenAssociations.toInt()
                    : null,
            stakedAccountId:
                this.stakedAccountId != null
                    ? this.stakedAccountId._toProtobuf()
                    : null,
            stakedNodeId: this.stakedNodeId,
            declineReward: this.declineStakingRewards,
            alias,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoCreateAccount",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountCreateTransaction._fromProtobuf,
);
// Filename: src/account/AccountDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoDeleteTransactionBody} HieroProto.proto.ICryptoDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Marks an account as deleted, moving all its current hbars to another account.
 *
 * It will remain in the ledger, marked as deleted, until it expires.
 * Transfers into it a deleted account fail. But a deleted account can still have its
 * expiration extended in the normal way.
 */
export default class AccountDeleteTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {AccountId} [props.accountId]
     * @param {AccountId} [props.transferAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._transferAccountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.transferAccountId != null) {
            this.setTransferAccountId(props.transferAccountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {AccountDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const accountDelete =
            /** @type {HieroProto.proto.ICryptoDeleteTransactionBody} */ (
                body.cryptoDelete
            );

        return Transaction._fromProtobufTransactions(
            new AccountDeleteTransaction({
                accountId:
                    accountDelete.deleteAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  accountDelete.deleteAccountID
                              ),
                          )
                        : undefined,
                transferAccountId:
                    accountDelete.transferAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  accountDelete.transferAccountID
                              ),
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID which is being deleted in this transaction.
     *
     * @param {AccountId | string} accountId
     * @returns {AccountDeleteTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get transferAccountId() {
        return this._transferAccountId;
    }

    /**
     * Set the account ID which will receive all remaining hbars.
     *
     * @param {AccountId | string} transferAccountId
     * @returns {AccountDeleteTransaction}
     */
    setTransferAccountId(transferAccountId) {
        this._requireNotFrozen();
        this._transferAccountId =
            typeof transferAccountId === "string"
                ? AccountId.fromString(transferAccountId)
                : transferAccountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        if (this._transferAccountId != null) {
            this._transferAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.cryptoDelete(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoDelete";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            deleteAccountID:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            transferAccountID:
                this._transferAccountId != null
                    ? this._transferAccountId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoDelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountDeleteTransaction._fromProtobuf,
);
// Filename: src/account/AccountId.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import * as entity_id from "../EntityIdHelper.js";
import * as HieroProto from "@hashgraph/proto";
import Key from "../Key.js";
import PublicKey from "../PublicKey.js";
import CACHE from "../Cache.js";
import EvmAddress from "../EvmAddress.js";
import * as hex from ".././encoding/hex.js";
import { isLongZeroAddress } from "../util.js";

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency account on Hedera.
 */
export default class AccountId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     * @param {(PublicKey)=} aliasKey
     * @param {(EvmAddress)=} evmAddress
     */
    constructor(props, realm, num, aliasKey, evmAddress) {
        const result = entity_id.constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;
        this.aliasKey = aliasKey != null ? aliasKey : null;
        this.evmAddress = evmAddress != null ? evmAddress : null;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @description Accepts the following formats as string:
     *      - as stand alone nubmers
     *      - as shard.realm.num
     *      - as shard.realm.hex (wo 0x prefix)
     *      - hex (w/wo 0x prefix)
     * @param {string} text
     * @returns {AccountId}
     */
    static fromString(text) {
        let shard = Long.ZERO;
        let realm = Long.ZERO;
        let num = Long.ZERO;
        let aliasKey = undefined;
        let evmAddress = undefined;

        if ((text.startsWith("0x") && text.length == 42) || text.length == 40) {
            evmAddress = EvmAddress.fromString(text);
        } else {
            const result = entity_id.fromStringSplitter(text);

            if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
                throw new Error("invalid format for entity ID");
            }

            if (result.shard != null) shard = Long.fromString(result.shard);
            if (result.realm != null) realm = Long.fromString(result.realm);

            if (result.numOrHex.length < 20) {
                num = Long.fromString(result.numOrHex);
            } else if (result.numOrHex.length == 40) {
                evmAddress = EvmAddress.fromString(result.numOrHex);
            } else {
                aliasKey = PublicKey.fromString(result.numOrHex);
            }
        }

        return new AccountId(shard, realm, num, aliasKey, evmAddress);
    }

    /**
     * @description This handles both long-zero format and evm address format addresses.
     * If an actual evm address is passed, please use `AccountId.populateAccountNum(client)` method
     * to get the actual `num` value, since there is no cryptographic relation to the evm address
     * and cannot be populated directly
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @param {EvmAddress | string} evmAddress
     * @returns {AccountId}
     */
    static fromEvmAddress(shard, realm, evmAddress) {
        const evmAddressObj =
            typeof evmAddress === "string"
                ? EvmAddress.fromString(evmAddress)
                : evmAddress;

        if (isLongZeroAddress(evmAddressObj.toBytes())) {
            return new AccountId(
                ...entity_id.fromSolidityAddress(evmAddressObj.toString()),
            );
        } else {
            return new AccountId(shard, realm, 0, undefined, evmAddressObj);
        }
    }

    /**
     * @deprecated - Use `fromEvmAddress` instead
     * @summary Accepts an evm address only as `EvmAddress` type
     * @param {EvmAddress} evmAddress
     * @returns {AccountId}
     */
    static fromEvmPublicAddress(evmAddress) {
        return new AccountId(0, 0, 0, undefined, evmAddress);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IAccountID} id
     * @returns {AccountId}
     */
    static _fromProtobuf(id) {
        let aliasKey = undefined;
        let evmAddress = undefined;

        if (id.alias != null) {
            if (id.alias.length === 20) {
                evmAddress = EvmAddress.fromBytes(id.alias);
            } else {
                aliasKey = Key._fromProtobufKey(
                    HieroProto.proto.Key.decode(id.alias),
                );
            }
        }

        if (!(aliasKey instanceof PublicKey)) {
            aliasKey = undefined;
        }

        return new AccountId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.accountNum != null ? id.accountNum : 0,
            aliasKey,
            evmAddress,
        );
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @returns {?EvmAddress}
     */
    getEvmAddress() {
        return this.evmAddress;
    }

    /**
     * @description Gets the actual `num` field of the `AccountId` from the Mirror Node.
     * Should be used after generating `AccountId.fromEvmAddress()` because it sets the `num` field to `0`
     * automatically since there is no connection between the `num` and the `evmAddress`
     * @param {Client} client
     * @returns {Promise<AccountId>}
     */
    async populateAccountNum(client) {
        if (this.evmAddress === null) {
            throw new Error("field `evmAddress` should not be null");
        }
        const mirrorUrl = client.mirrorNetwork[0].slice(
            0,
            client.mirrorNetwork[0].indexOf(":"),
        );

        await new Promise((resolve) => {
            setTimeout(resolve, 3000);
        });

        /* eslint-disable */
        const url = `https://${mirrorUrl}/api/v1/accounts/${this.evmAddress.toString()}`;
        const response = await fetch(url);
        const data = await response.json();
        const mirrorAccountId = data.account;

        this.num = Long.fromString(
            mirrorAccountId.slice(mirrorAccountId.lastIndexOf(".") + 1),
        );
        /* eslint-enable */

        return this;
    }

    /**
     * @description Populates `evmAddress` field of the `AccountId` extracted from the Mirror Node.
     * @param {Client} client
     * @returns {Promise<AccountId>}
     */
    async populateAccountEvmAddress(client) {
        if (this.num === null) {
            throw new Error("field `num` should not be null");
        }
        const mirrorUrl = client.mirrorNetwork[0].slice(
            0,
            client.mirrorNetwork[0].indexOf(":"),
        );

        await new Promise((resolve) => {
            setTimeout(resolve, 3000);
        });

        /* eslint-disable */
        const url = `https://${mirrorUrl}/api/v1/accounts/${this.num.toString()}`;
        const response = await fetch(url);
        const data = await response.json();
        const mirrorAccountId = data.evm_address;

        this.evmAddress = EvmAddress.fromString(mirrorAccountId);
        /* eslint-enable */

        return this;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        if (this.aliasKey != null) {
            throw new Error(
                "cannot calculate checksum with an account ID that has a aliasKey",
            );
        }

        entity_id.validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {AccountId}
     */
    static fromBytes(bytes) {
        return AccountId._fromProtobuf(
            HieroProto.proto.AccountID.decode(bytes),
        );
    }

    /**
     * @deprecated - Use `fromEvmAddress` instead
     * @param {string} address
     * @returns {AccountId}
     */
    static fromSolidityAddress(address) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (isLongZeroAddress(hex.decode(address))) {
            return new AccountId(...entity_id.fromSolidityAddress(address));
        } else {
            return this.fromEvmAddress(0, 0, address);
        }
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        if (this.evmAddress != null) {
            return this.evmAddress.toString();
        } else if (
            this.aliasKey != null &&
            this.aliasKey._key._type == "secp256k1"
        ) {
            return this.aliasKey.toEvmAddress();
        } else {
            return entity_id.toSolidityAddress([
                this.shard,
                this.realm,
                this.num,
            ]);
        }
    }

    //TODO remove the comments after we get to HIP-631
    /**
     * @internal
     * @returns {HieroProto.proto.IAccountID}
     */
    _toProtobuf() {
        let alias = null;
        //let evmAddress = null;

        if (this.aliasKey != null) {
            alias = HieroProto.proto.Key.encode(
                this.aliasKey._toProtobufKey(),
            ).finish();
        } else if (this.evmAddress != null) {
            alias = this.evmAddress._bytes;
        }

        /* if (this.evmAddress != null) {
            evmAddress = this.evmAddress._bytes;
        } */

        return {
            alias,
            accountNum: this.aliasKey != null ? null : this.num,
            shardNum: this.shard,
            realmNum: this.realm,
            //evmAddress,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.AccountID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {string}
     */
    toString() {
        let account = this.num.toString();

        if (this.aliasKey != null) {
            account = this.aliasKey.toString();
        } else if (this.evmAddress != null) {
            account = this.evmAddress.toString();
        }

        return `${this.shard.toString()}.${this.realm.toString()}.${account}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        if (this.aliasKey != null) {
            throw new Error(
                "cannot calculate checksum with an account ID that has a aliasKey",
            );
        }

        return entity_id.toStringWithChecksum(this.toString(), client);
    }

    /**
     * @param {this} other
     * @returns {boolean}
     */
    equals(other) {
        let account = false;

        if (this.aliasKey != null && other.aliasKey != null) {
            account = this.aliasKey.equals(other.aliasKey);
        } else if (this.evmAddress != null && other.evmAddress != null) {
            account = this.evmAddress.equals(other.evmAddress);
        } else if (
            this.aliasKey == null &&
            other.aliasKey == null &&
            this.evmAddress == null &&
            other.evmAddress == null
        ) {
            account = this.num.eq(other.num);
        }

        return (
            this.shard.eq(other.shard) && this.realm.eq(other.realm) && account
        );
    }

    /**
     * @returns {AccountId}
     */
    clone() {
        const id = new AccountId(this);
        id._checksum = this._checksum;
        id.aliasKey = this.aliasKey;
        id.evmAddress = this.evmAddress;
        return id;
    }

    /**
     * @param {AccountId} other
     * @returns {number}
     */
    compare(other) {
        let comparison = this.shard.compare(other.shard);
        if (comparison != 0) {
            return comparison;
        }

        comparison = this.realm.compare(other.realm);
        if (comparison != 0) {
            return comparison;
        }

        if (this.aliasKey != null && other.aliasKey != null) {
            const t = this.aliasKey.toString();
            const o = other.aliasKey.toString();

            if (t > o) {
                return 1;
            } else if (t < o) {
                return -1;
            } else {
                return 0;
            }
        } else if (this.evmAddress != null && other.evmAddress != null) {
            const t = this.evmAddress.toString();
            const o = other.evmAddress.toString();

            if (t > o) {
                return 1;
            } else if (t < o) {
                return -1;
            } else {
                return 0;
            }
        } else if (
            this.aliasKey == null &&
            other.aliasKey == null &&
            this.evmAddress == null &&
            other.evmAddress == null
        ) {
            return this.num.compare(other.num);
        } else {
            return 1;
        }
    }
}

CACHE.setAccountIdConstructor(
    (shard, realm, key) => new AccountId(shard, realm, Long.ZERO, key),
);
// Filename: src/account/AccountInfo.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./AccountId.js";
import StakingInfo from "../StakingInfo.js";
import LiveHash from "./LiveHash.js";
import Hbar from "../Hbar.js";
import Timestamp from "../Timestamp.js";
import Long from "long";
import TokenRelationshipMap from "./TokenRelationshipMap.js";
import * as HieroProto from "@hashgraph/proto";
import Duration from "../Duration.js";
import Key from "../Key.js";
import PublicKey from "../PublicKey.js";
import LedgerId from "../LedgerId.js";

/**
 * @typedef {import("./HbarAllowance.js").default} HbarAllowance
 * @typedef {import("./TokenAllowance.js").default} TokenAllowance
 * @typedef {import("./TokenNftAllowance.js").default} TokenNftAllowance
 * @typedef {import("../StakingInfo.js").StakingInfoJson} StakingInfoJson
 */

/**
 * @typedef {object} AccountInfoJson
 * @property {string} accountId
 * @property {?string} contractAccountId
 * @property {boolean} isDeleted
 * @property {?string} proxyAccountId
 * @property {string} proxyReceived
 * @property {?string} key
 * @property {string} balance
 * @property {string} sendRecordThreshold
 * @property {string} receiveRecordThreshold
 * @property {boolean} isReceiverSignatureRequired
 * @property {string} expirationTime
 * @property {string} autoRenewPeriod
 * @property {string} accountMemo
 * @property {string} ownedNfts
 * @property {string} maxAutomaticTokenAssociations
 * @property {?string} aliasKey
 * @property {?string} ledgerId
 * @property {?string} ethereumNonce
 * @property {?StakingInfoJson} stakingInfo
 */

/**
 * Current information about an account, including the balance.
 */
export default class AccountInfo {
    /**
     * @private
     * @param {object} props
     * @param {AccountId} props.accountId
     * @param {?string} props.contractAccountId
     * @param {boolean} props.isDeleted
     * @param {?AccountId} props.proxyAccountId
     * @param {Hbar} props.proxyReceived
     * @param {Key} props.key
     * @param {Hbar} props.balance
     * @param {Hbar} props.sendRecordThreshold
     * @param {Hbar} props.receiveRecordThreshold
     * @param {boolean} props.isReceiverSignatureRequired
     * @param {Timestamp} props.expirationTime
     * @param {Duration} props.autoRenewPeriod
     * @param {LiveHash[]} props.liveHashes
     * @param {TokenRelationshipMap} props.tokenRelationships
     * @param {string} props.accountMemo
     * @param {Long} props.ownedNfts
     * @param {Long} props.maxAutomaticTokenAssociations
     * @param {PublicKey | null} props.aliasKey
     * @param {LedgerId | null} props.ledgerId
     * @param {HbarAllowance[]} props.hbarAllowances
     * @param {TokenAllowance[]} props.tokenAllowances
     * @param {TokenNftAllowance[]} props.nftAllowances
     * @param {?Long} props.ethereumNonce
     * @param {?StakingInfo} props.stakingInfo
     */
    constructor(props) {
        /**
         * The account ID for which this information applies.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * The Contract Account ID comprising of both the contract instance and the cryptocurrency
         * account owned by the contract instance, in the format used by Solidity.
         *
         * @readonly
         */
        this.contractAccountId = props.contractAccountId;

        /**
         * If true, then this account has been deleted, it will disappear when it expires, and
         * all transactions for it will fail except the transaction to extend its expiration date.
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * @deprecated
         *
         * The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
         * or is an invalid account, or is an account that isn't a node, then this account is
         * automatically proxy staked to a node chosen by the network, but without earning payments.
         * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
         * running a node, then it will behave as if proxyAccountID was null.
         * @readonly
         */
        // eslint-disable-next-line deprecation/deprecation
        this.proxyAccountId = props.proxyAccountId;

        /**
         * @deprecated
         * The total number of tinybars proxy staked to this account.
         *
         * @readonly
         */
        // eslint-disable-next-line deprecation/deprecation
        this.proxyReceived = props.proxyReceived;

        /**
         * The key for the account, which must sign in order to transfer out, or to modify the account
         * in any way other than extending its expiration date.
         *
         * @readonly
         */
        this.key = props.key;

        /**
         * The current balance of account.
         *
         * @readonly
         */
        this.balance = props.balance;

        /**
         * The threshold amount (in tinybars) for which an account record is created (and this account
         * charged for them) for any send/withdraw transaction.
         *
         * @readonly
         */
        this.sendRecordThreshold = props.sendRecordThreshold;

        /**
         * The threshold amount (in tinybars) for which an account record is created
         * (and this account charged for them) for any transaction above this amount.
         *
         * @readonly
         */
        this.receiveRecordThreshold = props.receiveRecordThreshold;

        /**
         * If true, no transaction can transfer to this account unless signed by this account's key.
         *
         * @readonly
         */
        this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;

        /**
         * The TimeStamp time at which this account is set to expire.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * The duration for expiration time will extend every this many seconds. If there are
         * insufficient funds, then it extends as long as possible. If it is empty when it
         * expires, then it is deleted.
         *
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /** @readonly */
        this.liveHashes = props.liveHashes;

        /** @readonly */
        this.tokenRelationships = props.tokenRelationships;

        /** @readonly */
        this.accountMemo = props.accountMemo;

        /** @readonly */
        this.ownedNfts = props.ownedNfts;

        /** @readonly */
        this.maxAutomaticTokenAssociations =
            props.maxAutomaticTokenAssociations;

        this.aliasKey = props.aliasKey;

        this.ledgerId = props.ledgerId;
        /*
         * @deprecated - no longer supported
         */
        this.hbarAllowances = props.hbarAllowances;
        /*
         * @deprecated - no longer supported
         */
        this.tokenAllowances = props.tokenAllowances;
        /*
         * @deprecated - no longer supported
         */
        this.nftAllowances = props.nftAllowances;

        /**
         * The ethereum transaction nonce associated with this account.
         */
        this.ethereumNonce = props.ethereumNonce;

        /**
         * Staking metadata for this account.
         */
        this.stakingInfo = props.stakingInfo;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.CryptoGetInfoResponse.IAccountInfo} info
     * @returns {AccountInfo}
     */
    static _fromProtobuf(info) {
        let aliasKey =
            info.alias != null && info.alias.length > 0
                ? Key._fromProtobufKey(HieroProto.proto.Key.decode(info.alias))
                : null;

        if (!(aliasKey instanceof PublicKey)) {
            aliasKey = null;
        }

        const accountId = AccountId._fromProtobuf(
            /** @type {HieroProto.proto.IAccountID} */ (info.accountID),
        );

        return new AccountInfo({
            accountId,
            contractAccountId:
                info.contractAccountID != null ? info.contractAccountID : null,
            isDeleted: info.deleted != null ? info.deleted : false,
            key: Key._fromProtobufKey(
                /** @type {HieroProto.proto.IKey} */ (info.key),
            ),
            balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
            sendRecordThreshold: Hbar.fromTinybars(
                info.generateSendRecordThreshold != null
                    ? info.generateSendRecordThreshold
                    : 0,
            ),
            receiveRecordThreshold: Hbar.fromTinybars(
                info.generateReceiveRecordThreshold != null
                    ? info.generateReceiveRecordThreshold
                    : 0,
            ),
            isReceiverSignatureRequired:
                info.receiverSigRequired != null
                    ? info.receiverSigRequired
                    : false,
            expirationTime: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */ (
                    info.expirationTime
                ),
            ),
            autoRenewPeriod:
                info.autoRenewPeriod != null
                    ? new Duration(
                          /** @type {Long} */ (info.autoRenewPeriod.seconds),
                      )
                    : new Duration(0),
            proxyAccountId:
                info.proxyAccountID != null &&
                Long.fromValue(
                    /** @type {Long | number} */ (info.proxyAccountID.shardNum),
                ).toInt() !== 0 &&
                Long.fromValue(
                    /** @type {Long | number} */ (info.proxyAccountID.realmNum),
                ).toInt() !== 0 &&
                Long.fromValue(
                    /** @type {Long | number} */ (
                        info.proxyAccountID.accountNum
                    ),
                ).toInt() !== 0
                    ? AccountId._fromProtobuf(info.proxyAccountID)
                    : null,
            proxyReceived: Hbar.fromTinybars(
                info.proxyReceived != null ? info.proxyReceived : 0,
            ),
            liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(
                (hash) => LiveHash._fromProtobuf(hash),
            ),
            tokenRelationships: TokenRelationshipMap._fromProtobuf(
                info.tokenRelationships != null ? info.tokenRelationships : [],
            ),
            accountMemo: info.memo != null ? info.memo : "",
            ownedNfts: info.ownedNfts ? info.ownedNfts : Long.ZERO,
            maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations
                ? Long.fromNumber(info.maxAutomaticTokenAssociations)
                : Long.ZERO,
            aliasKey,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
            hbarAllowances: [],
            tokenAllowances: [],
            nftAllowances: [],
            ethereumNonce:
                info.ethereumNonce != null ? info.ethereumNonce : null,
            stakingInfo:
                info.stakingInfo != null
                    ? StakingInfo._fromProtobuf(info.stakingInfo)
                    : null,
        });
    }

    /**
     * @returns {HieroProto.proto.CryptoGetInfoResponse.IAccountInfo}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            contractAccountID: this.contractAccountId,
            deleted: this.isDeleted,
            proxyAccountID:
                // eslint-disable-next-line deprecation/deprecation
                this.proxyAccountId != null
                    ? // eslint-disable-next-line deprecation/deprecation
                      this.proxyAccountId._toProtobuf()
                    : null,
            // eslint-disable-next-line deprecation/deprecation
            proxyReceived: this.proxyReceived.toTinybars(),
            key: this.key._toProtobufKey(),
            balance: this.balance.toTinybars(),
            generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),
            generateReceiveRecordThreshold:
                this.receiveRecordThreshold.toTinybars(),
            receiverSigRequired: this.isReceiverSignatureRequired,
            expirationTime: this.expirationTime._toProtobuf(),
            autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),
            liveHashes: this.liveHashes.map((hash) => hash._toProtobuf()),
            tokenRelationships:
                this.tokenRelationships != null
                    ? this.tokenRelationships._toProtobuf()
                    : null,
            memo: this.accountMemo,
            ownedNfts: this.ownedNfts,
            maxAutomaticTokenAssociations:
                this.maxAutomaticTokenAssociations.toInt(),
            alias:
                this.aliasKey != null
                    ? HieroProto.proto.Key.encode(
                          this.aliasKey._toProtobufKey(),
                      ).finish()
                    : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
            ethereumNonce: this.ethereumNonce,
            stakingInfo:
                this.stakingInfo != null
                    ? this.stakingInfo._toProtobuf()
                    : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {AccountInfo}
     */
    static fromBytes(bytes) {
        return AccountInfo._fromProtobuf(
            HieroProto.proto.CryptoGetInfoResponse.AccountInfo.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.CryptoGetInfoResponse.AccountInfo.encode(
            this._toProtobuf(),
        ).finish();
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {AccountInfoJson}
     */
    toJSON() {
        return {
            balance: this.balance.toString(),
            accountId: this.accountId.toString(),
            contractAccountId: this.contractAccountId,
            isDeleted: this.isDeleted,
            proxyAccountId:
                // eslint-disable-next-line deprecation/deprecation
                this.proxyAccountId != null
                    ? // eslint-disable-next-line deprecation/deprecation
                      this.proxyAccountId.toString()
                    : null,
            // eslint-disable-next-line deprecation/deprecation
            proxyReceived: this.proxyReceived.toString(),
            key: this.key != null ? this.key.toString() : null,
            sendRecordThreshold: this.sendRecordThreshold.toString(),
            receiveRecordThreshold: this.receiveRecordThreshold.toString(),
            isReceiverSignatureRequired: this.isReceiverSignatureRequired,
            expirationTime: this.expirationTime.toString(),
            autoRenewPeriod: this.autoRenewPeriod.toString(),
            accountMemo: this.accountMemo,
            ownedNfts: this.ownedNfts.toString(),
            maxAutomaticTokenAssociations:
                this.maxAutomaticTokenAssociations.toString(),
            aliasKey: this.aliasKey != null ? this.aliasKey.toString() : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
            ethereumNonce:
                this.ethereumNonce != null
                    ? this.ethereumNonce.toString()
                    : null,
            stakingInfo:
                this.stakingInfo != null ? this.stakingInfo.toJSON() : null,
        };
    }
}
// Filename: src/account/AccountInfoFlow.js
// SPDX-License-Identifier: Apache-2.0

import AccountInfoQuery from "./AccountInfoQuery.js";
import KeyList from "../KeyList.js";

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/Transaction.js").default} Transaction
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("./AccountId.js").default} AccountId
 * @typedef {import("../Signer.js").Signer} Signer
 */

/**
 * This class provides static methods to verify signatures and transactions by fetching the account's key
 * from the network. It supports both Client and Signer-based operations.
 *
 * The class provides methods to:
 * - Verify message signatures using account public key
 * - Verify transaction signatures using account public key
 * - Perform verifications using either a Client or Signer instance
 */
export default class AccountInfoFlow {
    /**
     * @param {Client} client
     * @param {AccountId | string} accountId
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {Promise<boolean>}
     */
    static async verifySignature(client, accountId, message, signature) {
        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(client);

        if (info.key instanceof KeyList) {
            return false;
        }

        return /** @type {PublicKey} */ (info.key).verify(message, signature);
    }

    /**
     * @param {Client} client
     * @param {AccountId | string} accountId
     * @param {Transaction} transaction
     * @returns {Promise<boolean>}
     */
    static async verifyTransaction(client, accountId, transaction) {
        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(client);

        if (info.key instanceof KeyList) {
            return false;
        }

        return /** @type {PublicKey} */ (info.key).verifyTransaction(
            transaction,
        );
    }

    /**
     * @param {Signer} signer
     * @param {AccountId | string} accountId
     * @param {Uint8Array} message
     * @param {Uint8Array} signature
     * @returns {Promise<boolean>}
     */
    static async verifySignatureWithSigner(
        signer,
        accountId,
        message,
        signature,
    ) {
        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .executeWithSigner(signer);

        if (info.key instanceof KeyList) {
            return false;
        }

        return /** @type {PublicKey} */ (info.key).verify(message, signature);
    }

    /**
     * @param {Signer} signer
     * @param {AccountId | string} accountId
     * @param {Transaction} transaction
     * @returns {Promise<boolean>}
     */
    static async verifyTransactionWithSigner(signer, accountId, transaction) {
        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .executeWithSigner(signer);

        if (info.key instanceof KeyList) {
            return false;
        }

        return /** @type {PublicKey} */ (info.key).verifyTransaction(
            transaction,
        );
    }
}
// Filename: src/account/AccountInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import AccountId from "./AccountId.js";
import AccountInfo from "./AccountInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.CryptoGetInfoResponse.IAccountInfo} HieroProto.proto.CryptoGetInfoResponse.IAccountInfo
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetInfoQuery} HieroProto.proto.ICryptoGetInfoQuery
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetInfoResponse} HieroProto.proto.ICryptoGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Retrieves the metadata of an account
 * @augments {Query<AccountInfo>}
 */
export default class AccountInfoQuery extends Query {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;
        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {AccountInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {HieroProto.proto.ICryptoGetInfoQuery} */ (
            query.cryptoGetInfo
        );

        return new AccountInfoQuery({
            accountId:
                info.accountID != null
                    ? AccountId._fromProtobuf(info.accountID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the info is being requested.
     *
     * @param {AccountId | string} accountId
     * @returns {AccountInfoQuery}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getAccountInfo(request);
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetInfo =
            /** @type {HieroProto.proto.ICryptoGetInfoResponse} */ (
                response.cryptoGetInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            cryptoGetInfo.header
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<AccountInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {HieroProto.proto.ICryptoGetInfoResponse} */ (
            response.cryptoGetInfo
        );

        return Promise.resolve(
            AccountInfo._fromProtobuf(
                /** @type {HieroProto.proto.CryptoGetInfoResponse.IAccountInfo} */ (
                    info.accountInfo
                ),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetInfo: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;
        return `AccountInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("cryptoGetInfo", AccountInfoQuery._fromProtobuf);
// Filename: src/account/AccountRecordsQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import AccountId from "./AccountId.js";
import TransactionRecord from "../transaction/TransactionRecord.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountRecordsQuery} HieroProto.proto.ICryptoGetAccountRecordsQuery
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetAccountRecordsResponse} HieroProto.proto.ICryptoGetAccountRecordsResponse
 * @typedef {import("@hashgraph/proto").proto.ITransactionRecord} HieroProto.proto.ITransactionRecord
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get all the records for an account for any transfers into it and out of it,
 * that were above the threshold, during the last 25 hours.
 *
 * @augments {Query<TransactionRecord[]>}
 */
export default class AccountRecordsQuery extends Query {
    /**
     * @param {object} [props]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {AccountRecordsQuery}
     */
    static _fromProtobuf(query) {
        const records =
            /** @type {HieroProto.proto.ICryptoGetAccountRecordsQuery} */ (
                query.cryptoGetAccountRecords
            );

        return new AccountRecordsQuery({
            accountId:
                records.accountID != null
                    ? AccountId._fromProtobuf(records.accountID)
                    : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account ID for which the records are being requested.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getAccountRecords(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetAccountRecords =
            /** @type {HieroProto.proto.ICryptoGetAccountRecordsResponse} */ (
                response.cryptoGetAccountRecords
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            cryptoGetAccountRecords.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<TransactionRecord[]>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const cryptoGetAccountRecords =
            /** @type {HieroProto.proto.ICryptoGetAccountRecordsResponse} */ (
                response.cryptoGetAccountRecords
            );
        const records = /** @type {HieroProto.proto.ITransactionRecord[]} */ (
            cryptoGetAccountRecords.records
        );

        return Promise.resolve(
            records.map((record) =>
                TransactionRecord._fromProtobuf({ transactionRecord: record }),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetAccountRecords: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `AccountRecordsQuery:${timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "cryptoGetAccountRecords",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountRecordsQuery._fromProtobuf,
);
// Filename: src/account/AccountUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "./AccountId.js";
import Timestamp from "../Timestamp.js";
import Duration from "../Duration.js";
import Long from "long";
import Key from "../Key.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoUpdateTransactionBody} HieroProto.proto.ICryptoUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Change properties for the given account.
 */
export default class AccountUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {AccountId} [props.accountId]
     * @param {Key} [props.key]
     * @param {?boolean} [props.receiverSignatureRequired]
     * @param {AccountId} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {?string} [props.accountMemo]
     * @param {Long | number} [props.maxAutomaticTokenAssociations]
     * @param {Key} [props.aliasKey]
     * @param {AccountId | string} [props.stakedAccountId]
     * @param {Long | number} [props.stakedNodeId]
     * @param {?boolean} [props.declineStakingReward]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._key = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._receiverSignatureRequired = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?string}
         */
        this._accountMemo = null;

        /**
         * @private
         * @type {?Long}
         */
        this._maxAutomaticTokenAssociations = null;

        /**
         * @private
         * @type {?Key}
         */
        this._aliasKey = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._stakedAccountId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._stakedNodeId = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._declineStakingReward = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.key != null) {
            this.setKey(props.key);
        }

        if (props.receiverSignatureRequired != null) {
            this.setReceiverSignatureRequired(props.receiverSignatureRequired);
        }

        if (props.proxyAccountId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.accountMemo != null) {
            this.setAccountMemo(props.accountMemo);
        }

        if (props.maxAutomaticTokenAssociations != null) {
            this.setMaxAutomaticTokenAssociations(
                props.maxAutomaticTokenAssociations,
            );
        }

        if (props.stakedAccountId != null) {
            this.setStakedAccountId(props.stakedAccountId);
        }

        if (props.stakedNodeId != null) {
            this.setStakedNodeId(props.stakedNodeId);
        }

        if (props.declineStakingReward != null) {
            this.setDeclineStakingReward(props.declineStakingReward);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {AccountUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const update =
            /** @type {HieroProto.proto.ICryptoUpdateTransactionBody} */ (
                body.cryptoUpdateAccount
            );

        return Transaction._fromProtobufTransactions(
            new AccountUpdateTransaction({
                accountId:
                    update.accountIDToUpdate != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  update.accountIDToUpdate
                              ),
                          )
                        : undefined,
                key:
                    update.key != null
                        ? Key._fromProtobufKey(update.key)
                        : undefined,
                receiverSignatureRequired:
                    update.receiverSigRequiredWrapper != null
                        ? Object.hasOwn(
                              update.receiverSigRequiredWrapper,
                              "value",
                          )
                            ? update.receiverSigRequiredWrapper.value
                            : undefined
                        : undefined,
                proxyAccountId:
                    update.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  update.proxyAccountID
                              ),
                          )
                        : undefined,
                autoRenewPeriod:
                    update.autoRenewPeriod != null
                        ? update.autoRenewPeriod.seconds != null
                            ? update.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
                accountMemo:
                    update.memo != null
                        ? Object.hasOwn(update.memo, "value")
                            ? update.memo.value
                            : undefined
                        : undefined,
                maxAutomaticTokenAssociations:
                    update.maxAutomaticTokenAssociations != null &&
                    update.maxAutomaticTokenAssociations.value != null &&
                    Object.hasOwn(update.maxAutomaticTokenAssociations, "value")
                        ? Long.fromNumber(
                              update.maxAutomaticTokenAssociations.value,
                          )
                        : undefined,
                stakedAccountId:
                    update.stakedAccountId != null
                        ? AccountId._fromProtobuf(update.stakedAccountId)
                        : undefined,
                stakedNodeId:
                    update.stakedNodeId != null
                        ? update.stakedNodeId
                        : undefined,
                declineStakingReward:
                    update.declineReward != null
                        ? Object.hasOwn(update.declineReward, "value")
                            ? update.declineReward.value
                            : undefined
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Sets the account ID which is being updated in this transaction.
     *
     * @param {AccountId | string} accountId
     * @returns {AccountUpdateTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get key() {
        return this._key;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setKey(key) {
        this._requireNotFrozen();
        this._key = key;

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get receiverSignatureRequired() {
        return this._receiverSignatureRequired;
    }

    /**
     * @param {boolean} receiverSignatureRequired
     * @returns {this}
     */
    setReceiverSignatureRequired(receiverSignatureRequired) {
        this._requireNotFrozen();
        this._receiverSignatureRequired = receiverSignatureRequired;

        return this;
    }

    /**
     * @deprecated
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @deprecated
     * @param {AccountId} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId = proxyAccountId;

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp | Date} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Date
                ? Timestamp.fromDate(expirationTime)
                : expirationTime;

        return this;
    }

    /**
     * @returns {?string}
     */
    get accountMemo() {
        return this._accountMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setAccountMemo(memo) {
        this._requireNotFrozen();
        this._accountMemo = memo;

        return this;
    }

    /**
     * @returns {this}
     */
    clearAccountMemo() {
        this._requireNotFrozen();
        this._accountMemo = null;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get maxAutomaticTokenAssociations() {
        return this._maxAutomaticTokenAssociations;
    }

    /**
     * @param {Long | number} maxAutomaticTokenAssociations
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
        this._requireNotFrozen();
        this._maxAutomaticTokenAssociations =
            typeof maxAutomaticTokenAssociations === "number"
                ? Long.fromNumber(maxAutomaticTokenAssociations)
                : maxAutomaticTokenAssociations;

        return this;
    }

    /**
     * @deprecated - no longer supported
     * @returns {?Key}
     */
    get aliasKey() {
        return null;
    }

    /**
     * @deprecated - no longer supported
     * @param {Key} _
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setAliasKey(_) {
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get stakedAccountId() {
        return this._stakedAccountId;
    }

    /**
     * @param {AccountId | string} stakedAccountId
     * @returns {this}
     */
    setStakedAccountId(stakedAccountId) {
        this._requireNotFrozen();
        this._stakedAccountId =
            typeof stakedAccountId === "string"
                ? AccountId.fromString(stakedAccountId)
                : stakedAccountId;

        return this;
    }

    /**
     * @returns {this}
     */
    clearStakedAccountId() {
        this._requireNotFrozen();
        this._stakedAccountId = new AccountId(0, 0, 0);

        return this;
    }

    /**
     * @returns {?Long}
     */
    get stakedNodeId() {
        return this._stakedNodeId;
    }

    /**
     * @param {Long | number} stakedNodeId
     * @returns {this}
     */
    setStakedNodeId(stakedNodeId) {
        this._requireNotFrozen();
        this._stakedNodeId = Long.fromValue(stakedNodeId);

        return this;
    }

    /**
     * @returns {this}
     */
    clearStakedNodeId() {
        this._requireNotFrozen();
        this._stakedNodeId = Long.fromNumber(-1);

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get declineStakingRewards() {
        return this._declineStakingReward;
    }

    /**
     * @param {boolean} declineStakingReward
     * @returns {this}
     */
    setDeclineStakingReward(declineStakingReward) {
        this._requireNotFrozen();
        this._declineStakingReward = declineStakingReward;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.updateAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoUpdateAccount";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            accountIDToUpdate:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            key: this._key != null ? this._key._toProtobufKey() : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            receiverSigRequiredWrapper:
                this._receiverSignatureRequired == null
                    ? null
                    : {
                          value: this._receiverSignatureRequired,
                      },
            memo:
                this._accountMemo != null
                    ? {
                          value: this._accountMemo,
                      }
                    : null,
            maxAutomaticTokenAssociations:
                this._maxAutomaticTokenAssociations != null
                    ? { value: this._maxAutomaticTokenAssociations.toInt() }
                    : null,
            stakedAccountId:
                this.stakedAccountId != null
                    ? this.stakedAccountId._toProtobuf()
                    : null,
            stakedNodeId: this.stakedNodeId,
            declineReward:
                this.declineStakingRewards != null
                    ? { value: this.declineStakingRewards }
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `AccountUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoUpdateAccount",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    AccountUpdateTransaction._fromProtobuf,
);
// Filename: src/account/HbarAllowance.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./AccountId.js";
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IGrantedCryptoAllowance} HieroProto.proto.IGrantedCryptoAllowance
 * @typedef {import("@hashgraph/proto").proto.ICryptoAllowance} HieroProto.proto.ICryptoAllowance
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Represents an HBAR allowance granted to a spender account by an owner account.
 * This class manages the permissions for one account to spend HBAR on behalf of another account.
 */
export default class HbarAllowance {
    /**
     * @internal
     * @param {object} props
     * @param {AccountId | null} props.spenderAccountId
     * @param {AccountId | null} props.ownerAccountId
     * @param {Hbar | null} props.amount
     */
    constructor(props) {
        /**
         * The account ID of the hbar allowance spender.
         *
         * @readonly
         */
        this.spenderAccountId = props.spenderAccountId;

        /**
         * The account ID of the hbar allowance owner.
         *
         * @readonly
         */
        this.ownerAccountId = props.ownerAccountId;

        /**
         * The current balance of the spender's allowance in tinybars.
         *
         * @readonly
         */
        this.amount = props.amount;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ICryptoAllowance} allowance
     * @returns {HbarAllowance}
     */
    static _fromProtobuf(allowance) {
        return new HbarAllowance({
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
            ),
            ownerAccountId:
                allowance.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {HieroProto.proto.IAccountID}*/ (
                              allowance.owner
                          ),
                      )
                    : null,
            amount: Hbar.fromTinybars(
                allowance.amount != null ? allowance.amount : 0,
            ),
        });
    }

    /**
     * @internal
     * @param {HieroProto.proto.IGrantedCryptoAllowance} allowance
     * @param {AccountId} ownerAccountId
     * @returns {HbarAllowance}
     */
    static _fromGrantedProtobuf(allowance, ownerAccountId) {
        return new HbarAllowance({
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
            ),
            ownerAccountId,
            amount: Hbar.fromTinybars(
                allowance.amount != null ? allowance.amount : 0,
            ),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ICryptoAllowance}
     */
    _toProtobuf() {
        return {
            owner:
                this.ownerAccountId != null
                    ? this.ownerAccountId._toProtobuf()
                    : null,
            spender:
                this.spenderAccountId != null
                    ? this.spenderAccountId._toProtobuf()
                    : null,
            amount: this.amount != null ? this.amount.toTinybars() : null,
        };
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this.spenderAccountId != null) {
            this.spenderAccountId.validateChecksum(client);
        }

        if (this.spenderAccountId != null) {
            this.spenderAccountId.validateChecksum(client);
        }
    }

    /**
     * @returns {object}
     */
    toJSON() {
        return {
            ownerAccountId:
                this.ownerAccountId != null
                    ? this.ownerAccountId.toString()
                    : null,
            spenderAccountId:
                this.spenderAccountId != null
                    ? this.spenderAccountId.toString()
                    : null,
            amount: this.amount != null ? this.amount.toString() : null,
        };
    }
}
// Filename: src/account/HbarTransferMap.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./AccountId.js";
import Hbar from "../Hbar.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransferList} HieroProto.proto.ITransferList
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("../long.js").LongObject} LongObject
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @augments {ObjectMap<AccountId, Hbar>}
 */
export default class HbarTransferMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    /**
     * @param {HieroProto.proto.ITransferList} transfers
     * @returns {HbarTransferMap}
     */
    static _fromProtobuf(transfers) {
        const accountTransfers = new HbarTransferMap();

        for (const transfer of transfers.accountAmounts != null
            ? transfers.accountAmounts
            : []) {
            const account = AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (transfer.accountID),
            );

            accountTransfers._set(
                account,
                Hbar.fromTinybars(/** @type {Long} */ (transfer.amount)),
            );
        }

        return accountTransfers;
    }
}
// Filename: src/account/LiveHash.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./AccountId.js";
import Duration from "../Duration.js";
import KeyList from "../KeyList.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.ILiveHash} HieroProto.proto.ILiveHash
 * @typedef {import("@hashgraph/proto").proto.IDuration} HieroProto.proto.IDuration
 */

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
export default class LiveHash {
    /**
     * @private
     * @param {object} props
     * @param {AccountId} props.accountId
     * @param {Uint8Array} props.hash
     * @param {KeyList} props.keys
     * @param {Duration} props.duration
     */
    constructor(props) {
        /** @readonly */
        this.accountId = props.accountId;

        /** @readonly */
        this.hash = props.hash;

        /** @readonly */
        this.keys = props.keys;

        /** @readonly */
        this.duration = props.duration;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ILiveHash} liveHash
     * @returns {LiveHash}
     */
    static _fromProtobuf(liveHash) {
        const liveHash_ = /** @type {HieroProto.proto.ILiveHash} */ (liveHash);

        return new LiveHash({
            accountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (
                    liveHash_.accountId
                ),
            ),
            hash: liveHash_.hash != null ? liveHash_.hash : new Uint8Array(),
            keys:
                liveHash_.keys != null
                    ? KeyList.__fromProtobufKeyList(liveHash_.keys)
                    : new KeyList(),
            duration: Duration._fromProtobuf(
                /** @type {HieroProto.proto.IDuration} */ (liveHash_.duration),
            ),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ILiveHash}
     */
    _toProtobuf() {
        return {
            accountId: this.accountId._toProtobuf(),
            hash: this.hash,
            keys: this.keys._toProtobufKey().keyList,
            duration: this.duration._toProtobuf(),
        };
    }
}
// Filename: src/account/LiveHashAddTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "./AccountId.js";
import Duration from "../Duration.js";
import Key from "../Key.js";
import KeyList from "../KeyList.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoAddLiveHashTransactionBody} HieroProto.proto.ICryptoAddLiveHashTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ILiveHash} HieroProto.proto.ILiveHash
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @deprecated
 * This transaction is no longer supported.
 */
export default class LiveHashAddTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Uint8Array} [props.hash]
     * @param {Key[]} [props.keys]
     * @param {Duration | Long | number} [props.duration]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._hash = null;

        /**
         * @private
         * @type {?Key[]}
         */
        this._keys = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._duration = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.hash != null) {
            this.setHash(props.hash);
        }

        if (props.keys != null) {
            this.setKeys(props.keys);
        }

        if (props.duration != null) {
            this.setDuration(props.duration);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {LiveHashAddTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const hashes =
            /** @type {HieroProto.proto.ICryptoAddLiveHashTransactionBody} */ (
                body.cryptoAddLiveHash
            );
        const liveHash_ = /** @type {HieroProto.proto.ILiveHash} */ (
            hashes.liveHash
        );

        return Transaction._fromProtobufTransactions(
            // eslint-disable-next-line deprecation/deprecation
            new LiveHashAddTransaction({
                hash: liveHash_.hash != null ? liveHash_.hash : undefined,
                keys:
                    liveHash_.keys != null
                        ? liveHash_.keys.keys != null
                            ? liveHash_.keys.keys.map((key) =>
                                  Key._fromProtobufKey(key),
                              )
                            : undefined
                        : undefined,
                duration:
                    liveHash_.duration != null
                        ? liveHash_.duration.seconds != null
                            ? liveHash_.duration.seconds
                            : undefined
                        : undefined,
                accountId:
                    liveHash_.accountId != null
                        ? AccountId._fromProtobuf(liveHash_.accountId)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?Uint8Array}
     */
    get hash() {
        return this._hash;
    }

    /**
     * @param {Uint8Array} hash
     * @returns {LiveHashAddTransaction}
     */
    setHash(hash) {
        this._requireNotFrozen();
        this._hash = hash;

        return this;
    }

    /**
     * @returns {?Key[]}
     */
    get keys() {
        return this._keys;
    }

    /**
     * @param {Key[] | KeyList} keys
     * @returns {LiveHashAddTransaction}
     */
    setKeys(keys) {
        this._requireNotFrozen();
        this._keys = keys instanceof KeyList ? keys.toArray() : keys;

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get duration() {
        return this._duration;
    }

    /**
     * @param {Duration | Long | number} duration
     * @returns {LiveHashAddTransaction}
     */
    setDuration(duration) {
        this._requireNotFrozen();
        this._duration =
            duration instanceof Duration ? duration : new Duration(duration);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {LiveHashAddTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.addLiveHash(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoAddLiveHash";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoAddLiveHashTransactionBody}
     */
    _makeTransactionData() {
        return {
            liveHash: {
                hash: this._hash,
                keys:
                    this._keys != null
                        ? {
                              keys: this._keys.map((key) =>
                                  key._toProtobufKey(),
                              ),
                          }
                        : undefined,
                duration:
                    this._duration != null
                        ? this._duration._toProtobuf()
                        : null,
                accountId:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `LiveHashAddTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoAddLiveHash",
    // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
    LiveHashAddTransaction._fromProtobuf,
);
// Filename: src/account/LiveHashDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "./AccountId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoDeleteLiveHashTransactionBody} HieroProto.proto.ICryptoDeleteLiveHashTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @deprecated
 * This transaction is no longer supported.
 */
export default class LiveHashDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Uint8Array} [props.hash]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._hash = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.hash != null) {
            this.setHash(props.hash);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {LiveHashDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const hashes =
            /** @type {HieroProto.proto.ICryptoDeleteLiveHashTransactionBody} */ (
                body.cryptoDeleteLiveHash
            );

        return Transaction._fromProtobufTransactions(
            // eslint-disable-next-line deprecation/deprecation
            new LiveHashDeleteTransaction({
                hash:
                    hashes.liveHashToDelete != null
                        ? hashes.liveHashToDelete
                        : undefined,
                accountId:
                    hashes.accountOfLiveHash != null
                        ? AccountId._fromProtobuf(hashes.accountOfLiveHash)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?Uint8Array}
     */
    get hash() {
        return this._hash;
    }

    /**
     * @param {Uint8Array} hash
     * @returns {LiveHashDeleteTransaction}
     */
    setHash(hash) {
        this._requireNotFrozen();
        this._hash = hash;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {LiveHashDeleteTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.deleteLiveHash(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoDeleteLiveHash";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoDeleteLiveHashTransactionBody}
     */
    _makeTransactionData() {
        return {
            liveHashToDelete: this._hash,
            accountOfLiveHash:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `LiveHashDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoDeleteLiveHash",
    // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
    LiveHashDeleteTransaction._fromProtobuf,
);
// Filename: src/account/LiveHashQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import AccountId from "./AccountId.js";
import LiveHash from "./LiveHash.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetLiveHashQuery} HieroProto.proto.ICryptoGetLiveHashQuery
 * @typedef {import("@hashgraph/proto").proto.ICryptoGetLiveHashResponse} HieroProto.proto.ICryptoGetLiveHashResponse
 * @typedef {import("@hashgraph/proto").proto.ILiveHash} HieroProto.proto.ILiveHash
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @augments {Query<LiveHash>}
 * @deprecated
 * Тhis query is no longer supported.
 */
export default class LiveHashQuery extends Query {
    /**
     * @param {object} [props]
     * @param {AccountId | string} [props.accountId]
     * @param {Uint8Array} [props.hash]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?AccountId}
         * @private
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {?Uint8Array}
         * @private
         */
        this._hash = null;

        if (props.hash != null) {
            this.setHash(props.hash);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {LiveHashQuery}
     */
    static _fromProtobuf(query) {
        const hash = /** @type {HieroProto.proto.ICryptoGetLiveHashQuery} */ (
            query.cryptoGetLiveHash
        );

        // eslint-disable-next-line deprecation/deprecation
        return new LiveHashQuery({
            accountId:
                hash.accountID != null
                    ? AccountId._fromProtobuf(hash.accountID)
                    : undefined,
            hash: hash.hash != null ? hash.hash : undefined,
        });
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * Set the account to which the livehash is associated.
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get liveHash() {
        return this._hash;
    }

    /**
     * Set the SHA-384 data in the livehash.
     *
     * @param {Uint8Array} hash
     * @returns {this}
     */
    setHash(hash) {
        this._hash = hash;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getLiveHash(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const cryptoGetLiveHash =
            /** @type {HieroProto.proto.ICryptoGetLiveHashResponse} */ (
                response.cryptoGetLiveHash
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            cryptoGetLiveHash.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @returns {Promise<LiveHash>}
     */
    _mapResponse(response) {
        const hashes =
            /** @type {HieroProto.proto.ICryptoGetLiveHashResponse} */ (
                response.cryptoGetLiveHash
            );

        return Promise.resolve(
            LiveHash._fromProtobuf(
                /** @type {HieroProto.proto.ILiveHash} */ (hashes.liveHash),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            cryptoGetLiveHash: {
                header,
                accountID:
                    this._accountId != null
                        ? this._accountId._toProtobuf()
                        : null,
                hash: this._hash,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `LiveHashQuery:${timestamp.toString()}`;
    }
}

// @ts-ignore
// eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
QUERY_REGISTRY.set("cryptoGetLiveHash", LiveHashQuery._fromProtobuf);
// Filename: src/account/NullableTokenDecimalMap.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenBalance} HieroProto.proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @augments {ObjectMap<TokenId, number | null>}
 */
export default class NullableTokenDecimalMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }
}
// Filename: src/account/ProxyStaker.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "./AccountId.js";
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IProxyStaker} HieroProto.proto.IProxyStaker
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency transfer.
 */
export default class ProxyStaker {
    /**
     * @private
     * @param {object} props
     * @param {AccountId} props.accountId
     * @param {number | string | Long | BigNumber | Hbar} props.amount
     */
    constructor(props) {
        /**
         * The Account ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * The amount of tinybars that the account sends(negative)
         * or receives(positive).
         *
         * @readonly
         */
        this.amount =
            props.amount instanceof Hbar
                ? props.amount
                : new Hbar(props.amount);

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IProxyStaker} transfer
     * @returns {ProxyStaker}
     */
    static _fromProtobuf(transfer) {
        return new ProxyStaker({
            accountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (transfer.accountID),
            ),
            amount: Hbar.fromTinybars(
                transfer.amount != null ? transfer.amount : 0,
            ),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IProxyStaker}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            amount: this.amount.toTinybars(),
        };
    }
}
// Filename: src/account/TokenAllowance.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import AccountId from "./AccountId.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IGrantedTokenAllowance} HieroProto.proto.IGrantedTokenAllowance
 * @typedef {import("@hashgraph/proto").proto.ITokenAllowance} HieroProto.proto.ITokenAllowance
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Represents a token allowance granted to a spender account by an owner account.
 *
 * The `TokenAllowance` class manages the permissions for one account to spend a specified
 * amount of tokens on behalf of another account. It includes details about the token, the
 * spender, the owner, and the amount allowed.
 */
export default class TokenAllowance {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId} props.tokenId
     * @param {AccountId | null} props.spenderAccountId
     * @param {AccountId | null} props.ownerAccountId
     * @param {Long | null} props.amount
     */
    constructor(props) {
        /**
         * The token that the allowance pertains to.
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The account ID of the spender of the hbar allowance.
         *
         * @readonly
         */
        this.spenderAccountId = props.spenderAccountId;

        /**
         * The account ID of the owner of the hbar allowance.
         *
         * @readonly
         */
        this.ownerAccountId = props.ownerAccountId;

        /**
         * The current balance of the spender's token allowance.
         * **NOTE**: If `null`, the spender has access to all of the account owner's NFT instances
         * (currently owned and any in the future).
         *
         * @readonly
         */
        this.amount = props.amount;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITokenAllowance} allowance
     * @returns {TokenAllowance}
     */
    static _fromProtobuf(allowance) {
        return new TokenAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
            ),
            ownerAccountId:
                allowance.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {HieroProto.proto.IAccountID}*/ (
                              allowance.owner
                          ),
                      )
                    : null,
            amount:
                allowance.amount != null
                    ? Long.fromValue(/** @type {Long} */ (allowance.amount))
                    : null,
        });
    }

    /**
     * @internal
     * @param {HieroProto.proto.IGrantedTokenAllowance} allowance
     * @param {AccountId} ownerAccountId
     * @returns {TokenAllowance}
     */
    static _fromGrantedProtobuf(allowance, ownerAccountId) {
        return new TokenAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
            ),
            ownerAccountId,
            amount:
                allowance.amount != null
                    ? Long.fromValue(/** @type {Long} */ (allowance.amount))
                    : null,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITokenAllowance}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            spender:
                this.spenderAccountId != null
                    ? this.spenderAccountId._toProtobuf()
                    : null,
            owner:
                this.ownerAccountId != null
                    ? this.ownerAccountId._toProtobuf()
                    : null,
            amount: this.amount,
        };
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this.tokenId.validateChecksum(client);

        if (this.ownerAccountId != null) {
            this.ownerAccountId.validateChecksum(client);
        }

        if (this.spenderAccountId != null) {
            this.spenderAccountId.validateChecksum(client);
        }
    }
}
// Filename: src/account/TokenBalanceMap.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenBalance} HieroProto.proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @augments {ObjectMap<TokenId, Long>}
 */
export default class TokenBalanceMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }
}
// Filename: src/account/TokenDecimalMap.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenBalance} HieroProto.proto.ITokenBalance
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @augments {ObjectMap<TokenId, number>}
 */
export default class TokenDecimalMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }
}
// Filename: src/account/TokenNftAllowance.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import AccountId from "./AccountId.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IGrantedNftAllowance} HieroProto.proto.IGrantedNftAllowance
 * @typedef {import("@hashgraph/proto").proto.INftRemoveAllowance} HieroProto.proto.INftRemoveAllowance
 * @typedef {import("@hashgraph/proto").proto.INftAllowance} HieroProto.proto.INftAllowance
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The token that the allowance pertains to.
 */
export default class TokenNftAllowance {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId} props.tokenId
     * @param {AccountId | null} props.spenderAccountId
     * @param {AccountId | null} props.ownerAccountId
     * @param {Long[] | null} props.serialNumbers
     * @param {boolean | null} props.allSerials
     * @param {AccountId | null} props.delegatingSpender
     */
    constructor(props) {
        /**
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The account ID of the spender of the hbar allowance.
         *
         * @readonly
         */
        this.spenderAccountId = props.spenderAccountId;

        /**
         * The account ID of the owner of the hbar allowance.
         *
         * @readonly
         */
        this.ownerAccountId = props.ownerAccountId;

        /**
         * The current balance of the spender's token allowance.
         * **NOTE**: If `null`, the spender has access to all of the account owner's NFT instances
         * (currently owned and any in the future).
         *
         * @readonly
         */
        this.serialNumbers = props.serialNumbers;

        /**
         * @readonly
         */
        this.allSerials = props.allSerials;

        /**
         * The account ID of the spender who is granted approvedForAll allowance and granting
         * approval on an NFT serial to another spender.
         *
         * @readonly
         */
        this.delegatingSpender = props.delegatingSpender;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.INftAllowance} allowance
     * @returns {TokenNftAllowance}
     */
    static _fromProtobuf(allowance) {
        const allSerials =
            allowance.approvedForAll != null &&
            allowance.approvedForAll.value == true;
        return new TokenNftAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
            ),
            spenderAccountId:
                allowance.spender != null
                    ? AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              allowance.spender
                          ),
                      )
                    : null,
            ownerAccountId:
                allowance.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {HieroProto.proto.IAccountID}*/ (
                              allowance.owner
                          ),
                      )
                    : null,
            serialNumbers: allSerials
                ? null
                : allowance.serialNumbers != null
                  ? allowance.serialNumbers.map((serialNumber) =>
                        Long.fromValue(serialNumber),
                    )
                  : [],
            allSerials,
            delegatingSpender:
                allowance.delegatingSpender != null
                    ? AccountId._fromProtobuf(
                          /**@type {HieroProto.proto.IAccountID}*/ (
                              allowance.delegatingSpender
                          ),
                      )
                    : null,
        });
    }

    /**
     * @internal
     * @param {HieroProto.proto.IGrantedNftAllowance} allowance
     * @param {AccountId} ownerAccountId
     * @returns {TokenNftAllowance}
     */
    static _fromGrantedProtobuf(allowance, ownerAccountId) {
        return new TokenNftAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
            ),
            spenderAccountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (allowance.spender),
            ),
            ownerAccountId,
            serialNumbers: [],
            allSerials: null,
            delegatingSpender: null,
        });
    }

    /**
     * @internal
     * @param {HieroProto.proto.INftRemoveAllowance} allowance
     * @returns {TokenNftAllowance}
     */
    static _fromRemoveProtobuf(allowance) {
        return new TokenNftAllowance({
            tokenId: TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (allowance.tokenId),
            ),
            spenderAccountId: null,
            ownerAccountId:
                allowance.owner != null
                    ? AccountId._fromProtobuf(
                          /**@type {HieroProto.proto.IAccountID}*/ (
                              allowance.owner
                          ),
                      )
                    : null,
            serialNumbers:
                allowance.serialNumbers != null
                    ? allowance.serialNumbers.map((serialNumber) =>
                          Long.fromValue(serialNumber),
                      )
                    : [],
            allSerials: null,
            delegatingSpender: null,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.INftAllowance}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            spender:
                this.spenderAccountId != null
                    ? this.spenderAccountId._toProtobuf()
                    : null,
            owner:
                this.ownerAccountId != null
                    ? this.ownerAccountId._toProtobuf()
                    : null,
            approvedForAll:
                this.serialNumbers == null ? { value: this.allSerials } : null,
            serialNumbers: this.serialNumbers,
            delegatingSpender:
                this.delegatingSpender != null
                    ? this.delegatingSpender._toProtobuf()
                    : null,
        };
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        this.tokenId.validateChecksum(client);

        if (this.ownerAccountId != null) {
            this.ownerAccountId.validateChecksum(client);
        }

        if (this.spenderAccountId != null) {
            this.spenderAccountId.validateChecksum(client);
        }
    }
}
// Filename: src/account/TokenNftTransferMap.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import TokenId from "../token/TokenId.js";
import AccountId from "../account/AccountId.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").proto.INftTransfer} HieroProto.proto.INftTransfer
 * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {object} NftTransfer
 * @property {AccountId} sender
 * @property {AccountId} recipient
 * @property {Long} serial
 * @property {boolean} isApproved
 */

/**
 * @augments {ObjectMap<TokenId, NftTransfer[]>}
 */
export default class TokenNftTransferMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }

    /**
     * @internal
     * @param {TokenId} tokenId
     * @param {NftTransfer} nftTransfer
     */
    __set(tokenId, nftTransfer) {
        const token = tokenId.toString();

        let _map = this._map.get(token);
        if (_map == null) {
            _map = [];
            this._map.set(token, _map);
            this.__map.set(tokenId, _map);
        }

        _map.push(nftTransfer);
    }

    /**
     * @param {HieroProto.proto.ITokenTransferList[]} transfers
     * @returns {TokenNftTransferMap}
     */
    static _fromProtobuf(transfers) {
        const tokenTransfersMap = new TokenNftTransferMap();

        for (const transfer of transfers) {
            const token = TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (transfer.token),
            );

            for (const aa of transfer.nftTransfers != null
                ? transfer.nftTransfers
                : []) {
                const sender = AccountId._fromProtobuf(
                    /** @type {HieroProto.proto.IAccountID} */ (
                        aa.senderAccountID
                    ),
                );
                const recipient = AccountId._fromProtobuf(
                    /** @type {HieroProto.proto.IAccountID} */ (
                        aa.receiverAccountID
                    ),
                );

                tokenTransfersMap.__set(token, {
                    sender,
                    recipient,
                    serial: Long.fromValue(
                        /** @type {Long} */ (aa.serialNumber),
                    ),
                    isApproved: false,
                });
            }
        }

        return tokenTransfersMap;
    }

    /**
     * @returns {HieroProto.proto.ITokenTransferList[]}
     */
    _toProtobuf() {
        /** @type {HieroProto.proto.ITokenTransferList[]} */
        const tokenTransferList = [];

        for (const [tokenId, value] of this) {
            /** @type {HieroProto.proto.INftTransfer[]} */
            const transfers = [];

            for (const transfer of value) {
                transfers.push({
                    senderAccountID: transfer.sender._toProtobuf(),
                    receiverAccountID: transfer.recipient._toProtobuf(),
                    serialNumber: transfer.serial,
                });
            }

            tokenTransferList.push({
                token: tokenId._toProtobuf(),
                nftTransfers: transfers,
            });
        }

        return tokenTransferList;
    }

    toJSON() {
        const obj = {};

        this._map.forEach((value, key) => {
            // @ts-ignore
            obj[key] = value.map((nftTransfer) => ({
                sender: nftTransfer.sender.toString(),
                recipient: nftTransfer.recipient.toString(),
                serial: nftTransfer.serial,
                isApproved: nftTransfer.isApproved,
            }));
        });

        return obj;
    }
}
// Filename: src/account/TokenRelationship.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import TokenId from "../token/TokenId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenRelationship} HieroProto.proto.ITokenRelationship
 * @typedef {import("@hashgraph/proto").proto.TokenKycStatus} HieroProto.proto.TokenKycStatus
 * @typedef {import("@hashgraph/proto").proto.TokenFreezeStatus} HieroProto.proto.TokenFreezeStatus
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * Token's information related to the given Account
 */
export default class TokenRelationship {
    /**
     * @param {object} props
     * @param {TokenId} props.tokenId
     * @param {string} props.symbol
     * @param {Long} props.balance
     * @param {boolean | null} props.isKycGranted
     * @param {boolean | null} props.isFrozen
     * @param {boolean | null} props.automaticAssociation
     */
    constructor(props) {
        /**
         * The ID of the token
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The Symbol of the token
         *
         * @readonly
         */
        this.symbol = props.symbol;

        /**
         * The balance that the Account holds in the smallest denomination
         *
         * @readonly
         */
        this.balance = props.balance;

        /**
         * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does
         * not have KYC key, KycNotApplicable is returned
         *
         * @readonly
         */
        this.isKycGranted = props.isKycGranted;

        /**
         * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token
         * does not have Freeze key, FreezeNotApplicable is returned
         *
         * @readonly
         */
        this.isFrozen = props.isFrozen;

        /**
         * Specifies if the relationship is created implicitly. False : explicitly associated, True :
         * implicitly associated.
         *
         * @readonly
         */
        this.automaticAssociation = props.automaticAssociation;

        Object.freeze(this);
    }

    /**
     * @param {HieroProto.proto.ITokenRelationship} relationship
     * @returns {TokenRelationship}
     */
    static _fromProtobuf(relationship) {
        const tokenId = TokenId._fromProtobuf(
            /** @type {HieroProto.proto.ITokenID} */ (relationship.tokenId),
        );
        const isKycGranted =
            relationship.kycStatus == null || relationship.kycStatus === 0
                ? null
                : relationship.kycStatus === 1;
        const isFrozen =
            relationship.freezeStatus == null || relationship.freezeStatus === 0
                ? null
                : relationship.freezeStatus === 1;

        return new TokenRelationship({
            tokenId,
            symbol: /** @type {string} */ (relationship.symbol),
            balance:
                relationship.balance != null
                    ? relationship.balance instanceof Long
                        ? relationship.balance
                        : Long.fromValue(relationship.balance)
                    : Long.ZERO,
            isKycGranted,
            isFrozen,
            automaticAssociation:
                relationship.automaticAssociation != null
                    ? relationship.automaticAssociation
                    : null,
        });
    }

    /**
     * @returns {HieroProto.proto.ITokenRelationship}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            symbol: this.symbol,
            balance: this.balance,
            kycStatus:
                this.isKycGranted == null ? 0 : this.isKycGranted ? 1 : 2,
            freezeStatus: this.isFrozen == null ? 0 : this.isFrozen ? 1 : 2,
            automaticAssociation: this.automaticAssociation,
        };
    }
}
// Filename: src/account/TokenRelationshipMap.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import TokenRelationship from "./TokenRelationship.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenRelationship} HieroProto.proto.ITokenRelationship
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("long")} Long
 */

/**
 * @augments {ObjectMap<TokenId, TokenRelationship>}
 */
export default class TokenRelationshipMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }

    /**
     * @param {HieroProto.proto.ITokenRelationship[]} relationships
     * @returns {TokenRelationshipMap}
     */
    static _fromProtobuf(relationships) {
        const tokenRelationships = new TokenRelationshipMap();

        for (const relationship of relationships) {
            const tokenId = TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (relationship.tokenId),
            );

            tokenRelationships._set(
                tokenId,
                TokenRelationship._fromProtobuf(relationship),
            );
        }

        return tokenRelationships;
    }

    /**
     * @returns {HieroProto.proto.ITokenRelationship[]}
     */
    _toProtobuf() {
        const list = [];

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, relationship] of this) {
            list.push(relationship._toProtobuf());
        }

        return list;
    }
}
// Filename: src/account/TokenTransferAccountMap.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @augments {ObjectMap<AccountId, Long>}
 */
export default class TokenTransferAccountMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    toJSON() {
        const obj = {};

        this._map.forEach((value, key) => {
            // @ts-ignore
            obj[key] = value.toString();
        });

        return obj;
    }
}
// Filename: src/account/TokenTransferMap.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "../token/TokenId.js";
import AccountId from "../account/AccountId.js";
import TokenTransferAccountMap from "./TokenTransferAccountMap.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @augments {ObjectMap<TokenId, TokenTransferAccountMap>}
 */
export default class TokenTransferMap extends ObjectMap {
    constructor() {
        super((s) => TokenId.fromString(s));
    }

    /**
     * @internal
     * @param {TokenId} tokenId
     * @param {AccountId} accountId
     * @param {Long} amount
     */
    __set(tokenId, accountId, amount) {
        const token = tokenId.toString();

        let _map = this._map.get(token);
        if (_map == null) {
            _map = new TokenTransferAccountMap();
            this._map.set(token, _map);
            this.__map.set(tokenId, _map);
        }

        _map._set(accountId, amount);
    }

    /**
     * @param {HieroProto.proto.ITokenTransferList[]} transfers
     * @returns {TokenTransferMap}
     */
    static _fromProtobuf(transfers) {
        const tokenTransfersMap = new TokenTransferMap();

        for (const transfer of transfers) {
            const token = TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (transfer.token),
            );

            for (const aa of transfer.transfers != null
                ? transfer.transfers
                : []) {
                const account = AccountId._fromProtobuf(
                    /** @type {HieroProto.proto.IAccountID} */ (aa.accountID),
                );

                tokenTransfersMap.__set(
                    token,
                    account,
                    /** @type {Long} */ (aa.amount),
                );
            }
        }

        return tokenTransfersMap;
    }

    /**
     * @returns {HieroProto.proto.ITokenTransferList[]}
     */
    _toProtobuf() {
        /** @type {HieroProto.proto.ITokenTransferList[]} */
        const tokenTransferList = [];

        for (const [tokenId, value] of this) {
            /** @type {HieroProto.proto.IAccountAmount[]} */
            const transfers = [];

            for (const [accountId, amount] of value) {
                transfers.push({
                    accountID: accountId._toProtobuf(),
                    amount: amount,
                });
            }

            tokenTransferList.push({
                token: tokenId._toProtobuf(),
                transfers: transfers,
            });
        }

        return tokenTransferList;
    }
}
// Filename: src/account/TransferTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import TokenId from "../token/TokenId.js";
import AccountId from "./AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Transfer from "../Transfer.js";
import TokenTransfer from "../token/TokenTransfer.js";
import HbarTransferMap from "./HbarTransferMap.js";
import TokenNftTransfer from "../token/TokenNftTransfer.js";
import NftId from "../token/NftId.js";
import AbstractTokenTransferTransaction from "../token/AbstractTokenTransferTransaction.js";

/**
 * @typedef {import("../long.js").LongObject} LongObject
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ICryptoTransferTransactionBody} HieroProto.proto.ICryptoTransferTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} TransferTokensInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} accountId
 * @property {Long | number} amount
 */

/**
 * @typedef {object} TransferTokenObject
 * @property {TokenId} tokenId
 * @property {AccountId} accountId
 * @property {Long} amount
 */

/**
 * @typedef {object} TransferHbarInput
 * @property {AccountId | string} accountId
 * @property {number | string | Long | BigNumber | Hbar} amount
 */

/**
 * @typedef {object} TransferNftInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} sender
 * @property {AccountId | string} recipient
 * @property {Long | number} serial
 */

/**
 * Transfers a new Hedera™ crypto-currency token.
 */
export default class TransferTransaction extends AbstractTokenTransferTransaction {
    /**
     * @param {object} [props]
     * @param {(TransferTokensInput)[]} [props.tokenTransfers]
     * @param {(TransferHbarInput)[]} [props.hbarTransfers]
     * @param {(TransferNftInput)[]} [props.nftTransfers]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {Transfer[]}
         */
        this._hbarTransfers = [];

        this._defaultMaxTransactionFee = new Hbar(1);

        for (const transfer of props.hbarTransfers != null
            ? props.hbarTransfers
            : []) {
            this.addHbarTransfer(transfer.accountId, transfer.amount);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TransferTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const cryptoTransfer =
            /** @type {HieroProto.proto.ICryptoTransferTransactionBody} */ (
                body.cryptoTransfer
            );

        const transfers = new TransferTransaction();

        transfers._tokenTransfers = TokenTransfer._fromProtobuf(
            cryptoTransfer.tokenTransfers != null
                ? cryptoTransfer.tokenTransfers
                : [],
        );

        transfers._hbarTransfers = Transfer._fromProtobuf(
            cryptoTransfer.transfers != null
                ? cryptoTransfer.transfers.accountAmounts != null
                    ? cryptoTransfer.transfers.accountAmounts
                    : []
                : [],
        );

        transfers._nftTransfers = TokenNftTransfer._fromProtobuf(
            cryptoTransfer.tokenTransfers != null
                ? cryptoTransfer.tokenTransfers
                : [],
        );

        return Transaction._fromProtobufTransactions(
            transfers,
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {HbarTransferMap}
     */
    get hbarTransfers() {
        const map = new HbarTransferMap();

        for (const transfer of this._hbarTransfers) {
            map._set(transfer.accountId, transfer.amount);
        }

        return map;
    }

    /**
     * @returns {Transfer[]}
     */
    get hbarTransfersList() {
        return this._hbarTransfers;
    }

    /**
     * @internal
     * @param {AccountId | string} accountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    _addHbarTransfer(accountId, amount, isApproved) {
        this._requireNotFrozen();

        const account =
            accountId instanceof AccountId
                ? accountId.clone()
                : AccountId.fromString(accountId);
        const hbars = amount instanceof Hbar ? amount : new Hbar(amount);

        for (const transfer of this._hbarTransfers) {
            if (transfer.accountId.compare(account) === 0) {
                transfer.amount = Hbar.fromTinybars(
                    transfer.amount.toTinybars().add(hbars.toTinybars()),
                );
                return this;
            }
        }

        this._hbarTransfers.push(
            new Transfer({
                accountId: account,
                amount: hbars,
                isApproved,
            }),
        );

        return this;
    }

    /**
     * @internal
     * @param {AccountId | string} accountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {TransferTransaction}
     */
    addHbarTransfer(accountId, amount) {
        return this._addHbarTransfer(accountId, amount, false);
    }

    /**
     * @internal
     * @param {AccountId | string} accountId
     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount
     * @returns {TransferTransaction}
     */
    addApprovedHbarTransfer(accountId, amount) {
        return this._addHbarTransfer(accountId, amount, true);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const transfer of this._hbarTransfers) {
            transfer.accountId.validateChecksum(client);
        }

        for (const transfer of this._tokenTransfers) {
            transfer.tokenId.validateChecksum(client);
            transfer.accountId.validateChecksum(client);
        }

        for (const transfer of this._nftTransfers) {
            transfer.tokenId.validateChecksum(client);
            transfer.senderAccountId.validateChecksum(client);
            transfer.receiverAccountId.validateChecksum(client);
        }
    }

    /**
     * @deprecated - Use `addApprovedHbarTransfer()` instead
     * @param {AccountId | string} accountId
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    setHbarTransferApproval(accountId, isApproved) {
        const account =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;

        for (const transfer of this._hbarTransfers) {
            if (transfer.accountId.compare(account) === 0) {
                transfer.isApproved = isApproved;
            }
        }

        return this;
    }

    /**
     * @deprecated - Use `addApprovedTokenTransfer()` instead
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    setTokenTransferApproval(tokenId, accountId, isApproved) {
        const token =
            typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
        const account =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;

        for (const tokenTransfer of this._tokenTransfers) {
            if (
                tokenTransfer.tokenId.compare(token) === 0 &&
                tokenTransfer.accountId.compare(account) === 0
            ) {
                tokenTransfer.isApproved = isApproved;
            }
        }

        return this;
    }

    /**
     * @deprecated - Use `addApprovedNftTransfer()` instead
     * @param {NftId | string} nftId
     * @param {boolean} isApproved
     * @returns {TransferTransaction}
     */
    setNftTransferApproval(nftId, isApproved) {
        const nft = typeof nftId === "string" ? NftId.fromString(nftId) : nftId;

        for (const transfer of this._nftTransfers) {
            if (
                transfer.tokenId.compare(nft.tokenId) === 0 &&
                transfer.serialNumber.compare(nft.serial) === 0
            ) {
                transfer.isApproved = isApproved;
            }
        }

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.cryptoTransfer(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "cryptoTransfer";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ICryptoTransferTransactionBody}
     */
    _makeTransactionData() {
        const { tokenTransfers } = super._makeTransactionData();

        this._hbarTransfers.sort((a, b) => a.accountId.compare(b.accountId));

        return {
            transfers: {
                accountAmounts: this._hbarTransfers.map((transfer) => {
                    return {
                        accountID: transfer.accountId._toProtobuf(),
                        amount: transfer.amount.toTinybars(),
                        isApproval: transfer.isApproved,
                    };
                }),
            },
            tokenTransfers,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TransferTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "cryptoTransfer",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TransferTransaction._fromProtobuf,
);
// Filename: src/address_book/AddressBooks.js
// SPDX-License-Identifier: Apache-2.0

import NodeAddressBook from "./NodeAddressBook.js";
import * as hex from "../encoding/hex.js";
import * as HieroProto from "@hashgraph/proto";

export const PREVIEWNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
    HieroProto.proto.NodeAddressBook.decode(
        hex.decode(
            "0ad0070a0e33352e3233312e3230382e31343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340acf070a0d332e3231312e3234382e31373210a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ace070a0c34302e3132312e36342e343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ad1070a0d33352e3139392e31352e31373710a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad1070a0d332e3133332e3231332e31343610a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad0070a0c34302e37302e31312e32303210a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad2070a0e33352e3232352e3230312e31393510a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d35322e31352e3130352e31333010a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d3130342e34332e3234382e363310a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad2070a0e33352e3234372e3130392e31333510a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b35342e3234312e33382e3110a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b31332e38382e32322e343710a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330ad0070a0c33352e3233352e36352e353110a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d35342e3137372e35312e31323710a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad0070a0c31332e36342e3137302e343010a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d33342e3130362e3234372e363510a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33352e38332e38392e31373110a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad1070a0d31332e37382e3233322e31393210a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33342e3132352e32332e343910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390acf070a0b35302e31382e31372e393310a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390ad1070a0d32302e3135302e3133362e383910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939",
        ),
    ),
);
export const TESTNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
    HieroProto.proto.NodeAddressBook.decode(
        hex.decode(
            "0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232",
        ),
    ),
);
export const MAINNET_ADDRESS_BOOK = NodeAddressBook._fromProtobuf(
    HieroProto.proto.NodeAddressBook.decode(
        hex.decode(
            "0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330",
        ),
    ),
);
// Filename: src/address_book/Endpoint.js
// SPDX-License-Identifier: Apache-2.0

import IPv4Address from "./IPv4Address.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IServiceEndpoint} HieroProto.proto.IServiceEndpoint
 */

/**
 * @typedef {object} EndPointJson
 * @property {string | null} address
 * @property {string | null} port
 */

export default class EndPoint {
    /**
     * @param {object} props
     * @param {IPv4Address} [props.address]
     * @param {number} [props.port]
     */
    constructor(props = {}) {
        /**
         * @type {IPv4Address | null}
         */
        this._address = null;

        if (props.address != null) {
            this.setAddress(props.address);
        }

        /**
         * @type {number | null}
         */
        this._port = null;

        if (props.port != null) {
            this.setPort(props.port);
        }
    }

    /**
     * @returns {?IPv4Address}
     */
    get address() {
        return this.address;
    }

    /**
     * @param {IPv4Address} address
     * @returns {this}
     */
    setAddress(address) {
        this._address = address;
        return this;
    }

    /**
     * @returns {?number}
     */
    get port() {
        return this._port;
    }

    /**
     * @param {number} port
     * @returns {this}
     */
    setPort(port) {
        this._port = port;
        return this;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IServiceEndpoint} endpoint
     * @returns {EndPoint}
     */
    static _fromProtobuf(endpoint) {
        return new EndPoint({
            address:
                endpoint.ipAddressV4 != null
                    ? IPv4Address._fromProtobuf(endpoint.ipAddressV4)
                    : undefined,
            port: endpoint.port != null ? endpoint.port : undefined,
        });
    }

    /**
     * @returns {HieroProto.proto.IServiceEndpoint}
     */
    _toProtobuf() {
        return {
            ipAddressV4:
                this._address != null ? this._address._toProtobuf() : null,
            port: this._port,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this._address != null ? this._address.toString() : ""}:${
            this._port != null ? this._port.toString() : ""
        }`;
    }

    /**
     * @returns {EndPointJson}
     */
    toJSON() {
        return {
            address: this._address != null ? this._address.toString() : null,
            port: this._port != null ? this._port.toString() : null,
        };
    }
}
// Filename: src/address_book/IPv4Address.js
// SPDX-License-Identifier: Apache-2.0

import IPv4AddressPart from "./IPv4AddressPart.js";

export default class IPv4Address {
    /**
     * @param {object} props
     * @param {IPv4AddressPart} [props.network]
     * @param {IPv4AddressPart} [props.host]
     */
    constructor(props = {}) {
        /**
         * @type {IPv4AddressPart | null}
         */
        this._network = null;

        if (props.network != null) {
            this.setNetwork(props.network);
        }

        /**
         * @type {IPv4AddressPart | null}
         */
        this._host = null;

        if (props.host != null) {
            this.setHost(props.host);
        }
    }

    /**
     * @returns {?IPv4AddressPart}
     */
    get newtork() {
        return this._network;
    }

    /**
     * @param {IPv4AddressPart} part
     * @returns {this}
     */
    setNetwork(part) {
        this._network = part;
        return this;
    }

    /**
     * @returns {?IPv4AddressPart}
     */
    get host() {
        return this._host;
    }

    /**
     * @param {IPv4AddressPart} part
     * @returns {this}
     */
    setHost(part) {
        this._host = part;
        return this;
    }

    /**
     * @internal
     * @param {Uint8Array} bytes
     * @returns {IPv4Address}
     */
    static _fromProtobuf(bytes) {
        return new IPv4Address({
            network: new IPv4AddressPart().setLeft(bytes[0]).setRight(bytes[1]),
            host: new IPv4AddressPart().setLeft(bytes[2]).setRight(bytes[3]),
        });
    }

    /**
     * @returns {Uint8Array}
     */
    _toProtobuf() {
        return Uint8Array.of(
            this._network != null && this._network._left != null
                ? this._network._left
                : 0,
            this._network != null && this._network.right != null
                ? this._network.right
                : 0,
            this._host != null && this._host.left != null ? this._host.left : 0,
            this._host != null && this._host.right != null
                ? this._host.right
                : 0,
        );
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this._network != null && this._host != null) {
            return `${this._network.toString()}.${this._host.toString()}`;
        } else {
            return "";
        }
    }
}
// Filename: src/address_book/IPv4AddressPart.js
// SPDX-License-Identifier: Apache-2.0

export default class IPv4AddressPart {
    /**
     * @param {object} props
     * @param {number} [props.left]
     * @param {number} [props.right]
     */
    constructor(props = {}) {
        /**
         * @type {number | null}
         */
        this._left = null;

        if (props.left != null) {
            this.setLeft(props.left);
        }

        /**
         * @type {number | null}
         */
        this._right = null;

        if (props.right != null) {
            this.setRight(props.right);
        }
    }

    /**
     * @returns {?number}
     */
    get left() {
        return this._left;
    }

    /**
     * @param {number} part
     * @returns {this}
     */
    setLeft(part) {
        this._left = part;
        return this;
    }

    /**
     * @returns {?number}
     */
    get right() {
        return this._right;
    }

    /**
     * @param {number} part
     * @returns {this}
     */
    setRight(part) {
        this._right = part;
        return this;
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this._left != null && this._right != null) {
            return `${this._left.toString()}.${this._right.toString()}`;
        } else {
            return "";
        }
    }
}
// Filename: src/address_book/NodeAddress.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import Endpoint from "./Endpoint.js";
import * as utf8 from "../encoding/utf8.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.INodeAddress} HieroProto.proto.INodeAddress
 */

/**
 * @typedef {import("./Endpoint.js").EndPointJson} EndpointJson
 * @typedef {import("long")} Long
 */

/**
 * @typedef {object} NodeAddressJson
 * @property {string | null} publicKey
 * @property {string | null} nodeId
 * @property {string | null} accountId
 * @property {string | null} certHash
 * @property {EndpointJson[] | null} addresses
 * @property {string | null} description
 * @property {string | null} stake
 */

export default class NodeAddress {
    /**
     * @param {object} props
     * @param {string} [props.publicKey]
     * @param {Long} [props.nodeId]
     * @param {AccountId | string} [props.accountId]
     * @param {Uint8Array} [props.certHash]
     * @param {Endpoint[]} [props.addresses]
     * @param {string} [props.description]
     * @param {Long} [props.stake]
     */
    constructor(props = {}) {
        /**
         * @type {string | null}
         */
        this._publicKey = null;

        if (props.publicKey != null) {
            this.setPublicKey(props.publicKey);
        }

        /**
         * @type {Long |null}
         */
        this._nodeId = null;

        if (props.nodeId != null) {
            this.setNodeId(props.nodeId);
        }

        /**
         * @type {AccountId | null}
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {Uint8Array | null}
         */
        this._certHash = null;

        if (props.certHash != null) {
            this.setCertHash(props.certHash);
        }

        /**
         * @type {Endpoint[]}
         */
        this._addresses = [];

        if (props.addresses != null) {
            this.setAddresses(props.addresses);
        }

        /**
         * @type {string | null}
         */
        this._description = null;

        if (props.description != null) {
            this.setDescription(props.description);
        }

        /**
         * @type {Long | null}
         */
        this._stake = null;

        if (props.stake != null) {
            this.setStake(props.stake);
        }
    }

    /**
     * @returns {?string}
     */
    get publicKey() {
        return this._publicKey;
    }

    /**
     * @param {string} publicKey
     * @returns {this}
     */
    setPublicKey(publicKey) {
        this._publicKey = publicKey;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get nodeId() {
        return this._nodeId;
    }

    /**
     * @param {Long} nodeId
     * @returns {this}
     */
    setNodeId(nodeId) {
        this._nodeId = nodeId;
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();
        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get certHash() {
        return this._certHash;
    }

    /**
     * @param {Uint8Array} certHash
     * @returns {this}
     */
    setCertHash(certHash) {
        this._certHash = certHash;
        return this;
    }

    /**
     * @returns {Endpoint[]}
     */
    get addresses() {
        return this._addresses;
    }

    /**
     * @param {Endpoint[]} addresses
     * @returns {this}
     */
    setAddresses(addresses) {
        this._addresses = addresses;
        return this;
    }

    /**
     * @returns {?string}
     */
    get description() {
        return this._description;
    }

    /**
     * @param {string} description
     * @returns {this}
     */
    setDescription(description) {
        this._description = description;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get stake() {
        return this._stake;
    }

    /**
     * @param {Long} stake
     * @returns {this}
     */
    setStake(stake) {
        this._stake = stake;
        return this;
    }

    /**
     * @internal
     * @param {HieroProto.proto.INodeAddress} nodeAddress
     * @returns {NodeAddress}
     */
    static _fromProtobuf(nodeAddress) {
        return new NodeAddress({
            publicKey:
                nodeAddress.RSA_PubKey != null
                    ? nodeAddress.RSA_PubKey
                    : undefined,
            nodeId: nodeAddress.nodeId != null ? nodeAddress.nodeId : undefined,
            accountId:
                nodeAddress.nodeAccountId != null
                    ? AccountId._fromProtobuf(nodeAddress.nodeAccountId)
                    : undefined,
            certHash:
                nodeAddress.nodeCertHash != null
                    ? nodeAddress.nodeCertHash
                    : undefined,
            addresses:
                nodeAddress.serviceEndpoint != null
                    ? nodeAddress.serviceEndpoint.map((address) =>
                          Endpoint._fromProtobuf(address),
                      )
                    : undefined,
            description:
                nodeAddress.description != null
                    ? nodeAddress.description
                    : undefined,
            stake: nodeAddress.stake != null ? nodeAddress.stake : undefined,
        });
    }

    /**
     * @returns {HieroProto.proto.INodeAddress}
     */
    _toProtobuf() {
        return {
            RSA_PubKey: this._publicKey,
            nodeId: this._nodeId,
            nodeAccountId:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            nodeCertHash: this._certHash,
            serviceEndpoint: this._addresses.map((address) =>
                address._toProtobuf(),
            ),
            description: this._description,
            stake: this._stake,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {NodeAddressJson}
     */
    toJSON() {
        return {
            publicKey: this._publicKey,
            nodeId: this._nodeId != null ? this._nodeId.toString() : null,
            accountId:
                this._accountId != null ? this._accountId.toString() : null,
            certHash:
                this._certHash != null ? utf8.decode(this._certHash) : null,
            addresses: this._addresses.map((address) => address.toJSON()),
            description: this._description,
            stake: this._stake != null ? this._stake.toString() : null,
        };
    }
}
// Filename: src/address_book/NodeAddressBook.js
// SPDX-License-Identifier: Apache-2.0

import NodeAddress from "./NodeAddress.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("./NodeAddress.js").NodeAddressJson} NodeAddressJson
 */

/**
 * @typedef {object} NodeAddressBookJson
 * @property {NodeAddressJson[]} nodeAddresses
 */

/**
 * Represents a collection of node addresses in the Hedera network.
 *
 * The NodeAddressBook contains information about the nodes in the Hedera network,
 * including their network addresses, account IDs, and node IDs. This class is used
 * to manage and access the network's node information.
 */
export default class NodeAddressBook {
    /**
     * @param {object} props
     * @param {NodeAddress[]} [props.nodeAddresses]
     */
    constructor(props = {}) {
        /**
         * @type {NodeAddress[]}
         */
        this._nodeAddresses = [];

        if (props.nodeAddresses != null) {
            this.setNodeAddresses(props.nodeAddresses);
        }
    }

    /**
     * @returns {NodeAddress[]}
     */
    get nodeAddresses() {
        return this._nodeAddresses;
    }

    /**
     * @param {NodeAddress[]} nodeAddresses
     * @returns {this}
     */
    setNodeAddresses(nodeAddresses) {
        this._nodeAddresses = nodeAddresses;
        return this;
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {NodeAddressBook}
     */
    static fromBytes(bytes) {
        return NodeAddressBook._fromProtobuf(
            HieroProto.proto.NodeAddressBook.decode(bytes),
        );
    }

    /**
     * @internal
     * @param {HieroProto.proto.INodeAddressBook} nodeAddressBook
     * @returns {NodeAddressBook}
     */
    static _fromProtobuf(nodeAddressBook) {
        return new NodeAddressBook({
            nodeAddresses:
                nodeAddressBook.nodeAddress != null
                    ? nodeAddressBook.nodeAddress.map((nodeAddress) =>
                          NodeAddress._fromProtobuf(nodeAddress),
                      )
                    : undefined,
        });
    }

    /**
     * @returns {HieroProto.proto.INodeAddressBook}
     */
    _toProtobuf() {
        return {
            nodeAddress: this._nodeAddresses.map((nodeAddress) =>
                nodeAddress._toProtobuf(),
            ),
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @returns {NodeAddressBookJson}
     */
    toJSON() {
        return {
            nodeAddresses: this._nodeAddresses.map((nodeAddress) =>
                nodeAddress.toJSON(),
            ),
        };
    }

    toBytes() {
        return HieroProto.proto.NodeAddressBook.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/array.js
// SPDX-License-Identifier: Apache-2.0

/**
 * A simple efficient function for comparing byte arrays
 *
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
export function arrayEqual(array1, array2) {
    if (array1 === array2) {
        return true;
    }

    if (array1.byteLength !== array2.byteLength) {
        return false;
    }

    const view1 = new DataView(
        array1.buffer,
        array1.byteOffset,
        array1.byteLength,
    );
    const view2 = new DataView(
        array2.buffer,
        array2.byteOffset,
        array2.byteLength,
    );

    let i = array1.byteLength;

    while (i--) {
        if (view1.getUint8(i) !== view2.getUint8(i)) {
            return false;
        }
    }

    return true;
}

/**
 * @param {Uint8Array} array
 * @param {Uint8Array} arrayPrefix
 * @returns {boolean}
 */
export function arrayStartsWith(array, arrayPrefix) {
    if (array.byteLength < arrayPrefix.byteLength) {
        return false;
    }

    let i = arrayPrefix.byteLength;

    while (i--) {
        if (array[i] !== arrayPrefix[i]) {
            return false;
        }
    }

    return true;
}
// Filename: src/base32.js
// SPDX-License-Identifier: Apache-2.0

// HIP-32: https://hips.hedera.com/hip/hip-32
import { base32 } from "rfc4648";

const decodeOpts = { loose: true };
const encodeOpts = { pad: false };

/**
 * Decodes the rfc4648 base32 string into a {@link Uint8Array}. If the input string is null, returns null.
 * @param {string} str  the base32 string.
 * @returns {Uint8Array | ''}
 */
// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
const decode = (str) => str && base32.parse(str, decodeOpts);

/**
 * Encodes the byte array into a rfc4648 base32 string without padding. If the input is null, returns null. Note with
 * the rfc4648 loose = true option, it allows lower case letters, padding, and auto corrects 0 -> O, 1 -> L, 8 -> B
 * @param {Buffer|Uint8Array} data
 * @returns {string}
 */
// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
const encode = (data) => data && base32.stringify(data, encodeOpts);

export default {
    decode,
    encode,
};
// Filename: src/browser.js
// SPDX-License-Identifier: Apache-2.0

/**
 * The entry point for Browser applications
 */

export * from "./exports.js";

export { default as Client } from "./client/WebClient.js";
// Filename: src/channel/Channel.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import * as utf8 from "../encoding/utf8.js";

const { proto } = HieroProto;

/**
 * @internal
 * @abstract
 */
export default class Channel {
    /**
     * @protected
     */
    constructor() {
        /**
         * @protected
         * @type {?HieroProto.proto.CryptoService}
         */
        this._crypto = null;

        /**
         * @protected
         * @type {?HieroProto.proto.SmartContractService}
         */
        this._smartContract = null;

        /**
         * @protected
         * @type {?HieroProto.proto.FileService}
         */
        this._file = null;

        /**
         * @protected
         * @type {?HieroProto.proto.ConsensusService}
         */
        this._consensus = null;

        /**
         * @protected
         * @type {?HieroProto.proto.FreezeService}
         */
        this._freeze = null;

        /**
         * @protected
         * @type {?HieroProto.proto.NetworkService}
         */
        this._network = null;

        /**
         * @protected
         * @type {?HieroProto.proto.TokenService}
         */
        this._token = null;

        /**
         * @protected
         * @type {?HieroProto.proto.ScheduleService}
         */
        this._schedule = null;

        /**
         * @protected
         * @type {?HieroProto.proto.UtilService}
         */
        this._util = null;

        /**
         * @protected
         * @type {?HieroProto.proto.AddressBookService}
         */
        this._addressBook = null;
    }

    /**
     * @abstract
     * @returns {void}
     */
    close() {
        throw new Error("not implemented");
    }

    /**
     * @returns {HieroProto.proto.CryptoService}
     */
    get crypto() {
        if (this._crypto != null) {
            return this._crypto;
        }

        this._crypto = proto.CryptoService.create(
            this._createUnaryClient("CryptoService"),
        );

        return this._crypto;
    }

    /**
     * @returns {HieroProto.proto.SmartContractService}
     */
    get smartContract() {
        if (this._smartContract != null) {
            return this._smartContract;
        }

        this._smartContract = proto.SmartContractService.create(
            this._createUnaryClient("SmartContractService"),
        );

        return this._smartContract;
    }

    /**
     * @returns {HieroProto.proto.FileService}
     */
    get file() {
        if (this._file != null) {
            return this._file;
        }

        this._file = proto.FileService.create(
            this._createUnaryClient("FileService"),
        );

        return this._file;
    }

    /**
     * @returns {HieroProto.proto.ConsensusService}
     */
    get consensus() {
        if (this._consensus != null) {
            return this._consensus;
        }

        this._consensus = proto.ConsensusService.create(
            this._createUnaryClient("ConsensusService"),
        );

        return this._consensus;
    }

    /**
     * @returns {HieroProto.proto.FreezeService}
     */
    get freeze() {
        if (this._freeze != null) {
            return this._freeze;
        }

        this._freeze = proto.FreezeService.create(
            this._createUnaryClient("FreezeService"),
        );

        return this._freeze;
    }

    /**
     * @returns {HieroProto.proto.NetworkService}
     */
    get network() {
        if (this._network != null) {
            return this._network;
        }

        this._network = proto.NetworkService.create(
            this._createUnaryClient("NetworkService"),
        );

        return this._network;
    }

    /**
     * @returns {HieroProto.proto.TokenService}
     */
    get token() {
        if (this._token != null) {
            return this._token;
        }

        this._token = proto.TokenService.create(
            this._createUnaryClient("TokenService"),
        );

        return this._token;
    }

    /**
     * @returns {HieroProto.proto.ScheduleService}
     */
    get schedule() {
        if (this._schedule != null) {
            return this._schedule;
        }

        this._schedule = proto.ScheduleService.create(
            this._createUnaryClient("ScheduleService"),
        );

        return this._schedule;
    }

    /**
     * @returns {HieroProto.proto.UtilService}
     */
    get util() {
        if (this._util != null) {
            return this._util;
        }

        this._util = proto.UtilService.create(
            this._createUnaryClient("UtilService"),
        );

        return this._util;
    }

    /**
     * @returns {HieroProto.proto.AddressBookService}
     */
    get addressBook() {
        if (this._addressBook != null) {
            return this._addressBook;
        }

        this._addressBook = proto.AddressBookService.create(
            this._createUnaryClient("AddressBookService"),
        );

        return this._addressBook;
    }

    /**
     * @abstract
     * @protected
     * @param {string} serviceName
     * @returns {import("protobufjs").RPCImpl}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _createUnaryClient(serviceName) {
        throw new Error("not implemented");
    }
}

// grpc-web+proto is a series of data or trailer frames

// a frame is identified by a single byte (0 = data or 1 = trailer) followed by 4 bytes for the
// length of the frame, followed by the frame data

/**
 * @param {Uint8Array} data
 * @returns {ArrayBuffer}
 */
export function encodeRequest(data) {
    // for our requests, we want to transfer a single data frame

    const frame = new ArrayBuffer(data.byteLength + 5);

    // the frame type (data) is zero and can be left default-initialized

    // the length of the frame data
    new DataView(frame, 1, 4).setUint32(0, data.length);

    // copy in the frame data
    new Uint8Array(frame, 5).set(data);

    return frame;
}

/**
 * @param {ArrayBuffer} data
 * @param {number} byteOffset
 * @param {number} byteLength
 * @returns {Uint8Array}
 */
export function decodeUnaryResponse(
    data,
    byteOffset = 0,
    byteLength = data.byteLength,
) {
    const dataView = new DataView(data, byteOffset, byteLength);
    let dataOffset = 0;

    /** @type {?Uint8Array} */
    let unaryResponse = null;

    // 0 = successful
    let status = 0;

    while (dataOffset < dataView.byteLength) {
        const frameByte = dataView.getUint8(dataOffset + 0);
        const frameType = frameByte >> 7;
        const frameByteLength = dataView.getUint32(dataOffset + 1);
        const frameOffset = dataOffset + 5; // offset from the start of the dataView
        if (frameOffset + frameByteLength > dataView.byteLength) {
            throw new Error("(BUG) unexpected frame length past the boundary");
        }
        const frameData = new Uint8Array(
            data,
            dataView.byteOffset + frameOffset,
            frameByteLength,
        );

        if (frameType === 0) {
            if (unaryResponse != null) {
                throw new Error(
                    "(BUG) unexpectedly received more than one data frame",
                );
            }

            unaryResponse = frameData;
        } else if (frameType === 1) {
            const trailer = utf8.decode(frameData);
            const [trailerName, trailerValue] = trailer.split(":");

            if (trailerName === "grpc-status") {
                status = parseInt(trailerValue);
            } else {
                throw new Error(`(BUG) unhandled trailer, ${trailer}`);
            }
        } else {
            throw new Error(`(BUG) unexpected frame type: ${frameType}`);
        }

        dataOffset += frameByteLength + 5;
    }

    if (status !== 0) {
        throw new Error(`(BUG) unhandled grpc-status: ${status}`);
    }

    if (unaryResponse == null) {
        throw new Error("(BUG) unexpectedly received no response");
    }

    return unaryResponse;
}
// Filename: src/channel/MirrorChannel.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @typedef {object} MirrorError
 * @property {number} code
 * @property {string} details
 */

/**
 * @internal
 * @abstract
 */
export default class MirrorChannel {
    /**
     * @abstract
     * @returns {void}
     */
    close() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @internal
     * @param {string} serviceName
     * @param {string} methodName
     * @param {Uint8Array} requestData
     * @param {(data: Uint8Array) => void} callback
     * @param {(error: MirrorError | Error) => void} error
     * @param {() => void} end
     * @returns {() => void}
     */
    makeServerStreamRequest(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        serviceName,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        methodName,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        requestData,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        callback,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        error,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        end,
    ) {
        throw new Error("not implemented");
    }
}
// Filename: src/channel/NativeChannel.js
// SPDX-License-Identifier: Apache-2.0

import Channel, { encodeRequest, decodeUnaryResponse } from "./Channel.js";
import * as base64 from "../encoding/base64.native.js";
import HttpError from "../http/HttpError.js";
import HttpStatus from "../http/HttpStatus.js";

export default class NativeChannel extends Channel {
    /**
     * @param {string} address
     */
    constructor(address) {
        super();

        /**
         * @type {string}
         * @private
         */
        this._address = address;
    }

    /**
     * @override
     * @returns {void}
     */
    close() {
        // do nothing
    }

    /**
     * @override
     * @protected
     * @param {string} serviceName
     * @returns {import("protobufjs").RPCImpl}
     */
    _createUnaryClient(serviceName) {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        return async (method, requestData, callback) => {
            try {
                const data = base64.encode(
                    new Uint8Array(encodeRequest(requestData)),
                );

                // this will be executed in react native environment sho
                // fetch should be available
                //eslint-disable-next-line n/no-unsupported-features/node-builtins
                const response = await fetch(
                    `${this._address}/proto.${serviceName}/${method.name}`,
                    {
                        method: "POST",
                        headers: {
                            "content-type": "application/grpc-web-text",
                            "x-user-agent": "hedera-sdk-js/v2",
                            "x-accept-content-transfer-encoding": "base64",
                            "x-grpc-web": "1",
                        },
                        body: data,
                    },
                );

                if (!response.ok) {
                    const error = new HttpError(
                        HttpStatus._fromValue(response.status),
                    );
                    callback(error, null);
                }

                const blob = await response.blob();

                /** @type {string} */
                const responseData = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(blob);
                    reader.onloadend = () => {
                        resolve(/** @type {string} */ (reader.result));
                    };
                    reader.onerror = reject;
                });

                let responseBuffer;
                if (
                    responseData.startsWith(
                        "data:application/octet-stream;base64,",
                    )
                ) {
                    responseBuffer = base64.decode(
                        responseData.split(
                            "data:application/octet-stream;base64,",
                        )[1],
                    );
                } else if (
                    responseData.startsWith(
                        "data:application/grpc-web+proto;base64,",
                    )
                ) {
                    responseBuffer = base64.decode(
                        responseData.split(
                            "data:application/grpc-web+proto;base64,",
                        )[1],
                    );
                } else {
                    throw new Error(
                        `Expected response data to be base64 encode with a 'data:application/octet-stream;base64,' or 'data:application/grpc-web+proto;base64,' prefix, but found: ${responseData}`,
                    );
                }

                const unaryResponse = decodeUnaryResponse(
                    // @ts-ignore
                    responseBuffer.buffer,
                    responseBuffer.byteOffset,
                    responseBuffer.byteLength,
                );

                callback(null, unaryResponse);
            } catch (error) {
                callback(/** @type {Error} */ (error), null);
            }
        };
    }
}
// Filename: src/channel/NodeChannel.js
// SPDX-License-Identifier: Apache-2.0

import tls from "tls";
import { Client, credentials } from "@grpc/grpc-js";
import Channel from "./Channel.js";
import GrpcServicesError from "../grpc/GrpcServiceError.js";
import GrpcStatus from "../grpc/GrpcStatus.js";
import { ALL_NETWORK_IPS } from "../constants/ClientConstants.js";

/** @type {{ [key: string]: Client }} */
const clientCache = {};

export default class NodeChannel extends Channel {
    /**
     * @internal
     * @param {string} address
     * @param {number=} maxExecutionTime
     */
    constructor(address, maxExecutionTime) {
        super();

        /** @type {Client | null} */
        this._client = null;

        this.address = address;
        this.maxExecutionTime = maxExecutionTime;

        const { ip, port } = this.parseAddress(address);
        this.nodeIp = ip;
        this.nodePort = port;
    }

    /**
     * Convert certificate bytes to PEM format
     * @param {Buffer} certBytes
     * @returns {string}
     */
    bytesToPem(certBytes) {
        const base64Cert = certBytes.toString("base64");
        const lines = base64Cert.match(/.{1,64}/g)?.join("\n") || "";
        return `-----BEGIN CERTIFICATE-----\n${lines}\n-----END CERTIFICATE-----`;
    }

    /**
     * Validates and parses an address in the "IP:Port" format.
     * @param {string} address
     * @returns {{ ip: string, port: string }}
     */
    parseAddress(address) {
        const [ip, port] = address.split(":");
        if (!ip || !port) {
            throw new Error(
                "Invalid address format. Expected format: 'IP:Port'",
            );
        }
        return { ip, port };
    }

    /**
     * Retrieve the server's certificate dynamically.
     * @returns {Promise<string>}
     */
    async _retrieveCertificate() {
        return new Promise((resolve, reject) => {
            const socket = tls.connect(
                {
                    host: this.nodeIp,
                    port: Number(this.nodePort),
                    rejectUnauthorized: false,
                },
                () => {
                    try {
                        const cert = socket.getPeerCertificate();

                        if (cert && cert.raw) {
                            resolve(this.bytesToPem(cert.raw));
                        } else {
                            reject(new Error("No certificate retrieved."));
                        }
                    } catch (err) {
                        reject(err);
                    } finally {
                        socket.end();
                    }
                },
            );

            socket.on("error", reject);
        });
    }

    /**
     * Initialize the gRPC client
     * @returns {Promise<void>}
     */
    async _initializeClient() {
        if (clientCache[this.address]) {
            this._client = clientCache[this.address];
            return;
        }

        let security;
        const options = {
            "grpc.ssl_target_name_override": "127.0.0.1",
            "grpc.default_authority": "127.0.0.1",
            "grpc.http_connect_creds": "0",
            "grpc.keepalive_time_ms": 100000,
            "grpc.keepalive_timeout_ms": 10000,
            "grpc.keepalive_permit_without_calls": 1,
            "grpc.enable_retries": 0,
        };

        // If the port is 50212, use TLS
        if (this.nodePort === "50212") {
            const certificate = Buffer.from(await this._retrieveCertificate());

            security = credentials.createSsl(certificate);
        } else {
            security = credentials.createInsecure();
        }

        this._client = new Client(this.address, security, options);

        clientCache[this.address] = this._client;
    }

    /**
     * @override
     * @returns {void}
     */
    close() {
        if (this._client) {
            this._client.close();
            delete clientCache[this.address];
        }
    }

    /**
     * @override
     * @protected
     * @param {string} serviceName
     * @returns {import("protobufjs").RPCImpl}
     */
    _createUnaryClient(serviceName) {
        return (method, requestData, callback) => {
            this._initializeClient()
                .then(() => {
                    const deadline = new Date();
                    const milliseconds = this.maxExecutionTime
                        ? this.maxExecutionTime
                        : 10000;
                    deadline.setMilliseconds(
                        deadline.getMilliseconds() + milliseconds,
                    );

                    this._client?.waitForReady(deadline, (err) => {
                        if (err) {
                            callback(
                                new GrpcServicesError(
                                    GrpcStatus.Timeout,
                                    // Added colons to the IP address to resolve a SonarCloud IP issue.
                                    ALL_NETWORK_IPS[`${this.nodeIp}:`],
                                ),
                            );
                        } else {
                            this._client?.makeUnaryRequest(
                                `/proto.${serviceName}/${method.name}`,
                                (value) => value,
                                (value) => value,
                                Buffer.from(requestData),
                                (e, r) => {
                                    callback(e, r);
                                },
                            );
                        }
                    });
                })
                .catch((err) => {
                    if (err instanceof Error) {
                        callback(err);
                    } else {
                        callback(new Error("An unexpected error occurred"));
                    }
                });
        };
    }
}
// Filename: src/channel/NodeMirrorChannel.js
// SPDX-License-Identifier: Apache-2.0

import * as grpc from "@grpc/grpc-js";
import MirrorChannel from "./MirrorChannel.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("./MirrorChannel.js").MirrorError} MirrorError
 */

/**
 * @internal
 */
export default class NodeMirrorChannel extends MirrorChannel {
    /**
     * @internal
     * @param {string} address
     */
    constructor(address) {
        super();

        /**
         * @type {grpc.Client}
         * @private
         */
        this._client = new grpc.Client(
            address,
            address.endsWith(":50212") || address.endsWith(":443")
                ? grpc.credentials.createSsl()
                : grpc.credentials.createInsecure(),
            {
                "grpc.keepalive_time_ms": 90000,
                "grpc.keepalive_timeout_ms": 5000,
            },
        );
    }

    /**
     * @override
     * @returns {void}
     */
    close() {
        this._client.close();
    }

    /**
     * @override
     * @internal
     * @param {string} serviceName
     * @param {string} methodName
     * @param {Uint8Array} requestData
     * @param {(data: Uint8Array) => void} callback
     * @param {(error: MirrorError | Error) => void} error
     * @param {() => void} end
     * @returns {() => void}
     */
    makeServerStreamRequest(
        serviceName,
        methodName,
        requestData,
        callback,
        error,
        end,
    ) {
        const stream = this._client
            .makeServerStreamRequest(
                `/com.hedera.mirror.api.proto.${serviceName}/${methodName}`,
                (value) => value,
                (value) => value,
                Buffer.from(requestData),
            )
            .on("data", (/** @type {Uint8Array} */ data) => {
                callback(data);
            })
            .on("status", (/** @type {grpc.StatusObject} */ status) => {
                if (status.code == 0) {
                    end();
                } else {
                    error(status);
                }
            })
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            .on("error", (/** @type {grpc.StatusObject} */ err) => {
                error(err);
            });

        return () => {
            stream.cancel();
        };
    }
}
// Filename: src/channel/WebChannel.js
// SPDX-License-Identifier: Apache-2.0

import { ALL_WEB_NETWORK_NODES } from "../constants/ClientConstants.js";
import GrpcServiceError from "../grpc/GrpcServiceError.js";
import GrpcStatus from "../grpc/GrpcStatus.js";
import HttpError from "../http/HttpError.js";
import HttpStatus from "../http/HttpStatus.js";
import Channel, { encodeRequest, decodeUnaryResponse } from "./Channel.js";

export default class WebChannel extends Channel {
    /**
     * @param {string} address
     */
    constructor(address) {
        super();

        /**
         * @type {string}
         * @private
         */
        this._address = address;
    }

    /**
     * @override
     * @returns {void}
     */
    close() {
        // do nothing
    }

    /**
     * @override
     * @protected
     * @param {string} serviceName
     * @returns {import("protobufjs").RPCImpl}
     */
    _createUnaryClient(serviceName) {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        return async (method, requestData, callback) => {
            try {
                // this will be executed in a browser environment so eslint is
                // disabled for the fetch call
                //eslint-disable-next-line n/no-unsupported-features/node-builtins
                const response = await fetch(
                    `${this._address}/proto.${serviceName}/${method.name}`,
                    {
                        method: "POST",
                        headers: {
                            "content-type": "application/grpc-web+proto",
                            "x-user-agent": "hedera-sdk-js/v2",
                            "x-grpc-web": "1",
                        },
                        body: encodeRequest(requestData),
                    },
                );

                if (!response.ok) {
                    const error = new HttpError(
                        HttpStatus._fromValue(response.status),
                    );
                    callback(error, null);
                }

                // Check headers for gRPC errors
                const grpcStatus = response.headers.get("grpc-status");
                const grpcMessage = response.headers.get("grpc-message");

                if (grpcStatus != null && grpcMessage != null) {
                    const error = new GrpcServiceError(
                        GrpcStatus._fromValue(parseInt(grpcStatus)),
                        ALL_WEB_NETWORK_NODES[this._address].toString(),
                    );
                    error.message = grpcMessage;
                    callback(error, null);
                }

                const responseBuffer = await response.arrayBuffer();
                const unaryResponse = decodeUnaryResponse(responseBuffer);

                callback(null, unaryResponse);
            } catch (error) {
                const err = new GrpcServiceError(
                    // retry on grpc web errors
                    GrpcStatus._fromValue(18),
                    ALL_WEB_NETWORK_NODES[this._address].toString(),
                );
                callback(err, null);
            }
        };
    }
}
// Filename: src/client/Client.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import AccountBalanceQuery from "../account/AccountBalanceQuery.js";
import Hbar from "../Hbar.js";
import Network from "./Network.js";
import MirrorNetwork from "./MirrorNetwork.js";
import PublicKey from "../PublicKey.js";
import PrivateKey from "../PrivateKey.js";
import LedgerId from "../LedgerId.js";
import FileId from "../file/FileId.js";
import CACHE from "../Cache.js";
import Logger from "../logger/Logger.js"; // eslint-disable-line
import { convertToNumber } from "../util.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
 */

/**
 * @typedef {object} Operator
 * @property {string | PrivateKey} privateKey
 * @property {string | AccountId} accountId
 */

/**
 * @typedef {object} ClientOperator
 * @property {PublicKey} publicKey
 * @property {AccountId} accountId
 * @property {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
 */

/**
 * @typedef {object} ClientConfiguration
 * @property {{[key: string]: (string | AccountId)} | string} network
 * @property {string[] | string} [mirrorNetwork]
 * @property {Operator} [operator]
 * @property {boolean} [scheduleNetworkUpdate]
 */

/**
 * @typedef {"mainnet" | "testnet" | "previewnet"} NetworkName
 */

/**
 * The `Client` class is the main entry point for interacting with the Hedera Hashgraph network.
 * It provides methods for managing network connections, setting operators, handling transactions
 * and queries, and configuring various client settings.
 *
 * @abstract
 * @template {Channel} ChannelT
 * @template {MirrorChannel} MirrorChannelT
 */
export default class Client {
    /**
     * @protected
     * @hideconstructor
     * @param {ClientConfiguration} [props]
     */
    constructor(props) {
        /**
         * List of mirror network URLs.
         *
         * @internal
         * @type {MirrorNetwork}
         */
        this._mirrorNetwork = new MirrorNetwork(
            this._createMirrorNetworkChannel(),
        );

        /**
         * Map of node account ID (as a string)
         * to the node URL.
         *
         * @internal
         * @type {Network}
         */
        this._network = new Network(this._createNetworkChannel());

        /**
         * @internal
         * @type {?ClientOperator}
         */
        this._operator = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._defaultMaxTransactionFee = null;

        /**
         * @private
         * @type {Hbar}
         */
        this._defaultMaxQueryPayment = new Hbar(1);

        if (props != null) {
            if (props.operator != null) {
                this.setOperator(
                    props.operator.accountId,
                    props.operator.privateKey,
                );
            }
        }

        /** @type {number | null} */
        this._maxAttempts = null;

        /** @private */
        this._signOnDemand = false;

        /** @private */
        this._autoValidateChecksums = false;

        /** @private */
        this._minBackoff = 250;

        /** @private */
        this._maxBackoff = 8000;

        /** @private */
        this._defaultRegenerateTransactionId = true;

        /** @private */
        this._requestTimeout = null;

        /** @private */
        this._networkUpdatePeriod = 24 * 60 * 60 * 1000;

        /** @private */
        this._isShutdown = false;

        if (props != null && props.scheduleNetworkUpdate !== false) {
            this._scheduleNetworkUpdate();
        }

        /** @internal */
        /** @type {NodeJS.Timeout} */
        this._timer;

        /**
         * Logger
         *
         * @external
         * @type {Logger | null}
         */
        this._logger = null;
    }

    /**
     * @deprecated
     * @param {NetworkName} networkName
     * @returns {this}
     */
    setNetworkName(networkName) {
        // uses custom NetworkName type
        // remove if phasing out set|get NetworkName
        console.warn("Deprecated: Use `setLedgerId` instead");
        return this.setLedgerId(networkName);
    }

    /**
     * @deprecated
     * @returns {string | null}
     */
    get networkName() {
        console.warn("Deprecated: Use `ledgerId` instead");
        return this.ledgerId != null ? this.ledgerId.toString() : null;
    }

    /**
     * @param {string|LedgerId} ledgerId
     * @returns {this}
     */
    setLedgerId(ledgerId) {
        this._network.setLedgerId(
            typeof ledgerId === "string"
                ? LedgerId.fromString(ledgerId)
                : ledgerId,
        );

        return this;
    }

    /**
     * @returns {LedgerId | null}
     */
    get ledgerId() {
        return this._network._ledgerId != null ? this._network.ledgerId : null;
    }

    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setNetwork(network) {
        // TODO: This logic _can_ be de-duplicated and likely should
        throw new Error("not implemented");
    }

    /**
     * @param {NodeAddressBook} addressBook
     * @returns {this}
     */
    setNetworkFromAddressBook(addressBook) {
        this._network.setNetworkFromAddressBook(addressBook);
        return this;
    }

    /**
     * @returns {{[key: string]: (string | AccountId)}}
     */
    get network() {
        return this._network.network;
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMirrorNetwork(mirrorNetwork) {
        throw new Error("not implemented");
    }

    /**
     * @returns {string[]}
     */
    get mirrorNetwork() {
        return this._mirrorNetwork.network;
    }

    /**
     * @returns {boolean}
     */
    get signOnDemand() {
        return this._signOnDemand;
    }

    /**
     * @param {boolean} signOnDemand
     */
    setSignOnDemand(signOnDemand) {
        this._signOnDemand = signOnDemand;
    }

    /**
     * @returns {boolean}
     */
    isTransportSecurity() {
        return this._network.isTransportSecurity();
    }

    /**
     * @param {boolean} transportSecurity
     * @returns {this}
     */
    setTransportSecurity(transportSecurity) {
        this._network.setTransportSecurity(transportSecurity);
        return this;
    }

    /**
     * Set the account that will, by default, pay for transactions and queries built with this client.
     * NOTE: When using string for private key, the string needs to contain DER headers
     *
     * @param {AccountId | string} accountId
     * @param {PrivateKey | string} privateKey
     * @returns {this}
     */
    setOperator(accountId, privateKey) {
        const key =
            typeof privateKey === "string"
                ? PrivateKey.fromStringDer(privateKey)
                : privateKey;

        return this.setOperatorWith(accountId, key.publicKey, (message) =>
            Promise.resolve(key.sign(message)),
        );
    }

    /**
     * @returns {?ClientOperator}
     */
    getOperator() {
        return this._operator;
    }

    /**
     * Sets the account that will, by default, pay for transactions and queries built with
     * this client.
     *
     * @param {AccountId | string} accountId
     * @param {PublicKey | string} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    setOperatorWith(accountId, publicKey, transactionSigner) {
        const accountId_ =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);

        if (this._network._ledgerId != null) {
            accountId_.validateChecksum(this);
        }

        this._operator = {
            transactionSigner,

            accountId: accountId_,

            publicKey:
                publicKey instanceof PublicKey
                    ? publicKey
                    : PublicKey.fromString(publicKey),
        };

        return this;
    }

    /**
     * @param {boolean} value
     * @returns {this}
     */
    setAutoValidateChecksums(value) {
        this._autoValidateChecksums = value;
        return this;
    }

    /**
     * @returns {boolean}
     */
    isAutoValidateChecksumsEnabled() {
        return this._autoValidateChecksums;
    }

    /**
     * @returns {?AccountId}
     */
    get operatorAccountId() {
        return this._operator != null ? this._operator.accountId : null;
    }

    /**
     * @returns {?PublicKey}
     */
    get operatorPublicKey() {
        return this._operator != null ? this._operator.publicKey : null;
    }

    /**
     * @returns {?Hbar}
     */
    get defaultMaxTransactionFee() {
        return this._defaultMaxTransactionFee;
    }

    /**
     * @deprecated - Use `defaultMaxTransactionFee` instead
     * @returns {?Hbar}
     */
    get maxTransactionFee() {
        return this.defaultMaxTransactionFee;
    }

    /**
     * Set the defaultimum fee to be paid for transactions
     * executed by this client.
     *
     * @param {Hbar} defaultMaxTransactionFee
     * @returns {this}
     */
    setDefaultMaxTransactionFee(defaultMaxTransactionFee) {
        if (defaultMaxTransactionFee.toTinybars().toInt() < 0) {
            throw new Error("defaultMaxTransactionFee must be non-negative");
        }
        this._defaultMaxTransactionFee = defaultMaxTransactionFee;
        return this;
    }

    /**
     * @deprecated - Use `setDefaultMaxTransactionFee()` instead
     * Set the maximum fee to be paid for transactions
     * executed by this client.
     * @param {Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee) {
        return this.setDefaultMaxTransactionFee(maxTransactionFee);
    }

    /**
     * @returns {boolean}
     */
    get defaultRegenerateTransactionId() {
        return this._defaultRegenerateTransactionId;
    }

    /**
     * Set if a new transaction ID should be generated when a `TRANSACTION_EXPIRED` status
     * is returned.
     *
     * @param {boolean} defaultRegenerateTransactionId
     * @returns {this}
     */
    setDefaultRegenerateTransactionId(defaultRegenerateTransactionId) {
        this._defaultRegenerateTransactionId = defaultRegenerateTransactionId;
        return this;
    }

    /**
     * @returns {Hbar}
     */
    get defaultMaxQueryPayment() {
        return this._defaultMaxQueryPayment;
    }

    /**
     * @deprecated in a favor of defaultMaxQueryPayment
     * @returns {Hbar}
     */
    get maxQueryPayment() {
        return this.defaultMaxQueryPayment;
    }

    /**
     * Set the maximum payment allowable for queries.
     *
     * @param {Hbar} defaultMaxQueryPayment
     * @returns {Client<ChannelT, MirrorChannelT>}
     */
    setDefaultMaxQueryPayment(defaultMaxQueryPayment) {
        const isMaxQueryPaymentNegative =
            convertToNumber(defaultMaxQueryPayment.toTinybars()) < 0;
        if (isMaxQueryPaymentNegative) {
            throw new Error("defaultMaxQueryPayment must be non-negative");
        }
        this._defaultMaxQueryPayment = defaultMaxQueryPayment;
        return this;
    }
    /**
     * @deprecated in a favor of setDefaultMaxQueryPayment()
     * Set the maximum payment allowable for queries.
     * @param {Hbar} maxQueryPayment
     * @returns {Client<ChannelT, MirrorChannelT>}
     */
    setMaxQueryPayment(maxQueryPayment) {
        return this.setDefaultMaxQueryPayment(maxQueryPayment);
    }

    /**
     * @returns {number}
     */
    get maxAttempts() {
        return this._maxAttempts != null ? this._maxAttempts : 10;
    }

    /**
     * @param {number} maxAttempts
     * @returns {this}
     */
    setMaxAttempts(maxAttempts) {
        this._maxAttempts = maxAttempts;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodeAttempts() {
        return this._network.maxNodeAttempts;
    }

    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts) {
        this._network.setMaxNodeAttempts(maxNodeAttempts);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeWaitTime() {
        return this._network.minBackoff;
    }

    /**
     * @param {number} nodeWaitTime
     * @returns {this}
     */
    setNodeWaitTime(nodeWaitTime) {
        this._network.setMinBackoff(nodeWaitTime);
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodesPerTransaction() {
        return this._network.maxNodesPerTransaction;
    }

    /**
     * @param {number} maxNodesPerTransaction
     * @returns {this}
     */
    setMaxNodesPerTransaction(maxNodesPerTransaction) {
        this._network.setMaxNodesPerTransaction(maxNodesPerTransaction);
        return this;
    }

    /**
     * @param {?number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        if (minBackoff == null) {
            throw new Error("minBackoff cannot be null.");
        }
        if (minBackoff > this._maxBackoff) {
            throw new Error("minBackoff cannot be larger than maxBackoff.");
        }
        this._minBackoff = minBackoff;
        return this;
    }

    /**
     * @returns {number}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {?number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        if (maxBackoff == null) {
            throw new Error("maxBackoff cannot be null.");
        } else if (maxBackoff < this._minBackoff) {
            throw new Error("maxBackoff cannot be smaller than minBackoff.");
        }
        this._maxBackoff = maxBackoff;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @param {number} nodeMinBackoff
     * @returns {this}
     */
    setNodeMinBackoff(nodeMinBackoff) {
        this._network.setMinBackoff(nodeMinBackoff);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMinBackoff() {
        return this._network.minBackoff;
    }

    /**
     * @param {number} nodeMaxBackoff
     * @returns {this}
     */
    setNodeMaxBackoff(nodeMaxBackoff) {
        this._network.setMaxBackoff(nodeMaxBackoff);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMaxBackoff() {
        return this._network.maxBackoff;
    }

    /**
     * @param {number} nodeMinReadmitPeriod
     * @returns {this}
     */
    setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {
        this._network.setNodeMinReadmitPeriod(nodeMinReadmitPeriod);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMinReadmitPeriod() {
        return this._network.nodeMinReadmitPeriod;
    }

    /**
     * @param {number} nodeMaxReadmitPeriod
     * @returns {this}
     */
    setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {
        this._network.setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod);
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMaxReadmitPeriod() {
        return this._network.nodeMaxReadmitPeriod;
    }

    /**
     * @param {number} requestTimeout - Number of milliseconds
     * @returns {this}
     */
    setRequestTimeout(requestTimeout) {
        this._requestTimeout = requestTimeout;
        return this;
    }

    /**
     * @returns {?number}
     */
    get requestTimeout() {
        return this._requestTimeout;
    }

    /**
     * @returns {number}
     */
    get networkUpdatePeriod() {
        return this._networkUpdatePeriod;
    }

    /**
     * @param {number} networkUpdatePeriod
     * @returns {this}
     */
    setNetworkUpdatePeriod(networkUpdatePeriod) {
        clearTimeout(this._timer);
        this._networkUpdatePeriod = networkUpdatePeriod;
        this._scheduleNetworkUpdate();
        return this;
    }
    /**
     * Set logger
     *
     * @param {Logger} logger
     * @returns {this}
     */
    setLogger(logger) {
        this._logger = logger;
        return this;
    }

    /**
     * Get logger if set
     *
     * @returns {?Logger}
     */
    get logger() {
        return this._logger;
    }

    /**
     * @param {AccountId | string} accountId
     */
    async ping(accountId) {
        await new AccountBalanceQuery({ accountId })
            .setNodeAccountIds([
                accountId instanceof AccountId
                    ? accountId
                    : AccountId.fromString(accountId),
            ])
            .execute(this);
    }

    async pingAll() {
        for (const nodeAccountId of Object.values(this._network.network)) {
            await this.ping(nodeAccountId);
        }
    }

    /**
     * @returns {void}
     */
    close() {
        this._network.close();
        this._mirrorNetwork.close();
        this._isShutdown = true;
        clearTimeout(this._timer);
    }

    /**
     * @abstract
     * @returns {(address: string) => ChannelT}
     */
    _createNetworkChannel() {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @returns {(address: string) => MirrorChannelT}
     */
    _createMirrorNetworkChannel() {
        throw new Error("not implemented");
    }

    /**
     * @private
     */
    _scheduleNetworkUpdate() {
        // This is the automatic network update promise that _eventually_ completes
        // eslint-disable-next-line @typescript-eslint/no-floating-promises,@typescript-eslint/no-misused-promises
        this._timer = setTimeout(async () => {
            try {
                const addressBook = await CACHE.addressBookQueryConstructor()
                    .setFileId(FileId.ADDRESS_BOOK)
                    .execute(this);
                this.setNetworkFromAddressBook(addressBook);

                if (!this._isShutdown) {
                    // Recall this method to continuously update the network
                    // every `networkUpdatePeriod` amount of itme
                    this._scheduleNetworkUpdate();
                }
            } catch (error) {
                if (this._logger) {
                    this._logger.trace(
                        `failed to update client address book: ${
                            /** @type {Error} */ (error).toString()
                        }`,
                    );
                }
            }
        }, this._networkUpdatePeriod);
    }

    /**
     * @returns {boolean}
     */
    get isClientShutDown() {
        return this._isShutdown;
    }
}
// Filename: src/client/ManagedNetwork.js
// SPDX-License-Identifier: Apache-2.0

import LedgerId from "../LedgerId.js";
import * as util from "../util.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../Node.js").default} Node
 * @typedef {import("../MirrorNode.js").default} MirrorNode
 * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @typedef {import("../ManagedNode.js").default<ChannelT>} ManagedNode
 */

/**
 * @template {Channel | MirrorChannel} ChannelT
 * @template {ManagedNode<ChannelT>} NetworkNodeT
 * @template {{ toString: () => string }} KeyT
 */
export default class ManagedNetwork {
    /**
     * @param {(address: string) => ChannelT} createNetworkChannel
     */
    constructor(createNetworkChannel) {
        /**
         * Map of node account ID (as a string)
         * to the node URL.
         *
         * @internal
         * @type {Map<string, NetworkNodeT[]>}
         */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this._network = new Map();

        /**
         * List of node account IDs.
         *
         * @protected
         * @type {NetworkNodeT[]}
         */
        this._nodes = [];

        /**
         * List of node account IDs.
         *
         * @protected
         * @type {NetworkNodeT[]}
         */
        this._healthyNodes = [];

        /** @type {(address: string, cert?: string) => ChannelT} */
        this._createNetworkChannel = createNetworkChannel;

        /** @type {LedgerId | null} */
        this._ledgerId = null;

        this._minBackoff = 8000;
        this._maxBackoff = 1000 * 60 * 60;

        /** @type {number} */
        this._maxNodeAttempts = -1;

        this._nodeMinReadmitPeriod = this._minBackoff;
        this._nodeMaxReadmitPeriod = this._maxBackoff;

        this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
    }

    /**
     * @deprecated
     * @param {string} networkName
     * @returns {this}
     */
    setNetworkName(networkName) {
        console.warn("Deprecated: Use `setLedgerId` instead");
        return this.setLedgerId(networkName);
    }

    /**
     * @deprecated
     * @returns {string | null}
     */
    get networkName() {
        console.warn("Deprecated: Use `ledgerId` instead");
        return this.ledgerId != null ? this.ledgerId.toString() : null;
    }

    /**
     * @param {string|LedgerId} ledgerId
     * @returns {this}
     */
    setLedgerId(ledgerId) {
        this._ledgerId =
            typeof ledgerId === "string"
                ? LedgerId.fromString(ledgerId)
                : ledgerId;
        return this;
    }

    /**
     * @returns {LedgerId | null}
     */
    get ledgerId() {
        return this._ledgerId != null ? this._ledgerId : null;
    }

    /**
     * @abstract
     * @param {[string, KeyT]} entry
     * @returns {NetworkNodeT}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _createNodeFromNetworkEntry(entry) {
        throw new Error("not implemented");
    }

    /**
     * @abstract
     * @param {Map<string, KeyT>} network
     * @returns {number[]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _getNodesToRemove(network) {
        throw new Error("not implemented");
    }

    _removeDeadNodes() {
        if (this._maxNodeAttempts > 0) {
            for (let i = this._nodes.length - 1; i >= 0; i--) {
                const node = this._nodes[i];

                if (node._badGrpcStatusCount < this._maxNodeAttempts) {
                    continue;
                }

                this._closeNode(i);
            }
        }
    }

    _readmitNodes() {
        const now = Date.now();

        if (this._earliestReadmitTime <= now) {
            let nextEarliestReadmitTime = Number.MAX_SAFE_INTEGER;
            let searchForNextEarliestReadmitTime = true;

            outer: for (let i = 0; i < this._nodes.length; i++) {
                for (let j = 0; j < this._healthyNodes.length; j++) {
                    if (
                        searchForNextEarliestReadmitTime &&
                        this._nodes[i]._readmitTime > now
                    ) {
                        nextEarliestReadmitTime = Math.min(
                            this._nodes[i]._readmitTime,
                            nextEarliestReadmitTime,
                        );
                    }

                    if (this._nodes[i] == this._healthyNodes[j]) {
                        continue outer;
                    }
                }

                searchForNextEarliestReadmitTime = false;

                if (this._nodes[i]._readmitTime <= now) {
                    this._healthyNodes.push(this._nodes[i]);
                }
            }

            this._earliestReadmitTime = Math.min(
                Math.max(nextEarliestReadmitTime, this._nodeMinReadmitPeriod),
                this._nodeMaxReadmitPeriod,
            );
        }
    }

    /**
     * @param {number} count
     * @returns {NetworkNodeT[]}
     */
    _getNumberOfMostHealthyNodes(count) {
        this._removeDeadNodes();
        this._readmitNodes();

        const nodes = [];
        // Create a shallow for safe iteration
        let healthyNodes = this._healthyNodes.slice();
        count = Math.min(count, healthyNodes.length);

        for (let i = 0; i < count; i++) {
            // Select a random index
            const nodeIndex = Math.floor(Math.random() * healthyNodes.length);
            const selectedNode = healthyNodes[nodeIndex];

            // Check if the node exists
            if (!selectedNode) {
                break; // Break out of the loop if undefined node is selected
            }

            // Add the selected node in array for execution
            nodes.push(selectedNode);
            // Remove all nodes with the same account id as
            // the selected node account id from the array
            healthyNodes = healthyNodes.filter(
                // eslint-disable-next-line ie11/no-loop-func
                (node) => node.getKey() !== selectedNode.getKey(),
            );
        }

        return nodes;
    }

    /**
     * @param {number} i
     */
    _closeNode(i) {
        const node = this._nodes[i];

        node.close();
        this._removeNodeFromNetwork(node);
        this._nodes.splice(i, 1);
    }

    /**
     * @param {NetworkNodeT} node
     */
    _removeNodeFromNetwork(node) {
        const network = /** @type {NetworkNodeT[]} */ (
            this._network.get(node.getKey())
        );

        for (let j = 0; j < network.length; j++) {
            if (network[j] === node) {
                network.splice(j, 1);
                break;
            }
        }

        if (network.length === 0) {
            this._network.delete(node.getKey());
        }
    }

    /**
     * @param {Map<string, KeyT>} network
     * @returns {this}
     */
    _setNetwork(network) {
        /** @type {NetworkNodeT[]} */
        const newNodes = [];
        const newNodeKeys = new Set();
        const newNodeAddresses = new Set();

        /** @type {NetworkNodeT[]} */
        const newHealthyNodes = [];

        /** @type {Map<string, NetworkNodeT[]>} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const newNetwork = new Map();

        // Remove nodes that are not in the new network
        for (const i of this._getNodesToRemove(network)) {
            this._closeNode(i);
        }

        // Copy all the unclosed nodes
        for (const node of this._nodes) {
            newNodes.push(node);
            newNodeKeys.add(node.getKey());
            newNodeAddresses.add(node.address.toString());
        }

        // Add new nodes
        for (const [key, value] of network) {
            if (
                newNodeKeys.has(value.toString()) &&
                newNodeAddresses.has(key)
            ) {
                continue;
            }
            newNodes.push(this._createNodeFromNetworkEntry([key, value]));
        }

        // Shuffle the nodes so we don't immediately pick the first nodes
        util.shuffle(newNodes);

        // Copy all the nodes into the healhty nodes list initially
        // and push the nodes into the network; this maintains the
        // shuffled state from `newNodes`
        for (const node of newNodes) {
            if (!node.isHealthy()) {
                continue;
            }

            newHealthyNodes.push(node);

            const newNetworkNodes = newNetwork.has(node.getKey())
                ? /** @type {NetworkNodeT[]} */ (newNetwork.get(node.getKey()))
                : [];
            newNetworkNodes.push(node);
            newNetwork.set(node.getKey(), newNetworkNodes);
        }

        // console.log(JSON.stringify(newNodes, null, 2));
        this._nodes = newNodes;
        this._healthyNodes = newHealthyNodes;
        this._network = newNetwork;
        this._ledgerId = null;

        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodeAttempts() {
        return this._maxNodeAttempts;
    }

    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts) {
        this._maxNodeAttempts = maxNodeAttempts;
        return this;
    }

    /**
     * @returns {number}
     */
    get minBackoff() {
        return this._minBackoff;
    }

    /**
     * @param {number} minBackoff
     * @returns {this}
     */
    setMinBackoff(minBackoff) {
        this._minBackoff = minBackoff;
        for (const node of this._nodes) {
            node.setMinBackoff(minBackoff);
        }
        return this;
    }

    /**
     * @returns {number}
     */
    get maxBackoff() {
        return this._maxBackoff;
    }

    /**
     * @param {number} maxBackoff
     * @returns {this}
     */
    setMaxBackoff(maxBackoff) {
        this._maxBackoff = maxBackoff;
        for (const node of this._nodes) {
            node.setMaxBackoff(maxBackoff);
        }
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMinReadmitPeriod() {
        return this._nodeMinReadmitPeriod;
    }

    /**
     * @param {number} nodeMinReadmitPeriod
     * @returns {this}
     */
    setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {
        this._nodeMinReadmitPeriod = nodeMinReadmitPeriod;
        this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
        return this;
    }

    /**
     * @returns {number}
     */
    get nodeMaxReadmitPeriod() {
        return this._nodeMaxReadmitPeriod;
    }

    /**
     * @param {number} nodeMaxReadmitPeriod
     * @returns {this}
     */
    setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {
        this._nodeMaxReadmitPeriod = nodeMaxReadmitPeriod;
        return this;
    }

    /**
     * @param {KeyT=} key
     * @returns {NetworkNodeT}
     */
    getNode(key) {
        this._readmitNodes();
        if (key != null && key != undefined) {
            const lockedNodes = this._network.get(key.toString());
            if (lockedNodes) {
                const randomNodeAddress = Math.floor(
                    Math.random() * lockedNodes.length,
                );
                return /** @type {NetworkNodeT[]} */ (lockedNodes)[
                    randomNodeAddress
                ];
            } else {
                const nodes = Array.from(this._network.keys());
                const randomNodeAccountId =
                    nodes[Math.floor(Math.random() * nodes.length)];

                const randomNode = this._network.get(randomNodeAccountId);
                // We get the `randomNodeAccountId` from the network mapping,
                // so it cannot be `undefined`
                const randomNodeAddress = Math.floor(
                    // @ts-ignore
                    Math.random() * randomNode.length,
                );
                // @ts-ignore
                return randomNode[randomNodeAddress];
            }
        } else {
            if (this._healthyNodes.length == 0) {
                throw new Error("failed to find a healthy working node");
            }

            return this._healthyNodes[
                Math.floor(Math.random() * this._healthyNodes.length)
            ];
        }
    }

    /**
     * @param {NetworkNodeT} node
     */
    increaseBackoff(node) {
        node.increaseBackoff();

        for (let i = 0; i < this._healthyNodes.length; i++) {
            if (this._healthyNodes[i] == node) {
                this._healthyNodes.splice(i, 1);
            }
        }
    }

    /**
     * @param {NetworkNodeT} node
     */
    decreaseBackoff(node) {
        node.decreaseBackoff();
    }

    close() {
        for (const node of this._nodes) {
            node.close();
        }

        this._network.clear();
        this._nodes = [];
    }
}
// Filename: src/client/MirrorNetwork.js
// SPDX-License-Identifier: Apache-2.0

import MirrorNode from "../MirrorNode.js";
import ManagedNetwork from "./ManagedNetwork.js";

/**
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @augments {ManagedNetwork<MirrorChannel, MirrorNode, string>}
 */
export default class MirrorNetwork extends ManagedNetwork {
    /**
     * @param {(address: string) => MirrorChannel} channelInitFunction
     */
    constructor(channelInitFunction) {
        super(channelInitFunction);
    }

    /**
     * @param {string[]} network
     */
    setNetwork(network) {
        // eslint-disable-next-line ie11/no-collection-args
        this._setNetwork(new Map(network.map((address) => [address, address])));
    }

    /**
     * @returns {string[]}
     */
    get network() {
        /**
         * @type {string[]}
         */
        var n = [];

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const node of this._nodes) {
            n.push(node.address.toString());
        }

        return n;
    }

    /**
     * @abstract
     * @param {[string, string]} entry
     * @returns {MirrorNode}
     */
    _createNodeFromNetworkEntry(entry) {
        return new MirrorNode({
            newNode: {
                address: entry[1],
                channelInitFunction: this._createNetworkChannel,
            },
        }).setMinBackoff(this._minBackoff);
    }

    /**
     * @abstract
     * @param {Map<string, string>} network
     * @returns {number[]}
     */
    _getNodesToRemove(network) {
        const indexes = [];

        const values = Object.values(network);

        for (let i = this._nodes.length - 1; i >= 0; i--) {
            const node = this._nodes[i];

            if (!values.includes(node.address.toString())) {
                indexes.push(i);
            }
        }

        return indexes;
    }

    /**
     * @returns {MirrorNode}
     */
    getNextMirrorNode() {
        if (this._createNetworkChannel == null) {
            throw new Error("mirror network not supported on browser");
        }

        return this._getNumberOfMostHealthyNodes(1)[0];
    }
}
// Filename: src/client/NativeClient.js
// SPDX-License-Identifier: Apache-2.0

import Client from "./Client.js";
import NativeChannel from "../channel/NativeChannel.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import AccountId from "../account/AccountId.js";
import LedgerId from "../LedgerId.js";
import {
    MAINNET,
    NATIVE_TESTNET,
    NATIVE_PREVIEWNET,
} from "../constants/ClientConstants.js";

/**
 * @typedef {import("./Client.js").ClientConfiguration} ClientConfiguration
 */
export const Network = {
    /**
     * @param {string} name
     * @returns {{[key: string]: (string | AccountId)}}
     */
    fromName(name) {
        switch (name) {
            case "mainnet":
                return Network.MAINNET;

            case "testnet":
                return Network.TESTNET;

            case "previewnet":
                return Network.PREVIEWNET;

            default:
                throw new Error(`unknown network name: ${name}`);
        }
    },

    MAINNET: MAINNET,
    TESTNET: NATIVE_TESTNET,
    PREVIEWNET: NATIVE_PREVIEWNET,
};

/**
 * @augments {Client<NativeChannel, *>}
 */
export default class NativeClient extends Client {
    /**
     * @param {ClientConfiguration} [props]
     */
    constructor(props) {
        super(props);

        if (props != null) {
            if (typeof props.network === "string") {
                switch (props.network) {
                    case "mainnet":
                        this.setNetwork(Network.MAINNET);
                        this.setLedgerId(LedgerId.MAINNET);
                        break;

                    case "testnet":
                        this.setNetwork(Network.TESTNET);
                        this.setLedgerId(LedgerId.TESTNET);
                        break;

                    case "previewnet":
                        this.setNetwork(Network.PREVIEWNET);
                        this.setLedgerId(LedgerId.PREVIEWNET);
                        break;

                    default:
                        throw new Error(
                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                            `unknown network: ${props.network}`,
                        );
                }
            } else if (props.network != null) {
                this.setNetwork(props.network);
            }
        }
    }

    /**
     * @param {string | ClientConfiguration} data
     * @returns {NativeClient}
     */
    static fromConfig(data) {
        return new NativeClient(
            typeof data === "string"
                ? /** @type {ClientConfiguration | undefined} */ (
                      JSON.parse(data)
                  )
                : data,
        );
    }

    /**
     * Construct a client for a specific network.
     *
     * It is the responsibility of the caller to ensure that all nodes in the map are part of the
     * same Hedera network. Failure to do so will result in undefined behavior.
     *
     * The client will load balance all requests to Hedera using a simple round-robin scheme to
     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
     * tried.
     *
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {NativeClient}
     */
    static forNetwork(network) {
        return new NativeClient({ network, scheduleNetworkUpdate: false });
    }

    /**
     * @param {string} network
     * @returns {NativeClient}
     */
    static forName(network) {
        return new NativeClient({ network, scheduleNetworkUpdate: false });
    }

    /**
     * Construct a Hedera client pre-configured for Mainnet access.
     *
     * @returns {NativeClient}
     */
    static forMainnet() {
        return new NativeClient({
            network: "mainnet",
            scheduleNetworkUpdate: false,
        });
    }

    /**
     * Construct a Hedera client pre-configured for Testnet access.
     *
     * @returns {NativeClient}
     */
    static forTestnet() {
        return new NativeClient({
            network: "testnet",
            scheduleNetworkUpdate: false,
        });
    }

    /**
     * Construct a Hedera client pre-configured for Previewnet access.
     *
     * @returns {NativeClient}
     */
    static forPreviewnet() {
        return new NativeClient({
            network: "previewnet",
            scheduleNetworkUpdate: false,
        });
    }

    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    setNetwork(network) {
        if (typeof network === "string") {
            switch (network) {
                case "previewnet":
                    this._network.setNetwork(Network.PREVIEWNET);
                    break;
                case "testnet":
                    this._network.setNetwork(Network.TESTNET);
                    break;
                case "mainnet":
                    this._network.setNetwork(Network.MAINNET);
            }
        } else {
            this._network.setNetwork(network);
        }
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMirrorNetwork(mirrorNetwork) {
        // Do nothing as this is not currently supported
    }

    /**
     * @override
     * @returns {(address: string) => NativeChannel}
     */
    _createNetworkChannel() {
        return (address) => new NativeChannel(address);
    }

    /**
     * @abstract
     * @returns {(address: string) => *}
     */
    _createMirrorNetworkChannel() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        return (address) => null;
    }
}
// Filename: src/client/Network.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import Node from "../Node.js";
import {
    PREVIEWNET_ADDRESS_BOOK,
    TESTNET_ADDRESS_BOOK,
    MAINNET_ADDRESS_BOOK,
} from "../address_book/AddressBooks.js";
import ManagedNetwork from "./ManagedNetwork.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../address_book/NodeAddressBook.js").default} NodeAddressBook
 */

/**
 * @augments {ManagedNetwork<Channel, Node, AccountId>}
 */
export default class Network extends ManagedNetwork {
    /**
     * @param {(address: string) => Channel} createNetworkChannel
     */
    constructor(createNetworkChannel) {
        super(createNetworkChannel);

        this._maxNodesPerTransaction = -1;

        /** @type {NodeAddressBook | null} */
        this._addressBook = null;

        /** @type {boolean} */
        this._transportSecurity = false;
    }

    /**
     * @param {{[key: string]: (string | AccountId)}} network
     */
    setNetwork(network) {
        this._setNetwork(
            // eslint-disable-next-line ie11/no-collection-args
            new Map(
                // eslint-disable-next-line ie11/no-collection-args
                Object.entries(network).map(([key, value]) => {
                    return [
                        key,
                        typeof value === "string"
                            ? AccountId.fromString(value)
                            : value,
                    ];
                }),
            ),
        );
    }

    /**
     * @param {NodeAddressBook} addressBook
     * @returns {this}
     */
    setNetworkFromAddressBook(addressBook) {
        /** @type {Record<string, AccountId>} */
        const network = {};
        const port = this.isTransportSecurity() ? 50212 : 50211;

        for (const nodeAddress of addressBook.nodeAddresses) {
            for (const endpoint of nodeAddress.addresses) {
                // TODO: We hard code ports too much, should fix
                if (endpoint.port === port && nodeAddress.accountId != null) {
                    network[endpoint.toString()] = nodeAddress.accountId;
                }
            }
        }

        this.setNetwork(network);
        return this;
    }

    /**
     * @returns {{[key: string]: (string | AccountId)}}
     */
    get network() {
        /**
         * @type {{[key: string]: (string | AccountId)}}
         */
        var n = {};

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const node of this._nodes) {
            n[node.address.toString()] = node.accountId;
        }

        return n;
    }

    /**
     * @param {string} networkName
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setNetworkName(networkName) {
        super.setLedgerId(networkName);

        switch (networkName) {
            case "mainnet":
                this._addressBook = MAINNET_ADDRESS_BOOK;
                break;
            case "testnet":
                this._addressBook = TESTNET_ADDRESS_BOOK;
                break;
            case "previewnet":
                this._addressBook = PREVIEWNET_ADDRESS_BOOK;
                break;
        }

        if (this._addressBook != null) {
            for (const node of this._nodes) {
                for (const address of this._addressBook.nodeAddresses) {
                    if (
                        address.accountId != null &&
                        address.accountId.toString() ===
                            node.accountId.toString()
                    ) {
                        node.setNodeAddress(address);
                    }
                }
            }
        }

        return this;
    }

    /**
     * @returns {string | null}
     */
    get networkName() {
        return this._ledgerId != null ? this._ledgerId.toString() : null;
    }

    /**
     * @abstract
     * @param {[string, (string | AccountId)]} entry
     * @returns {Node}
     */
    _createNodeFromNetworkEntry(entry) {
        const accountId =
            typeof entry[1] === "string"
                ? AccountId.fromString(entry[1])
                : entry[1];

        return new Node({
            newNode: {
                address: entry[0],
                accountId,
                channelInitFunction: this._createNetworkChannel,
            },
        }).setMinBackoff(this._minBackoff);
    }

    /**
     * @abstract
     * @param {Map<string, AccountId>} network
     * @returns {number[]}
     */
    _getNodesToRemove(network) {
        const indexes = [];

        for (let i = this._nodes.length - 1; i >= 0; i--) {
            const node = this._nodes[i];
            const accountId = network.get(node.address.toString());

            if (
                accountId == null ||
                accountId.toString() !== node.accountId.toString()
            ) {
                indexes.push(i);
            }
        }

        return indexes;
    }

    /**
     * @abstract
     * @param {[string, (string | AccountId)]} entry
     * @returns {boolean}
     */
    _checkNetworkContainsEntry(entry) {
        for (const node of this._nodes) {
            if (node.address.toString() === entry[0]) {
                return true;
            }
        }

        return false;
    }

    /**
     * @returns {number}
     */
    get maxNodesPerTransaction() {
        return this._maxNodesPerTransaction;
    }

    /**
     * @param {number} maxNodesPerTransaction
     * @returns {this}
     */
    setMaxNodesPerTransaction(maxNodesPerTransaction) {
        this._maxNodesPerTransaction = maxNodesPerTransaction;
        return this;
    }

    /**
     * @returns {number}
     */
    get maxNodeAttempts() {
        return this._maxNodeAttempts;
    }

    /**
     * @param {number} maxNodeAttempts
     * @returns {this}
     */
    setMaxNodeAttempts(maxNodeAttempts) {
        this._maxNodeAttempts = maxNodeAttempts;
        return this;
    }

    /**
     * @returns {boolean}
     */
    isTransportSecurity() {
        return this._transportSecurity;
    }

    /**
     * @param {boolean} transportSecurity
     * @returns {this}
     */
    setTransportSecurity(transportSecurity) {
        if (this._transportSecurity == transportSecurity) {
            return this;
        }

        this._network.clear();

        for (let i = 0; i < this._nodes.length; i++) {
            let node = this._nodes[i];
            node.close();

            node = /** @type {Node} */ (
                transportSecurity
                    ? node
                          .toSecure()
                          .setCert(
                              this._ledgerId != null
                                  ? this._ledgerId.toString()
                                  : "",
                          )
                    : node.toInsecure()
            );
            this._nodes[i] = node;

            const nodes =
                this._network.get(node.getKey()) != null
                    ? /** @type {Node[]} */ (this._network.get(node.getKey()))
                    : [];
            nodes.push(node);
            this._network.set(node.getKey(), nodes);
        }

        // Overwrite healthy node list since new ports might make the node work again
        this._healthyNodes = [...this._nodes];

        this._transportSecurity = transportSecurity;
        return this;
    }

    /**
     * @internal
     * @returns {number}
     */
    getNumberOfNodesForTransaction() {
        if (this._maxNodesPerTransaction > 0) {
            return this._maxNodesPerTransaction;
        }
        // ultimately it does not matter if we round up or down
        // if we round up, we will eventually take one more healthy node for execution
        // and we would hit the 'nodes.length == count' check in _getNumberOfMostHealthyNodes() less often
        return this._nodes.length <= 9
            ? this._nodes.length
            : Math.floor((this._nodes.length + 3 - 1) / 3);
    }

    /**
     * @internal
     * @returns {AccountId[]}
     */
    getNodeAccountIdsForExecute() {
        return this._getNumberOfMostHealthyNodes(
            this.getNumberOfNodesForTransaction(),
        ).map((node) => node.accountId);
    }
}
// Filename: src/client/NodeClient.js
// SPDX-License-Identifier: Apache-2.0

import fs from "fs";
import util from "util";
import Client from "./Client.js";
import NodeChannel from "../channel/NodeChannel.js";
import NodeMirrorChannel from "../channel/NodeMirrorChannel.js";
import LedgerId from "../LedgerId.js";
import AccountId from "../account/AccountId.js";
import NodeAddressBook from "../address_book/NodeAddressBook.js";
import * as mainnet from "./addressbooks/mainnet.js";
import * as testnet from "./addressbooks/testnet.js";
import * as previewnet from "./addressbooks/previewnet.js";
import * as hex from "../encoding/hex.js";
import AddressBookQuery from "../network/AddressBookQuery.js";
import FileId from "../file/FileId.js";

const readFileAsync = util.promisify(fs.readFile);

/**
 * @typedef {import("./Client.js").ClientConfiguration} ClientConfiguration
 */

export const Network = {
    LOCAL_NODE: {
        "127.0.0.1:50211": new AccountId(3),
    },
};

export const MirrorNetwork = {
    /**
     * @param {string} name
     * @returns {string[]}
     */
    fromName(name) {
        switch (name) {
            case "mainnet":
                return MirrorNetwork.MAINNET;

            case "testnet":
                return MirrorNetwork.TESTNET;

            case "previewnet":
                return MirrorNetwork.PREVIEWNET;

            case "local-node":
                return MirrorNetwork.LOCAL_NODE;

            default:
                throw new Error(`unknown network name: ${name}`);
        }
    },

    MAINNET: ["mainnet-public.mirrornode.hedera.com:443"],
    TESTNET: ["testnet.mirrornode.hedera.com:443"],
    PREVIEWNET: ["previewnet.mirrornode.hedera.com:443"],
    LOCAL_NODE: ["127.0.0.1:5600"],
};

/**
 * @augments {Client<NodeChannel, NodeMirrorChannel>}
 * Client for interacting with the Hedera network using Node.js.
 * Extends the base Client class with Node.js specific implementations.
 */
export default class NodeClient extends Client {
    /**
     * @param {ClientConfiguration} [props]
     */
    constructor(props) {
        super(props);

        /** @private */
        this._maxExecutionTime = 10000;

        if (props != null) {
            if (typeof props.network === "string") {
                this._setNetworkFromName(props.network);
            } else if (props.network != null) {
                this.setNetwork(props.network);
            }

            if (typeof props.mirrorNetwork === "string") {
                switch (props.mirrorNetwork) {
                    case "mainnet":
                        this.setMirrorNetwork(MirrorNetwork.MAINNET);
                        break;

                    case "testnet":
                        this.setMirrorNetwork(MirrorNetwork.TESTNET);
                        break;

                    case "previewnet":
                        this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);
                        break;

                    default:
                        this.setMirrorNetwork([props.mirrorNetwork]);
                        break;
                }
            } else if (props.mirrorNetwork != null) {
                this.setMirrorNetwork(props.mirrorNetwork);
            }
        }
    }

    /**
     * @param {string | ClientConfiguration} data
     * @returns {NodeClient}
     */
    static fromConfig(data) {
        return new NodeClient(
            typeof data === "string"
                ? /** @type {ClientConfiguration | undefined} */ (
                      JSON.parse(data)
                  )
                : data,
        );
    }

    /**
     * @param {string} filename
     * @returns {Promise<NodeClient>}
     */
    static async fromConfigFile(filename) {
        return NodeClient.fromConfig(await readFileAsync(filename, "utf8"));
    }

    /**
     * Construct a client for a specific network.
     *
     * It is the responsibility of the caller to ensure that all nodes in the map are part of the
     * same Hedera network. Failure to do so will result in undefined behavior.
     *
     * The client will load balance all requests to Hedera using a simple round-robin scheme to
     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
     * tried.
     *
     * @param {{[key: string]: (string | AccountId)}} network
     * @param {ClientConfiguration} [props]
     * @returns {NodeClient}
     */
    static forNetwork(network, props) {
        return new NodeClient({ network, ...props });
    }

    /**
     * @param {string} network
     * @param {object} [props]
     * @param {boolean} [props.scheduleNetworkUpdate]
     * @returns {NodeClient}
     */
    static forName(network, props = {}) {
        return new NodeClient({ network, ...props });
    }

    /**
     * Construct a Hedera client pre-configured for Mainnet access.
     *
     * @param {object} [props]
     * @param {boolean} [props.scheduleNetworkUpdate]
     * @returns {NodeClient}
     */
    static forMainnet(props = {}) {
        return new NodeClient({ network: "mainnet", ...props });
    }

    /**
     * Construct a Hedera client pre-configured for Testnet access.
     *
     * @param {object} [props]
     * @param {boolean} [props.scheduleNetworkUpdate]
     * @returns {NodeClient}
     */
    static forTestnet(props = {}) {
        return new NodeClient({ network: "testnet", ...props });
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {Promise<NodeClient>}
     */
    static async forMirrorNetwork(mirrorNetwork) {
        const client = new NodeClient();

        client.setMirrorNetwork(mirrorNetwork).setNetworkUpdatePeriod(10000);

        // Execute an address book query to get the network nodes
        const addressBook = await new AddressBookQuery()
            .setFileId(FileId.ADDRESS_BOOK)
            .execute(client);

        client.setNetworkFromAddressBook(addressBook);

        return client;
    }

    /**
     * Construct a Hedera client pre-configured for Previewnet access.
     *
     * @param {object} [props]
     * @param {boolean} [props.scheduleNetworkUpdate]
     * @returns {NodeClient}
     */
    static forPreviewnet(props = {}) {
        return new NodeClient({ network: "previewnet", ...props });
    }

    /**
     * Construct a Hedera client pre-configured for local-node access.
     *
     * @param {object} [props]
     * @param {boolean} [props.scheduleNetworkUpdate]
     * @returns {NodeClient}
     */
    static forLocalNode(props = { scheduleNetworkUpdate: false }) {
        return new NodeClient({ network: "local-node", ...props });
    }

    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    setNetwork(network) {
        if (typeof network === "string") {
            this._setNetworkFromName(network);
        } else {
            this._network.setNetwork(network);
        }
    }

    /**
     * Available only for NodeClient
     *
     * @param {number} maxExecutionTime
     * @returns {this}
     */
    setMaxExecutionTime(maxExecutionTime) {
        this._maxExecutionTime = maxExecutionTime;
        return this;
    }

    /**
     * @private
     * @param {string} name
     * @returns {this}
     */
    _setNetworkFromName(name) {
        switch (name) {
            case "mainnet":
                this.setNetworkFromAddressBook(
                    NodeAddressBook.fromBytes(hex.decode(mainnet.addressBook)),
                );
                this.setMirrorNetwork(MirrorNetwork.MAINNET);
                this.setLedgerId(LedgerId.MAINNET);
                break;

            case "testnet":
                this.setNetworkFromAddressBook(
                    NodeAddressBook.fromBytes(hex.decode(testnet.addressBook)),
                );
                this.setMirrorNetwork(MirrorNetwork.TESTNET);
                this.setLedgerId(LedgerId.TESTNET);
                break;

            case "previewnet":
                this.setNetworkFromAddressBook(
                    NodeAddressBook.fromBytes(
                        hex.decode(previewnet.addressBook),
                    ),
                );
                this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);
                this.setLedgerId(LedgerId.PREVIEWNET);
                break;

            case "local-node":
                this.setNetwork(Network.LOCAL_NODE);
                this.setMirrorNetwork(MirrorNetwork.LOCAL_NODE);
                this.setLedgerId(LedgerId.LOCAL_NODE);
                break;

            default:
                throw new Error(
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    `unknown network: ${name}`,
                );
        }
        return this;
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {this}
     */
    setMirrorNetwork(mirrorNetwork) {
        if (typeof mirrorNetwork === "string") {
            switch (mirrorNetwork) {
                case "local-node":
                    this._mirrorNetwork.setNetwork(MirrorNetwork.LOCAL_NODE);
                    break;
                case "previewnet":
                    this._mirrorNetwork.setNetwork(MirrorNetwork.PREVIEWNET);
                    break;
                case "testnet":
                    this._mirrorNetwork.setNetwork(MirrorNetwork.TESTNET);
                    break;
                case "mainnet":
                    this._mirrorNetwork.setNetwork(MirrorNetwork.MAINNET);
                    break;
                default:
                    this._mirrorNetwork.setNetwork([mirrorNetwork]);
            }
        } else {
            this._mirrorNetwork.setNetwork(mirrorNetwork);
        }

        return this;
    }

    /**
     * @override
     * @returns {(address: string, cert?: string) => NodeChannel}
     */
    _createNetworkChannel() {
        return (address) => new NodeChannel(address, this._maxExecutionTime);
    }

    /**
     * @override
     * @returns {(address: string) => NodeMirrorChannel}
     */
    _createMirrorNetworkChannel() {
        return (address) => new NodeMirrorChannel(address);
    }
}
// Filename: src/client/WebClient.js
// SPDX-License-Identifier: Apache-2.0

import Client from "./Client.js";
import WebChannel from "../channel/WebChannel.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import AccountId from "../account/AccountId.js";
import LedgerId from "../LedgerId.js";
import {
    MAINNET,
    WEB_TESTNET,
    WEB_PREVIEWNET,
} from "../constants/ClientConstants.js";

/**
 * @typedef {import("./Client.js").ClientConfiguration} ClientConfiguration
 */

export const Network = {
    /**
     * @param {string} name
     * @returns {{[key: string]: (string | AccountId)}}
     */
    fromName(name) {
        switch (name) {
            case "mainnet":
                return Network.MAINNET;

            case "testnet":
                return Network.TESTNET;

            case "previewnet":
                return Network.PREVIEWNET;

            default:
                throw new Error(`unknown network name: ${name}`);
        }
    },

    MAINNET: MAINNET,
    TESTNET: WEB_TESTNET,
    PREVIEWNET: WEB_PREVIEWNET,
};

/**
 * Represents a client for interacting with the Hedera network over the web.
 * The `WebClient` class extends the base `Client` class and provides methods
 * for configuring and managing connections to the Hedera network, including
 * setting the network type (mainnet, testnet, previewnet) and handling
 * transactions and queries.
 * @augments {Client<WebChannel, *>}
 */
export default class WebClient extends Client {
    /**
     * @param {ClientConfiguration} [props]
     */
    constructor(props) {
        super(props);
        if (props != null) {
            if (typeof props.network === "string") {
                switch (props.network) {
                    case "mainnet":
                        this.setNetwork(Network.MAINNET);
                        this.setLedgerId(LedgerId.MAINNET);
                        break;

                    case "testnet":
                        this.setNetwork(Network.TESTNET);
                        this.setLedgerId(LedgerId.TESTNET);
                        break;

                    case "previewnet":
                        this.setNetwork(Network.PREVIEWNET);
                        this.setLedgerId(LedgerId.PREVIEWNET);
                        break;

                    default:
                        throw new Error(
                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                            `unknown network: ${props.network}`,
                        );
                }
            } else if (props.network != null) {
                this.setNetwork(props.network);
            }
        }
    }

    /**
     * @param {string | ClientConfiguration} data
     * @returns {WebClient}
     */
    static fromConfig(data) {
        return new WebClient(
            typeof data === "string"
                ? /** @type {ClientConfiguration | undefined} */ (
                      JSON.parse(data)
                  )
                : data,
        );
    }

    /**
     * Construct a client for a specific network.
     *
     * It is the responsibility of the caller to ensure that all nodes in the map are part of the
     * same Hedera network. Failure to do so will result in undefined behavior.
     *
     * The client will load balance all requests to Hedera using a simple round-robin scheme to
     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be
     * tried.
     *
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {WebClient}
     */
    static forNetwork(network) {
        return new WebClient({ network, scheduleNetworkUpdate: false });
    }

    /**
     * @param {string} network
     * @returns {WebClient}
     */
    static forName(network) {
        return new WebClient({ network, scheduleNetworkUpdate: false });
    }

    /**
     * Construct a Hedera client pre-configured for Mainnet access.
     *
     * @returns {WebClient}
     */
    static forMainnet() {
        return new WebClient({
            network: "mainnet",
            scheduleNetworkUpdate: false,
        });
    }

    /**
     * Construct a Hedera client pre-configured for Testnet access.
     *
     * @returns {WebClient}
     */
    static forTestnet() {
        return new WebClient({
            network: "testnet",
            scheduleNetworkUpdate: false,
        });
    }

    /**
     * Construct a Hedera client pre-configured for Previewnet access.
     *
     * @returns {WebClient}
     */
    static forPreviewnet() {
        return new WebClient({
            network: "previewnet",
            scheduleNetworkUpdate: false,
        });
    }

    /**
     * @param {{[key: string]: (string | AccountId)} | string} network
     * @returns {void}
     */
    setNetwork(network) {
        if (typeof network === "string") {
            switch (network) {
                case "previewnet":
                    this._network.setNetwork(Network.PREVIEWNET);
                    break;
                case "testnet":
                    this._network.setNetwork(Network.TESTNET);
                    break;
                case "mainnet":
                    this._network.setNetwork(Network.MAINNET);
            }
        } else {
            this._network.setNetwork(network);
        }
    }

    /**
     * @param {string[] | string} mirrorNetwork
     * @returns {this}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMirrorNetwork(mirrorNetwork) {
        if (typeof mirrorNetwork === "string") {
            this._mirrorNetwork.setNetwork([]);
        } else {
            this._mirrorNetwork.setNetwork(mirrorNetwork);
        }

        return this;
    }

    /**
     * @override
     * @returns {(address: string) => WebChannel}
     */
    _createNetworkChannel() {
        return (address) => new WebChannel(address);
    }

    /**
     * @override
     * @returns {(address: string) => *}
     */
    _createMirrorNetworkChannel() {
        return () => {
            throw new Error("mirror support is not supported in browsers");
        };
    }
}
// Filename: src/client/addressbooks/mainnet.js
export const addressBook =
    "0a970822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031280032060800100018033a60333432343464353061386564346434636261646632353632306431616238386133323038313937376432663864373062613832626135326233333035613435363038323463663662303130366436333565643563333932373266666661626538420a0a0422ef520610a38803420a0a0423edc8b410a48803420a0a0422ef520610a48803420a0a0423edc8b410a388034a21486f73746564206279204c47207c2053656f756c2c20536f757468204b6f72656150808092b7afe8f74f0a930822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039313331616133363866393334353232396639376236323539636363616666656132336530306364356561643032653366363936633165373134656533393339646164383630653338626639356132393734663965623438653933343366386161633430356561393535643035333233653131376233623163393438313361336166343266653830383263336434336261663162643464383336376539336462303061643639366536323761313033366165353334663031316561643565353666333761366666653434623662396530393934303131393261643536306130333436623431613831303039356635663264376664333264366565623635356261373538633662353236633132393338366166373139376337613533616536303364363232383332323534393631663136643065666138303739613736383536313838386265373333343932323137393536626263616661656262363133356335666262323438346435623461356664663033333661633032653236633136353263316264386561663330646165316436643365623030663762346661623864363437386665386439356562393131646639363661306465613465353232646237366238393636353730656363356166303935313634323466306166356638656536366533383664353635303731333939373136396163333735373362663532666430353864653935616232666636386536383131316162323334303565613936346232626238386430326330663163616564373165636464346534653430383539343837366664623835303062633535633762613032303636653035616239386439663765303436366439373032656235376565333732326638666363383561373535303566663332363231373032383862373838373233616462393765346465353632306363393065616431333832666364373537313838396665666231316536373731626333663666336665623139633761633534323837386430336139303237303532366333656564323439346566663534653135336361396636383930323033303130303031280132060800100018043a60303164313733373533383130633061616537393462613732643534343363323932653966663936326230313034363232306464393966353831363432323639366530353639633937376532663136396531653536383861666338663461613136420a0a0423babff710a48803420a0a04038234ec10a38803420a0a0423babff710a38803420a0a04038234ec10a488034a1d486f7374656420627920537769726c6473207c20496f77612c2055534150808092b7afe8f74f0ada0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303062326363616336356164306663373634356138313762666162633438376164376534313331316537613331393862333766623834326438346333393562336636376436626438343866313063366630336332393065386637646161386430303161383434316463333532613139313630613331393365363862383265646631396165363736393361396133336434636238376537383961313037303731353531356561373732636161386238366135363962393163353435303833356439633335346630646163656339376665373730393162343562313437363938623766383630313432326463643232363165393238646534646163396334326463626166646639366330373233336261333032373037366633376339363965386564333062366235643866353033346265376439326335393666386265383631653531666363336132343262663964386265396532613965386530663135356562636666323365666661376364353763313035343238313164383037373663393538353532366664623065616133346565313935356435313131393339306665383733653463303464656464323931363538383462393862343633303837383861653766633464346161346138666339626332363734626133323134393362363234343535616434313063316465373162633935643164393166613066323031343138613739356533303965616632393762363939626632376339666132373633636435396365623032316531366238323030633130363066323831376664383363666337363731383334383934363165333539393239316233383064366539333962616134623139323332613661323732646465363531663830343666646333346462323736613737376436666232626563333235356232636332343462346166353636623130356633306336353036646461653065623364656464636639343762636239633630653030303938346633623461386336633465643462663930626331393332623766393464633361653662333630303038656239303230343066396230323033303130303031280232060800100018053a60653535633535393937356331633932383563353236326436633934323632323837653564353031633636613063373730663063396138386637323334653034333563353634336530333636346562396338636532643966393464653731376563420a0a04031212fe10a48803420a0a046b9b406210a48803420a0a044a32752310a48803420a0a0423c0021910a38803420a0a04031212fe10a38803420a0a04176fbafa10a48803420a0a04176fbafa10a38803420a0a044a32752310a38803420a0a0423c0021910a48803420a0a046b9b406210a388034a1c486f7374656420627920464953207c20466c6f726964612c20555341508080c4c4f0d8cd4a0a9f0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061336533376237366336636435663636323264363932343434346431326336373763333935663262353930326633626239386238613862353035356137303737303663613032386364373530363061326438373032643264386230343934376264636665306138633134316161323834346231653036653636313930303132653862363332366162306661333137393733626337636234643239343966323130386161303463346230633931626161353732386635623536323265633735616266353738613166376234316564653261363765626436396331386535383166646639633630323061633064653963613263333166306336343639303033333131666262356365376462343963373837653161376432376161343235656537623834646137653636393339663963383064306538326663653535653032646663386235633738343138613236616134333635303639383731396261666365636630626434393030306164646366613430353730386264626566626231393734396432326461623030376534346434356561323362313036663838333463313532653235303632643463663234666632353335366337656233373239313035333933666234396261623930346130326630663062623431376364393139643335323839303132386536626266663466616339663930646531313861393734663261366464303165303332613739623137386636306661316663626264303262353730346662343632393563313531393038313633373365646436363335633835363937386631623935303366316637336234623062653861626132656431666565616435393935336266383265666465393361333437316162643535636461336261386136373366626233373939373439666230303664303033663065363366363635633334363164326137623239646338623230346261353961363536363861343661653238373866303064316639343930646639653238306665626634333135656130346561613536386133613966643438633632633633623665636461363930323033303130303031280332060800100018063a60623837303764643839313632316231306663653032626436656132383737333435366630303862303662396461393835616532646131616436366265383233376366383331666335623862346665613534353935313739653937333564356432420a0a0423c7a16c10a48803420a0a040d346cf310a48803420a0a0423c7a16c10a38803420a0a040d346cf310a388034a29486f7374656420666f7220576970726f207c20416d7374657264616d2c204e65746865726c616e6473508080c4c4f0d8cd4a0a950822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063343536316533633237386364363530653830633431336361343434323363316333633133636631343735663666363937366435393761653433326234396162343230383662373962383431333236303534623862336463663537643866636437396266633035383138336361323463643463316362633537346564313131376532663562376233633633636537623036643962346566636637333735363337623431666536663533633831316239646536313433663361353239353763646639353637373531323062333337303366663537363231343037616239353735626332643335633064343466303938336663316566363361346666353230396630373063393261663130363239353630316339366263656430363465633139303139373031396336383131633463386464383063623466346163373166396164373665376163383934353666626634663031316639306162643264393035333665383233343635316636626566393237653364356438623762663435393035303938336265636133616265663261396439376166333435373732613737343065393639393237356230313865613064663238366164643663653932336566393038666265373632613735663231313136383632646234346433646361316434346234643265386463313036366335303036626235613764393534616432353564346236303332373334373565353131616562343835643036396130363763306162356332343533386339333363303662356136616566613934303035633239313532313365346363646165366339343266363237326639646435323832643662383930663166323065666432333939636436373439323466613537303436616336646133326537333935316137333131336539316663326237666632396534383531623833666633396638336261396563366630386365666462623663626262666661626664666161393164393330663732303064613438313337633339346362643133653730316563646332363136666432316261643638316161346630303130323033303130303031280432060800100018073a60623863336339613161363430336161353536633462393663383936343339323563393831643565383364323963616665643739303832653331306531656234663135623536396337396664626332343136306238393165633732316663613337420a0a040372360410a48803420a0a0423cb52f010a48803420a0a040372360410a38803420a0a0423cb52f010a388034a1f486f73746564206279204e6f6d757261207c20546f6b796f2c204a6170616e508080c4c4f0d8cd4a0a9a0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061316334303737313534333033636337326334666237363932633366393432353162646563313233396131663761383937326162653931613335333233666265636136323561376666616536343036633835356463326166323131303930306230646630653665366462373633363464666131666665383565646135363739333665323938356238353633346133326161353261363539396464366333306265316637613663356238663565656361663236323164386134353936383266636432646261616431353631643131663333666363623766353530306163353638643136356462656161636533323836643238393466363431323964373831643663373266643764353939633965316433616634616134333363323362393130666165346334383431363431663631353236616437383765626561353339383734313637653964336137336363306662313536343239643135656337363361366430663036313135613739623961663738336437376239386438333039366161343734336639373430386439653134626366346464666665343539313736383834376234306362386461376361333735323536643262393335643039356665323532666165383166663665333766383464376139306437653537306134663865663363376437363665656461343732663039323031393930313561383930383235396138373363353435346663626264636164326535323864653835343535623430383363376463346164633561393838653063646466646331353964356437313261626435343461613733656330323930383938313463393861343466323666633036343436353963313833653331383461613237326638643164633062666133653061353630343834636230353562613464626235636333333965633830626431316436343264633361373032653863373033616232313933303834643962643633663064666531326134333363323537366561663738316366616438363765663730626461363137363862326265663134663530633663336238623039366630323033303130303031280532060800100018083a60346134346462616664353064636539653139616536353935656663663237626164666537396462383866306532393163333262303363306666633936383330623339316331343331313436313132353566356137366534613333626130333139420a0a0423b7429610a38803420a0a0423ec05db10a48803420a0a0423b7429610a48803420a0a0423ec05db10a388034a24486f7374656420627920476f6f676c65207c2048656c73696e6b692c2046696e6c616e6450808092b7afe8f74f0aa00822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039336132313563633461376137323263616539633133616264363336646639396363656563366166396462343662363966613531363731366566353063653234393061393831653039616230313963613263623436383131623562363139643162643164356565366634366134326337373763626465653634326131343834656364663564646433373239363432633338633664343361383835383837343437356635383234343433363634633034646665643962383930343566623038356532356333656663623438343137333365666637633532396331333965363933353063326364373962326338643139363739613731326534653863616664333236373534316238333262336531306130313235356465663639646631653964336238643865616630333131646536376435653132623236646430316462626439643365343264333564396465323731333032653066316636396438376362633761636139653838363765396434323864336361623036363665623439306435666261623330626666336637383564303366323037326134336262396235653534363536613539326362363165616664356135656632383463376361656336366637663437333235636330643463316432376636363164386137343863613530373163303665663133346466663936663430383636383833363664343638613234373830303137653062353661626137666162343362336237633062373739303666616535343832663332383131633239326536623134343534653134623839343830316138366130336363343737393464643064373435323761373265343234656433616661303438393965636239613633663261396165373262653766613938396164663064363561333263383531643938303166633431303438646633333536346663376233313730376563386662383031343066653762376131666131323062613163623636303332346365666662346263633264396262376465306366353463383139663264643362636561646563396332356635653139646339623130323033303130303031280632060800100018093a60393238316639613166303537653964653636666163343433326362313362313032643930643563633565613738373438376637313430336362363261613830393937366636356363336235656461333861316333336137313962343662333033420a0a0423c5c0e110a38803420a0a0423b59efa10a48803420a0a0423c5c0e110a48803420a0a0423b59efa10a388034a2a486f73746564206279205a61696e2047726f7570207c204b757761697420436974792c204b757761697450808092b7afe8f74f0ab20822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633537656462396666323736653032336232383032316362316438376364663139363662363938636634386534656161613763363932303737636565653863636232333961346339323135393765386538396637636330356433663331333135373839373663346533313434303564346134653033613732343130633563303963613532376164356138356239393836333765373261333265316662633064353534366232343635653965383036633264643530396562303530616235666232373036336664393238313562316464323638396532313131636165623666353439653934613966303066303832316434636136633661363131376635613533336339323633626630373461333064356362656635306431633863323338376263613937326564656461303938336235643061366235376463623030323030303638323862343065343037366234383730623234626164383430353665653532623566343232653838343030323863323530303633383264386539633636313232356634663736656137326533343036303765396663366633633230343333303736613163613863623135656430336163383936366430353037626364653638316534653032333165653966383764313131653762343861633866393464326438343262353264663733663537336363353431343936343739376336323639363866666165373431386633623631303962356130663039653332323366346134643565333530396464323530313338663662633137626636636563653137353934343330646631383061333865393061646632616666626661643063366238633162383766313738613036316463666266663862393263393136366438373463316666356166346662636462666538653964303939333730646466363062653734373633336433366565346562356364353166366533633333396531353165343162646235613563653263386339376130613433623363643463633038313838346338373966396432663337343834323863383537336631376339306633636264303230333031303030312807320608001000180a3a60373462636363393430333338393661613435393435343538623838336239383134336633643236313032316264653834373637356335633762306430663639313664656664636438386632303739303836613231663664363335343730393165420a0a04b19a3eea10a48803420a0a0403f81b3010a38803420a0a0423f2e99a10a48803420a0a04b19a3eea10a38803420a0a0423f2e99a10a38803420a0a0403f81b3010a488034a24486f73746564206279204d6167616c75207c2053616f205061756c6f2c204272617a696c50808092b7afe8f74f0a9d0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032353966346533643966306633393432353635343865396337333038623130623733343033636339303934643937616431353162373730363137306239373732636562363464363632656365663930316138643764313564333139613539633862373130373161636364383935623763393336313064633639373666363763346531373239626138333733616237653532613366336338663236353439316464653639643665303939393437306537343435393831313331626439366333366536383635323033666232656264356435306561646166623732363339366465633164393137343839386234653962653034633734643330346665616464396362643332333463336237663333303663393963623063333339666332353936396234316435386132623763666331383332653232366438316331393633393933653232353561303837643136393863303364343231306264363435383036343464303935636137366161313739346564643430633163383762356638326138653339663630336539373131366261303435373865376538303334363439356437383564346566376366373731346239656236663566396530623961393466346237333838343631396239323734643461393565663135373534613839643937656635633161383862366436393365306138306562643533376663396366306361393164316336326439313564653765643831386239353265363463323030323933656538653238346134313661373261336531326663376434323362313538663962343936363063626332343636666265643066656432653234653130326664653934326562346366643934626563343664336439306663303863333966656362613033653063613234363461653636346239373935313562613239653166373032633366653730326265373933373936643865646231376161343863303932393062303234353439663036313166356165323365643765313634343264663764316461643232383663326262303964353532326464336564363938633266303230333031303030312809320608001000180c3a60323030636462653835346639383561613664366264313539613234613033346561626539306438333861383438306638666230653665393265623563353762653265636265353461333263373161653466393731653363333666326637306339420a0a0423b1a2b410a48803420a0a0423b1a2b410a38803420a0a0423cc562010a48803420a0a0423cc562010a388034a27486f7374656420627920444c41205069706572207c2048656c73696e6b692c2046696e6c616e6450808092b7afe8f74f0aa10822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a320608001000180d3a60303762373763653238346637656262356265623037623130353337356166353564323238613736356531613834353837656231643166316230363735633338613164313531323337306535366632316338656435656164656662333737396139420a0a0422d7c06810a38803420a0a0423ea846b10a48803420a0a0423ea846b10a38803420a0a0422d7c06810a488034a2b486f73746564206279205461746120436f6d6d756e69636174696f6e73207c204f7265676f6e2c2055534150808092b7afe8f74f0a900822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b320608001000180e3a60353061666134343861336137386236313566343966656635373762643762363262313330383265623535326366383839353130396530653534333866373961633861656432663261343865326635373034393037343666346334333931303462420a0a043408158d10a48803420a0a0423ec021b10a48803420a0a043408158d10a38803420a0a0423ec021b10a388034a1a486f737465642062792049424d207c2054657861732c2055534150808092b7afe8f74f0abd0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c320608001000180f3a60633637313364383765336331663638353961336133363633656262316237653162643164613134666366303736636535316433363436346235363832613564663763666164643434303139373536346634393838343233313330393163326264420a0a040379ee1a10a38803420a0a04416dade410a48803420a0a04416dade410a38803420a0a0423e40b3510a48803420a0a040379ee1a10a48803420a0a0423e40b3510a388034a2f486f7374656420666f722044657574736368652054656c656b6f6d207c2048656c73696e6b692c2046696e6c616e6450808092b7afe8f74f0abb0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e32060800100018113a60623562323865366635373234303733306364613830326335366535336238383337613764363364616239623362336162313536613034643965326536653234623637393063333861356664333335626536376139353162373762656563373438420a0a044a768aa910a48803420a0a042256d4f710a38803420a0a0412e8fb1310a48803420a0a044a768aa910a38803420a0a0412e8fb1310a38803420a0a042256d4f710a488034a2d486f7374656420666f722041766572792044656e6e69736f6e207c2050656e6e73796c76616e69612c2055534150808092b7afe8f74f0ac30822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f32060800100018123a60656239373639393565356432613964613639633434623036646633633239656363613565626135303038663035343037376330656538376230383831333331346334666439316563383334643362383638666237656537373934663463626562420a0a04225756f210a48803420a0a0412888fb010a38803420a0a0412888fb010a48803420a0a048d5eafbb10a48803420a0a04225756f210a38803420a0a048d5eafbb10a388034a35486f7374656420666f722044656e746f6e73207c2053696e6761706f72652c2052657075626c6963206f662053696e6761706f726550808092b7afe8f74f0aab0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303062653137633939363437636563363561343434303762353335383536623363336261656635623534663536356166353862383435366261386337636535333564356163373263363163343463373662336335376338653836343834313633376265313061383363666533396330393234373664306462653464366364636463643732306133306235626665623531613031613138663538326334356636633836393933666366376466313832393335646531643836393036303434646366333531383639333564396264376565613739353233353262656262346566396165306637363631653730613432333761666139383939363638376361343866636663356230306433383037663035346265306661386333626661343235303338626536656632393531363466323266373362376538386339346561396265386161346633613234356338396239643166643531393266376135306239353862326566383130346233366631626638666432636662323863313432313830306331633437653465663938616631353030373063633664363964313765386562393266313861366161316136353236366134393532333864313033663866363935623537656366333733363530613035323030383734353732316265613831353632373936376338303736333635646638633463376137643464643866326333383530633138666261373165623630653665386466626431393665303533376664373062333434656362636335333064666338336461366665646634396435316139303431393530326261396437306364333566316366336330363934653233353466393036346664626635333565623233633237633061343364306237386331663836376336316439383639356438646566376263326131306262363637346332326636366161623061393138313364646632376364623835326335396566373965316239653161303735666136656532376137653337373464626634623236343635343237653664356162393166653766306633613731373834656361313832623530323033303130303031281032060800100018133a60643563653666343337386436643534373233393438366566643661373032613734666361396539363537323366306561343365656661333262653938313739353038633432313835666132333735306432306538633066316361316435363361420a0a042259578a10a48803420a0a0412a8043b10a48803420a0a042259578a10a38803420a0a0412a8043b10a388034a35486f7374656420666f72205374616e646172642042616e6b207c204a6f68616e6e6573627572672c20536f7574682041667269636150808092b7afe8f74f0aac0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061356164326237363433613034633035356432663863643235313162313531333966633435353735363231333838653439633131396232663339386163613131306636313339366230633836366465353036333532326262383534303237336531336636643934636531653630343338663661666230306161613634363132663731343565396263653862633161353362393431393133616137366339663361323833336661643763663238356337616332643337663939663363326364623439646534643135316536313637383536346632383166353431343234623431666137633531623261393630323238336337643332656530306562383338646131356333386166633936653036316439376365646532323136356666316161393539663163343237356232643039386334303538366135353739666262336362393030373237303431323061386136366135323730663466636664313038366339323336393061333565376664343435653333616330336631333963363836383535363537306364633461616632323130376136633161343432343536613763366337396565303430393065376535643466363662636136306361316634376236646662353433646163336362663139613737313961386635356236663833623461336238613636643630323536643061343635353166613730323462643035363331623861353538303837373235346332663266323638636463333364326462626366623733336539666265323333626239636235396162333161303134386232336538633432363830666631306166346337396134643038333436666237396139336439363239353438656166316262313234363938666165666134636464373234343263303361303462373333343332663734383930336133323563323833643435366162396165393231616537656433333931653564313738376566646332333534306137623835633639316165383730613037663930623131633133623332636534336561656431356233363936383563653439313737636339383530323033303130303031281132060800100018143a60623064373630623735333936626438303239326366373531646334333833326130313432366663373965323934306161396432383339353235666664613164623034626434376434653265643362343630383833373338303035303463653133420a0a0422524eff10a38803420a0a043427a2d810a48803420a0a043427a2d810a38803420a0a0422524eff10a488034a36486f73746564206279204175737472616c69616e205061796d656e747320506c7573207c205379646e65792c204175737472616c696150808092b7afe8f74f0a930822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038643435633231633063393565663635613032396435326339353766643066383566323031323364613033346536313637316464656535343735663037333832613636633636636234646335303530346464666433373538313038336466386431373537373330656438643666333634646634633336613236353135393139353564613230316132343037666138616239623233313338313132323561306461323330666265333830653039306161353665666134663230326563396234383233663635303164393661633639386562663236616163663365653264316633326137323163393437653130373663663335623337336461316438376133366131353265303065373130313137393232383265383235666631373163353833336238383537306266633664613834343965366639356638623132363561623535353139343033313535336431643537366639336334326330636136306161626163346338646431363264383131346632623231353131353833633732353339666535366334393961393239646533613430613064343563313763353839633264373938386365323665616663393261336433376237656130303432643433653033616661363237316232363235356136636363666165353337313832316438316530623035633235306235396630613930373431613065306538386130396564353663356239373830643039356630393036663062383164353132363339383261616530313133366330373264383434613131643664613462326136316336343465316162313766313666663438656532336665646538343532663165343265326433306130373930633235643432303630653164343461363731613265623233643131346636386337316533336631373664623538613638623433303035346263316432393833613233613332656136666639356661376334643865333830656232393665393862373936386563663834353464383137633733376565613564643932316562383663313663376232393330346134613765636265356133613130323033303130303031281232060800100018153a60633332623830343033666562653331633462613165623436636661393363626339313639663238353937613330636130313336356362336531373936373261373535613338343530636536616161626634306164396533363034386664386434420a0a04224c8c6d10a48803420a0a040d247bd110a38803420a0a04224c8c6d10a38803420a0a040d247bd110a488034a1d486f7374656420627920454446207c2050617269732c204672616e636550808092b7afe8f74f0a9a0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303062303561626532616230306664643036633935356538363731306230653036663161393236323461343861643163626338646663366632323132393632623063333066646264323834613337633561333736353862363363333665613831363235363161386534663934366362653537323263303238383031663066323831633730663864383863376330306132663265323966353937623739393836396564383335366466353763343762653939343461326161666636353066396234626261306462633533646338383066646262363965613435313930356432383032323032663865323963303461373664323761663265623763353438343835626633663436393463393063343138313038383838343337393238343838333566373831363730376433653864373666346536376635373830626366303838313363353565633633396139626436323431373866356562313437643530306166333531653965663162316533343234383463613236306462376363626165343836663133636632363562356231616236383830363630303830353362323063336465646365373731633961303861303332306161396365343531656239643938336137623439636161313039366638616463303938333138646333386530653763656630643865356435353761303637353638356131633965323536613262633964626133323262336262333137326366373134303737626333383066386130613433336138626661376662666335396636623039336563386266366539333937633039623138653138303430633162353636383634373337633866613765323937393566336134353838646461376332626162343935363635636334613962383336653265623930633632613366636166353931666235663831383034633736313830653632366661323634346137646533343531316436633436363764393839333765323737333366346431653931333838333335346535346664373335313732316537366637623536633334383333383866346136623837623238616562656230323033303130303031281332060800100018163a60373364383962353366376363316563363734616632386164353231666166303864376130313831363634363965666338343531353461633431313038613964383132396138383330303331613139613537353161326437396362633437353230420a0a04344eca2210a38803420a0a0422408da610a38803420a0a04344eca2210a48803420a0a0422408da610a488034a24486f7374656420666f72205368696e68616e2042616e6b207c204c6f6e646f6e2c20554b50808092b7afe8f74f0ab60822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039386564366232323133613364613839346238653833633435333235383930393764316639343536633730623966653264386333303864656633366461613837373036643433306632336361353362323764303334646566663563326530616333353161303732396234373630613139623135323562396432306131393631623936323235356334626232613563633035613035643762343736663665356230353437623461383833623530663764316339333734356261343033363636303831303664626630356237353565626335316431623832393164313037663563306439613234383365626365336430376338623762353835376436326234626535363337356366323331346637653030396534663139653863383038396563363966393664303236363139396366376561333336336231353761653935326232323833613864396637636562343537333862313532343836663534643430663632303062376561373535643333366531633333616435386666653033613863353635306162363262393362326236363435373639666530316634643231636661613463653939353130663737316465323262613961643165386335656364333430346363333138333137346337633834666264663130386234393733333836386537633966656362393062336262383562306333633133373830333266336237393865366662396637666433356664323566336332316537636661653831613031626261353062633466646638323232326131363836653932303061316233323362363138653434383939306532616566623330363139303438626533353939666663383838306564653362363765636338626264346466363433326635323162666233333762663262303935386532396536363232336165333564633039343036626530323132313332626532393538313639346137343032363034663163653638396334623537613562616662633164343662333432623531633331666632623536373563366331646636306431323864346136346336366662346631383330323033303130303031281432060800100018173a60393033333838666533346538626438636165323865656334633665386664643230333562316463623563396634356233326234623137643635386336383862383164323333303638393536346333373164343737663638623464326233393539420a0a0445a7a9d010a38803420a0a0423e8f49110a48803420a0a0403125bb010a38803420a0a0445a7a9d010a48803420a0a0403125bb010a48803420a0a0423e8f49110a388034a28486f7374656420627920436861696e6c696e6b204c616273207c204d6963686967616e2c20555341508080c4c4f0d8cd4a0a900822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039646364386330613533653930633335353935373466363632303431313764336235303365353061333664333039376661633834323965366365636433376262353430373138303866326565393832303335663835316130633962653231373633383361323265333863316162613136386633326639303537306362333233336366653632353938373636366166363762353134636165663231666238646636643066636433336366323630366239326464656135353336623630363864383637383265333962643563333834343539393164343139623764316563303835393934313263303934396431633234306233356331346463353532373464626137316666616539333631323561356638313966353431333265323433396434616335353937393936656365383565313364666633333631663931333166353663656163356239663535326234396366366639613961633665356463653264623336393436326639336166383065356235366236653862656661313632613036316234613736383932626463383436343733303663363030383538666464323730333237366332633730343430313938656664376665333534356366326162353830633734636664363434356161663762643766373435636332353265616264323635656162656538363234313731303465363934386135353735366664633232326466306131303135323464653163336330386363663034333031316563376665393634656464383435316131333031343763303733363361333566313166646565663866326132623736313735376234333538666638396237356134386436376264633630393036393365306262383637396563626239336666646233663365643936626563393365663436353665333731366162383763653436636138653132353963386665646465386632663165613066336562326334386539363535316465313233333033343537323566343565643639633835373562353136383361666134373236323138323664623232626232643163346631653336343634613930323033303130303031281532060800100018183a60343136663935626665653633666464343562666331303037636265633364353434666163366233303339666531643030333137616666346339633965363739313862323863343862646462323363346361313131333163643832363062336564420a0a042259672610a48803420a0a04128707d310a38803420a0a04128707d310a48803420a0a042259672610a388034a1a486f73746564206279204c5345207c204c6f6e646f6e2c20554b50808092b7afe8f74f0abb0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061653761663963363038633162646232383966623831376666633663393537376564366434663664353766323734623231356631333930633765373965343930663964636237346366666530653837353764363766393066346232306464343435316237666636363331613662343563396534303362653561363632323439353535383364316161343233386261366639343662373163636138633136636337383838623266306433333363363335623865353437386661633362613366383134353761316131366230346532623232353236353162366334363838633535313064326564633231623033653061396232383330343162656566363738336330303839383435656363393665366432333563353636383564323438663833393166653061666366386565303366336234393836393663366439646563663266633939306332313965663664326362626132613639613236353238653630303936333264383265616433613538336566306333376332623739303638313138653033323062396663623331386635616534386330383737393535643038333162633935323161616138386239333431396665643966343632663930306663343236303130353665323463653434396564626463383439626237383263303961316133366164356534643462356437343636623737363339313366373934623237373162303761666236313734343466623662346237343834643634653139316235313366633865323530313034336637323534323163643537623037336265643231623030333134313835643638383766626332623534386439306262326133633931383461653934346333323664623866333761373335366161383832626164346337393437613830653136643066303265333832643537373166313938376331623736653838636465316364663264316139323231356563363864396232303465383062356463343637356666336161626632323366373738376562323431356466356533383963666636306663343063613235323030306234373638343130323033303130303031281632060800100018193a60383835326362386463646461623336396535373139636462616335653566353030393866383832313736343132616437313165326230336163366539666537303335383236666434376331326131323734326432633030643530373537353366420a0a040de8f0cf10a48803420a0a045926624910a48803420a0a04225d700710a38803420a0a04225d700710a48803420a0a045926624910a38803420a0a040de8f0cf10a388034a2d486f7374656420627920494954204d6164726173207c204e61616c6477696a6b2c204e65746865726c616e647350808092b7afe8f74f0a9d0822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030636137393562313636643833343362656437656531343663393535646432316238323865383330373862326136643331346236373736313066666437336562613239313138336136396235353865393363346530653663363861323533356231336161663631663961353665323930316637653162623939396665313738663463393335346634353666636435636338633938643235393032386166646432666231646636363632326433343361306435313331373637376665653165623734393136393333333461306636366238393636356265343061346165623337366163633061633032383363356635643330346231303330363936626664366330373330363366323166646665376239613263383339616266363337383238333033626632646561323864613031353932303435386639666439346561633632666431373465333765653038613433623739333062323232313461353636346465636138643334383239356530633339396161386238343630383231666236343464373730323432363765633934326564663264643063356461623237323634303433313333333838356634343265373363633139343134386637323863356137633962356132393636643365336232356639383336303066646130656133613462653937636637653866336230666236343866306233356661313364323732616537643433343261393239623539376234306431633534343433396361646332366462393962353435636165653630373431383838333133356539626631363066393737396635386430386435303266356562393531626631653130393137633830333961626466303961633336313465646534393838333966336461323736303031363834303534316665666338346163393363376566643931383532613434303136626664633638653338653530633361653363633534356333376438336130363734326161386165353331643562313662653332633662646630366463633233373330313338393266393265336165353336343164373663643261386464303230333031303030312818320608001000181b3a60396535316430316664323032663535303830653564646334633561393832323734376336366138353762306434303730666332306233663530386335613230323339383737613231396237363138323533343961663566333030313061383364420a0a040d38046010a38803420a0a04227dc86010a38803420a0a04227dc86010a48803420a0a040d38046010a488034a27486f7374656420666f7220536572766963654e6f77207c2057617368696e67746f6e2c2055534150808092b7afe8f74f0a980822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396636363165316236353236626432333132333932383035353564623134613930393430346364636339313838363432623664343763623266336539633931363633326532366134353034636666303862613730643134366462333137613038636330383230303431396231623936393435393834633139636633386436316362346165366631316136616135303765616263313261373239313733313336333739303831366466336136356662396635356232303231383432396336643234636431393330326231326264623635396164366262383137316564366636386439653936646465316161306166343563363963336265633036316335363135643831363030626432626437313064383133356135303065333765623734386664323936663763353638633236633064636265366166653861326663326263336137653533303532346338333531323864373661613534623431336566613033353236396664363838313439376435616233303061623465666461343535663432613830656633396336626334313933316634366238393132393930343062366430663364653839336636383235346265303834316161653466353131323039376530396462386666633830633835323363373965613831633663316164656364303431313561663964626263626333356130326462653839646238386566663666666638636436623166333335656634666137323030303866613062326135623134303232313933656239653263623766303337326661396237653838313433386566373436306665313738306563363533663261336365373839633066356362366637623237313631343861326531636233656463316336646161316531306134633062383637343162316266633863346432663335636262306230626331346366666264363737353132666331356230646639336637366232326333323433376332373531633833323963646464386135366563613735323030373265663364303161636566633137626233386161346434343262623536643362303664303230333031303030312819320608001000181c3a60623032633965383566343964613138313437666431333533373733626166306537316437326532326130303766316466393035316161386134373631616538376164346639306561346333343039383131613163343737376363326663363166420a0a04128b2f0510a38803420a0a0423c6dc4b10a48803420a0a04128b2f0510a48803420a0a0423c6dc4b10a388034a22486f7374656420627920556269736f6674207c205175656265632c2043616e61646150808092b7afe8f74f0aaa0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039623138393637633833383837376638356136343731636539663136346365663933396230313833306239656232326330326363366237326139303730323062336534633031346463373131656138653039356238386430623438353865633836623035613863336135396163313264326239666162636163323832636562363138646230306562353937313636313164363730366338316161333264396464646336613663376233393662613230326665646562333366323839613838373238346562666330376431363664303263326336656433326337333234633365633861653232313132383534653138616235656130376136313563356566383030346563363861633730646330333030336134376637656665313033656463653235376432386537393631663432386631636661326536636637316266343563353634623832636362646131346131383366333063326333643561376166626137613030343037396538373730326332343965393661376232666464353632666331363735396566653735616265366132336430643266393036613264663164346236346362323131376137333034343439633735333139613736323063323139613466666339383265383232623665316130376265316366393862653932363564303836646332373161613430363331306638613834366664333331323339666533303362643536313663383930383066623838363339623763306365623134303039333831383233653034333364623666393135366532626461313837336434616139613361363339363034626662643131613664643663653033623462306365656639353630316337643838613834303339376364626361336666323134666266353863396439646264373964333965613736376539616535663665616239666361303566633438303066353537363537633930633132633630653032313634383235643463333361663437333733373465613233356235303331336564306237356266383961366237393030316662613734636331333139653535313530323033303130303031281a320608001000181d3a60666666383030656134323830643632633963316666333333636634333031393465306638616632383262383133623435323131333238353333636637326639663134363434633036303461616366313262313635623561366230353961636333420a0a04364a3c7810a48803420a0a04228e478110a38803420a0a04505546c510a48803420a0a04505546c510a38803420a0a04364a3c7810a38803420a0a04228e478110a488034a1c486f7374656420627920616272646e207c204c6f6e646f6e2c20554b508080c4c4f0d8cd4a0a9a0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061313365303030633633343962366238303565663538643036363132303131303762373534366135396432626434653064373633333363333834653361333361393436366338366665373866356462383062616663616263313737636637633961626536326163343838336539363336393735633665393538393738353465613163643366623830376237653630626539656231663238356339306661643230366265366661303163613134636666313161326264616539366630303030386261616234343361353338373463323539336337366230613362646462346132306164353762326635666534343430353965383539316636623533626266393233393634333666306137333934323364613833346537346333666366663332663464363937343334303838636365653737373331373236343064636234393432326666363638613334333131663730373838343937616662643064636536316439653362366434623833643533623331663237616664356337366365373763396566383062643764666139323861373466316131643233393437663266313439373832366661366638383034346565313731383538383032313334643965326461653735623765333937616563336138323666383930643730306138613233393666656639363733663737616530363333333439343130643937353837343765613866663238373866613733616331646561373962376365363830663138666239623830383135613735626531323431336435366261643733303131366530656136653930333863326432343765663065663935623164643033663632623866316131333636353538383937653433323461643036616139336663643935313662363430343266376265343038373861633738653761396334303434376665333838373866383231386135326665363431333262333939333665363630333039623034643037646337323266633439356263396263653831333864306536326338366563353363376639636339393763336436636438613931353230313839656230323033303130303031281b320608001000181e3a60393737333639316332393935353531393332653035326537646338303533326233316438343730656332646233373935366365383830333638313739363534333633303066303064393562613561373530633262373839316338623636613961420a0a0423eaf99610a48803420a0a0422c9b1d410a48803420a0a0423eaf99610a38803420a0a0422c9b1d410a388034a24486f7374656420666f722044656c6c207c204672616e6b667572742c204765726d616e7950808092b7afe8f74f0abb0822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039386538633539623263633133386236366333386562383137306435663364353561616462633037633835666639346338653965626631326139343736616535343665656339343665356161633436373539326661653263626433633362306366656562363833366537616237633137373830333661376532653161363763323765326661373135353532663232623837663632303662333135303938613938303238343061383735343030306330353165393465343033336465333762383437613165316236643863356163616365383164633763343935396239373530383634326264376333323032346662316364616437343535366238386435373765376133326535633437303362343931353161373163666237303130613134383433663239636463383936636361656632656532613631363931306632326464363566323164393961633335313532356130643234366330363666346566623962643461363430333165663164326663336638363461633863386638313462623365633030373539363937313034663362386231663364306161646536313363373438663834323264623630663566616139366637656439653636646438306439623664316564666464636164643739316365663036306533393330383261363166656130623066393936646435346532383766373562646530316536666364643832363938636362393065336565326532333539366138373036626464303466353666633934666334313730363131323835333631313064643963353832356537326565396335326135376233333265646636656231666566316433343235666465646164343031626462386339653261303730363738376365373863303061373430303733393834326230336335376234383331656636363133353164363238326534613666326332343861376266303533643664393439363635613638323039313436356134643064663432643831663534343837346631373439373664613731373034376566363036636538333234306366353436666666623761363930323033303130303031281c320608001000181f3a60663733313362633038623964346263373934636231343034643166343832613733616335666530633032393362356337333634376465333834316230353931303636363234653939323231373264353432313262316239653661373930393038420a0a04034d5efe10a38803420a0a04d94c39a510a48803420a0a04226b4eb310a38803420a0a04034d5efe10a48803420a0a04d94c39a510a38803420a0a04226b4eb310a488034a2d486f7374656420627920434f46524120486f6c64696e6773207c204672616e6b667572742c204765726d616e79508080c4c4f0d8cd4a0a980822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063376630636364316436313465336236626139373536663766393438323030613134636235336639633333343862373431653364643064323332643135313362656231666236393531653338376264356266643935656433653961303166343930363631363330613061646437386131336131613232396533633630623238653830366639346465373266653435373634333132313566306664633161643937663830386336646133653961306164633431353937336563343862383935363634636434353261663230646161633432333232623037656433356136316362323730306364623639386131343865636662633635373935363039303433363661353534346639363563653530666539383234366664366466323537353938396564633631383565633339616432326239353233666231643261313136393430646136306164633064353564303033313565666665323130643162666235623535366230313561383335633132386434613333643566363933386363623733633165663266313230653662663030393737663765346562333137346134373434653232313561643438373337613039366264333965333266643939643533306365343261376261653535616265373362376430613338656639643062346139666432373532336236633864306461666537313631613264323864653832626362373464373531636236633238333431373638633065653036356134383136393633376239323466613463363763393164623434636166353735333838393034626464336465343062643364323935356261633135616361623937636163373335626134653764303436353433376434623732393464653430333234373431663763356634333334383962356330653538353263363535353038653135363539343530323666373363343039666162353865336163343662386637363636643534353630393534643538613465383765653562343233353463393135653332373361666662633161626461626534323565616539623739343630626437633462663330323033303130303031281d32060800100018203a60353636626538323639636636623133393964636138323038386436303735356430656463303561316231663438663366623664626233306338343235663335313462613563613062653363353436643131393930353836363138663366363635420a0a042256ba9710a38803420a0a04031451e610a48803420a0a042256ba9710a48803420a0a04031451e610a388034a22486f7374656420666f722048697461636869207c2056697267696e69612c20555341508080c4c4f0d8cd4a0ad30822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303062646339343462333836373836343062653631653165653835303062303734343764313264633762313663353762636261363362633134666638386534376433363938383765303739343939373331333563386438633562363531353561613064303830653832396333663231613037633237343665333831363365663863366237313433313831306362323865616138643735646238343035356163663962353663393663386234376335313632633661613638616639653164623638336434363337333839643963383835383064383637336338663933303562363764326236356562316135626431316535376239333065396534663235653566633431376362646133346433323164326636646137663930393765326539653364623834313435653038633638323563633133633538356436393436363230633566336165353461356562393666616230323338313536623135386332613631643435313138306137343865666362343764306632323264376338393563333735656233636563616562313165343966653337383139623939666536373533623463643831383939353038653830666531306666353435346231663364643864376236613033633232653664333034613862343366653033636338386237613836323439656564343362363238386562336239356531383131663430356362333963386333336332303865643638656239613530333937333032313330636133393735656564393937363762663964623664373630323936323463336531303462363566646237323733336532393436386533323964373063623162323536316261633436643264656261393035333963663834623662616162313735303634643036633730623939376231313035363039663038613333323136336536313939613762303432303433623664383334623164306666663438643837633639313730616162313864386435363435323766356362363836356136386163356135633633313064376531666630376437646363343339663839356335666661646463626430323033303130303031281e32060800100018213a60336533313735656138616132656337353562643334363237353331376566626633363330666666663331633665623038633763393131643464323438333435313866643862636434373463663963663532323562346332363664346630653065420a0a0405c7a65110a48803420a0a04228eace410a38803420a0a04228eace410a48803420a0a041288411610a48803420a0a041288411610a38803420a0a0405c7a65110a388034a45486f7374656420666f72204d6f6e64656cc4937a20496e7465726e6174696f6e616c207c2053696e6761706f72652c2052657075626c6963206f662053696e6761706f726550808092b7afe8f74f0a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303065306563336265386535646230626330316536383832353138633265623536373366336532613131353666353436383662633839613934333334363836336534373938366162613766333537366264343738323063356565616564633332383438343736646533333365396339383435373733383230373934303036366632643534653864343165393032373932333364633363656266303735303866616262363836393261663566316334363737333462356131313866393534313361353263383939313561363939663339643266396330376665623930346331366537393635633337666165303237653733363435376565333531336263656631613662333034343261333130663233356361373331366536316135336263393166333131373862383530386164383661333737366365383262373565353032353038636239313435353839646632653365346237323663373961386532326533396438323432626233353662656264326339363636666430653433396636383031363134663632313363373139646562366539353966646166393632316365373936373862306533656166303361626465663261633663646535613837353238643731653639363031656331373330393136663138643864346132386566373464313134323562656362626661353439313166323632333933316532303337623664396131303662343762633630633961363239366563383537653035383264613063393739663931373337646363303239616635626265333464653663323363373962333237613639663532653337633661353862616130653438376463653634323163616535343066363230393766356631323232653461373065323638353935353237363032616634313361353764383864363765373461636262326432383631323633613335396133343632333936346633346566646261363733323566333133336339613064356632306333303961653237616131623765633866376539383133363433663338306163336264663164636332363435646262613433646630323033303130303031281f32060800100018223a60656164643732666366363066616233343232386337323961366432353834616436353432633265346537383561333531643331656338333235306434383264343064656136313737666364626364366530316163623365383063396230636138420a0a0422108bf810a48803420a0a04239bd45a10a38803420a0a04239bd45a10a48803420a0a0422108bf810a388034a23486f7374656420627920426974476f207c2053746f636b686f6c6d2c2053776564656e50808092b7afe8f74f";
// Filename: src/client/addressbooks/previewnet.js
export const addressBook =
    "0a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031280032060800100018033a60666664366164613734613361333461393034626561343736303330383666386265663362366265313861626564343463346434306531326662313330623937626436623835356165633564306239306230623863373335346435663362306534420a0a0423e7d09410a38803420a0a0403d3f8ac10a48803420a0a0403d3f8ac10a38803420a0a0423e7d09410a488034a22486f7374656420627920486564657261207c204561737420436f6173742c2055534150809a9b96cab89abd020a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063353537616635373966613833353031626538393962323839303737363562666466636435326162343332623031393561316631656364383666633030616236633535303962306664643937656464336362356365613536613239356633313261626235353038333164626639363366343530313138623466636336653232636634363736323030636539636338656466626266353538646336396630323432363461643764336461623233626564323133336332373465363933343438393135356462313038376639303337303930356336343138356136323131646337343266623961363930396438323138363934376232373734363364666233666630616364343765666631326561643166363937326566326331323033373933633435653737353735626534666131313063376534306661386462396336313837643131336634373034303134313739303731616266353962653764326230646538326465343231356463323535303662316339633236653439313734303163393937353036653337376536626630336236383837323765373934306661643639633565306461336364356362643262653737373335306165613264306434376539376134343863383462653663653133346436346265653039383563323931363266346331653536376363613933643036613363316265386162636533356235353766623737663466653637316136366465633739303735366430653838313831363566326261636161383931616165376163373433376663373137356236656236646562373437323337383735316262366266396230653134383366393636386539666462643536303463333962313464396532626564656563383436613938306437303464313731653762613462376663643161333064393435636131326634376133323564393339386161313866393730363630353464346431356663383939346532646562653733653932373164353438363833663631656134346662323530373165333531386137386564336562333765373161303639316632363730323033303130303031280132060800100018043a60663064393461636366366466663337323837346339646264386437393932656233313761663530303163613431393661626132363538303963623364323030626139363161353433386333613565643035633833626466396364313135643232420a0a0423c70fb110a48803420a0a040385d59210a48803420a0a0423c70fb110a38803420a0a040385d59210a388034a22486f7374656420627920486564657261207c204561737420436f6173742c2055534150809a9b96cab89abd020a960822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039626134353762373333303566303461393163633436623162393635633465383431373531616263386231343135613062616466643166333263323438323338366132323732356562376563373464656132316535303631376436343865613561633339333734316162303162386566623332313233396238643466646231646662656239653366333961613436353830646430343564313863613434643030326333376464623532376363653464646333326266633733343139363731663463613434363461336632613834666338356337316163663065356138393632366466363961383134373465643136353239663830316138616661393765343335633465303461393634613335373532373238383834336535386630613035636635313533656534353037623263363862336437666235346165366139356139353963383761313266363330653935633762316233633336393565383538363632343137393236643736633136393833666166363132323530333837343539303765396366313364363763326163643530336361343531633835393333616334313138616363323739383031636239363833343939303331343563656432373632396464303839313633313730393335383761373763323230356366613532353433623533633362366561313562383465336432633330633165643735326134363333633336623235623938393365613032616435363265623962373836386233623466343766346132356533353630363439363261633762323565353832393434663030643330373938613236326639323134643863356537346430613833373663633264366261363465313866356534613430616661633632353036326432636132336364323830303730383332316433383334333134663065353834343835393233323637336133326537306165306437313165333130353831626364623134653837313334363934633665303933306634366233376239366434396136343537333934373333316537653530376439653536646535653631343666326630323033303130303031280232060800100018053a60636136373865626362643364633836343866376564303366623539663065323161663637353133656165653531333138653662353439626535616365393036656463316666613236643933613537616365633962653737663430656165656437420a0a04340f698210a48803420a0a0423e1c9c310a48803420a0a0423e1c9c310a38803420a0a04340f698210a388034a1f486f7374656420627920486564657261207c2043656e7472616c2c2055534150809a9b96cab89abd020a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063343263636163356662633639316662626562646138376666643165373562646364383932323439346366343466646263636565343937383835323163333738626637376462303933346563306432313833643763353164623636663836346331316162376465316163336334636664633166303933613264366633376532623334636265346338313331663936383361643432383738633833643335353463363435616131363762636662303634613833646334356335623131353834393966396439323538376666663761626364356632323163643831353035343834313330303066613665353635393038396231646664363537363665613738656165646663613662343534353566643861623539383464626533356535373935643263363335656137393734643433653865616534666562666665343932653730376234386231623066633634383161653965303964333931333330303962376432363430326536653532653565393162326233383064383866306265376662346233303365373032313937383530353761613934636539323463343932366539313635363932383665383662336261363531636132613061363364663466363930376665666533343833643933623463653164346430336337313432313131333735623263326335316434656238333965333761663533306232636264366635306434636233366532373933373137306439636464616330616365326363323462383034623061323733353163663833306237363532356532366466623964626634396130353636323461373638363234393465373236336430643730636562616539353239343365353538343266356361643133666366363061326536646366376131643533336633613562623534656332313931386337366535323562613239313436363735383331653137653336633631666538353439383832386430396237363230313534313262326535323738343962616563316366666337376465346332393463353530383131653539386666323464613135613334353639646430323033303130303031280332060800100018063a60323437316633666538313430363831666539313931336432636330363366303635653434393061653632666635643534386135616265313331643261663936636265336163323562626532343336366361346638663065373663663934356633420a0a0436f1260110a38803420a0a0423f76d8710a38803420a0a0436f1260110a48803420a0a0423f76d8710a488034a22486f7374656420627920486564657261207c205765737420436f6173742c2055534150809a9b96cab89abd020a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303266303439306139623766356432636431633064393663366136393930663537336235663065623562646262613339363631656630323330393234313933343436363939363961363861346337303731643332393939306662313739326539303031636235353938656137316332643636373638323433323065653463616266316464333537616537663261646265646331623162306139643935363233373739623463346337623437633437383761313665653731383863373231373137373632346139323634616233396334316637666630623435613839626461343063346164303763346435393664356630396437303536626362356133356634346639356135396332363665303938393264636265343661643531663264326233653939316138663636353865316632636239346337373365623434633434653839326431653535633130373666313630383331396565363537653430663139323936373534336162343261623232323338366431373538366532353337343864616264303235653530623530616536303530373230653233396436346565366662343530376330363134646434626537616664623133333038393066663361366531373635323763333131366166313239613961633565333336643966363031653731323761366437643832306164326639303264616339623234383636386131626162303864313033343265613639613730393731333266663731323063633634666364653738343063363536626131373332626139356539633336373531313735653465633364383461376530643238383432623431626262626436663238653436633361363633336531383237393635633535383230643530646165326230343635636330643432653139356239643135333265363232356562393938643661343930373961386131636434643031373564653363383766393736313438343762336362623137616133346265383230623762336164393861633366616566393933613637373839373437383263306334616533666162626363343330323033303130303031280432060800100018073a60663335373837336434313134613161656630336164633662613639656661663236393065323237616263313661366663366535303439613633666264393638383030346231346534363363323065333834333661336132346433313832646438420a0a0436b1337f10a38803420a0a0423eb413310a38803420a0a0423eb413310a48803420a0a0436b1337f10a488034a22486f7374656420627920486564657261207c205765737420436f6173742c2055534150809a9b96cab89abd020a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039316437646666663738663465666265353839303435306335626339653335333462666661646164393366623761666231356263376263663637643364336234313362643939393430646438323536346164613034616232653465646630613163306238666237653161383039326539313338653936306265326363363862356239376635376432383163353837326539376134373966633834383336333136306533383633623537623333653438363962313835616365356533366264343361653566613637386339656236366631663430313437383638323662326638666137653030363066343430356330613866396461373230356666343638336132343366613066333135663161666262346134643134306430323233346534343733666239326663623338663365623238633630636637636266623634653036396331383038366534646436313933383932306165306664376331393365366531303465363562383137656439333938653233323233376664663038333232633963656330396434303939323732613763303135643232623464636339363966366561316635313839303231303564663630303932623535613431623466333262393537623537643834653562323233393035653836393839353137333365613966326532343631656330643635323265653831366435383530666163666562343132636666396239393934336138376463306430343634343763653933623937653136643733623936623432363339363266383166636639343538653537353737633738306136663136313561613761313233323637333865323639626237333166383965383931363232653537376561353434323062663063613436626536666334663731636632363831616330323532616138383565313362653637326364323834353930343237646364313337636633313136323565386265653362303866646361616634363562333837636537636233333831366632633134613662393961633764373334333138636663353962376564393339626166656638373930323033303130303031280532060800100018083a60343933316137383230326435356631306233313537353738356333663433396462363831396264313130303364663762633263653932653239613531376237633231383830646562346330313739353734346235373663643433623834393864420a0a04235359ab10a48803420a0a04226af74110a38803420a0a04226af74110a48803420a0a04235359ab10a388034a22486f7374656420627920486564657261207c205765737420436f6173742c2055534150809a9b96cab89abd020a990822cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063366531386338666266346364346562313034353432636232306161616132353264393566303532663130383664353831633434616437333762663636373663306333663738396166353236356238616662373962353039313264613834653061666366373534376362316666663038643035323730313765623664633563646638336235313936396434343333366136333837636437306239346266346339626166323032393834306535663466383633643730383166306661383165303836336164656462386238396135646163326262353532643665376239666261323232616332386335373037353533386663393537393932393432643334316661323837366536623530376539636537656435373265386366646135646566613336346664663864386532333832396134636362623437386631316565653362333261623835653037323935316335643934323031313566626133323730373334393466343362356636626562663834313532653335366537623136626137363462376133623532636232373334363430313633626531343635653664316661346336653666363636383461363335633961353536616137313030646265363435646638663463343233616534356130386362333562346263313837383836653232393962356330323130613566626133623934343966343833656639346564393232653165393863313133626531363662383963373335383232343331333564343432333036616265356137316237373031386666333335643664643739353432363937623136383233386239363732376664313333396235663832613362366135393764393736303337616532353036343536633862333465396662663362633332343130343431633462666338656261353835393732353465666562666161373838303961356338383534373239613562613738656365313966633834303764643838393461366263373834343033376438373863616365366331353263326538396538613634623036386136633233376530393939336265383036383930323033303130303031280632060800100018093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939420a0a04227d173110a38803420a0a043212115d10a48803420a0a04227d173110a48803420a0a043212115d10a388034a22486f7374656420627920486564657261207c205765737420436f6173742c2055534150809a9b96cab89abd02";
// Filename: src/client/addressbooks/testnet.js
export const addressBook =
    "0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031280032060800100018033a60613137316533626138333437363734376165623265326163346430653131356361616162393138323033623064666531636465616234343334333866633238396162633862613861366166663833646235663162333334303436646138386338420a0a04225e6a3d10a48803420a0a04321284d310a48803420a0a04225e6a3d10a38803420a0a04321284d310a388034a056e6f64653150808092b7afe8f74f0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063353537616635373966613833353031626538393962323839303737363562666466636435326162343332623031393561316631656364383666633030616236633535303962306664643937656464336362356365613536613239356633313261626235353038333164626639363366343530313138623466636336653232636634363736323030636539636338656466626266353538646336396630323432363461643764336461623233626564323133336332373465363933343438393135356462313038376639303337303930356336343138356136323131646337343266623961363930396438323138363934376232373734363364666233666630616364343765666631326561643166363937326566326331323033373933633435653737353735626534666131313063376534306661386462396336313837643131336634373034303134313739303731616266353962653764326230646538326465343231356463323535303662316339633236653439313734303163393937353036653337376536626630336236383837323765373934306661643639633565306461336364356362643262653737373335306165613264306434376539376134343863383462653663653133346436346265653039383563323931363266346331653536376363613933643036613363316265386162636533356235353766623737663466653637316136366465633739303735366430653838313831363566326261636161383931616165376163373433376663373137356236656236646562373437323337383735316262366266396230653134383366393636386539666462643536303463333962313464396532626564656563383436613938306437303464313731653762613462376663643161333064393435636131326634376133323564393339386161313866393730363630353464346431356663383939346532646562653733653932373164353438363833663631656134346662323530373165333531386137386564336562333765373161303639316632363730323033303130303031280132060800100018043a60373430396465633265343934623632376565343963363962323934626531636561656263613366646361663336373839653838666337643562306565663535363166353262383264333531393161333963326662656436303237323637313636420a0a0423ed773710a48803420a0a0403d4060d10a38803420a0a0403d4060d10a48803420a0a0423ed773710a388034a056e6f64653250808092b7afe8f74f0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039626134353762373333303566303461393163633436623162393635633465383431373531616263386231343135613062616466643166333263323438323338366132323732356562376563373464656132316535303631376436343865613561633339333734316162303162386566623332313233396238643466646231646662656239653366333961613436353830646430343564313863613434643030326333376464623532376363653464646333326266633733343139363731663463613434363461336632613834666338356337316163663065356138393632366466363961383134373465643136353239663830316138616661393765343335633465303461393634613335373532373238383834336535386630613035636635313533656534353037623263363862336437666235346165366139356139353963383761313266363330653935633762316233633336393565383538363632343137393236643736633136393833666166363132323530333837343539303765396366313364363763326163643530336361343531633835393333616334313138616363323739383031636239363833343939303331343563656432373632396464303839313633313730393335383761373763323230356366613532353433623533633362366561313562383465336432633330633165643735326134363333633336623235623938393365613032616435363265623962373836386233623466343766346132356533353630363439363261633762323565353832393434663030643330373938613236326639323134643863356537346430613833373663633264366261363465313866356534613430616661633632353036326432636132336364323830303730383332316433383334333134663065353834343835393233323637336133326537306165306437313165333130353831626364623134653837313334363934633665303933306634366233376239366434396136343537333934373333316537653530376439653536646535653631343666326630323033303130303031280232060800100018053a60396231343136353834613461333830626238366136633764373230376438616564646263336236336561333035393938323535626365383335316261346235646361353263393238326135346136626564363064653633636530336161613234420a0a0423f51bc110a48803420a0a043414125610a38803420a0a0423f51bc110a38803420a0a043414125610a488034a056e6f64653350808092b7afe8f74f0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063343263636163356662633639316662626562646138376666643165373562646364383932323439346366343466646263636565343937383835323163333738626637376462303933346563306432313833643763353164623636663836346331316162376465316163336334636664633166303933613264366633376532623334636265346338313331663936383361643432383738633833643335353463363435616131363762636662303634613833646334356335623131353834393966396439323538376666663761626364356632323163643831353035343834313330303066613665353635393038396231646664363537363665613738656165646663613662343534353566643861623539383464626533356535373935643263363335656137393734643433653865616534666562666665343932653730376234386231623066633634383161653965303964333931333330303962376432363430326536653532653565393162326233383064383866306265376662346233303365373032313937383530353761613934636539323463343932366539313635363932383665383662336261363531636132613061363364663466363930376665666533343833643933623463653164346430336337313432313131333735623263326335316434656238333965333761663533306232636264366635306434636233366532373933373137306439636464616330616365326363323462383034623061323733353163663833306237363532356532366466623964626634396130353636323461373638363234393465373236336430643730636562616539353239343365353538343266356361643133666366363061326536646366376131643533336633613562623534656332313931386337366535323562613239313436363735383331653137653336633631666538353439383832386430396237363230313534313262326535323738343962616563316366666337376465346332393463353530383131653539386666323464613135613334353639646430323033303130303031280332060800100018063a60363438363638356234653665306362393633343732633031666539393933316664396534633434383837626138333432336165376665656432326436343834383463663861336263356363636136613337333837626639366433383637323830420a0a042253707410a48803420a0a043646c02110a38803420a0a042253707410a38803420a0a043646c02110a488034a056e6f64653450808092b7afe8f74f0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303266303439306139623766356432636431633064393663366136393930663537336235663065623562646262613339363631656630323330393234313933343436363939363961363861346337303731643332393939306662313739326539303031636235353938656137316332643636373638323433323065653463616266316464333537616537663261646265646331623162306139643935363233373739623463346337623437633437383761313665653731383863373231373137373632346139323634616233396334316637666630623435613839626461343063346164303763346435393664356630396437303536626362356133356634346639356135396332363665303938393264636265343661643531663264326233653939316138663636353865316632636239346337373365623434633434653839326431653535633130373666313630383331396565363537653430663139323936373534336162343261623232323338366431373538366532353337343864616264303235653530623530616536303530373230653233396436346565366662343530376330363134646434626537616664623133333038393066663361366531373635323763333131366166313239613961633565333336643966363031653731323761366437643832306164326639303264616339623234383636386131626162303864313033343265613639613730393731333266663731323063633634666364653738343063363536626131373332626139356539633336373531313735653465633364383461376530643238383432623431626262626436663238653436633361363633336531383237393635633535383230643530646165326230343635636330643432653139356239643135333265363232356562393938643661343930373961386131636434643031373564653363383766393736313438343762336362623137616133346265383230623762336164393861633366616566393933613637373839373437383263306334616533666162626363343330323033303130303031280432060800100018073a60333965393039393135613835323830333031353461366337373039353063376234373737626134303133353763306536313837363534323135636332306161636364643865356666323965396334643935636634313031666136386265343563420a0a0436b0c76d10a48803420a0a04225ea00410a38803420a0a0436b0c76d10a38803420a0a04225ea00410a488034a056e6f64653550808092b7afe8f74f0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039316437646666663738663465666265353839303435306335626339653335333462666661646164393366623761666231356263376263663637643364336234313362643939393430646438323536346164613034616232653465646630613163306238666237653161383039326539313338653936306265326363363862356239376635376432383163353837326539376134373966633834383336333136306533383633623537623333653438363962313835616365356533366264343361653566613637386339656236366631663430313437383638323662326638666137653030363066343430356330613866396461373230356666343638336132343366613066333135663161666262346134643134306430323233346534343733666239326663623338663365623238633630636637636266623634653036396331383038366534646436313933383932306165306664376331393365366531303465363562383137656439333938653233323233376664663038333232633963656330396434303939323732613763303135643232623464636339363966366561316635313839303231303564663630303932623535613431623466333262393537623537643834653562323233393035653836393839353137333365613966326532343631656330643635323265653831366435383530666163666562343132636666396239393934336138376463306430343634343763653933623937653136643733623936623432363339363266383166636639343538653537353737633738306136663136313561613761313233323637333865323639626237333166383965383931363232653537376561353434323062663063613436626536666334663731636632363831616330323532616138383565313362653637326364323834353930343237646364313337636633313136323565386265653362303866646361616634363562333837636537636233333831366632633134613662393961633764373334333138636663353962376564393339626166656638373930323033303130303031280532060800100018083a60613434383734613761613162333737343161303731616461616537386662313532623639366431633538643864656662653164383233303435333261306330313965653936636331396437353638363537386433396131653663333161316565420a0a04226a66da10a48803420a0a04239b319310a38803420a0a04239b319310a48803420a0a04226a66da10a388034a056e6f64653650808092b7afe8f74f0afb0722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303063366531386338666266346364346562313034353432636232306161616132353264393566303532663130383664353831633434616437333762663636373663306333663738396166353236356238616662373962353039313264613834653061666366373534376362316666663038643035323730313765623664633563646638336235313936396434343333366136333837636437306239346266346339626166323032393834306535663466383633643730383166306661383165303836336164656462386238396135646163326262353532643665376239666261323232616332386335373037353533386663393537393932393432643334316661323837366536623530376539636537656435373265386366646135646566613336346664663864386532333832396134636362623437386631316565653362333261623835653037323935316335643934323031313566626133323730373334393466343362356636626562663834313532653335366537623136626137363462376133623532636232373334363430313633626531343635653664316661346336653666363636383461363335633961353536616137313030646265363435646638663463343233616534356130386362333562346263313837383836653232393962356330323130613566626133623934343966343833656639346564393232653165393863313133626531363662383963373335383232343331333564343432333036616265356137316237373031386666333335643664643739353432363937623136383233386239363732376664313333396235663832613362366135393764393736303337616532353036343536633862333465396662663362633332343130343431633462666338656261353835393732353465666562666161373838303961356338383534373239613562613738656365313966633834303764643838393461366263373834343033376438373863616365366331353263326538396538613634623036386136633233376530393939336265383036383930323033303130303031280632060800100018093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232420a0a042285c5e610a48803420a0a04340efccf10a38803420a0a042285c5e610a38803420a0a04340efccf10a488034a056e6f64653750808092b7afe8f74f";
// Filename: src/constants/ClientConstants.js
/* NOSONAR */
import AccountId from "../account/AccountId.js";

// MAINNET node proxies are the same for both 'WebClient' and 'NativeClient'
export const MAINNET = {
    "https://grpc-web.myhbarwallet.com:443": new AccountId(3),
    "https://node00.swirldslabs.com:443": new AccountId(3),
    "https://node01-00-grpc.swirlds.com:443": new AccountId(4),
    "https://node02.swirldslabs.com:443": new AccountId(5),
    "https://node03.swirldslabs.com:443": new AccountId(6),
    "https://node04.swirldslabs.com:443": new AccountId(7),
    "https://node05.swirldslabs.com:443": new AccountId(8),
    "https://node06.swirldslabs.com:443": new AccountId(9),
    "https://node07.swirldslabs.com:443": new AccountId(10),
    "https://node09.swirldslabs.com:443": new AccountId(12),
    "https://node10.swirldslabs.com:443": new AccountId(13),
    "https://node11.swirldslabs.com:443": new AccountId(14),
    "https://node12.swirldslabs.com:443": new AccountId(15),
    "https://node14.swirldslabs.com:443": new AccountId(17),
    "https://node15.swirldslabs.com:443": new AccountId(18),
    "https://node16.swirldslabs.com:443": new AccountId(19),
    "https://node17.swirldslabs.com:443": new AccountId(20),
    "https://node18.swirldslabs.com:443": new AccountId(21),
    "https://node19.swirldslabs.com:443": new AccountId(22),
    "https://node20.swirldslabs.com:443": new AccountId(23),
    "https://node21.swirldslabs.com:443": new AccountId(24),
    "https://node22.swirldslabs.com:443": new AccountId(25),
    "https://node24.swirldslabs.com:443": new AccountId(27),
    "https://node25.swirldslabs.com:443": new AccountId(28),
    "https://node26.swirldslabs.com:443": new AccountId(29),
    "https://node27.swirldslabs.com:443": new AccountId(30),
    "https://node28.swirldslabs.com:443": new AccountId(31),
    "https://node29.swirldslabs.com:443": new AccountId(32),
    "https://node30.swirldslabs.com:443": new AccountId(33),
    "https://node31.swirldslabs.com:443": new AccountId(34),
};

export const WEB_TESTNET = {
    "https://testnet-node00-00-grpc.hedera.com:443": new AccountId(3),
    "https://testnet-node01-00-grpc.hedera.com:443": new AccountId(4),
    "https://testnet-node02-00-grpc.hedera.com:443": new AccountId(5),
    "https://testnet-node03-00-grpc.hedera.com:443": new AccountId(6),
    "https://testnet-node04-00-grpc.hedera.com:443": new AccountId(7),
    "https://testnet-node05-00-grpc.hedera.com:443": new AccountId(8),
    "https://testnet-node06-00-grpc.hedera.com:443": new AccountId(9),
};

export const WEB_PREVIEWNET = {
    "https://previewnet-node00-00-grpc.hedera.com:443": new AccountId(3),
    "https://previewnet-node01-00-grpc.hedera.com:443": new AccountId(4),
    "https://previewnet-node02-00-grpc.hedera.com:443": new AccountId(5),
    "https://previewnet-node03-00-grpc.hedera.com:443": new AccountId(6),
    "https://previewnet-node04-00-grpc.hedera.com:443": new AccountId(7),
    "https://previewnet-node05-00-grpc.hedera.com:443": new AccountId(8),
    "https://previewnet-node06-00-grpc.hedera.com:443": new AccountId(9),
};

export const NATIVE_TESTNET = {
    "https://grpc-web.testnet.myhbarwallet.com:443": new AccountId(3),
};

export const NATIVE_PREVIEWNET = {
    "https://grpc-web.previewnet.myhbarwallet.com:443": new AccountId(3),
};

/**
 * @type {Record<string, AccountId>}
 */
export const ALL_WEB_NETWORK_NODES = {
    ...MAINNET,
    ...WEB_TESTNET,
    ...WEB_PREVIEWNET,
};

/**
 * @type {Record<string, string>}
 */
export const ALL_NETWORK_IPS = {
    // MAINNET
    "34.239.82.6:": "0.0.3",
    "35.237.200.180:": "0.0.3",
    "3.130.52.236:": "0.0.4",
    "35.186.191.247:": "0.0.4",
    "3.18.18.254:": "0.0.5",
    "35.192.2.25:": "0.0.5",
    "74.50.117.35:": "0.0.5",
    "23.111.186.250:": "0.0.5",
    "107.155.64.98:": "0.0.5",
    "13.52.108.243:": "0.0.6",
    "35.199.161.108:": "0.0.6",
    "3.114.54.4:": "0.0.7",
    "35.203.82.240:": "0.0.7",
    "35.236.5.219:": "0.0.8",
    "35.183.66.150:": "0.0.8",
    "35.181.158.250:": "0.0.9",
    "35.197.192.225:": "0.0.9",
    "177.154.62.234:": "0.0.10",
    "3.248.27.48:": "0.0.10",
    "35.242.233.154:": "0.0.10",
    "35.204.86.32:": "0.0.12",
    "35.177.162.180:": "0.0.12",
    "34.215.192.104:": "0.0.13",
    "35.234.132.107:": "0.0.13",
    "52.8.21.141:": "0.0.14",
    "35.236.2.27:": "0.0.14",
    "35.228.11.53:": "0.0.15",
    "3.121.238.26:": "0.0.15",
    "34.86.212.247:": "0.0.17",
    "18.232.251.19:": "0.0.17",
    "141.94.175.187:": "0.0.18",
    "34.89.87.138:": "0.0.19",
    "18.168.4.59:": "0.0.19",
    "34.82.78.255:": "0.0.20",
    "52.39.162.216:": "0.0.20",
    "34.76.140.109:": "0.0.21",
    "13.36.123.209:": "0.0.21",
    "52.78.202.34:": "0.0.22",
    "34.64.141.166:": "0.0.22",
    "3.18.91.176:": "0.0.23",
    "35.232.244.145:": "0.0.23",
    "69.167.169.208:": "0.0.23",
    "34.89.103.38:": "0.0.24",
    "18.135.7.211:": "0.0.24",
    "34.93.112.7:": "0.0.25",
    "13.232.240.207:": "0.0.25",
    "13.56.4.96:": "0.0.27",
    "34.125.200.96:": "0.0.27",
    "35.198.220.75:": "0.0.28",
    "18.139.47.5:": "0.0.28",
    "54.74.60.120:": "0.0.29",
    "34.142.71.129:": "0.0.29",
    "80.85.70.197:": "0.0.29",
    "35.234.249.150:": "0.0.30",
    "34.201.177.212:": "0.0.30",
    "217.76.57.165:": "0.0.31",
    "3.77.94.254:": "0.0.31",
    "34.107.78.179:": "0.0.31",
    "34.86.186.151:": "0.0.32",
    "3.20.81.230:": "0.0.32",
    "18.136.65.22:": "0.0.33",
    "34.142.172.228:": "0.0.33",
    "34.16.139.248:": "0.0.34",
    "35.155.212.90:": "0.0.34",
    // TESTNET
    "34.94.106.61:": "0.0.3",
    "50.18.132.211:": "0.0.3",
    "3.212.6.13:": "0.0.4",
    "35.237.119.55:": "0.0.4",
    "35.245.27.193:": "0.0.5",
    "52.20.18.86:": "0.0.5",
    "34.83.112.116:": "0.0.6",
    "54.70.192.33:": "0.0.6",
    "34.94.160.4:": "0.0.7",
    "54.176.199.109:": "0.0.7",
    "35.155.49.147:": "0.0.8",
    "34.106.102.218:": "0.0.8",
    "34.133.197.230:": "0.0.9",
    "52.14.252.207:": "0.0.9",
    // LOCAL NODE
    "127.0.0.1:": "0.0.3",
    // PREVIEW NET
    "3.211.248.172:": "0.0.3",
    "35.231.208.148:": "0.0.3",
    "35.199.15.177:": "0.0.4",
    "3.133.213.146:": "0.0.4",
    "35.225.201.195:": "0.0.5",
    "52.15.105.130:": "0.0.5",
    "54.241.38.1:": "0.0.6",
    "35.247.109.135:": "0.0.6",
    "54.177.51.127:": "0.0.7",
    "35.235.65.51:": "0.0.7",
    "34.106.247.65:": "0.0.8",
    "35.83.89.171:": "0.0.8",
    "50.18.17.93:": "0.0.9",
    "34.125.23.49:": "0.0.9",
};
// Filename: src/contract/ContractByteCodeQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import ContractId from "./ContractId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.IContractGetBytecodeQuery} HieroProto.proto.IContractGetBytecodeQuery
 * @typedef {import("@hashgraph/proto").proto.IContractGetBytecodeResponse} HieroProto.proto.IContractGetBytecodeResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Query to retrieve the bytecode of a smart contract from the network.
 *
 * This query returns the bytecode of a smart contract instance that has been
 * created on the Hedera network. The bytecode represents the compiled code
 * that is executed by the Hedera network when the contract is called.
 *
 * @augments {Query<Uint8Array>}
 */
export default class ContractByteCodeQuery extends Query {
    /**
     * @param {object} props
     * @param {ContractId | string} [props.contractId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?ContractId}
         * @private
         */
        this._contractId = null;
        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {ContractByteCodeQuery}
     */
    static _fromProtobuf(query) {
        const bytecode =
            /** @type {HieroProto.proto.IContractGetBytecodeQuery} */ (
                query.contractGetBytecode
            );

        return new ContractByteCodeQuery({
            contractId:
                bytecode.contractID != null
                    ? ContractId._fromProtobuf(bytecode.contractID)
                    : undefined,
        });
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the info is being requested.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractByteCodeQuery}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.contractGetBytecode(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const contractGetBytecodeResponse =
            /** @type {HieroProto.proto.IContractGetBytecodeResponse} */ (
                response.contractGetBytecodeResponse
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            contractGetBytecodeResponse.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @returns {Promise<Uint8Array>}
     */
    _mapResponse(response) {
        const contractGetBytecodeResponse =
            /** @type {HieroProto.proto.IContractGetBytecodeResponse} */ (
                response.contractGetBytecodeResponse
            );

        return Promise.resolve(
            contractGetBytecodeResponse.bytecode != null
                ? contractGetBytecodeResponse.bytecode
                : new Uint8Array(),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            contractGetBytecode: {
                header,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ContractByteCodeQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("contractGetBytecode", ContractByteCodeQuery._fromProtobuf);
// Filename: src/contract/ContractCallQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import ContractId from "./ContractId.js";
import AccountId from "../account/AccountId.js";
import ContractFunctionParameters from "./ContractFunctionParameters.js";
import ContractFunctionResult from "./ContractFunctionResult.js";
import Long from "long";
import * as HieroProto from "@hashgraph/proto";
import PrecheckStatusError from "../PrecheckStatusError.js";
import Status from "../Status.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @typedef {object} FunctionParameters
 * @property {ContractFunctionParameters} parameters
 * @property {string} name
 */

/**
 * A query that calls a function of a contract instance. It will consume the amount of gas
 * specified, and return the result of the function call.
 *
 * This query will not update the state of the contract instance on the network, but will
 * only retrieve information. To update the state, you must use ContractExecuteTransaction.
 *
 * @augments {Query<ContractFunctionResult>}
 */
export default class ContractCallQuery extends Query {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     * @param {number | Long} [props.gas]
     * @param {FunctionParameters | Uint8Array} [props.functionParameters]
     * @param {number | Long} [props.maxResultSize]
     * @param {AccountId | string} [props.senderAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;
        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._gas = null;
        if (props.gas != null) {
            this.setGas(props.gas);
        }

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._functionParameters = null;
        if (props.functionParameters != null) {
            if (props.functionParameters instanceof Uint8Array) {
                this.setFunctionParameters(props.functionParameters);
            } else {
                this.setFunction(
                    props.functionParameters.name,
                    props.functionParameters.parameters,
                );
            }
        }

        /**
         * @private
         * @type {?Long}
         */
        this._maxResultSize = null;
        if (props.maxResultSize != null) {
            this.setMaxResultSize(props.maxResultSize);
        }

        /**
         * @private
         * @type {?AccountId}
         */
        this._senderAccountId = null;
        if (props.senderAccountId != null) {
            this.setSenderAccountId(props.senderAccountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {ContractCallQuery}
     */
    static _fromProtobuf(query) {
        const call = /** @type {HieroProto.proto.IContractCallLocalQuery} */ (
            query.contractCallLocal
        );

        return new ContractCallQuery({
            contractId:
                call.contractID != null
                    ? ContractId._fromProtobuf(call.contractID)
                    : undefined,
            gas: call.gas != null ? call.gas : undefined,
            functionParameters:
                call.functionParameters != null
                    ? call.functionParameters
                    : undefined,
            maxResultSize:
                call.maxResultSize != null ? call.maxResultSize : undefined,
        });
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the call is being requested.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractCallQuery}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._gas;
    }

    /**
     * @param {number | Long} gas
     * @returns {ContractCallQuery}
     */
    setGas(gas) {
        this._gas = gas instanceof Long ? gas : Long.fromValue(gas);
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get senderAccountId() {
        return this._senderAccountId;
    }

    /**
     * @param {AccountId | string} senderAccountId
     * @returns {ContractCallQuery}
     */
    setSenderAccountId(senderAccountId) {
        this._senderAccountId =
            typeof senderAccountId === "string"
                ? AccountId.fromString(senderAccountId)
                : senderAccountId;
        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get functionParameters() {
        return this._functionParameters;
    }

    /**
     * @param {Uint8Array} params
     * @returns {ContractCallQuery}
     */
    setFunctionParameters(params) {
        this._functionParameters = params;
        return this;
    }

    /**
     * @param {string} name
     * @param {?ContractFunctionParameters} [params]
     * @returns {ContractCallQuery}
     */
    setFunction(name, params) {
        this._functionParameters = (
            params != null ? params : new ContractFunctionParameters()
        )._build(name);

        return this;
    }

    /**
     * @param {number | Long} size
     * @returns {ContractCallQuery}
     */
    setMaxResultSize(size) {
        this._maxResultSize =
            size instanceof Long ? size : Long.fromValue(size);
        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    _mapStatusError(request, response, nodeId) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : HieroProto.proto.ResponseCodeEnum.OK,
        );

        const call =
            /**
             *@type {HieroProto.proto.IContractCallLocalResponse}
             */
            (response.contractCallLocal);
        if (!call.functionResult) {
            return new PrecheckStatusError({
                nodeId,
                status,
                transactionId: this._getTransactionId(),
                contractFunctionResult: null,
            });
        }

        const contractFunctionResult = this._mapResponseSync(response);

        return new PrecheckStatusError({
            nodeId,
            status,
            transactionId: this._getTransactionId(),
            contractFunctionResult,
        });
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.contractCallLocalMethod(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const contractCallLocal =
            /** @type {HieroProto.proto.IContractCallLocalResponse} */ (
                response.contractCallLocal
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            contractCallLocal.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @returns {Promise<ContractFunctionResult>}
     */
    _mapResponse(response) {
        const call =
            /**
             *@type {HieroProto.proto.IContractCallLocalResponse}
             */
            (response.contractCallLocal);

        return Promise.resolve(
            ContractFunctionResult._fromProtobuf(
                /**
                 * @type {HieroProto.proto.IContractFunctionResult}
                 */
                (call.functionResult),
                false,
            ),
        );
    }

    /**
     * @private
     * @param {HieroProto.proto.IResponse} response
     * @returns {ContractFunctionResult}
     */
    _mapResponseSync(response) {
        const call =
            /**
             *@type {HieroProto.proto.IContractCallLocalResponse}
             */
            (response.contractCallLocal);

        return ContractFunctionResult._fromProtobuf(
            /**
             * @type {HieroProto.proto.IContractFunctionResult}
             */
            (call.functionResult),
            false,
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            contractCallLocal: {
                header,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
                gas: this._gas,
                maxResultSize: this._maxResultSize,
                functionParameters: this._functionParameters,
                senderId:
                    this._senderAccountId != null
                        ? this._senderAccountId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ContractCallQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("contractCallLocal", ContractCallQuery._fromProtobuf);
// Filename: src/contract/ContractCreateFlow.js
// SPDX-License-Identifier: Apache-2.0

import FileCreateTransaction from "../file/FileCreateTransaction.js";
import FileAppendTransaction from "../file/FileAppendTransaction.js";
import FileDeleteTransaction from "../file/FileDeleteTransaction.js";
import ContractCreateTransaction from "./ContractCreateTransaction.js";
import * as utf8 from "../encoding/utf8.js";
import * as hex from "../encoding/hex.js";
import PublicKey from "../PublicKey.js";

/**
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../file/FileId.js").default} FileId
 * @typedef {import("../Key.js").default} Key
 * @typedef {import("./ContractFunctionParameters.js").default} ContractFunctionParameters
 * @typedef {import("../Hbar.js").default} Hbar
 * @typedef {import("../Duration.js").default} Duration
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../transaction/TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../Signer.js").Signer} Signer
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 * @typedef {import("../transaction/Transaction.js").default} Transaction
 */

/**
 * @typedef {import("bignumber.js").BigNumber} BigNumber
 * @typedef {import("long")} Long
 */

/**
 * A convenience flow that handles the creation of a smart contract on the Hedera network.
 * This flow abstracts away the complexity of the contract creation process by:
 *
 * 1. Creating a file to store the contract bytecode
 * 2. Uploading the contract bytecode in chunks if necessary
 * 3. Creating the contract instance using the uploaded bytecode
 * 4. Cleaning up by deleting the bytecode file (if operator key is available)
 *
 * This flow is particularly useful when deploying large contracts that exceed the 2048 byte
 * limit of a single transaction.
 */
export default class ContractCreateFlow {
    constructor() {
        /** @type {Uint8Array | null} */
        this._bytecode = null;
        this._contractCreate = new ContractCreateTransaction();

        /**
         * Read `Transaction._signerPublicKeys`
         *
         * @internal
         * @type {Set<string>}
         */
        this._signerPublicKeys = new Set();

        /**
         * Read `Transaction._publicKeys`
         *
         * @private
         * @type {PublicKey[]}
         */
        this._publicKeys = [];

        /**
         * Read `Transaction._transactionSigners`
         *
         * @private
         * @type {((message: Uint8Array) => Promise<Uint8Array>)[]}
         */
        this._transactionSigners = [];

        this._maxChunks = null;
    }

    /**
     * @returns {number | null}
     */
    get maxChunks() {
        return this._maxChunks;
    }

    /**
     * @param {number} maxChunks
     * @returns {this}
     */
    setMaxChunks(maxChunks) {
        this._maxChunks = maxChunks;
        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get bytecode() {
        return this._bytecode;
    }

    /**
     * @param {string | Uint8Array} bytecode
     * @returns {this}
     */
    setBytecode(bytecode) {
        this._bytecode =
            bytecode instanceof Uint8Array ? bytecode : utf8.encode(bytecode);

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._contractCreate.adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._contractCreate.setAdminKey(adminKey);
        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._contractCreate.gas;
    }

    /**
     * @param {number | Long} gas
     * @returns {this}
     */
    setGas(gas) {
        this._contractCreate.setGas(gas);
        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get initialBalance() {
        return this._contractCreate.initialBalance;
    }

    /**
     * Set the initial amount to transfer into this contract.
     *
     * @param {number | string | Long | BigNumber | Hbar} initialBalance
     * @returns {this}
     */
    setInitialBalance(initialBalance) {
        this._contractCreate.setInitialBalance(initialBalance);
        return this;
    }

    /**
     * @deprecated
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        // eslint-disable-next-line deprecation/deprecation
        return this._contractCreate.proxyAccountId;
    }

    /**
     * @deprecated
     * @param {AccountId | string} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        // eslint-disable-next-line deprecation/deprecation
        this._contractCreate.setProxyAccountId(proxyAccountId);
        return this;
    }

    /**
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._contractCreate.autoRenewPeriod;
    }

    /**
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._contractCreate.setAutoRenewPeriod(autoRenewPeriod);
        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get constructorParameters() {
        return this._contractCreate.constructorParameters;
    }

    /**
     * @param {Uint8Array | ContractFunctionParameters} constructorParameters
     * @returns {this}
     */
    setConstructorParameters(constructorParameters) {
        this._contractCreate.setConstructorParameters(constructorParameters);
        return this;
    }

    /**
     * @returns {?string}
     */
    get contractMemo() {
        return this._contractCreate.contractMemo;
    }

    /**
     * @param {string} contractMemo
     * @returns {this}
     */
    setContractMemo(contractMemo) {
        this._contractCreate.setContractMemo(contractMemo);
        return this;
    }

    /**
     * @returns {?number}
     */
    get maxAutomaticTokenAssociation() {
        return this._contractCreate.maxAutomaticTokenAssociations;
    }

    /**
     * @param {number} maxAutomaticTokenAssociation
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociation) {
        this._contractCreate.setMaxAutomaticTokenAssociations(
            maxAutomaticTokenAssociation,
        );

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get stakedAccountId() {
        return this._contractCreate.stakedAccountId;
    }

    /**
     * @param {AccountId | string} stakedAccountId
     * @returns {this}
     */
    setStakedAccountId(stakedAccountId) {
        this._contractCreate.setStakedAccountId(stakedAccountId);
        return this;
    }

    /**
     * @returns {?Long}
     */
    get stakedNodeId() {
        return this._contractCreate.stakedNodeId;
    }

    /**
     * @param {Long | number} stakedNodeId
     * @returns {this}
     */
    setStakedNodeId(stakedNodeId) {
        this._contractCreate.setStakedNodeId(stakedNodeId);
        return this;
    }

    /**
     * @returns {boolean}
     */
    get declineStakingRewards() {
        return this._contractCreate.declineStakingRewards;
    }

    /**
     * @param {boolean} declineStakingReward
     * @returns {this}
     */
    setDeclineStakingReward(declineStakingReward) {
        this._contractCreate.setDeclineStakingReward(declineStakingReward);
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._contractCreate.autoRenewAccountId;
    }

    /**
     * @param {string | AccountId} autoRenewAccountId
     * @returns {this}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._contractCreate.setAutoRenewAccountId(autoRenewAccountId);
        return this;
    }

    /**
     * Sign the transaction with the private key
     * **NOTE**: This is a thin wrapper around `.signWith()`
     *
     * @param {PrivateKey} privateKey
     * @returns {this}
     */
    sign(privateKey) {
        return this.signWith(privateKey.publicKey, (message) =>
            Promise.resolve(privateKey.sign(message)),
        );
    }

    /**
     * Sign the transaction with the public key and signer function
     *
     * If sign on demand is enabled no signing will be done immediately, instead
     * the private key signing function and public key are saved to be used when
     * a user calls an exit condition method (not sure what a better name for this is)
     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
     *
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {this}
     */
    signWith(publicKey, transactionSigner) {
        const publicKeyData = publicKey.toBytesRaw();
        const publicKeyHex = hex.encode(publicKeyData);

        if (this._signerPublicKeys.has(publicKeyHex)) {
            // this public key has already signed this transaction
            return this;
        }

        this._publicKeys.push(publicKey);
        this._transactionSigners.push(transactionSigner);

        return this;
    }

    /**
     * @template {Channel} ChannelT
     * @template {MirrorChannel} MirrorChannelT
     * @param {import("../client/Client.js").default<ChannelT, MirrorChannelT>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client, requestTimeout) {
        if (this._bytecode == null) {
            throw new Error("cannot create contract with no bytecode");
        }

        const key = client.operatorPublicKey;

        const fileCreateTransaction = new FileCreateTransaction()
            .setKeys(key != null ? [key] : [])
            .setContents(
                this._bytecode.subarray(
                    0,
                    Math.min(this._bytecode.length, 2048),
                ),
            )
            .freezeWith(client);
        await addSignersToTransaction(
            fileCreateTransaction,
            this._publicKeys,
            this._transactionSigners,
        );

        let response = await fileCreateTransaction.execute(
            client,
            requestTimeout,
        );
        const receipt = await response.getReceipt(client);

        const fileId = /** @type {FileId} */ (receipt.fileId);

        if (this._bytecode.length > 2048) {
            const fileAppendTransaction = new FileAppendTransaction()
                .setFileId(fileId)
                .setContents(this._bytecode.subarray(2048))
                .freezeWith(client);
            await addSignersToTransaction(
                fileAppendTransaction,
                this._publicKeys,
                this._transactionSigners,
            );
            await fileAppendTransaction.execute(client, requestTimeout);
        }

        this._contractCreate.setBytecodeFileId(fileId).freezeWith(client);

        await addSignersToTransaction(
            this._contractCreate,
            this._publicKeys,
            this._transactionSigners,
        );

        response = await this._contractCreate.execute(client, requestTimeout);
        await response.getReceipt(client);

        if (key != null) {
            const fileDeleteTransaction = new FileDeleteTransaction()
                .setFileId(fileId)
                .freezeWith(client);
            await addSignersToTransaction(
                fileDeleteTransaction,
                this._publicKeys,
                this._transactionSigners,
            );
            await (
                await fileDeleteTransaction.execute(client, requestTimeout)
            ).getReceipt(client);
        }

        return response;
    }

    /**
     * @param {Signer} signer
     * @returns {Promise<TransactionResponse>}
     */
    async executeWithSigner(signer) {
        if (this._bytecode == null) {
            throw new Error("cannot create contract with no bytecode");
        }

        if (signer.getAccountKey == null) {
            throw new Error(
                "`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`",
            );
        }
        // eslint-disable-next-line @typescript-eslint/await-thenable
        const key = await signer.getAccountKey();
        let formattedPublicKey;

        if (key instanceof PublicKey) {
            formattedPublicKey = key;
        } else {
            const propertyValues = Object.values(
                // @ts-ignore
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
                key._key._key._keyData,
            );
            const keyArray = new Uint8Array(propertyValues);

            formattedPublicKey = PublicKey.fromBytes(keyArray);
        }

        const fileCreateTransaction = await new FileCreateTransaction()
            .setKeys(formattedPublicKey != null ? [formattedPublicKey] : [])
            .setContents(
                this._bytecode.subarray(
                    0,
                    Math.min(this._bytecode.length, 2048),
                ),
            )
            .freezeWithSigner(signer);
        await fileCreateTransaction.signWithSigner(signer);
        await addSignersToTransaction(
            fileCreateTransaction,
            this._publicKeys,
            this._transactionSigners,
        );

        let response = await fileCreateTransaction.executeWithSigner(signer);
        const receipt = await response.getReceiptWithSigner(signer);

        const fileId = /** @type {FileId} */ (receipt.fileId);

        if (this._bytecode.length > 2048) {
            let fileAppendTransaction = new FileAppendTransaction()
                .setFileId(fileId)
                .setContents(this._bytecode.subarray(2048));
            if (this._maxChunks != null) {
                fileAppendTransaction.setMaxChunks(this._maxChunks);
            }
            fileAppendTransaction =
                await fileAppendTransaction.freezeWithSigner(signer);
            await fileAppendTransaction.signWithSigner(signer);
            await addSignersToTransaction(
                fileAppendTransaction,
                this._publicKeys,
                this._transactionSigners,
            );
            await fileAppendTransaction.executeWithSigner(signer);
        }

        this._contractCreate = await this._contractCreate
            .setBytecodeFileId(fileId)
            .freezeWithSigner(signer);
        this._contractCreate =
            await this._contractCreate.signWithSigner(signer);
        await addSignersToTransaction(
            this._contractCreate,
            this._publicKeys,
            this._transactionSigners,
        );

        response = await this._contractCreate.executeWithSigner(signer);

        await response.getReceiptWithSigner(signer);

        if (key != null) {
            const fileDeleteTransaction = await new FileDeleteTransaction()
                .setFileId(fileId)
                .freezeWithSigner(signer);
            await fileDeleteTransaction.signWithSigner(signer);
            await addSignersToTransaction(
                fileDeleteTransaction,
                this._publicKeys,
                this._transactionSigners,
            );
            await (
                await fileDeleteTransaction.executeWithSigner(signer)
            ).getReceiptWithSigner(signer);
        }

        return response;
    }
}

/**
 * @template {Transaction} T
 * @param {T} transaction
 * @param {PublicKey[]} publicKeys
 * @param {((message: Uint8Array) => Promise<Uint8Array>)[]} transactionSigners
 * @returns {Promise<void>}
 */
async function addSignersToTransaction(
    transaction,
    publicKeys,
    transactionSigners,
) {
    for (let i = 0; i < publicKeys.length; i++) {
        await transaction.signWith(publicKeys[i], transactionSigners[i]);
    }
}
// Filename: src/contract/ContractCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import AccountId from "../account/AccountId.js";
import FileId from "../file/FileId.js";
import ContractFunctionParameters from "./ContractFunctionParameters.js";
import Transaction, {
    DEFAULT_AUTO_RENEW_PERIOD,
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Long from "long";
import Duration from "../Duration.js";
import Key from "../Key.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IContractCreateTransactionBody} HieroProto.proto.IContractCreateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new smart contract.
 *
 * If this transaction succeeds, the `ContractID` for the new smart contract
 * SHALL be set in the transaction receipt.<br/>
 * The contract is defined by the initial bytecode (or `initcode`). The
 * `initcode` SHALL be stored either in a previously created file, or in the
 * transaction body itself for very small contracts.
 *
 * As part of contract creation, the constructor defined for the new smart
 * contract SHALL run with the parameters provided in the
 * `constructorParameters` field.<br/>
 * The gas to "power" that constructor MUST be provided via the `gas` field,
 * and SHALL be charged to the payer for this transaction.<br/>
 * If the contract _constructor_ stores information, it is charged gas for that
 * storage. There is a separate fee in HBAR to maintain that storage until the
 * expiration, and that fee SHALL be added to this transaction as part of the
 * _transaction fee_, rather than gas.
 *
 */

export default class ContractCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.bytecodeFileId]
     * @param {Uint8Array} [props.bytecode]
     * @param {Key} [props.adminKey]
     * @param {number | Long} [props.gas]
     * @param {number | string | Long | BigNumber | Hbar} [props.initialBalance]
     * @param {AccountId | string} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {Uint8Array} [props.constructorParameters]
     * @param {string} [props.contractMemo]
     * @param {number} [props.maxAutomaticTokenAssociations]
     * @param {AccountId | string} [props.stakedAccountId]
     * @param {Long | number} [props.stakedNodeId]
     * @param {boolean} [props.declineStakingReward]
     * @param {AccountId} [props.autoRenewAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._bytecodeFileId = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._bytecode = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Long}
         */
        this._gas = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._initialBalance = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._constructorParameters = null;

        /**
         * @private
         * @type {?string}
         */
        this._contractMemo = null;

        /**
         * @private
         * @type {?number}
         */
        this._maxAutomaticTokenAssociations = null;

        this._defaultMaxTransactionFee = new Hbar(20);

        /**
         * @private
         * @type {?AccountId}
         */
        this._stakedAccountId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._stakedNodeId = null;

        /**
         * @private
         * @type {boolean}
         */
        this._declineStakingReward = false;

        /**
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        if (props.bytecodeFileId != null) {
            this.setBytecodeFileId(props.bytecodeFileId);
        }

        if (props.bytecode != null) {
            this.setBytecode(props.bytecode);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.gas != null) {
            this.setGas(props.gas);
        }

        if (props.initialBalance != null) {
            this.setInitialBalance(props.initialBalance);
        }

        if (props.proxyAccountId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.constructorParameters != null) {
            this.setConstructorParameters(props.constructorParameters);
        }

        if (props.contractMemo != null) {
            this.setContractMemo(props.contractMemo);
        }

        if (props.maxAutomaticTokenAssociations != null) {
            this.setMaxAutomaticTokenAssociations(
                props.maxAutomaticTokenAssociations,
            );
        }

        if (props.stakedAccountId != null) {
            this.setStakedAccountId(props.stakedAccountId);
        }

        if (props.stakedNodeId != null) {
            this.setStakedNodeId(props.stakedNodeId);
        }

        if (props.declineStakingReward != null) {
            this.setDeclineStakingReward(props.declineStakingReward);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ContractCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const create =
            /** @type {HieroProto.proto.IContractCreateTransactionBody} */ (
                body.contractCreateInstance
            );

        return Transaction._fromProtobufTransactions(
            new ContractCreateTransaction({
                bytecodeFileId:
                    create.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {HieroProto.proto.IFileID} */ (
                                  create.fileID
                              ),
                          )
                        : undefined,
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                gas: create.gas != null ? create.gas : undefined,
                initialBalance:
                    create.initialBalance != null
                        ? Hbar.fromTinybars(create.initialBalance)
                        : undefined,
                proxyAccountId:
                    create.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  create.proxyAccountID
                              ),
                          )
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? create.autoRenewPeriod.seconds != null
                            ? create.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                constructorParameters:
                    create.constructorParameters != null
                        ? create.constructorParameters
                        : undefined,
                contractMemo: create.memo != null ? create.memo : undefined,
                maxAutomaticTokenAssociations:
                    create.maxAutomaticTokenAssociations != null
                        ? create.maxAutomaticTokenAssociations
                        : undefined,
                stakedAccountId:
                    create.stakedAccountId != null
                        ? AccountId._fromProtobuf(create.stakedAccountId)
                        : undefined,
                stakedNodeId:
                    create.stakedNodeId != null
                        ? create.stakedNodeId
                        : undefined,
                declineStakingReward: create.declineReward == true,
                autoRenewAccountId:
                    create.autoRenewAccountId != null
                        ? AccountId._fromProtobuf(create.autoRenewAccountId)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?FileId}
     */
    get bytecodeFileId() {
        return this._bytecodeFileId;
    }

    /**
     * @param {FileId | string} bytecodeFileId
     * @returns {this}
     */
    setBytecodeFileId(bytecodeFileId) {
        this._requireNotFrozen();
        this._bytecodeFileId =
            typeof bytecodeFileId === "string"
                ? FileId.fromString(bytecodeFileId)
                : bytecodeFileId.clone();
        this._bytecode = null;

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get bytecode() {
        return this._bytecode;
    }

    /**
     * @param {Uint8Array} bytecode
     * @returns {this}
     */
    setBytecode(bytecode) {
        this._requireNotFrozen();
        this._bytecode = bytecode;
        this._bytecodeFileId = null;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._gas;
    }

    /**
     * @param {number | Long} gas
     * @returns {this}
     */
    setGas(gas) {
        this._requireNotFrozen();
        this._gas = gas instanceof Long ? gas : Long.fromValue(gas);

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get initialBalance() {
        return this._initialBalance;
    }

    /**
     * Set the initial amount to transfer into this contract.
     *
     * @param {number | string | Long | BigNumber | Hbar} initialBalance
     * @returns {this}
     */
    setInitialBalance(initialBalance) {
        this._requireNotFrozen();
        this._initialBalance =
            initialBalance instanceof Hbar
                ? initialBalance
                : new Hbar(initialBalance);

        return this;
    }

    /**
     * @deprecated
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @deprecated
     * @param {AccountId | string} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId =
            proxyAccountId instanceof AccountId
                ? proxyAccountId
                : AccountId.fromString(proxyAccountId);

        return this;
    }

    /**
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * An account to charge for auto-renewal of this contract. If not set, or set to an
     * account with zero hbar balance, the contract's own hbar balance will be used to
     * cover auto-renewal fees.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get constructorParameters() {
        return this._constructorParameters;
    }

    /**
     * @param {Uint8Array | ContractFunctionParameters} constructorParameters
     * @returns {this}
     */
    setConstructorParameters(constructorParameters) {
        this._requireNotFrozen();
        this._constructorParameters =
            constructorParameters instanceof ContractFunctionParameters
                ? constructorParameters._build()
                : constructorParameters;

        return this;
    }

    /**
     * @returns {?string}
     */
    get contractMemo() {
        return this._contractMemo;
    }

    /**
     * @param {string} contractMemo
     * @returns {this}
     */
    setContractMemo(contractMemo) {
        this._requireNotFrozen();
        this._contractMemo = contractMemo;

        return this;
    }

    /**
     * @returns {?number}
     */
    get maxAutomaticTokenAssociations() {
        return this._maxAutomaticTokenAssociations;
    }

    /**
     * @param {number} maxAutomaticTokenAssociations
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
        this._maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get stakedAccountId() {
        return this._stakedAccountId;
    }

    /**
     * @param {AccountId | string} stakedAccountId
     * @returns {this}
     */
    setStakedAccountId(stakedAccountId) {
        this._requireNotFrozen();
        this._stakedAccountId =
            typeof stakedAccountId === "string"
                ? AccountId.fromString(stakedAccountId)
                : stakedAccountId;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get stakedNodeId() {
        return this._stakedNodeId;
    }

    /**
     * @param {Long | number} stakedNodeId
     * @returns {this}
     */
    setStakedNodeId(stakedNodeId) {
        this._requireNotFrozen();
        this._stakedNodeId = Long.fromValue(stakedNodeId);

        return this;
    }

    /**
     * @returns {boolean}
     */
    get declineStakingRewards() {
        return this._declineStakingReward;
    }

    /**
     * @param {boolean} declineStakingReward
     * @returns {this}
     */
    setDeclineStakingReward(declineStakingReward) {
        this._requireNotFrozen();
        this._declineStakingReward = declineStakingReward;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {string | AccountId} autoRenewAccountId
     * @returns {this}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            typeof autoRenewAccountId === "string"
                ? AccountId.fromString(autoRenewAccountId)
                : autoRenewAccountId;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._bytecodeFileId != null) {
            this._bytecodeFileId.validateChecksum(client);
        }

        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.createContract(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractCreateInstance";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IContractCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID:
                this._bytecodeFileId != null
                    ? this._bytecodeFileId._toProtobuf()
                    : null,
            initcode: this._bytecode,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            gas: this._gas,
            initialBalance:
                this._initialBalance != null
                    ? this._initialBalance.toTinybars()
                    : null,
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
            constructorParameters: this._constructorParameters,
            memo: this._contractMemo,
            maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations,
            stakedAccountId:
                this.stakedAccountId != null
                    ? this.stakedAccountId._toProtobuf()
                    : null,
            stakedNodeId: this.stakedNodeId,
            declineReward: this.declineStakingRewards,
            autoRenewAccountId:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractCreateInstance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractCreateTransaction._fromProtobuf,
);
// Filename: src/contract/ContractDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import ContractId from "./ContractId.js";
import AccountId from "../account/AccountId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IContractDeleteTransactionBody} HieroProto.proto.IContractDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a smart contract, and transfer any remaining HBAR balance to a
 * designated account.
 *
 * If this call succeeds then all subsequent calls to that smart contract
 * SHALL execute the `0x0` opcode, as required for EVM equivalence.
 *
 * ### Requirements
 *  - An account or smart contract MUST be designated to receive all remaining
 *    account balances.
 *  - The smart contract MUST have an admin key set. If the contract does not
 *    have `admin_key` set, then this transaction SHALL fail and response code
 *    `MODIFYING_IMMUTABLE_CONTRACT` SHALL be set.
 *  - If `admin_key` is, or contains, an empty `KeyList` key, it SHALL be
 *    treated the same as an admin key that is not set.
 *  - The `Key` set for `admin_key` on the smart contract MUST have a valid
 *    signature set on this transaction.
 *  - The designated receiving account MAY have `receiver_sig_required` set. If
 *    that field is set, the receiver account MUST also sign this transaction.
 *  - The field `permanent_removal` MUST NOT be set. That field is reserved for
 *    internal system use when purging the smart contract from state. Any user
 *    transaction with that field set SHALL be rejected and a response code
 *    `PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION` SHALL be set.
 */
export default class ContractDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     * @param {ContractId | string} [props.transferContractId]
     * @param {AccountId | string} [props.transferAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._transferAccountId = null;

        /**
         * @private
         * @type {?ContractId}
         */
        this._transferContractId = null;

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.transferAccountId != null) {
            this.setTransferAccountId(props.transferAccountId);
        }

        if (props.transferContractId != null) {
            this.setTransferContractId(props.transferContractId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ContractDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const contractDelete =
            /** @type {HieroProto.proto.IContractDeleteTransactionBody} */ (
                body.contractDeleteInstance
            );

        return Transaction._fromProtobufTransactions(
            new ContractDeleteTransaction({
                contractId:
                    contractDelete.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {HieroProto.proto.IContractID} */ (
                                  contractDelete.contractID
                              ),
                          )
                        : undefined,
                transferAccountId:
                    contractDelete.transferAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  contractDelete.transferAccountID
                              ),
                          )
                        : undefined,
                transferContractId:
                    contractDelete.transferContractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {HieroProto.proto.IContractID} */ (
                                  contractDelete.transferContractID
                              ),
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Sets the contract ID which is being deleted in this transaction.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractDeleteTransaction}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get transferContractId() {
        return this._transferContractId;
    }

    /**
     * Sets the contract ID which will receive all remaining hbars.
     *
     * @param {ContractId | string} transferContractId
     * @returns {ContractDeleteTransaction}
     */
    setTransferContractId(transferContractId) {
        this._requireNotFrozen();
        this._transferContractId =
            transferContractId instanceof ContractId
                ? transferContractId
                : ContractId.fromString(transferContractId);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get transferAccountId() {
        return this._transferAccountId;
    }

    /**
     * Sets the account ID which will receive all remaining hbars.
     *
     * @param {AccountId | string} transferAccountId
     * @returns {ContractDeleteTransaction}
     */
    setTransferAccountId(transferAccountId) {
        this._requireNotFrozen();
        this._transferAccountId =
            transferAccountId instanceof AccountId
                ? transferAccountId
                : AccountId.fromString(transferAccountId);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }

        if (this._transferAccountId != null) {
            this._transferAccountId.validateChecksum(client);
        }

        if (this._transferContractId != null) {
            this._transferContractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.deleteContract(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractDeleteInstance";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IContractDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            transferAccountID: this._transferAccountId
                ? this._transferAccountId._toProtobuf()
                : null,
            transferContractID:
                this._transferContractId != null
                    ? this._transferContractId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractDeleteInstance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractDeleteTransaction._fromProtobuf,
);
// Filename: src/contract/ContractExecuteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import ContractId from "./ContractId.js";
import ContractFunctionParameters from "./ContractFunctionParameters.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IContractCallTransactionBody} HieroProto.proto.IContractCallTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} FunctionParameters
 * @property {string} name
 * @property {ContractFunctionParameters} parameters
 */

/**
 * Call a function of a given smart contract, providing function parameter
 * inputs as needed.
 * <p>
 * Resource ("gas") charges SHALL include all relevant fees incurred by
 * the contract execution, including any storage required.<br/>
 * The total transaction fee SHALL incorporate all of the "gas" actually
 * consumed as well as the standard fees for transaction handling,
 * data transfers, signature verification, etc...
 */
export default class ContractExecuteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     * @param {number | Long} [props.gas]
     * @param {number | string | Long | BigNumber | Hbar} [props.amount]
     * @param {Uint8Array} [props.functionParameters]
     * @param {FunctionParameters} [props.function]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._gas = null;

        /**
         * @private
         * @type {?Hbar}
         */
        this._amount = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._functionParameters = null;

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.gas != null) {
            this.setGas(props.gas);
        }

        if (props.amount != null) {
            this.setPayableAmount(props.amount);
        }

        if (props.functionParameters != null) {
            this.setFunctionParameters(props.functionParameters);
        } else if (props.function != null) {
            this.setFunction(props.function.name, props.function.parameters);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ContractExecuteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const call =
            /** @type {HieroProto.proto.IContractCallTransactionBody} */ (
                body.contractCall
            );

        return Transaction._fromProtobufTransactions(
            new ContractExecuteTransaction({
                contractId:
                    call.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {HieroProto.proto.IContractID} */ (
                                  call.contractID
                              ),
                          )
                        : undefined,
                gas: call.gas != null ? call.gas : undefined,
                amount:
                    call.amount != null
                        ? Hbar.fromTinybars(call.amount)
                        : undefined,
                functionParameters:
                    call.functionParameters != null
                        ? call.functionParameters
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Sets the contract ID which is being executed in this transaction.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractExecuteTransaction}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get gas() {
        return this._gas;
    }

    /**
     * Sets the amount of gas to use for the call.
     *
     * @param {number | Long} gas
     * @returns {ContractExecuteTransaction}
     */
    setGas(gas) {
        this._requireNotFrozen();
        this._gas = gas instanceof Long ? gas : Long.fromValue(gas);

        return this;
    }

    /**
     * @returns {?Hbar}
     */
    get payableAmount() {
        return this._amount;
    }

    /**
     * Sets the number of hbars to be sent with this function call.
     *
     * @param {number | string | Long | BigNumber | Hbar} amount
     * @returns {ContractExecuteTransaction}
     */
    setPayableAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof Hbar ? amount : new Hbar(amount);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get functionParameters() {
        return this._functionParameters;
    }

    /**
     * @param {Uint8Array} functionParameters
     * @returns {this}
     */
    setFunctionParameters(functionParameters) {
        this._requireNotFrozen();
        this._functionParameters = functionParameters;

        return this;
    }

    /**
     * @param {string} name
     * @param {ContractFunctionParameters} [functionParameters]
     * @returns {this}
     */
    setFunction(name, functionParameters) {
        this._requireNotFrozen();
        this._functionParameters =
            functionParameters != null
                ? functionParameters._build(name)
                : new ContractFunctionParameters()._build(name);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.contractCallMethod(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractCall";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IContractCallTransactionBody}
     */
    _makeTransactionData() {
        return {
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            gas: this._gas,
            amount: this._amount != null ? this._amount.toTinybars() : null,
            functionParameters: this._functionParameters,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractExecuteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractCall",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractExecuteTransaction._fromProtobuf,
);
// Filename: src/contract/ContractFunctionParameters.js
// SPDX-License-Identifier: Apache-2.0

import ContractFunctionSelector, {
    ArgumentType,
    solidityTypeToString,
} from "./ContractFunctionSelector.js";
import * as utf8 from "../encoding/utf8.js";
import * as hex from "../encoding/hex.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import BigNumber from "bignumber.js";
import * as util from "../util.js";
import { defaultAbiCoder } from "@ethersproject/abi";
import { arrayify } from "@ethersproject/bytes";

// eslint-disable-next-line @typescript-eslint/no-unused-vars
import EvmAddress from "../EvmAddress.js";

/**
 * Class to help construct parameters for a Hedera smart contract function call.
 *
 * This class provides methods to add different types of parameters that will be passed to a smart contract function.
 * It supports all Solidity parameter types including basic types (uint/int of various sizes, bool, address),
 * arrays, strings, and bytes.
 *
 */
export default class ContractFunctionParameters {
    constructor() {
        /**
         * @type {ContractFunctionSelector}
         */
        this._selector = new ContractFunctionSelector();

        /**
         * @type {import("./ContractFunctionSelector.js").Argument[]}
         */
        this._arguments = [];
    }

    /**
     * @param {string} value
     * @returns {ContractFunctionParameters}
     */
    addString(value) {
        this._selector.addString();
        return this._addParam(value, true);
    }

    /**
     * @param {string[]} value
     * @returns {ContractFunctionParameters}
     */
    addStringArray(value) {
        this._selector.addStringArray();
        return this._addParam(value, true);
    }

    /**
     * @param {Uint8Array} value
     * @returns {ContractFunctionParameters}
     */
    addBytes(value) {
        this._selector.addBytes();
        return this._addParam(value, true);
    }

    /**
     * @param {Uint8Array} value
     * @returns {ContractFunctionParameters}
     */
    addBytes32(value) {
        if (value.length !== 32) {
            throw new Error(
                `addBytes32 expected array to be of length 32, but received ${value.length}`,
            );
        }

        this._selector.addBytes32();
        return this._addParam(value, false);
    }

    /**
     * @param {Uint8Array[]} value
     * @returns {ContractFunctionParameters}
     */
    addBytesArray(value) {
        this._selector.addBytesArray();
        return this._addParam(value, true);
    }

    /**
     * @param {Uint8Array[]} value
     * @returns {ContractFunctionParameters}
     */
    addBytes32Array(value) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, entry] of value.entries()) {
            if (entry.length !== 32) {
                throw new Error(
                    `addBytes32 expected array to be of length 32, but received ${entry.length}`,
                );
            }
        }

        this._selector.addBytes32Array();
        return this._addParam(value, true);
    }

    /**
     * @param {boolean} value
     * @returns {ContractFunctionParameters}
     */
    addBool(value) {
        this._selector.addBool();
        return this._addParam(value, false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt8(value) {
        this._selector.addInt8();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint8(value) {
        this._selector.addUint8();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt16(value) {
        this._selector.addInt16();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint16(value) {
        this._selector.addUint16();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt24(value) {
        this._selector.addInt24();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint24(value) {
        this._selector.addUint24();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt32(value) {
        this._selector.addInt32();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint32(value) {
        this._selector.addUint32();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt40(value) {
        this._selector.addInt40();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint40(value) {
        this._selector.addUint40();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt48(value) {
        this._selector.addInt48();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint48(value) {
        this._selector.addUint48();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt56(value) {
        this._selector.addInt56();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint56(value) {
        this._selector.addUint56();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt64(value) {
        this._selector.addInt64();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint64(value) {
        this._selector.addUint64();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt72(value) {
        this._selector.addInt72();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint72(value) {
        this._selector.addUint72();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt80(value) {
        this._selector.addInt80();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint80(value) {
        this._selector.addUint80();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt88(value) {
        this._selector.addInt88();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint88(value) {
        this._selector.addUint88();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt96(value) {
        this._selector.addInt96();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint96(value) {
        this._selector.addUint96();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt104(value) {
        this._selector.addInt104();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint104(value) {
        this._selector.addUint104();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt112(value) {
        this._selector.addInt112();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint112(value) {
        this._selector.addUint112();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt120(value) {
        this._selector.addInt120();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint120(value) {
        this._selector.addUint120();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt128(value) {
        this._selector.addInt128();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint128(value) {
        this._selector.addUint128();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt136(value) {
        this._selector.addInt136();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint136(value) {
        this._selector.addUint136();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt144(value) {
        this._selector.addInt144();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint144(value) {
        this._selector.addUint144();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt152(value) {
        this._selector.addInt152();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint152(value) {
        this._selector.addUint152();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt160(value) {
        this._selector.addInt160();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint160(value) {
        this._selector.addUint160();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt168(value) {
        this._selector.addInt168();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint168(value) {
        this._selector.addUint168();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt176(value) {
        this._selector.addInt176();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint176(value) {
        this._selector.addUint176();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt184(value) {
        this._selector.addInt184();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint184(value) {
        this._selector.addUint184();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt192(value) {
        this._selector.addInt192();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint192(value) {
        this._selector.addUint192();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt200(value) {
        this._selector.addInt200();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint200(value) {
        this._selector.addUint200();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt208(value) {
        this._selector.addInt208();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint208(value) {
        this._selector.addUint208();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt216(value) {
        this._selector.addInt216();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint216(value) {
        this._selector.addUint216();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt224(value) {
        this._selector.addInt224();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint224(value) {
        this._selector.addUint224();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt232(value) {
        this._selector.addInt232();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint232(value) {
        this._selector.addUint232();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt240(value) {
        this._selector.addInt240();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint240(value) {
        this._selector.addUint240();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt248(value) {
        this._selector.addInt248();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint248(value) {
        this._selector.addUint248();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addInt256(value) {
        this._selector.addInt256();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number | BigNumber | Long} value
     * @returns {ContractFunctionParameters}
     */
    addUint256(value) {
        this._selector.addUint256();
        return this._addParam(util.convertToBigNumber(value), false);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt8Array(value) {
        this._selector.addInt8Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint8Array(value) {
        this._selector.addUint8Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt16Array(value) {
        this._selector.addInt16Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint16Array(value) {
        this._selector.addUint16Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt24Array(value) {
        this._selector.addInt24Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint24Array(value) {
        this._selector.addUint24Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt32Array(value) {
        this._selector.addInt32Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint32Array(value) {
        this._selector.addUint32Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt40Array(value) {
        this._selector.addInt40Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint40Array(value) {
        this._selector.addUint40Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt48Array(value) {
        this._selector.addInt48Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint48Array(value) {
        this._selector.addUint48Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt56Array(value) {
        this._selector.addInt56Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint56Array(value) {
        this._selector.addUint56Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt64Array(value) {
        this._selector.addInt64Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint64Array(value) {
        this._selector.addUint64Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt72Array(value) {
        this._selector.addInt72Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint72Array(value) {
        this._selector.addUint72Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt80Array(value) {
        this._selector.addInt80Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint80Array(value) {
        this._selector.addUint80Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt88Array(value) {
        this._selector.addInt88Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint88Array(value) {
        this._selector.addUint88Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt96Array(value) {
        this._selector.addInt96Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint96Array(value) {
        this._selector.addUint96Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt104Array(value) {
        this._selector.addInt104Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint104Array(value) {
        this._selector.addUint104Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt112Array(value) {
        this._selector.addInt112Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint112Array(value) {
        this._selector.addUint112Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt120Array(value) {
        this._selector.addInt120Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint120Array(value) {
        this._selector.addUint120Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt128Array(value) {
        this._selector.addInt128Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint128Array(value) {
        this._selector.addUint128Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt136Array(value) {
        this._selector.addInt136Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint136Array(value) {
        this._selector.addUint136Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt144Array(value) {
        this._selector.addInt144Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint144Array(value) {
        this._selector.addUint144Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt152Array(value) {
        this._selector.addInt152Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint152Array(value) {
        this._selector.addUint152Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt160Array(value) {
        this._selector.addInt160Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint160Array(value) {
        this._selector.addUint160Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt168Array(value) {
        this._selector.addInt168Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint168Array(value) {
        this._selector.addUint168Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt176Array(value) {
        this._selector.addInt176Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint176Array(value) {
        this._selector.addUint176Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt184Array(value) {
        this._selector.addInt184Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint184Array(value) {
        this._selector.addUint184Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt192Array(value) {
        this._selector.addInt192Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint192Array(value) {
        this._selector.addUint192Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt200Array(value) {
        this._selector.addInt200Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint200Array(value) {
        this._selector.addUint200Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt208Array(value) {
        this._selector.addInt208Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint208Array(value) {
        this._selector.addUint208Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt216Array(value) {
        this._selector.addInt216Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint216Array(value) {
        this._selector.addUint216Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt224Array(value) {
        this._selector.addInt224Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint224Array(value) {
        this._selector.addUint224Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt232Array(value) {
        this._selector.addInt232Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint232Array(value) {
        this._selector.addUint232Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt240Array(value) {
        this._selector.addInt240Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint240Array(value) {
        this._selector.addUint240Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt248Array(value) {
        this._selector.addInt248Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint248Array(value) {
        this._selector.addUint248Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addInt256Array(value) {
        this._selector.addInt256Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {number[] | BigNumber[] | Long[]} value
     * @returns {ContractFunctionParameters}
     */
    addUint256Array(value) {
        this._selector.addUint256Array();
        return this._addParam(util.convertToBigNumberArray(value), true);
    }

    /**
     * @param {string | EvmAddress} value
     * @returns {ContractFunctionParameters}
     */
    addAddress(value) {
        let address;
        if (typeof value === "string") {
            // Allow `0x` prefix
            if (value.length !== 40 && value.length !== 42) {
                throw new Error(
                    "`address` type requires parameter to be 40 or 42 characters",
                );
            }
            address = value;
        } else {
            address = value.toString();
        }

        const par =
            address.length === 40
                ? hex.decode(address)
                : hex.decode(address.substring(2));

        this._selector.addAddress();

        return this._addParam(par, false);
    }

    /**
     * @param {string[] | EvmAddress[]} value
     * @returns {ContractFunctionParameters}
     */
    addAddressArray(value) {
        /**
         * @type {Uint8Array[]}
         */
        const par = [];
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, entry] of value.entries()) {
            let address;
            if (typeof entry === "string") {
                if (entry.length !== 40 && entry.length !== 42) {
                    throw new Error(
                        "`address` type requires parameter to be 40 or 42 characters",
                    );
                }
                address = entry;
            } else {
                address = entry.toString();
            }

            const buf =
                address.length === 40
                    ? hex.decode(address)
                    : hex.decode(address.substring(2));

            par.push(buf);
        }

        this._selector.addAddressArray();

        return this._addParam(par, true);
    }

    /**
     * @param {string} address
     * @param {ContractFunctionSelector} selector
     * @returns {ContractFunctionParameters}
     */
    addFunction(address, selector) {
        const addressParam = hex.decode(address);
        const functionSelector = selector._build();

        if (addressParam.length !== 20) {
            throw new Error(
                "`function` type requires parameter `address` to be exactly 20 bytes",
            );
        }

        this._selector.addFunction();

        const proto = new Uint8Array(24);
        proto.set(addressParam, 0);
        proto.set(functionSelector, 20);

        return this._addParam(proto, false);
    }

    /**
     * @internal
     * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
     * @param {boolean} dynamic
     * @returns {ContractFunctionParameters}
     */
    _addParam(param, dynamic) {
        const index = this._selector._paramTypes.length - 1;
        const value = argumentToBytes(param, this._selector._paramTypes[index]);

        this._arguments.push({ dynamic, value });
        return this;
    }

    /**
     * @internal
     * @param {string=} name
     * @returns {Uint8Array}
     */
    _build(name) {
        const includeId = name != null;
        const nameOffset = includeId ? 4 : 0;

        const length =
            this._arguments.length === 0
                ? nameOffset
                : this._arguments.length * 32 +
                  this._arguments
                      .map((arg) => (arg.dynamic ? arg.value.length : 0))
                      .reduce((sum, value) => sum + value) +
                  nameOffset;

        const func = new Uint8Array(length);

        if (includeId) {
            func.set(this._selector._build(name), 0);
        }

        let offset = 32 * this._arguments.length;

        for (const [i, { dynamic, value }] of this._arguments.entries()) {
            if (dynamic) {
                const view = util.safeView(func, nameOffset + i * 32 + 28);
                view.setUint32(0, offset);
                func.set(value, view.getUint32(0) + nameOffset);
                offset += value.length;
            } else {
                func.set(value, nameOffset + i * 32);
            }
        }

        return func;
    }
}

/**
 * @param {string | boolean | number | Uint8Array | BigNumber | string[] | boolean[] | number[] | Uint8Array[] | BigNumber[]} param
 * @param {import("./ContractFunctionSelector.js").SolidityType} ty
 * @returns {Uint8Array}
 */
function argumentToBytes(param, ty) {
    let value = new Uint8Array(32);
    let valueView = util.safeView(value);
    /** @type {Uint8Array} */
    let par;

    if (ty.array) {
        if (!Array.isArray(param)) {
            throw new TypeError(
                "SolidityType indicates type is array, but parameter is not an array",
            );
        }

        /**
         * @type {Uint8Array[]}
         */
        const values = [];

        // Generic over any type of array
        // Destructuring required so the first variable must be assigned
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [_, p] of param.entries()) {
            const arg = argumentToBytes(p, { ty: ty.ty, array: false });
            values.push(arg);
        }

        const totalLengthOfValues = values
            .map((a) => a.length)
            .reduce((total, current) => total + current, 0);

        switch (ty.ty) {
            case ArgumentType.uint8:
            case ArgumentType.int8:
            case ArgumentType.uint16:
            case ArgumentType.int16:
            case ArgumentType.uint24:
            case ArgumentType.int24:
            case ArgumentType.uint32:
            case ArgumentType.int32:
            case ArgumentType.uint40:
            case ArgumentType.int40:
            case ArgumentType.uint48:
            case ArgumentType.int48:
            case ArgumentType.uint56:
            case ArgumentType.int56:
            case ArgumentType.uint64:
            case ArgumentType.int64:
            case ArgumentType.uint72:
            case ArgumentType.int72:
            case ArgumentType.uint80:
            case ArgumentType.int80:
            case ArgumentType.uint88:
            case ArgumentType.int88:
            case ArgumentType.uint96:
            case ArgumentType.int96:
            case ArgumentType.uint104:
            case ArgumentType.int104:
            case ArgumentType.uint112:
            case ArgumentType.int112:
            case ArgumentType.uint120:
            case ArgumentType.int120:
            case ArgumentType.uint128:
            case ArgumentType.int128:
            case ArgumentType.uint136:
            case ArgumentType.int136:
            case ArgumentType.uint144:
            case ArgumentType.int144:
            case ArgumentType.uint152:
            case ArgumentType.int152:
            case ArgumentType.uint160:
            case ArgumentType.int160:
            case ArgumentType.uint168:
            case ArgumentType.int168:
            case ArgumentType.uint176:
            case ArgumentType.int176:
            case ArgumentType.uint184:
            case ArgumentType.int184:
            case ArgumentType.uint192:
            case ArgumentType.int192:
            case ArgumentType.uint200:
            case ArgumentType.int200:
            case ArgumentType.uint208:
            case ArgumentType.int208:
            case ArgumentType.uint216:
            case ArgumentType.int216:
            case ArgumentType.uint224:
            case ArgumentType.int224:
            case ArgumentType.uint232:
            case ArgumentType.int232:
            case ArgumentType.uint240:
            case ArgumentType.int240:
            case ArgumentType.uint248:
            case ArgumentType.int248:
            case ArgumentType.uint256:
            case ArgumentType.int256:
            case ArgumentType.bool:
            case ArgumentType.bytes32:
            case ArgumentType.address:
            case ArgumentType.func:
                value = new Uint8Array(totalLengthOfValues + 32);
                break;
            case ArgumentType.bytes:
            case ArgumentType.string:
                value = new Uint8Array(
                    values.length * 32 + totalLengthOfValues + 32,
                );
                break;
            default:
                throw new TypeError(
                    `Expected param type to be ArgumentType, but received ${ty.ty}`,
                );
        }

        valueView = util.safeView(value, 28);
        valueView.setUint32(0, values.length);

        let offset = 32 * values.length;

        for (const [i, e] of values.entries()) {
            switch (ty.ty) {
                case ArgumentType.uint8:
                case ArgumentType.int8:
                case ArgumentType.uint16:
                case ArgumentType.int16:
                case ArgumentType.uint24:
                case ArgumentType.int24:
                case ArgumentType.uint32:
                case ArgumentType.int32:
                case ArgumentType.uint40:
                case ArgumentType.int40:
                case ArgumentType.uint48:
                case ArgumentType.int48:
                case ArgumentType.uint56:
                case ArgumentType.int56:
                case ArgumentType.uint64:
                case ArgumentType.int64:
                case ArgumentType.uint72:
                case ArgumentType.int72:
                case ArgumentType.uint80:
                case ArgumentType.int80:
                case ArgumentType.uint88:
                case ArgumentType.int88:
                case ArgumentType.uint96:
                case ArgumentType.int96:
                case ArgumentType.uint104:
                case ArgumentType.int104:
                case ArgumentType.uint112:
                case ArgumentType.int112:
                case ArgumentType.uint120:
                case ArgumentType.int120:
                case ArgumentType.uint128:
                case ArgumentType.int128:
                case ArgumentType.uint136:
                case ArgumentType.int136:
                case ArgumentType.uint144:
                case ArgumentType.int144:
                case ArgumentType.uint152:
                case ArgumentType.int152:
                case ArgumentType.uint160:
                case ArgumentType.int160:
                case ArgumentType.uint168:
                case ArgumentType.int168:
                case ArgumentType.uint176:
                case ArgumentType.int176:
                case ArgumentType.uint184:
                case ArgumentType.int184:
                case ArgumentType.uint192:
                case ArgumentType.int192:
                case ArgumentType.uint200:
                case ArgumentType.int200:
                case ArgumentType.uint208:
                case ArgumentType.int208:
                case ArgumentType.uint216:
                case ArgumentType.int216:
                case ArgumentType.uint224:
                case ArgumentType.int224:
                case ArgumentType.uint232:
                case ArgumentType.int232:
                case ArgumentType.uint240:
                case ArgumentType.int240:
                case ArgumentType.uint248:
                case ArgumentType.int248:
                case ArgumentType.uint256:
                case ArgumentType.int256:
                case ArgumentType.bool:
                case ArgumentType.bytes32:
                case ArgumentType.address:
                case ArgumentType.func:
                    value.set(e, i * 32 + 32);
                    break;
                case ArgumentType.bytes:
                case ArgumentType.string:
                    // eslint-disable-next-line no-case-declarations
                    const view = util.safeView(value, (i + 1) * 32 + 28);
                    view.setUint32(0, offset);
                    value.set(e, view.getUint32(0) + 32);
                    offset += e.length;
                    break;
                default:
                    throw new TypeError(
                        `Expected param type to be ArgumentType, but received ${ty.ty}`,
                    );
            }
        }

        return value;
    }

    switch (ty.ty) {
        case ArgumentType.uint8:
        case ArgumentType.int8:
        case ArgumentType.uint16:
        case ArgumentType.int16:
        case ArgumentType.uint24:
        case ArgumentType.int24:
        case ArgumentType.uint32:
        case ArgumentType.int32:
        case ArgumentType.uint40:
        case ArgumentType.int40:
        case ArgumentType.uint48:
        case ArgumentType.int48:
        case ArgumentType.uint56:
        case ArgumentType.int56:
        case ArgumentType.uint64:
        case ArgumentType.int64:
        case ArgumentType.uint72:
        case ArgumentType.int72:
        case ArgumentType.uint80:
        case ArgumentType.int80:
        case ArgumentType.uint88:
        case ArgumentType.int88:
        case ArgumentType.uint96:
        case ArgumentType.int96:
        case ArgumentType.uint104:
        case ArgumentType.int104:
        case ArgumentType.uint112:
        case ArgumentType.int112:
        case ArgumentType.uint120:
        case ArgumentType.int120:
        case ArgumentType.uint128:
        case ArgumentType.int128:
        case ArgumentType.uint136:
        case ArgumentType.int136:
        case ArgumentType.uint144:
        case ArgumentType.int144:
        case ArgumentType.uint152:
        case ArgumentType.int152:
        case ArgumentType.uint160:
        case ArgumentType.int160:
        case ArgumentType.uint168:
        case ArgumentType.int168:
        case ArgumentType.uint176:
        case ArgumentType.int176:
        case ArgumentType.uint184:
        case ArgumentType.int184:
        case ArgumentType.uint192:
        case ArgumentType.int192:
        case ArgumentType.uint200:
        case ArgumentType.int200:
        case ArgumentType.uint208:
        case ArgumentType.int208:
        case ArgumentType.uint216:
        case ArgumentType.int216:
        case ArgumentType.uint224:
        case ArgumentType.int224:
        case ArgumentType.uint232:
        case ArgumentType.int232:
        case ArgumentType.uint240:
        case ArgumentType.int240:
        case ArgumentType.uint248:
        case ArgumentType.int248:
        case ArgumentType.int256:
        case ArgumentType.uint256: {
            let paramToHex = param.toString(16);

            // @ts-ignore
            if (param > 0 || param == 0) {
                paramToHex = "0x" + paramToHex;
            } else {
                paramToHex =
                    paramToHex.slice(0, 1) + "0x" + paramToHex.slice(1);
            }

            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            const encodedData = defaultAbiCoder.encode(
                [solidityTypeToString(ty)],
                [paramToHex],
            );

            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const dataToArrayify = arrayify(encodedData);
            return dataToArrayify;
        }
        case ArgumentType.address:
            value.set(/** @type {Uint8Array} */ (param), 32 - 20);
            return value;
        case ArgumentType.bool:
            value[31] = /** @type {boolean} */ (param) ? 1 : 0;
            return value;
        case ArgumentType.func:
            value.set(/** @type {Uint8Array} */ (param), 32 - 24);
            return value;
        case ArgumentType.bytes32:
            value.set(/** @type {Uint8Array} */ (param), 0);
            return value;
        // Bytes should have not the length already encoded
        // JS String type is encoded as UTF-16 whilst Solidity `string` type is UTF-8 encoded.
        // So if will assume is already correctly updated to being a Uint8Array of UTF-8 string
        case ArgumentType.bytes:
        case ArgumentType.string: {
            // If value is of type string, encode it in UTF-8 format and conver it to Uint8Array
            // Required because JS Strings are UTF-16
            // eslint-disable-next-line no-case-declarations
            par =
                param instanceof Uint8Array
                    ? param
                    : utf8.encode(/** @type {string} */ (param));

            // Resize value to a 32 byte boundary if needed
            if (Math.floor(par.length / 32) >= 0) {
                if (Math.floor(par.length % 32) !== 0) {
                    value = new Uint8Array(
                        (Math.floor(par.length / 32) + 1) * 32 + 32,
                    );
                } else {
                    value = new Uint8Array(
                        Math.floor(par.length / 32) * 32 + 32,
                    );
                }
            } else {
                value = new Uint8Array(64);
            }

            value.set(par, 32);

            valueView = util.safeView(value, 28);
            valueView.setUint32(0, par.length);
            return value;
        }
        default:
            throw new Error(`Unsupported argument type: ${ty.toString()}`);
    }
}
// Filename: src/contract/ContractFunctionResult.js
// SPDX-License-Identifier: Apache-2.0

import ContractLogInfo from "./ContractLogInfo.js";
import ContractId from "./ContractId.js";
import AccountId from "../account/AccountId.js";
import BigNumber from "bignumber.js";
import * as hex from "../encoding/hex.js";
import * as utf8 from "../encoding/utf8.js";
import * as util from "../util.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { ParamType, defaultAbiCoder } from "@ethersproject/abi";
import Long from "long";
import ContractNonceInfo from "./ContractNonceInfo.js";

/**
 * @typedef {import("./ContractStateChange.js").default} ContractStateChange
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IContractFunctionResult} HieroProto.proto.IContractFunctionResult
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 */

/**
 * The result returned by a call to a smart contract function. This is part of the response to
 * a ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
 * transaction. The ContractCreateInstance transaction record has the results of the call to
 * the constructor.
 */
export default class ContractFunctionResult {
    /**
     * Constructor isn't part of the stable API
     *
     * @param {object} result
     * @param {boolean} result._createResult
     * @param {?ContractId} result.contractId
     * @param {?string} result.errorMessage
     * @param {Uint8Array} result.bloom
     * @param {Long} result.gasUsed
     * @param {ContractLogInfo[]} result.logs
     * @param {ContractId[]} result.createdContractIds
     * @param {Uint8Array | null} result.evmAddress
     * @param {Uint8Array} result.bytes
     * @param {Long} result.gas
     * @param {Long} result.amount
     * @param {Uint8Array} result.functionParameters
     * @param {?AccountId} result.senderAccountId
     * @param {ContractStateChange[]} result.stateChanges
     * @param {ContractNonceInfo[]} result.contractNonces
     * @param {Long | null} result.signerNonce
     */
    constructor(result) {
        /**
         * Determines if this result came from `record.contractCreateResult` if true
         * or `record.contractCallResult` if false
         */
        this._createResult = result._createResult;

        /**
         * The smart contract instance whose function was called.
         */
        this.contractId = result.contractId;

        this.bytes = result.bytes;

        /**
         * Message In case there was an error during smart contract execution.
         */
        this.errorMessage = result.errorMessage;

        /**
         * Bloom filter for record
         */
        this.bloom = result.bloom;

        /**
         * Units of gas used  to execute contract.
         */
        this.gasUsed = result.gasUsed;

        /**
         * The log info for events returned by the function.
         */
        this.logs = result.logs;

        /**
         * @deprecated the list of smart contracts that were created by the function call.
         *
         * The created ids will now _also_ be externalized through internal transaction
         * records, where each record has its alias field populated with the new contract's
         * EVM address. (This is needed for contracts created with CREATE2, since
         * there is no longer a simple relationship between the new contract's 0.0.X id
         * and its Solidity address.)
         */
        // eslint-disable-next-line deprecation/deprecation
        this.createdContractIds = result.createdContractIds;

        this.evmAddress = result.evmAddress;

        /**
         * @deprecated - Use mirror node for contract traceability instead
         */
        // eslint-disable-next-line deprecation/deprecation
        this.stateChanges = result.stateChanges;

        /**
         * The amount of gas available for the call, aka the gasLimit.
         */
        this.gas = result.gas;

        /**
         * Number of tinybars sent (the function must be payable if this is nonzero).
         */
        this.amount = result.amount;

        /**
         * The parameters passed into the contract call.
         */
        this.functionParameters = result.functionParameters;

        /**
         * The account that is the "sender." If not present it is the accountId from the transactionId.
         *
         * This field should only be populated when the paired TransactionBody in the record stream is not a
         * ContractCreateTransactionBody or a ContractCallTransactionBody.
         */
        this.senderAccountId = result.senderAccountId;

        /**
         * A list of updated contract account nonces containing the new nonce value for each contract account.
         * This is always empty in a ContractCallLocalResponse#ContractFunctionResult message, since no internal creations can happen in a static EVM call.
         */
        this.contractNonces = result.contractNonces;

        /**
         * If not null this field specifies what the value of the signer account nonce is post transaction execution.
         * For transactions that don't update the signer nonce (like HAPI ContractCall and ContractCreate transactions) this field should be null.
         */
        this.signerNonce = result.signerNonce;
    }

    /**
     * @param {HieroProto.proto.IContractFunctionResult} result
     * @param {boolean} _createResult
     * @returns {ContractFunctionResult}
     */
    static _fromProtobuf(result, _createResult) {
        const contractId = /** @type {HieroProto.proto.IContractID | null} */ (
            result.contractID
        );
        const gasUsed = /** @type {Long} */ (result.gasUsed);
        const gas = /** @type {Long} */ (result.gas ? result.gas : -1);
        const amount = /** @type {Long} */ (result.amount ? result.amount : -1);

        return new ContractFunctionResult({
            _createResult,
            bytes: /** @type {Uint8Array} */ (result.contractCallResult),
            contractId:
                contractId != null
                    ? ContractId._fromProtobuf(contractId)
                    : null,
            errorMessage:
                result.errorMessage != null ? result.errorMessage : null,
            bloom: /** @type {Uint8Array} */ (result.bloom),
            gasUsed:
                gasUsed instanceof Long ? gasUsed : Long.fromValue(gasUsed),
            logs: (result.logInfo != null ? result.logInfo : []).map((info) =>
                ContractLogInfo._fromProtobuf(info),
            ),
            createdContractIds: (result.createdContractIDs != null
                ? result.createdContractIDs
                : []
            ).map((contractId) => ContractId._fromProtobuf(contractId)),
            evmAddress:
                result.evmAddress != null &&
                Object.hasOwn(result.evmAddress, "value") &&
                result.evmAddress.value != null
                    ? result.evmAddress.value
                    : null,
            stateChanges: [],
            gas: gas instanceof Long ? gas : Long.fromValue(gas),
            amount: amount instanceof Long ? amount : Long.fromValue(amount),
            functionParameters: /** @type {Uint8Array} */ (
                result.functionParameters
            ),
            senderAccountId:
                result.senderId != null
                    ? AccountId._fromProtobuf(result.senderId)
                    : null,
            contractNonces: (result.contractNonces != null
                ? result.contractNonces
                : []
            ).map((contractNonce) =>
                ContractNonceInfo._fromProtobuf(contractNonce),
            ),
            signerNonce:
                result.signerNonce != null
                    ? Object.hasOwn(result.signerNonce, "value")
                        ? result.signerNonce.value || null
                        : null
                    : null,
        });
    }

    /**
     * @returns {Uint8Array}
     */
    asBytes() {
        return this.bytes;
    }

    /**
     * @param {number} [index]
     * @returns {string}
     */
    getString(index) {
        return utf8.decode(this.getBytes(index));
    }

    /**
     * @private
     * @param {number} [index]
     * @returns {Uint8Array}
     */
    getBytes(index) {
        // Len should never be larger than Number.MAX
        // index * 32 is the position of the lenth
        // (index + 1) * 32 onward to (index + 1) * 32 + len will be the elements of the array
        // Arrays in solidity cannot be longer than 1024:
        // https://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts.html
        const offset = this.getInt32(index);
        const len = util.safeView(this.bytes).getInt32(offset + 28);

        return this.bytes.subarray(offset + 32, offset + 32 + len);
    }

    /**
     * @param {number} [index]
     * @returns {Uint8Array}
     */
    getBytes32(index) {
        return this.bytes.subarray(
            (index != null ? index : 0) * 32,
            (index != null ? index : 0) * 32 + 32,
        );
    }

    /**
     * @param {number} [index]
     * @returns {boolean}
     */
    getBool(index) {
        return this.bytes[(index != null ? index : 0) * 32 + 31] !== 0;
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getInt8(index) {
        const position = (index != null ? index : 0) * 32 + 31;
        return util.safeView(this.bytes).getInt8(position);
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getUint8(index) {
        return this.bytes[(index != null ? index : 0) * 32 + 31];
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getInt16(index) {
        // .getInt32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return util.safeView(this.bytes).getInt32(position);
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getUint16(index) {
        // .getUint32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return util.safeView(this.bytes).getUint32(position);
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getInt24(index) {
        // .getInt32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return util.safeView(this.bytes).getInt32(position);
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getUint24(index) {
        // .getUint32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return util.safeView(this.bytes).getUint32(position);
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getInt32(index) {
        // .getInt32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return util.safeView(this.bytes).getInt32(position);
    }

    /**
     * @param {number} [index]
     * @returns {number}
     */
    getUint32(index) {
        // .getUint32() interprets as big-endian
        // Using DataView instead of Uint32Array because the latter interprets
        // using platform endianness which is little-endian on x86
        const position = (index != null ? index : 0) * 32 + 28;
        return util.safeView(this.bytes).getUint32(position);
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt40(index) {
        const result = defaultAbiCoder.decode(
            ["int40"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint40(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(27, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt48(index) {
        const result = defaultAbiCoder.decode(
            ["int48"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint48(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(26, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt56(index) {
        const result = defaultAbiCoder.decode(
            ["int56"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint56(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(25, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt64(index) {
        const result = defaultAbiCoder.decode(
            ["int64"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint64(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(24, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt72(index) {
        const result = defaultAbiCoder.decode(
            ["int72"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint72(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(23, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt80(index) {
        const result = defaultAbiCoder.decode(
            ["int80"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint80(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(22, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt88(index) {
        const result = defaultAbiCoder.decode(
            ["int88"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint88(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(21, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt96(index) {
        const result = defaultAbiCoder.decode(
            ["int96"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint96(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(20, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt104(index) {
        const result = defaultAbiCoder.decode(
            ["int104"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint104(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(19, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt112(index) {
        const result = defaultAbiCoder.decode(
            ["int112"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint112(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(18, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt120(index) {
        const result = defaultAbiCoder.decode(
            ["int120"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint120(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(17, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt128(index) {
        const result = defaultAbiCoder.decode(
            ["int128"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint128(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(16, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt136(index) {
        const result = defaultAbiCoder.decode(
            ["int136"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint136(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(15, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt144(index) {
        const result = defaultAbiCoder.decode(
            ["int144"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint144(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(14, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt152(index) {
        const result = defaultAbiCoder.decode(
            ["int152"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint152(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(13, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt160(index) {
        const result = defaultAbiCoder.decode(
            ["int160"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint160(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(12, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt168(index) {
        const result = defaultAbiCoder.decode(
            ["int168"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint168(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(11, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt176(index) {
        const result = defaultAbiCoder.decode(
            ["int176"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint176(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(10, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt184(index) {
        const result = defaultAbiCoder.decode(
            ["int184"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint184(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(9, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt192(index) {
        const result = defaultAbiCoder.decode(
            ["int192"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint192(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(8, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt200(index) {
        const result = defaultAbiCoder.decode(
            ["int200"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint200(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(7, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt208(index) {
        const result = defaultAbiCoder.decode(
            ["int208"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint208(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(6, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt216(index) {
        const result = defaultAbiCoder.decode(
            ["int216"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint216(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(5, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt224(index) {
        const result = defaultAbiCoder.decode(
            ["int224"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint224(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(4, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt232(index) {
        const result = defaultAbiCoder.decode(
            ["int232"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint232(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(3, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt240(index) {
        const result = defaultAbiCoder.decode(
            ["int240"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint240(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(2, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt248(index) {
        const result = defaultAbiCoder.decode(
            ["int248"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint248(index) {
        return new BigNumber(
            hex.encode(this._getBytes32(index).subarray(1, 32)),
            16,
        );
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getInt256(index) {
        const result = defaultAbiCoder.decode(
            ["int256"],
            this._getBytes32(index != null ? index : 0),
        );
        return new BigNumber(result.toString());
    }

    /**
     * @param {number} [index]
     * @returns {BigNumber}
     */
    getUint256(index) {
        return new BigNumber(hex.encode(this._getBytes32(index)), 16);
    }

    /**
     * @param {number} [index]
     * @returns {string}
     */
    getAddress(index) {
        return hex.encode(
            this.bytes.subarray(
                (index != null ? index : 0) * 32 + 12,
                (index != null ? index : 0) * 32 + 32,
            ),
        );
    }

    /**
     * @description Decode the data according to the array of types, each of which may be a string or ParamType.
     * @param {Array<string | ParamType>} types
     * @returns {string | any}
     */
    getResult(types) {
        return defaultAbiCoder.decode(types, this.bytes);
    }

    /**
     * @param {number} [index]
     * @returns {Uint8Array}
     */
    _getBytes32(index) {
        return this.bytes.subarray(
            (index != null ? index : 0) * 32,
            (index != null ? index : 0) * 32 + 32,
        );
    }

    /**
     * @returns {HieroProto.proto.IContractFunctionResult}
     */
    _toProtobuf() {
        return {
            contractID:
                this.contractId != null ? this.contractId._toProtobuf() : null,
            contractCallResult: this.bytes,
            errorMessage: this.errorMessage,
            bloom: this.bloom,
            gasUsed: this.gasUsed,
            logInfo: this.logs.map((log) => log._toProtobuf()),
            // eslint-disable-next-line deprecation/deprecation
            createdContractIDs: this.createdContractIds.map((id) =>
                id._toProtobuf(),
            ),
            evmAddress:
                this.evmAddress != null
                    ? {
                          value: this.evmAddress,
                      }
                    : null,
            gas: this.gas,
            amount: this.amount,
            functionParameters: this.functionParameters,
            senderId:
                this.senderAccountId != null
                    ? this.senderAccountId._toProtobuf()
                    : null,
            contractNonces: this.contractNonces.map((contractNonce) =>
                contractNonce._toProtobuf(),
            ),
            signerNonce:
                this.signerNonce != null
                    ? {
                          value: this.signerNonce,
                      }
                    : null,
        };
    }
}
// Filename: src/contract/ContractFunctionSelector.js
// SPDX-License-Identifier: Apache-2.0

import { keccak256 } from "../cryptography/keccak.js";
import * as hex from "../encoding/hex.js";
import * as utf8 from "../encoding/utf8.js";

/**
 * @enum {number}
 */
export const ArgumentType = {
    uint8: 0,
    int8: 1,
    uint16: 2,
    int16: 3,
    uint24: 4,
    int24: 5,
    uint32: 6,
    int32: 7,
    uint40: 8,
    int40: 9,
    uint48: 10,
    int48: 11,
    uint56: 12,
    int56: 13,
    uint64: 14,
    int64: 15,
    uint72: 16,
    int72: 17,
    uint80: 18,
    int80: 19,
    uint88: 20,
    int88: 21,
    uint96: 22,
    int96: 23,
    uint104: 24,
    int104: 25,
    uint112: 26,
    int112: 27,
    uint120: 28,
    int120: 29,
    uint128: 30,
    int128: 31,
    uint136: 32,
    int136: 33,
    uint144: 34,
    int144: 35,
    uint152: 36,
    int152: 37,
    uint160: 38,
    int160: 39,
    uint168: 40,
    int168: 41,
    uint176: 42,
    int176: 43,
    uint184: 44,
    int184: 45,
    uint192: 46,
    int192: 47,
    uint200: 48,
    int200: 49,
    uint208: 50,
    int208: 51,
    uint216: 52,
    int216: 53,
    uint224: 54,
    int224: 55,
    uint232: 56,
    int232: 57,
    uint240: 58,
    int240: 59,
    uint248: 60,
    int248: 61,
    uint256: 62,
    int256: 63,
    string: 64,
    bool: 65,
    bytes: 66,
    bytes32: 67,
    address: 68,
    func: 69,
};

/**
 * @typedef {object} Argument
 * @property {boolean} dynamic
 * @property {Uint8Array} value
 */

/**
 * @typedef {object} SolidityType
 * @property {ArgumentType} ty
 * @property {boolean} array
 */

/**
 * Class to help construct function selectors for Hedera smart contract function calls.
 * Function selectors are the first 4 bytes of the Keccak-256 hash of the function's signature.
 *
 * This class provides methods to build function signatures by adding parameters of various Solidity types.
 * It supports all standard Solidity parameter types and their array variants.
 */
export default class ContractFunctionSelector {
    /**
     * @param {string} [name]
     */
    constructor(name) {
        /**
         * @type {?string}
         */
        this.name = null;

        /**
         * @type {string}
         */
        this._params = "";

        /**
         * @type {SolidityType[]}
         */
        this._paramTypes = [];

        if (name != null) {
            this._name = name;
        }
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addString() {
        return this._addParam({ ty: ArgumentType.string, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addStringArray() {
        return this._addParam({ ty: ArgumentType.string, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytes() {
        return this._addParam({ ty: ArgumentType.bytes, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytes32() {
        return this._addParam({ ty: ArgumentType.bytes32, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytesArray() {
        return this._addParam({ ty: ArgumentType.bytes, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBytes32Array() {
        return this._addParam({ ty: ArgumentType.bytes32, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt8() {
        return this._addParam({ ty: ArgumentType.int8, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint8() {
        return this._addParam({ ty: ArgumentType.uint8, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt16() {
        return this._addParam({ ty: ArgumentType.int16, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint16() {
        return this._addParam({ ty: ArgumentType.uint16, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt24() {
        return this._addParam({ ty: ArgumentType.int24, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint24() {
        return this._addParam({ ty: ArgumentType.uint24, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt32() {
        return this._addParam({ ty: ArgumentType.int32, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint32() {
        return this._addParam({ ty: ArgumentType.uint32, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt40() {
        return this._addParam({ ty: ArgumentType.int40, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint40() {
        return this._addParam({ ty: ArgumentType.uint40, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt48() {
        return this._addParam({ ty: ArgumentType.int48, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint48() {
        return this._addParam({ ty: ArgumentType.uint48, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt56() {
        return this._addParam({ ty: ArgumentType.int56, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint56() {
        return this._addParam({ ty: ArgumentType.uint56, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt64() {
        return this._addParam({ ty: ArgumentType.int64, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint64() {
        return this._addParam({ ty: ArgumentType.uint64, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt72() {
        return this._addParam({ ty: ArgumentType.int72, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint72() {
        return this._addParam({ ty: ArgumentType.uint72, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt80() {
        return this._addParam({ ty: ArgumentType.int80, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint80() {
        return this._addParam({ ty: ArgumentType.uint80, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt88() {
        return this._addParam({ ty: ArgumentType.int88, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint88() {
        return this._addParam({ ty: ArgumentType.uint88, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt96() {
        return this._addParam({ ty: ArgumentType.int96, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint96() {
        return this._addParam({ ty: ArgumentType.uint96, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt104() {
        return this._addParam({ ty: ArgumentType.int104, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint104() {
        return this._addParam({ ty: ArgumentType.uint104, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt112() {
        return this._addParam({ ty: ArgumentType.int112, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint112() {
        return this._addParam({ ty: ArgumentType.uint112, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt120() {
        return this._addParam({ ty: ArgumentType.int120, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint120() {
        return this._addParam({ ty: ArgumentType.uint120, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt128() {
        return this._addParam({ ty: ArgumentType.int128, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint128() {
        return this._addParam({ ty: ArgumentType.uint128, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt136() {
        return this._addParam({ ty: ArgumentType.int136, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint136() {
        return this._addParam({ ty: ArgumentType.uint136, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt144() {
        return this._addParam({ ty: ArgumentType.int144, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint144() {
        return this._addParam({ ty: ArgumentType.uint144, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt152() {
        return this._addParam({ ty: ArgumentType.int152, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint152() {
        return this._addParam({ ty: ArgumentType.uint152, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt160() {
        return this._addParam({ ty: ArgumentType.int160, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint160() {
        return this._addParam({ ty: ArgumentType.uint160, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt168() {
        return this._addParam({ ty: ArgumentType.int168, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint168() {
        return this._addParam({ ty: ArgumentType.uint168, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt176() {
        return this._addParam({ ty: ArgumentType.int176, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint176() {
        return this._addParam({ ty: ArgumentType.uint176, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt184() {
        return this._addParam({ ty: ArgumentType.int184, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint184() {
        return this._addParam({ ty: ArgumentType.uint184, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt192() {
        return this._addParam({ ty: ArgumentType.int192, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint192() {
        return this._addParam({ ty: ArgumentType.uint192, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt200() {
        return this._addParam({ ty: ArgumentType.int200, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint200() {
        return this._addParam({ ty: ArgumentType.uint200, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt208() {
        return this._addParam({ ty: ArgumentType.int208, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint208() {
        return this._addParam({ ty: ArgumentType.uint208, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt216() {
        return this._addParam({ ty: ArgumentType.int216, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint216() {
        return this._addParam({ ty: ArgumentType.uint216, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt224() {
        return this._addParam({ ty: ArgumentType.int224, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint224() {
        return this._addParam({ ty: ArgumentType.uint224, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt232() {
        return this._addParam({ ty: ArgumentType.int232, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint232() {
        return this._addParam({ ty: ArgumentType.uint232, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt240() {
        return this._addParam({ ty: ArgumentType.int240, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint240() {
        return this._addParam({ ty: ArgumentType.uint240, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt248() {
        return this._addParam({ ty: ArgumentType.int248, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint248() {
        return this._addParam({ ty: ArgumentType.uint248, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt256() {
        return this._addParam({ ty: ArgumentType.int256, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint256() {
        return this._addParam({ ty: ArgumentType.uint256, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt8Array() {
        return this._addParam({ ty: ArgumentType.int8, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint8Array() {
        return this._addParam({ ty: ArgumentType.uint8, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt16Array() {
        return this._addParam({ ty: ArgumentType.int16, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint16Array() {
        return this._addParam({ ty: ArgumentType.uint16, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt24Array() {
        return this._addParam({ ty: ArgumentType.int24, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint24Array() {
        return this._addParam({ ty: ArgumentType.uint24, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt32Array() {
        return this._addParam({ ty: ArgumentType.int32, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint32Array() {
        return this._addParam({ ty: ArgumentType.uint32, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt40Array() {
        return this._addParam({ ty: ArgumentType.int40, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint40Array() {
        return this._addParam({ ty: ArgumentType.uint40, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt48Array() {
        return this._addParam({ ty: ArgumentType.int48, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint48Array() {
        return this._addParam({ ty: ArgumentType.uint48, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt56Array() {
        return this._addParam({ ty: ArgumentType.int56, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint56Array() {
        return this._addParam({ ty: ArgumentType.uint56, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt64Array() {
        return this._addParam({ ty: ArgumentType.int64, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint64Array() {
        return this._addParam({ ty: ArgumentType.uint64, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt72Array() {
        return this._addParam({ ty: ArgumentType.int72, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint72Array() {
        return this._addParam({ ty: ArgumentType.uint72, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt80Array() {
        return this._addParam({ ty: ArgumentType.int80, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint80Array() {
        return this._addParam({ ty: ArgumentType.uint80, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt88Array() {
        return this._addParam({ ty: ArgumentType.int88, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint88Array() {
        return this._addParam({ ty: ArgumentType.uint88, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt96Array() {
        return this._addParam({ ty: ArgumentType.int96, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint96Array() {
        return this._addParam({ ty: ArgumentType.uint96, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt104Array() {
        return this._addParam({ ty: ArgumentType.int104, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint104Array() {
        return this._addParam({ ty: ArgumentType.uint104, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt112Array() {
        return this._addParam({ ty: ArgumentType.int112, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint112Array() {
        return this._addParam({ ty: ArgumentType.uint112, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt120Array() {
        return this._addParam({ ty: ArgumentType.int120, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint120Array() {
        return this._addParam({ ty: ArgumentType.uint120, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt128Array() {
        return this._addParam({ ty: ArgumentType.int128, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint128Array() {
        return this._addParam({ ty: ArgumentType.uint128, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt136Array() {
        return this._addParam({ ty: ArgumentType.int136, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint136Array() {
        return this._addParam({ ty: ArgumentType.uint136, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt144Array() {
        return this._addParam({ ty: ArgumentType.int144, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint144Array() {
        return this._addParam({ ty: ArgumentType.uint144, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt152Array() {
        return this._addParam({ ty: ArgumentType.int152, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint152Array() {
        return this._addParam({ ty: ArgumentType.uint152, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt160Array() {
        return this._addParam({ ty: ArgumentType.int160, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint160Array() {
        return this._addParam({ ty: ArgumentType.uint160, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt168Array() {
        return this._addParam({ ty: ArgumentType.int168, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint168Array() {
        return this._addParam({ ty: ArgumentType.uint168, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt176Array() {
        return this._addParam({ ty: ArgumentType.int176, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint176Array() {
        return this._addParam({ ty: ArgumentType.uint176, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt184Array() {
        return this._addParam({ ty: ArgumentType.int184, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint184Array() {
        return this._addParam({ ty: ArgumentType.uint184, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt192Array() {
        return this._addParam({ ty: ArgumentType.int192, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint192Array() {
        return this._addParam({ ty: ArgumentType.uint192, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt200Array() {
        return this._addParam({ ty: ArgumentType.int200, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint200Array() {
        return this._addParam({ ty: ArgumentType.uint200, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt208Array() {
        return this._addParam({ ty: ArgumentType.int208, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint208Array() {
        return this._addParam({ ty: ArgumentType.uint208, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt216Array() {
        return this._addParam({ ty: ArgumentType.int216, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint216Array() {
        return this._addParam({ ty: ArgumentType.uint216, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt224Array() {
        return this._addParam({ ty: ArgumentType.int224, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint224Array() {
        return this._addParam({ ty: ArgumentType.uint224, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt232Array() {
        return this._addParam({ ty: ArgumentType.int232, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint232Array() {
        return this._addParam({ ty: ArgumentType.uint232, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt240Array() {
        return this._addParam({ ty: ArgumentType.int240, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint240Array() {
        return this._addParam({ ty: ArgumentType.uint240, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt248Array() {
        return this._addParam({ ty: ArgumentType.int248, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint248Array() {
        return this._addParam({ ty: ArgumentType.uint248, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addInt256Array() {
        return this._addParam({ ty: ArgumentType.int256, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addUint256Array() {
        return this._addParam({ ty: ArgumentType.uint256, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addBool() {
        return this._addParam({ ty: ArgumentType.bool, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addAddress() {
        return this._addParam({ ty: ArgumentType.address, array: false });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addAddressArray() {
        return this._addParam({ ty: ArgumentType.address, array: true });
    }

    /**
     * @returns {ContractFunctionSelector}
     */
    addFunction() {
        return this._addParam({ ty: ArgumentType.func, array: false });
    }

    /**
     * @param {SolidityType} ty
     * @returns {ContractFunctionSelector}
     */
    _addParam(ty) {
        if (this._paramTypes.length > 0) {
            this._params += ",";
        }

        this._params += solidityTypeToString(ty);
        this._paramTypes.push(ty);

        return this;
    }

    /**
     * @param {string} [name]
     * @returns {Uint8Array}
     */
    _build(name) {
        if (name != null) {
            this._name = name;
        } else if (this._name == null) {
            throw new Error("`name` required for ContractFunctionSelector");
        }

        const func = hex.encode(utf8.encode(this.toString()));
        return hex.decode(keccak256(`0x${func}`)).slice(0, 4);
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this._name != null ? this._name.toString() : ""}(${
            this._params
        })`;
    }
}

/**
 * @param {SolidityType} ty
 * @returns {string}
 */
export function solidityTypeToString(ty) {
    let s = "";
    switch (ty.ty) {
        case ArgumentType.uint8:
            s = "uint8";
            break;
        case ArgumentType.int8:
            s = "int8";
            break;
        case ArgumentType.uint16:
            s = "uint16";
            break;
        case ArgumentType.int16:
            s = "int16";
            break;
        case ArgumentType.uint24:
            s = "uint24";
            break;
        case ArgumentType.int24:
            s = "int24";
            break;
        case ArgumentType.uint32:
            s = "uint32";
            break;
        case ArgumentType.int32:
            s = "int32";
            break;
        case ArgumentType.uint40:
            s = "uint40";
            break;
        case ArgumentType.int40:
            s = "int40";
            break;
        case ArgumentType.uint48:
            s = "uint48";
            break;
        case ArgumentType.int48:
            s = "int48";
            break;
        case ArgumentType.uint56:
            s = "uint56";
            break;
        case ArgumentType.int56:
            s = "int56";
            break;
        case ArgumentType.uint64:
            s = "uint64";
            break;
        case ArgumentType.int64:
            s = "int64";
            break;
        case ArgumentType.uint72:
            s = "uint72";
            break;
        case ArgumentType.int72:
            s = "int72";
            break;
        case ArgumentType.uint80:
            s = "uint80";
            break;
        case ArgumentType.int80:
            s = "int80";
            break;
        case ArgumentType.uint88:
            s = "uint88";
            break;
        case ArgumentType.int88:
            s = "int88";
            break;
        case ArgumentType.uint96:
            s = "uint96";
            break;
        case ArgumentType.int96:
            s = "int96";
            break;
        case ArgumentType.uint104:
            s = "uint104";
            break;
        case ArgumentType.int104:
            s = "int104";
            break;
        case ArgumentType.uint112:
            s = "uint112";
            break;
        case ArgumentType.int112:
            s = "int112";
            break;
        case ArgumentType.uint120:
            s = "uint120";
            break;
        case ArgumentType.int120:
            s = "int120";
            break;
        case ArgumentType.uint128:
            s = "uint128";
            break;
        case ArgumentType.int128:
            s = "int128";
            break;
        case ArgumentType.uint136:
            s = "uint136";
            break;
        case ArgumentType.int136:
            s = "int136";
            break;
        case ArgumentType.uint144:
            s = "uint144";
            break;
        case ArgumentType.int144:
            s = "int144";
            break;
        case ArgumentType.uint152:
            s = "uint152";
            break;
        case ArgumentType.int152:
            s = "int152";
            break;
        case ArgumentType.uint160:
            s = "uint160";
            break;
        case ArgumentType.int160:
            s = "int160";
            break;
        case ArgumentType.uint168:
            s = "uint168";
            break;
        case ArgumentType.int168:
            s = "int168";
            break;
        case ArgumentType.uint176:
            s = "uint176";
            break;
        case ArgumentType.int176:
            s = "int176";
            break;
        case ArgumentType.uint184:
            s = "uint184";
            break;
        case ArgumentType.int184:
            s = "int184";
            break;
        case ArgumentType.uint192:
            s = "uint192";
            break;
        case ArgumentType.int192:
            s = "int192";
            break;
        case ArgumentType.uint200:
            s = "uint200";
            break;
        case ArgumentType.int200:
            s = "int200";
            break;
        case ArgumentType.uint208:
            s = "uint208";
            break;
        case ArgumentType.int208:
            s = "int208";
            break;
        case ArgumentType.uint216:
            s = "uint216";
            break;
        case ArgumentType.int216:
            s = "int216";
            break;
        case ArgumentType.uint224:
            s = "uint224";
            break;
        case ArgumentType.int224:
            s = "int224";
            break;
        case ArgumentType.uint232:
            s = "uint232";
            break;
        case ArgumentType.int232:
            s = "int232";
            break;
        case ArgumentType.uint240:
            s = "uint240";
            break;
        case ArgumentType.int240:
            s = "int240";
            break;
        case ArgumentType.uint248:
            s = "uint248";
            break;
        case ArgumentType.int248:
            s = "int248";
            break;
        case ArgumentType.uint256:
            s = "uint256";
            break;
        case ArgumentType.int256:
            s = "int256";
            break;
        case ArgumentType.string:
            s = "string";
            break;
        case ArgumentType.bool:
            s = "bool";
            break;
        case ArgumentType.bytes:
            s = "bytes";
            break;
        case ArgumentType.bytes32:
            s = "bytes32";
            break;
        case ArgumentType.address:
            s = "address";
            break;
        case ArgumentType.func:
            s = "function";
            break;
        default:
            s = "";
            break;
    }

    if (ty.array) {
        s += "[]";
    }

    return s;
}
// Filename: src/contract/ContractId.js
// SPDX-License-Identifier: Apache-2.0

import * as entity_id from "../EntityIdHelper.js";
import Key from "../Key.js";
import * as HieroProto from "@hashgraph/proto";
import CACHE from "../Cache.js";
import * as hex from "../encoding/hex.js";
import { arrayEqual } from "../array.js";
import Long from "long";
import { isLongZeroAddress } from "../util.js";

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency contract on Hedera.
 */
export default class ContractId extends Key {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     * @param {Uint8Array=} evmAddress
     */
    constructor(props, realm, num, evmAddress) {
        super();

        const result = entity_id.constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        this.evmAddress = evmAddress != null ? evmAddress : null;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @description This handles both long-zero format and evm address format addresses.
     * If an actual evm address is passed, please use `ContractId.populateAccountNum(client)` method
     * to get the actual `num` value, since there is no cryptographic relation to the evm address
     * and cannot be populated directly
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @param {string} evmAddress
     * @returns {ContractId}
     */
    static fromEvmAddress(shard, realm, evmAddress) {
        if (isLongZeroAddress(hex.decode(evmAddress))) {
            return new ContractId(...entity_id.fromSolidityAddress(evmAddress));
        } else {
            return new ContractId(shard, realm, 0, hex.decode(evmAddress));
        }
    }

    /**
     * @param {string} text
     * @returns {ContractId}
     */
    static fromString(text) {
        const result = entity_id.fromStringSplitter(text);

        if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {
            throw new Error("invalid format for entity ID");
        }

        const shard =
            result.shard != null ? Long.fromString(result.shard) : Long.ZERO;
        const realm =
            result.realm != null ? Long.fromString(result.realm) : Long.ZERO;
        const [num, evmAddress] =
            result.numOrHex.length < 40
                ? [Long.fromString(result.numOrHex), undefined]
                : [Long.ZERO, hex.decode(result.numOrHex)];

        return new ContractId(shard, realm, num, evmAddress);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IContractID} id
     * @returns {ContractId}
     */
    static _fromProtobuf(id) {
        const contractId = new ContractId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.contractNum != null ? id.contractNum : 0,
        );

        return contractId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @description Gets the actual `num` field of the `ContractId` from the Mirror Node.
     * Should be used after generating `ContractId.fromEvmAddress()` because it sets the `num` field to `0`
     * automatically since there is no connection between the `num` and the `evmAddress`
     * @param {Client} client
     * @returns {Promise<ContractId>}
     */
    async populateAccountNum(client) {
        if (this.evmAddress === null) {
            throw new Error("field `evmAddress` should not be null");
        }
        const mirrorUrl = client.mirrorNetwork[0].slice(
            0,
            client.mirrorNetwork[0].indexOf(":"),
        );

        /* eslint-disable */
        const url = `https://${mirrorUrl}/api/v1/contracts/${hex.encode(
            this.evmAddress,
        )}`;
        const response = await fetch(url);
        const data = await response.json();
        const mirrorAccountId = data.contract_id;

        this.num = Long.fromString(
            mirrorAccountId.slice(mirrorAccountId.lastIndexOf(".") + 1),
        );
        /* eslint-enable */

        return this;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        entity_id.validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ContractId}
     */
    static fromBytes(bytes) {
        return ContractId._fromProtobuf(
            HieroProto.proto.ContractID.decode(bytes),
        );
    }

    /**
     * @deprecated - Use `fromEvmAddress` instead
     * @param {string} address
     * @returns {ContractId}
     */
    static fromSolidityAddress(address) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (isLongZeroAddress(hex.decode(address))) {
            return new ContractId(...entity_id.fromSolidityAddress(address));
        } else {
            return this.fromEvmAddress(0, 0, address);
        }
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        if (this.evmAddress != null) {
            return hex.encode(this.evmAddress);
        } else {
            return entity_id.toSolidityAddress([
                this.shard,
                this.realm,
                this.num,
            ]);
        }
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IContractID}
     */
    _toProtobuf() {
        return {
            contractNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
            evmAddress: this.evmAddress,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this.evmAddress != null) {
            return `${this.shard.toString()}.${this.realm.toString()}.${hex.encode(
                this.evmAddress,
            )}`;
        } else {
            return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
        }
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return entity_id.toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.ContractID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {ContractId}
     */
    clone() {
        const id = new ContractId(this);
        id._checksum = this._checksum;
        id.evmAddress = this.evmAddress;
        return id;
    }

    /**
     * @param {ContractId} other
     * @returns {number}
     */
    compare(other) {
        return entity_id.compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num],
        );
    }

    /**
     * @param {this} other
     * @returns {boolean}
     */
    equals(other) {
        let evmAddresses = false;
        if (this.evmAddress != null && other.evmAddress != null) {
            evmAddresses = arrayEqual(this.evmAddress, other.evmAddress);
        }

        return (
            this.shard.eq(other.shard) &&
            this.realm.eq(other.realm) &&
            this.num.eq(other.num) &&
            evmAddresses
        );
    }

    /**
     * @returns {HieroProto.proto.IKey}
     */
    _toProtobufKey() {
        return {
            contractID: this._toProtobuf(),
        };
    }

    /**
     * @param {HieroProto.proto.IContractID} key
     * @returns {ContractId}
     */
    static __fromProtobufKey(key) {
        return ContractId._fromProtobuf(key);
    }
}

CACHE.setContractId((key) => ContractId.__fromProtobufKey(key));
// Filename: src/contract/ContractInfo.js
// SPDX-License-Identifier: Apache-2.0

import ContractId from "./ContractId.js";
import AccountId from "../account/AccountId.js";
import StakingInfo from "../StakingInfo.js";
import Timestamp from "../Timestamp.js";
import Duration from "../Duration.js";
import Hbar from "../Hbar.js";
import Long from "long";
import * as HieroProto from "@hashgraph/proto";
import TokenRelationshipMap from "../account/TokenRelationshipMap.js";
import Key from "../Key.js";
import LedgerId from "../LedgerId.js";

const { proto } = HieroProto;

/**
 * @typedef {import("../StakingInfo.js").StakingInfoJson} StakingInfoJson
 */

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
export default class ContractInfo {
    /**
     * @private
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {AccountId} props.accountId
     * @param {string} props.contractAccountId
     * @param {?Key} props.adminKey
     * @param {Timestamp} props.expirationTime
     * @param {Duration} props.autoRenewPeriod
     * @param {?AccountId} props.autoRenewAccountId
     * @param {Long} props.storage
     * @param {string} props.contractMemo
     * @param {Hbar} props.balance
     * @param {boolean} props.isDeleted
     * @param {TokenRelationshipMap} props.tokenRelationships
     * @param {LedgerId|null} props.ledgerId
     * @param {?StakingInfo} props.stakingInfo
     */
    constructor(props) {
        /**
         * ID of the contract instance, in the format used in transactions.
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * ID of the cryptocurrency account owned by the contract instance,
         * in the format used in transactions.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * ID of both the contract instance and the cryptocurrency account owned by the contract
         * instance, in the format used by Solidity.
         *
         * @readonly
         */
        this.contractAccountId = props.contractAccountId;

        /**
         * The state of the instance and its fields can be modified arbitrarily if this key signs a
         * transaction to modify it. If this is null, then such modifications are not possible,
         * and there is no administrator that can override the normal operation of this smart
         * contract instance. Note that if it is created with no admin keys, then there is no
         * administrator to authorize changing the admin keys, so there can never be any admin keys
         * for that instance.
         *
         * @readonly
         */
        this.adminKey = props.adminKey != null ? props.adminKey : null;

        /**
         * The current time at which this contract instance (and its account) is set to expire.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * The expiration time will extend every this many seconds. If there are insufficient funds,
         * then it extends as long as possible. If the account is empty when it expires,
         * then it is deleted.
         *
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /**
         * ID of the an account to charge for auto-renewal of this contract. If not set, or set
         * to an account with zero hbar balance, the contract's own hbar balance will be used
         * to cover auto-renewal fees.
         *
         * @readonly
         */
        this.autoRenewAccountId = props.autoRenewAccountId;

        /**
         * Number of bytes of storage being used by this instance (which affects the cost to
         * extend the expiration time).
         *
         * @readonly
         */
        this.storage = props.storage;

        /**
         * The memo associated with the contract (max 100 bytes).
         *
         * @readonly
         */
        this.contractMemo = props.contractMemo;

        /**
         * The current balance of the contract.
         *
         * @readonly
         */
        this.balance = props.balance;

        /**
         * Whether the contract has been deleted
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * The tokens associated to the contract
         *
         * @readonly
         */
        this.tokenRelationships = props.tokenRelationships;

        /**
         * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
         */
        this.ledgerId = props.ledgerId;

        /**
         * Staking metadata for this account.
         */
        this.stakingInfo = props.stakingInfo;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ContractGetInfoResponse.IContractInfo} info
     * @returns {ContractInfo}
     */
    static _fromProtobuf(info) {
        const autoRenewPeriod = /** @type {Long | number} */ (
            /** @type {HieroProto.proto.IDuration} */ (info.autoRenewPeriod)
                .seconds
        );

        return new ContractInfo({
            contractId: ContractId._fromProtobuf(
                /** @type {HieroProto.proto.IContractID} */ (info.contractID),
            ),
            accountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (info.accountID),
            ),
            contractAccountId:
                info.contractAccountID != null ? info.contractAccountID : "",
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            expirationTime: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */ (
                    info.expirationTime
                ),
            ),
            autoRenewPeriod: new Duration(autoRenewPeriod),
            autoRenewAccountId:
                info.autoRenewAccountId != null
                    ? AccountId._fromProtobuf(info.autoRenewAccountId)
                    : null,
            storage:
                info.storage != null
                    ? info.storage instanceof Long
                        ? info.storage
                        : Long.fromValue(info.storage)
                    : Long.ZERO,
            contractMemo: info.memo != null ? info.memo : "",
            balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),
            isDeleted: /** @type {boolean} */ (info.deleted),
            tokenRelationships: TokenRelationshipMap._fromProtobuf(
                info.tokenRelationships != null ? info.tokenRelationships : [],
            ),
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
            stakingInfo:
                info.stakingInfo != null
                    ? StakingInfo._fromProtobuf(info.stakingInfo)
                    : null,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ContractGetInfoResponse.IContractInfo}
     */
    _toProtobuf() {
        return {
            contractID: this.contractId._toProtobuf(),
            accountID: this.accountId._toProtobuf(),
            contractAccountID: this.contractAccountId,
            adminKey:
                this.adminKey != null ? this.adminKey._toProtobufKey() : null,
            expirationTime: this.expirationTime._toProtobuf(),
            autoRenewPeriod:
                this.autoRenewPeriod != null
                    ? this.autoRenewPeriod._toProtobuf()
                    : null,
            autoRenewAccountId:
                this.autoRenewAccountId != null
                    ? this.autoRenewAccountId._toProtobuf()
                    : null,
            storage: this.storage,
            memo: this.contractMemo,
            balance: this.balance.toTinybars(),
            deleted: this.isDeleted,
            tokenRelationships:
                this.tokenRelationships != null
                    ? this.tokenRelationships._toProtobuf()
                    : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
            stakingInfo:
                this.stakingInfo != null
                    ? this.stakingInfo._toProtobuf()
                    : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ContractInfo}
     */
    static fromBytes(bytes) {
        return ContractInfo._fromProtobuf(
            proto.ContractGetInfoResponse.ContractInfo.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return proto.ContractGetInfoResponse.ContractInfo.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/contract/ContractInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import ContractId from "./ContractId.js";
import ContractInfo from "./ContractInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.IContractGetInfoQuery} HieroProto.proto.IContractGetInfoQuery
 * @typedef {import("@hashgraph/proto").proto.IContractGetInfoResponse} HieroProto.proto.IContractGetInfoResponse
 * @typedef {import("@hashgraph/proto").proto.ContractGetInfoResponse.IContractInfo} HieroProto.proto.ContractGetInfoResponse.IContractInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * A query that returns information about a smart contract instance.
 * This includes the account that it owns, the contract's bytecode, and the timestamp when it will expire.
 * @augments {Query<ContractInfo>}
 */
export default class ContractInfoQuery extends Query {
    /**
     * @param {object} [props]
     * @param {ContractId | string} [props.contractId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?ContractId}
         * @private
         */
        this._contractId = null;
        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {ContractInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {HieroProto.proto.IContractGetInfoQuery} */ (
            query.contractGetInfo
        );

        return new ContractInfoQuery({
            contractId:
                info.contractID != null
                    ? ContractId._fromProtobuf(info.contractID)
                    : undefined,
        });
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Set the contract ID for which the info is being requested.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractInfoQuery}
     */
    setContractId(contractId) {
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.getContractInfo(request);
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const contractGetInfo =
            /** @type {HieroProto.proto.IContractGetInfoResponse} */ (
                response.contractGetInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            contractGetInfo.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<ContractInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {HieroProto.proto.IContractGetInfoResponse} */ (
            response.contractGetInfo
        );

        return Promise.resolve(
            ContractInfo._fromProtobuf(
                /** @type {HieroProto.proto.ContractGetInfoResponse.IContractInfo} */ (
                    info.contractInfo
                ),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            contractGetInfo: {
                header,
                contractID:
                    this._contractId != null
                        ? this._contractId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ContractInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("contractGetInfo", ContractInfoQuery._fromProtobuf);
// Filename: src/contract/ContractLogInfo.js
// SPDX-License-Identifier: Apache-2.0

import ContractId from "./ContractId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IContractLoginfo} HieroProto.proto.IContractLoginfo
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 */

/**
 * The log information for an event returned by a smart contract function call. One function call
 * may return several such events.
 */
export default class ContractLogInfo {
    /**
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {Uint8Array} props.bloom
     * @param {Uint8Array[]} props.topics
     * @param {Uint8Array} props.data
     */
    constructor(props) {
        /**
         * Address of a contract that emitted the event.
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * Bloom filter for a particular log.
         *
         * @readonly
         */
        this.bloom = props.bloom;

        /**
         * Topics of a particular event.
         *
         * @readonly
         */
        this.topics = props.topics;

        /**
         * Event data.
         *
         * @readonly
         */
        this.data = props.data;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IContractLoginfo} info
     * @returns {ContractLogInfo}
     */
    static _fromProtobuf(info) {
        return new ContractLogInfo({
            contractId: ContractId._fromProtobuf(
                /** @type {HieroProto.proto.IContractID} */ (info.contractID),
            ),
            bloom: info.bloom != null ? info.bloom : new Uint8Array(),
            topics: info.topic != null ? info.topic : [],
            data: info.data != null ? info.data : new Uint8Array(),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IContractLoginfo}
     */
    _toProtobuf() {
        return {
            contractID: this.contractId._toProtobuf(),
            bloom: this.bloom,
            topic: this.topics,
            data: this.data,
        };
    }
}
// Filename: src/contract/ContractNonceInfo.js
// SPDX-License-Identifier: Apache-2.0

import ContractId from "./ContractId.js";
import Long from "long";
import * as protos from "@hashgraph/proto";
const { proto } = protos;

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IContractNonceInfo} HieroProto.proto.IContractNonceInfo
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {object} ContractNonceInfoJSON
 * @property {string} contractId
 * @property {number} nonce
 */

/**
 * Info about a contract account's nonce value.
 * A nonce of a contract is only incremented when that contract creates another contract.
 */
export default class ContractNonceInfo {
    /**
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {Long} props.nonce
     */
    constructor(props) {
        /**
         * Id of the contract
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * The current value of the contract account's nonce property
         *
         * @readonly
         */
        this.nonce = props.nonce;

        Object.freeze(this);
    }

    /**
     *  Extract the contractNonce from the protobuf.
     *
     * @internal
     * @param {HieroProto.proto.IContractNonceInfo} contractNonceInfo the protobuf
     * @returns {ContractNonceInfo} the contract object
     */
    static _fromProtobuf(contractNonceInfo) {
        return new ContractNonceInfo({
            contractId: ContractId._fromProtobuf(
                /** @type {HieroProto.proto.IContractID} */ (
                    contractNonceInfo.contractId
                ),
            ),
            nonce:
                contractNonceInfo.nonce != null
                    ? contractNonceInfo.nonce
                    : Long.ZERO,
        });
    }

    /**
     * Build the protobuf
     *
     * @internal
     * @returns {HieroProto.proto.IContractNonceInfo} the protobuf representation
     */
    _toProtobuf() {
        return {
            contractId: this.contractId._toProtobuf(),
            nonce: this.nonce,
        };
    }

    /**
     * Extract the contractNonce from a byte array.
     *
     * @param {Uint8Array} bytes the byte array
     * @returns {ContractNonceInfo} the extracted contract nonce info
     */
    static fromBytes(bytes) {
        return ContractNonceInfo._fromProtobuf(
            proto.ContractNonceInfo.decode(bytes),
        );
    }

    /**
     * Create a byte array representation.
     *
     * @returns {Uint8Array} the byte array representation
     */
    toBytes() {
        return proto.ContractNonceInfo.encode(this._toProtobuf()).finish();
    }

    /**
     * Create a JSON representation.
     *
     * @returns {ContractNonceInfoJSON} the JSON representation
     */
    toJSON() {
        return {
            contractId: this.contractId.toString(),
            nonce: this.nonce.toNumber(),
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }

    /**
     * @param {this} other
     * @returns {boolean}
     */
    equals(other) {
        return (
            this.contractId.equals(other.contractId) &&
            this.nonce.eq(other.nonce)
        );
    }
}
// Filename: src/contract/ContractStateChange.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import ContractId from "./ContractId.js";
import StorageChange from "./StorageChange.js";

/**
 * @deprecated - Use mirror node for contract traceability instead
 */
export default class ContractStateChange {
    /**
     * @private
     * @param {object} props
     * @param {ContractId} props.contractId
     * @param {StorageChange[]} props.storageChanges
     */
    constructor(props) {
        this.contractId = props.contractId;
        this.storageChanges = props.storageChanges;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IContractStateChange} change
     * @returns {ContractStateChange}
     */
    static _fromProtobuf(change) {
        // eslint-disable-next-line deprecation/deprecation
        return new ContractStateChange({
            contractId: ContractId._fromProtobuf(
                /** @type {HieroProto.proto.IContractID} */ (change.contractId),
            ),
            storageChanges: (change.storageChanges != null
                ? change.storageChanges
                : []
            )
                // eslint-disable-next-line deprecation/deprecation
                .map((change) => StorageChange._fromProtobuf(change)),
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ContractStateChange}
     */
    static fromBytes(bytes) {
        // eslint-disable-next-line deprecation/deprecation
        return ContractStateChange._fromProtobuf(
            HieroProto.proto.ContractStateChange.decode(bytes),
        );
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IContractStateChange} change
     */
    _toProtobuf() {
        return {
            contractId: this.contractId._toProtobuf(),
            storageChanges: this.storageChanges.map((storageChange) =>
                storageChange._toProtobuf(),
            ),
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        // eslint-disable-next-line deprecation/deprecation
        return HieroProto.proto.ContractStateChange.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/contract/ContractUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import ContractId from "./ContractId.js";
import FileId from "../file/FileId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Duration from "../Duration.js";
import Timestamp from "../Timestamp.js";
import Key from "../Key.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IContractUpdateTransactionBody} HieroProto.proto.IContractUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Modify a smart contract.<br/>
 * Any change other than updating the expiration time requires that the
 * contract be modifiable (has a valid `adminKey`) and that the
 * transaction be signed by the `adminKey`
 * <p>
 * Fields _not set_ on the request SHALL NOT be modified.
 */
export default class ContractUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {ContractId | string} [props.contractId]
     * @param {FileId | string} [props.bytecodeFileId]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Key} [props.adminKey]
     * @param {AccountId | string} [props.proxyAccountId]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.contractMemo]
     * @param {number} [props.maxAutomaticTokenAssociations]
     * @param {AccountId | string} [props.stakedAccountId]
     * @param {Long | number} [props.stakedNodeId]
     * @param {boolean} [props.declineStakingReward]
     * @param {AccountId} [props.autoRenewAccountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._proxyAccountId = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        /**
         * @private
         * @type {?FileId}
         */
        this._bytecodeFileId = null;

        /**
         * @private
         * @type {?string}
         */
        this._contractMemo = null;

        /**
         * @private
         * @type {?number}
         */
        this._maxAutomaticTokenAssociations = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._stakedAccountId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._stakedNodeId = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._declineStakingReward = null;

        /**
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.proxyAccountId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setProxyAccountId(props.proxyAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.bytecodeFileId != null) {
            this.setBytecodeFileId(props.bytecodeFileId);
        }

        if (props.contractMemo != null) {
            this.setContractMemo(props.contractMemo);
        }

        if (props.maxAutomaticTokenAssociations != null) {
            this.setMaxAutomaticTokenAssociations(
                props.maxAutomaticTokenAssociations,
            );
        }

        if (props.stakedAccountId != null) {
            this.setStakedAccountId(props.stakedAccountId);
        }

        if (props.stakedNodeId != null) {
            this.setStakedNodeId(props.stakedNodeId);
        }

        if (props.declineStakingReward != null) {
            this.setDeclineStakingReward(props.declineStakingReward);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ContractUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const update =
            /** @type {HieroProto.proto.IContractUpdateTransactionBody} */ (
                body.contractUpdateInstance
            );

        let autoRenewPeriod = undefined;
        if (
            update.autoRenewPeriod != null &&
            update.autoRenewPeriod.seconds != null
        ) {
            autoRenewPeriod = update.autoRenewPeriod.seconds;
        }

        let contractMemo = undefined;
        if (
            update.memoWrapper != null &&
            Object.hasOwn(update.memoWrapper, "value") &&
            update.memoWrapper.value != null
        ) {
            contractMemo = update.memoWrapper.value;
        }

        let maxAutomaticTokenAssociations = undefined;
        if (
            update.maxAutomaticTokenAssociations != null &&
            update.maxAutomaticTokenAssociations.value != null
        ) {
            maxAutomaticTokenAssociations =
                update.maxAutomaticTokenAssociations.value;
        }

        return Transaction._fromProtobufTransactions(
            new ContractUpdateTransaction({
                contractId:
                    update.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {HieroProto.proto.IContractID} */ (
                                  update.contractID
                              ),
                          )
                        : undefined,
                bytecodeFileId:
                    update.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {HieroProto.proto.IFileID} */ (
                                  update.fileID
                              ),
                          )
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
                adminKey:
                    update.adminKey != null
                        ? Key._fromProtobufKey(update.adminKey)
                        : undefined,
                proxyAccountId:
                    update.proxyAccountID != null
                        ? AccountId._fromProtobuf(
                              /** @type {HieroProto.proto.IAccountID} */ (
                                  update.proxyAccountID
                              ),
                          )
                        : undefined,
                autoRenewPeriod,
                contractMemo,
                maxAutomaticTokenAssociations,
                stakedAccountId:
                    update.stakedAccountId != null
                        ? AccountId._fromProtobuf(update.stakedAccountId)
                        : undefined,
                stakedNodeId:
                    update.stakedNodeId != null
                        ? update.stakedNodeId
                        : undefined,
                declineStakingReward:
                    update.declineReward != null &&
                    Boolean(update.declineReward) == true,
                autoRenewAccountId:
                    update.autoRenewAccountId != null
                        ? AccountId._fromProtobuf(update.autoRenewAccountId)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * Sets the contract ID which is being deleted in this transaction.
     *
     * @param {ContractId | string} contractId
     * @returns {ContractUpdateTransaction}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            typeof contractId === "string"
                ? ContractId.fromString(contractId)
                : contractId.clone();

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * Sets the contract ID which is being deleted in this transaction.
     *
     * @param {Timestamp | Date} expirationTime
     * @returns {ContractUpdateTransaction}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Timestamp
                ? expirationTime
                : Timestamp.fromDate(expirationTime);

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @deprecated
     * @returns {?AccountId}
     */
    get proxyAccountId() {
        return this._proxyAccountId;
    }

    /**
     * @deprecated
     * @param {AccountId | string} proxyAccountId
     * @returns {this}
     */
    setProxyAccountId(proxyAccountId) {
        this._requireNotFrozen();
        this._proxyAccountId =
            typeof proxyAccountId === "string"
                ? AccountId.fromString(proxyAccountId)
                : proxyAccountId.clone();

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?FileId}
     */
    get bytecodeFileId() {
        return this._bytecodeFileId;
    }

    /**
     * @param {FileId | string} bytecodeFileId
     * @returns {this}
     */
    setBytecodeFileId(bytecodeFileId) {
        console.warn("Deprecated: there is no replacement");
        this._requireNotFrozen();
        this._bytecodeFileId =
            typeof bytecodeFileId === "string"
                ? FileId.fromString(bytecodeFileId)
                : bytecodeFileId.clone();

        return this;
    }

    /**
     * @returns {?string}
     */
    get contractMemo() {
        return this._contractMemo;
    }

    /**
     * @param {string} contractMemo
     * @returns {this}
     */
    setContractMemo(contractMemo) {
        this._requireNotFrozen();
        this._contractMemo = contractMemo;

        return this;
    }

    /**
     * @returns {this}
     */
    clearContractMemo() {
        this._requireNotFrozen();
        this._contractMemo = null;

        return this;
    }

    /**
     * @returns {number | null}
     */
    get maxAutomaticTokenAssociations() {
        return this._maxAutomaticTokenAssociations;
    }

    /**
     * @param {number} maxAutomaticTokenAssociations
     * @returns {this}
     */
    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations) {
        this._requireNotFrozen();
        this._maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get stakedAccountId() {
        return this._stakedAccountId;
    }

    /**
     * @param {AccountId | string} stakedAccountId
     * @returns {this}
     */
    setStakedAccountId(stakedAccountId) {
        this._requireNotFrozen();
        this._stakedAccountId =
            typeof stakedAccountId === "string"
                ? AccountId.fromString(stakedAccountId)
                : stakedAccountId;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get stakedNodeId() {
        return this._stakedNodeId;
    }

    /**
     * @param {Long | number} stakedNodeId
     * @returns {this}
     */
    setStakedNodeId(stakedNodeId) {
        this._requireNotFrozen();
        this._stakedNodeId = Long.fromValue(stakedNodeId);

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get declineStakingRewards() {
        return this._declineStakingReward;
    }

    /**
     * @param {boolean} declineStakingReward
     * @returns {this}
     */
    setDeclineStakingReward(declineStakingReward) {
        this._requireNotFrozen();
        this._declineStakingReward = declineStakingReward;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
     * account. Otherwise it updates the contract's auto-renew account to the referenced account.
     *
     * @param {string | AccountId} autoRenewAccountId
     * @returns {this}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            typeof autoRenewAccountId === "string"
                ? AccountId.fromString(autoRenewAccountId)
                : autoRenewAccountId;

        return this;
    }

    /**
     * @returns {this}
     */
    clearAutoRenewAccountId() {
        this._autoRenewAccountId = new AccountId(0);
        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._contractId != null) {
            this._contractId.validateChecksum(client);
        }

        if (this._bytecodeFileId != null) {
            this._bytecodeFileId.validateChecksum(client);
        }

        if (this._proxyAccountId != null) {
            this._proxyAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.smartContract.updateContract(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "contractUpdateInstance";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IContractUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            proxyAccountID:
                this._proxyAccountId != null
                    ? this._proxyAccountId._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            fileID: this._bytecodeFileId
                ? this._bytecodeFileId._toProtobuf()
                : null,
            memoWrapper:
                this._contractMemo != null
                    ? {
                          value: this._contractMemo,
                      }
                    : null,
            maxAutomaticTokenAssociations:
                this._maxAutomaticTokenAssociations != null
                    ? {
                          value: this._maxAutomaticTokenAssociations,
                      }
                    : null,
            stakedAccountId:
                this.stakedAccountId != null
                    ? this.stakedAccountId._toProtobuf()
                    : null,
            stakedNodeId: this.stakedNodeId,
            declineReward:
                this.declineStakingRewards != null
                    ? { value: this.declineStakingRewards }
                    : null,
            autoRenewAccountId:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ContractUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "contractUpdateInstance",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ContractUpdateTransaction._fromProtobuf,
);
// Filename: src/contract/DelegateContractId.js
// SPDX-License-Identifier: Apache-2.0

import CACHE from "../Cache.js";
import ContractId from "./ContractId.js";
import * as hex from "../encoding/hex.js";

/**
 * @namespace {proto}
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 */

/**
 * @typedef {import("long")} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * epresents a delegatable smart contract ID on the Hedera network.
 * This class extends ContractId and provides additional functionality for delegatable contracts.
 */
export default class DelegateContractId extends ContractId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     * @param {Uint8Array=} evmAddress
     */
    constructor(props, realm, num, evmAddress) {
        super(props, realm, num, evmAddress);
    }

    /**
     * @param {Long | number} shard
     * @param {Long | number} realm
     * @param {string} evmAddress
     * @returns {ContractId}
     */
    static fromEvmAddress(shard, realm, evmAddress) {
        return new DelegateContractId(shard, realm, 0, hex.decode(evmAddress));
    }

    /**
     * @param {string} text
     * @returns {DelegateContractId}
     */
    static fromString(text) {
        return new DelegateContractId(ContractId.fromString(text));
    }

    /**
     * @internal
     * @param {HieroProto.proto.IContractID} id
     * @returns {DelegateContractId}
     */
    static _fromProtobuf(id) {
        return new DelegateContractId(ContractId._fromProtobuf(id));
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {DelegateContractId}
     */
    static fromBytes(bytes) {
        return new DelegateContractId(ContractId.fromBytes(bytes));
    }

    /**
     * @param {string} address
     * @returns {DelegateContractId}
     */
    static fromSolidityAddress(address) {
        // eslint-disable-next-line deprecation/deprecation
        return new DelegateContractId(ContractId.fromSolidityAddress(address));
    }

    /**
     * @returns {DelegateContractId}
     */
    clone() {
        const id = new DelegateContractId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @returns {HieroProto.proto.IKey}
     */
    _toProtobufKey() {
        return {
            delegatableContractId: this._toProtobuf(),
        };
    }

    /**
     * @param {HieroProto.proto.IContractID} key
     * @returns {DelegateContractId}
     */
    static __fromProtobufKey(key) {
        return DelegateContractId._fromProtobuf(key);
    }
}

CACHE.setDelegateContractId((key) => DelegateContractId.__fromProtobufKey(key));
// Filename: src/contract/StorageChange.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";

/**
 * @deprecated - Use mirror node for contract traceability instead
 */
export default class StorageChange {
    /**
     * @private
     * @param {object} props
     * @param {Uint8Array} props.slot
     * @param {Uint8Array} props.valueRead
     * @param {Uint8Array?} props.valueWritten
     */
    constructor(props) {
        this.slot = props.slot;
        this.valueRead = props.valueRead;
        this.valueWritten = props.valueWritten;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IStorageChange} change
     * @returns {StorageChange}
     */
    static _fromProtobuf(change) {
        // eslint-disable-next-line deprecation/deprecation
        return new StorageChange({
            slot: /** @type {Uint8Array} */ (change.slot),
            valueRead: /** @type {Uint8Array} */ (change.valueRead),
            valueWritten:
                change.valueWritten != null && change.valueWritten.value != null
                    ? change.valueWritten.value
                    : null,
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {StorageChange}
     */
    static fromBytes(bytes) {
        // eslint-disable-next-line deprecation/deprecation
        return StorageChange._fromProtobuf(
            HieroProto.proto.StorageChange.decode(bytes),
        );
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IStorageChange}
     */
    _toProtobuf() {
        return {
            slot: this.slot,
            valueRead: this.valueRead,
            valueWritten:
                this.valueWritten != null ? { value: this.valueWritten } : null,
        };
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.StorageChange.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/cryptography/keccak.js
// SPDX-License-Identifier: Apache-2.0

// Originally sourced from:
// https://github.com/MaiaVictor/eth-lib/blob/da0971f5b09964d9c8449975fa87933f0c9fef35/src/hash.js
//  - added type declarations
//  - switched to es6 module syntax
//
// Disable linting for entire file because it's nearly all pure JS
// eslint-disable

const HEX_CHARS = "0123456789abcdef".split("");
const KECCAK_PADDING = [1, 256, 65536, 16777216];
const SHIFT = [0, 8, 16, 24];
const RC = [
    1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
    2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
    2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
    2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
    2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648,
    2147483649, 0, 2147516424, 2147483648,
];

/**
 * @typedef {object} KeccakT
 * @property {number[]} blocks
 * @property {number} blockCount
 * @property {number} outputBlocks
 * @property {number[]} s
 * @property {number} start
 * @property {number} block
 * @property {boolean} reset
 * @property {number=} lastByteIndex
 */

/** @type {(bits: number) => KeccakT} */
const Keccak = (bits) => ({
    blocks: [],
    reset: true,
    block: 0,
    start: 0,
    blockCount: (1600 - (bits << 1)) >> 5,
    outputBlocks: bits >> 5,
    // @ts-ignore
    s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
});

/** @type {(state: KeccakT, message: string | number[]) => string} */
//NOSONAR
const update = (state, /** @type {string | number[]} */ message) => {
    var length = message.length,
        blocks = state.blocks,
        byteCount = state.blockCount << 2,
        blockCount = state.blockCount,
        outputBlocks = state.outputBlocks,
        s = state.s,
        index = 0,
        i,
        code;

    // update
    while (index < length) {
        if (state.reset) {
            state.reset = false;
            blocks[0] = state.block;
            for (i = 1; i < blockCount + 1; ++i) {
                blocks[i] = 0;
            }
        }
        if (typeof message !== "string") {
            for (i = state.start; index < length && i < byteCount; ++index) {
                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
        } else {
            for (i = state.start; index < length && i < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 0x80) {
                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 0x800) {
                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                } else if (code < 0xd800 || code >= 0xe000) {
                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                } else {
                    code =
                        0x10000 +
                        (((code & 0x3ff) << 10) |
                            (message.charCodeAt(++index) & 0x3ff)); //NOSONAR
                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |=
                        (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                }
            }
        }
        state.lastByteIndex = i;
        if (i >= byteCount) {
            state.start = i - byteCount;
            state.block = blocks[blockCount];
            for (i = 0; i < blockCount; ++i) {
                s[i] ^= blocks[i];
            }
            f(s);
            state.reset = true;
        } else {
            state.start = i;
        }
    }

    // finalize
    i = state.lastByteIndex;
    // @ts-ignore
    blocks[i >> 2] |= KECCAK_PADDING[i & 3];
    if (state.lastByteIndex === byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
        }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
    }
    f(s);

    // toString
    var hex = "";
    var block;
    var j = 0;
    i = 0; //NOSONAR
    while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
            block = s[i];
            hex +=
                HEX_CHARS[(block >> 4) & 0x0f] +
                HEX_CHARS[block & 0x0f] +
                HEX_CHARS[(block >> 12) & 0x0f] +
                HEX_CHARS[(block >> 8) & 0x0f] +
                HEX_CHARS[(block >> 20) & 0x0f] +
                HEX_CHARS[(block >> 16) & 0x0f] +
                HEX_CHARS[(block >> 28) & 0x0f] +
                HEX_CHARS[(block >> 24) & 0x0f];
        }
        if (j % blockCount === 0) {
            f(s);
            i = 0; //NOSONAR
        }
    }
    // @ts-ignore
    return "0x" + hex;
};

/** @type {(s: number[]) => void} */
const f = (s) => {
    var h,
        l,
        n,
        c0,
        c1,
        c2,
        c3,
        c4,
        c5,
        c6,
        c7,
        c8,
        c9,
        b0,
        b1,
        b2,
        b3,
        b4,
        b5,
        b6,
        b7,
        b8,
        b9,
        b10,
        b11,
        b12,
        b13,
        b14,
        b15,
        b16,
        b17,
        b18,
        b19,
        b20,
        b21,
        b22,
        b23,
        b24,
        b25,
        b26,
        b27,
        b28,
        b29,
        b30,
        b31,
        b32,
        b33,
        b34,
        b35,
        b36,
        b37,
        b38,
        b39,
        b40,
        b41,
        b42,
        b43,
        b44,
        b45,
        b46,
        b47,
        b48,
        b49;

    for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

        h = c8 ^ ((c2 << 1) | (c3 >>> 31));
        l = c9 ^ ((c3 << 1) | (c2 >>> 31));
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ ((c4 << 1) | (c5 >>> 31));
        l = c1 ^ ((c5 << 1) | (c4 >>> 31));
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ ((c6 << 1) | (c7 >>> 31));
        l = c3 ^ ((c7 << 1) | (c6 >>> 31));
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ ((c8 << 1) | (c9 >>> 31));
        l = c5 ^ ((c9 << 1) | (c8 >>> 31));
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ ((c0 << 1) | (c1 >>> 31));
        l = c7 ^ ((c1 << 1) | (c0 >>> 31));
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;

        b0 = s[0];
        b1 = s[1];
        b32 = (s[11] << 4) | (s[10] >>> 28);
        b33 = (s[10] << 4) | (s[11] >>> 28);
        b14 = (s[20] << 3) | (s[21] >>> 29);
        b15 = (s[21] << 3) | (s[20] >>> 29);
        b46 = (s[31] << 9) | (s[30] >>> 23);
        b47 = (s[30] << 9) | (s[31] >>> 23);
        b28 = (s[40] << 18) | (s[41] >>> 14);
        b29 = (s[41] << 18) | (s[40] >>> 14);
        b20 = (s[2] << 1) | (s[3] >>> 31);
        b21 = (s[3] << 1) | (s[2] >>> 31);
        b2 = (s[13] << 12) | (s[12] >>> 20);
        b3 = (s[12] << 12) | (s[13] >>> 20);
        b34 = (s[22] << 10) | (s[23] >>> 22);
        b35 = (s[23] << 10) | (s[22] >>> 22);
        b16 = (s[33] << 13) | (s[32] >>> 19);
        b17 = (s[32] << 13) | (s[33] >>> 19);
        b48 = (s[42] << 2) | (s[43] >>> 30);
        b49 = (s[43] << 2) | (s[42] >>> 30);
        b40 = (s[5] << 30) | (s[4] >>> 2);
        b41 = (s[4] << 30) | (s[5] >>> 2);
        b22 = (s[14] << 6) | (s[15] >>> 26);
        b23 = (s[15] << 6) | (s[14] >>> 26);
        b4 = (s[25] << 11) | (s[24] >>> 21);
        b5 = (s[24] << 11) | (s[25] >>> 21);
        b36 = (s[34] << 15) | (s[35] >>> 17);
        b37 = (s[35] << 15) | (s[34] >>> 17);
        b18 = (s[45] << 29) | (s[44] >>> 3);
        b19 = (s[44] << 29) | (s[45] >>> 3);
        b10 = (s[6] << 28) | (s[7] >>> 4);
        b11 = (s[7] << 28) | (s[6] >>> 4);
        b42 = (s[17] << 23) | (s[16] >>> 9);
        b43 = (s[16] << 23) | (s[17] >>> 9);
        b24 = (s[26] << 25) | (s[27] >>> 7);
        b25 = (s[27] << 25) | (s[26] >>> 7);
        b6 = (s[36] << 21) | (s[37] >>> 11);
        b7 = (s[37] << 21) | (s[36] >>> 11);
        b38 = (s[47] << 24) | (s[46] >>> 8);
        b39 = (s[46] << 24) | (s[47] >>> 8);
        b30 = (s[8] << 27) | (s[9] >>> 5);
        b31 = (s[9] << 27) | (s[8] >>> 5);
        b12 = (s[18] << 20) | (s[19] >>> 12);
        b13 = (s[19] << 20) | (s[18] >>> 12);
        b44 = (s[29] << 7) | (s[28] >>> 25);
        b45 = (s[28] << 7) | (s[29] >>> 25);
        b26 = (s[38] << 8) | (s[39] >>> 24);
        b27 = (s[39] << 8) | (s[38] >>> 24);
        b8 = (s[48] << 14) | (s[49] >>> 18);
        b9 = (s[49] << 14) | (s[48] >>> 18);

        s[0] = b0 ^ (~b2 & b4);
        s[1] = b1 ^ (~b3 & b5);
        s[10] = b10 ^ (~b12 & b14);
        s[11] = b11 ^ (~b13 & b15);
        s[20] = b20 ^ (~b22 & b24);
        s[21] = b21 ^ (~b23 & b25);
        s[30] = b30 ^ (~b32 & b34);
        s[31] = b31 ^ (~b33 & b35);
        s[40] = b40 ^ (~b42 & b44);
        s[41] = b41 ^ (~b43 & b45);
        s[2] = b2 ^ (~b4 & b6);
        s[3] = b3 ^ (~b5 & b7);
        s[12] = b12 ^ (~b14 & b16);
        s[13] = b13 ^ (~b15 & b17);
        s[22] = b22 ^ (~b24 & b26);
        s[23] = b23 ^ (~b25 & b27);
        s[32] = b32 ^ (~b34 & b36);
        s[33] = b33 ^ (~b35 & b37);
        s[42] = b42 ^ (~b44 & b46);
        s[43] = b43 ^ (~b45 & b47);
        s[4] = b4 ^ (~b6 & b8);
        s[5] = b5 ^ (~b7 & b9);
        s[14] = b14 ^ (~b16 & b18);
        s[15] = b15 ^ (~b17 & b19);
        s[24] = b24 ^ (~b26 & b28);
        s[25] = b25 ^ (~b27 & b29);
        s[34] = b34 ^ (~b36 & b38);
        s[35] = b35 ^ (~b37 & b39);
        s[44] = b44 ^ (~b46 & b48);
        s[45] = b45 ^ (~b47 & b49);
        s[6] = b6 ^ (~b8 & b0);
        s[7] = b7 ^ (~b9 & b1);
        s[16] = b16 ^ (~b18 & b10);
        s[17] = b17 ^ (~b19 & b11);
        s[26] = b26 ^ (~b28 & b20);
        s[27] = b27 ^ (~b29 & b21);
        s[36] = b36 ^ (~b38 & b30);
        s[37] = b37 ^ (~b39 & b31);
        s[46] = b46 ^ (~b48 & b40);
        s[47] = b47 ^ (~b49 & b41);
        s[8] = b8 ^ (~b0 & b2);
        s[9] = b9 ^ (~b1 & b3);
        s[18] = b18 ^ (~b10 & b12);
        s[19] = b19 ^ (~b11 & b13);
        s[28] = b28 ^ (~b20 & b22);
        s[29] = b29 ^ (~b21 & b23);
        s[38] = b38 ^ (~b30 & b32);
        s[39] = b39 ^ (~b31 & b33);
        s[48] = b48 ^ (~b40 & b42);
        s[49] = b49 ^ (~b41 & b43);

        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
    }
};

const keccak = (/** @type {number} */ bits) => (/** @type {string} */ str) => {
    var msg;
    if (str.slice(0, 2) === "0x") {
        msg = [];
        for (var i = 2, l = str.length; i < l; i += 2)
            msg.push(parseInt(str.slice(i, i + 2), 16));
    } else {
        msg = str;
    }
    // @ts-ignore
    return update(Keccak(bits), msg);
};

/**
 * @type {(message: string) => string}
 */
export const keccak256 = keccak(256);
// Filename: src/cryptography/sha384.browser.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export async function digest(data) {
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
    // This will be executed in a browser environment so the crypto object should be available if its
    // in secure context.
    // eslint-disable-next-line n/no-unsupported-features/node-builtins
    return new Uint8Array(await window.crypto.subtle.digest("SHA-384", data));
}
// Filename: src/cryptography/sha384.js
// SPDX-License-Identifier: Apache-2.0

import crypto from "crypto";

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
export function digest(data) {
    // fallback to trying node-crypto which could be polyfilled by the browser environment
    return Promise.resolve(crypto.createHash("sha384").update(data).digest());
}

/**
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
export function digestSync(data) {
    return crypto.createHash("sha384").update(data).digest();
}
// Filename: src/cryptography/sha384.native.js
// SPDX-License-Identifier: Apache-2.0

import CryptoJS from "crypto-js";
import * as hex from "../encoding/hex.js";

/**
 * @param {Uint8Array} data
 * @returns {Promise<Uint8Array>}
 */
// eslint-disable-next-line @typescript-eslint/require-await
export async function digest(data) {
    return Promise.resolve(
        hex.decode(
            CryptoJS.SHA384(CryptoJS.enc.Hex.parse(hex.encode(data))).toString(
                CryptoJS.enc.Hex,
            ),
        ),
    );
}
// Filename: src/encoding/base64.native.js
// SPDX-License-Identifier: Apache-2.0

import { atob, btoa } from "js-base64";

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    return Uint8Array.from(atob(text), (c) => c.charCodeAt(0));
}

/**
 * @param {Uint8Array} data
 * @returns {string};
 */
export function encode(data) {
    return btoa(String.fromCharCode.apply(null, Array.from(data)));
}
// Filename: src/encoding/hex.browser.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @type {string[]}
 */
const byteToHex = [];

for (let n = 0; n <= 0xff; n += 1) {
    byteToHex.push(n.toString(16).padStart(2, "0"));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encode(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHex[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    const result = str.match(/.{1,2}/gu);

    return new Uint8Array(
        (result == null ? [] : result).map((byte) => parseInt(byte, 16)),
    );
}

/**
 * Encode with a specified length. Supports zero padding if the most significant byte is 0
 *
 * https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
 *
 * @param {Uint8Array} value
 * @param {number} length
 * @returns {string}
 */
export function hexZeroPadded(value, length) {
    const HexCharacters = "0123456789abcdef";

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L243
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
    if (result.length > 2 * length + 2) {
        console.log("result out of range", "result");
    }

    while (result.length < 2 * length + 2) {
        result = "0x0" + result.substring(2);
    }

    return result.substring(2);
}
// Filename: src/encoding/hex.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encode(data) {
    return Buffer.from(data).toString("hex");
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    return Buffer.from(str, "hex");
}

/**
 * Encode with a specified length. Supports zero padding if the most significant byte is 0
 *
 * https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
 *
 * @param {Uint8Array} value
 * @param {number} length
 * @returns {string}
 */
export function hexZeroPadded(value, length) {
    const HexCharacters = "0123456789abcdef";

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L243
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
    if (result.length > 2 * length + 2) {
        console.log("result out of range", "result");
    }

    while (result.length < 2 * length + 2) {
        result = "0x0" + result.substring(2);
    }

    return result.substring(2);
}
// Filename: src/encoding/hex.native.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @type {string[]}
 */
const byteToHex = [];

/**
 * @type {string[]}
 */
const byteToHexByteString = [
    "\x00",
    "\x01",
    "\x02",
    "\x03",
    "\x04",
    "\x05",
    "\x06",
    "\x07",
    "\x08",
    "\x09",
    "\x0A",
    "\x0B",
    "\x0C",
    "\x0D",
    "\x0E",
    "\x0F",
    "\x10",
    "\x11",
    "\x12",
    "\x13",
    "\x14",
    "\x15",
    "\x16",
    "\x17",
    "\x18",
    "\x19",
    "\x1A",
    "\x1B",
    "\x1C",
    "\x1D",
    "\x1E",
    "\x1F",
    "\x20",
    "\x21",
    "\x22",
    "\x23",
    "\x24",
    "\x25",
    "\x26",
    "\x27",
    "\x28",
    "\x29",
    "\x2A",
    "\x2B",
    "\x2C",
    "\x2D",
    "\x2E",
    "\x2F",
    "\x30",
    "\x31",
    "\x32",
    "\x33",
    "\x34",
    "\x35",
    "\x36",
    "\x37",
    "\x38",
    "\x39",
    "\x3A",
    "\x3B",
    "\x3C",
    "\x3D",
    "\x3E",
    "\x3F",
    "\x40",
    "\x41",
    "\x42",
    "\x43",
    "\x44",
    "\x45",
    "\x46",
    "\x47",
    "\x48",
    "\x49",
    "\x4A",
    "\x4B",
    "\x4C",
    "\x4D",
    "\x4E",
    "\x4F",
    "\x50",
    "\x51",
    "\x52",
    "\x53",
    "\x54",
    "\x55",
    "\x56",
    "\x57",
    "\x58",
    "\x59",
    "\x5A",
    "\x5B",
    "\x5C",
    "\x5D",
    "\x5E",
    "\x5F",
    "\x60",
    "\x61",
    "\x62",
    "\x63",
    "\x64",
    "\x65",
    "\x66",
    "\x67",
    "\x68",
    "\x69",
    "\x6A",
    "\x6B",
    "\x6C",
    "\x6D",
    "\x6E",
    "\x6F",
    "\x70",
    "\x71",
    "\x72",
    "\x73",
    "\x74",
    "\x75",
    "\x76",
    "\x77",
    "\x78",
    "\x79",
    "\x7A",
    "\x7B",
    "\x7C",
    "\x7D",
    "\x7E",
    "\x7F",
    "\x80",
    "\x81",
    "\x82",
    "\x83",
    "\x84",
    "\x85",
    "\x86",
    "\x87",
    "\x88",
    "\x89",
    "\x8A",
    "\x8B",
    "\x8C",
    "\x8D",
    "\x8E",
    "\x8F",
    "\x90",
    "\x91",
    "\x92",
    "\x93",
    "\x94",
    "\x95",
    "\x96",
    "\x97",
    "\x98",
    "\x99",
    "\x9A",
    "\x9B",
    "\x9C",
    "\x9D",
    "\x9E",
    "\x9F",
    "\xA0",
    "\xA1",
    "\xA2",
    "\xA3",
    "\xA4",
    "\xA5",
    "\xA6",
    "\xA7",
    "\xA8",
    "\xA9",
    "\xAA",
    "\xAB",
    "\xAC",
    "\xAD",
    "\xAE",
    "\xAF",
    "\xB0",
    "\xB1",
    "\xB2",
    "\xB3",
    "\xB4",
    "\xB5",
    "\xB6",
    "\xB7",
    "\xB8",
    "\xB9",
    "\xBA",
    "\xBB",
    "\xBC",
    "\xBD",
    "\xBE",
    "\xBF",
    "\xC0",
    "\xC1",
    "\xC2",
    "\xC3",
    "\xC4",
    "\xC5",
    "\xC6",
    "\xC7",
    "\xC8",
    "\xC9",
    "\xCA",
    "\xCB",
    "\xCC",
    "\xCD",
    "\xCE",
    "\xCF",
    "\xD0",
    "\xD1",
    "\xD2",
    "\xD3",
    "\xD4",
    "\xD5",
    "\xD6",
    "\xD7",
    "\xD8",
    "\xD9",
    "\xDA",
    "\xDB",
    "\xDC",
    "\xDD",
    "\xDE",
    "\xDF",
    "\xE0",
    "\xE1",
    "\xE2",
    "\xE3",
    "\xE4",
    "\xE5",
    "\xE6",
    "\xE7",
    "\xE8",
    "\xE9",
    "\xEA",
    "\xEB",
    "\xEC",
    "\xED",
    "\xEE",
    "\xEF",
    "\xF0",
    "\xF1",
    "\xF2",
    "\xF3",
    "\xF4",
    "\xF5",
    "\xF6",
    "\xF7",
    "\xF8",
    "\xF9",
    "\xFA",
    "\xFB",
    "\xFC",
    "\xFD",
    "\xFE",
    "\xFF",
];

for (let n = 0; n <= 0xff; n += 1) {
    byteToHex.push(n.toString(16).padStart(2, "0"));
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encode(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHex[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decode(text) {
    const str = text.startsWith("0x") ? text.substring(2) : text;
    const result = str.match(/.{1,2}/gu);

    return new Uint8Array(
        (result == null ? [] : result).map((byte) => parseInt(byte, 16)),
    );
}

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function encodeToByteString(data) {
    let string = "";

    for (const byte of data) {
        string += byteToHexByteString[byte];
    }

    return string;
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function decodeFromByteString(text) {
    const buffer = new Uint8Array(text.length);
    const view = new DataView(buffer.buffer);

    for (let i = 0; i < text.length; i++) {
        view.setUint8(i, text.charCodeAt(i));
    }

    return buffer;
}

/**
 * Encode with a specified length. Supports zero padding if the most significant byte is 0
 *
 * https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
 *
 * @param {Uint8Array} value
 * @param {number} length
 * @returns {string}
 */
export function hexZeroPadded(value, length) {
    const HexCharacters = "0123456789abcdef";

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L243
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
        let v = value[i];
        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    // https://github.com/ethers-io/ethers.js/blob/master/packages/bytes/src.ts/index.ts#L315
    if (result.length > 2 * length + 2) {
        console.log("result out of range", "result");
    }

    while (result.length < 2 * length + 2) {
        result = "0x0" + result.substring(2);
    }

    return result.substring(2);
}
// Filename: src/encoding/utf8.browser.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function decode(data) {
    // eslint-disable-next-line n/no-unsupported-features/node-builtins
    return new TextDecoder().decode(data);
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function encode(text) {
    // eslint-disable-next-line n/no-unsupported-features/node-builtins
    return new TextEncoder().encode(text);
}
// Filename: src/encoding/utf8.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function decode(data) {
    return Buffer.from(data).toString("utf8");
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function encode(text) {
    return Buffer.from(text, "utf8");
}
// Filename: src/encoding/utf8.native.js
// SPDX-License-Identifier: Apache-2.0

import utf8 from "utf8";
import * as hex from "./hex.native.js";

/**
 * @param {Uint8Array} data
 * @returns {string}
 */
export function decode(data) {
    return utf8.decode(hex.encodeToByteString(data));
}

/**
 * @param {string} text
 * @returns {Uint8Array}
 */
export function encode(text) {
    return hex.decodeFromByteString(utf8.encode(text));
}
// Filename: src/exports.js
// SPDX-License-Identifier: Apache-2.0
import * as EntityIdHelper from "./EntityIdHelper.js";

export { default as Cache } from "./Cache.js";
export {
    BadKeyError,
    BadMnemonicError,
    BadMnemonicReason,
    HEDERA_PATH,
    SLIP44_ECDSA_ETH_PATH,
    SLIP44_ECDSA_HEDERA_PATH,
} from "@hashgraph/cryptography";
export { default as PrivateKey } from "./PrivateKey.js";
export { default as PublicKey } from "./PublicKey.js";
export { default as KeyList } from "./KeyList.js";
export { default as Key } from "./Key.js";
export { default as Mnemonic } from "./Mnemonic.js";
export { default as TokenAirdropTransaction } from "./token/TokenAirdropTransaction.js";
export { default as TokenClaimAirdropTransaction } from "./token/TokenClaimAirdropTransaction.js";
export { default as TokenCancelAirdropTransaction } from "./token/TokenCancelAirdropTransaction.js";
// eslint-disable-next-line deprecation/deprecation
export { default as AccountAllowanceAdjustTransaction } from "./account/AccountAllowanceAdjustTransaction.js";
export { default as AccountAllowanceApproveTransaction } from "./account/AccountAllowanceApproveTransaction.js";
export { default as AccountAllowanceDeleteTransaction } from "./account/AccountAllowanceDeleteTransaction.js";
export { default as AccountBalance } from "./account/AccountBalance.js";
export { default as AccountBalanceQuery } from "./account/AccountBalanceQuery.js";
export { default as AccountCreateTransaction } from "./account/AccountCreateTransaction.js";
export { default as AccountDeleteTransaction } from "./account/AccountDeleteTransaction.js";
export { default as AccountId } from "./account/AccountId.js";
export { default as AccountInfo } from "./account/AccountInfo.js";
export { default as AccountInfoFlow } from "./account/AccountInfoFlow.js";
export { default as AccountInfoQuery } from "./account/AccountInfoQuery.js";
export { default as AccountRecordsQuery } from "./account/AccountRecordsQuery.js";
export { default as AccountUpdateTransaction } from "./account/AccountUpdateTransaction.js";
export { default as AddressBookQuery } from "./network/AddressBookQuery.js";
export { default as AssessedCustomFee } from "./token/AssessedCustomFee.js";
export { default as ContractByteCodeQuery } from "./contract/ContractByteCodeQuery.js";
export { default as ContractCallQuery } from "./contract/ContractCallQuery.js";
export { default as ContractCreateFlow } from "./contract/ContractCreateFlow.js";
export { default as ContractCreateTransaction } from "./contract/ContractCreateTransaction.js";
export { default as ContractDeleteTransaction } from "./contract/ContractDeleteTransaction.js";
export { default as ContractExecuteTransaction } from "./contract/ContractExecuteTransaction.js";
export { default as ContractFunctionParameters } from "./contract/ContractFunctionParameters.js";
export { default as ContractFunctionResult } from "./contract/ContractFunctionResult.js";
export { default as ContractFunctionSelector } from "./contract/ContractFunctionSelector.js";
export { default as ContractId } from "./contract/ContractId.js";
export { default as ContractInfo } from "./contract/ContractInfo.js";
export { default as ContractInfoQuery } from "./contract/ContractInfoQuery.js";
export { default as ContractLogInfo } from "./contract/ContractLogInfo.js";
export { default as ContractNonceInfo } from "./contract/ContractNonceInfo.js";
export { default as ContractUpdateTransaction } from "./contract/ContractUpdateTransaction.js";
export { default as CustomFee } from "./token/CustomFee.js";
export { default as CustomFixedFee } from "./token/CustomFixedFee.js";
export { default as CustomFractionalFee } from "./token/CustomFractionalFee.js";
export { default as CustomRoyaltyFee } from "./token/CustomRoyaltyFee.js";
export { default as DelegateContractId } from "./contract/DelegateContractId.js";
export { default as EthereumTransaction } from "./EthereumTransaction.js";
export { default as EthereumTransactionDataLegacy } from "./EthereumTransactionDataLegacy.js";
export { default as EthereumTransactionDataEip1559 } from "./EthereumTransactionDataEip1559.js";
export { default as EthereumTransactionDataEip2930 } from "./EthereumTransactionDataEip2930.js";
export { default as EthereumTransactionData } from "./EthereumTransactionData.js";
export { default as EthereumFlow } from "./EthereumFlow.js";
export { default as EvmAddress } from "./EvmAddress.js";
export { default as ExchangeRate } from "./ExchangeRate.js";
export { default as ExchangeRates } from "./ExchangeRates.js";
export { default as Executable } from "./Executable.js";
export { default as FeeAssessmentMethod } from "./token/FeeAssessmentMethod.js";
export { default as FeeComponents } from "./FeeComponents.js";
export { default as FeeData } from "./FeeData.js";
export { default as FeeDataType } from "./FeeDataType.js";
export { default as FeeSchedule } from "./FeeSchedule.js";
export { default as FeeSchedules } from "./FeeSchedules.js";
export { default as FileAppendTransaction } from "./file/FileAppendTransaction.js";
export { default as FileContentsQuery } from "./file/FileContentsQuery.js";
export { default as FileCreateTransaction } from "./file/FileCreateTransaction.js";
export { default as FileDeleteTransaction } from "./file/FileDeleteTransaction.js";
export { default as FileId } from "./file/FileId.js";
export { default as FileInfo } from "./file/FileInfo.js";
export { default as FileInfoQuery } from "./file/FileInfoQuery.js";
export { default as FileUpdateTransaction } from "./file/FileUpdateTransaction.js";
export { default as FreezeTransaction } from "./system/FreezeTransaction.js";
export { default as Hbar } from "./Hbar.js";
export { default as HbarAllowance } from "./account/HbarAllowance.js";
export { default as HbarUnit } from "./HbarUnit.js";
export { default as LiveHash } from "./account/LiveHash.js";
// eslint-disable-next-line deprecation/deprecation
export { default as LiveHashAddTransaction } from "./account/LiveHashAddTransaction.js";
// eslint-disable-next-line deprecation/deprecation
export { default as LiveHashDeleteTransaction } from "./account/LiveHashDeleteTransaction.js";
// eslint-disable-next-line deprecation/deprecation
export { default as LiveHashQuery } from "./account/LiveHashQuery.js";
export { default as MaxQueryPaymentExceeded } from "./MaxQueryPaymentExceeded.js";
export { default as MirrorNodeContractCallQuery } from "./query/MirrorNodeContractCallQuery.js";
export { default as MirrorNodeContractEstimateQuery } from "./query/MirrorNodeContractEstimateQuery.js";
export { default as NodeAddressBook } from "./address_book/NodeAddressBook.js";
export { default as NetworkVersionInfo } from "./network/NetworkVersionInfo.js";
export { default as NetworkVersionInfoQuery } from "./network/NetworkVersionInfoQuery.js";
export { default as NftId } from "./token/NftId.js";
export { default as PendingAirdropId } from "./token/PendingAirdropId.js";
export { default as Provider } from "./Provider.js";
export { default as PrngTransaction } from "./PrngTransaction.js";
export { default as ProxyStaker } from "./account/ProxyStaker.js";
export { default as Query } from "./query/Query.js";
export { default as RequestType } from "./RequestType.js";
export { default as ScheduleCreateTransaction } from "./schedule/ScheduleCreateTransaction.js";
export { default as ScheduleDeleteTransaction } from "./schedule/ScheduleDeleteTransaction.js";
export { default as ScheduleId } from "./schedule/ScheduleId.js";
export { default as ScheduleInfo } from "./schedule/ScheduleInfo.js";
export { default as ScheduleInfoQuery } from "./schedule/ScheduleInfoQuery.js";
export { default as ScheduleSignTransaction } from "./schedule/ScheduleSignTransaction.js";
export { default as SemanticVersion } from "./network/SemanticVersion.js";
export { default as SignatureMap } from "./transaction/SignatureMap.js";
export { default as Signer } from "./Signer.js";
export { default as SignerSignature } from "./SignerSignature.js";
export { default as Status } from "./Status.js";
export { default as SubscriptionHandle } from "./topic/SubscriptionHandle.js";
// eslint-disable-next-line deprecation/deprecation
export { default as SystemDeleteTransaction } from "./system/SystemDeleteTransaction.js";
// eslint-disable-next-line deprecation/deprecation
export { default as SystemUndeleteTransaction } from "./system/SystemUndeleteTransaction.js";
export { default as Timestamp } from "./Timestamp.js";
export { default as TokenAllowance } from "./account/TokenAllowance.js";
export { default as TokenAssociateTransaction } from "./token/TokenAssociateTransaction.js";
export { default as TokenBurnTransaction } from "./token/TokenBurnTransaction.js";
export { default as TokenRejectTransaction } from "./token/TokenRejectTransaction.js";
export { default as TokenRejectFlow } from "./token/TokenRejectFlow.js";
export { default as TokenCreateTransaction } from "./token/TokenCreateTransaction.js";
export { default as TokenDeleteTransaction } from "./token/TokenDeleteTransaction.js";
export { default as TokenDissociateTransaction } from "./token/TokenDissociateTransaction.js";
export { default as TokenFeeScheduleUpdateTransaction } from "./token/TokenFeeScheduleUpdateTransaction.js";
export { default as TokenFreezeTransaction } from "./token/TokenFreezeTransaction.js";
export { default as TokenGrantKycTransaction } from "./token/TokenGrantKycTransaction.js";
export { default as TokenId } from "./token/TokenId.js";
export { default as TokenInfo } from "./token/TokenInfo.js";
export { default as TokenInfoQuery } from "./token/TokenInfoQuery.js";
export { default as TokenMintTransaction } from "./token/TokenMintTransaction.js";
export { default as TokenNftAllowance } from "./account/TokenNftAllowance.js";
export { default as TokenNftInfo } from "./token/TokenNftInfo.js";
export { default as TokenNftInfoQuery } from "./token/TokenNftInfoQuery.js";
export { default as TokenPauseTransaction } from "./token/TokenPauseTransaction.js";
export { default as TokenRevokeKycTransaction } from "./token/TokenRevokeKycTransaction.js";
export { default as TokenSupplyType } from "./token/TokenSupplyType.js";
export { default as TokenType } from "./token/TokenType.js";
export { default as TokenUnfreezeTransaction } from "./token/TokenUnfreezeTransaction.js";
export { default as TokenUnpauseTransaction } from "./token/TokenUnpauseTransaction.js";
export { default as TokenUpdateTransaction } from "./token/TokenUpdateTransaction.js";
export { default as TokenWipeTransaction } from "./token/TokenWipeTransaction.js";
export { default as TopicCreateTransaction } from "./topic/TopicCreateTransaction.js";
export { default as TopicDeleteTransaction } from "./topic/TopicDeleteTransaction.js";
export { default as TopicId } from "./topic/TopicId.js";
export { default as TopicInfo } from "./topic/TopicInfo.js";
export { default as TopicInfoQuery } from "./topic/TopicInfoQuery.js";
export { default as TopicMessage } from "./topic/TopicMessage.js";
export { default as TopicMessageChunk } from "./topic/TopicMessageChunk.js";
export { default as TopicMessageQuery } from "./topic/TopicMessageQuery.js";
export { default as TopicMessageSubmitTransaction } from "./topic/TopicMessageSubmitTransaction.js";
export { default as TopicUpdateTransaction } from "./topic/TopicUpdateTransaction.js";
export { default as CustomFeeLimit } from "./transaction/CustomFeeLimit.js";
export { default as Transaction } from "./transaction/Transaction.js";
export { default as TransactionFeeSchedule } from "./TransactionFeeSchedule.js";
export { default as TransactionId } from "./transaction/TransactionId.js";
export { default as TransactionReceipt } from "./transaction/TransactionReceipt.js";
export { default as TransactionReceiptQuery } from "./transaction/TransactionReceiptQuery.js";
export { default as TransactionRecord } from "./transaction/TransactionRecord.js";
export { default as TransactionRecordQuery } from "./transaction/TransactionRecordQuery.js";
export { default as TransactionResponse } from "./transaction/TransactionResponse.js";
export { default as Transfer } from "./Transfer.js";
export { default as TransferTransaction } from "./account/TransferTransaction.js";
export { default as Wallet } from "./Wallet.js";
export { default as Logger } from "./logger/Logger.js";
export { default as LogLevel } from "./logger/LogLevel.js";
export { EntityIdHelper };
export { default as Long } from "long";
export { default as FreezeType } from "./FreezeType.js";
export { default as TokenKeyValidation } from "./token/TokenKeyValidation.js";

export { default as StatusError } from "./StatusError.js";
export { default as MaxAttemptsOrTimeoutError } from "./MaxAttemptsOrTimeoutError.js";
export { default as PrecheckStatusError } from "./PrecheckStatusError.js";
export { default as ReceiptStatusError } from "./ReceiptStatusError.js";
export { default as LedgerId } from "./LedgerId.js";
export { default as TokenUpdateNftsTransaction } from "./token/TokenUpdateNftsTransaction.js";
export { default as NodeCreateTransaction } from "./node/NodeCreateTransaction.js";
export { default as ServiceEndpoint } from "./node/ServiceEndpoint.js";
export { default as NodeDeleteTransaction } from "./node/NodeDeleteTransaction.js";
export { default as NodeUpdateTransaction } from "./node/NodeUpdateTransaction.js";

export { default as WebClient } from "./client/WebClient.js";

/**
 * @typedef {import("./client/Client.js").NetworkName} ClientNetworkName
 * @typedef {import("./Provider.js").Provider} Provider
 * @typedef {import("./Signer.js").Signer} Signer
 * @typedef {import("./account/AccountBalance.js").AccountBalanceJson} AccountBalanceJson
 * @typedef {import("./account/AccountBalance.js").TokenBalanceJson} TokenBalanceJson
 * @typedef {import("./transaction/TransactionResponse.js").TransactionResponseJSON} TransactionResponseJSON
 */

/**
 * @typedef {object} NetworkNameType
 * @property {ClientNetworkName} Mainnet
 * @property {ClientNetworkName} Testnet
 * @property {ClientNetworkName} Previewnet
 */
/**
 * @type {NetworkNameType}
 */
export const NetworkName = {
    Mainnet: "mainnet",
    Testnet: "testnet",
    Previewnet: "previewnet",
};

import "./query/CostQuery.js";
// Filename: src/file/FileAppendTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import * as utf8 from "../encoding/utf8.js";
import FileId from "./FileId.js";
import TransactionId from "../transaction/TransactionId.js";
import Timestamp from "../Timestamp.js";
import List from "../transaction/List.js";
import AccountId from "../account/AccountId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IFileAppendTransactionBody} HieroProto.proto.IFileAppendTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
 */

/**
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<Channel, *>} Client
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 */

/**
 * A transaction specifically to append data to a file on the network.
 *
 * If a file has multiple keys, all keys must sign to modify its contents.
 */
export default class FileAppendTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     * @param {Uint8Array | string} [props.contents]
     * @param {number} [props.maxChunks]
     * @param {number} [props.chunkSize]
     * @param {number} [props.chunkInterval]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._contents = null;

        /**
         * @private
         * @type {number}
         */
        this._maxChunks = 20;

        /**
         * @private
         * @type {number}
         */
        this._chunkSize = 4096;

        /**
         * @private
         * @type {number}
         */
        this._chunkInterval = 10;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.contents != null) {
            this.setContents(props.contents);
        }

        if (props.maxChunks != null) {
            this.setMaxChunks(props.maxChunks);
        }

        if (props.chunkSize != null) {
            this.setChunkSize(props.chunkSize);
        }

        if (props.chunkInterval != null) {
            this.setChunkInterval(props.chunkInterval);
        }

        /** @type {List<TransactionId>} */
        this._transactionIds = new List();
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {FileAppendTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const append =
            /** @type {HieroProto.proto.IFileAppendTransactionBody} */ (
                body.fileAppend
            );

        let contents;

        // The increment value depends on whether the node IDs list is empty or not.
        // The node IDs list is not empty if the transaction has been frozen
        // before serialization and deserialization, otherwise, it's empty.
        const incrementValue = nodeIds.length > 0 ? nodeIds.length : 1;

        for (let i = 0; i < bodies.length; i += incrementValue) {
            const fileAppend =
                /** @type {HieroProto.proto.IFileAppendTransactionBody} */ (
                    bodies[i].fileAppend
                );
            if (fileAppend.contents == null) {
                break;
            }

            if (contents == null) {
                contents = new Uint8Array(
                    /** @type {Uint8Array} */ (fileAppend.contents),
                );
                continue;
            }

            /** @type {Uint8Array} */
            const concat = new Uint8Array(
                contents.length +
                    /** @type {Uint8Array} */ (fileAppend.contents).length,
            );
            concat.set(contents, 0);
            concat.set(
                /** @type {Uint8Array} */ (fileAppend.contents),
                contents.length,
            );
            contents = concat;
        }
        const chunkSize = append.contents?.length || undefined;
        const maxChunks = bodies.length
            ? bodies.length / incrementValue
            : undefined;
        let chunkInterval;
        if (transactionIds.length > 1) {
            const firstValidStart = transactionIds[0].validStart;
            const secondValidStart = transactionIds[1].validStart;
            if (firstValidStart && secondValidStart) {
                chunkInterval = secondValidStart.nanos
                    .sub(firstValidStart.nanos)
                    .toNumber();
            }
        }

        return Transaction._fromProtobufTransactions(
            new FileAppendTransaction({
                fileId:
                    append.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {HieroProto.proto.IFileID} */ (
                                  append.fileID
                              ),
                          )
                        : undefined,
                contents,
                chunkSize,
                maxChunks,
                chunkInterval,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @override
     * @returns {number}
     */
    getRequiredChunks() {
        if (this._contents == null) {
            return 1;
        }

        const result = Math.ceil(this._contents.length / this._chunkSize);

        return result;
    }

    /**
     * @returns {?Uint8Array}
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set the given byte array as the file's contents.
     *
     * This may be omitted to append an empty file.
     *
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a HederaPreCheckStatusException
     * with Status#TransactionOversize.
     *
     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
     * transaction with the first chunk and then use FileAppendTransaction with
     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
     *
     * @param {Uint8Array | string} contents
     * @returns {this}
     */
    setContents(contents) {
        this._requireNotFrozen();
        this._contents =
            contents instanceof Uint8Array ? contents : utf8.encode(contents);

        return this;
    }

    /**
     * @returns {?number}
     */
    get maxChunks() {
        return this._maxChunks;
    }

    /**
     * @param {number} maxChunks
     * @returns {this}
     */
    setMaxChunks(maxChunks) {
        this._requireNotFrozen();
        this._maxChunks = maxChunks;
        return this;
    }

    /**
     * @returns {?number}
     */
    get chunkSize() {
        return this._chunkSize;
    }

    /**
     * @param {number} chunkSize
     * @returns {this}
     */
    setChunkSize(chunkSize) {
        this._chunkSize = chunkSize;
        return this;
    }

    /**
     * @returns {number}
     */
    get chunkInterval() {
        return this._chunkInterval;
    }

    /**
     * @param {number} chunkInterval The valid start interval between chunks in nanoseconds
     * @returns {this}
     */
    setChunkInterval(chunkInterval) {
        this._chunkInterval = chunkInterval;
        return this;
    }

    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        super.freezeWith(client);

        if (this._contents == null) {
            return this;
        }

        let nextTransactionId = this._getTransactionId();

        // Hack around the locked list. Should refactor a bit to remove such code
        this._transactionIds.locked = false;

        this._transactions.clear();
        this._transactionIds.clear();
        this._signedTransactions.clear();

        for (let chunk = 0; chunk < this.getRequiredChunks(); chunk++) {
            this._transactionIds.push(nextTransactionId);
            this._transactionIds.advance();

            for (const nodeAccountId of this._nodeAccountIds.list) {
                this._signedTransactions.push(
                    this._makeSignedTransaction(nodeAccountId),
                );
            }

            nextTransactionId = new TransactionId(
                /** @type {AccountId} */ (nextTransactionId.accountId),
                new Timestamp(
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).seconds,
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).nanos.add(this._chunkInterval),
                ),
            );
        }

        this._transactionIds.advance();
        this._transactionIds.setLocked();

        return this;
    }

    /**
     * @returns {ScheduleCreateTransaction}
     */
    schedule() {
        this._requireNotFrozen();

        if (this._contents != null && this._contents.length > this._chunkSize) {
            throw new Error(
                `cannot schedule \`FileAppendTransaction\` with message over ${this._chunkSize} bytes`,
            );
        }

        return super.schedule();
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client, requestTimeout) {
        return (await this.executeAll(client, requestTimeout))[0];
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse[]>}
     */
    async executeAll(client, requestTimeout) {
        if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {
            throw new Error(
                `cannot execute \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`,
            );
        }

        if (!super._isFrozen()) {
            this.freezeWith(client);
        }

        // on execute, sign each transaction with the operator, if present
        // and we are signing a transaction that used the default transaction ID

        const transactionId = this._getTransactionId();
        const operatorAccountId = client.operatorAccountId;

        if (
            operatorAccountId != null &&
            operatorAccountId.equals(
                /** @type {AccountId} */ (transactionId.accountId),
            )
        ) {
            await super.signWithOperator(client);
        }

        const responses = [];
        let remainingTimeout = requestTimeout;

        for (let i = 0; i < this._transactionIds.length; i++) {
            const startTimestamp = Date.now();
            const response = await super.execute(client, remainingTimeout);

            if (remainingTimeout != null) {
                remainingTimeout = Date.now() - startTimestamp;
            }

            await response.getReceipt(client);
            responses.push(response);
        }

        return responses;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.appendContent(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileAppend";
    }

    /**
     * Build all the transactions
     * when transactions are not complete.
     * @override
     * @internal
     */
    _buildIncompleteTransactions() {
        const dummyAccountId = AccountId.fromString("0.0.0");
        const accountId = this.transactionId?.accountId || dummyAccountId;
        const validStart =
            this.transactionId?.validStart || Timestamp.fromDate(new Date());

        if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {
            throw new Error(
                `cannot build \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`,
            );
        }

        // Hack around the locked list. Should refactor a bit to remove such code
        this._transactionIds.locked = false;

        this._transactions.clear();
        this._transactionIds.clear();
        this._signedTransactions.clear();

        for (let chunk = 0; chunk < this.getRequiredChunks(); chunk++) {
            let nextTransactionId = TransactionId.withValidStart(
                accountId,
                validStart.plusNanos(this._chunkInterval * chunk),
            );
            this._transactionIds.push(nextTransactionId);
            this._transactionIds.advance();

            if (this._nodeAccountIds.list.length === 0) {
                this._transactions.push(this._makeSignedTransaction(null));
            } else {
                for (const nodeAccountId of this._nodeAccountIds.list) {
                    this._transactions.push(
                        this._makeSignedTransaction(nodeAccountId),
                    );
                }
            }
        }

        this._transactionIds.advance();
        this._transactionIds.setLocked();
    }

    /**
     * Build all the signed transactions
     * @override
     * @internal
     */
    _buildAllTransactions() {
        if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) {
            throw new Error(
                `cannot build \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`,
            );
        }
        for (let i = 0; i < this._signedTransactions.length; i++) {
            this._buildTransaction(i);
        }
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileAppendTransaction:${timestamp.toString()}`;
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IFileAppendTransactionBody}
     */
    _makeTransactionData() {
        const length = this._contents != null ? this._contents.length : 0;
        const startIndex = this._transactionIds.index * this._chunkSize;
        const endIndex = Math.min(startIndex + this._chunkSize, length);

        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            contents:
                this._contents != null
                    ? this._contents.slice(startIndex, endIndex)
                    : null,
        };
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileAppend", FileAppendTransaction._fromProtobuf);
// Filename: src/file/FileContentsQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import FileId from "./FileId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.IFileGetContentsQuery} HieroProto.proto.IFileGetContentsQuery
 * @typedef {import("@hashgraph/proto").proto.IFileGetContentsResponse} HieroProto.proto.IFileGetContentsResponse
 * @typedef {import("@hashgraph/proto").proto.FileGetContentsResponse.IFileContents} HieroProto.proto.FileGetContentsResponse.IFileContents
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<Uint8Array>}
 * Retrieve the content of a file in HFS.<br/>
 * Note that this query retrieves _only_ the file content, not any of
 * the metadata for the file.
 */
export default class FileContentsQuery extends Query {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?FileId}
         * @private
         */
        this._fileId = null;
        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {FileContentsQuery}
     */
    static _fromProtobuf(query) {
        const contents = /** @type {HieroProto.proto.IFileGetContentsQuery} */ (
            query.fileGetContents
        );

        return new FileContentsQuery({
            fileId:
                contents.fileID != null
                    ? FileId._fromProtobuf(contents.fileID)
                    : undefined,
        });
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.file.getFileContent(request);
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the file ID for which the info is being requested.
     *
     * @param {FileId | string} fileId
     * @returns {FileContentsQuery}
     */
    setFileId(fileId) {
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const fileGetContents =
            /** @type {HieroProto.proto.IFileGetContentsResponse} */ (
                response.fileGetContents
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            fileGetContents.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @returns {Promise<Uint8Array>}
     */
    _mapResponse(response) {
        const fileContentsResponse =
            /** @type {HieroProto.proto.IFileGetContentsResponse} */ (
                response.fileGetContents
            );
        const fileConents =
            /** @type {HieroProto.proto.FileGetContentsResponse.IFileContents} */ (
                fileContentsResponse.fileContents
            );
        const contents = /** @type {Uint8Array} */ (fileConents.contents);

        return Promise.resolve(contents);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            fileGetContents: {
                header,
                fileID:
                    this._fileId != null ? this._fileId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `FileContentsQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("fileGetContents", FileContentsQuery._fromProtobuf);
// Filename: src/file/FileCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import Transaction, {
    TRANSACTION_REGISTRY,
    DEFAULT_AUTO_RENEW_PERIOD,
} from "../transaction/Transaction.js";
import * as utf8 from "../encoding/utf8.js";
import Timestamp from "../Timestamp.js";
import Key from "../Key.js";
import KeyList from "../KeyList.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IFileCreateTransactionBody} HieroProto.proto.IFileCreateTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a new Hedera™ crypto-currency file.
 */
export default class FileCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Key[] | KeyList} [props.keys]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Uint8Array | string} [props.contents]
     * @param {string} [props.fileMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key[]}
         */
        this._keys = null;

        /**
         * @private
         * @type {Timestamp}
         */
        this._expirationTime = new Timestamp(0, 0).plusNanos(
            Long.fromNumber(Date.now())
                .mul(1000000)
                .add(DEFAULT_AUTO_RENEW_PERIOD.mul(1000000000)),
        );

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._contents = null;

        /**
         * @private
         * @type {?string}
         */
        this._fileMemo = null;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.keys != null) {
            this.setKeys(props.keys);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.contents != null) {
            this.setContents(props.contents);
        }

        if (props.fileMemo && props.fileMemo != null) {
            this.setFileMemo(props.fileMemo);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {FileCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const create =
            /** @type {HieroProto.proto.IFileCreateTransactionBody} */ (
                body.fileCreate
            );

        return Transaction._fromProtobufTransactions(
            new FileCreateTransaction({
                keys:
                    create.keys != null
                        ? create.keys.keys != null
                            ? create.keys.keys.map((key) =>
                                  Key._fromProtobufKey(key),
                              )
                            : undefined
                        : undefined,
                expirationTime:
                    create.expirationTime != null
                        ? Timestamp._fromProtobuf(create.expirationTime)
                        : undefined,
                contents: create.contents != null ? create.contents : undefined,
                fileMemo: create.memo != null ? create.memo : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?Key[]}
     */
    get keys() {
        return this._keys;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {Key[] | KeyList} keys
     * @returns {this}
     */
    setKeys(keys) {
        this._requireNotFrozen();
        if (keys instanceof KeyList && keys.threshold != null) {
            throw new Error("Cannot set threshold key as file key");
        }

        this._keys = keys instanceof KeyList ? keys.toArray() : keys;

        return this;
    }

    /**
     * @returns {Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * Set the instant at which this file will expire, after which its contents will no longer be
     * available.
     *
     * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction
     * was invoked.
     *
     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
     *
     * @param {Timestamp | Date} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Timestamp
                ? expirationTime
                : Timestamp.fromDate(expirationTime);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set the given byte array as the file's contents.
     *
     * This may be omitted to create an empty file.
     *
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a HederaPreCheckStatusException
     * with Status#TransactionOversize.
     *
     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
     * transaction with the first chunk and then use FileAppendTransaction with
     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
     *
     * @param {Uint8Array | string} contents
     * @returns {this}
     */
    setContents(contents) {
        this._requireNotFrozen();
        this._contents =
            contents instanceof Uint8Array ? contents : utf8.encode(contents);

        return this;
    }

    /**
     * @returns {?string}
     */
    get fileMemo() {
        return this._fileMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setFileMemo(memo) {
        this._requireNotFrozen();
        this._fileMemo = memo;

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.createFile(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileCreate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IFileCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            keys:
                this._keys != null
                    ? {
                          keys: this._keys.map((key) => key._toProtobufKey()),
                      }
                    : null,
            expirationTime: this._expirationTime._toProtobuf(),
            contents: this._contents,
            memo: this._fileMemo,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileCreateTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileCreate", FileCreateTransaction._fromProtobuf);
// Filename: src/file/FileDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import FileId from "./FileId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IFileDeleteTransactionBody} HieroProto.proto.IFileDeleteTransactionBody
 */

/**
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * A transaction to delete a file on the Hedera network.
 *
 * When deleted, a file's contents are truncated to zero length and it can no longer be updated
 * or appended to, or its expiration time extended. FileContentsQuery and FileInfoQuery
 * will throw HederaPreCheckStatusException with a status of Status#FileDeleted.
 *
 * Only one of the file's keys needs to sign to delete the file, unless the key you have is part
 * of a KeyList.
 */
export default class FileDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {FileDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const fileDelete =
            /** @type {HieroProto.proto.IFileDeleteTransactionBody} */ (
                body.fileDelete
            );

        return Transaction._fromProtobufTransactions(
            new FileDeleteTransaction({
                fileId:
                    fileDelete.fileID != null
                        ? FileId._fromProtobuf(fileDelete.fileID)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the file ID which is being deleted in this transaction.
     *
     * @param {FileId | string} fileId
     * @returns {FileDeleteTransaction}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.deleteFile(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileDelete";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IFileDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileDeleteTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileDelete", FileDeleteTransaction._fromProtobuf);
// Filename: src/file/FileId.js
// SPDX-License-Identifier: Apache-2.0

import * as entity_id from "../EntityIdHelper.js";
import * as HieroProto from "@hashgraph/proto";
import Long from "long";

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency file on Hedera.
 */
export default class FileId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = entity_id.constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {FileId}
     */
    static fromString(text) {
        const result = entity_id.fromString(text);
        const id = new FileId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IFileID} id
     * @returns {FileId}
     */
    static _fromProtobuf(id) {
        const fileId = new FileId(
            id.shardNum != null ? Long.fromString(id.shardNum.toString()) : 0,
            id.realmNum != null ? Long.fromString(id.realmNum.toString()) : 0,
            id.fileNum != null ? Long.fromString(id.fileNum.toString()) : 0,
        );

        return fileId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        entity_id.validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FileId}
     */
    static fromBytes(bytes) {
        return FileId._fromProtobuf(HieroProto.proto.FileID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {FileId}
     */
    static fromSolidityAddress(address) {
        const [shard, realm, file] = entity_id.fromSolidityAddress(address);
        return new FileId(shard, realm, file);
    }

    /**
     * @returns {string} solidity address
     */
    toSolidityAddress() {
        return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IFileID}
     */
    _toProtobuf() {
        return {
            fileNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return entity_id.toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.FileID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {FileId}
     */
    clone() {
        const id = new FileId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {FileId} other
     * @returns {number}
     */
    compare(other) {
        return entity_id.compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num],
        );
    }
}

/**
 * The public node address book for the current network.
 */
FileId.ADDRESS_BOOK = new FileId(102);

/**
 * The current fee schedule for the network.
 */
FileId.FEE_SCHEDULE = new FileId(111);

/**
 * The current exchange rate of HBAR to USD.
 */
FileId.EXCHANGE_RATES = new FileId(112);
// Filename: src/file/FileInfo.js
// SPDX-License-Identifier: Apache-2.0

import FileId from "./FileId.js";
import Timestamp from "../Timestamp.js";
import Long from "long";
import KeyList from "../KeyList.js";
import LedgerId from "../LedgerId.js";
import * as HieroProto from "@hashgraph/proto";

const { proto } = HieroProto;

/**
 * Response when the client sends the node CryptoGetInfoQuery.
 */
export default class FileInfo {
    /**
     * @private
     * @param {object} props
     * @param {FileId} props.fileId
     * @param {Long} props.size
     * @param {Timestamp} props.expirationTime
     * @param {boolean} props.isDeleted
     * @param {KeyList} props.keys
     * @param {string} props.fileMemo
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * The ID of the file for which information is requested.
         *
         * @readonly
         */
        this.fileId = props.fileId;

        /**
         * Number of bytes in contents.
         *
         * @readonly
         */
        this.size = props.size;

        /**
         * The current time at which this account is set to expire.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * True if deleted but not yet expired.
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * One of these keys must sign in order to delete the file.
         * All of these keys must sign in order to update the file.
         *
         * @readonly
         */
        this.keys = props.keys;

        this.fileMemo = props.fileMemo;

        this.ledgerId = props.ledgerId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.FileGetInfoResponse.IFileInfo} info
     * @returns {FileInfo}
     */
    static _fromProtobuf(info) {
        const size = /** @type {Long | number} */ (info.size);

        return new FileInfo({
            fileId: FileId._fromProtobuf(
                /** @type {HieroProto.proto.IFileID} */ (info.fileID),
            ),
            size: size instanceof Long ? size : Long.fromValue(size),
            expirationTime: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */ (
                    info.expirationTime
                ),
            ),
            isDeleted: /** @type {boolean} */ (info.deleted),
            keys:
                info.keys != null
                    ? KeyList.__fromProtobufKeyList(info.keys)
                    : new KeyList(),
            fileMemo: info.memo != null ? info.memo : "",
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.FileGetInfoResponse.IFileInfo}
     */
    _toProtobuf() {
        return {
            fileID: this.fileId._toProtobuf(),
            size: this.size,
            expirationTime: this.expirationTime._toProtobuf(),
            deleted: this.isDeleted,
            keys: this.keys._toProtobufKey().keyList,
            memo: this.fileMemo,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {FileInfo}
     */
    static fromBytes(bytes) {
        return FileInfo._fromProtobuf(
            HieroProto.proto.FileGetInfoResponse.FileInfo.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return proto.FileGetInfoResponse.FileInfo.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/file/FileInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import FileId from "./FileId.js";
import FileInfo from "./FileInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.IFileGetInfoQuery} HieroProto.proto.IFileGetInfoQuery
 * @typedef {import("@hashgraph/proto").proto.IFileGetInfoResponse} HieroProto.proto.IFileGetInfoResponse
 * @typedef {import("@hashgraph/proto").proto.FileGetInfoResponse.IFileInfo} HieroProto.proto.IFileInfo
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @augments {Query<FileInfo>}
 * Retrieve the metadata for a file in HFS.<br/>
 * Note that this query does not retrieve the file _content_.
 */
export default class FileInfoQuery extends Query {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     */
    constructor(props = {}) {
        super();

        /**
         * @type {?FileId}
         * @private
         */
        this._fileId = null;
        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {FileInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {HieroProto.proto.IFileGetInfoQuery} */ (
            query.fileGetInfo
        );

        return new FileInfoQuery({
            fileId:
                info.fileID != null
                    ? FileId._fromProtobuf(info.fileID)
                    : undefined,
        });
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the file ID for which the info is being requested.
     *
     * @param {FileId | string} fileId
     * @returns {FileInfoQuery}
     */
    setFileId(fileId) {
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.file.getFileInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const fileGetInfo =
            /** @type {HieroProto.proto.IFileGetInfoResponse} */ (
                response.fileGetInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            fileGetInfo.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<FileInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {HieroProto.proto.IFileGetInfoResponse} */ (
            response.fileGetInfo
        );

        return Promise.resolve(
            FileInfo._fromProtobuf(
                /** @type {HieroProto.proto.IFileInfo} */ (info.fileInfo),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            fileGetInfo: {
                header,
                fileID:
                    this._fileId != null ? this._fileId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `FileInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("fileGetInfo", FileInfoQuery._fromProtobuf);
// Filename: src/file/FileUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Timestamp from "../Timestamp.js";
import * as utf8 from "../encoding/utf8.js";
import FileId from "./FileId.js";
import Key from "../Key.js";
import KeyList from "../KeyList.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IFileUpdateTransactionBody} HieroProto.proto.IFileUpdateTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a new Hedera™ crypto-currency file.
 */
export default class FileUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {FileId | string} [props.fileId]
     * @param {Key[] | KeyList} [props.keys]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Uint8Array | string} [props.contents]
     * @param {?string} [props.fileMemo]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?Key[]}
         */
        this._keys = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._contents = null;

        /**
         * @private
         * @type {?string}
         */
        this._fileMemo = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.keys != null) {
            this.setKeys(props.keys);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.contents != null) {
            this.setContents(props.contents);
        }

        if (props.fileMemo && props.fileMemo != null) {
            this.setFileMemo(props.fileMemo);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {FileUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const update =
            /** @type {HieroProto.proto.IFileUpdateTransactionBody} */ (
                body.fileUpdate
            );

        return Transaction._fromProtobufTransactions(
            new FileUpdateTransaction({
                fileId:
                    update.fileID != null
                        ? FileId._fromProtobuf(update.fileID)
                        : undefined,
                keys:
                    update.keys != null
                        ? update.keys.keys != null
                            ? update.keys.keys.map((key) =>
                                  Key._fromProtobufKey(key),
                              )
                            : undefined
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
                contents: update.contents != null ? update.contents : undefined,
                fileMemo:
                    update.memo != null
                        ? Object.hasOwn(update.memo, "value")
                            ? update.memo.value
                            : undefined
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @returns {?Key[]}
     */
    get keys() {
        return this._keys;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * To require more than one key to sign to delete a file, add them to a
     * KeyList and pass that here.
     *
     * The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param {Key[] | KeyList} keys
     * @returns {this}
     */
    setKeys(keys) {
        this._requireNotFrozen();
        if (keys instanceof KeyList && keys.threshold != null) {
            throw new Error("Cannot set threshold key as file key");
        }

        this._keys = keys instanceof KeyList ? keys.toArray() : keys;

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * Set the instant at which this file will expire, after which its contents will no longer be
     * available.
     *
     * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction
     * was invoked.
     *
     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).
     *
     * @param {Timestamp | Date} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime =
            expirationTime instanceof Timestamp
                ? expirationTime
                : Timestamp.fromDate(expirationTime);

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get contents() {
        return this._contents;
    }

    /**
     * Set the given byte array as the file's contents.
     *
     * This may be omitted to update an empty file.
     *
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a HederaPreCheckStatusException
     * with Status#TransactionOversize.
     *
     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this
     * transaction with the first chunk and then use FileAppendTransaction with
     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.
     *
     * @param {Uint8Array | string} contents
     * @returns {this}
     */
    setContents(contents) {
        this._requireNotFrozen();
        this._contents =
            contents instanceof Uint8Array ? contents : utf8.encode(contents);

        return this;
    }

    /**
     * @returns {?string}
     */
    get fileMemo() {
        return this._fileMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setFileMemo(memo) {
        this._requireNotFrozen();
        this._fileMemo = memo;

        return this;
    }

    /**
     * @returns {this}
     */
    clearFileMemo() {
        this._requireNotFrozen();
        this._fileMemo = null;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._fileId != null) {
            this._fileId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.file.updateFile(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "fileUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IFileUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            keys:
                this._keys != null
                    ? {
                          keys: this._keys.map((key) => key._toProtobufKey()),
                      }
                    : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            contents: this._contents,
            memo:
                this._fileMemo != null
                    ? {
                          value: this._fileMemo,
                      }
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FileUpdateTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("fileUpdate", FileUpdateTransaction._fromProtobuf);
// Filename: src/grpc/GrpcServiceError.js
// SPDX-License-Identifier: Apache-2.0

import GrpcStatus from "./GrpcStatus.js";

/**
 * Describes how the gRPC request failed.
 *
 * Exists in order for the Hiero JavaScript SDK to produce the same error type for gRPC errors regardless of
 * operating in node or the browser.
 *
 * Definition taken from <https://grpc.github.io/grpc/node/grpc.html#~ServiceError>.
 */
export default class GrpcServiceError extends Error {
    /**
     * @param {GrpcStatus} status
     * @param {string} [nodeAccountId]
     */
    constructor(status, nodeAccountId) {
        super(
            `gRPC service failed with: Status: ${status.toString()}, Code: ${status.valueOf()}`,
        );

        /**
         * @readonly
         */
        this.status = status;

        /**
         * Optional: node account ID associated with the error
         */
        this.nodeAccountId = nodeAccountId;

        this.name = "GrpcServiceError";

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, GrpcServiceError);
        }
    }

    /**
     * @param {Error & { code?: number; details?: string }} obj
     * @returns {Error}
     */
    static _fromResponse(obj) {
        if (obj.code != null && obj.details != null) {
            const status = GrpcStatus._fromValue(obj.code);
            const err = new GrpcServiceError(status);
            err.stack += `\nCaused by: ${
                obj.stack ? obj.stack.toString() : ""
            }`;
            err.message += `: ${obj.details}`;
            return err;
        } else {
            return /** @type {Error} */ (obj);
        }
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.name}: ${this.message}`;
    }
}
// Filename: src/grpc/GrpcStatus.js
// SPDX-License-Identifier: Apache-2.0

export default class GrpcStatus {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {number} code
     * @returns {GrpcStatus}
     */
    static _fromValue(code) {
        switch (code) {
            case 0:
                return GrpcStatus.Ok;
            case 1:
                return GrpcStatus.Cancelled;
            case 2:
                return GrpcStatus.Unknown;
            case 3:
                return GrpcStatus.InvalidArgument;
            case 4:
                return GrpcStatus.DeadlineExceeded;
            case 5:
                return GrpcStatus.NotFound;
            case 6:
                return GrpcStatus.AlreadyExists;
            case 7:
                return GrpcStatus.PermissionDenied;
            case 8:
                return GrpcStatus.ResourceExhausted;
            case 9:
                return GrpcStatus.FailedPrecondition;
            case 10:
                return GrpcStatus.Aborted;
            case 11:
                return GrpcStatus.OutOfRange;
            case 12:
                return GrpcStatus.Unimplemented;
            case 13:
                return GrpcStatus.Internal;
            case 14:
                return GrpcStatus.Unavailable;
            case 15:
                return GrpcStatus.DataLoss;
            case 16:
                return GrpcStatus.Unauthenticated;
            case 17:
                return GrpcStatus.Timeout;
            case 18:
                return GrpcStatus.GrpcWeb;
            default:
                throw new Error(
                    "(BUG) non-exhaustive GrpcStatus switch statement",
                );
        }
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case GrpcStatus.Ok:
                return "OK";
            case GrpcStatus.Cancelled:
                return "CANCELLED";
            case GrpcStatus.Unknown:
                return "UNKNOWN";
            case GrpcStatus.InvalidArgument:
                return "INVALID_ARGUMENT";
            case GrpcStatus.DeadlineExceeded:
                return "DEADLINE_EXCEEDED";
            case GrpcStatus.NotFound:
                return "NOT_FOUND";
            case GrpcStatus.AlreadyExists:
                return "ALREADY_EXISTS";
            case GrpcStatus.PermissionDenied:
                return "PERMISSION_DENIED";
            case GrpcStatus.Unauthenticated:
                return "UNAUTHENTICATED";
            case GrpcStatus.ResourceExhausted:
                return "RESOURCE_EXHAUSTED";
            case GrpcStatus.FailedPrecondition:
                return "FAILED_PRECONDITION";
            case GrpcStatus.Aborted:
                return "ABORTED";
            case GrpcStatus.OutOfRange:
                return "OUT_OF_RANGE";
            case GrpcStatus.Unimplemented:
                return "UNIMPLEMENTED";
            case GrpcStatus.Internal:
                return "INTERNAL";
            case GrpcStatus.Unavailable:
                return "UNAVAILABLE";
            case GrpcStatus.DataLoss:
                return "DATA_LOSS";
            case GrpcStatus.Timeout:
                return "TIMEOUT";
            case GrpcStatus.GrpcWeb:
                return "GRPC_WEB";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @returns {number}
     */
    valueOf() {
        return this._code;
    }
}

GrpcStatus.Ok = new GrpcStatus(0);
GrpcStatus.Cancelled = new GrpcStatus(1);
GrpcStatus.Unknown = new GrpcStatus(2);
GrpcStatus.InvalidArgument = new GrpcStatus(3);
GrpcStatus.DeadlineExceeded = new GrpcStatus(4);
GrpcStatus.NotFound = new GrpcStatus(5);
GrpcStatus.AlreadyExists = new GrpcStatus(6);
GrpcStatus.PermissionDenied = new GrpcStatus(7);
GrpcStatus.ResourceExhausted = new GrpcStatus(8);
GrpcStatus.FailedPrecondition = new GrpcStatus(9);
GrpcStatus.Aborted = new GrpcStatus(10);
GrpcStatus.OutOfRange = new GrpcStatus(11);
GrpcStatus.Unimplemented = new GrpcStatus(12);
GrpcStatus.Internal = new GrpcStatus(13);
GrpcStatus.Unavailable = new GrpcStatus(14);
GrpcStatus.DataLoss = new GrpcStatus(15);
GrpcStatus.Unauthenticated = new GrpcStatus(16);
GrpcStatus.Timeout = new GrpcStatus(17);
GrpcStatus.GrpcWeb = new GrpcStatus(18);
// Filename: src/http/HttpError.js
// SPDX-License-Identifier: Apache-2.0
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import HttpStatus from "./HttpStatus.js";

/**
 * Describes how the http request failed.
 */
export default class HttpError extends Error {
    /**
     * @param {HttpStatus} status
     */
    constructor(status) {
        super(`failed with error code: ${status.toString()}`);

        /**
         * @readonly
         */
        this.status = status;

        this.name = "HttpError";

        if (typeof Error.captureStackTrace !== "undefined") {
            Error.captureStackTrace(this, HttpError);
        }
    }
}
// Filename: src/http/HttpStatus.js
// SPDX-License-Identifier: Apache-2.0

export default class HttpStatus {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {number} code
     * @returns {HttpStatus}
     */
    static _fromValue(code) {
        return new HttpStatus(code);
    }

    /**
     * @returns {string}
     */
    toString() {
        return this._code.toString();
    }

    /**
     * @returns {number}
     */
    valueOf() {
        return this._code;
    }
}
// Filename: src/index.js
// SPDX-License-Identifier: Apache-2.0

/**
 * The entry point for NodeJS applications
 */

export * from "./exports.js";

export { default as LocalProvider } from "./LocalProvider.js";
export { default as Client } from "./client/NodeClient.js";
// Filename: src/logger/LogLevel.js
// SPDX-License-Identifier: Apache-2.0

export default class LogLevel {
    /**
     * @hideconstructor
     * @internal
     * @param {string} name
     */
    constructor(name) {
        /** @readonly */
        this._name = name;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case LogLevel.Silent:
                return "silent";
            case LogLevel.Trace:
                return "trace";
            case LogLevel.Debug:
                return "debug";
            case LogLevel.Info:
                return "info";
            case LogLevel.Warn:
                return "warn";
            case LogLevel.Error:
                return "error";
            case LogLevel.Fatal:
                return "fatal";
            default:
                return `Unknown log level (${this._name})`;
        }
    }

    /**
     * @param {string} level
     * @returns {LogLevel}
     */
    static _fromString(level) {
        switch (level) {
            case "silent":
                return LogLevel.Silent;
            case "trace":
                return LogLevel.Trace;
            case "debug":
                return LogLevel.Debug;
            case "info":
                return LogLevel.Info;
            case "warn":
                return LogLevel.Warn;
            case "error":
                return LogLevel.Error;
            case "fatal":
                return LogLevel.Fatal;
            default:
                throw new Error(`Unknown log level: ${level}`);
        }
    }
}

LogLevel.Silent = new LogLevel("silent");
LogLevel.Trace = new LogLevel("trace");
LogLevel.Debug = new LogLevel("debug");
LogLevel.Info = new LogLevel("info");
LogLevel.Warn = new LogLevel("warn");
LogLevel.Error = new LogLevel("error");
LogLevel.Fatal = new LogLevel("fatal");
// Filename: src/logger/Logger.js
// SPDX-License-Identifier: Apache-2.0
import pino from "pino";
import LogLevel from "./LogLevel.js";

/**
 * A Logger class for logging messages in the Hiero JavaScript SDK.
 * This class provides a flexible logging mechanism that can log messages
 * to various outputs, including the console and log files. It supports
 * different log levels (e.g., trace, debug, info, warn, error, fatal)
 * and allows for configuration of logging behavior, such as synchronous
 * writes and file management.
 *
 * The Logger can be initialized with a specific log level, a log file path,
 * and options for synchronous writes and file synchronization. It also
 * provides methods to change the logging level and to enable or disable
 * silent mode, which suppresses all log messages.
 */
export default class Logger {
    /**
     * @param {LogLevel} level
     * @param {string} logFile the file to log to, if empty, logs to console
     * @param {boolean} sync perform writes synchronously (similar to console.log)
     * @param {boolean} fsync perform a fsyncSync every time a write is completed
     * @param {boolean} mkdir ensure directory for dest file exists when true (default false)
     * @param {number} minLength the minimum length of the internal buffer that is required to be full before flushing
     */
    constructor(
        level,
        logFile = "",
        sync = true,
        fsync = true,
        mkdir = true,
        minLength = 0,
    ) {
        const fileTransport = logFile
            ? pino.destination({
                  dest: logFile,
                  sync,
                  fsync,
                  mkdir,
                  minLength,
              })
            : null;

        const loggerOptions = fileTransport
            ? {
                  level: level.toString(),
                  timestamp: pino.stdTimeFunctions.isoTime,
                  formatters: {
                      bindings: () => {
                          return {};
                      },
                      // @ts-ignore
                      level: (label) => {
                          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access
                          return { level: label.toUpperCase() };
                      },
                  },
              }
            : {
                  level: level.toString(),
                  transport: {
                      target: "pino-pretty",
                      options: {
                          translateTime: "SYS:dd-mm-yyyy HH:MM:ss",
                          ignore: "pid,hostname",
                      },
                  },
              };

        /**
         * @private
         * @type {import("pino").Logger}
         */
        this._logger = fileTransport
            ? pino(loggerOptions, fileTransport)
            : pino(loggerOptions);

        /**
         * @private
         * @type {LogLevel}
         */
        this._previousLevel = level;
    }

    /**
     * Set logger
     *
     * @public
     * @param {import("pino").Logger} logger
     * @returns {this}
     */
    setLogger(logger) {
        this._logger = logger;
        return this;
    }

    /**
     * Set log level
     *
     * @public
     * @param {LogLevel} level
     * @returns {this}
     */
    setLevel(level) {
        this._previousLevel = LogLevel._fromString(this._logger.level);
        this._logger.level = level.toString();
        return this;
    }

    /**
     * Get logging level
     *
     * @public
     * @returns {LogLevel}
     */
    get level() {
        return LogLevel._fromString(this._logger.level);
    }

    /**
     * Get logging level
     *
     * @public
     * @returns {{[level: number]: string}}
     */
    get levels() {
        return this._logger.levels.labels;
    }

    /**
     * Set silent mode on/off
     *
     * @public
     * @description If set to true, the logger will not display any log messages
     * - This can also be achieved by calling `.setLevel(LogLevel.Silent)`
     * @param {boolean} silent
     * @returns {this}
     */
    setSilent(silent) {
        if (silent) {
            this._logger.level = LogLevel.Silent.toString();
        } else {
            // Here we are setting the level to the previous level, before silencing the logger
            this._logger.level = this._previousLevel.toString();
        }
        return this;
    }

    /**
     * Get silent mode
     *
     * @public
     * @returns {boolean}
     */
    get silent() {
        return this._logger.level == LogLevel.Silent.toString();
    }

    /**
     * Log trace
     *
     * @public
     * @param {string} message
     * @returns {void}
     */
    trace(message) {
        this._logger.trace(message);
    }

    /**
     * Log debug
     *
     * @public
     * @param {string} message
     * @returns {void}
     */
    debug(message) {
        this._logger.debug(message);
    }

    /**
     * Log info
     *
     * @public
     * @param {string} message
     * @returns {void}
     */
    info(message) {
        this._logger.info(message);
    }

    /**
     * Log warn
     *
     * @public
     * @param {string} message
     * @returns {void}
     */
    warn(message) {
        this._logger.warn(message);
    }

    /**
     * Log error
     *
     * @public
     * @param {string} message
     * @returns {void}
     */
    error(message) {
        this._logger.error(message);
    }

    /**
     * Log fatal
     *
     * @public
     * @param {string} message
     * @returns {void}
     */
    fatal(message) {
        this._logger.fatal(message);
    }
}
// Filename: src/long.js
// SPDX-License-Identifier: Apache-2.0

import BigNumber from "bignumber.js";

/**
 * @typedef {{low: number, high: number, unsigned: boolean}} LongObject
 * @typedef {import("long")} Long
 */

/**
 * @param {Long | number | string | LongObject | BigNumber} value
 * @returns {BigNumber}
 */
export function valueToLong(value) {
    if (BigNumber.isBigNumber(value)) {
        return value;
    } else {
        return new BigNumber(value.toString());
    }
}
// Filename: src/native.js
// SPDX-License-Identifier: Apache-2.0

/**
 * The entry point for React Native applications
 */

export * from "./exports.js";

export { default as Client } from "./client/NativeClient.js";
// Filename: src/network/AddressBookQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query from "../query/Query.js";
import NodeAddress from "../address_book/NodeAddress.js";
import NodeAddressBook from "../address_book/NodeAddressBook.js";
import * as HieroProto from "@hashgraph/proto";
import FileId from "../file/FileId.js";
import { RST_STREAM } from "../Executable.js";
import CACHE from "../Cache.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../channel/MirrorChannel.js").MirrorError} MirrorError
 */

/**
 * @template {Channel} ChannelT
 * @typedef {import("../client/Client.js").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>
 */

/**
 * Query to get a list of Hedera network node addresses from a mirror node.
 *
 * This query can be used to retrieve node addresses either from a specific file ID
 * or from the most recent address book if no file ID is specified. The response
 * contains node metadata including IP addresses and ports for both node and mirror
 * node services.
 * @augments {Query<NodeAddressBook>}
 */
export default class AddressBookQuery extends Query {
    /**
     * @param {object} props
     * @param {FileId | string} [props.fileId]
     * @param {number} [props.limit]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;
        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        /**
         * @private
         * @type {?number}
         */
        this._limit = null;
        if (props.limit != null) {
            this.setLimit(props.limit);
        }

        /**
         * @private
         * @type {(error: MirrorError | Error | null) => boolean}
         */
        this._retryHandler = (error) => {
            if (error != null) {
                if (error instanceof Error) {
                    // Retry on all errors which are not `MirrorError` because they're
                    // likely lower level HTTP/2 errors
                    return true;
                } else {
                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`
                    // if the message matches the right regex.
                    switch (error.code) {
                        // INTERNAL
                        // eslint-disable-next-line no-fallthrough
                        case 13:
                            return RST_STREAM.test(error.details.toString());
                        // NOT_FOUND
                        // eslint-disable-next-line no-fallthrough
                        case 5:
                        // RESOURCE_EXHAUSTED
                        // eslint-disable-next-line no-fallthrough
                        case 8:
                        // UNAVAILABLE
                        // eslint-disable-next-line no-fallthrough
                        case 14:
                        case 17:
                            return true;
                        default:
                            return false;
                    }
                }
            }

            return false;
        };

        /** @type {NodeAddress[]} */
        this._addresses = [];

        /**
         * @private
         * @type {number}
         */
        this._attempt = 0;
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId | string} fileId
     * @returns {AddressBookQuery}
     */
    setFileId(fileId) {
        this._fileId =
            typeof fileId === "string"
                ? FileId.fromString(fileId)
                : fileId.clone();

        return this;
    }

    /**
     * @returns {?number}
     */
    get limit() {
        return this._limit;
    }

    /**
     * @param {number} limit
     * @returns {AddressBookQuery}
     */
    setLimit(limit) {
        this._limit = limit;

        return this;
    }

    /**
     * @param {number} attempts
     * @returns {this}
     */
    setMaxAttempts(attempts) {
        this._maxAttempts = attempts;
        return this;
    }

    /**
     * @param {number} backoff
     * @returns {this}
     */
    setMaxBackoff(backoff) {
        this._maxBackoff = backoff;
        return this;
    }

    /**
     * @param {Client<Channel>} client
     * @param {number=} requestTimeout
     * @returns {Promise<NodeAddressBook>}
     */
    execute(client, requestTimeout) {
        // Extra validation when initializing the client with only a mirror network
        if (client._network._network.size === 0 && !client._timer) {
            throw new Error(
                "The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.",
            );
        }

        return new Promise((resolve, reject) => {
            this._makeServerStreamRequest(
                client,
                /** @type {(value: NodeAddressBook) => void} */ (resolve),
                reject,
                requestTimeout,
            );
        });
    }

    /**
     * @private
     * @param {Client<Channel>} client
     * @param {(value: NodeAddressBook) => void} resolve
     * @param {(error: Error) => void} reject
     * @param {number=} requestTimeout
     */
    _makeServerStreamRequest(client, resolve, reject, requestTimeout) {
        const request =
            HieroProto.com.hedera.mirror.api.proto.AddressBookQuery.encode({
                fileId:
                    this._fileId != null ? this._fileId._toProtobuf() : null,
                limit: this._limit,
            }).finish();

        client._mirrorNetwork
            .getNextMirrorNode()
            .getChannel()
            .makeServerStreamRequest(
                "NetworkService",
                "getNodes",
                request,
                (data) => {
                    this._addresses.push(
                        NodeAddress._fromProtobuf(
                            HieroProto.proto.NodeAddress.decode(data),
                        ),
                    );

                    if (this._limit != null && this._limit > 0) {
                        this._limit = this._limit - 1;
                    }
                },
                (error) => {
                    const message =
                        error instanceof Error ? error.message : error.details;
                    if (
                        this._attempt < this._maxAttempts &&
                        !client.isClientShutDown &&
                        this._retryHandler(error)
                    ) {
                        const delay = Math.min(
                            250 * 2 ** this._attempt,
                            this._maxBackoff,
                        );
                        if (this._attempt >= this._maxAttempts) {
                            console.warn(
                                `Error getting nodes from mirror for file ${
                                    this._fileId != null
                                        ? this._fileId.toString()
                                        : "UNKNOWN"
                                } during attempt ${
                                    this._attempt
                                }. Waiting ${delay} ms before next attempt: ${message}`,
                            );
                        }
                        if (this._logger) {
                            this._logger.debug(
                                `Error getting nodes from mirror for file ${
                                    this._fileId != null
                                        ? this._fileId.toString()
                                        : "UNKNOWN"
                                } during attempt ${
                                    this._attempt
                                }. Waiting ${delay} ms before next attempt: ${message}`,
                            );
                        }

                        this._attempt += 1;

                        setTimeout(() => {
                            this._makeServerStreamRequest(
                                client,
                                resolve,
                                reject,
                                requestTimeout,
                            );
                        }, delay);
                    } else {
                        reject(new Error("failed to query address book"));
                    }
                },
                () => {
                    resolve(
                        new NodeAddressBook({ nodeAddresses: this._addresses }),
                    );
                },
            );
    }
}

CACHE.setAddressBookQueryConstructor(() => new AddressBookQuery());
// Filename: src/network/NetworkVersionInfo.js
// SPDX-License-Identifier: Apache-2.0

import SemanticVersion from "./SemanticVersion.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * Response when the client sends the node CryptoGetVersionInfoQuery.
 */
export default class NetworkVersionInfo {
    /**
     * @private
     * @param {object} props
     * @param {SemanticVersion} props.protobufVersion
     * @param {SemanticVersion} props.servicesVersion
     */
    constructor(props) {
        /**
         * The account ID for which this information applies.
         *
         * @readonly
         */
        this.protobufVersion = props.protobufVersion;

        /**
         * The account ID for which this information applies.
         *
         * @readonly
         */
        this.servicesVersion = props.servicesVersion;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.INetworkGetVersionInfoResponse} info
     * @returns {NetworkVersionInfo}
     */
    static _fromProtobuf(info) {
        return new NetworkVersionInfo({
            protobufVersion: SemanticVersion._fromProtobuf(
                /** @type {HieroProto.proto.ISemanticVersion} */
                (info.hapiProtoVersion),
            ),
            servicesVersion: SemanticVersion._fromProtobuf(
                /** @type {HieroProto.proto.ISemanticVersion} */
                (info.hederaServicesVersion),
            ),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.INetworkGetVersionInfoResponse}
     */
    _toProtobuf() {
        return {
            hapiProtoVersion: this.protobufVersion._toProtobuf(),
            hederaServicesVersion: this.servicesVersion._toProtobuf(),
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {NetworkVersionInfo}
     */
    static fromBytes(bytes) {
        return NetworkVersionInfo._fromProtobuf(
            HieroProto.proto.NetworkGetVersionInfoResponse.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.NetworkGetVersionInfoResponse.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/network/NetworkVersionInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import NetworkVersionInfo from "./NetworkVersionInfo.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.INetworkGetVersionInfoQuery} HieroProto.proto.INetworkGetVersionInfoQuery
 * @typedef {import("@hashgraph/proto").proto.INetworkGetVersionInfoResponse} HieroProto.proto.INetworkGetVersionInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 *
 * A query to retrieve version information about the Hedera network.
 *
 * This query returns information about the versions of both the Hedera Services software
 * and the protobuf schema in use by the network. This information is useful for ensuring
 * client-network compatibility and debugging version-related issues.
 *
 * @augments {Query<NetworkVersionInfo>}
 */
export default class NetworkVersionInfoQuery extends Query {
    constructor() {
        super();
    }

    /**
     * @param {HieroProto.proto.IQuery} query
     * @returns {NetworkVersionInfoQuery}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(query) {
        return new NetworkVersionInfoQuery();
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.network.getVersionInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const networkGetVersionInfo =
            /** @type {HieroProto.proto.INetworkGetVersionInfoResponse} */ (
                response.networkGetVersionInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            networkGetVersionInfo.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @returns {Promise<NetworkVersionInfo>}
     */
    _mapResponse(response) {
        const info =
            /** @type {HieroProto.proto.INetworkGetVersionInfoResponse} */ (
                response.networkGetVersionInfo
            );
        return Promise.resolve(NetworkVersionInfo._fromProtobuf(info));
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            networkGetVersionInfo: {
                header,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `NetworkVersionInfoQuery:${timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "networkGetVersionInfo",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    NetworkVersionInfoQuery._fromProtobuf,
);
// Filename: src/network/SemanticVersion.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
/**
 * Represents a semantic versioning structure for software components.
 *
 * This class encapsulates the major, minor, and patch version numbers, following
 * the Semantic Versioning (SemVer) specification. It provides methods for creating,
 * comparing, and manipulating version numbers, ensuring that versioning adheres to
 * the SemVer rules.
 */
export default class SemanticVersion {
    /**
     * @private
     * @param {object} props
     * @param {number} props.major
     * @param {number} props.minor
     * @param {number} props.patch
     */
    constructor(props) {
        /** @readonly */
        this.major = props.major;
        /** @readonly */
        this.minor = props.minor;
        /** @readonly */
        this.patch = props.patch;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ISemanticVersion} version
     * @returns {SemanticVersion}
     */
    static _fromProtobuf(version) {
        return new SemanticVersion({
            major: /** @type {number} */ (version.major),
            minor: /** @type {number} */ (version.minor),
            patch: /** @type {number} */ (version.patch),
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ISemanticVersion}
     */
    _toProtobuf() {
        return {
            major: this.major,
            minor: this.minor,
            patch: this.patch,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {SemanticVersion}
     */
    static fromBytes(bytes) {
        return SemanticVersion._fromProtobuf(
            HieroProto.proto.SemanticVersion.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.SemanticVersion.encode(
            this._toProtobuf(),
        ).finish();
    }
}
// Filename: src/node/NodeCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import Key from "../Key.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import ServiceEndpoint from "./ServiceEndpoint.js";

const DESCRIPTION_MAX_LENGTH = 100;
const GOSSIP_ENDPOINTS_MAX_LENGTH = 10;
const SERVICE_ENDPOINTS_MAX_LENGTH = 8;

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} ITransaction
 * @typedef {import("@hashgraph/proto").proto.ITransaction} ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} ITransactionResponse
 */

/**
 * @namespace com.hedera.hapi.node.addressbook
 * @typedef {import("@hashgraph/proto").com.hedera.hapi.node.addressbook.INodeCreateTransactionBody} INodeCreateTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * A transaction to create a new consensus node in the network.
 */
export default class NodeCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {AccountId} [props.accountId]
     * @param {?string} [props.description]
     * @param {Array<ServiceEndpoint>} [props.gossipEndpoints]
     * @param {?Array<ServiceEndpoint>} [props.serviceEndpoints]
     * @param {Uint8Array} [props.gossipCaCertificate]
     * @param {Uint8Array} [props.grpcCertificateHash]
     * @param {Key} [props.adminKey]
     */
    constructor(props) {
        super();

        /**
         * @private
         * @type {?AccountId}
         * @description Node account identifier. It's required.
         */
        this._accountId = props?.accountId != null ? props.accountId : null;

        /**
         * @private
         * @type {?string}
         * @description Short description of the node.
         */
        this._description =
            props?.description != null ? props.description : null;

        /**
         * @private
         * @type {?Array<ServiceEndpoint>}
         * @description List of service endpoints for gossip. It's required.
         */
        this._gossipEndpoints =
            props?.gossipEndpoints != null ? props.gossipEndpoints : null;

        /**
         * @private
         * @type {?Array<ServiceEndpoint>}
         * @description List of service endpoints for gRPC calls.
         */
        this._serviceEndpoints =
            props?.serviceEndpoints != null ? props.serviceEndpoints : null;

        /**
         * @private
         * @type {?Uint8Array}
         * @description Certificate used to sign gossip events. It's required.
         */
        this._gossipCaCertificate =
            props?.gossipCaCertificate != null
                ? props.gossipCaCertificate
                : null;

        /**
         * @private
         * @type {?Uint8Array}
         * @description Hash of the node gRPC TLS certificate.
         */
        this._grpcCertificateHash =
            props?.grpcCertificateHash != null
                ? props.grpcCertificateHash
                : null;

        /**
         * @private
         * @type {?Key}
         * @description Administrative key controlled by the node operator. It's required.
         */
        this._adminKey = props?.adminKey != null ? props.adminKey : null;
    }

    /**
     * @internal
     * @param {ITransaction[]} transactions
     * @param {ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {ITransactionBody[]} bodies
     * @returns {NodeCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const nodeCreate = /** @type {INodeCreateTransactionBody} */ (
            body.nodeCreate
        );

        return Transaction._fromProtobufTransactions(
            new NodeCreateTransaction({
                accountId:
                    nodeCreate.accountId != null
                        ? AccountId._fromProtobuf(nodeCreate.accountId)
                        : undefined,
                description:
                    nodeCreate.description != null
                        ? nodeCreate.description
                        : undefined,
                gossipEndpoints:
                    nodeCreate.gossipEndpoint != null
                        ? nodeCreate.gossipEndpoint.map((endpoint) =>
                              ServiceEndpoint._fromProtobuf(endpoint),
                          )
                        : undefined,
                serviceEndpoints:
                    nodeCreate.serviceEndpoint != null
                        ? nodeCreate.serviceEndpoint.map((endpoint) =>
                              ServiceEndpoint._fromProtobuf(endpoint),
                          )
                        : undefined,
                gossipCaCertificate:
                    nodeCreate.gossipCaCertificate != null
                        ? nodeCreate.gossipCaCertificate
                        : undefined,
                grpcCertificateHash:
                    nodeCreate.grpcCertificateHash != null
                        ? nodeCreate.grpcCertificateHash
                        : undefined,
                adminKey:
                    nodeCreate.adminKey != null
                        ? Key._fromProtobufKey(nodeCreate.adminKey)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @param {AccountId | string} accountId
     * @description Set node account identifier.
     * @returns {NodeCreateTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);

        return this;
    }

    /**
     * @description Get node account identifier.
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {string} description
     * @description Set description of the node.
     * @returns {NodeCreateTransaction}
     */
    setDescription(description) {
        this._requireNotFrozen();
        if (description.length > DESCRIPTION_MAX_LENGTH) {
            throw new Error(
                `Description must be at most ${DESCRIPTION_MAX_LENGTH} characters.`,
            );
        }
        this._description = description;

        return this;
    }

    /**
     * @description Get description of the node.
     * @returns {?string}
     */
    get description() {
        return this._description;
    }

    /**
     * @param {ServiceEndpoint[]} gossipEndpoints
     * @description Set list of service endpoints for gossip.
     * @returns {NodeCreateTransaction}
     */
    setGossipEndpoints(gossipEndpoints) {
        this._requireNotFrozen();
        if (gossipEndpoints.length == 0) {
            throw new Error("GossipEndpoints list must not be empty.");
        }

        if (gossipEndpoints.length > GOSSIP_ENDPOINTS_MAX_LENGTH) {
            throw new Error(
                `GossipEndpoints list must not contain more than ${GOSSIP_ENDPOINTS_MAX_LENGTH} entries.`,
            );
        }

        this._gossipEndpoints = [...gossipEndpoints];

        return this;
    }

    /**
     * @description Get list of service endpoints for gossip.
     * @returns {?Array<ServiceEndpoint>}
     */
    get gossipEndpoints() {
        return this._gossipEndpoints;
    }

    /**
     * @param {ServiceEndpoint} endpoint
     * @description Add an endpoint to the list of service endpoints for gossip.
     * @returns {NodeCreateTransaction}
     */
    addGossipEndpoint(endpoint) {
        if (this._gossipEndpoints != null) {
            this._gossipEndpoints.push(endpoint);
        }
        return this;
    }

    /**
     * @param {ServiceEndpoint[]} serviceEndpoints
     * @description Set list of service endpoints for gRPC calls.
     * @returns {NodeCreateTransaction}
     */
    setServiceEndpoints(serviceEndpoints) {
        this._requireNotFrozen();
        if (serviceEndpoints.length == 0) {
            throw new Error("ServiceEndpoints list must not be empty.");
        }

        if (serviceEndpoints.length > SERVICE_ENDPOINTS_MAX_LENGTH) {
            throw new Error(
                `ServiceEndpoints list must not contain more than ${SERVICE_ENDPOINTS_MAX_LENGTH} entries.`,
            );
        }

        this._serviceEndpoints = [...serviceEndpoints];

        return this;
    }

    /**
     * @description Get list of service endpoints for gRPC calls.
     * @returns {?Array<ServiceEndpoint>}
     */
    get serviceEndpoints() {
        return this._serviceEndpoints;
    }

    /**
     * @param {ServiceEndpoint} endpoint
     * @description Add an endpoint to the list of service endpoints for gRPC calls.
     * @returns {NodeCreateTransaction}
     */
    addServiceEndpoint(endpoint) {
        if (this._serviceEndpoints != null) {
            this._serviceEndpoints.push(endpoint);
        }
        return this;
    }

    /**
     * @param {Uint8Array} bytes
     * @description Set certificate used to sign gossip events.
     * @returns {NodeCreateTransaction}
     */
    setGossipCaCertificate(bytes) {
        this._requireNotFrozen();
        if (bytes.length == 0) {
            throw new Error("GossipCaCertificate must not be empty.");
        }

        this._gossipCaCertificate = bytes;

        return this;
    }

    /**
     * @description Get certificate used to sign gossip events.
     * @returns {?Uint8Array}
     */
    get gossipCaCertificate() {
        return this._gossipCaCertificate;
    }

    /**
     * @param {Uint8Array} bytes
     * @description Set hash of the node gRPC TLS certificate.
     * @returns {NodeCreateTransaction}
     */
    setCertificateHash(bytes) {
        this._requireNotFrozen();
        this._grpcCertificateHash = bytes;

        return this;
    }

    /**
     * @description Get hash of the node gRPC TLS certificate.
     * @returns {?Uint8Array}
     */
    get certificateHash() {
        return this._grpcCertificateHash;
    }

    /**
     * @param {Key} adminKey
     * @description Set administrative key controlled by the node operator.
     * @returns {NodeCreateTransaction}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @description Get administrative key controlled by the node operator.
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {ITransaction} request
     * @returns {Promise<ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.addressBook.createNode(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "nodeCreate";
    }

    /**
     * @override
     * @protected
     * @returns {INodeCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            accountId:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            description: this._description != null ? this._description : null,
            gossipEndpoint:
                this._gossipEndpoints != null
                    ? this._gossipEndpoints.map(
                          (/** @type {ServiceEndpoint} */ endpoint) =>
                              endpoint._toProtobuf(),
                      )
                    : null,
            serviceEndpoint:
                this._serviceEndpoints != null
                    ? this._serviceEndpoints.map(
                          (/** @type {ServiceEndpoint} */ endpoint) =>
                              endpoint._toProtobuf(),
                      )
                    : null,
            gossipCaCertificate:
                this._gossipCaCertificate != null
                    ? this._gossipCaCertificate
                    : null,
            grpcCertificateHash:
                this._grpcCertificateHash != null
                    ? this._grpcCertificateHash
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `NodeCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "nodeCreate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    NodeCreateTransaction._fromProtobuf,
);
// Filename: src/node/NodeDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} ITransaction
 * @typedef {import("@hashgraph/proto").proto.ITransaction} ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} ITransactionResponse
 */

/**
 * @namespace com.hedera.hapi.node.addressbook
 * @typedef {import("@hashgraph/proto").com.hedera.hapi.node.addressbook.INodeDeleteTransactionBody} INodeDeleteTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * A transaction to delete a consensus node in the network.
 */
export default class NodeDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Long} [props.nodeId]
     */
    constructor(props) {
        super();

        /**
         * @private
         * @type {?Long}
         * @description Consensus node identifier in the network state. It's required.
         */
        this._nodeId = props?.nodeId != null ? props.nodeId : null;
    }

    /**
     * @internal
     * @param {ITransaction[]} transactions
     * @param {ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {ITransactionBody[]} bodies
     * @returns {NodeDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const nodeDelete = /** @type {INodeDeleteTransactionBody} */ (
            body.nodeDelete
        );

        return Transaction._fromProtobufTransactions(
            new NodeDeleteTransaction({
                nodeId:
                    nodeDelete.nodeId != null ? nodeDelete.nodeId : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @param {Long} nodeId
     * @description Set consensus node identifier.
     * @returns {NodeDeleteTransaction}
     */
    setNodeId(nodeId) {
        this._nodeId = nodeId;

        return this;
    }

    /**
     * @description Get consensus node identifier.
     * @returns {?Long}
     */
    get nodeId() {
        return this._nodeId;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {ITransaction} request
     * @returns {Promise<ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.addressBook.deleteNode(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "nodeDelete";
    }

    /**
     * @override
     * @protected
     * @returns {INodeDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            nodeId: this._nodeId != null ? this._nodeId : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `NodeDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "nodeDelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    NodeDeleteTransaction._fromProtobuf,
);
// Filename: src/node/NodeUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import Key from "../Key.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import ServiceEndpoint from "./ServiceEndpoint.js";

const DESCRIPTION_MAX_LENGTH = 100;
const GOSSIP_ENDPOINTS_MAX_LENGTH = 10;
const SERVICE_ENDPOINTS_MAX_LENGTH = 8;

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} ITransaction
 * @typedef {import("@hashgraph/proto").proto.ITransaction} ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} ITransactionResponse
 */

/**
 * @namespace com.hedera.hapi.node.addressbook
 * @typedef {import("@hashgraph/proto").com.hedera.hapi.node.addressbook.INodeUpdateTransactionBody} INodeUpdateTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * @description A transaction to update a consensus node in the network.
 */
export default class NodeUpdateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Long} [props.nodeId]
     * @param {AccountId} [props.accountId]
     * @param {?string} [props.description]
     * @param {Array<ServiceEndpoint>} [props.gossipEndpoints]
     * @param {?Array<ServiceEndpoint>} [props.serviceEndpoints]
     * @param {?Uint8Array} [props.gossipCaCertificate]
     * @param {?Uint8Array} [props.grpcCertificateHash]
     * @param {Key} [props.adminKey]
     */
    constructor(props) {
        super();

        /**
         * @private
         * @type {?Long}
         * @description A consensus node identifier in the network state. It's required.
         */
        this._nodeId = props?.nodeId != null ? props.nodeId : null;

        /**
         * @private
         * @type {?AccountId}
         * @description Desired new account identifier of the node.
         */
        this._accountId = props?.accountId != null ? props.accountId : null;

        /**
         * @private
         * @type {?string}
         * @description Short description of the node. If set, this value SHALL replace the previous value.
         */
        this._description =
            props?.description != null ? props.description : null;

        /**
         * @private
         * @type {?Array<ServiceEndpoint>}
         * @description List of service endpoints for gossip.
         */
        this._gossipEndpoints =
            props?.gossipEndpoints != null ? props.gossipEndpoints : null;

        /**
         * @private
         * @type {?Array<ServiceEndpoint>}
         * @description List of service endpoints for gRPC calls.
         */
        this._serviceEndpoints =
            props?.serviceEndpoints != null ? props.serviceEndpoints : null;

        /**
         * @private
         * @type {?Uint8Array}
         * @description Certificate used to sign gossip events.
         */
        this._gossipCaCertificate =
            props?.gossipCaCertificate != null
                ? props.gossipCaCertificate
                : null;

        /**
         * @private
         * @type {?Uint8Array}
         * @description Hash of the node gRPC TLS certificate.
         */
        this._grpcCertificateHash =
            props?.grpcCertificateHash != null
                ? props.grpcCertificateHash
                : null;

        /**
         * @private
         * @type {?Key}
         * @description Administrative key controlled by the node operator.
         */
        this._adminKey = props?.adminKey != null ? props.adminKey : null;
    }

    /**
     * @internal
     * @param {ITransaction[]} transactions
     * @param {ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {ITransactionBody[]} bodies
     * @returns {NodeUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const nodeUpdate = /** @type {INodeUpdateTransactionBody} */ (
            body.nodeUpdate
        );

        return Transaction._fromProtobufTransactions(
            new NodeUpdateTransaction({
                nodeId:
                    nodeUpdate.nodeId != null ? nodeUpdate.nodeId : undefined,
                accountId:
                    nodeUpdate.accountId != null
                        ? AccountId._fromProtobuf(nodeUpdate.accountId)
                        : undefined,
                description:
                    nodeUpdate.description != null
                        ? Object.hasOwn(nodeUpdate.description, "value")
                            ? nodeUpdate.description.value
                            : undefined
                        : undefined,
                gossipEndpoints:
                    nodeUpdate.gossipEndpoint != null
                        ? nodeUpdate.gossipEndpoint.map((endpoint) =>
                              ServiceEndpoint._fromProtobuf(endpoint),
                          )
                        : undefined,
                serviceEndpoints:
                    nodeUpdate.serviceEndpoint != null
                        ? nodeUpdate.serviceEndpoint.map((endpoint) =>
                              ServiceEndpoint._fromProtobuf(endpoint),
                          )
                        : undefined,
                gossipCaCertificate:
                    nodeUpdate.gossipCaCertificate != null
                        ? Object.hasOwn(nodeUpdate.gossipCaCertificate, "value")
                            ? nodeUpdate.gossipCaCertificate.value
                            : undefined
                        : undefined,
                grpcCertificateHash:
                    nodeUpdate.grpcCertificateHash != null
                        ? Object.hasOwn(nodeUpdate.grpcCertificateHash, "value")
                            ? nodeUpdate.grpcCertificateHash.value
                            : undefined
                        : undefined,
                adminKey:
                    nodeUpdate.adminKey != null
                        ? Key._fromProtobufKey(nodeUpdate.adminKey)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @param {Long} nodeId
     * @description Set consensus node identifier in the network state.
     * @returns {NodeUpdateTransaction}
     */
    setNodeId(nodeId) {
        this._requireNotFrozen();
        this._nodeId = nodeId;

        return this;
    }

    /**
     * @description Get consensus node identifier in the network state.
     * @returns {?Long}
     */
    get nodeId() {
        return this._nodeId;
    }

    /**
     * @param {AccountId | string} accountId
     * @description Set desired new account identifier of the node.
     * @returns {NodeUpdateTransaction}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);

        return this;
    }

    /**
     * @description Get desired new account identifier of the node.
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {string} description
     * @description Set description of the node.
     * @returns {NodeUpdateTransaction}
     */
    setDescription(description) {
        this._requireNotFrozen();
        if (description.length > DESCRIPTION_MAX_LENGTH) {
            throw new Error(
                `Description must be at most ${DESCRIPTION_MAX_LENGTH} characters.`,
            );
        }
        this._description = description;

        return this;
    }

    /**
     * @description Clear description of the node.
     * @returns {void}
     */
    clearDescription() {
        this._description = "";
    }

    /**
     * @description Get description of the node.
     * @returns {?string}
     */
    get description() {
        return this._description;
    }

    /**
     * @param {ServiceEndpoint[]} gossipEndpoints
     * @description Set list of service endpoints for gossip.
     * @returns {NodeUpdateTransaction}
     */
    setGossipEndpoints(gossipEndpoints) {
        this._requireNotFrozen();
        if (gossipEndpoints.length == 0) {
            throw new Error("GossipEndpoints list must not be empty.");
        }

        if (gossipEndpoints.length > GOSSIP_ENDPOINTS_MAX_LENGTH) {
            throw new Error(
                `GossipEndpoints list must not contain more than ${GOSSIP_ENDPOINTS_MAX_LENGTH} entries.`,
            );
        }

        this._gossipEndpoints = [...gossipEndpoints];

        return this;
    }

    /**
     * @description Get list of service endpoints for gossip.
     * @returns {?Array<ServiceEndpoint>}
     */
    get gossipEndpoints() {
        return this._gossipEndpoints;
    }

    /**
     * @param {ServiceEndpoint} endpoint
     * @description Add an endpoint to the list of service endpoints for gossip.
     * @returns {NodeUpdateTransaction}
     */
    addGossipEndpoint(endpoint) {
        this._requireNotFrozen();
        if (this._gossipEndpoints != null) {
            this._gossipEndpoints.push(endpoint);
        }
        return this;
    }

    /**
     * @param {ServiceEndpoint[]} serviceEndpoints
     * @description Set list of service endpoints for gRPC calls.
     * @returns {NodeUpdateTransaction}
     */
    setServiceEndpoints(serviceEndpoints) {
        this._requireNotFrozen();
        if (serviceEndpoints.length == 0) {
            throw new Error("ServiceEndpoints list must not be empty.");
        }

        if (serviceEndpoints.length > SERVICE_ENDPOINTS_MAX_LENGTH) {
            throw new Error(
                `ServiceEndpoints list must not contain more than ${SERVICE_ENDPOINTS_MAX_LENGTH} entries.`,
            );
        }

        this._serviceEndpoints = [...serviceEndpoints];

        return this;
    }

    /**
     * @description Get list of service endpoints for gRPC calls.
     * @returns {?Array<ServiceEndpoint>}
     */
    get serviceEndpoints() {
        return this._serviceEndpoints;
    }

    /**
     * @param {ServiceEndpoint} endpoint
     * @description Add an endpoint to the list of service endpoints for gRPC calls.
     * @returns {NodeUpdateTransaction}
     */
    addServiceEndpoint(endpoint) {
        this._requireNotFrozen();
        if (this._serviceEndpoints != null) {
            this._serviceEndpoints.push(endpoint);
        }
        return this;
    }

    /**
     * @param {Uint8Array} bytes
     * @description Set certificate used to sign gossip events.
     * @returns {NodeUpdateTransaction}
     */
    setGossipCaCertificate(bytes) {
        this._requireNotFrozen();
        if (bytes.length == 0) {
            throw new Error("GossipCaCertificate must not be empty.");
        }

        this._gossipCaCertificate = bytes;

        return this;
    }

    /**
     * @description Get certificate used to sign gossip events.
     * @returns {?Uint8Array}
     */
    get gossipCaCertificate() {
        return this._gossipCaCertificate;
    }

    /**
     * @param {Uint8Array} bytes
     * @description Set hash of the node gRPC TLS certificate.
     * @returns {NodeUpdateTransaction}
     */
    setCertificateHash(bytes) {
        this._requireNotFrozen();
        this._grpcCertificateHash = bytes;

        return this;
    }

    /**
     * @description Get hash of the node gRPC TLS certificate.
     * @returns {?Uint8Array}
     */
    get certificateHash() {
        return this._grpcCertificateHash;
    }

    /**
     * @param {Key} adminKey
     * @description Set administrative key controlled by the node operator.
     * @returns {NodeUpdateTransaction}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @description Get administrative key controlled by the node operator.
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {ITransaction} request
     * @returns {Promise<ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.addressBook.updateNode(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "nodeUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {INodeUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            accountId:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            description: {
                value: this._description != null ? this._description : null,
            },
            gossipEndpoint:
                this._gossipEndpoints != null
                    ? this._gossipEndpoints.map(
                          (/** @type {ServiceEndpoint} */ endpoint) =>
                              endpoint._toProtobuf(),
                      )
                    : null,
            serviceEndpoint:
                this._serviceEndpoints != null
                    ? this._serviceEndpoints.map(
                          (/** @type {ServiceEndpoint} */ endpoint) =>
                              endpoint._toProtobuf(),
                      )
                    : null,
            gossipCaCertificate:
                this._gossipCaCertificate != null
                    ? {
                          value: this._gossipCaCertificate,
                      }
                    : null,
            grpcCertificateHash:
                this._grpcCertificateHash != null
                    ? {
                          value: this._grpcCertificateHash,
                      }
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            nodeId: this._nodeId != null ? this._nodeId : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `NodeUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "nodeUpdate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    NodeUpdateTransaction._fromProtobuf,
);
// Filename: src/node/ServiceEndpoint.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IServiceEndpoint} IServiceEndpoint
 */

export default class ServiceEndpoint {
    /**
     * @param {object} [props]
     * @param {?Uint8Array} [props.ipAddressV4]
     * @param {?number} [props.port]
     * @param {?string} [props.domainName]
     */
    constructor(props) {
        /**
         * @type {?Uint8Array}
         * @description The 4-byte IPv4 address of the endpoint
         * encoded in left to right order
         * (e.g. 127.0.0.1 has bytes [127, 0, 0, 1]).
         */
        this._ipAddressV4 =
            props?.ipAddressV4 != null ? props.ipAddressV4 : null;

        /**
         * @type {?number}
         * @description The port of the service endpoint. It's required.
         */
        this._port = props?.port != null ? props.port : null;

        /**
         * @type {?string}
         * @description A node domain name. This MUST be the
         * fully qualified domain(DNS) name of the node. This
         * value MUST NOT be more than 253 characters.
         * domain_name and ipAddressV4 are mutually exclusive.
         * When the `domain_name` field is set, the `ipAddressV4`
         * field MUST NOT be set. When the `ipAddressV4` field
         * is set, the `domain_name` field MUST NOT be set.
         */
        this._domainName = props?.domainName != null ? props.domainName : null;
    }

    /**
     * @param {Uint8Array} ipAddressV4
     * @description Set 4-byte IPv4 address of the endpoint.
     * @returns {ServiceEndpoint}
     *
     */
    setIpAddressV4(ipAddressV4) {
        if (this._domainName != null) {
            throw new Error(
                "Cannot set IP address when domain name is already set.",
            );
        }
        this._ipAddressV4 = ipAddressV4;
        return this;
    }

    /**
     * @description Get 4-byte IPv4 address of the endpoint.
     * @returns {?Uint8Array}
     *
     */
    get getIpAddressV4() {
        return this._ipAddressV4;
    }

    /**
     * @param {number} port
     * @description Set port of the endpoint.
     * @returns {ServiceEndpoint}
     *
     */
    setPort(port) {
        this._port = port;
        return this;
    }

    /**
     * @description Get port of the endpoint.
     * @returns {?number}
     *
     */
    get getPort() {
        return this._port;
    }

    /**
     * @param {string} domainName
     * @description Set domain name of the endpoint.
     * @returns {ServiceEndpoint}
     *
     */
    setDomainName(domainName) {
        if (this._ipAddressV4 != null) {
            throw new Error(
                "Cannot set domain name when IP address is already set.",
            );
        }
        this._domainName = domainName;
        return this;
    }

    /**
     * @description Get domain name of the endpoint.
     * @returns {?string}
     *
     */
    get getDomainName() {
        return this._domainName;
    }

    /**
     * @internal
     * @param {IServiceEndpoint} serviceEndpoint
     * @returns {ServiceEndpoint}
     */
    static _fromProtobuf(serviceEndpoint) {
        return new ServiceEndpoint({
            ipAddressV4:
                serviceEndpoint.ipAddressV4 != null
                    ? serviceEndpoint.ipAddressV4
                    : undefined,
            port:
                serviceEndpoint.port != null ? serviceEndpoint.port : undefined,
            domainName:
                serviceEndpoint.domainName != null
                    ? serviceEndpoint.domainName
                    : undefined,
        });
    }

    /**
     * @internal
     * @returns {IServiceEndpoint}
     */
    _toProtobuf() {
        return {
            ipAddressV4: this._ipAddressV4,
            port: this._port,
            domainName: this._domainName,
        };
    }
}
// Filename: src/query/CostQuery.js
// SPDX-License-Identifier: Apache-2.0

import TransactionId from "../transaction/TransactionId.js";
import Hbar from "../Hbar.js";
import Executable from "../Executable.js";
import AccountId from "../account/AccountId.js";
import { _makePaymentTransaction, COST_QUERY } from "./Query.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../Status.js").default} Status
 * @typedef {import("../Executable.js").ExecutionState} ExecutionState
 */

/**
 * @template OutputT
 * @augments {Executable<HieroProto.proto.IQuery, HieroProto.proto.IResponse, Hbar>}
 */
export default class CostQuery extends Executable {
    /**
     * @param {import("./Query.js").default<OutputT>} query
     */
    constructor(query) {
        super();

        this._query = query;
        this._grpcDeadline = query._grpcDeadline;
        this._requestTimeout = query._requestTimeout;
        this._nodeAccountIds = query._nodeAccountIds.clone();
        this._operator = query._operator;

        /**
         * @type {HieroProto.proto.IQueryHeader | null}
         */
        this._header = null;
    }

    /**
     * @returns {TransactionId}
     */
    _getTransactionId() {
        return this._query._getTransactionId();
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        return `CostQuery:${this._query._getLogId()}`;
    }

    /**
     * @abstract
     * @protected
     * @param {import("../client/Client.js").default<*, *>} client
     * @returns {Promise<void>}
     */
    async _beforeExecute(client) {
        if (client == null) {
            throw new Error("Cannot do CostQuery without Client");
        }

        const operator =
            this._operator != null ? this._operator : client._operator;

        if (operator == null) {
            throw new Error(
                "`client` must have an `operator` or an explicit payment transaction must be provided",
            );
        }

        if (this._query._nodeAccountIds.isEmpty) {
            this._query._nodeAccountIds.setList(
                client._network.getNodeAccountIdsForExecute(),
            );
        }

        // operator.accountId
        const transactionId = TransactionId.generate(operator.accountId);
        if (this._query.paymentTransactionId == null) {
            this._query.setPaymentTransactionId(transactionId);
        }

        const logId = this._getLogId();
        const nodeId = new AccountId(0);
        const paymentTransactionId =
            /** @type {import("../transaction/TransactionId.js").default} */
            (TransactionId.generate(new AccountId(0)));
        const paymentAmount = new Hbar(0);
        if (this._logger) {
            this._logger.debug(
                `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,
            );
        }

        this._header = {
            payment: await _makePaymentTransaction(
                paymentTransactionId,
                new AccountId(0),
                operator,
                paymentAmount,
            ),
            responseType: HieroProto.proto.ResponseType.COST_ANSWER,
        };
    }

    /**
     * @abstract
     * @internal
     * @returns {Promise<HieroProto.proto.IQuery>}
     */
    _makeRequestAsync() {
        return Promise.resolve(
            this._query._onMakeRequest(
                /** @type {HieroProto.proto.IQueryHeader} */ (this._header),
            ),
        );
    }

    /**
     * @abstract
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @returns {[Status, ExecutionState]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        return this._query._shouldRetry(request, response);
    }

    /**
     * @abstract
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response, nodeId) {
        return this._query._mapStatusError(request, response, nodeId);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<Hbar>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const cost = this._query._mapResponseHeader(response).cost;
        return Promise.resolve(
            Hbar.fromTinybars(/** @type {Long | number} */ (cost)),
        );
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return this._query._execute(channel, request);
    }

    /**
     * @param {HieroProto.proto.Query} request
     * @returns {Uint8Array}
     */
    _requestToBytes(request) {
        return this._query._requestToBytes(request);
    }

    /**
     * @param {HieroProto.proto.Response} response
     * @returns {Uint8Array}
     */
    _responseToBytes(response) {
        return this._query._responseToBytes(response);
    }
}

COST_QUERY.push((query) => new CostQuery(query));
// Filename: src/query/MirrorNodeContractCallQuery.js
import MirrorNodeContractQuery from "./MirrorNodeContractQuery.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 A query that simulates a contract function call using the Hedera Mirror Node.
 * 
 * This query allows you to execute a read-only smart contract call without submitting a transaction
 * to the main network. It's useful for querying contract state or executing view/pure functions.
 * The simulation is performed against the state of the contract at a specific block height.
 */
export default class MirrorNodeContractCallQuery extends MirrorNodeContractQuery {
    /**
     * @returns {object}
     */
    get JSONPayload() {
        if (this.callData == null) {
            throw new Error("Call data is required.");
        }

        return {
            data: Buffer.from(this.callData).toString("hex"),
            from: this.senderEvmAddress,
            to: this.contractEvmAddress,
            estimate: false,
            gasPrice: this.gasPrice?.toString(),
            gas: this.gasLimit?.toString(),
            blockNumber: this.blockNumber?.toString(),
            value: this.value?.toString(),
        };
    }

    /**
     * @param {Client} client
     * @returns {Promise<string>}
     */
    async execute(client) {
        const mirrorNodeRequest = await this.performMirrorNodeRequest(
            client,
            this.JSONPayload,
        );

        return mirrorNodeRequest.result;
    }
}
// Filename: src/query/MirrorNodeContractEstimateQuery.js
import MirrorNodeContractQuery from "./MirrorNodeContractQuery.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * A query that estimates the gas required for a contract function call using the Hedera Mirror Node.
 *
 * This query simulates a contract call to estimate the amount of gas that would be required
 * to execute the same call on the main network. It's useful for determining the appropriate
 * gas limit before submitting an actual transaction.
 */
export default class MirrorNodeContractCallQuery extends MirrorNodeContractQuery {
    /**
     * @returns {object}
     */
    get JSONPayload() {
        if (this.callData == null) {
            throw new Error("Call data is required.");
        }

        return {
            data: Buffer.from(this.callData).toString("hex"),
            from: this.senderEvmAddress,
            to: this.contractEvmAddress,
            estimate: true,
            gasPrice: this.gasPrice?.toString(),
            gas: this.gasLimit?.toString(),
            blockNumber: this.blockNumber?.toString(),
            value: this.value?.toString(),
        };
    }

    /**
     * @param {Client} client
     * @returns {Promise<number>}
     */
    async execute(client) {
        const mirrorNodeRequest = await this.performMirrorNodeRequest(
            client,
            this.JSONPayload,
        );

        return Number(mirrorNodeRequest.result);
    }
}
// Filename: src/query/MirrorNodeContractQuery.js
import ContractFunctionParameters from "../contract/ContractFunctionParameters.js";

/**
 * @typedef {import("../contract/ContractId").default} ContractId
 * @typedef {import("../account/AccountId").default} AccountId
 * @typedef {import("../client/Client.js").default<*, *>} Client
 *
 */

/**
 * @typedef {object} MirrorNodeResponse
 * @property {string} result
 * @property {string} [error]
 * @property {string} [gasUsed]
 * @property {string} [contractAddress]
 * @property {string} [status]
 */

/**
 * MirrorNodeContractQuery returns a result from EVM execution such as cost-free execution of read-only smart contract
 * queries, gas estimation, and transient simulation of read-write operations.
 */
export default class MirrorNodeContractQuery {
    constructor() {
        this._contractId = null;
        this._contractEvmAddress = null;
        this._sender = null;
        this._senderEvmAddress = null;
        this._functionName = null;
        this._functionParameters = null;
        this._value = null;
        this._gasLimit = null;
        this._gasPrice = null;
        this._blockNumber = null;
    }

    /**
     *
     * @param {ContractId} contractId
     * @description Sets the contract instance to call.
     * @returns {this}
     */
    setContractId(contractId) {
        this._contractId = contractId;
        return this;
    }

    /**
     * @param {AccountId} sender
     * @description Sets the sender of the transaction simulation.
     * @returns {this}
     */
    setSender(sender) {
        this._sender = sender;
        return this;
    }

    /**
     *
     * @param {string} sender
     * @description Set the 20-byte EVM address of the sender.
     * @returns {this}
     */
    setSenderEvmAddress(sender) {
        this._senderEvmAddress = sender;
        return this;
    }

    /**
     *
     * @param {string} name
     * @param {ContractFunctionParameters} functionParameters
     * @description Sets the function to call, and the parameters to pass to the function
     * @returns {this}
     */
    setFunction(name, functionParameters) {
        this._functionParameters =
            functionParameters != null
                ? functionParameters._build(name)
                : new ContractFunctionParameters()._build(name);

        return this;
    }

    /**
     * @param {Long} value
     * @description Sets the amount of value (in tinybars or wei) to be sent to the contract in the transaction.
     * Use this to specify an amount for a payable function call.
     * @returns {this}
     */
    setValue(value) {
        this._value = value;
        return this;
    }

    /**
     * @param {Long} gasLimit
     * @description Sets the gas limit for the contract call.
     * This specifies the maximum amount of gas that the transaction can consume.
     * @returns {this}
     */
    setGasLimit(gasLimit) {
        this._gasLimit = gasLimit;
        return this;
    }

    /**
     * @param {Long} gasPrice
     * @description Sets the gas price to be used for the contract call. This specifies the price of each unit of gas used in the transaction.
     * @returns {this}
     */
    setGasPrice(gasPrice) {
        this._gasPrice = gasPrice;
        return this;
    }

    /**
     * @param {Long} blockNumber
     * @description  Sets the block number for the simulation of the contract call.
     * The block number determines the context of the contract call simulation within the blockchain.
     * @returns {this}
     */
    setBlockNumber(blockNumber) {
        this._blockNumber = blockNumber;
        return this;
    }

    /**
     * @returns {ContractId?}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * @returns {string}
     */
    get contractEvmAddress() {
        const solidityAddress = this._contractId?.toSolidityAddress();
        if (solidityAddress == null) {
            throw new Error("Contract ID is not set");
        }
        return solidityAddress;
    }

    /**
     * @returns {AccountId?}
     */
    get sender() {
        return this._sender;
    }

    /**
     * @returns {string | null }
     */
    get senderEvmAddress() {
        if (this.sender) {
            return this.sender.toSolidityAddress();
        } else if (this._senderEvmAddress) {
            return this._senderEvmAddress;
        }

        return null;
    }

    /**
     * @returns {Uint8Array | null | undefined}
     */
    get callData() {
        return this._functionParameters;
    }

    /**
     * @returns {Long?}
     */
    get value() {
        return this._value;
    }

    /**
     * @returns {Long?}
     */
    get gasLimit() {
        return this._gasLimit;
    }

    /**
     * @returns {Long?}
     */
    get gasPrice() {
        return this._gasPrice;
    }

    /**
     * @returns {Long?}
     */
    get blockNumber() {
        return this._blockNumber;
    }

    /**
     *
     * @param {Client} client
     * @param {object} jsonPayload
     * @returns {Promise<MirrorNodeResponse>}
     */
    async performMirrorNodeRequest(client, jsonPayload) {
        if (this.contractId == null) {
            throw new Error("Contract ID is not set");
        }
        let mirrorNetworkAddress = client.mirrorNetwork[0];
        const contractCallEndpoint = "/api/v1/contracts/call";

        if (!client.ledgerId || client.ledgerId?.isLocalNode()) {
            mirrorNetworkAddress = "http://"
                .concat(client.mirrorNetwork[0].replace("5600", "8545"))
                .concat(contractCallEndpoint);
        } else {
            let trimmed = client.mirrorNetwork[0].split(":");
            mirrorNetworkAddress = "https://"
                .concat(trimmed[0])
                .concat(contractCallEndpoint);
        }

        // eslint-disable-next-line n/no-unsupported-features/node-builtins
        const response = await fetch(mirrorNetworkAddress, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(jsonPayload),
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const data = /** @type {MirrorNodeResponse} */ (await response.json());
        return data;
    }

    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * @returns {object}
     */
    get JSONPayload() {
        throw new Error(
            "JSONPayload getter is not implemented. Please implement this method in the subclass.",
        );
    }
}
// Filename: src/query/Query.js
// SPDX-License-Identifier: Apache-2.0

import Status from "../Status.js";
import AccountId from "../account/AccountId.js";
import Hbar from "../Hbar.js";
import Executable, { ExecutionState } from "../Executable.js";
import TransactionId from "../transaction/TransactionId.js";
import * as HieroProto from "@hashgraph/proto";
import PrecheckStatusError from "../PrecheckStatusError.js";
import MaxQueryPaymentExceeded from "../MaxQueryPaymentExceeded.js";
import Long from "long";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../client/Client.js").ClientOperator} ClientOperator
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../logger/Logger.js").default} Logger
 */

/**
 * This registry holds a bunch of callbacks for `fromProtobuf()` implementations
 * Since this is essentially aa cache, perhaps we should move this variable into the `Cache`
 * type for consistency?
 *
 * @type {Map<HieroProto.proto.Query["query"], (query: HieroProto.proto.IQuery) => Query<*>>}
 */
export const QUERY_REGISTRY = new Map();

/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @abstract
 * @template OutputT
 * @augments {Executable<HieroProto.proto.IQuery, HieroProto.proto.IResponse, OutputT>}
 */
export default class Query extends Executable {
    constructor() {
        super();

        /**
         * The payment transaction ID
         *
         * @type {?TransactionId}
         */
        this._paymentTransactionId = null;

        /**
         * The payment transactions list where each index points to a different node
         *
         * @type {HieroProto.proto.ITransaction[]}
         */
        this._paymentTransactions = [];

        /**
         * The amount being paid to the node for this query.
         * A user can set this field explicitly, or we'll query the value during execution.
         *
         * @type {?Hbar}
         */
        this._queryPayment = null;

        /**
         * The maximum query payment a user is willing to pay. Unlike `Transaction.maxTransactionFee`
         * this field only exists in the SDK; there is no protobuf field equivalent. If and when
         * we query the actual cost of the query and the cost is greater than the max query payment
         * we'll throw a `MaxQueryPaymentExceeded` error.
         *
         * @type {?Hbar}
         */
        this._maxQueryPayment = null;

        /**
         * This is strictly used for `_getLogId()` which requires a timestamp. The timestamp it typically
         * uses comes from the payment transaction ID, but that field is not set if this query is free.
         * For those occasions we use this timestamp field generated at query construction instead.
         *
         * @type {number}
         */
        this._timestamp = Date.now();
    }

    /**
     * Deserialize a query from bytes. The bytes should be a `proto.Query`.
     *
     * @template T
     * @param {Uint8Array} bytes
     * @returns {Query<T>}
     */
    static fromBytes(bytes) {
        const query = HieroProto.proto.Query.decode(bytes);

        if (query.query == null) {
            throw new Error("(BUG) query.query was not set in the protobuf");
        }

        const fromProtobuf =
            /** @type {(query: HieroProto.proto.IQuery) => Query<T>} */ (
                QUERY_REGISTRY.get(query.query)
            );

        if (fromProtobuf == null) {
            throw new Error(
                `(BUG) Query.fromBytes() not implemented for type ${query.query}`,
            );
        }

        return fromProtobuf(query);
    }

    /**
     * Serialize the query into bytes.
     *
     * **NOTE**: Does not preserve payment transactions
     *
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.Query.encode(this._makeRequest()).finish();
    }

    /**
     * Set an explicit payment amount for this query.
     *
     * The client will submit exactly this amount for the payment of this query. Hedera
     * will not return any remainder.
     *
     * @param {Hbar} queryPayment
     * @returns {this}
     */
    setQueryPayment(queryPayment) {
        this._queryPayment = queryPayment;

        return this;
    }

    /**
     * Set the maximum payment allowable for this query.
     *
     * @param {Hbar} maxQueryPayment
     * @returns {this}
     */
    setMaxQueryPayment(maxQueryPayment) {
        this._maxQueryPayment = maxQueryPayment;

        return this;
    }

    /**
     * Fetch the cost of this query from a consensus node
     *
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        // The node account IDs must be set to execute a cost query
        if (this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setList(
                client._network.getNodeAccountIdsForExecute(),
            );
        }

        if (COST_QUERY.length != 1) {
            throw new Error("CostQuery has not been loaded yet");
        }

        // Change the timestamp. Should we be doing this?
        this._timestamp = Date.now();
        const cost = await COST_QUERY[0](this).execute(client);
        return Hbar.fromTinybars(
            cost._valueInTinybar.multipliedBy(1.1).toFixed(0),
        );
    }

    /**
     * Set he payment transaction explicitly
     *
     * @param {TransactionId} paymentTransactionId
     * @returns {this}
     */
    setPaymentTransactionId(paymentTransactionId) {
        this._paymentTransactionId = paymentTransactionId;
        return this;
    }

    /**
     * Get the payment transaction ID
     *
     * @returns {?TransactionId}
     */
    get paymentTransactionId() {
        return this._paymentTransactionId;
    }

    /**
     * Get the current transaction ID, and make sure it's not null
     *
     * @returns {TransactionId}
     */
    _getTransactionId() {
        if (this._paymentTransactionId == null) {
            throw new Error(
                "Query.PaymentTransactionId was not set duration execution",
            );
        }

        return this._paymentTransactionId;
    }

    /**
     * Is payment required for this query. By default most queries require payment
     * so the default implementation returns true.
     *
     * @protected
     * @returns {boolean}
     */
    _isPaymentRequired() {
        return true;
    }

    /**
     * Validate checksums of the query.
     *
     * @param {Client} client
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    _validateChecksums(client) {
        // Shouldn't we be checking `paymentTransactionId` here sine it contains an `accountId`?
        // Do nothing
    }

    /**
     * Before we proceed exeuction, we need to do a couple checks
     *
     * @template {MirrorChannel} MirrorChannelT
     * @param {import("../client/Client.js").default<Channel, MirrorChannelT>} client
     * @returns {Promise<void>}
     */
    async _beforeExecute(client) {
        // If we're executing this query multiple times the the payment transaction ID list
        // will already be set
        if (this._paymentTransactions.length > 0) {
            return;
        }

        // Check checksums if enabled
        if (client.isAutoValidateChecksumsEnabled()) {
            this._validateChecksums(client);
        }

        // If the nodes aren't set, set them.
        if (this._nodeAccountIds.isEmpty) {
            this._nodeAccountIds.setList(
                client._network.getNodeAccountIdsForExecute(),
            );
        }

        // Save the operator
        this._operator =
            this._operator != null ? this._operator : client._operator;

        // And payment is required
        if (this._isPaymentRequired()) {
            // Assign the account IDs to which the transaction should be sent.
            this.transactionNodeIds = Object.values(client.network).map(
                (accountNodeId) => accountNodeId.toString(),
            );

            // And the client has an operator
            if (this._operator != null) {
                // Generate the payment transaction ID
                this._paymentTransactionId = TransactionId.generate(
                    this._operator.accountId,
                );
            } else {
                // If payment is required, but an operator did not exist, throw an error
                throw new Error(
                    "`client` must have an `operator` or an explicit payment transaction must be provided",
                );
            }
        } else {
            // If the payment transaction ID is not set, but this query doesn't require a payment
            // set the payment transaction ID to an empty transaction ID.
            // FIXME: Should use `TransactionId.withValidStart()` instead
            this._paymentTransactionId = TransactionId.generate(
                new AccountId(0),
            );
        }

        let cost = new Hbar(0);

        const maxQueryPayment =
            this._maxQueryPayment != null
                ? this._maxQueryPayment
                : client.defaultMaxQueryPayment;

        if (this._queryPayment != null) {
            cost = this._queryPayment;
        } else if (
            this._paymentTransactions.length === 0 &&
            this._isPaymentRequired()
        ) {
            // If the query payment was not explictly set, fetch the actual cost.
            const actualCost = await this.getCost(client);

            // Confirm it's less than max query payment
            if (
                maxQueryPayment.toTinybars().toInt() <
                actualCost.toTinybars().toInt()
            ) {
                throw new MaxQueryPaymentExceeded(actualCost, maxQueryPayment);
            }

            cost = actualCost;
            if (this._logger) {
                this._logger.debug(
                    `[${this._getLogId()}] received cost for query ${cost.toString()}`,
                );
            }
        }

        // Set the either queried cost, or the original value back into `queryPayment`
        // in case a user executes same query multiple times. However, users should
        // really not be executing the same query multiple times meaning this is
        // typically not needed.
        this._queryPayment = cost;

        // Not sure if we should be overwritting this field tbh.
        this._timestamp = Date.now();

        this._nodeAccountIds.setLocked();

        // Generate the payment transactions
        for (const nodeId of this._nodeAccountIds.list) {
            const logId = this._getLogId();
            const paymentTransactionId =
                /** @type {import("../transaction/TransactionId.js").default} */ (
                    this._paymentTransactionId
                );
            const paymentAmount = /** @type {Hbar} */ (this._queryPayment);

            if (this._logger) {
                this._logger.debug(
                    `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,
                );
            }

            this._paymentTransactions.push(
                await _makePaymentTransaction(
                    paymentTransactionId,
                    nodeId,
                    this._isPaymentRequired() ? this._operator : null,
                    paymentAmount,
                ),
            );
        }
    }

    /**
     * @abstract
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponseHeader(response) {
        throw new Error("not implemented");
    }

    /**
     * @protected
     * @returns {HieroProto.proto.IQueryHeader}
     */
    _makeRequestHeader() {
        /** @type {HieroProto.proto.IQueryHeader} */
        let header = {};

        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {
            header = {
                responseType: HieroProto.proto.ResponseType.ANSWER_ONLY,
                payment: this._paymentTransactions[this._nodeAccountIds.index],
            };
        }

        return header;
    }

    /**
     * @abstract
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _onMakeRequest(header) {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IQuery}
     */
    _makeRequest() {
        /** @type {HieroProto.proto.IQueryHeader} */
        let header = {};

        if (this._isPaymentRequired() && this._paymentTransactions != null) {
            header = {
                payment: this._paymentTransactions[this._nodeAccountIds.index],
                responseType: HieroProto.proto.ResponseType.ANSWER_ONLY,
            };
        }

        return this._onMakeRequest(header);
    }

    /**
     * @override
     * @internal
     * @returns {Promise<HieroProto.proto.IQuery>}
     */
    async _makeRequestAsync() {
        /** @type {HieroProto.proto.IQueryHeader} */
        let header = {
            responseType: HieroProto.proto.ResponseType.ANSWER_ONLY,
        };

        const logId = this._getLogId();
        const nodeId = this._nodeAccountIds.current;
        const paymentTransactionId = TransactionId.generate(
            this._operator ? this._operator.accountId : new AccountId(0),
        );
        const paymentAmount = /** @type {Hbar} */ (this._queryPayment);

        if (this._logger) {
            this._logger.debug(
                `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`,
            );
        }

        header.payment = await _makePaymentTransaction(
            paymentTransactionId,
            nodeId,
            this._isPaymentRequired() ? this._operator : null,
            paymentAmount,
        );

        return this._onMakeRequest(header);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @returns {[Status, ExecutionState]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : HieroProto.proto.ResponseCodeEnum.OK,
        );
        if (this._logger) {
            this._logger.debug(
                `[${this._getLogId()}] received status ${status.toString()}`,
            );
        }

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.PlatformTransactionNotCreated:
            case Status.PlatformNotActive:
                return [status, ExecutionState.Retry];
            case Status.Ok:
                return [status, ExecutionState.Finished];
            default:
                return [status, ExecutionState.Error];
        }
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response, nodeId) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : HieroProto.proto.ResponseCodeEnum.OK,
        );

        return new PrecheckStatusError({
            nodeId,
            status,
            transactionId: this._getTransactionId(),
            contractFunctionResult: null,
        });
    }

    /**
     * @param {HieroProto.proto.Query} request
     * @returns {Uint8Array}
     */
    _requestToBytes(request) {
        return HieroProto.proto.Query.encode(request).finish();
    }

    /**
     * @param {HieroProto.proto.Response} response
     * @returns {Uint8Array}
     */
    _responseToBytes(response) {
        return HieroProto.proto.Response.encode(response).finish();
    }
}

/**
 * Generate a payment transaction given, aka. `TransferTransaction`
 *
 * @param {TransactionId} paymentTransactionId
 * @param {AccountId} nodeId
 * @param {?ClientOperator} operator
 * @param {Hbar} paymentAmount
 * @returns {Promise<HieroProto.proto.ITransaction>}
 */
export async function _makePaymentTransaction(
    paymentTransactionId,
    nodeId,
    operator,
    paymentAmount,
) {
    const accountAmounts = [];

    // If an operator is provided then we should make sure we transfer
    // from the operator to the node.
    // If an operator is not provided we simply create an effectively
    // empty account amounts
    if (operator != null) {
        accountAmounts.push({
            accountID: operator.accountId._toProtobuf(),
            amount: paymentAmount.negated().toTinybars(),
        });
        accountAmounts.push({
            accountID: nodeId._toProtobuf(),
            amount: paymentAmount.toTinybars(),
        });
    } else {
        accountAmounts.push({
            accountID: new AccountId(0)._toProtobuf(),
            // If the account ID is 0, shouldn't we just hard
            // code this value to 0? Same for the latter.
            amount: paymentAmount.negated().toTinybars(),
        });
        accountAmounts.push({
            accountID: nodeId._toProtobuf(),
            amount: paymentAmount.toTinybars(),
        });
    }
    /**
     * @type {HieroProto.proto.ITransactionBody}
     */
    const body = {
        transactionID: paymentTransactionId._toProtobuf(),
        nodeAccountID: nodeId._toProtobuf(),
        transactionFee: new Hbar(1).toTinybars(),
        transactionValidDuration: {
            seconds: Long.fromNumber(120),
        },
        cryptoTransfer: {
            transfers: {
                accountAmounts,
            },
        },
    };

    /** @type {HieroProto.proto.ISignedTransaction} */
    const signedTransaction = {
        bodyBytes: HieroProto.proto.TransactionBody.encode(body).finish(),
    };

    // Sign the transaction if an operator is provided
    //
    // We have _several_ places where we build the transactions, maybe this is
    // something we can deduplicate?
    if (operator != null) {
        const signature = await operator.transactionSigner(
            /** @type {Uint8Array} */ (signedTransaction.bodyBytes),
        );

        signedTransaction.sigMap = {
            sigPair: [operator.publicKey._toProtobufSignature(signature)],
        };
    }

    // Create and return a `proto.Transaction`
    return {
        signedTransactionBytes:
            HieroProto.proto.SignedTransaction.encode(
                signedTransaction,
            ).finish(),
    };
}

/**
 * Cache for the cost query constructor. This prevents cyclic dependencies.
 *
 * @type {((query: Query<*>) => import("./CostQuery.js").default<*>)[]}
 */
export const COST_QUERY = [];
// Filename: src/schedule/ScheduleCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Timestamp from "../Timestamp.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
    SCHEDULE_CREATE_TRANSACTION,
} from "../transaction/Transaction.js";
import Key from "../Key.js";
import Hbar from "../Hbar.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 */

/**
 * Create a new Hedera™ crypto-currency account.
 */
export default class ScheduleCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {Key} [props.adminKey]
     * @param {AccountId} [props.payerAccountID]
     * @param {string} [props.scheduleMemo]
     * @param {Timestamp} [props.expirationTime]
     * @param {boolean} [props.waitForExpiry]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Transaction}
         */
        this._scheduledTransaction = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._payerAccountId = null;

        /**
         * @private
         * @type {?string}
         */
        this._scheduleMemo = null;

        /**
         * @private
         * @type {Set<string>}
         */
        this._scheduledSignerPublicKeys = new Set();

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._waitForExpiry = null;

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.payerAccountID != null) {
            this.setPayerAccountId(props.payerAccountID);
        }

        if (props.scheduleMemo != null) {
            this.setScheduleMemo(props.scheduleMemo);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ScheduleCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const create =
            /** @type {HieroProto.proto.IScheduleCreateTransactionBody} */ (
                body.scheduleCreate
            );

        const scheduledTransaction = new ScheduleCreateTransaction({
            adminKey:
                create.adminKey != null
                    ? Key._fromProtobufKey(create.adminKey)
                    : undefined,
            payerAccountID:
                create.payerAccountID != null
                    ? AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              create.payerAccountID
                          ),
                      )
                    : undefined,
            scheduleMemo: create.memo != null ? create.memo : undefined,
            waitForExpiry:
                create.waitForExpiry != null ? create.waitForExpiry : undefined,
            expirationTime:
                create.expirationTime != null
                    ? Timestamp._fromProtobuf(create.expirationTime)
                    : undefined,
        });
        if (body.scheduleCreate != null) {
            const scheduleCreateBody =
                body.scheduleCreate.scheduledTransactionBody;

            const scheduleCreateBodyBytes =
                HieroProto.proto.TransactionBody.encode(
                    // @ts-ignore
                    scheduleCreateBody,
                ).finish();

            const signedScheduledCreateTransaction =
                HieroProto.proto.SignedTransaction.encode({
                    bodyBytes: scheduleCreateBodyBytes,
                }).finish();

            const scheduleCreatetransaction = {
                signedTransactionBytes: signedScheduledCreateTransaction,
            };

            const txlist = HieroProto.proto.TransactionList.encode({
                transactionList: [scheduleCreatetransaction],
            }).finish();

            const finalScheduledDecodedTx = Transaction.fromBytes(txlist);

            scheduledTransaction._setScheduledTransaction(
                finalScheduledDecodedTx,
            );
        }

        return Transaction._fromProtobufTransactions(
            scheduledTransaction,
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @internal
     * @param {Transaction} tx
     * @returns {this}
     */
    _setScheduledTransaction(tx) {
        this._scheduledTransaction = tx;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * Set the key for this account.
     *
     * This is the key that must sign each transfer out of the account.
     *
     * If `receiverSignatureRequired` is true, then the key must also sign
     * any transfer into the account.
     *
     * @param {Key} key
     * @returns {this}
     */
    setAdminKey(key) {
        this._requireNotFrozen();
        this._adminKey = key;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get payerAccountId() {
        return this._payerAccountId;
    }

    /**
     * @param {AccountId} account
     * @returns {this}
     */
    setPayerAccountId(account) {
        this._requireNotFrozen();
        this._payerAccountId = account;

        return this;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setScheduleMemo(memo) {
        this._requireNotFrozen();
        this._scheduleMemo = memo;

        return this;
    }

    /**
     * @returns {?string}
     */
    get getScheduleMemo() {
        this._requireNotFrozen();
        return this._scheduleMemo;
    }

    /**
     * @param {Transaction} transaction
     * @returns {this}
     */
    setScheduledTransaction(transaction) {
        this._requireNotFrozen();
        transaction._requireNotFrozen();

        this._scheduledTransaction =
            transaction.schedule()._scheduledTransaction;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._payerAccountId != null) {
            this._payerAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.createSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "scheduleCreate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IScheduleCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            payerAccountID:
                this._payerAccountId != null
                    ? this._payerAccountId._toProtobuf()
                    : null,
            scheduledTransactionBody:
                this._scheduledTransaction != null
                    ? this._scheduledTransaction._getScheduledTransactionBody()
                    : null,
            memo: this._scheduleMemo,
            waitForExpiry: this._waitForExpiry,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ScheduleCreateTransaction:${timestamp.toString()}`;
    }

    /**
     * @param {?Timestamp} expirationTime
     * @returns {this}
     */
    setExpirationTime(expirationTime) {
        this._expirationTime = expirationTime;
        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        this._requireNotFrozen();
        return this._expirationTime;
    }

    /**
     * @param {boolean} waitForExpiry
     * @returns {this}
     */
    setWaitForExpiry(waitForExpiry) {
        this._waitForExpiry = waitForExpiry;

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get waitForExpiry() {
        this._requireNotFrozen();
        return this._waitForExpiry;
    }
}

TRANSACTION_REGISTRY.set(
    "scheduleCreate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ScheduleCreateTransaction._fromProtobuf,
);

SCHEDULE_CREATE_TRANSACTION.push(() => new ScheduleCreateTransaction());
// Filename: src/schedule/ScheduleDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import ScheduleId from "./ScheduleId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IScheduleDeleteTransactionBody} HieroProto.proto.IScheduleDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IScheduleID} HieroProto.proto.IScheduleID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Create a new Hedera™ crypto-currency account.
 */
export default class ScheduleDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ScheduleId | string} [props.scheduleId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ScheduleId}
         */
        this._scheduleId = null;

        if (props.scheduleId != null) {
            this.setScheduleId(props.scheduleId);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ScheduleDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const scheduleDelete =
            /** @type {HieroProto.proto.IScheduleDeleteTransactionBody} */ (
                body.scheduleDelete
            );

        return Transaction._fromProtobufTransactions(
            new ScheduleDeleteTransaction({
                scheduleId:
                    scheduleDelete.scheduleID != null
                        ? ScheduleId._fromProtobuf(
                              /** @type {HieroProto.proto.IScheduleID} */ (
                                  scheduleDelete.scheduleID
                              ),
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?ScheduleId}
     */
    get scheduleId() {
        return this._scheduleId;
    }

    /**
     * @param {ScheduleId | string} scheduleId
     * @returns {this}
     */
    setScheduleId(scheduleId) {
        this._requireNotFrozen();
        this._scheduleId =
            typeof scheduleId === "string"
                ? ScheduleId.fromString(scheduleId)
                : scheduleId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._scheduleId != null) {
            this._scheduleId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.deleteSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "scheduleDelete";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IScheduleDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            scheduleID:
                this._scheduleId != null
                    ? this._scheduleId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ScheduleDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "scheduleDelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ScheduleDeleteTransaction._fromProtobuf,
);
// Filename: src/schedule/ScheduleId.js
// SPDX-License-Identifier: Apache-2.0

import * as entity_id from "../EntityIdHelper.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("long")} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Class representing a unique identifier for a scheduled transaction on the Hedera network.
 *
 * A ScheduleId consists of three components:
 * Shard ID: The shard number where the schedule exists
 * Realm ID: The realm number within the shard
 * Schedule Number: The unique number identifying the schedule
 * @augments {EntityId<HieroProto.proto.IScheduleID>}
 */

export default class ScheduleId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = entity_id.constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {ScheduleId}
     */
    static fromString(text) {
        const result = entity_id.fromString(text);
        const id = new ScheduleId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IScheduleID} id
     * @returns {ScheduleId}
     */
    static _fromProtobuf(id) {
        const scheduleId = new ScheduleId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.scheduleNum != null ? id.scheduleNum : 0,
        );

        return scheduleId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        entity_id.validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {ScheduleId}
     */
    static fromBytes(bytes) {
        return ScheduleId._fromProtobuf(
            HieroProto.proto.ScheduleID.decode(bytes),
        );
    }

    /**
     * @param {string} address
     * @returns {ScheduleId}
     */
    static fromSolidityAddress(address) {
        return new ScheduleId(...entity_id.fromSolidityAddress(address));
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ScheduleID}
     */
    _toProtobuf() {
        return {
            scheduleNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return entity_id.toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.ScheduleID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {ScheduleId}
     */
    clone() {
        const id = new ScheduleId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {ScheduleId} other
     * @returns {number}
     */
    compare(other) {
        return entity_id.compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num],
        );
    }
}
// Filename: src/schedule/ScheduleInfo.js
// SPDX-License-Identifier: Apache-2.0

import ScheduleId from "./ScheduleId.js";
import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import Transaction from "../transaction/Transaction.js";
import * as HieroProto from "@hashgraph/proto";
import TransactionId from "../transaction/TransactionId.js";
import Key from "../Key.js";
import KeyList from "../KeyList.js";

const { proto } = HieroProto;

/**
 * Response when the client sends the node ScheduleGetInfoQuery.
 */
export default class ScheduleInfo {
    /**
     * @private
     * @param {object} props
     * @param {ScheduleId} props.scheduleId;
     * @param {?AccountId} props.creatorAccountID;
     * @param {?AccountId} props.payerAccountID;
     * @param {?HieroProto.proto.ISchedulableTransactionBody} props.schedulableTransactionBody;
     * @param {?Key} props.adminKey
     * @param {?KeyList} props.signers;
     * @param {?string} props.scheduleMemo;
     * @param {?Timestamp} props.expirationTime;
     * @param {?Timestamp} props.executed;
     * @param {?Timestamp} props.deleted;
     * @param {?TransactionId} props.scheduledTransactionId;
     * @param {boolean} props.waitForExpiry;
     */
    constructor(props) {
        /**
         * @readonly
         */
        this.scheduleId = props.scheduleId;

        /**
         * @readonly
         */
        this.creatorAccountId = props.creatorAccountID;

        /**
         * @readonly
         */
        this.payerAccountId = props.payerAccountID;

        /**
         * @readonly
         */
        this.schedulableTransactionBody = props.schedulableTransactionBody;

        /**
         * @readonly
         */
        this.signers = props.signers;

        /**
         * @readonly
         */
        this.scheduleMemo = props.scheduleMemo;

        /**
         * @readonly
         */
        this.adminKey = props.adminKey != null ? props.adminKey : null;

        /**
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * @readonly
         */
        this.executed = props.executed;

        /**
         * @readonly
         */
        this.deleted = props.deleted;

        /**
         * @readonly
         */
        this.scheduledTransactionId = props.scheduledTransactionId;

        /**
         *
         * @readonly
         */
        this.waitForExpiry = props.waitForExpiry;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IScheduleInfo} info
     * @returns {ScheduleInfo}
     */
    static _fromProtobuf(info) {
        return new ScheduleInfo({
            scheduleId: ScheduleId._fromProtobuf(
                /** @type {HieroProto.proto.IScheduleID} */ (info.scheduleID),
            ),
            creatorAccountID:
                info.creatorAccountID != null
                    ? AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              info.creatorAccountID
                          ),
                      )
                    : null,
            payerAccountID:
                info.payerAccountID != null
                    ? AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              info.payerAccountID
                          ),
                      )
                    : null,
            schedulableTransactionBody:
                info.scheduledTransactionBody != null
                    ? info.scheduledTransactionBody
                    : null,
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            signers:
                info.signers != null
                    ? KeyList.__fromProtobufKeyList(info.signers)
                    : null,
            scheduleMemo: info.memo != null ? info.memo : null,
            expirationTime:
                info.expirationTime != null
                    ? Timestamp._fromProtobuf(
                          /** @type {HieroProto.proto.ITimestamp} */ (
                              info.expirationTime
                          ),
                      )
                    : null,
            executed:
                info.executionTime != null
                    ? Timestamp._fromProtobuf(
                          /** @type {HieroProto.proto.ITimestamp} */ (
                              info.executionTime
                          ),
                      )
                    : null,
            deleted:
                info.deletionTime != null
                    ? Timestamp._fromProtobuf(
                          /** @type {HieroProto.proto.ITimestamp} */ (
                              info.deletionTime
                          ),
                      )
                    : null,
            scheduledTransactionId:
                info.scheduledTransactionID != null
                    ? TransactionId._fromProtobuf(info.scheduledTransactionID)
                    : null,
            waitForExpiry:
                info.waitForExpiry != null ? info.waitForExpiry : false,
        });
    }

    /**
     * @returns {HieroProto.proto.IScheduleInfo}
     */
    _toProtobuf() {
        return {
            scheduleID:
                this.scheduleId != null ? this.scheduleId._toProtobuf() : null,
            creatorAccountID:
                this.creatorAccountId != null
                    ? this.creatorAccountId._toProtobuf()
                    : null,
            payerAccountID:
                this.payerAccountId != null
                    ? this.payerAccountId._toProtobuf()
                    : null,
            scheduledTransactionBody:
                this.schedulableTransactionBody != null
                    ? this.schedulableTransactionBody
                    : null,
            adminKey:
                this.adminKey != null ? this.adminKey._toProtobufKey() : null,
            signers:
                this.signers != null
                    ? this.signers._toProtobufKey().keyList
                    : null,
            memo: this.scheduleMemo != null ? this.scheduleMemo : "",
            expirationTime:
                this.expirationTime != null
                    ? this.expirationTime._toProtobuf()
                    : null,
            scheduledTransactionID:
                this.scheduledTransactionId != null
                    ? this.scheduledTransactionId._toProtobuf()
                    : null,
            waitForExpiry: this.waitForExpiry,
        };
    }

    /**
     * @returns {Transaction}
     */
    get scheduledTransaction() {
        if (this.schedulableTransactionBody == null) {
            throw new Error("Scheduled transaction body is empty");
        }

        const scheduled = new proto.SchedulableTransactionBody(
            this.schedulableTransactionBody,
        );
        const data =
            /** @type {NonNullable<HieroProto.proto.SchedulableTransactionBody["data"]>} */ (
                scheduled.data
            );

        return Transaction.fromBytes(
            proto.TransactionList.encode({
                transactionList: [
                    {
                        signedTransactionBytes: proto.SignedTransaction.encode({
                            bodyBytes: proto.TransactionBody.encode({
                                transactionFee:
                                    this.schedulableTransactionBody
                                        .transactionFee,
                                memo: this.schedulableTransactionBody.memo,
                                [data]: scheduled[data],
                            }).finish(),
                        }).finish(),
                    },
                ],
            }).finish(),
        );
    }
}
// Filename: src/schedule/ScheduleInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import ScheduleId from "./ScheduleId.js";
import ScheduleInfo from "./ScheduleInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.IScheduleInfo} HieroProto.proto.IScheduleInfo
 * @typedef {import("@hashgraph/proto").proto.IScheduleGetInfoQuery} HieroProto.proto.IScheduleGetInfoQuery
 * @typedef {import("@hashgraph/proto").proto.IScheduleGetInfoResponse} HieroProto.proto.IScheduleGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Retrieve the metadata for a schedule.
 * @augments {Query<ScheduleInfo>}
 */
export default class ScheduleInfoQuery extends Query {
    /**
     * @param {object} properties
     * @param {ScheduleId | string} [properties.scheduleId]
     */
    constructor(properties = {}) {
        super();

        /**
         * @private
         * @type {?ScheduleId}
         */
        this._scheduleId = null;

        if (properties.scheduleId != null) {
            this.setScheduleId(properties.scheduleId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {ScheduleInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {HieroProto.proto.IScheduleGetInfoQuery} */ (
            query.scheduleGetInfo
        );

        return new ScheduleInfoQuery({
            scheduleId:
                info.scheduleID != null
                    ? ScheduleId._fromProtobuf(info.scheduleID)
                    : undefined,
        });
    }

    /**
     * @returns {?ScheduleId}
     */
    get scheduleId() {
        return this._scheduleId;
    }

    /**
     *
     * @param {ScheduleId | string} scheduleId
     * @returns {ScheduleInfoQuery}
     */
    setScheduleId(scheduleId) {
        this._scheduleId =
            typeof scheduleId === "string"
                ? ScheduleId.fromString(scheduleId)
                : scheduleId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._scheduleId != null) {
            this._scheduleId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.getScheduleInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const scheduleGetInfo =
            /** @type {HieroProto.proto.IScheduleGetInfoResponse} */ (
                response.scheduleGetInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            scheduleGetInfo.header
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<ScheduleInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {HieroProto.proto.IScheduleGetInfoResponse} */ (
            response.scheduleGetInfo
        );

        return Promise.resolve(
            ScheduleInfo._fromProtobuf(
                /** @type {HieroProto.proto.IScheduleInfo} */ (
                    info.scheduleInfo
                ),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            scheduleGetInfo: {
                header,
                scheduleID:
                    this._scheduleId != null
                        ? this._scheduleId._toProtobuf()
                        : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `ScheduleInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("scheduleGetInfo", ScheduleInfoQuery._fromProtobuf);
// Filename: src/schedule/ScheduleSignTransaction.js
// SPDX-License-Identifier: Apache-2.0

import ScheduleId from "./ScheduleId.js";
import Hbar from "../Hbar.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @typedef {object} ProtoSignaturePair
 * @property {(Uint8Array | null)=} pubKeyPrefix
 * @property {(Uint8Array | null)=} ed25519
 */

/**
 * @typedef {object} ProtoSigMap
 * @property {(ProtoSignaturePair[] | null)=} sigPair
 */

/**
 * @typedef {object} ProtoSignedTransaction
 * @property {(Uint8Array | null)=} bodyBytes
 * @property {(ProtoSigMap | null)=} sigMap
 */

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IScheduleSignTransactionBody} HieroProto.proto.IScheduleSignTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.ISignatureMap} HieroProto.proto.ISignatureMap
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("@hashgraph/cryptography").Key} Key
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("@hashgraph/cryptography").PublicKey} PublicKey
 */

/**
 * Create a new Hedera™ crypto-currency account.
 */
export default class ScheduleSignTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {ScheduleId | string} [props.scheduleId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?ScheduleId}
         */
        this._scheduleId = null;

        if (props.scheduleId != null) {
            this.setScheduleId(props.scheduleId);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {ScheduleSignTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const sign =
            /** @type {HieroProto.proto.IScheduleSignTransactionBody} */ (
                body.scheduleSign
            );

        return Transaction._fromProtobufTransactions(
            new ScheduleSignTransaction({
                scheduleId:
                    sign.scheduleID != null
                        ? ScheduleId._fromProtobuf(sign.scheduleID)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?ScheduleId}
     */
    get scheduleId() {
        return this._scheduleId;
    }

    /**
     * @param {ScheduleId | string} scheduleId
     * @returns {this}
     */
    setScheduleId(scheduleId) {
        this._requireNotFrozen();
        this._scheduleId =
            typeof scheduleId === "string"
                ? ScheduleId.fromString(scheduleId)
                : scheduleId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._scheduleId != null) {
            this._scheduleId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.schedule.signSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "scheduleSign";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IScheduleSignTransactionBody}
     */
    _makeTransactionData() {
        return {
            scheduleID:
                this._scheduleId != null
                    ? this._scheduleId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `ScheduleSignTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "scheduleSign",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ScheduleSignTransaction._fromProtobuf,
);
// Filename: src/system/FreezeTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Timestamp from "../Timestamp.js";
import FileId from "../file/FileId.js";
import * as hex from "../encoding/hex.js";
import FreezeType from "../FreezeType.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IFreezeTransactionBody} HieroProto.proto.IFreezeTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * @typedef {object} HourMinute
 * @property {number} hour
 * @property {number} minute
 */

/**
 * Freeze, cancel, or prepare a freeze.
 * This single transaction performs all of the functions supported
 * by the network freeze service. These functions include actions to
 * prepare an upgrade, prepare a telemetry upgrade, freeze the network,
 * freeze the network for upgrade, or abort a scheduled freeze.
 * <p>
 * The actual freeze action SHALL be determined by the `freeze_type` field
 * of the `FreezeTransactionBody`.<br/>
 */
export default class FreezeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {HourMinute} [props.startTime]
     * @param {HourMinute} [props.endTime]
     * @param {Timestamp} [props.startTimestamp]
     * @param {FileId} [props.updateFileId]
     * @param {FileId} [props.fileId]
     * @param {Uint8Array | string} [props.fileHash]
     * @param { FreezeType } [props.freezeType]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?HourMinute}
         */
        this._startTime = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._startTimestamp = null;

        /**
         * @private
         * @type {?HourMinute}
         */
        this._endTime = null;

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._fileHash = null;

        /**
         * @private
         * @type {?FreezeType}
         */
        this._freezeType = null;

        if (props.startTime != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setStartTime(props.startTime.hour, props.startTime.minute);
        }

        if (props.endTime != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setEndTime(props.endTime.hour, props.endTime.minute);
        }

        if (props.startTimestamp != null) {
            this.setStartTimestamp(props.startTimestamp);
        }

        if (props.updateFileId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setUpdateFileId(props.updateFileId);
        }

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.fileHash != null) {
            this.setFileHash(props.fileHash);
        }

        if (props.freezeType != null) {
            this.setFreezeType(props.freezeType);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {FreezeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const freeze = /** @type {HieroProto.proto.IFreezeTransactionBody} */ (
            body.freeze
        );

        return Transaction._fromProtobufTransactions(
            new FreezeTransaction({
                startTime:
                    freeze.startHour != null && freeze.startMin != null
                        ? {
                              hour: freeze.startHour,
                              minute: freeze.startMin,
                          }
                        : undefined,
                endTime:
                    freeze.endHour != null && freeze.endMin != null
                        ? {
                              hour: freeze.endHour,
                              minute: freeze.endMin,
                          }
                        : undefined,
                startTimestamp:
                    freeze.startTime != null
                        ? Timestamp._fromProtobuf(freeze.startTime)
                        : undefined,
                updateFileId:
                    freeze.updateFile != null
                        ? FileId._fromProtobuf(freeze.updateFile)
                        : undefined,
                fileHash: freeze.fileHash != null ? freeze.fileHash : undefined,
                freezeType:
                    freeze.freezeType != null
                        ? FreezeType._fromCode(freeze.freezeType)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @deprecated - Use `startTimestamp` instead
     * @returns {?HourMinute}
     */
    get startTime() {
        return null;
    }

    /**
     * @deprecated - Use `startTimestamp` instead
     * @param {number | string} startHourOrString
     * @param {?number} startMinute
     * @returns {FreezeTransaction}
     */
    setStartTime(startHourOrString, startMinute) {
        this._requireNotFrozen();
        if (typeof startHourOrString === "string") {
            const split = startHourOrString.split(":");
            this._startTime = {
                hour: Number(split[0]),
                minute: Number(split[1]),
            };
        } else {
            this._startTime = {
                hour: startHourOrString,
                minute: /** @type {number} */ (startMinute),
            };
        }

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get startTimestamp() {
        return this._startTimestamp;
    }

    /**
     * @param {Timestamp} startTimestamp
     * @returns {FreezeTransaction}
     */
    setStartTimestamp(startTimestamp) {
        this._requireNotFrozen();
        this._startTimestamp = startTimestamp;

        return this;
    }

    /**
     * @deprecated
     * @returns {?HourMinute}
     */
    get endTime() {
        console.warn("`FreezeTransaction.endTime` is deprecated");
        return this._endTime;
    }

    /**
     * @deprecated
     * @param {number | string} endHourOrString
     * @param {?number} endMinute
     * @returns {FreezeTransaction}
     */
    setEndTime(endHourOrString, endMinute) {
        console.warn("`FreezeTransaction.endTime` is deprecated");
        this._requireNotFrozen();
        if (typeof endHourOrString === "string") {
            const split = endHourOrString.split(":");
            this._endTime = {
                hour: Number(split[0]),
                minute: Number(split[1]),
            };
        } else {
            this._endTime = {
                hour: endHourOrString,
                minute: /** @type {number} */ (endMinute),
            };
        }

        return this;
    }

    /**
     * @deprecated - Use `fileId` instead
     * @returns {?FileId}
     */
    get updateFileId() {
        return this.fileId;
    }

    /**
     * @deprecated - Use `setFileId()` instead
     * @param {FileId} updateFileId
     * @returns {FreezeTransaction}
     */
    setUpdateFileId(updateFileId) {
        return this.setFileId(updateFileId);
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId} fileId
     * @returns {FreezeTransaction}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId = fileId;

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get fileHash() {
        return this._fileHash;
    }

    /**
     * @param {Uint8Array | string} fileHash
     * @returns {FreezeTransaction}
     */
    setFileHash(fileHash) {
        this._requireNotFrozen();
        this._fileHash =
            typeof fileHash === "string" ? hex.decode(fileHash) : fileHash;

        return this;
    }

    /**
     * @returns {?FreezeType}
     */
    get freezeType() {
        return this._freezeType;
    }

    /**
     * @param {FreezeType} freezeType
     * @returns {FreezeTransaction}
     */
    setFreezeType(freezeType) {
        this._requireNotFrozen();
        this._freezeType = freezeType;
        return this;
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "freeze";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IFreezeTransactionBody}
     */
    _makeTransactionData() {
        return {
            startTime:
                this._startTimestamp != null
                    ? this._startTimestamp._toProtobuf()
                    : null,
            updateFile:
                this._fileId != null ? this._fileId._toProtobuf() : null,
            fileHash: this._fileHash,
            freezeType:
                this._freezeType != null ? this._freezeType.valueOf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `FreezeTransaction:${timestamp.toString()}`;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.freeze.freeze(request);
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
TRANSACTION_REGISTRY.set("freeze", FreezeTransaction._fromProtobuf);
// Filename: src/system/SystemDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import FileId from "../file/FileId.js";
import ContractId from "../contract/ContractId.js";
import Timestamp from "../Timestamp.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ISystemDeleteTransactionBody} HieroProto.proto.ISystemDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Deprecated: Do not use.
 * @deprecated
 */
export default class SystemDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     * @param {ContractId | string} [props.contractId]
     * @param {Timestamp} [props.expirationTime]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {SystemDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const systemDelete =
            /** @type {HieroProto.proto.ISystemDeleteTransactionBody} */ (
                body.systemDelete
            );

        return Transaction._fromProtobufTransactions(
            // eslint-disable-next-line deprecation/deprecation
            new SystemDeleteTransaction({
                fileId:
                    systemDelete.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {HieroProto.proto.IFileID} */ (
                                  systemDelete.fileID
                              ),
                          )
                        : undefined,
                contractId:
                    systemDelete.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {HieroProto.proto.IContractID} */ (
                                  systemDelete.contractID
                              ),
                          )
                        : undefined,
                expirationTime:
                    systemDelete.expirationTime != null
                        ? Timestamp._fromProtobuf(systemDelete.expirationTime)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            fileId instanceof FileId ? fileId : FileId.fromString(fileId);

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * @param {ContractId | string} contractId
     * @returns {this}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            contractId instanceof ContractId
                ? contractId
                : ContractId.fromString(contractId);

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp} expirationTime
     * @returns {SystemDeleteTransaction}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();
        this._expirationTime = expirationTime;
        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        if (this._fileId != null) {
            return channel.file.systemDelete(request);
        } else {
            return channel.smartContract.systemDelete(request);
        }
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "systemDelete";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ISystemDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `SystemDeleteTransaction:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
TRANSACTION_REGISTRY.set("systemDelete", SystemDeleteTransaction._fromProtobuf);
// Filename: src/system/SystemUndeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import FileId from "../file/FileId.js";
import ContractId from "../contract/ContractId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ISystemUndeleteTransactionBody} HieroProto.proto.ISystemUndeleteTransactionBody
 * @typedef {import("@hashgraph/proto").proto.IContractID} HieroProto.proto.IContractID
 * @typedef {import("@hashgraph/proto").proto.IFileID} HieroProto.proto.IFileID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../Timestamp.js").default} Timestamp
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Deprecated: Do not use.
 * @deprecated
 */
export default class SystemUndeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {FileId | string} [props.fileId]
     * @param {ContractId | string} [props.contractId]
     * @param {Timestamp} [props.expirationTime]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?FileId}
         */
        this._fileId = null;

        /**
         * @private
         * @type {?ContractId}
         */
        this._contractId = null;

        if (props.fileId != null) {
            this.setFileId(props.fileId);
        }

        if (props.contractId != null) {
            this.setContractId(props.contractId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {SystemUndeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const systemUndelete =
            /** @type {HieroProto.proto.ISystemUndeleteTransactionBody} */ (
                body.systemUndelete
            );

        return Transaction._fromProtobufTransactions(
            // eslint-disable-next-line deprecation/deprecation
            new SystemUndeleteTransaction({
                fileId:
                    systemUndelete.fileID != null
                        ? FileId._fromProtobuf(
                              /** @type {HieroProto.proto.IFileID} */ (
                                  systemUndelete.fileID
                              ),
                          )
                        : undefined,
                contractId:
                    systemUndelete.contractID != null
                        ? ContractId._fromProtobuf(
                              /** @type {HieroProto.proto.IContractID} */ (
                                  systemUndelete.contractID
                              ),
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?FileId}
     */
    get fileId() {
        return this._fileId;
    }

    /**
     * @param {FileId | string} fileId
     * @returns {this}
     */
    setFileId(fileId) {
        this._requireNotFrozen();
        this._fileId =
            fileId instanceof FileId ? fileId : FileId.fromString(fileId);

        return this;
    }

    /**
     * @returns {?ContractId}
     */
    get contractId() {
        return this._contractId;
    }

    /**
     * @param {ContractId | string} contractId
     * @returns {this}
     */
    setContractId(contractId) {
        this._requireNotFrozen();
        this._contractId =
            contractId instanceof ContractId
                ? contractId
                : ContractId.fromString(contractId);

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        if (this._fileId != null) {
            return channel.file.systemUndelete(request);
        } else {
            return channel.smartContract.systemUndelete(request);
        }
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "systemUndelete";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ISystemUndeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,
            contractID:
                this._contractId != null
                    ? this._contractId._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `SystemUndeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "systemUndelete",
    // eslint-disable-next-line @typescript-eslint/unbound-method, deprecation/deprecation
    SystemUndeleteTransaction._fromProtobuf,
);
// Filename: src/token/AbstractTokenTransferTransaction.js
// SPDX-License-Identifier: Apache-2.0
import TokenTransfer from "./TokenTransfer.js";
import TokenNftTransfer from "../token/TokenNftTransfer.js";
import TokenId from "./TokenId.js";
import NftId from "./NftId.js";
import AccountId from "../account/AccountId.js";
import Transaction from "../transaction/Transaction.js";
import Long from "long";
import NullableTokenDecimalMap from "../account/NullableTokenDecimalMap.js";
import TokenNftTransferMap from "../account/TokenNftTransferMap.js";
import TokenTransferMap from "../account/TokenTransferMap.js";
import TokenTransferAccountMap from "../account/TokenTransferAccountMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenAirdropTransactionBody} HieroProto.proto.ITokenAirdropTransactionBody
 */

/**
 * @typedef {object} TransferTokensInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} accountId
 * @property {Long | number} amount
 */

/**
 * @typedef {object} TransferNftInput
 * @property {TokenId | string} tokenId
 * @property {AccountId | string} sender
 * @property {AccountId | string} recipient
 * @property {Long | number} serial
 */

export default class AbstractTokenTransferTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {(TransferTokensInput)[]} [props.tokenTransfers]
     * @param {(TransferNftInput)[]} [props.nftTransfers]
     */
    constructor(props = {}) {
        super();

        /**
         * @protected
         * @type {TokenTransfer[]}
         */
        this._tokenTransfers = [];

        /**
         * @protected
         * @type {TokenNftTransfer[]}
         */
        this._nftTransfers = [];

        for (const transfer of props.tokenTransfers != null
            ? props.tokenTransfers
            : []) {
            this.addTokenTransfer(
                transfer.tokenId,
                transfer.accountId,
                transfer.amount,
            );
        }

        for (const transfer of props.nftTransfers != null
            ? props.nftTransfers
            : []) {
            this.addNftTransfer(
                transfer.tokenId,
                transfer.serial,
                transfer.sender,
                transfer.recipient,
            );
        }
    }

    /**
     * @param {NftId | TokenId | string} tokenIdOrNftId
     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
     * @param {AccountId | string} receiverAccountIdOrSenderAccountId
     * @param {(AccountId | string)=} receiver
     * @returns {this}
     */
    addNftTransfer(
        tokenIdOrNftId,
        senderAccountIdOrSerialNumber,
        receiverAccountIdOrSenderAccountId,
        receiver,
    ) {
        return this._addNftTransfer(
            false,
            tokenIdOrNftId,
            senderAccountIdOrSerialNumber,
            receiverAccountIdOrSenderAccountId,
            receiver,
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @param {boolean} isApproved
     * @param {number | null} expectedDecimals
     * @returns {this}
     */
    _addTokenTransfer(
        tokenId,
        accountId,
        amount,
        isApproved,
        expectedDecimals,
    ) {
        this._requireNotFrozen();

        const token =
            tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
        const account =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);
        const value = amount instanceof Long ? amount : Long.fromNumber(amount);

        for (const tokenTransfer of this._tokenTransfers) {
            if (
                tokenTransfer.tokenId.compare(token) === 0 &&
                tokenTransfer.accountId.compare(account) === 0
            ) {
                tokenTransfer.amount = tokenTransfer.amount.add(value);
                tokenTransfer.expectedDecimals = expectedDecimals;
                return this;
            }
        }

        this._tokenTransfers.push(
            new TokenTransfer({
                tokenId,
                accountId,
                expectedDecimals: expectedDecimals,
                amount,
                isApproved,
            }),
        );

        return this;
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @returns {this}
     */
    addTokenTransfer(tokenId, accountId, amount) {
        return this._addTokenTransfer(tokenId, accountId, amount, false, null);
    }

    /**
     * @param {boolean} isApproved
     * @param {NftId | TokenId | string} tokenIdOrNftId
     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
     * @param {AccountId | string} receiverAccountIdOrSenderAccountId
     * @param {(AccountId | string)=} receiver
     * @returns {this}
     */
    _addNftTransfer(
        isApproved,
        tokenIdOrNftId,
        senderAccountIdOrSerialNumber,
        receiverAccountIdOrSenderAccountId,
        receiver,
    ) {
        this._requireNotFrozen();

        let nftId;
        let senderAccountId;
        let receiverAccountId;

        if (tokenIdOrNftId instanceof NftId) {
            nftId = tokenIdOrNftId;
            senderAccountId =
                typeof senderAccountIdOrSerialNumber === "string"
                    ? AccountId.fromString(senderAccountIdOrSerialNumber)
                    : /** @type {AccountId} */ (senderAccountIdOrSerialNumber);
            receiverAccountId =
                typeof receiverAccountIdOrSenderAccountId === "string"
                    ? AccountId.fromString(receiverAccountIdOrSenderAccountId)
                    : /** @type {AccountId} */ (
                          receiverAccountIdOrSenderAccountId
                      );
        } else if (tokenIdOrNftId instanceof TokenId) {
            nftId = new NftId(
                tokenIdOrNftId,
                /** @type {Long} */ (senderAccountIdOrSerialNumber),
            );
            senderAccountId =
                typeof receiverAccountIdOrSenderAccountId === "string"
                    ? AccountId.fromString(receiverAccountIdOrSenderAccountId)
                    : /** @type {AccountId} */ (
                          receiverAccountIdOrSenderAccountId
                      );
            receiverAccountId =
                typeof receiver === "string"
                    ? AccountId.fromString(receiver)
                    : /** @type {AccountId} */ (receiver);
        } else {
            try {
                nftId = NftId.fromString(tokenIdOrNftId);
                senderAccountId =
                    typeof senderAccountIdOrSerialNumber === "string"
                        ? AccountId.fromString(senderAccountIdOrSerialNumber)
                        : /** @type {AccountId} */ (
                              senderAccountIdOrSerialNumber
                          );
                receiverAccountId =
                    typeof receiverAccountIdOrSenderAccountId === "string"
                        ? AccountId.fromString(
                              receiverAccountIdOrSenderAccountId,
                          )
                        : /** @type {AccountId} */ (
                              receiverAccountIdOrSenderAccountId
                          );
            } catch (_) {
                const tokenId = TokenId.fromString(tokenIdOrNftId);
                nftId = new NftId(
                    tokenId,
                    /** @type {Long} */ (senderAccountIdOrSerialNumber),
                );
                senderAccountId =
                    typeof receiverAccountIdOrSenderAccountId === "string"
                        ? AccountId.fromString(
                              receiverAccountIdOrSenderAccountId,
                          )
                        : /** @type {AccountId} */ (
                              receiverAccountIdOrSenderAccountId
                          );
                receiverAccountId =
                    typeof receiver === "string"
                        ? AccountId.fromString(receiver)
                        : /** @type {AccountId} */ (receiver);
            }
        }

        for (const nftTransfer of this._nftTransfers) {
            if (
                nftTransfer.tokenId.compare(nftId.tokenId) === 0 &&
                nftTransfer.serialNumber.compare(nftId.serial) === 0
            ) {
                nftTransfer.senderAccountId = senderAccountId;
                nftTransfer.receiverAccountId = receiverAccountId;
                return this;
            }
        }

        this._nftTransfers.push(
            new TokenNftTransfer({
                tokenId: nftId.tokenId,
                serialNumber: nftId.serial,
                senderAccountId,
                receiverAccountId,
                isApproved,
            }),
        );

        return this;
    }

    /**
     * @param {NftId | TokenId | string} tokenIdOrNftId
     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber
     * @param {AccountId | string} receiverAccountIdOrSenderAccountId
     * @param {(AccountId | string)=} receiver
     * @returns {this}
     */
    addApprovedNftTransfer(
        tokenIdOrNftId,
        senderAccountIdOrSerialNumber,
        receiverAccountIdOrSenderAccountId,
        receiver,
    ) {
        return this._addNftTransfer(
            true,
            tokenIdOrNftId,
            senderAccountIdOrSerialNumber,
            receiverAccountIdOrSenderAccountId,
            receiver,
        );
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @returns {this}
     */
    addApprovedTokenTransfer(tokenId, accountId, amount) {
        return this._addTokenTransfer(tokenId, accountId, amount, true, null);
    }

    /**
     * @param {TokenId | string} tokenId
     * @param {AccountId | string} accountId
     * @param {number | Long} amount
     * @param {number} decimals
     * @returns {this}
     */
    addTokenTransferWithDecimals(tokenId, accountId, amount, decimals) {
        this._requireNotFrozen();

        const token =
            tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);
        const account =
            accountId instanceof AccountId
                ? accountId
                : AccountId.fromString(accountId);
        const value = amount instanceof Long ? amount : Long.fromNumber(amount);

        let found = false;

        for (const tokenTransfer of this._tokenTransfers) {
            if (tokenTransfer.tokenId.compare(token) === 0) {
                if (
                    tokenTransfer.expectedDecimals != null &&
                    tokenTransfer.expectedDecimals !== decimals
                ) {
                    throw new Error("expected decimals mis-match");
                } else {
                    tokenTransfer.expectedDecimals = decimals;
                }

                if (tokenTransfer.accountId.compare(account) === 0) {
                    tokenTransfer.amount = tokenTransfer.amount.add(value);
                    tokenTransfer.expectedDecimals = decimals;
                    found = true;
                }
            }
        }

        if (found) {
            return this;
        }

        this._tokenTransfers.push(
            new TokenTransfer({
                tokenId,
                accountId,
                expectedDecimals: decimals,
                amount,
                isApproved: false,
            }),
        );

        return this;
    }

    /**
     * @returns {NullableTokenDecimalMap}
     */
    get tokenIdDecimals() {
        const map = new NullableTokenDecimalMap();

        for (const transfer of this._tokenTransfers) {
            map._set(transfer.tokenId, transfer.expectedDecimals);
        }

        return map;
    }

    /**
     * @returns {TokenNftTransferMap}
     */
    get nftTransfers() {
        const map = new TokenNftTransferMap();

        for (const transfer of this._nftTransfers) {
            const transferList = map.get(transfer.tokenId);

            const nftTransfer = {
                sender: transfer.senderAccountId,
                recipient: transfer.receiverAccountId,
                serial: transfer.serialNumber,
                isApproved: transfer.isApproved,
            };

            if (transferList != null) {
                transferList.push(nftTransfer);
            } else {
                map._set(transfer.tokenId, [nftTransfer]);
            }
        }

        return map;
    }

    /**
     * @returns {TokenTransferMap}
     */
    get tokenTransfers() {
        const map = new TokenTransferMap();

        for (const transfer of this._tokenTransfers) {
            let transferMap = map.get(transfer.tokenId);

            if (transferMap != null) {
                transferMap._set(transfer.accountId, transfer.amount);
            } else {
                transferMap = new TokenTransferAccountMap();
                transferMap._set(transfer.accountId, transfer.amount);
                map._set(transfer.tokenId, transferMap);
            }
        }

        return map;
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenAirdropTransactionBody}
     */
    _makeTransactionData() {
        /** @type {{tokenId: TokenId; expectedDecimals: number | null; transfers: TokenTransfer[]; nftTransfers: TokenNftTransfer[];}[]} */
        const tokenTransferList = [];

        this._tokenTransfers.sort((a, b) => {
            const compare = a.tokenId.compare(b.tokenId);

            if (compare !== 0) {
                return compare;
            }

            return a.accountId.compare(b.accountId);
        });

        this._nftTransfers.sort((a, b) => {
            const senderComparision = a.senderAccountId.compare(
                b.senderAccountId,
            );
            if (senderComparision != 0) {
                return senderComparision;
            }

            const recipientComparision = a.receiverAccountId.compare(
                b.receiverAccountId,
            );
            if (recipientComparision != 0) {
                return recipientComparision;
            }

            return a.serialNumber.compare(b.serialNumber);
        });

        let i = 0;
        let j = 0;
        while (
            i < this._tokenTransfers.length ||
            j < this._nftTransfers.length
        ) {
            if (
                i < this._tokenTransfers.length &&
                j < this._nftTransfers.length
            ) {
                const iTokenId = this._tokenTransfers[i].tokenId;
                const jTokenId = this._nftTransfers[j].tokenId;

                const last =
                    tokenTransferList.length > 0
                        ? tokenTransferList[tokenTransferList.length - 1]
                        : null;
                const lastTokenId = last != null ? last.tokenId : null;

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(iTokenId) === 0
                ) {
                    last.transfers.push(this._tokenTransfers[i++]);
                    continue;
                }

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(jTokenId) === 0
                ) {
                    last.nftTransfers.push(this._nftTransfers[j++]);
                    continue;
                }

                const result = iTokenId.compare(jTokenId);

                if (result === 0) {
                    tokenTransferList.push({
                        tokenId: iTokenId,
                        expectedDecimals:
                            this._tokenTransfers[i].expectedDecimals,
                        transfers: [this._tokenTransfers[i++]],
                        nftTransfers: [this._nftTransfers[j++]],
                    });
                } else if (result < 0) {
                    tokenTransferList.push({
                        tokenId: iTokenId,
                        expectedDecimals:
                            this._tokenTransfers[i].expectedDecimals,
                        transfers: [this._tokenTransfers[i++]],
                        nftTransfers: [],
                    });
                } else {
                    tokenTransferList.push({
                        tokenId: jTokenId,
                        expectedDecimals: null,
                        transfers: [],
                        nftTransfers: [this._nftTransfers[j++]],
                    });
                }
            } else if (i < this._tokenTransfers.length) {
                const iTokenId = this._tokenTransfers[i].tokenId;

                let last;
                for (const transfer of tokenTransferList) {
                    if (transfer.tokenId.compare(iTokenId) === 0) {
                        last = transfer;
                    }
                }
                const lastTokenId = last != null ? last.tokenId : null;

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(iTokenId) === 0
                ) {
                    last.transfers.push(this._tokenTransfers[i++]);
                    continue;
                }

                tokenTransferList.push({
                    tokenId: iTokenId,
                    expectedDecimals: this._tokenTransfers[i].expectedDecimals,
                    transfers: [this._tokenTransfers[i++]],
                    nftTransfers: [],
                });
            } else if (j < this._nftTransfers.length) {
                const jTokenId = this._nftTransfers[j].tokenId;

                let last;
                for (const transfer of tokenTransferList) {
                    if (transfer.tokenId.compare(jTokenId) === 0) {
                        last = transfer;
                    }
                }
                const lastTokenId = last != null ? last.tokenId : null;

                if (
                    last != null &&
                    lastTokenId != null &&
                    lastTokenId.compare(jTokenId) === 0
                ) {
                    last.nftTransfers.push(this._nftTransfers[j++]);
                    continue;
                }

                tokenTransferList.push({
                    tokenId: jTokenId,
                    expectedDecimals: null,
                    transfers: [],
                    nftTransfers: [this._nftTransfers[j++]],
                });
            }
        }

        return {
            tokenTransfers: tokenTransferList.map((tokenTransfer) => {
                return {
                    token: tokenTransfer.tokenId._toProtobuf(),
                    expectedDecimals:
                        tokenTransfer.expectedDecimals != null
                            ? { value: tokenTransfer.expectedDecimals }
                            : null,
                    transfers: tokenTransfer.transfers.map((transfer) =>
                        transfer._toProtobuf(),
                    ),
                    nftTransfers: tokenTransfer.nftTransfers.map((transfer) =>
                        transfer._toProtobuf(),
                    ),
                };
            }),
        };
    }
}
// Filename: src/token/AirdropPendingTransaction.js
// SPDX-License-Identifier: Apache-2.0
import Transaction from "../transaction/Transaction.js";

/**
 * @typedef {import("../token/PendingAirdropId.js").default} PendingAirdropId
 */
export default class AirdropPendingTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {PendingAirdropId[]} [props.pendingAirdropIds]
     */
    constructor(props) {
        /**
         * @private
         * @type {PendingAirdropId[]}
         */
        super();

        /**
         * @private
         * @type {PendingAirdropId[]}
         */
        this._pendingAirdropIds = [];

        if (props?.pendingAirdropIds != null) {
            this._pendingAirdropIds = props.pendingAirdropIds;
        }
    }

    /**
     * @returns {PendingAirdropId[]}
     */
    get pendingAirdropIds() {
        return this._pendingAirdropIds;
    }

    /**
     *
     * @param {PendingAirdropId} pendingAirdropId
     * @returns {this}
     */
    addPendingAirdropId(pendingAirdropId) {
        this._requireNotFrozen();
        this._pendingAirdropIds.push(pendingAirdropId);
        return this;
    }

    /**
     *
     * @param {PendingAirdropId[]} pendingAirdropIds
     * @returns {this}
     */
    setPendingAirdropIds(pendingAirdropIds) {
        this._requireNotFrozen();
        this._pendingAirdropIds = pendingAirdropIds;
        return this;
    }
}
// Filename: src/token/AssessedCustomFee.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IAssessedCustomFee} HieroProto.proto.IAssessedCustomFee
 */

/**
 * @typedef {object} AssessedCustomFeeJSON
 * @property {?string} feeCollectorAccountId
 * @property {?string} tokenId
 * @property {?string} amount
 * @property {string[]} payerAccountIds
 */

/**
 * Represents an assessed custom fee that has been evaluated and attached to a transaction.
 * This includes details about who collects the fee, which token the fee is paid in,
 * the amount of the fee, and which accounts are responsible for paying it.
 */
export default class AssessedCustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long | number} [props.amount]
     * @param {AccountId[]} [props.payerAccountIds]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._feeCollectorAccountId = null;

        if (props.feeCollectorAccountId != null) {
            this.setFeeCollectorAccountId(props.feeCollectorAccountId);
        }

        /**
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        /**
         * @type {?Long}
         */
        this._amount = null;

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        /**
         * @type {?AccountId[]}
         */
        this._payerAccountIds = null;

        if (props.payerAccountIds != null) {
            this.setPayerAccountIds(props.payerAccountIds);
        }
    }

    /**
     * @returns {?AccountId}
     */
    get feeCollectorAccountId() {
        return this._feeCollectorAccountId;
    }

    /**
     * @param {AccountId | string} feeCollectorAccountId
     * @returns {this}
     */
    setFeeCollectorAccountId(feeCollectorAccountId) {
        this._feeCollectorAccountId =
            typeof feeCollectorAccountId === "string"
                ? AccountId.fromString(feeCollectorAccountId)
                : feeCollectorAccountId;
        return this;
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._tokenId =
            typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {AssessedCustomFee}
     */
    setAmount(amount) {
        this._amount =
            typeof amount === "number" ? Long.fromNumber(amount) : amount;
        return this;
    }

    /**
     * @returns {?AccountId[]}
     */
    get payerAccountIds() {
        return this._payerAccountIds;
    }

    /**
     * @param {AccountId[]} payerAccountIds
     * @returns {AssessedCustomFee}
     */
    setPayerAccountIds(payerAccountIds) {
        this._payerAccountIds = payerAccountIds;
        return this;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IAssessedCustomFee} fee
     * @returns {AssessedCustomFee}
     */
    static _fromProtobuf(fee) {
        return new AssessedCustomFee({
            feeCollectorAccountId:
                fee.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(fee.feeCollectorAccountId)
                    : undefined,
            tokenId:
                fee.tokenId != null
                    ? TokenId._fromProtobuf(fee.tokenId)
                    : undefined,
            amount: fee.amount != null ? fee.amount : undefined,
            payerAccountIds:
                fee.effectivePayerAccountId != null
                    ? fee.effectivePayerAccountId.map((id) =>
                          AccountId._fromProtobuf(id),
                      )
                    : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.IAssessedCustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            amount: this._amount,
            effectivePayerAccountId:
                this._payerAccountIds != null
                    ? this._payerAccountIds.map((id) => id._toProtobuf())
                    : null,
        };
    }

    /**
     * @returns {AssessedCustomFeeJSON}
     */
    toJSON() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId?.toString() || null,
            tokenId: this._tokenId?.toString() || null,
            amount: this._amount?.toString() || null,
            payerAccountIds:
                this._payerAccountIds?.map((id) => id.toString()) || [],
        };
    }
}
// Filename: src/token/CustomFee.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
 */

export default class CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {boolean} [props.allCollectorsAreExempt]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._feeCollectorAccountId = null;

        this._allCollectorsAreExempt = false;

        if (props.feeCollectorAccountId != null) {
            this.setFeeCollectorAccountId(props.feeCollectorAccountId);
        }

        if (props.allCollectorsAreExempt != null) {
            this.setAllCollectorsAreExempt(props.allCollectorsAreExempt);
        }
    }

    /**
     * @returns {?AccountId}
     */
    get feeCollectorAccountId() {
        return this._feeCollectorAccountId;
    }

    /**
     * @param {AccountId | string} feeCollectorAccountId
     * @returns {this}
     */
    setFeeCollectorAccountId(feeCollectorAccountId) {
        this._feeCollectorAccountId =
            typeof feeCollectorAccountId === "string"
                ? AccountId.fromString(feeCollectorAccountId)
                : feeCollectorAccountId;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get allCollectorsAreExempt() {
        return this._allCollectorsAreExempt;
    }

    /**
     * @param {boolean} allCollectorsAreExempt
     * @returns {this}
     */
    setAllCollectorsAreExempt(allCollectorsAreExempt) {
        this._allCollectorsAreExempt = allCollectorsAreExempt;
        return this;
    }

    /**
     * @internal
     * @abstract
     * @param {HieroProto.proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        throw new Error("not implemented");
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.ICustomFee}
     */
    _toProtobuf() {
        throw new Error("not implemented");
    }
}
// Filename: src/token/CustomFixedFee.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import CustomFee from "./CustomFee.js";
import AccountId from "../account/AccountId.js";
import Long from "long";
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
 * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
 * @typedef {import("@hashgraph/proto").proto.IFixedCustomFee} HieroProto.proto.IFixedCustomFee
 */

export default class CustomFixedFee extends CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {boolean} [props.allCollectorsAreExempt]
     * @param {TokenId | string} [props.denominatingTokenId]
     * @param {Long | number} [props.amount]
     */
    constructor(props = {}) {
        super(props);

        /**
         * @type {?TokenId}
         */
        this._denominatingTokenId = null;

        if (props.denominatingTokenId != null) {
            this.setDenominatingTokenId(props.denominatingTokenId);
        }

        /**
         * @type {?Long}
         */
        this._amount = null;

        if (props.amount != null) {
            this.setAmount(props.amount);
        }
    }

    /**
     * @param {Hbar} amount
     * @returns {CustomFixedFee}
     */
    setHbarAmount(amount) {
        this._amount = amount.toTinybars();
        this._denominatingTokenId = null;
        return this;
    }

    /**
     * @returns {TokenId | Hbar | null}
     */
    get hbarAmount() {
        return this._denominatingTokenId != null
            ? null
            : Hbar.fromTinybars(this._amount != null ? this._amount : 0);
    }

    /**
     * @returns {CustomFixedFee}
     */
    setDenominatingTokenToSameToken() {
        this._denominatingTokenId = new TokenId(0, 0, 0);
        return this;
    }

    /**
     * @returns {?TokenId}
     */
    get denominatingTokenId() {
        return this._denominatingTokenId;
    }

    /**
     * @param {TokenId | string} denominatingTokenId
     * @returns {CustomFixedFee}
     */
    setDenominatingTokenId(denominatingTokenId) {
        this._denominatingTokenId =
            typeof denominatingTokenId === "string"
                ? TokenId.fromString(denominatingTokenId)
                : denominatingTokenId;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {CustomFixedFee}
     */
    setAmount(amount) {
        this._amount =
            typeof amount === "number" ? Long.fromNumber(amount) : amount;
        return this;
    }

    /**
     * @internal
     * @override
     * @param {HieroProto.proto.ICustomFee} info
     * @returns {CustomFixedFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        const fee = /** @type {HieroProto.proto.IFixedFee} */ (info.fixedFee);

        return new CustomFixedFee({
            feeCollectorAccountId:
                info.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                    : undefined,
            allCollectorsAreExempt:
                info.allCollectorsAreExempt != null
                    ? info.allCollectorsAreExempt
                    : undefined,
            denominatingTokenId:
                fee.denominatingTokenId != null
                    ? TokenId._fromProtobuf(fee.denominatingTokenId)
                    : undefined,
            amount: fee.amount != null ? fee.amount : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.ICustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            allCollectorsAreExempt: this.allCollectorsAreExempt,
            fixedFee: {
                denominatingTokenId:
                    this._denominatingTokenId != null
                        ? this._denominatingTokenId._toProtobuf()
                        : null,
                amount: this._amount,
            },
        };
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.IFixedCustomFee}
     */
    _toTopicFeeProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            fixedFee: {
                denominatingTokenId:
                    this._denominatingTokenId != null
                        ? this._denominatingTokenId._toProtobuf()
                        : null,
                amount: this._amount,
            },
        };
    }
}
// Filename: src/token/CustomFractionalFee.js
// SPDX-License-Identifier: Apache-2.0

import CustomFee from "./CustomFee.js";
import AccountId from "../account/AccountId.js";
import FeeAssessmentMethod from "./FeeAssessmentMethod.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
 * @typedef {import("@hashgraph/proto").proto.IFractionalFee} HieroProto.proto.IFractionalFee
 * @typedef {import("@hashgraph/proto").proto.IFraction} HieroProto.proto.IFraction
 */

export default class CustomFractionalFee extends CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {boolean} [props.allCollectorsAreExempt]
     * @param {Long | number} [props.numerator]
     * @param {Long | number} [props.denominator]
     * @param {Long | number} [props.min]
     * @param {Long | number} [props.max]
     * @param {FeeAssessmentMethod} [props.assessmentMethod]
     */
    constructor(props = {}) {
        super(props);

        /**
         * @type {?Long}
         */
        this._numerator = null;

        if (props.numerator != null) {
            this.setNumerator(props.numerator);
        }

        /**
         * @type {?Long}
         */
        this._denominator = null;

        if (props.denominator != null) {
            this.setDenominator(props.denominator);
        }

        /**
         * @type {?Long}
         */
        this._min = null;

        if (props.min != null) {
            this.setMin(props.min);
        }

        /**
         * @type {?Long}
         */
        this._max;

        if (props.max != null) {
            this.setMax(props.max);
        }

        /**
         * @type {?FeeAssessmentMethod}
         */
        this._assessmentMethod;

        if (props.assessmentMethod != null) {
            this.setAssessmentMethod(props.assessmentMethod);
        }
    }

    /**
     * @returns {?Long}
     */
    get numerator() {
        return this._numerator;
    }

    /**
     * @param {Long | number} numerator
     * @returns {CustomFractionalFee}
     */
    setNumerator(numerator) {
        this._numerator =
            typeof numerator === "number"
                ? Long.fromNumber(numerator)
                : numerator;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get denominator() {
        return this._denominator;
    }

    /**
     * @param {Long | number} denominator
     * @returns {CustomFractionalFee}
     */
    setDenominator(denominator) {
        this._denominator =
            typeof denominator === "number"
                ? Long.fromNumber(denominator)
                : denominator;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get min() {
        return this._min;
    }

    /**
     * @param {Long | number} min
     * @returns {CustomFractionalFee}
     */
    setMin(min) {
        this._min = typeof min === "number" ? Long.fromNumber(min) : min;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get max() {
        return this._max;
    }

    /**
     * @param {Long | number} max
     * @returns {CustomFractionalFee}
     */
    setMax(max) {
        this._max = typeof max === "number" ? Long.fromNumber(max) : max;
        return this;
    }

    /**
     * @returns {?FeeAssessmentMethod}
     */
    get assessmentMethod() {
        return this._assessmentMethod;
    }

    /**
     * @param {FeeAssessmentMethod} assessmentMethod
     * @returns {CustomFractionalFee}
     */
    setAssessmentMethod(assessmentMethod) {
        this._assessmentMethod = assessmentMethod;
        return this;
    }

    /**
     * @internal
     * @override
     * @param {HieroProto.proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        const fee = /** @type {HieroProto.proto.IFractionalFee} */ (
            info.fractionalFee
        );
        const fractional = /** @type {HieroProto.proto.IFraction} */ (
            fee.fractionalAmount
        );

        return new CustomFractionalFee({
            feeCollectorAccountId:
                info.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                    : undefined,
            allCollectorsAreExempt:
                info.allCollectorsAreExempt != null
                    ? info.allCollectorsAreExempt
                    : undefined,
            numerator:
                fractional.numerator != null ? fractional.numerator : undefined,
            denominator:
                fractional.denominator != null
                    ? fractional.denominator
                    : undefined,
            min: fee.minimumAmount != null ? fee.minimumAmount : undefined,
            max: fee.maximumAmount != null ? fee.maximumAmount : undefined,
            assessmentMethod:
                fee.netOfTransfers != null
                    ? new FeeAssessmentMethod(fee.netOfTransfers)
                    : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.ICustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            allCollectorsAreExempt: this.allCollectorsAreExempt,
            fractionalFee: {
                fractionalAmount: {
                    numerator: this._numerator,
                    denominator: this._denominator,
                },
                minimumAmount: this._min,
                maximumAmount: this._max,
                netOfTransfers:
                    this._assessmentMethod != null
                        ? this._assessmentMethod.valueOf()
                        : false,
            },
        };
    }
}
// Filename: src/token/CustomRoyaltyFee.js
// SPDX-License-Identifier: Apache-2.0

import CustomFee from "./CustomFee.js";
import AccountId from "../account/AccountId.js";
import Long from "long";
import CustomFixedFee from "./CustomFixedFee.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IFraction} HieroProto.proto.IFraction
 * @typedef {import("@hashgraph/proto").proto.IRoyaltyFee} HieroProto.proto.IRoyaltyFee
 * @typedef {import("@hashgraph/proto").proto.ICustomFee} HieroProto.proto.ICustomFee
 * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
 */

export default class CustomRoyalyFee extends CustomFee {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.feeCollectorAccountId]
     * @param {boolean} [props.allCollectorsAreExempt]
     * @param {Long | number} [props.numerator]
     * @param {Long | number} [props.denominator]
     * @param {CustomFixedFee} [props.fallbackFee]
     */
    constructor(props = {}) {
        super(props);

        /**
         * @type {?CustomFixedFee}
         */
        this._fallbackFee = null;

        if (props.fallbackFee != null) {
            this.setFallbackFee(props.fallbackFee);
        }

        /**
         * @type {?Long}
         */
        this._numerator = null;

        if (props.numerator != null) {
            this.setNumerator(props.numerator);
        }

        /**
         * @type {?Long}
         */
        this._denominator = null;

        if (props.denominator != null) {
            this.setDenominator(props.denominator);
        }
    }

    /**
     * @returns {?CustomFixedFee}
     */
    get fallbackFee() {
        return this._fallbackFee;
    }

    /**
     * @param {CustomFixedFee} fallbackFee
     * @returns {CustomRoyalyFee}
     */
    setFallbackFee(fallbackFee) {
        this._fallbackFee = fallbackFee;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get numerator() {
        return this._numerator;
    }

    /**
     * @param {Long | number} numerator
     * @returns {CustomRoyalyFee}
     */
    setNumerator(numerator) {
        this._numerator =
            typeof numerator === "number"
                ? Long.fromNumber(numerator)
                : numerator;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get denominator() {
        return this._denominator;
    }

    /**
     * @param {Long | number} denominator
     * @returns {CustomRoyalyFee}
     */
    setDenominator(denominator) {
        this._denominator =
            typeof denominator === "number"
                ? Long.fromNumber(denominator)
                : denominator;
        return this;
    }

    /**
     * @internal
     * @override
     * @param {HieroProto.proto.ICustomFee} info
     * @returns {CustomFee}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(info) {
        const fee = /** @type {HieroProto.proto.IRoyaltyFee} */ (
            info.royaltyFee
        );
        const fraction = /** @type {HieroProto.proto.IFraction} */ (
            fee.exchangeValueFraction
        );

        return new CustomRoyalyFee({
            feeCollectorAccountId:
                info.feeCollectorAccountId != null
                    ? AccountId._fromProtobuf(info.feeCollectorAccountId)
                    : undefined,
            allCollectorsAreExempt:
                info.allCollectorsAreExempt != null
                    ? info.allCollectorsAreExempt
                    : undefined,
            fallbackFee:
                fee.fallbackFee != null
                    ? /** @type {CustomFixedFee} */ (
                          CustomFixedFee._fromProtobuf({
                              fixedFee: fee.fallbackFee,
                          })
                      )
                    : undefined,
            numerator:
                fraction.numerator != null ? fraction.numerator : undefined,
            denominator:
                fraction.denominator != null ? fraction.denominator : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.ICustomFee}
     */
    _toProtobuf() {
        return {
            feeCollectorAccountId:
                this.feeCollectorAccountId != null
                    ? this.feeCollectorAccountId._toProtobuf()
                    : null,
            allCollectorsAreExempt: this.allCollectorsAreExempt,
            royaltyFee: {
                exchangeValueFraction: {
                    numerator: this._numerator,
                    denominator: this._denominator,
                },
                fallbackFee:
                    this._fallbackFee != null
                        ? this._fallbackFee._toProtobuf().fixedFee
                        : null,
            },
        };
    }
}
// Filename: src/token/FeeAssessmentMethod.js
// SPDX-License-Identifier: Apache-2.0

export default class FeeAssessmentMethod {
    /**
     * @hideconstructor
     * @internal
     * @param {boolean} value
     */
    constructor(value) {
        /** @readonly */
        this._value = value;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case FeeAssessmentMethod.Inclusive:
                return "INCLUSIVE";
            case FeeAssessmentMethod.Exclusive:
                return "EXCLUSIVE";
            default:
                return `UNKNOWN (${this._value.toString()})`;
        }
    }

    /**
     * @internal
     * @param {boolean} value
     * @returns {FeeAssessmentMethod}
     */
    static _fromValue(value) {
        switch (value) {
            case false:
                return FeeAssessmentMethod.Inclusive;
            case true:
                return FeeAssessmentMethod.Exclusive;
        }
    }

    /**
     * @returns {boolean}
     */
    valueOf() {
        return this._value;
    }
}

FeeAssessmentMethod.Inclusive = new FeeAssessmentMethod(false);
FeeAssessmentMethod.Exclusive = new FeeAssessmentMethod(true);
// Filename: src/token/NftId.js
// SPDX-License-Identifier: Apache-2.0

import * as HieroProto from "@hashgraph/proto";
import TokenId from "../token/TokenId.js";
import Long from "long";

/**
 * The ID for a crypto-currency token on Hedera.
 *
 * @augments {EntityId<HieroProto.proto.INftID>}
 */
export default class NftId {
    /**
     * @param {TokenId} token
     * @param {number | Long} serial
     */
    constructor(token, serial) {
        this.tokenId = token;
        this.serial =
            typeof serial === "number" ? Long.fromNumber(serial) : serial;

        Object.freeze(this);
    }

    /**
     * @param {string} text
     * @returns {NftId}
     */
    static fromString(text) {
        const strings =
            text.split("/").length > 1 ? text.split("/") : text.split("@");

        for (const string of strings) {
            if (string === "") {
                throw new Error(
                    "invalid format for NftId: use [token]/[serial] or [token]@[serial]",
                );
            }
        }

        const token = TokenId.fromString(strings[0]);
        const serial = Long.fromString(strings[1]);

        return new NftId(token, serial);
    }

    /**
     * @internal
     * @param {HieroProto.proto.INftID} id
     * @returns {NftId}
     */
    static _fromProtobuf(id) {
        return new NftId(
            TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (id.token_ID),
            ),
            id.serialNumber != null ? id.serialNumber : Long.ZERO,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {NftId}
     */
    static fromBytes(bytes) {
        return NftId._fromProtobuf(HieroProto.proto.NftID.decode(bytes));
    }

    /**
     * @internal
     * @returns {HieroProto.proto.INftID}
     */
    _toProtobuf() {
        return {
            token_ID: this.tokenId._toProtobuf(),
            serialNumber: Long.fromValue(
                this.serial !== undefined ? this.serial : 0,
            ),
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.tokenId.toString()}/${this.serial.toString()}`;
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.NftID.encode(this._toProtobuf()).finish();
    }
}
// Filename: src/token/PendingAirdropId.js
// SPDX-License-Identifier: Apache-2.0
/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.PendingAirdropId} HieroProto.proto.PendingAirdropId
 */

import AccountId from "../account/AccountId.js";
import TokenId from "./TokenId.js";
import NftId from "./NftId.js";

/**
 * Represents the identifier for a pending airdrop in the Hedera network.
 *
 * A PendingAirdropId contains information about a pending token or NFT airdrop,
 * including the sender, receiver, and the token or NFT being airdropped. This class
 * is used to track and identify specific airdrops in the system.
 */
export default class PendingAirdropId {
    /**
     *
     * @param {object} props
     * @param {AccountId} [props.senderId]
     * @param {AccountId} [props.receiverId]
     * @param {TokenId?} [props.tokenId]
     * @param {NftId?} [props.nftId]
     */
    constructor(props = {}) {
        this._senderId = null;
        this._receiverId = null;
        this._tokenId = null;
        this._nftId = null;

        if (props.receiverId) {
            this._receiverId = props.receiverId;
        }
        if (props.senderId) {
            this._senderId = props.senderId;
        }
        if (props.tokenId) {
            this._tokenId = new TokenId(props.tokenId);
        } else if (props.nftId) {
            this._nftId = new NftId(props.nftId?.tokenId, props.nftId?.serial);
        }
    }

    /**
     * @param {HieroProto.proto.PendingAirdropId} pb
     * @returns {PendingAirdropId}
     */
    static fromBytes(pb) {
        if (pb.senderId == null) {
            throw new Error("senderId is required");
        }

        if (pb.receiverId == null) {
            throw new Error("receiverId is required");
        }

        if (pb.fungibleTokenType == null && pb.nonFungibleToken == null) {
            throw new Error(
                "Either fungibleTokenType or nonFungibleToken is required",
            );
        }

        return new PendingAirdropId({
            senderId: AccountId._fromProtobuf(pb.senderId),
            receiverId: AccountId._fromProtobuf(pb.receiverId),
            nftId:
                pb.nonFungibleToken != null
                    ? NftId._fromProtobuf(pb.nonFungibleToken)
                    : null,
            tokenId:
                pb.fungibleTokenType != null
                    ? TokenId._fromProtobuf(pb.fungibleTokenType)
                    : null,
        });
    }

    /**
     *
     * @param {AccountId} senderId
     * @returns {this}
     */
    setSenderid(senderId) {
        this._senderId = senderId;
        return this;
    }

    /**
     * @param {AccountId} receiverId
     * @returns {this}
     */
    setReceiverId(receiverId) {
        this._receiverId = receiverId;
        return this;
    }

    /**
     * @param {TokenId} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._nftId = null;
        this._tokenId = tokenId;
        return this;
    }

    /**
     * @param {NftId} nftId
     * @returns {this}
     */
    setNftId(nftId) {
        this._tokenId = null;
        this._nftId = nftId;
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get senderId() {
        return this._senderId;
    }

    /**
     * @returns {?AccountId}
     */
    get receiverId() {
        return this._receiverId;
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @returns {?NftId}
     */
    get nftId() {
        return this._nftId;
    }

    /**
     *  @returns {HieroProto.proto.PendingAirdropId}
     */
    toBytes() {
        return {
            senderId: this.senderId?._toProtobuf(),
            receiverId: this._receiverId?._toProtobuf(),
            fungibleTokenType: this._tokenId?._toProtobuf(),
            nonFungibleToken: this._nftId?._toProtobuf(),
        };
    }
}
// Filename: src/token/PendingAirdropRecord.js
// SPDX-License-Identifier: Apache-2.0
/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.PendingAirdropRecord} HieroProto.proto.PendingAirdropRecord
 */

import Long from "long";
import PendingAirdropId from "./PendingAirdropId.js";

export default class PendingAirdropRecord {
    /**
     * @param {object} props
     * @param {PendingAirdropId} props.airdropId
     * @param {Long} props.amount
     */
    constructor(props) {
        this.airdropId = props.airdropId;
        this.amount = props.amount;
    }

    /**
     * @returns {HieroProto.proto.PendingAirdropRecord}
     */
    toBytes() {
        return {
            pendingAirdropId: this.airdropId.toBytes(),
            pendingAirdropValue: {
                amount: this.amount,
            },
        };
    }

    /**
     * @param {HieroProto.proto.PendingAirdropRecord} pb
     * @returns {PendingAirdropRecord}
     */
    static fromBytes(pb) {
        if (pb.pendingAirdropId == null) {
            throw new Error("pendingAirdropId is required");
        }

        const airdropId = PendingAirdropId.fromBytes(pb.pendingAirdropId);
        const amount = pb.pendingAirdropValue?.amount;

        return new PendingAirdropRecord({
            airdropId: airdropId,
            amount: amount ? amount : Long.ZERO,
        });
    }
}
// Filename: src/token/TokenAirdropTransaction.js
// SPDX-License-Identifier: Apache-2.0
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import TokenTransfer from "./TokenTransfer.js";
import NftTransfer from "./TokenNftTransfer.js";
import AbstractTokenTransferTransaction from "./AbstractTokenTransferTransaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenAirdropTransactionBody} HieroProto.proto.ITokenAirdropTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionID} HieroProto.proto.TransactionID
 * @typedef {import("@hashgraph/proto").proto.AccountID} HieroProto.proto.AccountID
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("./NftId.js").default} NftId
 * @typedef {import("./TokenId.js").default} TokenId
 */

/**
 * Airdrop one or more tokens to one or more accounts.
 *
 * ### Effects
 * This distributes tokens from the balance of one or more sending account(s)
 * to the balance of one or more recipient accounts. Accounts MAY receive the
 * tokens in one of four ways.
 *
 *  - An account already associated to the token to be distributed SHALL
 *    receive the airdropped tokens immediately to the recipient account
 *    balance.<br/>
 *    The fee for this transfer SHALL include the transfer, the airdrop fee,
 *    and any custom fees.
 *  - An account with available automatic association slots SHALL be
 *    automatically associated to the token, and SHALL immediately receive
 *    the airdropped tokens to the recipient account balance.<br/>
 *    The fee for this transfer SHALL include the transfer, the association,
 *    the cost to renew that association once, the airdrop fee, and
 *    any custom fees.
 *  - An account with "receiver signature required" set SHALL have a
 *    "Pending Airdrop" created and must claim that airdrop with a
 *    `claimAirdrop` transaction.<br/>
 *    The fee for this transfer SHALL include the transfer, the association,
 *    the cost to renew that association once, the airdrop fee, and
 *    any custom fees.<br/>
 *    If the pending airdrop is not claimed immediately, the `sender` SHALL
 *    pay the cost to renew the token association, and the cost to maintain
 *    the pending airdrop, until the pending airdrop is claimed or cancelled.
 *  - An account with no available automatic association slots SHALL have a
 *    "Pending Airdrop" created and must claim that airdrop with a
 *    `claimAirdrop` transaction.<br/>
 *    The fee for this transfer SHALL include the transfer, the association,
 *    the cost to renew that association once, the airdrop fee, and any custom
 *    fees.<br/>
 *    If the pending airdrop is not claimed immediately, the `sender` SHALL
 *    pay the cost to renew the token association, and the cost to maintain
 *    the pending airdrop, until the pending airdrop is claimed or cancelled.
 *
 * If an airdrop would create a pending airdrop for a fungible/common token,
 * and a pending airdrop for the same sender, receiver, and token already
 * exists, the existing pending airdrop SHALL be updated to add the new
 * amount to the existing airdrop, rather than creating
 * a new pending airdrop.<br/>
 * Any airdrop that completes immediately SHALL be irreversible. Any airdrop
 * that results in a "Pending Airdrop" MAY be canceled via a `cancelAirdrop`
 * transaction.<br/>
 * All transfer fees (including custom fees and royalties), as well as the
 * rent cost for the first auto-renewal period for any automatic-association
 * slot occupied by the airdropped tokens, SHALL be charged to the account
 * paying for this transaction.<br/>
 */
export default class TokenAirdropTransaction extends AbstractTokenTransferTransaction {
    /**
     * @param {object} props
     * @param {TokenTransfer[]} [props.tokenTransfers]
     * @param {NftTransfer[]} [props.nftTransfers]
     */
    constructor(props = {}) {
        super();

        if (props.tokenTransfers != null) {
            for (const tokenTransfer of props.tokenTransfers) {
                this._addTokenTransfer(
                    tokenTransfer.tokenId,
                    tokenTransfer.accountId,
                    tokenTransfer.amount,
                    tokenTransfer.isApproved,
                    tokenTransfer.expectedDecimals,
                );
            }
        }
        /**
         * @private
         * @type {NftTransfer[]}
         */
        this._nftTransfers = [];
        if (props.nftTransfers != null) {
            for (const nftTransfer of props.nftTransfers) {
                this._addNftTransfer(
                    nftTransfer.isApproved,
                    nftTransfer.tokenId,
                    nftTransfer.serialNumber,
                    nftTransfer.senderAccountId,
                    nftTransfer.receiverAccountId,
                );
            }
        }
    }

    /**
     *
     * @param {TokenId} tokenId
     * @param {AccountId} accountId
     * @param {Long} amount
     * @param {number} expectedDecimals
     * @returns {this}
     */
    addApprovedTokenTransferWithDecimals(
        tokenId,
        accountId,
        amount,
        expectedDecimals,
    ) {
        this._requireNotFrozen();
        this._addTokenTransfer(
            tokenId,
            accountId,
            amount,
            true,
            expectedDecimals,
        );
        return this;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenAirdropTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const tokenAirdrop =
            /** @type {HieroProto.proto.ITokenAirdropTransactionBody} */ (
                body.tokenAirdrop
            );

        const tokenTransfers = TokenTransfer._fromProtobuf(
            tokenAirdrop.tokenTransfers ?? [],
        );
        const nftTransfers = NftTransfer._fromProtobuf(
            tokenAirdrop.tokenTransfers ?? [],
        );

        return Transaction._fromProtobufTransactions(
            new TokenAirdropTransaction({
                nftTransfers: nftTransfers,
                tokenTransfers: tokenTransfers,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.airdropTokens(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenAirdrop";
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenAirdropTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenAirdrop",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenAirdropTransaction._fromProtobuf,
);
// Filename: src/token/TokenAssociateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenAssociateTransactionBody} HieroProto.proto.ITokenAssociateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Associate a new Hedera™ crypto-currency token.
 */
export default class TokenAssociateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {(TokenId | string)[]} [props.tokenIds]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId[]}
         */
        this._tokenIds = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.tokenIds != null) {
            this.setTokenIds(props.tokenIds);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenAssociateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const associateToken =
            /** @type {HieroProto.proto.ITokenAssociateTransactionBody} */ (
                body.tokenAssociate
            );

        return Transaction._fromProtobufTransactions(
            new TokenAssociateTransaction({
                tokenIds:
                    associateToken.tokens != null
                        ? associateToken.tokens.map((token) =>
                              TokenId._fromProtobuf(token),
                          )
                        : undefined,
                accountId:
                    associateToken.account != null
                        ? AccountId._fromProtobuf(associateToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId[]}
     */
    get tokenIds() {
        return this._tokenIds;
    }

    /**
     * @param {(TokenId | string)[]} tokenIds
     * @returns {this}
     */
    setTokenIds(tokenIds) {
        this._requireNotFrozen();
        this._tokenIds = tokenIds.map((tokenId) =>
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone(),
        );

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
            if (tokenId != null) {
                tokenId.validateChecksum(client);
            }
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.associateTokens(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenAssociate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenAssociateTransactionBody}
     */
    _makeTransactionData() {
        return {
            tokens:
                this._tokenIds != null
                    ? this._tokenIds.map((tokenId) => tokenId._toProtobuf())
                    : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenAssociateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenAssociate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenAssociateTransaction._fromProtobuf,
);
// Filename: src/token/TokenAssociation.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import TokenId from "../token/TokenId.js";
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenAssociation} HieroProto.proto.ITokenAssociation
 */

/**
 * @typedef {object} TokenAssociationJSON
 * @property {?string} accountId
 * @property {?string} tokenId
 */

export default class TokenAssociation {
    /**
     * @param {object} props
     * @param {AccountId | string} [props.accountId]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        this._defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId;
        return this;
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._tokenId =
            typeof tokenId === "string" ? TokenId.fromString(tokenId) : tokenId;
        return this;
    }

    /**
     * @internal
     * @abstract
     * @param {HieroProto.proto.ITokenAssociation} association
     * @returns {TokenAssociation}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _fromProtobuf(association) {
        return new TokenAssociation({
            accountId:
                association.accountId != null
                    ? AccountId._fromProtobuf(association.accountId)
                    : undefined,
            tokenId:
                association.tokenId != null
                    ? TokenId._fromProtobuf(association.tokenId)
                    : undefined,
        });
    }

    /**
     * @internal
     * @abstract
     * @returns {HieroProto.proto.ITokenAssociation}
     */
    _toProtobuf() {
        return {
            accountId:
                this._accountId != null
                    ? this._accountId._toProtobuf()
                    : undefined,
            tokenId:
                this._tokenId != null ? this._tokenId._toProtobuf() : undefined,
        };
    }

    /**
     * @returns {TokenAssociationJSON}
     */
    toJSON() {
        return {
            accountId: this._accountId?.toString() || null,
            tokenId: this._tokenId?.toString() || null,
        };
    }
}
// Filename: src/token/TokenBurnTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenBurnTransactionBody} HieroProto.proto.ITokenBurnTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Burn a new Hedera™ crypto-currency token.
 */
export default class TokenBurnTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long | number} [props.amount]
     * @param {(Long | number)[]} [props.serials]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._amount = null;

        /**
         * @private
         * @type {Long[]}
         */
        this._serials = [];

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        if (props.serials != null) {
            this.setSerials(props.serials);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenBurnTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const burnToken =
            /** @type {HieroProto.proto.ITokenBurnTransactionBody} */ (
                body.tokenBurn
            );

        return Transaction._fromProtobufTransactions(
            new TokenBurnTransaction({
                tokenId:
                    burnToken.token != null
                        ? TokenId._fromProtobuf(burnToken.token)
                        : undefined,
                amount: burnToken.amount != null ? burnToken.amount : undefined,
                serials:
                    burnToken.serialNumbers != null
                        ? burnToken.serialNumbers
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {this}
     */
    setAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof Long ? amount : Long.fromValue(amount);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @returns {Long[]}
     */
    get serials() {
        return this._serials;
    }

    /**
     * @param {(Long | number)[]} serials
     * @returns {this}
     */
    setSerials(serials) {
        this._requireNotFrozen();
        this._serials = serials.map((serial) =>
            serial instanceof Long ? serial : Long.fromValue(serial),
        );

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.burnToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenBurn";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenBurnTransactionBody}
     */
    _makeTransactionData() {
        return {
            amount: this._amount,
            serialNumbers: this._serials,
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenBurnTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenBurn",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenBurnTransaction._fromProtobuf,
);
// Filename: src/token/TokenCancelAirdropTransaction.js
// SPDX-License-Identifier: Apache-2.0
import PendingAirdropId from "../token/PendingAirdropId.js";
import { TRANSACTION_REGISTRY } from "../transaction/Transaction.js";
import Transaction from "../transaction/Transaction.js";
import AirdropPendingTransaction from "./AirdropPendingTransaction.js";

/**
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenCancelAirdropTransactionBody} HieroProto.proto.ITokenCancelAirdropTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * A transaction that allows the cancellation of pending airdrops.
 * This transaction can be used by authorized accounts to cancel airdrop operations
 * that have been initiated but not yet claimed by recipients.
 */
export default class TokenCancelAirdropTransaction extends AirdropPendingTransaction {
    /**
     * @param {object} props
     * @param {PendingAirdropId[]} [props.pendingAirdropIds]
     */
    constructor(props = {}) {
        super(props);
    }

    /**
     * @override
     * @internal
     * @returns {HieroProto.proto.ITokenCancelAirdropTransactionBody}
     */
    _makeTransactionData() {
        return {
            pendingAirdrops: this.pendingAirdropIds.map((pendingAirdropId) =>
                pendingAirdropId.toBytes(),
            ),
        };
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.cancelAirdrop(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenCancelAirdrop";
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenCancelAirdropTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const { pendingAirdrops } =
            /** @type {HieroProto.proto.ITokenCancelAirdropTransactionBody} */ (
                body.tokenCancelAirdrop
            );

        return Transaction._fromProtobufTransactions(
            new TokenCancelAirdropTransaction({
                pendingAirdropIds: pendingAirdrops?.map((pendingAirdrop) => {
                    return PendingAirdropId.fromBytes(pendingAirdrop);
                }),
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenCancelAirdrop:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenCancelAirdrop",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenCancelAirdropTransaction._fromProtobuf,
);
// Filename: src/token/TokenClaimAirdropTransaction.js
// SPDX-License-Identifier: Apache-2.0
import PendingAirdropId from "../token/PendingAirdropId.js";
import AirdropPendingTransaction from "./AirdropPendingTransaction.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenClaimAirdropTransactionBody} HieroProto.proto.ITokenClaimAirdropTransactionBody
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * A transaction that allows an account to claim tokens from a pending airdrop.
 * This transaction is used to finalize the receipt of tokens that were distributed
 * through an airdrop mechanism but require explicit claiming by the recipient.
 */
export default class TokenClaimAirdropTransaction extends AirdropPendingTransaction {
    /**
     * @param {object} props
     * @param {PendingAirdropId[]} [props.pendingAirdropIds]
     */
    constructor(props = {}) {
        super(props);
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.claimAirdrop(request);
    }

    /**
     * @override
     * @internal
     * @returns {HieroProto.proto.ITokenClaimAirdropTransactionBody}
     */
    _makeTransactionData() {
        return {
            pendingAirdrops: this.pendingAirdropIds.map((pendingAirdropId) =>
                pendingAirdropId.toBytes(),
            ),
        };
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenClaimAirdropTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const { pendingAirdrops } =
            /** @type {HieroProto.proto.ITokenClaimAirdropTransactionBody} */ (
                body.tokenClaimAirdrop
            );

        return Transaction._fromProtobufTransactions(
            new TokenClaimAirdropTransaction({
                pendingAirdropIds: pendingAirdrops?.map((pendingAirdrop) => {
                    return PendingAirdropId.fromBytes(pendingAirdrop);
                }),
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenClaimAirdrop";
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenClaimAirdropTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenClaimAirdrop",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenClaimAirdropTransaction._fromProtobuf,
);
// Filename: src/token/TokenCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import Transaction, {
    DEFAULT_AUTO_RENEW_PERIOD,
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Long from "long";
import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import Duration from "../Duration.js";
import CustomFixedFee from "./CustomFixedFee.js";
import CustomFractionalFee from "./CustomFractionalFee.js";
import CustomRoyaltyFee from "./CustomRoyaltyFee.js";
import TokenType from "./TokenType.js";
import TokenSupplyType from "./TokenSupplyType.js";
import Key from "../Key.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenCreateTransactionBody} HieroProto.proto.ITokenCreateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./CustomFee.js").default} CustomFee
 */

/**
 * Create a new Hedera™ crypto-currency token.
 */
export default class TokenCreateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {string} [props.tokenName]
     * @param {string} [props.tokenSymbol]
     * @param {Long | number} [props.decimals]
     * @param {Long | number} [props.initialSupply]
     * @param {AccountId | string} [props.treasuryAccountId]
     * @param {Key} [props.adminKey]
     * @param {Key} [props.kycKey]
     * @param {Key} [props.freezeKey]
     * @param {Key} [props.pauseKey]
     * @param {Key} [props.wipeKey]
     * @param {Key} [props.supplyKey]
     * @param {Key} [props.feeScheduleKey]
     * @param {boolean} [props.freezeDefault]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {string} [props.tokenMemo]
     * @param {CustomFee[]} [props.customFees]
     * @param {TokenType} [props.tokenType]
     * @param {TokenSupplyType} [props.supplyType]
     * @param {Long | number} [props.maxSupply]
     * @param {Key} [props.metadataKey]
     * @param {Uint8Array} [props.metadata]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?string}
         */
        this._tokenName = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenSymbol = null;

        /**
         * @private
         * @type {?Long}
         */
        this._decimals = null;

        /**
         * @private
         * @type {?Long}
         */
        this._initialSupply = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._treasuryAccountId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._kycKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._freezeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._pauseKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._wipeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._supplyKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._feeScheduleKey = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._freezeDefault = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = new Timestamp(
            Math.floor(
                Date.now() / 1000 + DEFAULT_AUTO_RENEW_PERIOD.toNumber(),
            ),
            0,
        );

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {?string}
         */
        this._tokenMemo = null;

        /**
         * @private
         * @type {CustomFee[]}
         */
        this._customFees = [];

        /**
         * @private
         * @type {?TokenType}
         */
        this._tokenType = null;

        /**
         * @private
         * @type {?TokenSupplyType}
         */
        this._supplyType = null;

        /**
         * @private
         * @type {?Long}
         */
        this._maxSupply = null;

        this._defaultMaxTransactionFee = new Hbar(30);

        /**
         * @private
         * @type {?Key}
         */
        this._metadataKey = null;

        /**
         * @private
         * @description Metadata of the created token definition.
         * @type {?Uint8Array}
         */
        this._metadata = null;

        if (props.tokenName != null) {
            this.setTokenName(props.tokenName);
        }

        if (props.tokenSymbol != null) {
            this.setTokenSymbol(props.tokenSymbol);
        }

        if (props.decimals != null) {
            this.setDecimals(props.decimals);
        }

        if (props.initialSupply != null) {
            this.setInitialSupply(props.initialSupply);
        }

        if (props.treasuryAccountId != null) {
            this.setTreasuryAccountId(props.treasuryAccountId);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.kycKey != null) {
            this.setKycKey(props.kycKey);
        }

        if (props.freezeKey != null) {
            this.setFreezeKey(props.freezeKey);
        }

        if (props.pauseKey != null) {
            this.setPauseKey(props.pauseKey);
        }

        if (props.wipeKey != null) {
            this.setWipeKey(props.wipeKey);
        }

        if (props.supplyKey != null) {
            this.setSupplyKey(props.supplyKey);
        }

        if (props.feeScheduleKey != null) {
            this.setFeeScheduleKey(props.feeScheduleKey);
        }

        if (props.freezeDefault != null) {
            this.setFreezeDefault(props.freezeDefault);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.tokenMemo != null) {
            this.setTokenMemo(props.tokenMemo);
        }

        if (props.customFees != null) {
            this.setCustomFees(props.customFees);
        }

        if (props.tokenType != null) {
            this.setTokenType(props.tokenType);
        }

        if (props.supplyType != null) {
            this.setSupplyType(props.supplyType);
        }

        if (props.maxSupply != null) {
            this.setMaxSupply(props.maxSupply);
        }

        if (props.metadataKey != null) {
            this.setMetadataKey(props.metadataKey);
        }

        if (props.metadata != null) {
            this.setMetadata(props.metadata);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const create =
            /** @type {HieroProto.proto.ITokenCreateTransactionBody} */ (
                body.tokenCreation
            );

        return Transaction._fromProtobufTransactions(
            new TokenCreateTransaction({
                tokenName: create.name != null ? create.name : undefined,
                tokenSymbol: create.symbol != null ? create.symbol : undefined,
                decimals: create.decimals != null ? create.decimals : undefined,
                initialSupply:
                    create.initialSupply != null
                        ? create.initialSupply
                        : undefined,
                treasuryAccountId:
                    create.treasury != null
                        ? AccountId._fromProtobuf(create.treasury)
                        : undefined,
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                kycKey:
                    create.kycKey != null
                        ? Key._fromProtobufKey(create.kycKey)
                        : undefined,
                freezeKey:
                    create.freezeKey != null
                        ? Key._fromProtobufKey(create.freezeKey)
                        : undefined,
                pauseKey:
                    create.pauseKey != null
                        ? Key._fromProtobufKey(create.pauseKey)
                        : undefined,
                wipeKey:
                    create.wipeKey != null
                        ? Key._fromProtobufKey(create.wipeKey)
                        : undefined,
                supplyKey:
                    create.supplyKey != null
                        ? Key._fromProtobufKey(create.supplyKey)
                        : undefined,
                feeScheduleKey:
                    create.feeScheduleKey != null
                        ? Key._fromProtobufKey(create.feeScheduleKey)
                        : undefined,
                freezeDefault:
                    create.freezeDefault != null
                        ? create.freezeDefault
                        : undefined,
                autoRenewAccountId:
                    create.autoRenewAccount != null
                        ? AccountId._fromProtobuf(create.autoRenewAccount)
                        : undefined,
                expirationTime:
                    create.expiry != null
                        ? Timestamp._fromProtobuf(create.expiry)
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? Duration._fromProtobuf(create.autoRenewPeriod)
                        : undefined,
                tokenMemo: create.memo != null ? create.memo : undefined,
                customFees:
                    create.customFees != null
                        ? create.customFees.map((fee) => {
                              if (fee.fixedFee != null) {
                                  return CustomFixedFee._fromProtobuf(fee);
                              } else if (fee.fractionalFee != null) {
                                  return CustomFractionalFee._fromProtobuf(fee);
                              } else {
                                  return CustomRoyaltyFee._fromProtobuf(fee);
                              }
                          })
                        : undefined,
                tokenType:
                    create.tokenType != null
                        ? TokenType._fromCode(create.tokenType)
                        : undefined,
                supplyType:
                    create.supplyType != null
                        ? TokenSupplyType._fromCode(create.supplyType)
                        : undefined,
                maxSupply:
                    create.maxSupply != null ? create.maxSupply : undefined,
                metadataKey:
                    create.metadataKey != null
                        ? Key._fromProtobufKey(create.metadataKey)
                        : undefined,
                metadata: create.metadata != null ? create.metadata : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?string}
     */
    get tokenName() {
        return this._tokenName;
    }

    /**
     * @param {string} name
     * @returns {this}
     */
    setTokenName(name) {
        this._requireNotFrozen();
        this._tokenName = name;

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenSymbol() {
        return this._tokenSymbol;
    }

    /**
     * @param {string} symbol
     * @returns {this}
     */
    setTokenSymbol(symbol) {
        this._requireNotFrozen();
        this._tokenSymbol = symbol;

        return this;
    }

    /**
     * @returns {?Long}
     */
    get decimals() {
        return this._decimals;
    }

    /**
     * @param {Long | number} decimals
     * @returns {this}
     */
    setDecimals(decimals) {
        this._requireNotFrozen();
        this._decimals =
            decimals instanceof Long ? decimals : Long.fromValue(decimals);

        return this;
    }

    /**
     * @returns {?Long}
     */
    get initialSupply() {
        return this._initialSupply;
    }

    /**
     * @param {Long | number} initialSupply
     * @returns {this}
     */
    setInitialSupply(initialSupply) {
        this._requireNotFrozen();
        this._initialSupply = Long.fromValue(initialSupply);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get treasuryAccountId() {
        return this._treasuryAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setTreasuryAccountId(id) {
        this._requireNotFrozen();
        this._treasuryAccountId =
            typeof id === "string" ? AccountId.fromString(id) : id.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setAdminKey(key) {
        this._requireNotFrozen();
        this._adminKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get kycKey() {
        return this._kycKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setKycKey(key) {
        this._requireNotFrozen();
        this._kycKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get freezeKey() {
        return this._freezeKey;
    }

    /**
     * @override
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        if (!this._autoRenewAccountId && this.transactionId?.accountId) {
            this.setAutoRenewAccountId(this.transactionId?.accountId);
        } else if (!this._autoRenewAccountId && client?.operatorAccountId) {
            this.setAutoRenewAccountId(client.operatorAccountId);
        }
        return super.freezeWith(client);
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setFreezeKey(key) {
        this._requireNotFrozen();
        this._freezeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get pauseKey() {
        return this._pauseKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setPauseKey(key) {
        this._requireNotFrozen();
        this._pauseKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get wipeKey() {
        return this._wipeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setWipeKey(key) {
        this._requireNotFrozen();
        this._wipeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get supplyKey() {
        return this._supplyKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setSupplyKey(key) {
        this._requireNotFrozen();
        this._supplyKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get feeScheduleKey() {
        return this._feeScheduleKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setFeeScheduleKey(key) {
        this._requireNotFrozen();
        this._feeScheduleKey = key;

        return this;
    }

    /**
     * @returns {?boolean}
     */
    get freezeDefault() {
        return this._freezeDefault;
    }

    /**
     * @param {boolean} freeze
     * @returns {this}
     */
    setFreezeDefault(freeze) {
        this._requireNotFrozen();
        this._freezeDefault = freeze;

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * If autoRenewPeriod is set - this value will be ignored and the expiration time will be calculated based on the autoRenewPeriod + time.now()
     * Setting this value will clear the autoRenewPeriod as the autoRenewPeriod period has default value of 7890000 seconds and leaving it set will override the expiration time
     * @param {Timestamp | Date} time
     * @returns {this}
     */
    setExpirationTime(time) {
        this._requireNotFrozen();
        this._expirationTime =
            time instanceof Timestamp ? time : Timestamp.fromDate(time);
        this._autoRenewPeriod = null;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setAutoRenewAccountId(id) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            id instanceof AccountId ? id : AccountId.fromString(id);

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * If expirationTime is set - autoRenewPeriod will be effectively ignored and it's effect will be replaced by expirationTime
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenMemo() {
        return this._tokenMemo;
    }

    /**
     * @param {string} memo
     * @returns {this}
     */
    setTokenMemo(memo) {
        this._requireNotFrozen();
        this._tokenMemo = memo;

        return this;
    }

    /**
     * @returns {CustomFee[]}
     */
    get customFees() {
        return this._customFees;
    }

    /**
     * @param {CustomFee[]} customFees
     * @returns {this}
     */
    setCustomFees(customFees) {
        this._customFees = customFees;
        return this;
    }

    /**
     * @returns {?TokenType}
     */
    get tokenType() {
        return this._tokenType;
    }

    /**
     * @param {TokenType} tokenType
     * @returns {this}
     */
    setTokenType(tokenType) {
        this._tokenType = tokenType;
        return this;
    }

    /**
     * @returns {?TokenSupplyType}
     */
    get supplyType() {
        return this._supplyType;
    }

    /**
     * @param {TokenSupplyType} supplyType
     * @returns {this}
     */
    setSupplyType(supplyType) {
        this._supplyType = supplyType;
        return this;
    }

    /**
     * @returns {?Long}
     */
    get maxSupply() {
        return this._maxSupply;
    }

    /**
     * @param {Long | number} maxSupply
     * @returns {this}
     */
    setMaxSupply(maxSupply) {
        this._maxSupply =
            typeof maxSupply === "number"
                ? Long.fromNumber(maxSupply)
                : maxSupply;
        return this;
    }

    /**
     * @returns {?Key}
     */
    get metadataKey() {
        return this._metadataKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setMetadataKey(key) {
        this._requireNotFrozen();
        this._metadataKey = key;

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get metadata() {
        return this._metadata;
    }

    /**
     * @param {Uint8Array} metadata
     * @returns {this}
     */
    setMetadata(metadata) {
        this._requireNotFrozen();
        this._metadata = metadata;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._treasuryAccountId != null) {
            this._treasuryAccountId.validateChecksum(client);
        }

        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.createToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenCreation";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenCreateTransactionBody}
     */
    _makeTransactionData() {
        return {
            name: this._tokenName,
            symbol: this._tokenSymbol,
            decimals: this._decimals != null ? this._decimals.toInt() : null,
            initialSupply: this._initialSupply,
            treasury:
                this._treasuryAccountId != null
                    ? this._treasuryAccountId._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
            freezeKey:
                this._freezeKey != null
                    ? this._freezeKey._toProtobufKey()
                    : null,
            pauseKey:
                this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
            wipeKey:
                this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
            supplyKey:
                this._supplyKey != null
                    ? this._supplyKey._toProtobufKey()
                    : null,
            feeScheduleKey:
                this._feeScheduleKey != null
                    ? this._feeScheduleKey._toProtobufKey()
                    : null,
            freezeDefault: this._freezeDefault,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            expiry:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            memo: this._tokenMemo,
            customFees: this.customFees.map((fee) => fee._toProtobuf()),
            tokenType: this._tokenType != null ? this._tokenType._code : null,
            supplyType:
                this._supplyType != null ? this._supplyType._code : null,
            maxSupply: this.maxSupply,
            metadataKey:
                this._metadataKey != null
                    ? this._metadataKey._toProtobufKey()
                    : null,
            metadata: this._metadata != null ? this._metadata : undefined,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenCreation",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenCreateTransaction._fromProtobuf,
);
// Filename: src/token/TokenDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenDeleteTransactionBody} HieroProto.proto.ITokenDeleteTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a new Hedera™ crypto-currency token.
 */
export default class TokenDeleteTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const deleteToken =
            /** @type {HieroProto.proto.ITokenDeleteTransactionBody} */ (
                body.tokenDeletion
            );

        return Transaction._fromProtobufTransactions(
            new TokenDeleteTransaction({
                tokenId:
                    deleteToken.token != null
                        ? TokenId._fromProtobuf(deleteToken.token)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.deleteToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenDeletion";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenDeleteTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenDeletion",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenDeleteTransaction._fromProtobuf,
);
// Filename: src/token/TokenDissociateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenDissociateTransactionBody} HieroProto.proto.ITokenDissociateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Dissociate a new Hedera™ crypto-currency token.
 */
export default class TokenDissociateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {(TokenId | string)[]} [props.tokenIds]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId[]}
         */
        this._tokenIds = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        this._defaultMaxTransactionFee = new Hbar(5);

        if (props.tokenIds != null) {
            this.setTokenIds(props.tokenIds);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenDissociateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const dissociateToken =
            /** @type {HieroProto.proto.ITokenDissociateTransactionBody} */ (
                body.tokenDissociate
            );

        return Transaction._fromProtobufTransactions(
            new TokenDissociateTransaction({
                tokenIds:
                    dissociateToken.tokens != null
                        ? dissociateToken.tokens.map((token) =>
                              TokenId._fromProtobuf(token),
                          )
                        : undefined,
                accountId:
                    dissociateToken.account != null
                        ? AccountId._fromProtobuf(dissociateToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId[]}
     */
    get tokenIds() {
        return this._tokenIds;
    }

    /**
     * @param {(TokenId | string)[]} tokenIds
     * @returns {this}
     */
    setTokenIds(tokenIds) {
        this._requireNotFrozen();
        this._tokenIds = tokenIds.map((tokenId) =>
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone(),
        );

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }

        for (const tokenId of this._tokenIds != null ? this._tokenIds : []) {
            if (tokenId != null) {
                tokenId.validateChecksum(client);
            }
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.dissociateTokens(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenDissociate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenDissociateTransactionBody}
     */
    _makeTransactionData() {
        return {
            tokens:
                this._tokenIds != null
                    ? this._tokenIds.map((tokenId) => tokenId._toProtobuf())
                    : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenDissociateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenDissociate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenDissociateTransaction._fromProtobuf,
);
// Filename: src/token/TokenFeeScheduleUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import CustomFixedFee from "./CustomFixedFee.js";
import CustomFractionalFee from "./CustomFractionalFee.js";
import CustomRoyaltyFee from "./CustomRoyaltyFee.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenFeeScheduleUpdateTransactionBody} HieroProto.proto.ITokenFeeScheduleUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("./CustomFee.js").default} CustomFee
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * FeeScheduleUpdate a new Hedera™ crypto-currency token.
 */
export default class TokenFeeScheduleUpdateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {CustomFee[]} [props.customFees]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {CustomFee[]}
         */
        this._customFees = [];

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.customFees != null) {
            this.setCustomFees(props.customFees);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenFeeScheduleUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const feeScheduleUpdate =
            /** @type {HieroProto.proto.ITokenFeeScheduleUpdateTransactionBody} */ (
                body.tokenFeeScheduleUpdate
            );

        return Transaction._fromProtobufTransactions(
            new TokenFeeScheduleUpdateTransaction({
                tokenId:
                    feeScheduleUpdate.tokenId != null
                        ? TokenId._fromProtobuf(feeScheduleUpdate.tokenId)
                        : undefined,
                customFees:
                    feeScheduleUpdate.customFees != null
                        ? feeScheduleUpdate.customFees.map((fee) => {
                              if (fee.fixedFee != null) {
                                  return CustomFixedFee._fromProtobuf(fee);
                              } else if (fee.fractionalFee != null) {
                                  return CustomFractionalFee._fromProtobuf(fee);
                              } else {
                                  return CustomRoyaltyFee._fromProtobuf(fee);
                              }
                          })
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : TokenId._fromProtobuf(tokenId._toProtobuf());

        return this;
    }

    /**
     * @returns {CustomFee[]}
     */
    get customFees() {
        return this._customFees;
    }

    /**
     * @param {CustomFee[]} fees
     * @returns {this}
     */
    setCustomFees(fees) {
        this._requireNotFrozen();
        this._customFees = fees;

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.updateTokenFeeSchedule(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenFeeScheduleUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenFeeScheduleUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            tokenId: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            customFees: this._customFees.map((fee) => fee._toProtobuf()),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenFeeScheduleUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenFeeScheduleUpdate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenFeeScheduleUpdateTransaction._fromProtobuf,
);
// Filename: src/token/TokenFreezeTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenFreezeAccountTransactionBody} HieroProto.proto.ITokenFreezeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Freeze a new Hedera™ crypto-currency token.
 */
export default class TokenFreezeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenFreezeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const freezeToken =
            /** @type {HieroProto.proto.ITokenFreezeAccountTransactionBody} */ (
                body.tokenFreeze
            );

        return Transaction._fromProtobufTransactions(
            new TokenFreezeTransaction({
                tokenId:
                    freezeToken.token != null
                        ? TokenId._fromProtobuf(freezeToken.token)
                        : undefined,
                accountId:
                    freezeToken.account != null
                        ? AccountId._fromProtobuf(freezeToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.freezeTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenFreeze";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenFreezeAccountTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenFreezeTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenFreeze",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenFreezeTransaction._fromProtobuf,
);
// Filename: src/token/TokenGrantKycTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenGrantKycTransactionBody} HieroProto.proto.ITokenGrantKycTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * GrantKyc a new Hedera™ crypto-currency token.
 */
export default class TokenGrantKycTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenGrantKycTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const grantKycToken =
            /** @type {HieroProto.proto.ITokenGrantKycTransactionBody} */ (
                body.tokenGrantKyc
            );

        return Transaction._fromProtobufTransactions(
            new TokenGrantKycTransaction({
                tokenId:
                    grantKycToken.token != null
                        ? TokenId._fromProtobuf(grantKycToken.token)
                        : undefined,
                accountId:
                    grantKycToken.account != null
                        ? AccountId._fromProtobuf(grantKycToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.grantKycToTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenGrantKyc";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenGrantKycTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenGrantKycTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenGrantKyc",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenGrantKycTransaction._fromProtobuf,
);
// Filename: src/token/TokenId.js
// SPDX-License-Identifier: Apache-2.0

import * as entity_id from "../EntityIdHelper.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("long")} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * The ID for a crypto-currency token on Hedera.
 */
export default class TokenId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = entity_id.constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {TokenId}
     */
    static fromString(text) {
        const result = entity_id.fromString(text);
        const id = new TokenId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITokenID} id
     * @returns {TokenId}
     */
    static _fromProtobuf(id) {
        const tokenId = new TokenId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.tokenNum != null ? id.tokenNum : 0,
        );

        return tokenId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        entity_id.validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TokenId}
     */
    static fromBytes(bytes) {
        return TokenId._fromProtobuf(HieroProto.proto.TokenID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {TokenId}
     */
    static fromSolidityAddress(address) {
        return new TokenId(...entity_id.fromSolidityAddress(address));
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITokenID}
     */
    _toProtobuf() {
        return {
            tokenNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return entity_id.toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TokenID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {TokenId}
     */
    clone() {
        const id = new TokenId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {TokenId} other
     * @returns {number}
     */
    compare(other) {
        return entity_id.compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num],
        );
    }
}
// Filename: src/token/TokenInfo.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Duration from "../Duration.js";
import Timestamp from "../Timestamp.js";
import Long from "long";
import * as HieroProto from "@hashgraph/proto";
import TokenType from "./TokenType.js";
import TokenSupplyType from "./TokenSupplyType.js";
import CustomFixedFee from "./CustomFixedFee.js";
import CustomFractionalFee from "./CustomFractionalFee.js";
import CustomRoyaltyFee from "./CustomRoyaltyFee.js";
import Key from "../Key.js";
import LedgerId from "../LedgerId.js";

/**
 * @typedef {import("./CustomFee.js").default} CustomFee
 */

/**
 * Response when the client sends the node TokenGetInfoQuery.
 */
export default class TokenInfo {
    /**
     * @private
     * @param {object} props
     * @param {TokenId} props.tokenId;
     * @param {string} props.name;
     * @param {string} props.symbol;
     * @param {number} props.decimals;
     * @param {Long} props.totalSupply;
     * @param {AccountId | null} props.treasuryAccountId;
     * @param {Key | null} props.adminKey;
     * @param {Key | null} props.kycKey;
     * @param {Key | null} props.freezeKey;
     * @param {Key | null} props.pauseKey;
     * @param {Key | null} props.wipeKey;
     * @param {Key | null} props.supplyKey;
     * @param {Key | null} props.feeScheduleKey;
     * @param {boolean | null} props.defaultFreezeStatus;
     * @param {boolean | null} props.defaultKycStatus;
     * @param {boolean | null} props.pauseStatus;
     * @param {boolean} props.isDeleted;
     * @param {AccountId | null} props.autoRenewAccountId;
     * @param {Duration | null} props.autoRenewPeriod;
     * @param {Timestamp | null} props.expirationTime;
     * @param {string} props.tokenMemo;
     * @param {CustomFee[]} props.customFees;
     * @param {TokenType | null} props.tokenType;
     * @param {TokenSupplyType | null} props.supplyType;
     * @param {Long | null} props.maxSupply;
     * @param {LedgerId|null} props.ledgerId;
     * @param {Key | null} props.metadataKey;
     * @param {Uint8Array | null} props.metadata;
     */
    constructor(props) {
        /**
         * ID of the token instance
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The name of the token. It is a string of ASCII only characters
         *
         * @readonly
         */
        this.name = props.name;

        /**
         * The symbol of the token. It is a UTF-8 capitalized alphabetical string
         *
         * @readonly
         */
        this.symbol = props.symbol;

        /**
         * The number of decimal places a token is divisible by
         *
         * @readonly
         */
        this.decimals = props.decimals;

        /**
         * The total supply of tokens that are currently in circulation
         *
         * @readonly
         */
        this.totalSupply = props.totalSupply;

        /**
         * The ID of the account which is set as treasuryAccountId
         *
         * @readonly
         */
        this.treasuryAccountId = props.treasuryAccountId;

        /**
         * The key which can perform update/delete operations on the token. If empty, the token can be perceived as
         * immutable (not being able to be updated/deleted)
         *
         * @readonly
         */
        this.adminKey = props.adminKey;

        /**
         * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required,
         * and KYC grant or revoke operations are not possible.
         *
         * @readonly
         */
        this.kycKey = props.kycKey;

        /**
         * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
         *
         * @readonly
         */
        this.freezeKey = props.freezeKey;

        /**
         * The Key which can pause and unpause the Token.
         *
         * @readonly
         */
        this.pauseKey = props.pauseKey;

        /**
         * The key which can wipe token balance of an account. If empty, wipe is not possible
         *
         * @readonly
         */
        this.wipeKey = props.wipeKey;

        /**
         * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
         *
         * @readonly
         */
        this.supplyKey = props.supplyKey;

        this.feeScheduleKey = props.feeScheduleKey;

        /**
         * The default Freeze status (not applicable = null, frozen = false, or unfrozen = true) of Hedera accounts relative to this token.
         * FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and
         * defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
         *      FreezeNotApplicable = null;
         *      Frozen = true;
         *      Unfrozen = false;
         *
         * @readonly
         */
        this.defaultFreezeStatus = props.defaultFreezeStatus;

        /**
         * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable
         * is returned if KYC key is not set, otherwise Revoked
         *      KycNotApplicable = null;
         *      Granted = true;
         *      Revoked = false;
         *
         * @readonly
         */
        this.defaultKycStatus = props.defaultKycStatus;

        /**
         * The default pause status of Hedera accounts relative to this token.
         * PauseNotApplicable is returned if pauseKey is not set
         *      PauseNotApplicable = null;
         *      Paused = true;
         *      Unpaused = false;
         *
         * @readonly
         */
        this.pauseStatus = props.pauseStatus;

        /**
         * Specifies whether the token was deleted or not
         *
         * @readonly
         */
        this.isDeleted = props.isDeleted;

        /**
         * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
         *
         * @readonly
         */
        this.autoRenewAccountId = props.autoRenewAccountId;

        /**
         * The interval at which the auto-renew account will be charged to extend the token's expiry
         *
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /**
         * The epoch second at which the token expire: will; if an auto-renew account and period are specified,
         * this is coerced to the current epoch second plus the autoRenewPeriod
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * The memo associated with the token.
         *
         * @readonly
         */
        this.tokenMemo = props.tokenMemo;

        this.customFees = props.customFees;

        this.tokenType = props.tokenType;

        this.supplyType = props.supplyType;

        this.maxSupply = props.maxSupply;

        this.ledgerId = props.ledgerId;

        /**
         * @description The key which can change the metadata of a token (token definition and individual NFTs).
         *
         * @readonly
         */
        this.metadataKey = props.metadataKey;

        /**
         * @description Metadata of the created token definition.
         * @readonly
         */
        this.metadata = props.metadata;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITokenInfo} info
     * @returns {TokenInfo}
     */
    static _fromProtobuf(info) {
        const defaultFreezeStatus =
            /** @type {HieroProto.proto.TokenFreezeStatus} */ (
                info.defaultFreezeStatus
            );
        const defaultKycStatus =
            /** @type {HieroProto.proto.TokenKycStatus} */ (
                info.defaultKycStatus
            );
        const pauseStatus = /**@type {HieroProto.proto.TokenPauseStatus} */ (
            info.pauseStatus
        );

        const autoRenewAccountId =
            info.autoRenewAccount != null
                ? AccountId._fromProtobuf(info.autoRenewAccount)
                : new AccountId(0);

        return new TokenInfo({
            tokenId: TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (info.tokenId),
            ),
            name: /** @type {string} */ (info.name),
            symbol: /** @type {string} */ (info.symbol),
            decimals: /** @type {number} */ (info.decimals),
            totalSupply: Long.fromValue(/** @type {Long} */ (info.totalSupply)),
            treasuryAccountId:
                info.treasury != null
                    ? AccountId._fromProtobuf(
                          /** @type {HieroProto.proto.IAccountID} */ (
                              info.treasury
                          ),
                      )
                    : null,
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            kycKey:
                info.kycKey != null ? Key._fromProtobufKey(info.kycKey) : null,
            freezeKey:
                info.freezeKey != null
                    ? Key._fromProtobufKey(info.freezeKey)
                    : null,
            pauseKey:
                info.pauseKey != null
                    ? Key._fromProtobufKey(info.pauseKey)
                    : null,
            wipeKey:
                info.wipeKey != null
                    ? Key._fromProtobufKey(info.wipeKey)
                    : null,
            supplyKey:
                info.supplyKey != null
                    ? Key._fromProtobufKey(info.supplyKey)
                    : null,
            feeScheduleKey:
                info.feeScheduleKey != null
                    ? Key._fromProtobufKey(info.feeScheduleKey)
                    : null,
            defaultFreezeStatus:
                defaultFreezeStatus === 0 ? null : defaultFreezeStatus == 1,
            defaultKycStatus:
                defaultKycStatus === 0 ? null : defaultKycStatus == 1,
            pauseStatus: pauseStatus === 0 ? null : pauseStatus == 1,
            isDeleted: /** @type {boolean} */ (info.deleted),
            autoRenewAccountId: !(
                autoRenewAccountId.shard.toInt() == 0 &&
                autoRenewAccountId.realm.toInt() == 0 &&
                autoRenewAccountId.num.toInt() == 0
            )
                ? autoRenewAccountId
                : null,
            autoRenewPeriod:
                info.autoRenewPeriod != null
                    ? Duration._fromProtobuf(
                          /** @type {HieroProto.proto.IDuration} */ (
                              info.autoRenewPeriod
                          ),
                      )
                    : null,
            expirationTime:
                info.expiry != null
                    ? Timestamp._fromProtobuf(
                          /** @type {HieroProto.proto.ITimestamp} */ (
                              info.expiry
                          ),
                      )
                    : null,
            tokenMemo: info.memo != null ? info.memo : "",
            customFees:
                info.customFees != null
                    ? info.customFees.map((fee) => {
                          if (fee.fixedFee != null) {
                              return CustomFixedFee._fromProtobuf(fee);
                          } else if (fee.fractionalFee != null) {
                              return CustomFractionalFee._fromProtobuf(fee);
                          } else {
                              return CustomRoyaltyFee._fromProtobuf(fee);
                          }
                      })
                    : [],
            tokenType:
                info.tokenType != null
                    ? TokenType._fromCode(info.tokenType)
                    : null,
            supplyType:
                info.supplyType != null
                    ? TokenSupplyType._fromCode(info.supplyType)
                    : null,
            maxSupply: info.maxSupply != null ? info.maxSupply : null,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
            metadataKey:
                info.metadataKey != null
                    ? Key._fromProtobufKey(info.metadataKey)
                    : null,
            metadata: info.metadata != null ? info.metadata : new Uint8Array(),
        });
    }

    /**
     * @returns {HieroProto.proto.ITokenInfo}
     */
    _toProtobuf() {
        return {
            tokenId: this.tokenId._toProtobuf(),
            name: this.name,
            symbol: this.symbol,
            decimals: this.decimals,
            totalSupply: this.totalSupply,
            treasury:
                this.treasuryAccountId != null
                    ? this.treasuryAccountId._toProtobuf()
                    : null,
            adminKey:
                this.adminKey != null ? this.adminKey._toProtobufKey() : null,
            kycKey: this.kycKey != null ? this.kycKey._toProtobufKey() : null,
            freezeKey:
                this.freezeKey != null ? this.freezeKey._toProtobufKey() : null,
            pauseKey:
                this.pauseKey != null ? this.pauseKey._toProtobufKey() : null,
            wipeKey:
                this.wipeKey != null ? this.wipeKey._toProtobufKey() : null,
            supplyKey:
                this.supplyKey != null ? this.supplyKey._toProtobufKey() : null,
            feeScheduleKey:
                this.feeScheduleKey != null
                    ? this.feeScheduleKey._toProtobufKey()
                    : null,
            defaultFreezeStatus:
                this.defaultFreezeStatus == null
                    ? 0
                    : this.defaultFreezeStatus
                      ? 1
                      : 2,
            defaultKycStatus:
                this.defaultKycStatus == null
                    ? 0
                    : this.defaultKycStatus
                      ? 1
                      : 2,
            pauseStatus:
                this.pauseStatus == null ? 0 : this.pauseStatus ? 1 : 2,
            deleted: this.isDeleted,
            autoRenewAccount:
                this.autoRenewAccountId != null
                    ? this.autoRenewAccountId._toProtobuf()
                    : undefined,
            autoRenewPeriod:
                this.autoRenewPeriod != null
                    ? this.autoRenewPeriod._toProtobuf()
                    : null,
            expiry:
                this.expirationTime != null
                    ? this.expirationTime._toProtobuf()
                    : null,
            memo: this.tokenMemo,
            customFees: this.customFees.map((fee) => fee._toProtobuf()),
            tokenType: this.tokenType != null ? this.tokenType._code : null,
            supplyType: this.supplyType != null ? this.supplyType._code : null,
            maxSupply: this.maxSupply,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
            metadataKey:
                this.metadataKey != null
                    ? this.metadataKey._toProtobufKey()
                    : null,
            metadata: this.metadata != null ? this.metadata : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TokenInfo}
     */
    static fromBytes(bytes) {
        return TokenInfo._fromProtobuf(
            HieroProto.proto.TokenInfo.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TokenInfo.encode(this._toProtobuf()).finish();
    }
}
// Filename: src/token/TokenInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import TokenId from "./TokenId.js";
import TokenInfo from "./TokenInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.ITokenInfo} HieroProto.proto.ITokenInfo
 * @typedef {import("@hashgraph/proto").proto.ITokenGetInfoQuery} HieroProto.proto.ITokenGetInfoQuery
 * @typedef {import("@hashgraph/proto").proto.ITokenGetInfoResponse} HieroProto.proto.ITokenGetInfoResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Retrieve the detail characteristics for a token.
 * @augments {Query<TokenInfo>}
 */
export default class TokenInfoQuery extends Query {
    /**
     * @param {object} properties
     * @param {TokenId | string} [properties.tokenId]
     */
    constructor(properties = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;
        if (properties.tokenId != null) {
            this.setTokenId(properties.tokenId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {TokenInfoQuery}
     */
    static _fromProtobuf(query) {
        const info = /** @type {HieroProto.proto.ITokenGetInfoQuery} */ (
            query.tokenGetInfo
        );

        return new TokenInfoQuery({
            tokenId:
                info.token != null
                    ? TokenId._fromProtobuf(info.token)
                    : undefined,
        });
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * Set the token ID for which the info is being requested.
     *
     * @param {TokenId | string} tokenId
     * @returns {TokenInfoQuery}
     */
    setTokenId(tokenId) {
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.token.getTokenInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const tokenGetInfo =
            /** @type {HieroProto.proto.ITokenGetInfoResponse} */ (
                response.tokenGetInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            tokenGetInfo.header
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<TokenInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const info = /** @type {HieroProto.proto.ITokenGetInfoResponse} */ (
            response.tokenGetInfo
        );

        return Promise.resolve(
            TokenInfo._fromProtobuf(
                /** @type {HieroProto.proto.ITokenInfo} */ (info.tokenInfo),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            tokenGetInfo: {
                header,
                token:
                    this._tokenId != null ? this._tokenId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TokenInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("tokenGetInfo", TokenInfoQuery._fromProtobuf);
// Filename: src/token/TokenKeyValidation.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.TokenKeyValidation} HieroProto.proto.TokenKeyValidation
 */

/** Types of validation strategies for token keys. */
export default class TokenKeyValidation {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case TokenKeyValidation.FullValidation:
                return "FULL_VALIDATION";
            case TokenKeyValidation.NoValidation:
                return "NO_VALIDATION";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {TokenKeyValidation}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return TokenKeyValidation.FullValidation;
            case 1:
                return TokenKeyValidation.NoValidation;
        }

        throw new Error(
            `(BUG) TokenKeyValidation.fromCode() does not handle code: ${code}`,
        );
    }

    /**
     * @returns {HieroProto.proto.TokenKeyValidation}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * Currently the default behaviour. It will perform all token key validations.
 */
TokenKeyValidation.FullValidation = new TokenKeyValidation(0);

/**
 * Perform no validations at all for all passed token keys.
 */
TokenKeyValidation.NoValidation = new TokenKeyValidation(1);
// Filename: src/token/TokenMintTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Long from "long";
import * as hex from "../encoding/hex.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenMintTransactionBody} HieroProto.proto.ITokenMintTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Mint a new Hedera™ crypto-currency token.
 */
export default class TokenMintTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long | number} [props.amount]
     * @param {Uint8Array[]} [props.metadata]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?Long}
         */
        this._amount = null;

        /**
         * @private
         * @type {Uint8Array[]}
         */
        this._metadata = [];

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        if (props.metadata != null) {
            this.setMetadata(props.metadata);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenMintTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const mintToken =
            /** @type {HieroProto.proto.ITokenMintTransactionBody} */ (
                body.tokenMint
            );

        return Transaction._fromProtobufTransactions(
            new TokenMintTransaction({
                tokenId:
                    mintToken.token != null
                        ? TokenId._fromProtobuf(mintToken.token)
                        : undefined,
                amount: mintToken.amount != null ? mintToken.amount : undefined,
                metadata:
                    mintToken.metadata != null ? mintToken.metadata : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {this}
     */
    setAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof Long ? amount : Long.fromValue(amount);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @returns {Uint8Array[]}
     */
    get metadata() {
        return this._metadata;
    }

    /**
     * @param {Uint8Array | string} metadata
     * @returns {this}
     */
    addMetadata(metadata) {
        this._requireNotFrozen();

        if (typeof metadata === "string") {
            console.warn(
                "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.",
            );
        }

        this._metadata.push(
            typeof metadata === "string" ? hex.decode(metadata) : metadata,
        );

        return this;
    }

    /**
     * @param {Uint8Array[]} metadata
     * @returns {this}
     */
    setMetadata(metadata) {
        this._requireNotFrozen();

        for (const data of metadata) {
            if (typeof data === "string") {
                console.warn(
                    "Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.",
                );
                break;
            }
        }

        this._metadata = metadata.map((data) =>
            typeof data === "string" ? hex.decode(data) : data,
        );

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.mintToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenMint";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenMintTransactionBody}
     */
    _makeTransactionData() {
        return {
            amount: this._amount,
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            metadata: this._metadata,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenMintTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenMint",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenMintTransaction._fromProtobuf,
);
// Filename: src/token/TokenNftInfo.js
// SPDX-License-Identifier: Apache-2.0

import NftId from "./NftId.js";
import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import * as hex from "../encoding/hex.js";
import LedgerId from "../LedgerId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.TokenFreezeStatus} HieroProto.proto.TokenFreezeStatus
 * @typedef {import("@hashgraph/proto").proto.TokenKycStatus} HieroProto.proto.TokenKycStatus
 * @typedef {import("@hashgraph/proto").proto.TokenPauseStatus} HieroProto.proto.TokenPauseStatus
 * @typedef {import("@hashgraph/proto").proto.ITokenNftInfo} HieroProto.proto.ITokenNftInfo
 * @typedef {import("@hashgraph/proto").proto.INftID} HieroProto.proto.INftID
 * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.IKey} HieroProto.proto.IKey
 * @typedef {import("@hashgraph/proto").proto.IDuration} HieroProto.proto.IDuration
 */

export default class TokenNftInfo {
    /**
     * @private
     * @param {object} props
     * @param {NftId} props.nftId
     * @param {AccountId} props.accountId
     * @param {Timestamp} props.creationTime
     * @param {Uint8Array | null} props.metadata
     * @param {LedgerId|null} props.ledgerId
     * @param {AccountId|null} props.spenderId
     */
    constructor(props) {
        /**
         * ID of the nft instance
         *
         * @readonly
         */
        this.nftId = props.nftId;

        /**
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * @readonly
         */
        this.creationTime = props.creationTime;

        /**
         * @readonly
         */
        this.metadata = props.metadata;

        this.ledgerId = props.ledgerId;

        this.spenderId = props.spenderId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITokenNftInfo} info
     * @returns {TokenNftInfo}
     */
    static _fromProtobuf(info) {
        return new TokenNftInfo({
            nftId: NftId._fromProtobuf(
                /** @type {HieroProto.proto.INftID} */ (info.nftID),
            ),
            accountId: AccountId._fromProtobuf(
                /** @type {HieroProto.proto.IAccountID} */ (info.accountID),
            ),
            creationTime: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */ (info.creationTime),
            ),
            metadata: info.metadata !== undefined ? info.metadata : null,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
            spenderId:
                info.spenderId != null
                    ? AccountId._fromProtobuf(info.spenderId)
                    : null,
        });
    }

    /**
     * @returns {HieroProto.proto.ITokenNftInfo}
     */
    _toProtobuf() {
        return {
            nftID: this.nftId._toProtobuf(),
            accountID: this.accountId._toProtobuf(),
            creationTime: this.creationTime._toProtobuf(),
            metadata: this.metadata,
            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,
            spenderId:
                this.spenderId != null ? this.spenderId._toProtobuf() : null,
        };
    }

    /**
     * @typedef {object} TokenNftInfoJson
     * @property {string} nftId
     * @property {string} accountId
     * @property {string} creationTime
     * @property {string | null} metadata
     * @property {string | null} ledgerId
     * @property {string | null} spenderId
     * @returns {TokenNftInfoJson}
     */
    toJson() {
        return {
            nftId: this.nftId.toString(),
            accountId: this.accountId.toString(),
            creationTime: this.creationTime.toString(),
            metadata: this.metadata != null ? hex.encode(this.metadata) : null,
            ledgerId: this.ledgerId != null ? this.ledgerId.toString() : null,
            spenderId:
                this.spenderId != null ? this.spenderId.toString() : null,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJson());
    }
}
// Filename: src/token/TokenNftInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import NftId from "./NftId.js";
import AccountId from "../account/AccountId.js";
import TokenId from "../token/TokenId.js";
import TokenNftInfo from "./TokenNftInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenNftInfo} HieroProto.proto.ITokenNftInfo
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfoQuery} HieroProto.proto.ITokenGetNftInfoQuery
 * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfosQuery} HieroProto.proto.ITokenGetNftInfosQuery
 * @typedef {import("@hashgraph/proto").proto.ITokenGetAccountNftInfosQuery} HieroProto.proto.ITokenGetAccountNftInfosQuery
 * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfoResponse} HieroProto.proto.ITokenGetNftInfoResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenGetNftInfosResponse} HieroProto.proto.ITokenGetNftInfosResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenGetAccountNftInfosResponse} HieroProto.proto.ITokenGetAccountNftInfosResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 */

/**
 * @augments {Query<TokenNftInfo[]>}
 */
export default class TokenNftInfoQuery extends Query {
    /**
     * @param {object} properties
     * @param {NftId | string} [properties.nftId]
     * @param {AccountId | string} [properties.accountId]
     * @param {TokenId | string} [properties.tokenId]
     * @param {Long | number} [properties.start]
     * @param {Long | number} [properties.end]
     */
    constructor(properties = {}) {
        super();

        /**
         * @private
         * @type {?NftId}
         */
        this._nftId = null;
        if (properties.nftId != null) {
            this.setNftId(properties.nftId);
        }

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;
        if (properties.accountId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setAccountId(properties.accountId);
        }

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;
        if (properties.tokenId != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setTokenId(properties.tokenId);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._start = null;
        if (properties.start != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setStart(properties.start);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._end = null;
        if (properties.end != null) {
            // eslint-disable-next-line deprecation/deprecation
            this.setEnd(properties.end);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {TokenNftInfoQuery}
     */
    static _fromProtobuf(query) {
        if (query.tokenGetNftInfo != null) {
            const info = /** @type {HieroProto.proto.ITokenGetNftInfoQuery} */ (
                query.tokenGetNftInfo
            );

            return new TokenNftInfoQuery({
                nftId:
                    info.nftID != null
                        ? NftId._fromProtobuf(info.nftID)
                        : undefined,
            });
        } else if (query.tokenGetAccountNftInfos != null) {
            const info =
                /** @type {HieroProto.proto.ITokenGetAccountNftInfosQuery} */ (
                    query.tokenGetAccountNftInfos
                );

            return new TokenNftInfoQuery({
                accountId:
                    info.accountID != null
                        ? AccountId._fromProtobuf(info.accountID)
                        : undefined,
                start: info.start != null ? info.start : undefined,
                end: info.end != null ? info.end : undefined,
            });
        } else {
            const info =
                /** @type {HieroProto.proto.ITokenGetNftInfosQuery} */ (
                    query.tokenGetNftInfos
                );

            return new TokenNftInfoQuery({
                tokenId:
                    info.tokenID != null
                        ? TokenId._fromProtobuf(info.tokenID)
                        : undefined,
                start: info.start != null ? info.start : undefined,
                end: info.end != null ? info.end : undefined,
            });
        }
    }

    /**
     * @returns {?NftId}
     */
    get nftId() {
        return this._nftId;
    }

    /**
     * Set the token ID for which the info is being requested.
     *
     * @param {NftId | string} nftId
     * @returns {TokenNftInfoQuery}
     */
    setNftId(nftId) {
        this._nftId =
            typeof nftId === "string"
                ? NftId.fromString(nftId)
                : NftId._fromProtobuf(nftId._toProtobuf());

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?AccountId}
     */
    get accountId() {
        console.warn(
            "`TokenNftInfoQuery.accountId` is deprecated with no replacement",
        );
        return this._accountId;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {AccountId | string} accountId
     * @returns {TokenNftInfoQuery}
     */
    setAccountId(accountId) {
        console.warn(
            "`TokenNftInfoQuery.setAccountId()` is deprecated with no replacement",
        );
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : AccountId._fromProtobuf(accountId._toProtobuf());

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?TokenId}
     */
    get tokenId() {
        console.warn(
            "`TokenNftInfoQuery.tokenId` is deprecated with no replacement",
        );
        return this._tokenId;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {TokenId | string} tokenId
     * @returns {TokenNftInfoQuery}
     */
    setTokenId(tokenId) {
        console.warn(
            "`TokenNftInfoQuery.setTokenId()` is deprecated with no replacement",
        );
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : TokenId._fromProtobuf(tokenId._toProtobuf());

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?Long}
     */
    get start() {
        console.warn(
            "`TokenNftInfoQuery.start` is deprecated with no replacement",
        );
        return this._start;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {Long | number} start
     * @returns {TokenNftInfoQuery}
     */
    setStart(start) {
        console.warn(
            "`TokenNftInfoQuery.setStart()` is deprecated with no replacement",
        );
        this._start =
            typeof start === "number" ? Long.fromNumber(start) : start;

        return this;
    }

    /**
     * @deprecated with no replacement
     * @returns {?Long}
     */
    get end() {
        console.warn(
            "`TokenNftInfoQuery.end` is deprecated with no replacement",
        );
        return this._end;
    }

    /**
     * @deprecated with no replacement
     * Set the token ID for which the info is being requested.
     * @param {Long | number} end
     * @returns {TokenNftInfoQuery}
     */
    setEnd(end) {
        console.warn(
            "`TokenNftInfoQuery.setEnd()` is deprecated with no replacement",
        );
        this._end = typeof end === "number" ? Long.fromNumber(end) : end;

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.token.getTokenNftInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const infos = /** @type {HieroProto.proto.ITokenGetNftInfoResponse} */ (
            response.tokenGetNftInfo
        );

        return /** @type {HieroProto.proto.IResponseHeader} */ (infos.header);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<TokenNftInfo[]>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const nfts = [
            /** @type {HieroProto.proto.ITokenNftInfo} */
            (
                /** @type {HieroProto.proto.ITokenGetNftInfoResponse} */ (
                    response.tokenGetNftInfo
                ).nft
            ),
        ];

        return Promise.resolve(
            nfts.map((nft) =>
                TokenNftInfo._fromProtobuf(
                    /** @type {HieroProto.proto.ITokenNftInfo} */ (nft),
                ),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            tokenGetNftInfo: {
                header,
                nftID: this._nftId != null ? this._nftId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TokenNftInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("tokenGetNftInfo", TokenNftInfoQuery._fromProtobuf);
// Filename: src/token/TokenNftTransfer.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import AccountId from "../account/AccountId.js";
import TokenId from "./TokenId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").proto.INftTransfer} HieroProto.proto.INftTransfer
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency tokentransfer.
 */
export default class TokenNftTransfer {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId | string} props.tokenId
     * @param {AccountId | string} props.senderAccountId
     * @param {AccountId | string} props.receiverAccountId
     * @param {Long | number} props.serialNumber
     * @param {boolean} props.isApproved
     */
    constructor(props) {
        /**
         * The Token ID that sends or receives cryptocurrency.
         */
        this.tokenId =
            props.tokenId instanceof TokenId
                ? props.tokenId
                : TokenId.fromString(props.tokenId);

        /**
         * The Account ID that sends or receives cryptocurrency.
         */
        this.senderAccountId =
            props.senderAccountId instanceof AccountId
                ? props.senderAccountId
                : AccountId.fromString(props.senderAccountId);

        /**
         * The Account ID that sends or receives cryptocurrency.
         */
        this.receiverAccountId =
            props.receiverAccountId instanceof AccountId
                ? props.receiverAccountId
                : AccountId.fromString(props.receiverAccountId);

        this.serialNumber = Long.fromValue(props.serialNumber);
        this.isApproved = props.isApproved;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITokenTransferList[]} tokenTransfers
     * @returns {TokenNftTransfer[]}
     */
    static _fromProtobuf(tokenTransfers) {
        const transfers = [];

        for (const tokenTransfer of tokenTransfers) {
            const tokenId = TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (tokenTransfer.token),
            );
            for (const transfer of tokenTransfer.nftTransfers != null
                ? tokenTransfer.nftTransfers
                : []) {
                transfers.push(
                    new TokenNftTransfer({
                        tokenId,
                        senderAccountId: AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                transfer.senderAccountID
                            ),
                        ),
                        receiverAccountId: AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                transfer.receiverAccountID
                            ),
                        ),
                        serialNumber:
                            transfer.serialNumber != null
                                ? transfer.serialNumber
                                : Long.ZERO,
                        isApproved: transfer.isApproval == true,
                    }),
                );
            }
        }

        return transfers;
    }

    /**
     * @internal
     * @returns {HieroProto.proto.INftTransfer}
     */
    _toProtobuf() {
        return {
            senderAccountID: this.senderAccountId._toProtobuf(),
            receiverAccountID: this.receiverAccountId._toProtobuf(),
            serialNumber: this.serialNumber,
            isApproval: this.isApproved,
        };
    }
}
// Filename: src/token/TokenNftsUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenUpdateNftsTransactionBody} HieroProto.proto.ITokenUpdateNftsTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * @deprecated - Use TokenUpdateNftsTransaction instead
 */
export default class TokenNftsUpdateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long[]} [props.serialNumbers]
     * @param {Uint8Array} [props.metadata]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?Long[]}
         */
        this._serialNumbers = [];

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._metadata = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.serialNumbers != null) {
            this.setSerialNumbers(props.serialNumbers);
        }

        if (props.metadata != null) {
            this.setMetadata(props.metadata);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenNftsUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const tokenUpdate =
            /** @type {HieroProto.proto.ITokenUpdateNftsTransactionBody} */ (
                body.tokenUpdate
            );

        return Transaction._fromProtobufTransactions(
            // eslint-disable-next-line deprecation/deprecation
            new TokenNftsUpdateTransaction({
                tokenId:
                    tokenUpdate.token != null
                        ? TokenId._fromProtobuf(tokenUpdate.token)
                        : undefined,
                serialNumbers:
                    tokenUpdate.serialNumbers != null
                        ? tokenUpdate.serialNumbers
                        : [],
                metadata:
                    tokenUpdate.metadata != null
                        ? tokenUpdate.metadata.value != null
                            ? tokenUpdate.metadata.value
                            : undefined
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @description Assign the token id.
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @description Assign the list of serial numbers.
     * @param {Long[]} serialNumbers
     * @returns {this}
     */
    setSerialNumbers(serialNumbers) {
        this._requireNotFrozen();
        this._serialNumbers = serialNumbers;

        return this;
    }

    /**
     * @param {Uint8Array} metadata
     * @returns {this}
     */
    setMetadata(metadata) {
        this._requireNotFrozen();
        this._metadata = metadata;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.pauseToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUpdateNfts";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenUpdateNftsTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            serialNumbers:
                this._serialNumbers != null ? this._serialNumbers : [],
            ...(this._metadata != null
                ? {
                      metadata: {
                          value: this._metadata,
                      },
                  }
                : null),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenNftsUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUpdateNfts",
    // eslint-disable-next-line deprecation/deprecation, @typescript-eslint/unbound-method
    TokenNftsUpdateTransaction._fromProtobuf,
);
// Filename: src/token/TokenPauseTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenPauseTransactionBody} HieroProto.proto.ITokenPauseTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Pause a new Hedera™ crypto-currency token.
 */
export default class TokenPauseTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenPauseTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const pauseToken =
            /** @type {HieroProto.proto.ITokenPauseTransactionBody} */ (
                body.tokenPause
            );

        return Transaction._fromProtobufTransactions(
            new TokenPauseTransaction({
                tokenId:
                    pauseToken.token != null
                        ? TokenId._fromProtobuf(pauseToken.token)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.pauseToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenPause";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenPauseTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenPauseTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenPause",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenPauseTransaction._fromProtobuf,
);
// Filename: src/token/TokenReference.js
import NftId from "./NftId.js";
import TokenId from "./TokenId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.TokenReference} HieroProto.proto.TokenReference
 */

export default class TokenReference {
    constructor() {
        /**
         * @public
         * @type {?TokenId}
         */
        this.fungibleToken = null;
        /**
         * @public
         * @type {?NftId}
         */
        this.nft = null;
    }

    /**
     * @public
     * @param {HieroProto.proto.TokenReference} reference
     * @returns {TokenReference}
     */
    static _fromProtobuf(reference) {
        return {
            fungibleToken:
                reference.fungibleToken != undefined
                    ? TokenId._fromProtobuf(reference.fungibleToken)
                    : null,
            nft:
                reference.nft != undefined
                    ? NftId._fromProtobuf(reference.nft)
                    : null,
        };
    }
}
// Filename: src/token/TokenRejectFlow.js
// SPDX-License-Identifier: Apache-2.0
import TokenRejectTransaction from "../token/TokenRejectTransaction.js";
import TokenDissociateTransaction from "../token/TokenDissociateTransaction.js";

/**
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Signer.js").default} Signer
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../transaction/Transaction.js").default} Transaction
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../token/TokenId.js").default} TokenId
 * @typedef {import("../token/NftId.js").default} NftId
 * @typedef {import("../PublicKey.js").default} PublicKey
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Reject undesired token(s) and dissociate in a single flow.
 */
export default class TokenRejectFlow {
    constructor() {
        /**
         * @private
         * @type {?AccountId}
         */
        this._ownerId = null;

        /**
         * @private
         * @type {TokenId[]}
         */
        this._tokenIds = [];

        /**
         * @private
         * @type {NftId[]}
         */
        this._nftIds = [];

        /**
         * @private
         * @type {?Client}
         */
        this._freezeWithClient = null;

        /**
         * @private
         * @type {?PrivateKey}
         */
        this._signPrivateKey = null;

        /**
         * @private
         * @type {?PublicKey}
         */
        this._signPublicKey = null;

        /**
         * @private
         * @type {?(message: Uint8Array) => Promise<Uint8Array>}
         */
        this._transactionSigner = null;
    }

    /**
     *
     * @param {AccountId} ownerId
     * @returns {this}
     */
    setOwnerId(ownerId) {
        this.requireNotFrozen();
        this._ownerId = ownerId;
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get ownerId() {
        return this._ownerId;
    }

    /**
     *
     * @param {TokenId[]} ids
     * @returns {this}
     */
    setTokenIds(ids) {
        this.requireNotFrozen();
        this._tokenIds = ids;
        return this;
    }

    /**
     *
     * @param {TokenId} id
     * @returns {this}
     */
    addTokenId(id) {
        this.requireNotFrozen();
        this._tokenIds.push(id);
        return this;
    }

    /**
     *
     * @returns {TokenId[]}
     */
    get tokenIds() {
        return this._tokenIds;
    }

    /**
     *
     * @param {NftId[]} ids
     * @returns {this}
     */
    setNftIds(ids) {
        this.requireNotFrozen();
        this._nftIds = ids;
        return this;
    }

    /**
     *
     * @param {NftId} id
     * @returns {this}
     */
    addNftId(id) {
        this.requireNotFrozen();
        this._nftIds.push(id);
        return this;
    }

    /**
     *
     * @returns {NftId[]}
     */
    get nftIds() {
        return this._nftIds;
    }

    /**
     *
     * @param {PrivateKey} privateKey
     * @returns {this}
     */
    sign(privateKey) {
        this._signPrivateKey = privateKey;
        this._signPublicKey = null;
        this._transactionSigner = null;
        return this;
    }

    /**
     *
     * @param {PublicKey} publicKey
     * @param {((message: Uint8Array) => Promise<Uint8Array>)} signer
     * @returns {this}
     */
    signWith(publicKey, signer) {
        this._signPublicKey = publicKey;
        this._transactionSigner = signer;
        this._signPrivateKey = null;
        return this;
    }

    /**
     * @param {Client} client
     * @returns {this}
     */
    signWithOperator(client) {
        const operator = client.getOperator();
        if (operator == null) {
            throw new Error("Client operator must be set");
        }
        this._signPublicKey = operator.publicKey;
        this._transactionSigner = operator.transactionSigner;
        this._signPrivateKey = null;
        return this;
    }

    /**
     * @private
     * @param {Transaction} transaction
     */
    fillOutTransaction(transaction) {
        if (this._freezeWithClient) {
            transaction.freezeWith(this._freezeWithClient);
        }
        if (this._signPrivateKey) {
            void transaction.sign(this._signPrivateKey);
        } else if (this._signPublicKey && this._transactionSigner) {
            void transaction.signWith(
                this._signPublicKey,
                this._transactionSigner,
            );
        }
    }
    /**
     *
     * @param {Client} client
     * @returns {this}
     */
    freezeWith(client) {
        this._freezeWithClient = client;
        return this;
    }

    /**
     * @param {Client} client
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client) {
        const tokenRejectTxn = new TokenRejectTransaction()
            .setTokenIds(this.tokenIds)
            .setNftIds(this.nftIds);

        if (this.ownerId) {
            tokenRejectTxn.setOwnerId(this.ownerId);
        }

        this.fillOutTransaction(tokenRejectTxn);

        /* Get all token ids from NFT and remove duplicates as duplicated IDs 
        will trigger a TOKEN_REFERENCE_REPEATED error. */
        const nftTokenIds = this.nftIds
            .map((nftId) => nftId.tokenId)
            .filter(function (value, index, array) {
                return array.indexOf(value) === index;
            });

        const tokenDissociateTxn = new TokenDissociateTransaction().setTokenIds(
            [...this.tokenIds, ...nftTokenIds],
        );

        if (this.ownerId != null) {
            tokenDissociateTxn.setAccountId(this.ownerId);
        }

        this.fillOutTransaction(tokenDissociateTxn);

        const tokenRejectResponse = await tokenRejectTxn.execute(client);
        await tokenRejectResponse.getReceipt(client);

        const tokenDissociateResponse =
            await tokenDissociateTxn.execute(client);
        await tokenDissociateResponse.getReceipt(client);

        return tokenRejectResponse;
    }

    requireNotFrozen() {
        if (this._freezeWithClient != null) {
            throw new Error(
                "Transaction is already frozen and cannot be modified",
            );
        }
    }
}
// Filename: src/token/TokenRejectTransaction.js
// SPDX-License-Identifier: Apache-2.0
import AccountId from "../account/AccountId.js";
import Transaction from "../transaction/Transaction.js";
import { TRANSACTION_REGISTRY } from "../transaction/Transaction.js";
import TokenReference from "../token/TokenReference.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenRejectTransactionBody} HieroProto.proto.ITokenRejectTransactionBody
 * @typedef {import("@hashgraph/proto").proto.TokenReference} HieroProto.proto.TokenReference
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../token/TokenId.js").default} TokenId
 * @typedef {import("../token/NftId.js").default} NftId
 */

/**
 * Reject a new Hedera™ crypto-currency token.
 */
export default class TokenRejectTransaction extends Transaction {
    /**
     *
     * @param {object} [props]
     * @param {?AccountId} [props.owner]
     * @param {NftId[]} [props.nftIds]
     * @param {TokenId[]} [props.tokenIds]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?AccountId}
         */
        this._owner = null;

        if (props.owner != null) {
            this.setOwnerId(props.owner);
        }

        /**
         * @private
         * @type {TokenId[]}
         */
        this._tokenIds = [];

        /**
         * @private
         * @type {NftId[]}
         */
        this._nftIds = [];

        if (props.tokenIds != null) {
            this.setTokenIds(props.tokenIds);
        }

        if (props.nftIds != null) {
            this.setNftIds(props.nftIds);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenRejectTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const rejectToken =
            /** @type {HieroProto.proto.ITokenRejectTransactionBody} */ (
                body.tokenReject
            );

        const tokenIds = rejectToken.rejections?.map((rejection) =>
            TokenReference._fromProtobuf(rejection),
        );
        const ftIds = tokenIds
            ?.filter((token) => token.fungibleToken)
            .map(({ fungibleToken }) => {
                if (fungibleToken == null) {
                    throw new Error("Fungible Token cannot be null");
                }
                return fungibleToken;
            });

        const nftIds = tokenIds
            ?.filter((token) => token.nft)
            .map(({ nft }) => {
                if (nft == null) {
                    throw new Error("Nft cannot be null");
                }
                return nft;
            });

        return Transaction._fromProtobufTransactions(
            new TokenRejectTransaction({
                owner:
                    rejectToken.owner != null
                        ? AccountId._fromProtobuf(rejectToken.owner)
                        : undefined,

                tokenIds: ftIds,
                nftIds: nftIds,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {TokenId[]}
     */
    get tokenIds() {
        return this._tokenIds;
    }

    /**
     * @param {TokenId[]} tokenIds
     * @returns {this}
     */
    setTokenIds(tokenIds) {
        this._requireNotFrozen();
        this._tokenIds = tokenIds;
        return this;
    }

    /**
     * @param {TokenId} tokenId
     * @returns {this}
     */
    addTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenIds?.push(tokenId);
        return this;
    }

    /**
     * @returns {NftId[]}
     *
     */
    get nftIds() {
        return this._nftIds;
    }

    /**
     *
     * @param {NftId[]} nftIds
     * @returns {this}
     */
    setNftIds(nftIds) {
        this._requireNotFrozen();
        this._nftIds = nftIds;
        return this;
    }

    /**
     * @param {NftId} nftId
     * @returns {this}
     */
    addNftId(nftId) {
        this._requireNotFrozen();
        this._nftIds?.push(nftId);
        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get ownerId() {
        return this._owner;
    }

    /**
     * @param {AccountId} owner
     * @returns {this}
     */
    setOwnerId(owner) {
        this._requireNotFrozen();
        this._owner = owner;
        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.rejectToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenReject";
    }

    /**
     * @returns {HieroProto.proto.ITokenRejectTransactionBody}
     */
    _makeTransactionData() {
        /** @type {HieroProto.proto.TokenReference[]} */
        const rejections = [];
        for (const tokenId of this._tokenIds) {
            rejections.push({
                fungibleToken: tokenId._toProtobuf(),
            });
        }

        for (const nftId of this._nftIds) {
            rejections.push({
                nft: nftId._toProtobuf(),
            });
        }
        return {
            owner: this.ownerId?._toProtobuf() ?? null,
            rejections,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenRejectTransaction:${timestamp.toString()}`;
    }
}
TRANSACTION_REGISTRY.set(
    "tokenReject",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenRejectTransaction._fromProtobuf,
);
// Filename: src/token/TokenRevokeKycTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenRevokeKycTransactionBody} HieroProto.proto.ITokenRevokeKycTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * RevokeKyc a new Hedera™ crypto-currency token.
 */
export default class TokenRevokeKycTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenRevokeKycTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const revokeKycToken =
            /** @type {HieroProto.proto.ITokenRevokeKycTransactionBody} */ (
                body.tokenRevokeKyc
            );

        return Transaction._fromProtobufTransactions(
            new TokenRevokeKycTransaction({
                tokenId:
                    revokeKycToken.token != null
                        ? TokenId._fromProtobuf(revokeKycToken.token)
                        : undefined,
                accountId:
                    revokeKycToken.account != null
                        ? AccountId._fromProtobuf(revokeKycToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.revokeKycFromTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenRevokeKyc";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenRevokeKycTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenRevokeKycTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenRevokeKyc",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenRevokeKycTransaction._fromProtobuf,
);
// Filename: src/token/TokenSupplyType.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.TokenSupplyType} HieroProto.proto.TokenSupplyType
 */

export default class TokenSupplyType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case TokenSupplyType.Infinite:
                return "INFINITE";
            case TokenSupplyType.Finite:
                return "FINITE";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {TokenSupplyType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return TokenSupplyType.Infinite;
            case 1:
                return TokenSupplyType.Finite;
        }

        throw new Error(
            `(BUG) TokenSupplyType.fromCode() does not handle code: ${code}`,
        );
    }

    /**
     * @returns {HieroProto.proto.TokenSupplyType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * Interchangeable value with one another, where any quantity of them has the
 * same value as another equal quantity if they are in the same class. Share
 * a single set of properties, not distinct from one another. Simply represented
 * as a balance or quantity to a given Hedera account.
 */
TokenSupplyType.Infinite = new TokenSupplyType(0);

/**
 * Unique, not interchangeable with other tokens of the same type as they
 * typically have different values. Individually traced and can carry unique
 * properties (e.g. serial number).
 */
TokenSupplyType.Finite = new TokenSupplyType(1);
// Filename: src/token/TokenTransfer.js
// SPDX-License-Identifier: Apache-2.0

import Long from "long";
import AccountId from "../account/AccountId.js";
import TokenId from "./TokenId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITokenTransferList} HieroProto.proto.ITokenTransferList
 * @typedef {import("@hashgraph/proto").proto.IAccountAmount} HieroProto.proto.IAccountAmount
 * @typedef {import("@hashgraph/proto").proto.IAccountID} HieroProto.proto.IAccountID
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @typedef {object} TokenTransferJSON
 * @property {string} tokenId
 * @property {string} accountId
 * @property {?number} expectedDecimals
 * @property {string} amount
 * @property {boolean} isApproved
 */

/**
 * An account, and the amount that it sends or receives during a cryptocurrency tokentransfer.
 */
export default class TokenTransfer {
    /**
     * @internal
     * @param {object} props
     * @param {TokenId | string} props.tokenId
     * @param {AccountId | string} props.accountId
     * @param {number | null} props.expectedDecimals
     * @param {Long | number} props.amount
     * @param {boolean} props.isApproved
     */
    constructor(props) {
        /**
         * The Token ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.tokenId =
            props.tokenId instanceof TokenId
                ? props.tokenId
                : TokenId.fromString(props.tokenId);

        /**
         * The Account ID that sends or receives cryptocurrency.
         *
         * @readonly
         */
        this.accountId =
            props.accountId instanceof AccountId
                ? props.accountId
                : AccountId.fromString(props.accountId);

        this.expectedDecimals = props.expectedDecimals;
        this.amount = Long.fromValue(props.amount);
        this.isApproved = props.isApproved;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITokenTransferList[]} tokenTransfers
     * @returns {TokenTransfer[]}
     */
    static _fromProtobuf(tokenTransfers) {
        const transfers = [];

        for (const tokenTransfer of tokenTransfers) {
            const tokenId = TokenId._fromProtobuf(
                /** @type {HieroProto.proto.ITokenID} */ (tokenTransfer.token),
            );
            const expectedDecimals =
                tokenTransfer.expectedDecimals != null
                    ? Object.hasOwn(tokenTransfer.expectedDecimals, "value")
                        ? tokenTransfer.expectedDecimals.value
                        : null
                    : null;

            for (const transfer of tokenTransfer.transfers != null
                ? tokenTransfer.transfers
                : []) {
                transfers.push(
                    new TokenTransfer({
                        tokenId,
                        accountId: AccountId._fromProtobuf(
                            /** @type {HieroProto.proto.IAccountID} */ (
                                transfer.accountID
                            ),
                        ),
                        expectedDecimals: expectedDecimals || null,
                        amount:
                            transfer.amount != null
                                ? transfer.amount
                                : Long.ZERO,
                        isApproved: transfer.isApproval == true,
                    }),
                );
            }
        }

        return transfers;
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IAccountAmount}
     */
    _toProtobuf() {
        return {
            accountID: this.accountId._toProtobuf(),
            amount: this.amount,
            isApproval: this.isApproved,
        };
    }

    /**
     * @returns {TokenTransferJSON}
     */
    toJSON() {
        return {
            tokenId: this.tokenId.toString(),
            accountId: this.accountId.toString(),
            expectedDecimals: this.expectedDecimals,
            amount: this.amount.toString(),
            isApproved: this.isApproved,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
// Filename: src/token/TokenType.js
// SPDX-License-Identifier: Apache-2.0

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.TokenType} HieroProto.proto.TokenType
 */

export default class TokenType {
    /**
     * @hideconstructor
     * @internal
     * @param {number} code
     */
    constructor(code) {
        /** @readonly */
        this._code = code;

        Object.freeze(this);
    }

    /**
     * @returns {string}
     */
    toString() {
        switch (this) {
            case TokenType.FungibleCommon:
                return "FUNGIBLE_COMMON";
            case TokenType.NonFungibleUnique:
                return "NON_FUNGIBLE_UNIQUE";
            default:
                return `UNKNOWN (${this._code})`;
        }
    }

    /**
     * @internal
     * @param {number} code
     * @returns {TokenType}
     */
    static _fromCode(code) {
        switch (code) {
            case 0:
                return TokenType.FungibleCommon;
            case 1:
                return TokenType.NonFungibleUnique;
        }

        throw new Error(
            `(BUG) TokenType.fromCode() does not handle code: ${code}`,
        );
    }

    /**
     * @returns {HieroProto.proto.TokenType}
     */
    valueOf() {
        return this._code;
    }
}

/**
 * Interchangeable value with one another, where any quantity of them has the
 * same value as another equal quantity if they are in the same class. Share
 * a single set of properties, not distinct from one another. Simply represented
 * as a balance or quantity to a given Hedera account.
 */
TokenType.FungibleCommon = new TokenType(0);

/**
 * Unique, not interchangeable with other tokens of the same type as they
 * typically have different values. Individually traced and can carry unique
 * properties (e.g. serial number).
 */
TokenType.NonFungibleUnique = new TokenType(1);
// Filename: src/token/TokenUnfreezeTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenUnfreezeAccountTransactionBody} HieroProto.proto.ITokenUnfreezeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Unfreeze a new Hedera™ crypto-currency token.
 */
export default class TokenUnfreezeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenUnfreezeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const unfreezeToken =
            /** @type {HieroProto.proto.ITokenUnfreezeAccountTransactionBody} */ (
                body.tokenUnfreeze
            );

        return Transaction._fromProtobufTransactions(
            new TokenUnfreezeTransaction({
                tokenId:
                    unfreezeToken.token != null
                        ? TokenId._fromProtobuf(unfreezeToken.token)
                        : undefined,
                accountId:
                    unfreezeToken.account != null
                        ? AccountId._fromProtobuf(unfreezeToken.account)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.unfreezeTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUnfreeze";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenUnfreezeAccountTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUnfreezeTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUnfreeze",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUnfreezeTransaction._fromProtobuf,
);
// Filename: src/token/TokenUnpauseTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenUnpauseTransactionBody} HieroProto.proto.ITokenUnpauseTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Unpause a new Hedera™ crypto-currency token.
 */
export default class TokenUnpauseTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenUnpauseTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const unpauseToken =
            /** @type {HieroProto.proto.ITokenUnpauseTransactionBody} */ (
                body.tokenUnpause
            );

        return Transaction._fromProtobufTransactions(
            new TokenUnpauseTransaction({
                tokenId:
                    unpauseToken.token != null
                        ? TokenId._fromProtobuf(unpauseToken.token)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.unpauseToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUnpause";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenUnpauseTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUnpauseTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUnpause",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUnpauseTransaction._fromProtobuf,
);
// Filename: src/token/TokenUpdateNftsTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenUpdateNftsTransactionBody} HieroProto.proto.ITokenUpdateNftsTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * At consensus, updates an already created Non Fungible Token to the given values.
 *
 * If no value is given for a field, that field is left unchanged.
 * Only certain fields such as metadata can be updated.
 *
 * Updating the metadata of an NFT does not affect its ownership or transferability.
 * This operation is intended for updating attributes of individual NFTs in a collection.
 */
export default class TokenUpdateNftsTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {Long[]} [props.serialNumbers]
     * @param {?Uint8Array} [props.metadata]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?Long[]}
         */
        this._serialNumbers = [];

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._metadata = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.serialNumbers != null) {
            this.setSerialNumbers(props.serialNumbers);
        }

        if (props.metadata != null) {
            this.setMetadata(props.metadata);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenUpdateNftsTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const tokenUpdate =
            /** @type {HieroProto.proto.ITokenUpdateNftsTransactionBody} */ (
                body.tokenUpdateNfts
            );

        return Transaction._fromProtobufTransactions(
            new TokenUpdateNftsTransaction({
                tokenId:
                    tokenUpdate.token != null
                        ? TokenId._fromProtobuf(tokenUpdate.token)
                        : undefined,
                serialNumbers:
                    tokenUpdate.serialNumbers != null
                        ? tokenUpdate.serialNumbers
                        : [],
                metadata:
                    tokenUpdate.metadata != null
                        ? Object.hasOwn(tokenUpdate.metadata, "value")
                            ? tokenUpdate.metadata.value
                            : undefined
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @description Assign the token id.
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @description Assign the list of serial numbers.
     * @param {Long[]} serialNumbers
     * @returns {this}
     */
    setSerialNumbers(serialNumbers) {
        this._requireNotFrozen();
        this._serialNumbers = serialNumbers;

        return this;
    }

    /**
     * @param {Uint8Array} metadata
     * @returns {this}
     */
    setMetadata(metadata) {
        this._requireNotFrozen();
        this._metadata = metadata;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.pauseToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUpdateNfts";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenUpdateNftsTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            serialNumbers:
                this._serialNumbers != null ? this._serialNumbers : [],
            ...(this._metadata != null
                ? {
                      metadata: {
                          value: this._metadata,
                      },
                  }
                : null),
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUpdateNftsTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUpdateNfts",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUpdateNftsTransaction._fromProtobuf,
);
// Filename: src/token/TokenUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import Duration from "../Duration.js";
import Key from "../Key.js";
import TokenKeyValidation from "./TokenKeyValidation.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenUpdateTransactionBody} HieroProto.proto.ITokenUpdateTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("bignumber.js").default} BigNumber
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a new Hedera™ crypto-currency token.
 */
export default class TokenUpdateTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {?string} [props.tokenName]
     * @param {?string} [props.tokenSymbol]
     * @param {AccountId | string} [props.treasuryAccountId]
     * @param {Key} [props.adminKey]
     * @param {Key} [props.kycKey]
     * @param {Key} [props.freezeKey]
     * @param {Key} [props.wipeKey]
     * @param {Key} [props.supplyKey]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {Timestamp | Date} [props.expirationTime]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {?string} [props.tokenMemo]
     * @param {Key} [props.feeScheduleKey]
     * @param {Key} [props.pauseKey]
     * @param {Key} [props.metadataKey]
     * @param {?Uint8Array} [props.metadata]
     * @param {TokenKeyValidation} [props.keyVerificationMode]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenName = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenSymbol = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._treasuryAccountId = null;

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._kycKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._freezeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._wipeKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._supplyKey = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        /**
         * @private
         * @type {?string}
         */
        this._tokenMemo = null;

        /**
         * @private
         * @type {?Key}
         */
        this._feeScheduleKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._pauseKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._metadataKey = null;

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._metadata = null;

        /**
         * @private
         * @type {?TokenKeyValidation}
         * Determines whether the system should check the validity of the passed keys for update.
         * Defaults to FULL_VALIDATION
         */
        this._keyVerificationMode = TokenKeyValidation.FullValidation;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.tokenName != null) {
            this.setTokenName(props.tokenName);
        }

        if (props.tokenSymbol != null) {
            this.setTokenSymbol(props.tokenSymbol);
        }

        if (props.treasuryAccountId != null) {
            this.setTreasuryAccountId(props.treasuryAccountId);
        }

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.kycKey != null) {
            this.setKycKey(props.kycKey);
        }

        if (props.freezeKey != null) {
            this.setFreezeKey(props.freezeKey);
        }

        if (props.wipeKey != null) {
            this.setWipeKey(props.wipeKey);
        }

        if (props.supplyKey != null) {
            this.setSupplyKey(props.supplyKey);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.tokenMemo != null) {
            this.setTokenMemo(props.tokenMemo);
        }

        if (props.feeScheduleKey != null) {
            this.setFeeScheduleKey(props.feeScheduleKey);
        }

        if (props.pauseKey != null) {
            this.setPauseKey(props.pauseKey);
        }

        if (props.metadataKey != null) {
            this.setMetadataKey(props.metadataKey);
        }

        if (props.metadata != null) {
            this.setMetadata(props.metadata);
        }

        if (props.keyVerificationMode != null) {
            this.setKeyVerificationMode(props.keyVerificationMode);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const update =
            /** @type {HieroProto.proto.ITokenUpdateTransactionBody} */ (
                body.tokenUpdate
            );

        return Transaction._fromProtobufTransactions(
            new TokenUpdateTransaction({
                tokenId:
                    update.token != null
                        ? TokenId._fromProtobuf(update.token)
                        : undefined,
                tokenName: Object.hasOwn(update, "name")
                    ? update.name
                    : undefined,
                tokenSymbol: Object.hasOwn(update, "symbol")
                    ? update.symbol
                    : undefined,
                treasuryAccountId:
                    update.treasury != null
                        ? AccountId._fromProtobuf(update.treasury)
                        : undefined,
                adminKey:
                    update.adminKey != null
                        ? Key._fromProtobufKey(update.adminKey)
                        : undefined,
                kycKey:
                    update.kycKey != null
                        ? Key._fromProtobufKey(update.kycKey)
                        : undefined,
                freezeKey:
                    update.freezeKey != null
                        ? Key._fromProtobufKey(update.freezeKey)
                        : undefined,
                wipeKey:
                    update.wipeKey != null
                        ? Key._fromProtobufKey(update.wipeKey)
                        : undefined,
                supplyKey:
                    update.supplyKey != null
                        ? Key._fromProtobufKey(update.supplyKey)
                        : undefined,
                autoRenewAccountId:
                    update.autoRenewAccount != null
                        ? AccountId._fromProtobuf(update.autoRenewAccount)
                        : undefined,
                expirationTime:
                    update.expiry != null
                        ? Timestamp._fromProtobuf(update.expiry)
                        : undefined,
                autoRenewPeriod:
                    update.autoRenewPeriod != null
                        ? Duration._fromProtobuf(update.autoRenewPeriod)
                        : undefined,
                tokenMemo:
                    update.memo != null
                        ? Object.hasOwn(update.memo, "value")
                            ? update.memo.value
                            : undefined
                        : undefined,
                feeScheduleKey:
                    update.feeScheduleKey != null
                        ? Key._fromProtobufKey(update.feeScheduleKey)
                        : undefined,
                pauseKey:
                    update.pauseKey != null
                        ? Key._fromProtobufKey(update.pauseKey)
                        : undefined,
                metadataKey:
                    update.metadataKey != null
                        ? Key._fromProtobufKey(update.metadataKey)
                        : undefined,
                metadata:
                    update.metadata != null
                        ? Object.hasOwn(update.metadata, "value")
                            ? update.metadata.value
                            : undefined
                        : undefined,
                keyVerificationMode:
                    update.keyVerificationMode != null
                        ? TokenKeyValidation._fromCode(
                              update.keyVerificationMode,
                          )
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenName() {
        return this._tokenName;
    }

    /**
     * @param {string} name
     * @returns {this}
     */
    setTokenName(name) {
        this._requireNotFrozen();
        this._tokenName = name;

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenSymbol() {
        return this._tokenSymbol;
    }

    /**
     * @param {string} symbol
     * @returns {this}
     */
    setTokenSymbol(symbol) {
        this._requireNotFrozen();
        this._tokenSymbol = symbol;

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get treasuryAccountId() {
        return this._treasuryAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setTreasuryAccountId(id) {
        this._requireNotFrozen();
        this._treasuryAccountId =
            typeof id === "string" ? AccountId.fromString(id) : id.clone();

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setAdminKey(key) {
        this._requireNotFrozen();
        this._adminKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get kycKey() {
        return this._kycKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setKycKey(key) {
        this._requireNotFrozen();
        this._kycKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get freezeKey() {
        return this._freezeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setFreezeKey(key) {
        this._requireNotFrozen();
        this._freezeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get wipeKey() {
        return this._wipeKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setWipeKey(key) {
        this._requireNotFrozen();
        this._wipeKey = key;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get supplyKey() {
        return this._supplyKey;
    }

    /**
     * @param {Key} key
     * @returns {this}
     */
    setSupplyKey(key) {
        this._requireNotFrozen();
        this._supplyKey = key;

        return this;
    }

    /**
     * @deprecated
     * @param {Key} key
     * @returns {this}
     */
    setsupplyKey(key) {
        this._requireNotFrozen();
        this._supplyKey = key;

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp | Date} time
     * @returns {this}
     */
    setExpirationTime(time) {
        this._requireNotFrozen();
        this._expirationTime =
            time instanceof Timestamp ? time : Timestamp.fromDate(time);

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} id
     * @returns {this}
     */
    setAutoRenewAccountId(id) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            id instanceof AccountId ? id : AccountId.fromString(id);

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this token.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * @returns {?string}
     */
    get tokenMemo() {
        return this._tokenMemo;
    }

    /**
     * @param {string} tokenMemo
     * @returns {this}
     */
    setTokenMemo(tokenMemo) {
        this._requireNotFrozen();
        this._tokenMemo = tokenMemo;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get feeScheduleKey() {
        return this._feeScheduleKey;
    }

    /**
     * @param {Key} feeScheduleKey
     * @returns {this}
     */
    setFeeScheduleKey(feeScheduleKey) {
        this._requireNotFrozen();
        this._feeScheduleKey = feeScheduleKey;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get pauseKey() {
        return this._pauseKey;
    }

    /**
     * @param {Key} pauseKey
     * @returns {this}
     */
    setPauseKey(pauseKey) {
        this._requireNotFrozen();
        this._pauseKey = pauseKey;
        return this;
    }

    /**
     * @returns {?Key}
     */
    get metadataKey() {
        return this._metadataKey;
    }

    /**
     * @param {Key} metadataKey
     * @returns {this}
     */
    setMetadataKey(metadataKey) {
        this._requireNotFrozen();
        this._metadataKey = metadataKey;

        return this;
    }

    /**
     * @returns {?Uint8Array}
     */
    get metadata() {
        return this._metadata;
    }

    /**
     * @param {Uint8Array} metadata
     * @returns {this}
     */
    setMetadata(metadata) {
        this._requireNotFrozen();
        this._metadata = metadata;

        return this;
    }

    /**
     * @returns {?TokenKeyValidation}
     */
    get keyVerificationMode() {
        return this._keyVerificationMode;
    }

    /**
     * @param {TokenKeyValidation} keyVerificationMode
     * @returns {this}
     */
    setKeyVerificationMode(keyVerificationMode) {
        this._requireNotFrozen();
        this._keyVerificationMode = keyVerificationMode;

        return this;
    }

    /**
     * @returns {this}
     */
    clearTokenMemo() {
        this._requireNotFrozen();
        this._tokenMemo = null;

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._treasuryAccountId != null) {
            this._treasuryAccountId.validateChecksum(client);
        }

        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.updateToken(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenUpdate";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenUpdateTransactionBody}
     */
    _makeTransactionData() {
        return {
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            name: this.tokenName != null ? this.tokenName : null,
            symbol: this.tokenSymbol,
            treasury:
                this._treasuryAccountId != null
                    ? this._treasuryAccountId._toProtobuf()
                    : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            kycKey: this._kycKey != null ? this._kycKey._toProtobufKey() : null,
            freezeKey:
                this._freezeKey != null
                    ? this._freezeKey._toProtobufKey()
                    : null,
            pauseKey:
                this._pauseKey != null ? this._pauseKey._toProtobufKey() : null,
            wipeKey:
                this._wipeKey != null ? this._wipeKey._toProtobufKey() : null,
            supplyKey:
                this._supplyKey != null
                    ? this._supplyKey._toProtobufKey()
                    : null,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            expiry:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            memo:
                this._tokenMemo != null
                    ? {
                          value: this._tokenMemo,
                      }
                    : null,
            feeScheduleKey:
                this._feeScheduleKey != null
                    ? this._feeScheduleKey._toProtobufKey()
                    : null,
            metadataKey:
                this._metadataKey != null
                    ? this._metadataKey._toProtobufKey()
                    : null,
            metadata:
                this._metadata != null
                    ? {
                          value: this._metadata,
                      }
                    : null,
            keyVerificationMode:
                this._keyVerificationMode != null
                    ? this._keyVerificationMode._code
                    : undefined,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenUpdate",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenUpdateTransaction._fromProtobuf,
);
// Filename: src/token/TokenWipeTransaction.js
// SPDX-License-Identifier: Apache-2.0

import TokenId from "./TokenId.js";
import AccountId from "../account/AccountId.js";
import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.ITokenWipeAccountTransactionBody} HieroProto.proto.ITokenWipeAccountTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITokenID} HieroProto.proto.ITokenID
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Wipe a new Hedera™ crypto-currency token.
 */
export default class TokenWipeTransaction extends Transaction {
    /**
     * @param {object} [props]
     * @param {TokenId | string} [props.tokenId]
     * @param {AccountId | string} [props.accountId]
     * @param {Long | number} [props.amount]
     * @param {(Long | number)[]} [props.serials]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TokenId}
         */
        this._tokenId = null;

        /**
         * @private
         * @type {?AccountId}
         */
        this._accountId = null;

        /**
         * @private
         * @type {?Long[]}
         */
        this._serials = [];

        /**
         * @private
         * @type {?Long}
         */
        this._amount = null;

        if (props.tokenId != null) {
            this.setTokenId(props.tokenId);
        }

        if (props.accountId != null) {
            this.setAccountId(props.accountId);
        }

        if (props.amount != null) {
            this.setAmount(props.amount);
        }

        if (props.serials != null) {
            this.setSerials(props.serials);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TokenWipeTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const wipeToken =
            /** @type {HieroProto.proto.ITokenWipeAccountTransactionBody} */ (
                body.tokenWipe
            );

        return Transaction._fromProtobufTransactions(
            new TokenWipeTransaction({
                tokenId:
                    wipeToken.token != null
                        ? TokenId._fromProtobuf(wipeToken.token)
                        : undefined,
                accountId:
                    wipeToken.account != null
                        ? AccountId._fromProtobuf(wipeToken.account)
                        : undefined,
                amount: wipeToken.amount != null ? wipeToken.amount : undefined,
                serials:
                    wipeToken.serialNumbers != null
                        ? wipeToken.serialNumbers
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TokenId}
     */
    get tokenId() {
        return this._tokenId;
    }

    /**
     * @param {TokenId | string} tokenId
     * @returns {this}
     */
    setTokenId(tokenId) {
        this._requireNotFrozen();
        this._tokenId =
            typeof tokenId === "string"
                ? TokenId.fromString(tokenId)
                : tokenId.clone();

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get accountId() {
        return this._accountId;
    }

    /**
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        this._requireNotFrozen();
        this._accountId =
            typeof accountId === "string"
                ? AccountId.fromString(accountId)
                : accountId.clone();

        return this;
    }

    /**
     * @returns {?Long}
     */
    get amount() {
        return this._amount;
    }

    /**
     * @param {Long | number} amount
     * @returns {this}
     */
    setAmount(amount) {
        this._requireNotFrozen();
        this._amount = amount instanceof Long ? amount : Long.fromValue(amount);

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._tokenId != null) {
            this._tokenId.validateChecksum(client);
        }

        if (this._accountId != null) {
            this._accountId.validateChecksum(client);
        }
    }

    /**
     * @returns {?Long[]}
     */
    get serials() {
        return this._serials;
    }

    /**
     * @param {(Long | number)[]} serials
     * @returns {this}
     */
    setSerials(serials) {
        this._requireNotFrozen();
        this._serials = serials.map((serial) =>
            typeof serial === "number" ? Long.fromNumber(serial) : serial,
        );

        return this;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.token.wipeTokenAccount(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "tokenWipe";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.ITokenWipeAccountTransactionBody}
     */
    _makeTransactionData() {
        return {
            amount: this._amount,
            token: this._tokenId != null ? this._tokenId._toProtobuf() : null,
            account:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            serialNumbers: this.serials,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TokenWipeTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "tokenWipe",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TokenWipeTransaction._fromProtobuf,
);
// Filename: src/topic/SubscriptionHandle.js
// SPDX-License-Identifier: Apache-2.0

/**
 * Represents a handle for managing subscriptions to topics in the Hedera network.
 *
 * The `SubscriptionHandle` class provides methods to manage the lifecycle of a subscription,
 * including setting a callback function to be executed when an event occurs and unsubscribing
 * from the topic notifications. It is primarily used for handling real-time updates from the
 * Hedera network like topic subscriptions.
 */
export default class SubscriptionHandle {
    constructor() {
        /** @type {{(): void} | null} */
        this._call = null;

        /** @type {boolean} */
        this._unsubscribed = false;
    }

    /**
     * @param {() => void} call
     * @returns {void}
     */
    _setCall(call) {
        this._call = call;
    }

    unsubscribe() {
        if (this._call != null) {
            this._unsubscribed = true;
            this._call();
        }
    }
}
// Filename: src/topic/TopicCreateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import CustomFixedFee from "../token/CustomFixedFee.js";
import Transaction, {
    DEFAULT_AUTO_RENEW_PERIOD,
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import Duration from "../Duration.js";
import Key from "../Key.js";
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IConsensusCreateTopicTransactionBody} HieroProto.proto.IConsensusCreateTopicTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Create a topic to be used for consensus.
 */
export default class TopicCreateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {Key} [props.adminKey]
     * @param {Key} [props.submitKey]
     * @param {Key} [props.feeScheduleKey]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {CustomFixedFee[]} [props.customFees]
     * @param {Key[]} [props.feeExemptKeys]
     * @param {string} [props.topicMemo]
     */
    constructor(props = {}) {
        super();

        this._defaultMaxTransactionFee = new Hbar(25);

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._submitKey = null;

        /**
         * @private
         * @type {?Key}
         */
        this._feeScheduleKey = null;

        /**
         * @private
         * @type {Key[]}
         */
        this._feeExemptKeys = [];

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        /**
         * @private
         * @type {Duration}
         */
        this._autoRenewPeriod = new Duration(DEFAULT_AUTO_RENEW_PERIOD);

        /**
         * @private
         * @type {CustomFixedFee[]}
         */
        this._customFees = [];

        /**
         * @private
         * @type {?string}
         */
        this._topicMemo = null;

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }

        if (props.submitKey != null) {
            this.setSubmitKey(props.submitKey);
        }

        if (props.feeScheduleKey != null) {
            this.setFeeScheduleKey(props.feeScheduleKey);
        }

        if (props.feeExemptKeys != null) {
            this.setFeeExemptKeys(props.feeExemptKeys);
        }

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        if (props.customFees != null) {
            this.setCustomFees(props.customFees);
        }

        if (props.topicMemo != null) {
            this.setTopicMemo(props.topicMemo);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TopicCreateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const create =
            /** @type {HieroProto.proto.IConsensusCreateTopicTransactionBody} */ (
                body.consensusCreateTopic
            );

        return Transaction._fromProtobufTransactions(
            new TopicCreateTransaction({
                adminKey:
                    create.adminKey != null
                        ? Key._fromProtobufKey(create.adminKey)
                        : undefined,
                submitKey:
                    create.submitKey != null
                        ? Key._fromProtobufKey(create.submitKey)
                        : undefined,
                feeScheduleKey:
                    create.feeScheduleKey != null
                        ? Key._fromProtobufKey(create.feeScheduleKey)
                        : undefined,
                feeExemptKeys:
                    create.feeExemptKeyList != null
                        ? create.feeExemptKeyList.map((key) =>
                              Key._fromProtobufKey(key),
                          )
                        : undefined,
                autoRenewAccountId:
                    create.autoRenewAccount != null
                        ? AccountId._fromProtobuf(create.autoRenewAccount)
                        : undefined,
                autoRenewPeriod:
                    create.autoRenewPeriod != null
                        ? create.autoRenewPeriod.seconds != null
                            ? create.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                customFees:
                    create.customFees != null
                        ? create.customFees.map((customFee) =>
                              CustomFixedFee._fromProtobuf(customFee),
                          )
                        : undefined,
                topicMemo: create.memo != null ? create.memo : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @deprecated  - Use `getTopicMemo()` instead
     * @returns {?string}
     */
    get topicMemo() {
        return this._topicMemo;
    }

    /**
     * @returns {?string}
     */
    getTopicMemo() {
        return this._topicMemo;
    }

    /**
     * @param {string} topicMemo
     * @returns {this}
     */
    setTopicMemo(topicMemo) {
        this._requireNotFrozen();
        this._topicMemo = topicMemo;

        return this;
    }

    /**
     * @deprecated  - Use `getAdminKey()` instead
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @returns {?Key}
     */
    getAdminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {this}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @deprecated  - Use `getSubmitKey()` instead
     * @returns {?Key}
     */
    get submitKey() {
        return this._submitKey;
    }

    /**
     * @returns {?Key}
     */
    getSubmitKey() {
        return this._submitKey;
    }

    /**
     * @param {Key} submitKey
     * @returns {this}
     */
    setSubmitKey(submitKey) {
        this._requireNotFrozen();
        this._submitKey = submitKey;

        return this;
    }

    /**
     * Returns the key which allows updates to the new topic’s fees.
     * @returns {?Key}
     */
    getFeeScheduleKey() {
        return this._feeScheduleKey;
    }

    /**
     * Sets the key which allows updates to the new topic’s fees.
     * @param {Key} feeScheduleKey
     * @returns {this}
     */
    setFeeScheduleKey(feeScheduleKey) {
        this._requireNotFrozen();
        this._feeScheduleKey = feeScheduleKey;

        return this;
    }

    /**
     * Returns the keys that will be exempt from paying fees.
     * @returns {Key[]}
     */
    getFeeExemptKeys() {
        return this._feeExemptKeys;
    }

    /**
     * Sets the keys that will be exempt from paying fees.
     * @param {Key[]} feeExemptKeys
     * @returns {this}
     */
    setFeeExemptKeys(feeExemptKeys) {
        this._requireNotFrozen();
        this._feeExemptKeys = feeExemptKeys;

        return this;
    }

    /**
     * Adds a key that will be exempt from paying fees.
     * @param {Key} key
     * @returns {this}
     */
    addFeeExemptKey(key) {
        this._requireNotFrozen();
        this._feeExemptKeys.push(key);

        return this;
    }

    /**
     * Clears all keys that will be exempt from paying fees.
     * @returns {this}
     */
    clearFeeExemptKeys() {
        this._requireNotFrozen();
        this._feeExemptKeys = [];

        return this;
    }

    /**
     * @deprecated  - Use `getAutoRenewAccountId()` instead
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @returns {?AccountId}
     */
    getAutoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} autoRenewAccountId
     * @returns {this}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            autoRenewAccountId instanceof AccountId
                ? autoRenewAccountId
                : AccountId.fromString(autoRenewAccountId);

        return this;
    }

    /**
     * @deprecated  - Use `getAutoRenewPeriod()` instead
     * @returns {Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * @returns {Duration}
     */
    getAutoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {this}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * Returns the fixed fees to assess when a message is submitted to the new topic.
     * @returns {CustomFixedFee[]}
     */
    getCustomFees() {
        return this._customFees;
    }

    /**
     * Sets the fixed fees to assess when a message is submitted to the new topic.
     *
     * @param {CustomFixedFee[]} customFees
     * @returns {this}
     */
    setCustomFees(customFees) {
        this._requireNotFrozen();
        this._customFees = customFees;

        return this;
    }

    /**
     * Adds fixed fee to assess when a message is submitted to the new topic.
     *
     * @param {CustomFixedFee} customFee
     * @returns {this}
     */
    addCustomFee(customFee) {
        this._requireNotFrozen();

        this._customFees.push(customFee);

        return this;
    }

    /**
     * Clears fixed fees.
     *
     * @returns {this}
     */
    clearCustomFees() {
        this._requireNotFrozen();

        this._customFees = [];

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        if (!this._autoRenewAccountId && this.transactionId?.accountId) {
            this.setAutoRenewAccountId(this.transactionId?.accountId);
        } else if (!this._autoRenewAccountId && client?.operatorAccountId) {
            this.setAutoRenewAccountId(client.operatorAccountId);
        }
        return super.freezeWith(client);
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.createTopic(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusCreateTopic";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IConsensusCreateTopicTransactionBody}
     */
    _makeTransactionData() {
        return {
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            submitKey:
                this._submitKey != null
                    ? this._submitKey._toProtobufKey()
                    : null,
            feeScheduleKey:
                this._feeScheduleKey != null
                    ? this._feeScheduleKey._toProtobufKey()
                    : null,
            feeExemptKeyList: this._feeExemptKeys.map((key) =>
                key._toProtobufKey(),
            ),
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            autoRenewPeriod: this._autoRenewPeriod._toProtobuf(),
            customFees: this._customFees.map((customFee) =>
                customFee._toTopicFeeProtobuf(),
            ),
            memo: this._topicMemo,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicCreateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusCreateTopic",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicCreateTransaction._fromProtobuf,
);
// Filename: src/topic/TopicDeleteTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import TopicId from "./TopicId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IConsensusDeleteTopicTransactionBody} HieroProto.proto.IConsensusDeleteTopicTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Delete a topic.
 *
 * No more transactions or queries on the topic will succeed.
 *
 * If an adminKey is set, this transaction must be signed by that key.
 * If there is no adminKey, this transaction will fail with Status#Unautorized.
 */
export default class TopicDeleteTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TopicDeleteTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const topicDelete =
            /** @type {HieroProto.proto.IConsensusDeleteTopicTransactionBody} */ (
                body.consensusDeleteTopic
            );

        return Transaction._fromProtobufTransactions(
            new TopicDeleteTransaction({
                topicId:
                    topicDelete.topicID != null
                        ? TopicId._fromProtobuf(topicDelete.topicID)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * Set the topic ID which is being deleted in this transaction.
     *
     * @param {TopicId | string} topicId
     * @returns {TopicDeleteTransaction}
     */
    setTopicId(topicId) {
        this._requireNotFrozen();
        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._topicId != null) {
            this._topicId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.deleteTopic(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusDeleteTopic";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IConsensusDeleteTopicTransactionBody}
     */
    _makeTransactionData() {
        return {
            topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicDeleteTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusDeleteTopic",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicDeleteTransaction._fromProtobuf,
);
// Filename: src/topic/TopicId.js
// SPDX-License-Identifier: Apache-2.0

import * as entity_id from "../EntityIdHelper.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @typedef {import("long")} Long
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Unique identifier for a topic (used by the consensus service).
 */
export default class TopicId {
    /**
     * @param {number | Long | import("../EntityIdHelper").IEntityId} props
     * @param {(number | Long)=} realm
     * @param {(number | Long)=} num
     */
    constructor(props, realm, num) {
        const result = entity_id.constructor(props, realm, num);

        this.shard = result.shard;
        this.realm = result.realm;
        this.num = result.num;

        /**
         * @type {string | null}
         */
        this._checksum = null;
    }

    /**
     * @param {string} text
     * @returns {TopicId}
     */
    static fromString(text) {
        const result = entity_id.fromString(text);
        const id = new TopicId(result);
        id._checksum = result.checksum;
        return id;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITopicID} id
     * @returns {TopicId}
     */
    static _fromProtobuf(id) {
        const topicId = new TopicId(
            id.shardNum != null ? id.shardNum : 0,
            id.realmNum != null ? id.realmNum : 0,
            id.topicNum != null ? id.topicNum : 0,
        );

        return topicId;
    }

    /**
     * @returns {string | null}
     */
    get checksum() {
        return this._checksum;
    }

    /**
     * @deprecated - Use `validateChecksum` instead
     * @param {Client} client
     */
    validate(client) {
        console.warn("Deprecated: Use `validateChecksum` instead");
        this.validateChecksum(client);
    }

    /**
     * @param {Client} client
     */
    validateChecksum(client) {
        entity_id.validateChecksum(
            this.shard,
            this.realm,
            this.num,
            this._checksum,
            client,
        );
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TopicId}
     */
    static fromBytes(bytes) {
        return TopicId._fromProtobuf(HieroProto.proto.TopicID.decode(bytes));
    }

    /**
     * @param {string} address
     * @returns {TopicId}
     */
    static fromSolidityAddress(address) {
        const [shard, realm, topic] = entity_id.fromSolidityAddress(address);
        return new TopicId(shard, realm, topic);
    }

    /**
     * @returns {string}
     */
    toSolidityAddress() {
        return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);
    }

    /**
     * @returns {HieroProto.proto.ITopicID}
     */
    _toProtobuf() {
        return {
            topicNum: this.num,
            shardNum: this.shard,
            realmNum: this.realm,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
    }

    /**
     * @param {Client} client
     * @returns {string}
     */
    toStringWithChecksum(client) {
        return entity_id.toStringWithChecksum(this.toString(), client);
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TopicID.encode(this._toProtobuf()).finish();
    }

    /**
     * @returns {TopicId}
     */
    clone() {
        const id = new TopicId(this);
        id._checksum = this._checksum;
        return id;
    }

    /**
     * @param {TopicId} other
     * @returns {number}
     */
    compare(other) {
        return entity_id.compare(
            [this.shard, this.realm, this.num],
            [other.shard, other.realm, other.num],
        );
    }
}
// Filename: src/topic/TopicInfo.js
// SPDX-License-Identifier: Apache-2.0

import TopicId from "./TopicId.js";
import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import Long from "long";
import Duration from "../Duration.js";
import * as HieroProto from "@hashgraph/proto";
import Key from "../Key.js";
import LedgerId from "../LedgerId.js";
import CustomFixedFee from "../token/CustomFixedFee.js";

/**
 * Current state of a topic.
 */
export default class TopicInfo {
    /**
     * @private
     * @param {object} props
     * @param {TopicId} props.topicId
     * @param {string} props.topicMemo
     * @param {Uint8Array} props.runningHash
     * @param {Long} props.sequenceNumber
     * @param {?Timestamp} props.expirationTime
     * @param {?Key} props.adminKey
     * @param {?Key} props.submitKey
     * @param {?Key} props.feeScheduleKey
     * @param {?Key[]} props.feeExemptKeys
     * @param {?Duration} props.autoRenewPeriod
     * @param {?AccountId} props.autoRenewAccountId
     * @param {?CustomFixedFee[]} props.customFees
     * @param {LedgerId|null} props.ledgerId
     */
    constructor(props) {
        /**
         * The ID of the topic for which information is requested.
         *
         * @readonly
         */
        this.topicId = props.topicId;

        /**
         * Short publicly visible memo about the topic. No guarantee of uniqueness.
         *
         * @readonly
         */
        this.topicMemo = props.topicMemo;

        /**
         * SHA-384 running hash of (previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message).
         *
         * @readonly
         */
        this.runningHash = props.runningHash;

        /**
         * Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
         *
         * @readonly
         */
        this.sequenceNumber = props.sequenceNumber;

        /**
         * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic.
         *
         * @readonly
         */
        this.expirationTime = props.expirationTime;

        /**
         * Access control for update/delete of the topic. Null if there is no key.
         *
         * @readonly
         */
        this.adminKey = props.adminKey;

        /**
         * Access control for ConsensusService.submitMessage. Null if there is no key.
         *
         * @readonly
         */
        this.submitKey = props.submitKey;

        /**
         * Access control for updating topic fees. Null If there is no key.
         *
         * @readonly
         */
        this.feeScheduleKey = props.feeScheduleKey;

        /**
         * The keys that will are exempt from paying fees.
         * @readonly
         */
        this.feeExemptKeys = props.feeExemptKeys;
        /**
         * @readonly
         */
        this.autoRenewPeriod = props.autoRenewPeriod;

        /**
         * @readonly
         */
        this.autoRenewAccountId = props.autoRenewAccountId;

        /**
         * The fixed fees assessed when a message is submitted to the topic.
         * @readonly
         */
        this.customFees = props.customFees;

        this.ledgerId = props.ledgerId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {HieroProto.proto.IConsensusGetTopicInfoResponse} infoResponse
     * @returns {TopicInfo}
     */
    static _fromProtobuf(infoResponse) {
        const info = /** @type {HieroProto.proto.IConsensusTopicInfo} */ (
            infoResponse.topicInfo
        );

        return new TopicInfo({
            topicId: TopicId._fromProtobuf(
                /** @type {HieroProto.proto.ITopicID} */ (infoResponse.topicID),
            ),
            topicMemo: info.memo != null ? info.memo : "",
            runningHash:
                info.runningHash != null ? info.runningHash : new Uint8Array(),
            sequenceNumber:
                info.sequenceNumber != null
                    ? info.sequenceNumber instanceof Long
                        ? info.sequenceNumber
                        : Long.fromValue(info.sequenceNumber)
                    : Long.ZERO,
            expirationTime:
                info.expirationTime != null
                    ? Timestamp._fromProtobuf(info.expirationTime)
                    : null,
            adminKey:
                info.adminKey != null
                    ? Key._fromProtobufKey(info.adminKey)
                    : null,
            submitKey:
                info.submitKey != null
                    ? Key._fromProtobufKey(info.submitKey)
                    : null,
            feeScheduleKey:
                info.feeScheduleKey != null
                    ? Key._fromProtobufKey(info.feeScheduleKey)
                    : null,
            feeExemptKeys:
                info.feeExemptKeyList != null
                    ? info.feeExemptKeyList.map((key) =>
                          Key._fromProtobufKey(key),
                      )
                    : null,
            autoRenewPeriod:
                info.autoRenewPeriod != null
                    ? new Duration(
                          /** @type {Long} */ (info.autoRenewPeriod.seconds),
                      )
                    : null,
            autoRenewAccountId:
                info.autoRenewAccount != null
                    ? AccountId._fromProtobuf(info.autoRenewAccount)
                    : null,
            customFees:
                info.customFees != null
                    ? info.customFees.map((customFee) =>
                          CustomFixedFee._fromProtobuf(customFee),
                      )
                    : null,
            ledgerId:
                info.ledgerId != null
                    ? LedgerId.fromBytes(info.ledgerId)
                    : null,
        });
    }

    /**
     * @internal
     * @returns {HieroProto.proto.IConsensusGetTopicInfoResponse}
     */
    _toProtobuf() {
        return {
            topicID: this.topicId._toProtobuf(),
            topicInfo: {
                memo: this.topicMemo,
                runningHash: this.runningHash,
                sequenceNumber: this.sequenceNumber,
                expirationTime:
                    this.expirationTime != null
                        ? this.expirationTime._toProtobuf()
                        : null,
                adminKey:
                    this.adminKey != null
                        ? this.adminKey._toProtobufKey()
                        : null,
                submitKey:
                    this.submitKey != null
                        ? this.submitKey._toProtobufKey()
                        : null,
                feeScheduleKey:
                    this.feeScheduleKey != null
                        ? this.feeScheduleKey._toProtobufKey()
                        : null,
                feeExemptKeyList:
                    this.feeExemptKeys != null
                        ? this.feeExemptKeys.map((key) => key._toProtobufKey())
                        : null,
                autoRenewPeriod:
                    this.autoRenewPeriod != null
                        ? this.autoRenewPeriod._toProtobuf()
                        : null,
                autoRenewAccount:
                    this.autoRenewAccountId != null
                        ? this.autoRenewAccountId._toProtobuf()
                        : null,
                customFees:
                    this.customFees != null
                        ? this.customFees.map((customFee) =>
                              customFee._toProtobuf(),
                          )
                        : null,
            },
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TopicInfo}
     */
    static fromBytes(bytes) {
        return TopicInfo._fromProtobuf(
            HieroProto.proto.ConsensusGetTopicInfoResponse.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.ConsensusGetTopicInfoResponse.encode(
            /** @type {HieroProto.proto.ConsensusGetTopicInfoResponse} */ (
                this._toProtobuf()
            ),
        ).finish();
    }
}
// Filename: src/topic/TopicInfoQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import TopicId from "./TopicId.js";
import TopicInfo from "./TopicInfo.js";
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import Hbar from "../Hbar.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IQuery} HieroProto.proto.IQuery
 * @typedef {import("@hashgraph/proto").proto.IQueryHeader} HieroProto.proto.IQueryHeader
 * @typedef {import("@hashgraph/proto").proto.IResponse} HieroProto.proto.IResponse
 * @typedef {import("@hashgraph/proto").proto.IResponseHeader} HieroProto.proto.IResponseHeader
 * @typedef {import("@hashgraph/proto").proto.IConsensusGetTopicInfoResponse} HieroProto.proto.IConsensusGetTopicInfoResponse
 * @typedef {import("@hashgraph/proto").proto.IConsensusGetTopicInfoQuery} HieroProto.proto.IConsensusGetTopicInfoQuery
 */

/**
 * @namespace com
 * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Retrieve the latest state of a topic.
 *
 * @augments {Query<TopicInfo>}
 */
export default class TopicInfoQuery extends Query {
    /**
     * @param {object} [props]
     * @param {TopicId | string} [props.topicId]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {TopicInfoQuery}
     */
    static _fromProtobuf(query) {
        const info =
            /** @type {HieroProto.proto.IConsensusGetTopicInfoQuery} */ (
                query.consensusGetTopicInfo
            );

        return new TopicInfoQuery({
            topicId:
                info.topicID != null
                    ? TopicId._fromProtobuf(info.topicID)
                    : undefined,
        });
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * Set the topic ID for which the info is being requested.
     *
     * @param {TopicId | string} topicId
     * @returns {TopicInfoQuery}
     */
    setTopicId(topicId) {
        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @override
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<Hbar>}
     */
    async getCost(client) {
        return super.getCost(client);
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._topicId != null) {
            this._topicId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.getTopicInfo(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const consensusGetTopicInfo =
            /** @type {HieroProto.proto.IConsensusGetTopicInfoResponse} */ (
                response.consensusGetTopicInfo
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            consensusGetTopicInfo.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<TopicInfo>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        return Promise.resolve(
            TopicInfo._fromProtobuf(
                /** @type {HieroProto.proto.IConsensusGetTopicInfoResponse} */ (
                    response.consensusGetTopicInfo
                ),
            ),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            consensusGetTopicInfo: {
                header,
                topicID:
                    this._topicId != null ? this._topicId._toProtobuf() : null,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TopicInfoQuery:${timestamp.toString()}`;
    }
}

// eslint-disable-next-line @typescript-eslint/unbound-method
QUERY_REGISTRY.set("consensusGetTopicInfo", TopicInfoQuery._fromProtobuf);
// Filename: src/topic/TopicMessage.js
// SPDX-License-Identifier: Apache-2.0

import Timestamp from "../Timestamp.js";
import TopicMessageChunk from "./TopicMessageChunk.js";
import Long from "long";
import TransactionId from "../transaction/TransactionId.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
 */

/**
 * @namespace com
 * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
 */

export default class TopicMessage {
    /**
     * @private
     * @param {object} props
     * @param {Timestamp} props.consensusTimestamp
     * @param {Uint8Array} props.contents
     * @param {Uint8Array} props.runningHash
     * @param {Long} props.sequenceNumber
     * @param {?TransactionId} props.initialTransactionId
     * @param {TopicMessageChunk[]} props.chunks
     */
    constructor(props) {
        /** @readonly */
        this.consensusTimestamp = props.consensusTimestamp;
        /** @readonly */
        this.contents = props.contents;
        /** @readonly */
        this.runningHash = props.runningHash;
        /** @readonly */
        this.sequenceNumber = props.sequenceNumber;
        /** @readonly */
        this.chunks = props.chunks;
        /** @readonly */
        this.initialTransactionId = props.initialTransactionId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} response
     * @returns {TopicMessage}
     */
    static _ofSingle(response) {
        return new TopicMessage({
            consensusTimestamp: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */
                (response.consensusTimestamp),
            ),
            contents:
                response.message != null ? response.message : new Uint8Array(),
            runningHash:
                response.runningHash != null
                    ? response.runningHash
                    : new Uint8Array(),
            sequenceNumber:
                response.sequenceNumber != null
                    ? response.sequenceNumber instanceof Long
                        ? response.sequenceNumber
                        : Long.fromNumber(response.sequenceNumber)
                    : Long.ZERO,
            initialTransactionId:
                response.chunkInfo != null &&
                response.chunkInfo.initialTransactionID != null
                    ? TransactionId._fromProtobuf(
                          response.chunkInfo.initialTransactionID,
                      )
                    : null,
            chunks: [TopicMessageChunk._fromProtobuf(response)],
        });
    }

    /**
     * @internal
     * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse[]} responses
     * @returns {TopicMessage}
     */
    static _ofMany(responses) {
        const length = responses.length;

        const last =
            /** @type {com.hedera.mirror.api.proto.IConsensusTopicResponse} */ (
                responses[length - 1]
            );

        const consensusTimestamp = Timestamp._fromProtobuf(
            /** @type {HieroProto.proto.ITimestamp} */
            (last.consensusTimestamp),
        );

        const runningHash = /** @type {Uint8Array} */ (last.runningHash);

        /**
         * @type {Long}
         */
        const sequenceNumber =
            last.sequenceNumber != null
                ? last.sequenceNumber instanceof Long
                    ? last.sequenceNumber
                    : Long.fromValue(last.sequenceNumber)
                : Long.ZERO;

        responses.sort((a, b) =>
            (a != null
                ? a.chunkInfo != null
                    ? a.chunkInfo.number != null
                        ? a.chunkInfo.number
                        : 0
                    : 0
                : 0) <
            (b != null
                ? b.chunkInfo != null
                    ? b.chunkInfo.number != null
                        ? b.chunkInfo.number
                        : 0
                    : 0
                : 0)
                ? -1
                : 1,
        );

        /**
         * @type {TopicMessageChunk[]}
         */
        const chunks = responses.map(
            /**
             * @type {com.hedera.mirror.api.proto.IConsensusTopicResponse}
             */ (m) => TopicMessageChunk._fromProtobuf(m),
        );

        const size = chunks
            .map((chunk) => chunk.contents.length)
            .reduce((sum, current) => sum + current, 0);

        const contents = new Uint8Array(size);
        let offset = 0;

        responses.forEach((value) => {
            contents.set(/** @type {Uint8Array} */ (value.message), offset);
            offset += /** @type {Uint8Array} */ (value.message).length;
        });

        let initialTransactionId = null;
        if (
            responses.length > 0 &&
            responses[0].chunkInfo != null &&
            responses[0].chunkInfo.initialTransactionID != null
        ) {
            initialTransactionId = TransactionId._fromProtobuf(
                responses[0].chunkInfo.initialTransactionID,
            );
        }

        return new TopicMessage({
            consensusTimestamp,
            contents,
            runningHash,
            sequenceNumber,
            chunks,
            initialTransactionId,
        });
    }
}
// Filename: src/topic/TopicMessageChunk.js
// SPDX-License-Identifier: Apache-2.0

import Timestamp from "../Timestamp.js";
import Long from "long";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITimestamp} HieroProto.proto.ITimestamp
 */

/**
 * @namespace com
 * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
 */

export default class TopicMessageChunk {
    /**
     * @private
     * @param {object} props
     * @param {Timestamp} props.consensusTimestamp
     * @param {Uint8Array} props.contents
     * @param {Uint8Array} props.runningHash
     * @param {Long} props.sequenceNumber
     */
    constructor(props) {
        /** @readonly */
        this.consensusTimestamp = props.consensusTimestamp;
        /** @readonly */
        this.contents = props.contents;
        /** @readonly */
        this.runningHash = props.runningHash;
        /** @readonly */
        this.sequenceNumber = props.sequenceNumber;

        Object.freeze(this);
    }

    /**
     * @internal
     * @param {com.hedera.mirror.api.proto.IConsensusTopicResponse} response
     * @returns {TopicMessageChunk}
     */
    static _fromProtobuf(response) {
        return new TopicMessageChunk({
            consensusTimestamp: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */
                (response.consensusTimestamp),
            ),
            contents:
                response.message != null ? response.message : new Uint8Array(),
            runningHash:
                response.runningHash != null
                    ? response.runningHash
                    : new Uint8Array(),
            sequenceNumber:
                response.sequenceNumber != null
                    ? response.sequenceNumber instanceof Long
                        ? response.sequenceNumber
                        : Long.fromValue(response.sequenceNumber)
                    : Long.ZERO,
        });
    }

    /**
     * @internal
     * @returns {com.hedera.mirror.api.proto.IConsensusTopicResponse}
     */
    _toProtobuf() {
        return {
            consensusTimestamp: this.consensusTimestamp._toProtobuf(),
            message: this.contents,
            runningHash: this.runningHash,
            sequenceNumber: this.sequenceNumber,
        };
    }
}
// Filename: src/topic/TopicMessageQuery.js
// SPDX-License-Identifier: Apache-2.0

import TransactionId from "../transaction/TransactionId.js";
import SubscriptionHandle from "./SubscriptionHandle.js";
import TopicMessage from "./TopicMessage.js";
import * as HieroProto from "@hashgraph/proto";
import TopicId from "./TopicId.js";
import Long from "long";
import Timestamp from "../Timestamp.js";
import { RST_STREAM } from "../Executable.js";

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 * @typedef {import("../channel/MirrorChannel.js").MirrorError} MirrorError
 */

/**
 * @template {Channel} ChannelT
 * @typedef {import("../client/Client.js").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>
 */

/**
 * Represents a class that you can use to subscribe to
 * different topics on Hedera network.
 * @augments {Query<TopicMessageQuery>}
 */
export default class TopicMessageQuery {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     * @param {Timestamp} [props.startTime]
     * @param {Timestamp} [props.endTime]
     * @param {(message: TopicMessage | null, error: Error)=> void} [props.errorHandler]
     * @param {() => void} [props.completionHandler]
     * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]
     * @param {Long | number} [props.limit]
     */
    constructor(props = {}) {
        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;
        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }

        /**
         * @private
         * @type {?Timestamp}
         */
        this._startTime = null;
        if (props.startTime != null) {
            this.setStartTime(props.startTime);
        }

        /**
         * @private
         * @type {?Timestamp}
         */
        this._endTime = null;
        if (props.endTime != null) {
            this.setEndTime(props.endTime);
        }

        /**
         * @private
         * @type {?Long}
         */
        this._limit = null;
        if (props.limit != null) {
            this.setLimit(props.limit);
        }

        /**
         * @private
         * @type {(message: TopicMessage | null, error: Error) => void}
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this._errorHandler = (message, error) => {
            console.error(
                `Error attempting to subscribe to topic: ${
                    this._topicId != null ? this._topicId.toString() : ""
                }`,
            );
        };

        if (props.errorHandler != null) {
            this._errorHandler = props.errorHandler;
        }

        /*
         * @private
         * @type {((message: TopicMessage) => void) | null}
         */
        this._listener = null;

        /**
         * @private
         * @type {() => void}
         */
        this._completionHandler = () => {
            console.log(
                `Subscription to topic ${
                    this._topicId != null ? this._topicId.toString() : ""
                } complete`,
            );
        };

        if (props.completionHandler != null) {
            this._completionHandler = props.completionHandler;
        }

        /* The number of times we can retry the grpc call
         *
         * @internal
         * @type {number}
         */
        this._maxAttempts = 20;

        /**
         * This is the request's max backoff
         *
         * @internal
         * @type {number}
         */
        this._maxBackoff = 8000;

        /**
         * @private
         * @type {(error: MirrorError | Error | null) => boolean}
         */
        this._retryHandler = (error) => {
            if (error != null) {
                if (error instanceof Error) {
                    // Retry on all errors which are not `MirrorError` because they're
                    // likely lower level HTTP/2 errors
                    return true;
                } else {
                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`
                    // if the message matches the right regex.
                    switch (error.code) {
                        // INTERNAL
                        // eslint-disable-next-line no-fallthrough
                        case 13:
                            return RST_STREAM.test(error.details.toString());
                        // NOT_FOUND
                        // eslint-disable-next-line no-fallthrough
                        case 5:
                        // RESOURCE_EXHAUSTED
                        // eslint-disable-next-line no-fallthrough
                        case 8:
                        // UNAVAILABLE
                        // eslint-disable-next-line no-fallthrough
                        case 14:
                        case 17:
                            return true;
                        default:
                            return false;
                    }
                }
            }

            return false;
        };

        if (props.retryHandler != null) {
            this._retryHandler = props.retryHandler;
        }

        /**
         * @private
         * @type {number}
         */
        this._attempt = 0;

        /**
         * @private
         * @type {SubscriptionHandle | null}
         */
        this._handle = null;

        this.setMaxBackoff(8000);
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * @param {TopicId | string} topicId
     * @returns {TopicMessageQuery}
     */
    setTopicId(topicId) {
        this.requireNotSubscribed();

        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get startTime() {
        return this._startTime;
    }

    /**
     * @param {Timestamp | Date | number} startTime
     * @returns {TopicMessageQuery}
     */
    setStartTime(startTime) {
        this.requireNotSubscribed();

        this._startTime =
            startTime instanceof Timestamp
                ? startTime
                : startTime instanceof Date
                  ? Timestamp.fromDate(startTime)
                  : new Timestamp(startTime, 0);
        return this;
    }

    /**
     * @returns {?Timestamp}
     */
    get endTime() {
        return this._endTime;
    }

    /**
     * @param {Timestamp | Date | number} endTime
     * @returns {TopicMessageQuery}
     */
    setEndTime(endTime) {
        this.requireNotSubscribed();

        this._endTime =
            endTime instanceof Timestamp
                ? endTime
                : endTime instanceof Date
                  ? Timestamp.fromDate(endTime)
                  : new Timestamp(endTime, 0);
        return this;
    }

    /**
     * @returns {?Long}
     */
    get limit() {
        return this._limit;
    }

    /**
     * @param {Long | number} limit
     * @returns {TopicMessageQuery}
     */
    setLimit(limit) {
        this.requireNotSubscribed();

        this._limit = limit instanceof Long ? limit : Long.fromValue(limit);

        return this;
    }

    /**
     * @param {(message: TopicMessage | null, error: Error)=> void} errorHandler
     * @returns {TopicMessageQuery}
     */
    setErrorHandler(errorHandler) {
        this._errorHandler = errorHandler;

        return this;
    }

    /**
     * @param {() => void} completionHandler
     * @returns {TopicMessageQuery}
     */
    setCompletionHandler(completionHandler) {
        this.requireNotSubscribed();

        this._completionHandler = completionHandler;

        return this;
    }

    /**
     * @param {number} attempts
     * @returns {this}
     */
    setMaxAttempts(attempts) {
        this.requireNotSubscribed();
        this._maxAttempts = attempts;
        return this;
    }

    /**
     * @param {number} backoff
     * @returns {this}
     */
    setMaxBackoff(backoff) {
        this.requireNotSubscribed();
        this._maxBackoff = backoff;
        return this;
    }

    /**
     * @param {Client<Channel>} client
     * @param {((message: TopicMessage | null, error: Error) => void) | null} errorHandler
     * @param {(message: TopicMessage) => void} listener
     * @returns {SubscriptionHandle}
     */
    subscribe(client, errorHandler, listener) {
        this._handle = new SubscriptionHandle();
        this._listener = listener;

        if (errorHandler != null) {
            this._errorHandler = errorHandler;
        }

        this._makeServerStreamRequest(client);

        return this._handle;
    }

    /**
     * Makes a server stream request to subscribe to topic messages
     * @private
     * @param {Client<Channel>} client
     * @returns {void}
     */
    _makeServerStreamRequest(client) {
        const request = this._buildConsensusRequest();
        /** @type {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} */
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const list = new Map();

        const streamHandler = client._mirrorNetwork
            .getNextMirrorNode()
            .getChannel()
            .makeServerStreamRequest(
                "ConsensusService",
                "subscribeTopic",
                request,
                (data) => this._handleMessage(data, list),
                (error) => this._handleError(error, client),
                this._completionHandler,
            );

        if (this._handle != null) {
            this._handle._setCall(() => streamHandler());
        }
    }

    requireNotSubscribed() {
        if (this._handle != null) {
            throw new Error(
                "Cannot change fields on an already subscribed query",
            );
        }
    }

    /**
     * @private
     * @param {TopicMessage} topicMessage
     */
    _passTopicMessage(topicMessage) {
        try {
            if (this._listener != null) {
                this._listener(topicMessage);
            } else {
                throw new Error("(BUG) listener is unexpectedly not set");
            }
        } catch (error) {
            this._errorHandler(topicMessage, /** @type {Error} */ (error));
        }
    }

    /**
     * Builds the consensus topic query request
     * @private
     * @returns {Uint8Array} Encoded consensus topic query
     */
    _buildConsensusRequest() {
        return HieroProto.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode(
            {
                topicID: this._topicId?._toProtobuf() ?? null,
                consensusStartTime: this._startTime?._toProtobuf() ?? null,
                consensusEndTime: this._endTime?._toProtobuf() ?? null,
                limit: this._limit,
            },
        ).finish();
    }

    /**
     * Handles an incoming message from the topic subscription
     * @private
     * @param {Uint8Array} data - Raw message data
     * @param {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} list
     */
    _handleMessage(data, list) {
        const message =
            HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(
                data,
            );

        if (this._limit?.gt(0)) {
            this._limit = this._limit.sub(1);
        }

        this._startTime = Timestamp._fromProtobuf(
            /** @type {HieroProto.proto.ITimestamp} */ (
                message.consensusTimestamp
            ),
        ).plusNanos(1);

        if (
            message.chunkInfo == null ||
            (message.chunkInfo != null && message.chunkInfo.total === 1)
        ) {
            this._passTopicMessage(TopicMessage._ofSingle(message));
        } else {
            this._handleChunkedMessage(message, list);
        }
    }

    /**
     * Handles a chunked message from the topic subscription
     * @private
     * @param {HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse} message - The message response
     * @param {Map<string, HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} list
     */
    _handleChunkedMessage(message, list) {
        const chunkInfo =
            /** @type {HieroProto.proto.IConsensusMessageChunkInfo} */ (
                message.chunkInfo
            );
        const initialTransactionID =
            /** @type {HieroProto.proto.ITransactionID} */ (
                chunkInfo.initialTransactionID
            );
        const total = /** @type {number} */ (chunkInfo.total);
        const transactionId =
            TransactionId._fromProtobuf(initialTransactionID).toString();

        /** @type {HieroProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]} */
        let responses = [];

        const temp = list.get(transactionId);
        if (temp == null) {
            list.set(transactionId, responses);
        } else {
            responses = temp;
        }

        responses.push(message);

        if (responses.length === total) {
            const topicMessage = TopicMessage._ofMany(responses);
            list.delete(transactionId);
            this._passTopicMessage(topicMessage);
        }
    }

    /**
     * Handles errors from the topic subscription
     * @private
     * @param {MirrorError | Error} error - The error that occurred
     * @param {Client<Channel>} client - The client to use for retries
     * @returns {void}
     */
    _handleError(error, client) {
        const message = error instanceof Error ? error.message : error.details;

        if (this._handle?._unsubscribed) {
            return;
        }

        if (this.shouldRetry(error)) {
            this._scheduleRetry(client, message);
        } else {
            this._errorHandler(null, new Error(message));
        }
    }

    /**
     * Determines if a retry should be attempted
     * @private
     * @param {MirrorError | Error} error - The error to check
     * @returns {boolean} - Whether to retry
     */
    shouldRetry(error) {
        return this._attempt < this._maxAttempts && this._retryHandler(error);
    }

    /**
     * Schedules a retry of the server stream request
     * @private
     * @param {Client<Channel>} client - The client to use for the retry
     * @param {string} errorMessage - The error message for logging
     * @returns {void}
     */
    _scheduleRetry(client, errorMessage) {
        const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);

        console.warn(
            `Error subscribing to topic ${this._topicId?.toString() ?? "UNKNOWN"} ` +
                `during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${errorMessage}`,
        );

        this._attempt += 1;
        setTimeout(() => this._makeServerStreamRequest(client), delay);
    }
}
// Filename: src/topic/TopicMessageSubmitTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
    CHUNK_SIZE,
} from "../transaction/Transaction.js";
import TopicId from "./TopicId.js";
import * as utf8 from "../encoding/utf8.js";
import TransactionId from "../transaction/TransactionId.js";
import Timestamp from "../Timestamp.js";
import * as util from "../util.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IConsensusSubmitMessageTransactionBody} HieroProto.proto.IConsensusSubmitMessageTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 * @typedef {import("@hashgraph/proto").proto.IConsensusMessageChunkInfo} HieroProto.proto.IConsensusMessageChunkInfo
 * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
 * @typedef {import("@hashgraph/proto").proto.ICustomFeeLimit} HieroProto.proto.ICustomFeeLimit
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../token/CustomFixedFee.js").default} CustomFixedFee
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../transaction/TransactionResponse.js").default} TransactionResponse
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 * @typedef {import("../transaction/CustomFeeLimit.js").default} CustomFeeLimit
 */

/**
 * <p>
 * Valid and authorized messages on valid topics will be ordered by the
 * consensus service, published in the block stream, and available to all
 * subscribers on this topic via the mirror nodes.<br/>
 * If this transaction succeeds the resulting TransactionReceipt SHALL
 * contain the latest topicSequenceNumber and topicRunningHash for the
 * topic.<br/>
 * If the topic has a `submitKey` then that key MUST sign this
 * transaction.<br/>
 */
export default class TopicMessageSubmitTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     * @param {Uint8Array | string} [props.message]
     * @param {number} [props.maxChunks]
     * @param {number} [props.chunkSize]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }

        /**
         * @private
         * @type {?Uint8Array}
         */
        this._message = null;

        if (props.message != null) {
            this.setMessage(props.message);
        }

        /**
         * @private
         * @type {number}
         * The maximum number of chunks a topic message can be split into.
         * Default max chunk size: 20
         * This value can be overridden with `setMaxChunks`
         */
        this._maxChunks = 20;

        /**
         * @private
         * @type {number}
         * The size of each chunk for a given topic message in bytes.
         */
        this._chunkSize = CHUNK_SIZE;

        if (props.maxChunks != null) {
            this.setMaxChunks(props.maxChunks);
        }

        if (props.chunkSize != null) {
            this.setChunkSize(props.chunkSize);
        }

        /** @type {HieroProto.proto.IConsensusMessageChunkInfo | null} */
        this._chunkInfo = null;
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TopicMessageSubmitTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const message =
            /** @type {HieroProto.proto.IConsensusSubmitMessageTransactionBody} */ (
                body.consensusSubmitMessage
            );

        return Transaction._fromProtobufTransactions(
            new TopicMessageSubmitTransaction({
                topicId:
                    message.topicID != null
                        ? TopicId._fromProtobuf(message.topicID)
                        : undefined,
                message: message.message != null ? message.message : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * @param {TopicId | string} topicId
     * @returns {this}
     */
    setTopicId(topicId) {
        this._requireNotFrozen();

        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @deprecated  - Use `getMessage()` instead
     * @returns {?Uint8Array}
     */
    get message() {
        return this._message;
    }

    /**
     * @returns {?Uint8Array}
     */
    getMessage() {
        return this._message;
    }

    /**
     * @param {string | Uint8Array} message
     * @returns {this}
     */
    setMessage(message) {
        this._requireNotFrozen();
        message = util.requireStringOrUint8Array(message);
        this._message =
            message instanceof Uint8Array ? message : utf8.encode(message);
        return this;
    }

    /**
     * Gets the maximum custom fee that the user is willing to pay for the message.
     * @returns {CustomFeeLimit[]}
     */
    getCustomFeeLimits() {
        return this._customFeeLimits;
    }

    /**
     * Sets the maximum custom fee that the user is willing to pay for message submission.
     * @param {CustomFeeLimit[]} customFeeLimits
     * @returns {this}
     */
    setCustomFeeLimits(customFeeLimits) {
        this._requireNotFrozen();

        this._customFeeLimits = customFeeLimits;

        return this;
    }

    /**
     * Adds a maximum custom fee that the user is willing to pay for message submission.
     * @param {CustomFeeLimit} customFeeLimit
     * @returns {this}
     */
    addCustomFeeLimit(customFeeLimit) {
        this._requireNotFrozen();

        this._customFeeLimits.push(customFeeLimit);

        return this;
    }

    /**
     * @deprecated  - Use `getMaxChunks()` instead
     * @returns {?number}
     */
    get maxChunks() {
        return this._maxChunks;
    }

    /**
     * @returns {?number}
     */
    getMaxChunks() {
        return this._maxChunks;
    }

    /**
     * @param {number} maxChunks
     * @returns {this}
     */
    setMaxChunks(maxChunks) {
        this._requireNotFrozen();
        this._maxChunks = maxChunks;
        return this;
    }

    /**
     * @deprecated  - Use `getChunkSize()` instead
     * @returns {?number}
     */
    get chunkSize() {
        return this._chunkSize;
    }

    /**
     * @returns {?number}
     */
    getChunkSize() {
        return this._chunkSize;
    }

    /**
     * @param {number} chunkSize
     * @returns {this}
     */
    setChunkSize(chunkSize) {
        this._chunkSize = chunkSize;
        return this;
    }

    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        super.freezeWith(client);

        if (this._message == null) {
            return this;
        }

        const chunks = Math.floor(
            (this._message.length + (this._chunkSize - 1)) / this._chunkSize,
        );

        if (chunks > this._maxChunks) {
            throw new Error(
                `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`,
            );
        }

        const initialTransactionId = this._getTransactionId()._toProtobuf();
        let nextTransactionId = this._getTransactionId();

        // Hack around the locked list. Should refactor a bit to remove such code
        this._transactionIds.locked = false;

        this._transactions.clear();
        this._transactionIds.clear();
        this._signedTransactions.clear();

        for (let chunk = 0; chunk < chunks; chunk++) {
            this._chunkInfo = {
                initialTransactionID: initialTransactionId,
                total: chunks,
                number: chunk + 1,
            };

            this._transactionIds.push(nextTransactionId);
            this._transactionIds.advance();

            for (const nodeAccountId of this._nodeAccountIds.list) {
                this._signedTransactions.push(
                    this._makeSignedTransaction(nodeAccountId),
                );
            }

            nextTransactionId = new TransactionId(
                /** @type {AccountId} */ (nextTransactionId.accountId),
                new Timestamp(
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).seconds,
                    /** @type {Timestamp} */ (
                        nextTransactionId.validStart
                    ).nanos.add(1),
                ),
            );
        }

        this._transactionIds.advance();
        this._chunkInfo = null;

        return this;
    }

    /**
     * @returns {ScheduleCreateTransaction}
     */
    schedule() {
        this._requireNotFrozen();

        if (this._message != null && this._message.length > this._chunkSize) {
            throw new Error(
                `cannot schedule \`TopicMessageSubmitTransaction\` with message over ${this._chunkSize} bytes`,
            );
        }

        return super.schedule();
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse>}
     */
    async execute(client, requestTimeout) {
        return (await this.executeAll(client, requestTimeout))[0];
    }

    /**
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @param {number=} requestTimeout
     * @returns {Promise<TransactionResponse[]>}
     */
    async executeAll(client, requestTimeout) {
        if (!super._isFrozen()) {
            this.freezeWith(client);
        }

        // on execute, sign each transaction with the operator, if present
        // and we are signing a transaction that used the default transaction ID

        const transactionId = this._getTransactionId();
        const operatorAccountId = client.operatorAccountId;

        if (
            operatorAccountId != null &&
            operatorAccountId.equals(
                /** @type {AccountId} */ (transactionId.accountId),
            )
        ) {
            await super.signWithOperator(client);
        }

        const responses = [];
        let remainingTimeout = requestTimeout;
        for (let i = 0; i < this._transactionIds.length; i++) {
            const startTimestamp = Date.now();
            responses.push(await super.execute(client, remainingTimeout));

            if (remainingTimeout != null) {
                remainingTimeout = Date.now() - startTimestamp;
            }
        }

        return responses;
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.submitMessage(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusSubmitMessage";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IConsensusSubmitMessageTransactionBody}
     */
    _makeTransactionData() {
        if (this._chunkInfo != null && this._message != null) {
            const num = /** @type {number} */ (this._chunkInfo.number);
            const startIndex = (num - 1) * this._chunkSize;
            let endIndex = startIndex + this._chunkSize;

            if (endIndex > this._message.length) {
                endIndex = this._message.length;
            }

            return {
                topicID:
                    this._topicId != null ? this._topicId._toProtobuf() : null,
                message: this._message.slice(startIndex, endIndex),
                chunkInfo: this._chunkInfo,
            };
        } else {
            return {
                topicID:
                    this._topicId != null ? this._topicId._toProtobuf() : null,
                message: this._message,
            };
        }
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicMessageSubmitTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusSubmitMessage",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicMessageSubmitTransaction._fromProtobuf,
);
// Filename: src/topic/TopicUpdateTransaction.js
// SPDX-License-Identifier: Apache-2.0

import Transaction, {
    TRANSACTION_REGISTRY,
} from "../transaction/Transaction.js";
import AccountId from "../account/AccountId.js";
import TopicId from "./TopicId.js";
import Duration from "../Duration.js";
import Key from "../Key.js";
import Timestamp from "../Timestamp.js";
import CustomFixedFee from "../token/CustomFixedFee.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IConsensusUpdateTopicTransactionBody} HieroProto.proto.IConsensusUpdateTopicTransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 * @typedef {import("@hashgraph/proto").proto.ISignedTransaction} HieroProto.proto.ISignedTransaction
 * @typedef {import("@hashgraph/proto").proto.TransactionBody} HieroProto.proto.TransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionBody} HieroProto.proto.ITransactionBody
 * @typedef {import("@hashgraph/proto").proto.ITransactionResponse} HieroProto.proto.ITransactionResponse
 */

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../transaction/TransactionId.js").default} TransactionId
 */

/**
 * Update a topic.
 *
 * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
 * Otherwise transaction must be signed by the adminKey.
 *
 * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
 *
 * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
 */
export default class TopicUpdateTransaction extends Transaction {
    /**
     * @param {object} props
     * @param {TopicId | string} [props.topicId]
     * @param {Key} [props.adminKey]
     * @param {Key} [props.submitKey]
     * @param {Key} [props.feeScheduleKey]
     * @param {Key[]} [props.feeExemptKeys]
     * @param {Duration | Long | number} [props.autoRenewPeriod]
     * @param {AccountId | string} [props.autoRenewAccountId]
     * @param {CustomFixedFee[]} [props.customFees]
     * @param {?string} [props.topicMemo]
     * @param {Timestamp | Date} [props.expirationTime]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TopicId}
         */
        this._topicId = null;

        if (props.topicId != null) {
            this.setTopicId(props.topicId);
        }

        /**
         * @private
         * @type {?string}
         */
        this._topicMemo = null;

        if (props.topicMemo != null) {
            this.setTopicMemo(props.topicMemo);
        }

        /**
         * @private
         * @type {?Key}
         */
        this._submitKey = null;

        if (props.submitKey != null) {
            this.setSubmitKey(props.submitKey);
        }

        /**
         * @private
         * @type {?Key}
         */
        this._adminKey = null;

        if (props.adminKey != null) {
            this.setAdminKey(props.adminKey);
        }
        /**
         * @private
         * @type {?Key}
         */
        this._feeScheduleKey = null;

        if (props.feeScheduleKey != null) {
            this.setFeeScheduleKey(props.feeScheduleKey);
        }

        /**
         * @private
         * @type {Key[]}
         */
        this._feeExemptKeys = [];

        if (props.feeExemptKeys != null) {
            this.setFeeExemptKeys(props.feeExemptKeys);
        }

        /**
         * @private
         * @type {?AccountId}
         */
        this._autoRenewAccountId = null;

        if (props.autoRenewAccountId != null) {
            this.setAutoRenewAccountId(props.autoRenewAccountId);
        }

        /**
         * @private
         * @type {?Duration}
         */
        this._autoRenewPeriod = null;

        if (props.autoRenewPeriod != null) {
            this.setAutoRenewPeriod(props.autoRenewPeriod);
        }

        /**
         * @private
         * @type {CustomFixedFee[]}
         */
        this._customFees = [];

        if (props.customFees != null) {
            this.setCustomFees(props.customFees);
        }

        /**
         * @private
         * @type {?Timestamp}
         */
        this._expirationTime = null;

        if (props.expirationTime != null) {
            this.setExpirationTime(props.expirationTime);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TopicUpdateTransaction}
     */
    static _fromProtobuf(
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];
        const update =
            /** @type {HieroProto.proto.IConsensusUpdateTopicTransactionBody} */ (
                body.consensusUpdateTopic
            );

        return Transaction._fromProtobufTransactions(
            new TopicUpdateTransaction({
                topicId:
                    update.topicID != null
                        ? TopicId._fromProtobuf(update.topicID)
                        : undefined,
                adminKey:
                    update.adminKey != null
                        ? Key._fromProtobufKey(update.adminKey)
                        : undefined,
                submitKey:
                    update.submitKey != null
                        ? Key._fromProtobufKey(update.submitKey)
                        : undefined,
                feeScheduleKey:
                    update.feeScheduleKey != null
                        ? Key._fromProtobufKey(update.feeScheduleKey)
                        : undefined,
                feeExemptKeys:
                    update.feeExemptKeyList != null &&
                    update.feeExemptKeyList.keys != null
                        ? update?.feeExemptKeyList.keys.map((key) =>
                              Key._fromProtobufKey(key),
                          )
                        : undefined,
                autoRenewAccountId:
                    update.autoRenewAccount != null
                        ? AccountId._fromProtobuf(update.autoRenewAccount)
                        : undefined,
                autoRenewPeriod:
                    update.autoRenewPeriod != null
                        ? update.autoRenewPeriod.seconds != null
                            ? update.autoRenewPeriod.seconds
                            : undefined
                        : undefined,
                customFees:
                    update.customFees != null && update.customFees.fees != null
                        ? update.customFees.fees.map((customFee) =>
                              CustomFixedFee._fromProtobuf(customFee),
                          )
                        : undefined,
                topicMemo:
                    update.memo != null
                        ? Object.hasOwn(update.memo, "value")
                            ? update.memo.value
                            : undefined
                        : undefined,
                expirationTime:
                    update.expirationTime != null
                        ? Timestamp._fromProtobuf(update.expirationTime)
                        : undefined,
            }),
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * @returns {?Timestamp}
     */
    get expirationTime() {
        return this._expirationTime;
    }

    /**
     * @param {Timestamp | Date | null} expirationTime
     * @returns {TopicUpdateTransaction}
     */
    setExpirationTime(expirationTime) {
        this._requireNotFrozen();

        this._expirationTime =
            expirationTime instanceof Date
                ? Timestamp.fromDate(expirationTime)
                : expirationTime;

        return this;
    }

    /**
     * @returns {?TopicId}
     */
    get topicId() {
        return this._topicId;
    }

    /**
     * @param {TopicId | string} topicId
     * @returns {TopicUpdateTransaction}
     */
    setTopicId(topicId) {
        this._requireNotFrozen();
        this._topicId =
            typeof topicId === "string"
                ? TopicId.fromString(topicId)
                : topicId.clone();

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearTopicId() {
        this._requireNotFrozen();
        this._topicId = null;

        return this;
    }

    /**
     * @returns {?string}
     */
    get topicMemo() {
        return this._topicMemo;
    }

    /**
     * @param {string} topicMemo
     * @returns {TopicUpdateTransaction}
     */
    setTopicMemo(topicMemo) {
        this._requireNotFrozen();
        this._topicMemo = topicMemo;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearTopicMemo() {
        this._requireNotFrozen();
        this._topicMemo = null;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get adminKey() {
        return this._adminKey;
    }

    /**
     * @param {Key} adminKey
     * @returns {TopicUpdateTransaction}
     */
    setAdminKey(adminKey) {
        this._requireNotFrozen();
        this._adminKey = adminKey;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearAdminKey() {
        this._requireNotFrozen();
        this._adminKey = null;

        return this;
    }

    /**
     * @returns {?Key}
     */
    get submitKey() {
        return this._submitKey;
    }

    /**
     * @param {Key} submitKey
     * @returns {TopicUpdateTransaction}
     */
    setSubmitKey(submitKey) {
        this._requireNotFrozen();
        this._submitKey = submitKey;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearSubmitKey() {
        this._requireNotFrozen();
        this._submitKey = null;

        return this;
    }

    /**
     * Returns the key which allows updates to the new topic’s fees.
     * @returns {?Key}
     */
    getFeeScheduleKey() {
        return this._feeScheduleKey;
    }

    /**
     * Sets the key which allows updates to the new topic’s fees.
     * @param {Key} feeScheduleKey
     * @returns {this}
     */
    setFeeScheduleKey(feeScheduleKey) {
        this._requireNotFrozen();
        this._feeScheduleKey = feeScheduleKey;

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearFeeScheduleKey() {
        this._requireNotFrozen();
        this._feeScheduleKey = null;

        return this;
    }

    /**
     * Returns the keys that will be exempt from paying fees.
     * @returns {Key[]}
     */
    getFeeExemptKeys() {
        return this._feeExemptKeys;
    }

    /**
     * Sets the keys that will be exempt from paying fees.
     * @param {Key[]} feeExemptKeys
     * @returns {this}
     */
    setFeeExemptKeys(feeExemptKeys) {
        this._requireNotFrozen();
        this._feeExemptKeys = feeExemptKeys;

        return this;
    }

    /**
     * Adds a key that will be exempt from paying fees.
     * @param {Key} key
     * @returns {this}
     */
    addFeeExemptKey(key) {
        this._requireNotFrozen();
        this._feeExemptKeys.push(key);

        return this;
    }

    /**
     * Clears all keys that will be exempt from paying fees.
     * @returns {this}
     */
    clearFeeExemptKeys() {
        this._requireNotFrozen();
        this._feeExemptKeys = [];

        return this;
    }

    /**
     * @returns {?AccountId}
     */
    get autoRenewAccountId() {
        return this._autoRenewAccountId;
    }

    /**
     * @param {AccountId | string} autoRenewAccountId
     * @returns {TopicUpdateTransaction}
     */
    setAutoRenewAccountId(autoRenewAccountId) {
        this._requireNotFrozen();
        this._autoRenewAccountId =
            autoRenewAccountId instanceof AccountId
                ? autoRenewAccountId
                : AccountId.fromString(autoRenewAccountId);

        return this;
    }

    /**
     * @returns {TopicUpdateTransaction}
     */
    clearAutoRenewAccountId() {
        this._requireNotFrozen();
        this._autoRenewAccountId = null;

        return this;
    }

    /**
     * @returns {?Duration}
     */
    get autoRenewPeriod() {
        return this._autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * @param {Duration | Long | number} autoRenewPeriod
     * @returns {TopicUpdateTransaction}
     */
    setAutoRenewPeriod(autoRenewPeriod) {
        this._requireNotFrozen();
        this._autoRenewPeriod =
            autoRenewPeriod instanceof Duration
                ? autoRenewPeriod
                : new Duration(autoRenewPeriod);

        return this;
    }

    /**
     * Returns the fixed fees to assess when a message is submitted to the new topic.
     * @returns {CustomFixedFee[]}
     */
    getCustomFees() {
        return this._customFees;
    }

    /**
     * Sets the fixed fees to assess when a message is submitted to the new topic.
     *
     * @param {CustomFixedFee[]} customFees
     * @returns {this}
     */
    setCustomFees(customFees) {
        this._requireNotFrozen();
        this._customFees = customFees;

        return this;
    }

    /**
     * Adds fixed fee to assess when a message is submitted to the new topic.
     *
     * @param {CustomFixedFee} customFee
     * @returns {this}
     */
    addCustomFee(customFee) {
        this._requireNotFrozen();
        this._customFees.push(customFee);

        return this;
    }

    /**
     * Clears fixed fees.
     *
     * @returns {this}
     */
    clearCustomFees() {
        this._requireNotFrozen();
        this._customFees = [];

        return this;
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (this._topicId != null) {
            this._topicId.validateChecksum(client);
        }

        if (this._autoRenewAccountId != null) {
            this._autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<HieroProto.proto.ITransactionResponse>}
     */
    _execute(channel, request) {
        return channel.consensus.updateTopic(request);
    }

    /**
     * @override
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        return "consensusUpdateTopic";
    }

    /**
     * @override
     * @protected
     * @returns {HieroProto.proto.IConsensusUpdateTopicTransactionBody}
     */
    _makeTransactionData() {
        return {
            topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
            adminKey:
                this._adminKey != null ? this._adminKey._toProtobufKey() : null,
            submitKey:
                this._submitKey != null
                    ? this._submitKey._toProtobufKey()
                    : null,
            feeScheduleKey:
                this._feeScheduleKey != null
                    ? this._feeScheduleKey._toProtobufKey()
                    : null,
            feeExemptKeyList: {
                keys: this._feeExemptKeys.map((key) => key._toProtobufKey()),
            },
            memo:
                this._topicMemo != null
                    ? {
                          value: this._topicMemo,
                      }
                    : null,
            autoRenewAccount:
                this._autoRenewAccountId != null
                    ? this._autoRenewAccountId._toProtobuf()
                    : null,
            autoRenewPeriod:
                this._autoRenewPeriod != null
                    ? this._autoRenewPeriod._toProtobuf()
                    : null,
            customFees: {
                fees: this._customFees.map((customFee) =>
                    customFee._toTopicFeeProtobuf(),
                ),
            },
            expirationTime:
                this._expirationTime != null
                    ? this._expirationTime._toProtobuf()
                    : null,
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp = /** @type {import("../Timestamp.js").default} */ (
            this._transactionIds.current.validStart
        );
        return `TopicUpdateTransaction:${timestamp.toString()}`;
    }
}

TRANSACTION_REGISTRY.set(
    "consensusUpdateTopic",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TopicUpdateTransaction._fromProtobuf,
);
// Filename: src/transaction/CustomFeeLimit.js
import AccountId from "../account/AccountId.js";
import CustomFixedFee from "../token/CustomFixedFee.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.IFixedFee} HieroProto.proto.IFixedFee
 * @typedef {import("@hashgraph/proto").proto.ICustomFeeLimit} HieroProto.proto.ICustomFeeLimit
 */

export default class CustomFeeLimit {
    /**
     *
     * @param {object} props
     * @param {?AccountId | string} [props.accountId]
     * @param {?CustomFixedFee[]} [props.fees]
     */
    constructor(props = {}) {
        /**
         * @type {?AccountId}
         */
        this._accountId = null;

        if (props.accountId) {
            this.setAccountId(props.accountId);
        }

        /**
         * @type {?CustomFixedFee[]}
         */
        this._fees = null;

        if (props.fees) {
            this.setFees(props.fees);
        }
    }

    /**
     * @static
     * @param {HieroProto.proto.ICustomFeeLimit} customFeeLimit
     * @returns {CustomFeeLimit}
     */
    static _fromProtobuf(customFeeLimit) {
        return new CustomFeeLimit({
            accountId:
                customFeeLimit.accountId != null
                    ? AccountId._fromProtobuf(customFeeLimit.accountId)
                    : null,
            fees:
                customFeeLimit.fees != null
                    ? customFeeLimit.fees.map((fixedFee) => {
                          return CustomFixedFee._fromProtobuf({
                              fixedFee: fixedFee,
                          });
                      })
                    : null,
        });
    }

    /**
     * @returns {?AccountId}
     */
    getAccountId() {
        return this._accountId;
    }

    /**
     *
     * @param {AccountId | string} accountId
     * @returns {this}
     */
    setAccountId(accountId) {
        if (accountId instanceof AccountId) {
            this._accountId = accountId;
        } else {
            this._accountId = AccountId.fromString(accountId);
        }
        return this;
    }

    /**
     * @returns {?CustomFixedFee[]}
     */
    getFees() {
        return this._fees;
    }

    /**
     *
     * @param {CustomFixedFee[]} fees
     * @returns {this}
     */
    setFees(fees) {
        this._fees = fees;

        return this;
    }

    /**
     *
     * @returns {HieroProto.proto.ICustomFeeLimit}
     */
    _toProtobuf() {
        /** @type {HieroProto.proto.IFixedFee[]} */
        const protoFixedFees = [];

        if (this._fees != null) {
            this._fees.forEach((fixedFee) => {
                const fixedFeeProto = fixedFee._toProtobuf();
                if (fixedFeeProto.fixedFee != null) {
                    protoFixedFees.push(fixedFeeProto.fixedFee);
                }
            });
        }

        return {
            accountId:
                this._accountId != null ? this._accountId._toProtobuf() : null,
            fees: protoFixedFees,
        };
    }
}
// Filename: src/transaction/List.js
// SPDX-License-Identifier: Apache-2.0

/**
 * A custom list type which round robins, supports locking, and as additional
 * QoL improvements.
 *
 * @template {any} T
 */
export default class List {
    constructor() {
        /** @type {T[]} */
        this.list = [];
        this.locked = false;
        this.index = 0;
    }

    /**
     * Overwrite the entire list.
     *
     * @throws if the list is locked
     * @param {T[]} list
     * @returns {this}
     */
    setList(list) {
        if (this.locked) {
            throw new Error("list is locked");
        }

        this.list = list;
        this.index = 0;

        return this;
    }

    /**
     * Push items to the end of the list.
     *
     * @throws if the list is locked
     * @param {T[]} items
     * @returns {this}
     */
    push(...items) {
        if (this.locked) {
            throw new Error("list is locked");
        }

        this.list.push(...items);
        return this;
    }

    /**
     * Locks the list.
     *
     * @returns {this}
     */
    setLocked() {
        this.locked = true;
        return this;
    }

    /**
     * Clear the list
     */
    clear() {
        this.list = [];
        this.index = 0;
    }

    /**
     * The get value at a particular index.
     *
     * @param {number} index
     * @returns {T}
     */
    get(index) {
        return this.list[index];
    }

    /**
     * Set value at index
     *
     * @param {number} index
     * @param {T} item
     * @returns {this}
     */
    set(index, item) {
        // QoL: If the index is at the end simply push the element to the end
        if (index === this.length) {
            this.list.push(item);
        } else {
            this.list[index] = item;
        }

        return this;
    }

    /**
     * Set value at index if it's not already set
     *
     * @throws if the list is locked
     * @param {number} index
     * @param {() => T} lambda
     * @returns {this}
     */
    setIfAbsent(index, lambda) {
        if (index == this.length || this.list[index] == null) {
            this.set(index, lambda());
        }

        return this;
    }

    /**
     * Get the current value, and advance the index
     *
     * @returns {T}
     */
    get next() {
        return this.get(this.advance());
    }

    /**
     * Get the current value.
     *
     * @returns {T}
     */
    get current() {
        return this.get(this.index);
    }

    /**
     * Advance the index to the next element in a round robin fashion
     *
     * @returns {number}
     */
    advance() {
        const index = this.index;
        this.index = (this.index + 1) % this.list.length;
        return index;
    }

    /**
     * Is the list empty
     *
     * @returns {boolean}
     */
    get isEmpty() {
        return this.length === 0;
    }

    /**
     * Get the length of the list
     *
     * @returns {number}
     */
    get length() {
        return this.list.length;
    }

    /**
     * Shallow clone this list.
     * Perhaps we should explicitly call this `shallowClone()` since it doesn't
     * clone the list inside?
     *
     * @returns {List<T>}
     */
    clone() {
        /** @type {List<T>} */
        const list = new List();
        list.list = this.list;
        list.locked = this.locked;
        return list;
    }
}
// Filename: src/transaction/NodeAccountIdSignatureMap.js
// SPDX-License-Identifier: Apache-2.0

import ObjectMap from "../ObjectMap.js";
import TransactionId from "./TransactionId.js";
import SignaturePairMap from "./SignaturePairMap.js";
import * as HieroProto from "@hashgraph/proto";

/**
 * @augments {ObjectMap<TransactionId, SignaturePairMap>}
 */
export default class NodeAccountIdSignatureMap extends ObjectMap {
    constructor() {
        super((s) => TransactionId.fromString(s));
    }

    /**
     * This function is used to create a NodeAccountIdSignaturemap from an already built transaction.
     * @param { import('./List.js').default<import("@hashgraph/proto").proto.ISignedTransaction>} signedTransactions
     * @returns {NodeAccountIdSignatureMap}
     */
    static _fromSignedTransactions(signedTransactions) {
        const signatures = new NodeAccountIdSignatureMap();

        for (const { bodyBytes, sigMap } of signedTransactions.list) {
            if (bodyBytes != null && sigMap != null) {
                const body = HieroProto.proto.TransactionBody.decode(bodyBytes);

                if (body.transactionID != null) {
                    const transactionId = TransactionId._fromProtobuf(
                        body.transactionID,
                    );

                    signatures._set(
                        transactionId,
                        SignaturePairMap._fromTransactionSigMap(sigMap),
                    );
                }
            }
        }

        return signatures;
    }

    /**
     *
     * Adds a signature pair for this transaction id.
     * @param {TransactionId} txId
     * @param {import("../SignerSignature.js").PublicKey} publicKey
     * @param {Uint8Array} signature
     */
    addSignature(txId, publicKey, signature) {
        const sigPairMap = this.get(txId);
        if (sigPairMap) {
            sigPairMap.addSignature(publicKey, signature);
        } else {
            this._set(
                txId,
                new SignaturePairMap().addSignature(publicKey, signature),
            );
        }
    }
}
// Filename: src/transaction/SignatureMap.js
// SPDX-License-Identifier: Apache-2.0

import NodeAccountIdSignatureMap from "./NodeAccountIdSignatureMap.js";
import ObjectMap from "../ObjectMap.js";
import AccountId from "../account/AccountId.js";
import List from "./List.js";

/**
 * Represents a mapping of account IDs to their corresponding signatures for transactions.
 *
 * The `SignatureMap` class is used to manage and store signatures associated with
 * different accounts in a transaction. It allows for adding signatures, retrieving
 * them, and converting the signature map to and from various formats.
 */

/**
 * @augments {ObjectMap<AccountId, NodeAccountIdSignatureMap>}
 */
export default class SignatureMap extends ObjectMap {
    /**
     * @typedef {import("../transaction/TransactionId.js").default} TransactionId
     * @typedef {import("../transaction/SignaturePairMap.js").default} SignaturePairMap
     */
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    /**
     * This function is used to create a SignatureMap from an already built transaction.
     * @param {import("./Transaction.js").default} transaction
     * @returns {SignatureMap}
     */
    static _fromTransaction(transaction) {
        const signatures = new SignatureMap();

        const rowLength = transaction._nodeAccountIds.length;
        const columns = transaction._signedTransactions.length / rowLength;

        /*
        this setup implies that the signed transactions are stored sequentially
        in the signed transactions list. This means that the first rowLength
        signed transactions are for the first node account id, the next rowLength
        signed transactions are for the second node account id and so on.
        */
        for (let row = 0; row < rowLength; row++) {
            /** @type { List<import("@hashgraph/proto").proto.ISignedTransaction> } */
            const signedTransactions = new List();

            for (let col = 0; col < columns; col++) {
                signedTransactions.push(
                    transaction._signedTransactions.get(col * rowLength + row),
                );
            }

            signatures._set(
                transaction._nodeAccountIds.list[row],
                NodeAccountIdSignatureMap._fromSignedTransactions(
                    signedTransactions,
                ),
            );
        }

        return signatures;
    }

    /**
     * Updates the signature map with the given signature.
     * by generating a new node account id signature map if it does not exist
     * or adding the signature to the existing node account id signature map.
     *
     * @param {AccountId} nodeId
     * @param {TransactionId} txId
     * @param {import("../SignerSignature.js").PublicKey} publicKey
     * @param {Uint8Array} signature
     * @returns {SignatureMap}
     */
    addSignature(nodeId, txId, publicKey, signature) {
        let nodeAccountIdSigdMap = this.get(nodeId);

        if (!nodeAccountIdSigdMap) {
            nodeAccountIdSigdMap = new NodeAccountIdSignatureMap();
            this._set(nodeId, nodeAccountIdSigdMap);
        }

        nodeAccountIdSigdMap.addSignature(txId, publicKey, signature);
        this._set(nodeId, nodeAccountIdSigdMap);

        return this;
    }
    /**
     * @returns {SignaturePairMap[]}
     */
    getFlatSignatureList() {
        const flatSignatureList = [];

        for (const nodeAccountIdSignatureMap of this.values()) {
            for (const tx of nodeAccountIdSignatureMap.values()) {
                flatSignatureList.push(tx);
            }
        }

        return flatSignatureList;
    }
}
// Filename: src/transaction/SignaturePairMap.js
import ObjectMap from "../ObjectMap.js";
import PublicKey from "../PublicKey.js";

/**
 * @augments {ObjectMap<PublicKey, Uint8Array>}
 */
export default class SignaturePairMap extends ObjectMap {
    constructor() {
        super((s) => PublicKey.fromString(s));
    }

    /**
     * This function is used to create a SignaturePairMap from an already built transaction.
     * @param {import("@hashgraph/proto").proto.ISignatureMap} sigMap
     * @returns {SignaturePairMap}
     */
    static _fromTransactionSigMap(sigMap) {
        const signatures = new SignaturePairMap();

        const sigPairs = sigMap.sigPair != null ? sigMap.sigPair : [];

        for (const sigPair of sigPairs) {
            if (sigPair.pubKeyPrefix == null) {
                continue;
            }

            if (sigPair.ed25519 != null) {
                signatures._set(
                    PublicKey.fromBytesED25519(sigPair.pubKeyPrefix),
                    sigPair.ed25519,
                );
            } else if (sigPair.ECDSASecp256k1 != null) {
                signatures._set(
                    PublicKey.fromBytesECDSA(sigPair.pubKeyPrefix),
                    sigPair.ECDSASecp256k1,
                );
            }
        }

        return signatures;
    }

    /**
     *
     * @param {PublicKey} pubKey
     * @param {Uint8Array} signature
     * @returns {SignaturePairMap}
     */
    addSignature(pubKey, signature) {
        this._set(pubKey, signature);
        return this;
    }
}
// Filename: src/transaction/TokenTransfer.js
// SPDX-License-Identifier: Apache-2.0
// Filename: src/transaction/Transaction.js
// SPDX-License-Identifier: Apache-2.0

import Hbar from "../Hbar.js";
import TransactionResponse from "./TransactionResponse.js";
import TransactionId from "./TransactionId.js";
import TransactionHashMap from "./TransactionHashMap.js";
import SignatureMap from "./SignatureMap.js";
import Executable, { ExecutionState } from "../Executable.js";
import Status from "../Status.js";
import Long from "long";
import * as sha384 from "../cryptography/sha384.js";
import * as hex from "../encoding/hex.js";
import * as HieroProto from "@hashgraph/proto";
import PrecheckStatusError from "../PrecheckStatusError.js";
import AccountId from "../account/AccountId.js";
import PublicKey from "../PublicKey.js";
import List from "./List.js";
import Timestamp from "../Timestamp.js";
import * as util from "../util.js";
import CustomFeeLimit from "./CustomFeeLimit.js";

/**
 * @typedef {import("bignumber.js").default} BigNumber
 */

/**
 * @typedef {import("../schedule/ScheduleCreateTransaction.js").default} ScheduleCreateTransaction
 * @typedef {import("../PrivateKey.js").default} PrivateKey
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../Signer.js").Signer} Signer
 */

// 90 days (in seconds)
export const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000);

// maximum value of i64 (so there is never a record generated)
export const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(
    Long.fromString("9223372036854775807"),
);

// 120 seconds
const DEFAULT_TRANSACTION_VALID_DURATION = 120;

// The default message chunk size in bytes when splitting a given message.
// This value can be overriden using `setChunkSize` when preparing to submit a messsage via `TopicMessageSubmitTransaction`.
export const CHUNK_SIZE = 1024;

/**
 * @type {Map<NonNullable<HieroProto.proto.TransactionBody["data"]>, (transactions: HieroProto.proto.ITransaction[], signedTransactions: HieroProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HieroProto.proto.TransactionBody[]) => Transaction>}
 */
export const TRANSACTION_REGISTRY = new Map();

/**
 * Base class for all transactions that may be submitted to Hedera.
 *
 * @abstract
 * @augments {Executable<HieroProto.proto.ITransaction, HieroProto.proto.ITransactionResponse, TransactionResponse>}
 */
export default class Transaction extends Executable {
    // A SDK transaction is composed of multiple, raw protobuf transactions.
    // These should be functionally identical, with the exception of pointing to
    // different nodes.

    // When retrying a transaction after a network error or retry-able
    // status response, we try a different transaction and thus a different node.

    constructor() {
        super();

        /**
         * List of proto transactions that have been built from this SDK
         * transaction.
         *
         * This is a 2-D array built into one, meaning to
         * get to the next row you'd index into this array `row * rowLength + column`
         * where `rowLength` is `nodeAccountIds.length`
         *
         * @internal
         * @type {List<HieroProto.proto.ITransaction | null>}
         */
        this._transactions = new List();

        /**
         * List of proto transactions that have been built from this SDK
         * transaction.
         *
         * This is a 2-D array built into one, meaning to
         * get to the next row you'd index into this array `row * rowLength + column`
         * where `rowLength` is `nodeAccountIds.length`
         *
         * @internal
         * @type {List<HieroProto.proto.ISignedTransaction>}
         */
        this._signedTransactions = new List();

        /**
         * Set of public keys (as string) who have signed this transaction so
         * we do not allow them to sign it again.
         *
         * @internal
         * @type {Set<string>}
         */
        this._signerPublicKeys = new Set();

        /**
         * The transaction valid duration
         *
         * @private
         * @type {number}
         */
        this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;

        /**
         * The default max transaction fee for this particular transaction type.
         * Most transactions use the default of 2 Hbars, but some requests such
         * as `TokenCreateTransaction` need to use a different default value.
         *
         * @protected
         * @type {Hbar}
         */
        this._defaultMaxTransactionFee = new Hbar(2);

        /**
         * The maximum custom fee that the user is willing to pay for the message. If left empty, the user is willing to pay any custom fee.
         * If used with a transaction type that does not support custom fee limits, the transaction will fail.
         * @type {CustomFeeLimit[]}
         */
        this._customFeeLimits = [];

        /**
         * The max transaction fee on the request. This field is what users are able
         * to set, not the `defaultMaxTransactionFee`. The purpose of this field is
         * to allow us to determine if the user set the field explicitly, or if we're
         * using the default max transation fee for the request.
         *
         * @private
         * @type {Hbar | null}
         */
        this._maxTransactionFee = null;

        /**
         * The transaction's memo
         *
         * @private
         * @type {string}
         */
        this._transactionMemo = "";

        /**
         * The list of transaction IDs. This list will almost always be of length 1.
         * The only time this list will be a different length is for chunked transactions.
         * The only two chunked transactions supported right now are `FileAppendTransaction`
         * and `TopicMessageSubmitTransaction`
         *
         * @protected
         * @type {List<TransactionId>}
         */
        this._transactionIds = new List();

        /**
         * A list of public keys that will be added to the requests signatures
         *
         * @private
         * @type {PublicKey[]}
         */
        this._publicKeys = [];

        /**
         * The list of signing function 1-1 with `_publicKeys` which sign the request.
         * The reason this list allows `null` is because if we go from bytes into
         * a transaction, then we know the public key, but we don't have the signing function.
         *
         * @private
         * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}
         */
        this._transactionSigners = [];

        /**
         * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`
         *
         * @private
         * @type {?boolean}
         */
        this._regenerateTransactionId = null;
    }

    /**
     * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or
     * `proto.TransactionList`.
     *
     * @param {Uint8Array} bytes
     * @returns {Transaction}
     */
    static fromBytes(bytes) {
        /** @type {HieroProto.proto.ISignedTransaction[]} */
        const signedTransactions = [];

        /** @type {TransactionId[]} */
        const transactionIds = [];

        /** @type {AccountId[]} */
        const nodeIds = [];

        /** @type {string[]} */
        const transactionIdStrings = [];

        /** @type {string[]} */
        const nodeIdStrings = [];

        /** @type {HieroProto.proto.TransactionBody[]} */
        const bodies = [];

        const list =
            HieroProto.proto.TransactionList.decode(bytes).transactionList;

        // If the list is of length 0, then teh bytes provided were not a
        // `proto.TransactionList`
        //
        // FIXME: We should also check to make sure the bytes length is greater than
        // 0 otherwise this check is wrong?
        if (list.length === 0) {
            const transaction = HieroProto.proto.Transaction.decode(bytes);

            // We support `Transaction.signedTransactionBytes` and
            // `Transaction.bodyBytes` + `Transaction.sigMap`. If the bytes represent the
            // latter, convert them into `signedTransactionBytes`
            if (transaction.signedTransactionBytes.length !== 0) {
                list.push(transaction);
            } else {
                list.push({
                    signedTransactionBytes:
                        HieroProto.proto.SignedTransaction.encode({
                            sigMap: transaction.sigMap,
                            bodyBytes: transaction.bodyBytes,
                        }).finish(),
                });
            }
        }

        // This loop is responsible for fill out the `signedTransactions`, `transactionIds`,
        // `nodeIds`, and `bodies` variables.
        for (const transaction of list) {
            // The `bodyBytes` or `signedTransactionBytes` should not be null
            if (
                transaction.bodyBytes == null &&
                transaction.signedTransactionBytes == null
            ) {
                throw new Error(
                    "bodyBytes and signedTransactionBytes are null",
                );
            }

            if (transaction.bodyBytes && transaction.bodyBytes.length != 0) {
                // Decode a transaction
                const body = HieroProto.proto.TransactionBody.decode(
                    transaction.bodyBytes,
                );

                // Make sure the transaction ID within the body is set
                if (body.transactionID != null) {
                    const transactionId = TransactionId._fromProtobuf(
                        /** @type {HieroProto.proto.ITransactionID} */ (
                            body.transactionID
                        ),
                    );

                    // If we haven't already seen this transaction ID in the list, add it
                    if (
                        !transactionIdStrings.includes(transactionId.toString())
                    ) {
                        transactionIds.push(transactionId);
                        transactionIdStrings.push(transactionId.toString());
                    }
                }

                // Make sure the node account ID within the body is set
                if (body.nodeAccountID != null) {
                    const nodeAccountId = AccountId._fromProtobuf(
                        /** @type {HieroProto.proto.IAccountID} */ (
                            body.nodeAccountID
                        ),
                    );

                    // If we haven't already seen this node account ID in the list, add it
                    if (!nodeIdStrings.includes(nodeAccountId.toString())) {
                        nodeIds.push(nodeAccountId);
                        nodeIdStrings.push(nodeAccountId.toString());
                    }
                }

                // Make sure the body is set
                if (body.data == null) {
                    throw new Error(
                        "(BUG) body.data was not set in the protobuf",
                    );
                }

                bodies.push(body);
            }

            if (
                transaction.signedTransactionBytes &&
                transaction.signedTransactionBytes.length != 0
            ) {
                // Decode a signed transaction
                const signedTransaction =
                    HieroProto.proto.SignedTransaction.decode(
                        transaction.signedTransactionBytes,
                    );

                signedTransactions.push(signedTransaction);

                // Decode a transaction body
                const body = HieroProto.proto.TransactionBody.decode(
                    signedTransaction.bodyBytes,
                );

                // Make sure the transaction ID within the body is set
                if (body.transactionID != null) {
                    const transactionId = TransactionId._fromProtobuf(
                        /** @type {HieroProto.proto.ITransactionID} */ (
                            body.transactionID
                        ),
                    );

                    // If we haven't already seen this transaction ID in the list, add it
                    if (
                        !transactionIdStrings.includes(transactionId.toString())
                    ) {
                        transactionIds.push(transactionId);
                        transactionIdStrings.push(transactionId.toString());
                    }
                }

                // Make sure the node account ID within the body is set
                if (body.nodeAccountID != null) {
                    const nodeAccountId = AccountId._fromProtobuf(
                        /** @type {HieroProto.proto.IAccountID} */ (
                            body.nodeAccountID
                        ),
                    );

                    // If we haven't already seen this node account ID in the list, add it
                    if (!nodeIdStrings.includes(nodeAccountId.toString())) {
                        nodeIds.push(nodeAccountId);
                        nodeIdStrings.push(nodeAccountId.toString());
                    }
                }

                // Make sure the body is set
                if (body.data == null) {
                    throw new Error(
                        "(BUG) body.data was not set in the protobuf",
                    );
                }

                bodies.push(body);
            }
        }

        // FIXME: We should have a length check before we access `0` since that would error
        const body = bodies[0];

        // We should have at least more than one body
        if (body == null || body.data == null) {
            throw new Error(
                "No transaction found in bytes or failed to decode TransactionBody",
            );
        }

        // Use the registry to call the right transaction's `fromProtobuf` method based
        // on the `body.data` string
        const fromProtobuf = TRANSACTION_REGISTRY.get(body.data); //NOSONAR

        // If we forgot to update the registry we should error
        if (fromProtobuf == null) {
            throw new Error(
                `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`,
            );
        }

        // That the specific transaction type from protobuf implementation and pass in all the
        // information we've gathered.
        return fromProtobuf(
            list,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );
    }

    /**
     * Convert this transaction a `ScheduleCreateTransaction`
     *
     * @returns {ScheduleCreateTransaction}
     */
    schedule() {
        this._requireNotFrozen();

        if (SCHEDULE_CREATE_TRANSACTION.length != 1) {
            throw new Error(
                "ScheduleCreateTransaction has not been loaded yet",
            );
        }

        return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);
    }

    /**
     * This method is called by each `*Transaction._fromProtobuf()` method. It does
     * all the finalization before the user gets hold of a complete `Transaction`
     *
     * @template {Transaction} TransactionT
     * @param {TransactionT} transaction
     * @param {HieroProto.proto.ITransaction[]} transactions
     * @param {HieroProto.proto.ISignedTransaction[]} signedTransactions
     * @param {TransactionId[]} transactionIds
     * @param {AccountId[]} nodeIds
     * @param {HieroProto.proto.ITransactionBody[]} bodies
     * @returns {TransactionT}
     */
    static _fromProtobufTransactions(
        transaction,
        transactions,
        signedTransactions,
        transactionIds,
        nodeIds,
        bodies,
    ) {
        const body = bodies[0];

        // "row" of the 2-D `bodies` array has all the same contents except for `nodeAccountID`
        for (let i = 0; i < transactionIds.length; i++) {
            for (let j = 0; j < nodeIds.length - 1; j++) {
                if (
                    !util.compare(
                        bodies[i * nodeIds.length + j],
                        bodies[i * nodeIds.length + j + 1],
                        // eslint-disable-next-line ie11/no-collection-args
                        new Set(["nodeAccountID"]),
                    )
                ) {
                    throw new Error("failed to validate transaction bodies");
                }
            }
        }

        // Remove node account IDs of 0
        // _IIRC_ this was initial due to some funny behavior with `ScheduleCreateTransaction`
        // We may be able to remove this.
        const zero = new AccountId(0);
        for (let i = 0; i < nodeIds.length; i++) {
            if (nodeIds[i].equals(zero)) {
                nodeIds.splice(i--, 1);
            }
        }

        // Set the transactions accordingly, but don't lock the list because transactions can
        // be regenerated if more signatures are added
        transaction._transactions.setList(transactions);

        // Set the signed transactions accordingly. Although, they
        // can be manipulated if for instance more signatures are added
        transaction._signedTransactions.setList(signedTransactions);

        // Set the transaction IDs accordingly
        transaction._transactionIds.setList(transactionIds);

        // Set the node account IDs accordingly
        transaction._nodeAccountIds.setList(nodeIds);

        // Make sure to update the rest of the fields
        transaction._transactionValidDuration =
            body.transactionValidDuration != null &&
            body.transactionValidDuration.seconds != null
                ? Long.fromValue(body.transactionValidDuration.seconds).toInt()
                : DEFAULT_TRANSACTION_VALID_DURATION;
        transaction._maxTransactionFee =
            body.transactionFee != null &&
            body.transactionFee > new Long(0, 0, true)
                ? Hbar.fromTinybars(body.transactionFee)
                : null;
        transaction._customFeeLimits =
            body.maxCustomFees != null
                ? body.maxCustomFees?.map((fee) =>
                      CustomFeeLimit._fromProtobuf(fee),
                  )
                : [];
        transaction._transactionMemo = body.memo != null ? body.memo : "";

        // Loop over a single row of `signedTransactions` and add all the public
        // keys to the `signerPublicKeys` set, and `publicKeys` list with
        // `null` in the `transactionSigners` at the same index.
        for (let i = 0; i < nodeIds.length; i++) {
            const tx = signedTransactions[i] || transactions[i];
            if (tx.sigMap != null && tx.sigMap.sigPair != null) {
                for (const sigPair of tx.sigMap.sigPair) {
                    transaction._signerPublicKeys.add(
                        hex.encode(
                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),
                        ),
                    );

                    transaction._publicKeys.push(
                        PublicKey.fromBytes(
                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix),
                        ),
                    );
                    transaction._transactionSigners.push(null);
                }
            }
        }

        return transaction;
    }

    /**
     * Set the node account IDs
     *
     * @override
     * @param {AccountId[]} nodeIds
     * @returns {this}
     */
    setNodeAccountIds(nodeIds) {
        // The reason we overwrite this method is simply because we need to call `requireNotFrozen()`
        // Now that I think of it, we could just add an abstract method `setterPrerequiest()` which
        // by default does nothing, and `Executable` can call. Then we'd only need to overwrite that
        // method once.
        this._requireNotFrozen();
        super.setNodeAccountIds(nodeIds);
        return this;
    }

    /**
     * Get the transaction valid duration
     *
     * @returns {number}
     */
    get transactionValidDuration() {
        return this._transactionValidDuration;
    }

    /**
     * Sets the duration (in seconds) that this transaction is valid for.
     *
     * This is defaulted to 120 seconds (from the time its executed).
     *
     * @param {number} validDuration
     * @returns {this}
     */
    setTransactionValidDuration(validDuration) {
        this._requireNotFrozen();
        this._transactionValidDuration = validDuration;

        return this;
    }

    /**
     * Get the max transaction fee
     *
     * @returns {?Hbar}
     */
    get maxTransactionFee() {
        return this._maxTransactionFee;
    }

    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee
     * @returns {this}
     */
    setMaxTransactionFee(maxTransactionFee) {
        this._requireNotFrozen();
        this._maxTransactionFee =
            maxTransactionFee instanceof Hbar
                ? maxTransactionFee
                : new Hbar(maxTransactionFee);

        return this;
    }

    /**
     * Is transaction ID regeneration enabled
     *
     * @returns {?boolean}
     */
    get regenerateTransactionId() {
        return this._regenerateTransactionId;
    }

    /**
     * Set the maximum transaction fee the operator (paying account)
     * is willing to pay.
     *
     * @param {boolean} regenerateTransactionId
     * @returns {this}
     */
    setRegenerateTransactionId(regenerateTransactionId) {
        this._requireNotFrozen();
        this._regenerateTransactionId = regenerateTransactionId;

        return this;
    }

    /**
     * Get the transaction memo
     *
     * @returns {string}
     */
    get transactionMemo() {
        return this._transactionMemo;
    }

    /**
     * Set a note or description to be recorded in the transaction
     * record (maximum length of 100 bytes).
     *
     * @param {string} transactionMemo
     * @returns {this}
     */
    setTransactionMemo(transactionMemo) {
        this._requireNotFrozen();
        this._transactionMemo = transactionMemo;

        return this;
    }

    /**
     * Get the curent transaction ID
     *
     * @returns {?TransactionId}
     */
    get transactionId() {
        if (this._transactionIds.isEmpty) {
            return null;
        }

        // If a user calls `.transactionId` that means we need to use that transaction ID
        // and **not** regenerate it. To do this, we simply lock the transaction ID list.
        //
        // This may be a little conffusing since a user can enable transaction ID regenration
        // explicity, but if they call `.transactionId` then we will not regenerate transaction
        // IDs.
        this._transactionIds.setLocked();

        return this._transactionIds.current;
    }

    /**
     * Set the ID for this transaction.
     *
     * The transaction ID includes the operator's account ( the account paying the transaction
     * fee). If two transactions have the same transaction ID, they won't both have an effect. One
     * will complete normally and the other will fail with a duplicate transaction status.
     *
     * Normally, you should not use this method. Just before a transaction is executed, a
     * transaction ID will be generated from the operator on the client.
     *
     * @param {TransactionId} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId) {
        this._requireNotFrozen();
        this._transactionIds.setList([transactionId]).setLocked();

        return this;
    }

    /**
     * How many chunk sizes are expected
     * @abstract
     * @internal
     * @returns {number}
     */
    getRequiredChunks() {
        return 1;
    }

    /**
     * Sign the transaction with the private key
     * **NOTE**: This is a thin wrapper around `.signWith()`
     *
     * @param {PrivateKey} privateKey
     * @returns {Promise<this>}
     */
    sign(privateKey) {
        return this.signWith(privateKey.publicKey, (message) =>
            Promise.resolve(privateKey.sign(message)),
        );
    }

    /**
     * Sign the transaction with the public key and signer function
     *
     * If sign on demand is enabled no signing will be done immediately, instead
     * the private key signing function and public key are saved to be used when
     * a user calls an exit condition method (not sure what a better name for this is)
     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.
     *
     * @param {PublicKey} publicKey
     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner
     * @returns {Promise<this>}
     */
    async signWith(publicKey, transactionSigner) {
        // If signing on demand is disabled, we need to make sure
        // the request is frozen
        if (!this._signOnDemand) {
            this._requireFrozen();
        }
        const publicKeyData = publicKey.toBytesRaw();

        // note: this omits the DER prefix on purpose because Hedera doesn't
        // support that in the protobuf. this means that we would fail
        // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER
        // prefixes here
        const publicKeyHex = hex.encode(publicKeyData);

        if (this._signerPublicKeys.has(publicKeyHex)) {
            // this public key has already signed this transaction
            return this;
        }

        // If we add a new signer, then we need to re-create all transactions
        this._transactions.clear();

        // Save the current public key so we don't attempt to sign twice
        this._signerPublicKeys.add(publicKeyHex);

        // If signing on demand is enabled we will save the public key and signer and return
        if (this._signOnDemand) {
            this._publicKeys.push(publicKey);
            this._transactionSigners.push(transactionSigner);

            return this;
        }

        // If we get here, signing on demand is disabled, this means the transaction
        // is frozen and we need to sign all the transactions immediately. If we're
        // signing all the transactions immediately, we need to lock the node account IDs
        // and transaction IDs.
        // Now that I think of it, this code should likely exist in `freezeWith()`?
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        // Sign each signed transatcion
        for (const signedTransaction of this._signedTransactions.list) {
            const bodyBytes = /** @type {Uint8Array} */ (
                signedTransaction.bodyBytes
            );
            const signature = await transactionSigner(bodyBytes);

            if (signedTransaction.sigMap == null) {
                signedTransaction.sigMap = {};
            }

            if (signedTransaction.sigMap.sigPair == null) {
                signedTransaction.sigMap.sigPair = [];
            }

            signedTransaction.sigMap.sigPair.push(
                publicKey._toProtobufSignature(signature),
            );
        }

        return this;
    }

    /**
     * Sign the transaction with the client operator. This is a thin wrapper
     * around `.signWith()`
     *
     * **NOTE**: If client does not have an operator set, this method will throw
     *
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<this>}
     */
    signWithOperator(client) {
        const operator = client._operator;

        if (operator == null) {
            throw new Error(
                "`client` must have an operator to sign with the operator",
            );
        }

        if (!this._isFrozen()) {
            this.freezeWith(client);
        }

        return this.signWith(operator.publicKey, operator.transactionSigner);
    }

    /**
     * Add a signature explicitly
     *
     * @param {PublicKey} publicKey
     * @param {SignatureMap} signatureMap
     * @returns {this}
     */
    addSignature(publicKey, signatureMap) {
        // If the transaction isn't frozen, freeze it.
        if (!this.isFrozen()) {
            this.freeze();
        }

        const publicKeyData = publicKey.toBytesRaw();
        const publicKeyHex = hex.encode(publicKeyData);

        if (this._signerPublicKeys.has(publicKeyHex)) {
            // this public key has already signed this transaction
            return this;
        }

        // If we add a new signer, then we need to re-create all transactions
        this._transactions.clear();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();
        this._signedTransactions.setLocked();

        // Add the signature to the signed transaction list
        for (let index = 0; index < this._signedTransactions.length; index++) {
            const signedTransaction = this._signedTransactions.get(index);
            if (signedTransaction.sigMap == null) {
                signedTransaction.sigMap = {};
            }

            if (signedTransaction.sigMap.sigPair == null) {
                signedTransaction.sigMap.sigPair = [];
            }

            if (signedTransaction.bodyBytes) {
                const { transactionID, nodeAccountID } =
                    HieroProto.proto.TransactionBody.decode(
                        signedTransaction.bodyBytes,
                    );

                if (!transactionID || !nodeAccountID) {
                    throw new Error(
                        "Transaction ID or Node Account ID not found in the signed transaction",
                    );
                }

                const transactionId =
                    TransactionId._fromProtobuf(transactionID);
                const nodeAccountId = AccountId._fromProtobuf(nodeAccountID);

                const nodeSignatures = signatureMap.get(nodeAccountId);
                const transactionSignatures =
                    nodeSignatures?.get(transactionId);
                const signature = transactionSignatures?.get(publicKey);

                if (!signature) {
                    throw new Error(
                        "Signature not found for the transaction and public key",
                    );
                }
                const sigPair = publicKey._toProtobufSignature(signature);
                signedTransaction.sigMap?.sigPair?.push(sigPair);
            }
        }

        this._signerPublicKeys.add(publicKeyHex);
        this._publicKeys.push(publicKey);
        this._transactionSigners.push(null);

        return this;
    }

    /**
     * This method removes all signatures from the transaction based on the public key provided.
     *
     * @param {PublicKey} publicKey - The public key associated with the signature to remove.
     * @returns {Uint8Array[]} The removed signatures.
     */
    removeSignature(publicKey) {
        if (!this.isFrozen()) {
            this.freeze();
        }

        const publicKeyData = publicKey.toBytesRaw();
        const publicKeyHex = hex.encode(publicKeyData);

        if (!this._signerPublicKeys.has(publicKeyHex)) {
            throw new Error("The public key has not signed this transaction");
        }

        /** @type {Uint8Array[]} */
        const removedSignatures = [];

        // Iterate over the signed transactions and remove matching signatures
        for (const transaction of this._signedTransactions.list) {
            const removedSignaturesFromTransaction =
                this._removeSignaturesFromTransaction(
                    transaction,
                    publicKeyHex,
                );

            removedSignatures.push(...removedSignaturesFromTransaction);
        }

        // Remove the public key from internal tracking if no signatures remain
        this._signerPublicKeys.delete(publicKeyHex);
        this._publicKeys = this._publicKeys.filter(
            (key) => !key.equals(publicKey),
        );

        // Update transaction signers array
        this._transactionSigners.pop();

        return removedSignatures;
    }

    /**
     * This method clears all signatures from the transaction and returns them in a specific format.
     *
     * It will call collectSignatures to get the removed signatures, then clear all signatures
     * from the internal tracking.
     *
     * @returns { Map<PublicKey, Uint8Array[] | Uint8Array> } The removed signatures in the specified format.
     */
    removeAllSignatures() {
        if (!this.isFrozen()) {
            this.freeze();
        }

        const removedSignatures = this._collectSignaturesByPublicKey();

        // Iterate over the signed transactions and clear all signatures
        for (const transaction of this._signedTransactions.list) {
            if (transaction.sigMap && transaction.sigMap.sigPair) {
                // Clear all signature pairs from the transaction's signature map
                transaction.sigMap.sigPair = [];
            }
        }

        // Clear the internal tracking of signer public keys and other relevant arrays
        this._signerPublicKeys.clear();
        this._publicKeys = [];
        this._transactionSigners = [];

        return removedSignatures;
    }

    /**
     * Get the current signatures on the request
     *
     * **NOTE**: Does NOT support sign on demand
     *
     * @returns {SignatureMap}
     */
    getSignatures() {
        // If a user is attempting to get signatures for a transaction, then the
        // transaction must be frozen.
        this._requireFrozen();

        // Sign on demand must be disabled because this is the non-async version and
        // signing requires awaiting callbacks.
        this._requireNotSignOnDemand();

        // Build all the transactions
        this._buildAllTransactions();

        // Lock transaction IDs, and node account IDs
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        // Construct a signature map from this transaction
        return SignatureMap._fromTransaction(this);
    }

    /**
     * Get the current signatures on the request
     *
     * **NOTE**: Supports sign on demand
     *
     * @returns {Promise<SignatureMap>}
     */
    async getSignaturesAsync() {
        // If sign on demand is enabled, we don't need to care about being frozen
        // since we can just regenerate and resign later if some field of the transaction
        // changes.

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        // Build all transactions, and sign them
        await this._buildAllTransactionsAsync();

        // Lock transaction IDs, and node account IDs
        this._transactions.setLocked();
        this._signedTransactions.setLocked();

        // Construct a signature map from this transaction
        return SignatureMap._fromTransaction(this);
    }

    /**
     * Not sure why this is called `setTransactionId()` when it doesn't set anything...
     * FIXME: Remove this?
     */
    _setTransactionId() {
        if (this._operatorAccountId == null && this._transactionIds.isEmpty) {
            throw new Error(
                "`transactionId` must be set or `client` must be provided with `freezeWith`",
            );
        }
    }

    /**
     * Set the node account IDs using the client
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     */
    _setNodeAccountIds(client) {
        if (!this._nodeAccountIds.isEmpty) {
            return;
        }

        if (client == null) {
            throw new Error(
                "`nodeAccountId` must be set or `client` must be provided with `freezeWith`",
            );
        }

        this._nodeAccountIds.setList(
            client._network.getNodeAccountIdsForExecute(),
        );
    }

    /**
     * Build all the signed transactions from the node account IDs
     *
     * @private
     */
    _buildSignedTransactions() {
        if (this._signedTransactions.locked) {
            return;
        }

        this._signedTransactions.setList(
            this._nodeAccountIds.list.map((nodeId) =>
                this._makeSignedTransaction(nodeId),
            ),
        );
    }

    /**
     * Build all the signed transactions from the node account IDs
     *
     * @internal
     */
    _buildIncompleteTransactions() {
        if (this._nodeAccountIds.length == 0) {
            this._transactions.setList([this._makeSignedTransaction(null)]);
        } else {
            // In case the node account ids are set
            this._transactions.setList(
                this._nodeAccountIds.list.map((nodeId) =>
                    this._makeSignedTransaction(nodeId),
                ),
            );
        }
    }

    /**
     * Freeze this transaction from future modification to prepare for
     * signing or serialization.
     *
     * @returns {this}
     */
    freeze() {
        return this.freezeWith(null);
    }

    /**
     * @param {?AccountId} accountId
     */
    _freezeWithAccountId(accountId) {
        if (this._operatorAccountId == null) {
            this._operatorAccountId = accountId;
        }
    }

    /**
     * Freeze this transaction from further modification to prepare for
     * signing or serialization.
     *
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3
     * nodes to prepare this transaction for.
     *
     * @param {?import("../client/Client.js").default<Channel, *>} client
     * @returns {this}
     */
    freezeWith(client) {
        // Set sign on demand based on client
        this._signOnDemand = client != null ? client.signOnDemand : false;

        // Save the operator
        this._operator = client != null ? client._operator : null;
        this._freezeWithAccountId(
            client != null ? client.operatorAccountId : null,
        );

        // Set max transaction fee to either `this._maxTransactionFee`,
        // `client._defaultMaxTransactionFee`, or `this._defaultMaxTransactionFee`
        // in that priority order depending on if `this._maxTransactionFee` has
        // been set or if `client._defaultMaxTransactionFee` has been set.
        this._maxTransactionFee =
            this._maxTransactionFee == null
                ? client != null && client.defaultMaxTransactionFee != null
                    ? client.defaultMaxTransactionFee
                    : this._defaultMaxTransactionFee
                : this._maxTransactionFee;

        // Determine if transaction ID generation should be enabled.
        this._regenerateTransactionId =
            client != null && this._regenerateTransactionId == null
                ? client.defaultRegenerateTransactionId
                : this._regenerateTransactionId;

        // Set the node account IDs via client
        this._setNodeAccountIds(client);

        // Make sure a transaction ID or operator is set.
        this._setTransactionId();

        // If a client was not provided, we need to make sure the transaction ID already set
        // validates aginst the client.
        if (client != null) {
            for (const transactionId of this._transactionIds.list) {
                if (transactionId.accountId != null) {
                    transactionId.accountId.validateChecksum(client);
                }
            }
        }

        // Build a list of transaction IDs so that if a user calls `.transactionId` they'll
        // get a value, but if they dont' we'll just regenerate transaction IDs during execution
        this._buildNewTransactionIdList();

        // If sign on demand is disabled we need to build out all the signed transactions
        if (!this._signOnDemand) {
            this._buildSignedTransactions();
        }

        return this;
    }

    /**
     * Sign the transaction using a signer
     *
     * This is part of the signature provider feature
     *
     * @param {Signer} signer
     * @returns {Promise<this>}
     */
    async signWithSigner(signer) {
        await signer.signTransaction(this);
        return this;
    }

    /**
     * Freeze the transaction using a signer
     *
     * This is part of the signature provider feature.
     *
     * @param {Signer} signer
     * @returns {Promise<this>}
     */
    async freezeWithSigner(signer) {
        await signer.populateTransaction(this);
        this.freeze();
        return this;
    }

    /**
     * Serialize the request into bytes. This will encode all the transactions
     * into a `proto.TransactionList` and return the encoded protobuf.
     *
     * **NOTE**: Does not support sign on demand
     *
     * @returns {Uint8Array}
     */
    toBytes() {
        // Sign on demand must be disabled because this is the non-async version and
        // signing requires awaiting callbacks.
        this._requireNotSignOnDemand();

        if (this._isFrozen()) {
            // Locking the transaction IDs and node account IDs is necessary for consistency
            // between before and after execution
            this._transactionIds.setLocked();
            this._nodeAccountIds.setLocked();

            // Build all the transactions without signing
            this._buildAllTransactions();
        } else {
            this._buildIncompleteTransactions();
        }

        // Construct and encode the transaction list
        return HieroProto.proto.TransactionList.encode({
            transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (
                this._transactions.list
            ),
        }).finish();
    }

    /**
     * Serialize the transaction into bytes
     *
     * **NOTE**: Supports sign on demand
     *
     * @returns {Promise<Uint8Array>}
     */
    async toBytesAsync() {
        // If sign on demand is enabled, we don't need to care about being frozen
        // since we can just regenerate and resign later if some field of the transaction
        // changes.

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        // Build all transactions, and sign them
        await this._buildAllTransactionsAsync();

        // Lock transaction IDs, and node account IDs
        this._transactions.setLocked();
        this._signedTransactions.setLocked();

        // Construct and encode the transaction list
        return HieroProto.proto.TransactionList.encode({
            transactionList: /** @type {HieroProto.proto.ITransaction[]} */ (
                this._transactions.list
            ),
        }).finish();
    }

    /**
     * Get the transaction hash
     *
     * @returns {Promise<Uint8Array>}
     */
    async getTransactionHash() {
        this._requireFrozen();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        await this._buildAllTransactionsAsync();

        this._transactions.setLocked();
        this._signedTransactions.setLocked();

        return sha384.digest(
            /** @type {Uint8Array} */ (
                /** @type {HieroProto.proto.ITransaction} */ (
                    this._transactions.get(0)
                ).signedTransactionBytes
            ),
        );
    }

    /**
     * Get all the transaction hashes
     *
     * @returns {Promise<TransactionHashMap>}
     */
    async getTransactionHashPerNode() {
        this._requireFrozen();

        // Locking the transaction IDs and node account IDs is necessary for consistency
        // between before and after execution
        this._transactionIds.setLocked();
        this._nodeAccountIds.setLocked();

        await this._buildAllTransactionsAsync();

        return await TransactionHashMap._fromTransaction(this);
    }

    /**
     * Is transaction frozen
     *
     * @returns {boolean}
     */
    isFrozen() {
        return this._signedTransactions.length > 0;
    }

    /**
     * Get the current transaction ID, and make sure it's not null
     *
     * @protected
     * @returns {TransactionId}
     */
    _getTransactionId() {
        const transactionId = this.transactionId;
        if (transactionId == null) {
            throw new Error(
                "transaction must have been frozen before getting the transaction ID, try calling `freeze`",
            );
        }
        return transactionId;
    }

    /**
     * @param {Client} client
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function
    _validateChecksums(client) {
        // Do nothing
    }

    /**
     * Before we proceed execution, we need to do a couple checks
     *
     * @override
     * @protected
     * @param {import("../client/Client.js").default<Channel, *>} client
     * @returns {Promise<void>}
     */
    async _beforeExecute(client) {
        // Assign the account IDs to which the transaction should be sent.
        this.transactionNodeIds = Object.values(client.network).map(
            (accountNodeId) => accountNodeId.toString(),
        );

        if (this._logger) {
            this._logger.info(
                `Network used: ${client._network.networkName}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions
            );
        }

        // Make sure we're frozen
        if (!this._isFrozen()) {
            this.freezeWith(client);
        }

        // Valid checksums if the option is enabled
        if (client.isAutoValidateChecksumsEnabled()) {
            this._validateChecksums(client);
        }

        // Set the operator if the client has one and the current operator is nullish
        if (this._operator == null || this._operator == undefined) {
            this._operator = client != null ? client._operator : null;
        }

        if (
            this._operatorAccountId == null ||
            this._operatorAccountId == undefined
        ) {
            this._operatorAccountId =
                client != null && client._operator != null
                    ? client._operator.accountId
                    : null;
        }

        // If the client has an operator, sign this request with the operator
        if (this._operator != null) {
            await this.signWith(
                this._operator.publicKey,
                this._operator.transactionSigner,
            );
        }
    }

    /**
     * Construct a protobuf transaction
     *
     * @override
     * @internal
     * @returns {Promise<HieroProto.proto.ITransaction>}
     */
    async _makeRequestAsync() {
        // The index for the transaction
        const index =
            this._transactionIds.index * this._nodeAccountIds.length +
            this._nodeAccountIds.index;

        // If sign on demand is disabled we need to simply build that transaction
        // and return the result, without signing
        if (!this._signOnDemand) {
            this._buildTransaction(index);
            return /** @type {HieroProto.proto.ITransaction} */ (
                this._transactions.get(index)
            );
        }

        // Build and sign a transaction
        return await this._buildTransactionAsync();
    }

    /**
     * Sign a `proto.SignedTransaction` with all the keys
     *
     * @private
     * @returns {Promise<HieroProto.proto.ISignedTransaction>}
     */
    async _signTransaction() {
        const signedTransaction = this._makeSignedTransaction(
            this._nodeAccountIds.next,
        );

        const bodyBytes = /** @type {Uint8Array} */ (
            signedTransaction.bodyBytes
        );

        for (let j = 0; j < this._publicKeys.length; j++) {
            const publicKey = this._publicKeys[j];
            const transactionSigner = this._transactionSigners[j];

            if (transactionSigner == null) {
                continue;
            }

            const signature = await transactionSigner(bodyBytes);

            if (signedTransaction.sigMap == null) {
                signedTransaction.sigMap = {};
            }

            if (signedTransaction.sigMap.sigPair == null) {
                signedTransaction.sigMap.sigPair = [];
            }

            signedTransaction.sigMap.sigPair.push(
                publicKey._toProtobufSignature(signature),
            );
        }

        return signedTransaction;
    }

    /**
     * Construct a new transaction ID at the current index
     *
     * @private
     */
    _buildNewTransactionIdList() {
        if (this._transactionIds.locked || this._operatorAccountId == null) {
            return;
        }

        const transactionId = TransactionId.withValidStart(
            this._operatorAccountId,
            Timestamp.generate(),
        );

        this._transactionIds.set(this._transactionIds.index, transactionId);
    }

    /**
     * Build each signed transaction in a loop
     *
     * @internal
     */
    _buildAllTransactions() {
        for (let i = 0; i < this._signedTransactions.length; i++) {
            this._buildTransaction(i);
        }
    }

    /**
     * Build and and sign each transaction in a loop
     *
     * This method is primary used in the exist condition methods
     * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`
     *
     * @private
     */
    async _buildAllTransactionsAsync() {
        if (!this._signOnDemand) {
            this._buildAllTransactions();
            return;
        }

        this._buildSignedTransactions();

        if (this._transactions.locked) {
            return;
        }

        for (let i = 0; i < this._signedTransactions.length; i++) {
            this._transactions.push(await this._buildTransactionAsync());
        }
    }

    /**
     * Build a transaction at a particular index
     *
     * @internal
     * @param {number} index
     */
    _buildTransaction(index) {
        if (this._transactions.length < index) {
            for (let i = this._transactions.length; i < index; i++) {
                this._transactions.push(null);
            }
        }

        // In case when an incomplete transaction is created, serialized and
        // deserialized,and then the transaction being frozen, the copy of the
        // incomplete transaction must be updated in order to be prepared for execution
        if (this._transactions.list[index] != null) {
            this._transactions.set(index, {
                signedTransactionBytes:
                    HieroProto.proto.SignedTransaction.encode(
                        this._signedTransactions.get(index),
                    ).finish(),
            });
        }

        this._transactions.setIfAbsent(index, () => {
            return {
                signedTransactionBytes:
                    HieroProto.proto.SignedTransaction.encode(
                        this._signedTransactions.get(index),
                    ).finish(),
            };
        });
    }

    /**
     * Build a trransaction using the current index, where the current
     * index is determined by `this._nodeAccountIds.index` and
     * `this._transactionIds.index`
     *
     * @private
     * @returns {Promise<HieroProto.proto.ITransaction>}
     */
    async _buildTransactionAsync() {
        return {
            signedTransactionBytes: HieroProto.proto.SignedTransaction.encode(
                await this._signTransaction(),
            ).finish(),
        };
    }

    /**
     * Determine what execution state we're in.
     *
     * @override
     * @internal
     * @param {HieroProto.proto.ITransaction} request
     * @param {HieroProto.proto.ITransactionResponse} response
     * @returns {[Status, ExecutionState]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } = response;

        // Get the node precheck code, and convert it into an SDK `Status`
        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : HieroProto.proto.ResponseCodeEnum.OK,
        );

        if (this._logger) {
            this._logger.debug(
                `[${this._getLogId()}] received status ${status.toString()}`,
            );
            this._logger.info(
                `SDK Transaction Status Response: ${status.toString()}`,
            );
        }

        // Based on the status what execution state are we in
        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.PlatformTransactionNotCreated:
            case Status.PlatformNotActive:
                return [status, ExecutionState.Retry];
            case Status.Ok:
                return [status, ExecutionState.Finished];
            case Status.TransactionExpired:
                if (
                    this._transactionIds.locked ||
                    (this._regenerateTransactionId != null &&
                        !this._regenerateTransactionId)
                ) {
                    return [status, ExecutionState.Error];
                } else {
                    this._buildNewTransactionIdList();
                    return [status, ExecutionState.Retry];
                }
            default:
                return [status, ExecutionState.Error];
        }
    }

    /**
     * Map the request and response into a precheck status error
     *
     * @override
     * @internal
     * @param {HieroProto.proto.ITransaction} request
     * @param {HieroProto.proto.ITransactionResponse} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response, nodeId) {
        const { nodeTransactionPrecheckCode } = response;

        const status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : HieroProto.proto.ResponseCodeEnum.OK,
        );
        if (this._logger) {
            this._logger.info(
                // @ts-ignore
                `Transaction Error Info: ${status.toString()}, ${this.transactionId.toString()}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions
            );
        }

        return new PrecheckStatusError({
            nodeId,
            status,
            transactionId: this._getTransactionId(),
            contractFunctionResult: null,
        });
    }

    /**
     * Map the request, response, and node account ID into a `TransactionResponse`
     *
     * @override
     * @protected
     * @param {HieroProto.proto.ITransactionResponse} response
     * @param {AccountId} nodeId
     * @param {HieroProto.proto.ITransaction} request
     * @returns {Promise<TransactionResponse>}
     */
    async _mapResponse(response, nodeId, request) {
        const transactionHash = await sha384.digest(
            /** @type {Uint8Array} */ (request.signedTransactionBytes),
        );
        const transactionId = this._getTransactionId();

        this._transactionIds.advance();
        if (this._logger) {
            this._logger.info(
                `Transaction Info: ${JSON.stringify(
                    new TransactionResponse({
                        nodeId,
                        transactionHash,
                        transactionId,
                    }).toJSON(),
                )}`,
            );
        }

        return new TransactionResponse({
            nodeId,
            transactionHash,
            transactionId,
        });
    }

    /**
     * Make a signed transaction given a node account ID
     *
     * @internal
     * @param {?AccountId} nodeId
     * @returns {HieroProto.proto.ISignedTransaction}
     */
    _makeSignedTransaction(nodeId) {
        const body = this._makeTransactionBody(nodeId);
        if (this._logger) {
            this._logger.info(`Transaction Body: ${JSON.stringify(body)}`);
        }
        const bodyBytes =
            HieroProto.proto.TransactionBody.encode(body).finish();

        return {
            sigMap: {
                sigPair: [],
            },
            bodyBytes,
        };
    }

    /**
     * Make a protobuf transaction body
     *
     * @private
     * @param {?AccountId} nodeId
     * @returns {HieroProto.proto.ITransactionBody}
     */
    _makeTransactionBody(nodeId) {
        return {
            [this._getTransactionDataCase()]: this._makeTransactionData(),
            transactionFee:
                this._maxTransactionFee != null
                    ? this._maxTransactionFee.toTinybars()
                    : null,
            memo: this._transactionMemo,
            transactionID:
                this._transactionIds.current != null
                    ? this._transactionIds.current._toProtobuf()
                    : null,
            nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,
            transactionValidDuration: {
                seconds: Long.fromNumber(this._transactionValidDuration),
            },
            maxCustomFees:
                this._customFeeLimits != null
                    ? this._customFeeLimits.map((maxCustomFee) =>
                          maxCustomFee._toProtobuf(),
                      )
                    : null,
        };
    }

    /**
     * This method returns a key for the `data` field in a transaction body.
     * Each transaction overwrite this to make sure when we build the transaction body
     * we set the right data field.
     *
     * @abstract
     * @protected
     * @returns {NonNullable<HieroProto.proto.TransactionBody["data"]>}
     */
    _getTransactionDataCase() {
        throw new Error("not implemented");
    }

    /**
     * Make a scheduled transaction body
     * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent
     *
     * @internal
     * @returns {HieroProto.proto.ISchedulableTransactionBody}
     */
    _getScheduledTransactionBody() {
        return {
            memo: this.transactionMemo,
            transactionFee:
                this._maxTransactionFee == null
                    ? this._defaultMaxTransactionFee.toTinybars()
                    : this._maxTransactionFee.toTinybars(),
            [this._getTransactionDataCase()]: this._makeTransactionData(),
        };
    }

    /**
     * Make the transaction body data.
     *
     * @abstract
     * @protected
     * @returns {object}
     */
    _makeTransactionData() {
        throw new Error("not implemented");
    }

    /**
     * FIXME: Why do we have `isFrozen` and `_isFrozen()`?
     *
     * @protected
     * @returns {boolean}
     */
    _isFrozen() {
        return this._signOnDemand || this._signedTransactions.length > 0;
    }

    /**
     * Require the transaction to NOT be frozen
     *
     * @internal
     */
    _requireNotFrozen() {
        if (this._isFrozen()) {
            throw new Error(
                "transaction is immutable; it has at least one signature or has been explicitly frozen",
            );
        }
    }

    /**
     * Require the transaction to have sign on demand disabled
     *
     * @internal
     */
    _requireNotSignOnDemand() {
        if (this._signOnDemand) {
            throw new Error(
                "Please use `toBytesAsync()` if `signOnDemand` is enabled",
            );
        }
    }

    /**
     * Require the transaction to be frozen
     *
     * @internal
     */
    _requireFrozen() {
        if (!this._isFrozen()) {
            throw new Error(
                "transaction must have been frozen before calculating the hash will be stable, try calling `freeze`",
            );
        }
    }

    /**
     * Require the transaction to have a single node account ID set
     *
     * @internal
     * @protected
     */
    _requireOneNodeAccountId() {
        if (this._nodeAccountIds.length != 1) {
            throw "transaction did not have exactly one node ID set";
        }
    }

    /**
     * @param {HieroProto.proto.Transaction} request
     * @returns {Uint8Array}
     */
    _requestToBytes(request) {
        return HieroProto.proto.Transaction.encode(request).finish();
    }

    /**
     * @param {HieroProto.proto.TransactionResponse} response
     * @returns {Uint8Array}
     */
    _responseToBytes(response) {
        return HieroProto.proto.TransactionResponse.encode(response).finish();
    }

    /**
     * Removes all signatures from a transaction and collects the removed signatures.
     *
     * @param {HieroProto.proto.ISignedTransaction} transaction - The transaction object to process.
     * @param {string} publicKeyHex - The hexadecimal representation of the public key.
     * @returns {Uint8Array[]} An array of removed signatures.
     */
    _removeSignaturesFromTransaction(transaction, publicKeyHex) {
        /** @type {Uint8Array[]} */
        const removedSignatures = [];

        if (!transaction.sigMap || !transaction.sigMap.sigPair) {
            return [];
        }

        transaction.sigMap.sigPair = transaction.sigMap.sigPair.filter(
            (sigPair) => {
                const shouldRemove = this._shouldRemoveSignature(
                    sigPair,
                    publicKeyHex,
                );
                const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;

                if (shouldRemove && signature) {
                    removedSignatures.push(signature);
                }

                return !shouldRemove;
            },
        );

        return removedSignatures;
    }

    /**
     * Determines whether a signature should be removed based on the provided public key.
     *
     * @param {HieroProto.proto.ISignaturePair} sigPair - The signature pair object that contains
     *        the public key prefix and signature to be evaluated.
     * @param {string} publicKeyHex - The hexadecimal representation of the public key to compare against.
     * @returns {boolean} `true` if the public key prefix in the signature pair matches the provided public key,
     *          indicating that the signature should be removed; otherwise, `false`.
     */
    _shouldRemoveSignature = (sigPair, publicKeyHex) => {
        const sigPairPublicKeyHex = hex.encode(
            sigPair?.pubKeyPrefix || new Uint8Array(),
        );

        const matchesPublicKey = sigPairPublicKeyHex === publicKeyHex;

        return matchesPublicKey;
    };

    /**
     * Collects all signatures from signed transactions and returns them in a format keyed by PublicKey.
     *
     * @returns { Map<PublicKey, Uint8Array[]> } The collected signatures keyed by PublicKey.
     */
    _collectSignaturesByPublicKey() {
        /** @type {  Map<PublicKey, Uint8Array[]>} */
        const collectedSignatures = new Map();
        /** @type { Record<string, PublicKey> } */
        const publicKeyMap = {}; // Map to hold string representation of the PublicKey object

        // Iterate over the signed transactions and collect signatures
        for (const transaction of this._signedTransactions.list) {
            if (!(transaction.sigMap && transaction.sigMap.sigPair)) {
                return new Map();
            }

            // Collect the signatures
            for (const sigPair of transaction.sigMap.sigPair) {
                const signature = sigPair.ed25519 ?? sigPair.ECDSASecp256k1;

                if (!signature || !sigPair.pubKeyPrefix) {
                    return new Map();
                }

                const publicKeyStr = hex.encode(sigPair.pubKeyPrefix);
                let publicKeyObj = publicKeyMap[publicKeyStr];

                // If the PublicKey instance for this string representation doesn't exist, create and store it
                if (!publicKeyObj) {
                    publicKeyObj = PublicKey.fromString(publicKeyStr);
                    publicKeyMap[publicKeyStr] = publicKeyObj;
                }

                // Initialize the structure for this publicKey if it doesn't exist
                if (!collectedSignatures.has(publicKeyObj)) {
                    collectedSignatures.set(publicKeyObj, []);
                }

                const existingSignatures =
                    collectedSignatures.get(publicKeyObj);

                // Add the signature to the corresponding public key
                if (existingSignatures) {
                    existingSignatures.push(signature);
                }
            }
        }

        return collectedSignatures;
    }
}

/**
 * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`
 *
 * @type {(() => ScheduleCreateTransaction)[]}
 */
export const SCHEDULE_CREATE_TRANSACTION = [];
// Filename: src/transaction/TransactionHashMap.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import * as sha384 from "../cryptography/sha384.js";
import ObjectMap from "../ObjectMap.js";

/**
 * @namespace proto
 * @typedef {import("@hashgraph/proto").proto.ITransaction} HieroProto.proto.ITransaction
 */

/**
 * @augments {ObjectMap<AccountId, Uint8Array>}
 */
export default class TransactionHashMap extends ObjectMap {
    constructor() {
        super((s) => AccountId.fromString(s));
    }

    /**
     * @param {import("./Transaction.js").default} transaction
     * @returns {Promise<TransactionHashMap>}
     */
    static async _fromTransaction(transaction) {
        const hashes = new TransactionHashMap();

        for (let i = 0; i < transaction._nodeAccountIds.length; i++) {
            const nodeAccountId = transaction._nodeAccountIds.list[i];
            const tx = /** @type {HieroProto.proto.ITransaction} */ (
                transaction._transactions.get(i)
            );
            const hash = await sha384.digest(
                /** @type {Uint8Array} */ (tx.signedTransactionBytes),
            );

            hashes._set(nodeAccountId, hash);
        }

        return hashes;
    }
}
// Filename: src/transaction/TransactionId.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import Timestamp from "../Timestamp.js";
import * as HieroProto from "@hashgraph/proto";
import Long from "long";
import CACHE from "../Cache.js";

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./TransactionRecord.js").default} TransactionRecord
 */

/**
 * The client-generated ID for a transaction.
 *
 * This is used for retrieving receipts and records for a transaction, for appending to a file
 * right after creating it, for instantiating a smart contract with bytecode in a file just created,
 * and internally by the network for detecting when duplicate transactions are submitted.
 */
export default class TransactionId {
    /**
     * Don't use this method directly.
     * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.
     *
     * @param {?AccountId} accountId
     * @param {?Timestamp} validStart
     * @param {?boolean} scheduled
     * @param {?Long | number} nonce
     */
    constructor(accountId, validStart, scheduled = false, nonce = null) {
        /**
         * The Account ID that paid for this transaction.
         *
         * @readonly
         */
        this.accountId = accountId;

        /**
         * The time from when this transaction is valid.
         *
         * When a transaction is submitted there is additionally a validDuration (defaults to 120s)
         * and together they define a time window that a transaction may be processed in.
         *
         * @readonly
         */
        this.validStart = validStart;

        this.scheduled = scheduled;

        this.nonce = null;
        if (nonce != null && nonce != 0) {
            this.setNonce(nonce);
        }

        Object.seal(this);
    }

    /**
     * @param {Long | number} nonce
     * @returns {TransactionId}
     */
    setNonce(nonce) {
        this.nonce = typeof nonce === "number" ? Long.fromNumber(nonce) : nonce;
        return this;
    }

    /**
     * @param {AccountId} accountId
     * @param {Timestamp} validStart
     * @returns {TransactionId}
     */
    static withValidStart(accountId, validStart) {
        return new TransactionId(accountId, validStart);
    }

    /**
     * Generates a new transaction ID for the given account ID.
     *
     * Note that transaction IDs are made of the valid start of the transaction and the account
     * that will be charged the transaction fees for the transaction.
     *
     * @param {AccountId | string} id
     * @returns {TransactionId}
     */
    static generate(id) {
        return new TransactionId(
            typeof id === "string"
                ? AccountId.fromString(id)
                : new AccountId(id),
            Timestamp.generate(),
        );
    }

    /**
     * @param {string} wholeId
     * @returns {TransactionId}
     */
    static fromString(wholeId) {
        let account, seconds, nanos, isScheduled, nonce;
        let rest;
        // 1.1.1@5.4?scheduled/117

        [account, rest] = wholeId.split("@");
        [seconds, rest] = rest.split(".");
        if (rest.includes("?")) {
            [nanos, rest] = rest.split("?scheduled");
            isScheduled = true;
            if (rest.includes("/")) {
                nonce = rest.replace("/", "");
            } else {
                nonce = null;
            }
        } else if (rest.includes("/")) {
            [nanos, nonce] = rest.split("/");
            isScheduled = false;
        } else {
            nanos = rest;
        }

        return new TransactionId(
            AccountId.fromString(account),
            new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)),
            isScheduled,
            nonce != null ? Long.fromString(nonce) : null,
        );
    }

    /**
     * @param {boolean} scheduled
     * @returns {this}
     */
    setScheduled(scheduled) {
        this.scheduled = scheduled;
        return this;
    }

    /**
     * @returns {string}
     */
    toString() {
        if (this.accountId != null && this.validStart != null) {
            const zeroPaddedNanos = String(this.validStart.nanos).padStart(
                9,
                "0",
            );
            const nonce =
                this.nonce != null ? "/".concat(this.nonce.toString()) : "";
            const scheduled = this.scheduled ? "?scheduled" : "";
            return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${zeroPaddedNanos}${scheduled}${nonce}`;
        } else {
            throw new Error("neither `accountId` nor `validStart` are set");
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransactionID} id
     * @returns {TransactionId}
     */
    static _fromProtobuf(id) {
        if (id.accountID != null && id.transactionValidStart != null) {
            return new TransactionId(
                AccountId._fromProtobuf(id.accountID),
                Timestamp._fromProtobuf(id.transactionValidStart),
                id.scheduled != null ? id.scheduled : undefined,
                id.nonce != null ? id.nonce : undefined,
            );
        } else {
            throw new Error(
                "Neither `nonce` or `accountID` and `transactionValidStart` are set",
            );
        }
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITransactionID}
     */
    _toProtobuf() {
        return {
            accountID:
                this.accountId != null ? this.accountId._toProtobuf() : null,
            transactionValidStart:
                this.validStart != null ? this.validStart._toProtobuf() : null,
            scheduled: this.scheduled,
            nonce: this.nonce != null ? this.nonce.toInt() : null,
        };
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionId}
     */
    static fromBytes(bytes) {
        return TransactionId._fromProtobuf(
            HieroProto.proto.TransactionID.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TransactionID.encode(
            this._toProtobuf(),
        ).finish();
    }

    /**
     * @returns {TransactionId}
     */
    clone() {
        return new TransactionId(
            this.accountId,
            this.validStart,
            this.scheduled,
            this.nonce,
        );
    }

    /**
     * @param {TransactionId} other
     * @returns {number}
     */
    compare(other) {
        const comparison = /** @type {AccountId} */ (this.accountId).compare(
            /** @type {AccountId} */ (other.accountId),
        );

        if (comparison != 0) {
            return comparison;
        }

        return /** @type {Timestamp} */ (this.validStart).compare(
            /** @type {Timestamp} */ (other.validStart),
        );
    }

    /**
     * @param {Client} client
     * @returns {Promise<TransactionReceipt>}
     */
    getReceipt(client) {
        return CACHE.transactionReceiptQueryConstructor()
            .setTransactionId(this)
            .execute(client);
    }

    /**
     * @param {Client} client
     * @returns {Promise<TransactionRecord>}
     */
    async getRecord(client) {
        await this.getReceipt(client);

        return CACHE.transactionRecordQueryConstructor()
            .setTransactionId(this)
            .execute(client);
    }
}
// Filename: src/transaction/TransactionReceipt.js
// SPDX-License-Identifier: Apache-2.0

import AccountId from "../account/AccountId.js";
import ContractId from "../contract/ContractId.js";
import FileId from "../file/FileId.js";
import TopicId from "../topic/TopicId.js";
import TokenId from "../token/TokenId.js";
import ScheduleId from "../schedule/ScheduleId.js";
import ExchangeRate from "../ExchangeRate.js";
import Status from "../Status.js";
import Long from "long";
import * as HieroProto from "@hashgraph/proto";
import TransactionId from "../transaction/TransactionId.js";
import * as hex from "../encoding/hex.js";

/**
 * @typedef {import("../ExchangeRate.js").ExchangeRateJSON} ExchangeRateJSON
 */

/**
 * @typedef {object} TransactionReceiptJSON
 * @property {string} status
 * @property {?string} accountId
 * @property {?string} filedId
 * @property {?string} contractId
 * @property {?string} topicId
 * @property {?string} tokenId
 * @property {?string} scheduleId
 * @property {?ExchangeRateJSON} exchangeRate
 * @property {?ExchangeRateJSON} nextExchangeRate
 * @property {?string} topicSequenceNumber
 * @property {?string} topicRunningHash
 * @property {?string} totalSupply
 * @property {?string} scheduledTransactionId
 * @property {string[]} serials
 * @property {TransactionReceiptJSON[]} duplicates
 * @property {TransactionReceiptJSON[]} children
 * @property {?string} nodeId
 */

/**
 * The consensus result for a transaction, which might not be currently known,
 * or may succeed or fail.
 */
export default class TransactionReceipt {
    /**
     * @private
     * @param {object} props
     * @param {Status} props.status
     * @param {?AccountId} props.accountId
     * @param {?FileId} props.fileId
     * @param {?ContractId} props.contractId
     * @param {?TopicId} props.topicId
     * @param {?TokenId} props.tokenId
     * @param {?ScheduleId} props.scheduleId
     * @param {?ExchangeRate} props.exchangeRate
     * @param {?ExchangeRate} props.nextExchangeRate
     * @param {?Long} props.topicSequenceNumber
     * @param {?Uint8Array} props.topicRunningHash
     * @param {?Long} props.totalSupply
     * @param {?TransactionId} props.scheduledTransactionId
     * @param {Long[]} props.serials
     * @param {TransactionReceipt[]} props.duplicates
     * @param {TransactionReceipt[]} props.children
     * @param {?Long} props.nodeId
     */
    constructor(props) {
        /**
         * Whether the transaction succeeded or failed (or is unknown).
         *
         * @readonly
         */
        this.status = props.status;

        /**
         * The account ID, if a new account was created.
         *
         * @readonly
         */
        this.accountId = props.accountId;

        /**
         * The file ID, if a new file was created.
         *
         * @readonly
         */
        this.fileId = props.fileId;

        /**
         * The contract ID, if a new contract was created.
         *
         * @readonly
         */
        this.contractId = props.contractId;

        /**
         * The topic ID, if a new topic was created.
         *
         * @readonly
         */
        this.topicId = props.topicId;

        /**
         * The token ID, if a new token was created.
         *
         * @readonly
         */
        this.tokenId = props.tokenId;

        /**
         * The schedule ID, if a new schedule was created.
         *
         * @readonly
         */
        this.scheduleId = props.scheduleId;

        /**
         * The exchange rate of Hbars to cents (USD).
         *
         * @readonly
         */
        this.exchangeRate = props.exchangeRate;

        /**
         * The next exchange rate of Hbars to cents (USD).
         *
         * @readonly
         */
        this.nextExchangeRate = props.nextExchangeRate;

        /**
         * Updated sequence number for a consensus service topic.
         *
         * @readonly
         */
        this.topicSequenceNumber = props.topicSequenceNumber;

        /**
         * Updated running hash for a consensus service topic.
         *
         * @readonly
         */
        this.topicRunningHash = props.topicRunningHash;

        /**
         * Updated total supply for a token
         *
         * @readonly
         */
        this.totalSupply = props.totalSupply;

        this.scheduledTransactionId = props.scheduledTransactionId;

        this.serials = props.serials ?? [];

        /**
         * @readonly
         */
        this.duplicates = props.duplicates ?? [];

        /**
         * @readonly
         */
        this.children = props.children ?? [];

        /**
         * @readonly
         * @description In the receipt of a NodeCreate, NodeUpdate, NodeDelete, the id of the newly created node.
         * An affected node identifier.
         * This value SHALL be set following a `createNode` transaction.
         * This value SHALL be set following a `updateNode` transaction.
         * This value SHALL be set following a `deleteNode` transaction.
         * This value SHALL NOT be set following any other transaction.
         */
        this.nodeId = props.nodeId;

        Object.freeze(this);
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITransactionGetReceiptResponse}
     */
    _toProtobuf() {
        const duplicates = this.duplicates.map(
            (receipt) =>
                /** @type {HieroProto.proto.ITransactionReceipt} */ (
                    receipt._toProtobuf().receipt
                ),
        );
        const children = this.children.map(
            (receipt) =>
                /** @type {HieroProto.proto.ITransactionReceipt} */ (
                    receipt._toProtobuf().receipt
                ),
        );

        return {
            duplicateTransactionReceipts: duplicates,
            childTransactionReceipts: children,
            receipt: {
                status: this.status.valueOf(),

                accountID:
                    this.accountId != null
                        ? this.accountId._toProtobuf()
                        : null,
                fileID: this.fileId != null ? this.fileId._toProtobuf() : null,
                contractID:
                    this.contractId != null
                        ? this.contractId._toProtobuf()
                        : null,
                topicID:
                    this.topicId != null ? this.topicId._toProtobuf() : null,
                tokenID:
                    this.tokenId != null ? this.tokenId._toProtobuf() : null,
                scheduleID:
                    this.scheduleId != null
                        ? this.scheduleId._toProtobuf()
                        : null,

                topicRunningHash:
                    this.topicRunningHash == null
                        ? null
                        : this.topicRunningHash,

                topicSequenceNumber: this.topicSequenceNumber,

                exchangeRate: {
                    nextRate:
                        this.nextExchangeRate != null
                            ? this.nextExchangeRate._toProtobuf()
                            : null,
                    currentRate:
                        this.exchangeRate != null
                            ? this.exchangeRate._toProtobuf()
                            : null,
                },

                scheduledTransactionID:
                    this.scheduledTransactionId != null
                        ? this.scheduledTransactionId._toProtobuf()
                        : null,

                serialNumbers: this.serials,
                newTotalSupply: this.totalSupply,
                nodeId: this.nodeId,
            },
        };
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransactionGetReceiptResponse} response
     * @returns {TransactionReceipt}
     */
    static _fromProtobuf(response) {
        const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
            response.receipt
        );

        const children =
            response.childTransactionReceipts != null
                ? response.childTransactionReceipts.map((child) =>
                      TransactionReceipt._fromProtobuf({ receipt: child }),
                  )
                : [];

        const duplicates =
            response.duplicateTransactionReceipts != null
                ? response.duplicateTransactionReceipts.map((duplicate) =>
                      TransactionReceipt._fromProtobuf({ receipt: duplicate }),
                  )
                : [];

        return new TransactionReceipt({
            status: Status._fromCode(
                receipt.status != null ? receipt.status : 0,
            ),

            accountId:
                receipt.accountID != null
                    ? AccountId._fromProtobuf(receipt.accountID)
                    : null,

            fileId:
                receipt.fileID != null
                    ? FileId._fromProtobuf(receipt.fileID)
                    : null,

            contractId:
                receipt.contractID != null
                    ? ContractId._fromProtobuf(receipt.contractID)
                    : null,

            topicId:
                receipt.topicID != null
                    ? TopicId._fromProtobuf(receipt.topicID)
                    : null,

            tokenId:
                receipt.tokenID != null
                    ? TokenId._fromProtobuf(receipt.tokenID)
                    : null,

            scheduleId:
                receipt.scheduleID != null
                    ? ScheduleId._fromProtobuf(receipt.scheduleID)
                    : null,

            exchangeRate:
                receipt.exchangeRate != null
                    ? ExchangeRate._fromProtobuf(
                          /** @type {HieroProto.proto.IExchangeRate} */
                          (receipt.exchangeRate.currentRate),
                      )
                    : null,

            nextExchangeRate:
                receipt.exchangeRate != null
                    ? ExchangeRate._fromProtobuf(
                          /** @type {HieroProto.proto.IExchangeRate} */
                          (receipt.exchangeRate.nextRate),
                      )
                    : null,

            topicSequenceNumber:
                receipt.topicSequenceNumber == null
                    ? null
                    : Long.fromString(receipt.topicSequenceNumber.toString()),

            topicRunningHash:
                receipt.topicRunningHash != null
                    ? new Uint8Array(receipt.topicRunningHash)
                    : null,

            totalSupply:
                receipt.newTotalSupply != null
                    ? Long.fromString(receipt.newTotalSupply.toString())
                    : null,

            scheduledTransactionId:
                receipt.scheduledTransactionID != null
                    ? TransactionId._fromProtobuf(
                          receipt.scheduledTransactionID,
                      )
                    : null,
            serials:
                receipt.serialNumbers != null
                    ? receipt.serialNumbers.map((serial) =>
                          Long.fromValue(serial),
                      )
                    : [],
            children,
            duplicates,
            nodeId: receipt.nodeId != null ? receipt.nodeId : null,
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionReceipt}
     */
    static fromBytes(bytes) {
        return TransactionReceipt._fromProtobuf(
            HieroProto.proto.TransactionGetReceiptResponse.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TransactionGetReceiptResponse.encode(
            this._toProtobuf(),
        ).finish();
    }

    /**
     * @returns {TransactionReceiptJSON}
     */
    toJSON() {
        return {
            status: this.status.toString(),
            accountId: this.accountId?.toString() || null,
            filedId: this.fileId?.toString() || null,
            contractId: this.contractId?.toString() || null,
            topicId: this.topicId?.toString() || null,
            tokenId: this.tokenId?.toString() || null,
            scheduleId: this.scheduleId?.toString() || null,
            exchangeRate: this.exchangeRate?.toJSON() || null,
            nextExchangeRate: this.nextExchangeRate?.toJSON() || null,
            topicSequenceNumber: this.topicSequenceNumber?.toString() || null,
            topicRunningHash:
                this.topicRunningHash != null
                    ? hex.encode(this.topicRunningHash)
                    : null,
            totalSupply: this.totalSupply?.toString() || null,
            scheduledTransactionId:
                this.scheduledTransactionId?.toString() || null,
            serials: this.serials.map((serial) => serial.toString()),
            duplicates: this.duplicates.map((receipt) => receipt.toJSON()),
            children: this.children.map((receipt) => receipt.toJSON()),
            nodeId: this.nodeId?.toString() || null,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
// Filename: src/transaction/TransactionReceiptQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import Status from "../Status.js";
import TransactionReceipt from "./TransactionReceipt.js";
import TransactionId from "./TransactionId.js";
import PrecheckStatusError from "../PrecheckStatusError.js";
import ReceiptStatusError from "../ReceiptStatusError.js";
import { ExecutionState } from "../Executable.js";
import * as HieroProto from "@hashgraph/proto";

const { proto } = HieroProto;

/**
 * @typedef {import("../account/AccountId.js").default} AccountId
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 */

/**
 * Get the receipt of a transaction, given its transaction ID.
 *
 * <p>Once a transaction reaches consensus, then information about whether it succeeded or failed
 * will be available until the end of the receipt period.
 *
 * <p>This query is free.
 * @augments {Query<TransactionReceipt>}
 */
export default class TransactionReceiptQuery extends Query {
    /**
     * @param {object} [props]
     * @param {TransactionId | string} [props.transactionId]
     * @param {boolean} [props.includeDuplicates]
     * @param {boolean} [props.includeChildren]
     * @param {boolean} [props.validateStatus]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TransactionId}
         */
        this._transactionId = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeChildren = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeDuplicates = null;

        this._validateStatus = true;

        if (props.transactionId != null) {
            this.setTransactionId(props.transactionId);
        }

        if (props.includeChildren != null) {
            this.setIncludeChildren(props.includeChildren);
        }

        if (props.includeDuplicates != null) {
            this.setIncludeDuplicates(props.includeDuplicates);
        }

        if (props.validateStatus != null) {
            this.setValidateStatus(props.validateStatus);
        }
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {TransactionReceiptQuery}
     */
    static _fromProtobuf(query) {
        const receipt =
            /** @type {HieroProto.proto.ITransactionGetReceiptQuery} */ (
                query.transactionGetReceipt
            );

        return new TransactionReceiptQuery({
            transactionId: receipt.transactionID
                ? TransactionId._fromProtobuf(receipt.transactionID)
                : undefined,
            includeDuplicates:
                receipt.includeDuplicates != null
                    ? receipt.includeDuplicates
                    : undefined,
            includeChildren:
                receipt.includeChildReceipts != null
                    ? receipt.includeChildReceipts
                    : undefined,
        });
    }

    /**
     * @returns {?TransactionId}
     */
    get transactionId() {
        return this._transactionId;
    }

    /**
     * Set the transaction ID for which the receipt is being requested.
     *
     * @param {TransactionId | string} transactionId
     * @returns {this}
     */
    setTransactionId(transactionId) {
        this._transactionId =
            typeof transactionId === "string"
                ? TransactionId.fromString(transactionId)
                : transactionId.clone();

        return this;
    }

    /**
     * @param {boolean} includeDuplicates
     * @returns {TransactionReceiptQuery}
     */
    setIncludeDuplicates(includeDuplicates) {
        this._includeDuplicates = includeDuplicates;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeDuplicates() {
        return this._includeDuplicates != null
            ? this._includeDuplicates
            : false;
    }

    /**
     * @param {boolean} includeChildren
     * @returns {TransactionReceiptQuery}
     */
    setIncludeChildren(includeChildren) {
        this._includeChildren = includeChildren;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeChildren() {
        return this._includeChildren != null ? this._includeChildren : false;
    }

    /**
     * @param {boolean} validateStatus
     * @returns {this}
     */
    setValidateStatus(validateStatus) {
        this._validateStatus = validateStatus;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get validateStatus() {
        return this._validateStatus;
    }

    /**
     * @override
     * @protected
     * @returns {boolean}
     */
    _isPaymentRequired() {
        return false;
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @returns {[Status, ExecutionState]}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : proto.ResponseCodeEnum.OK,
        );

        if (this._logger) {
            this._logger.debug(
                `[${this._getLogId()}] received node precheck status ${status.toString()}`,
            );
        }

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
            case Status.PlatformNotActive:
                return [status, ExecutionState.Retry];
            case Status.Ok:
                break;
            default:
                return [status, ExecutionState.Error];
        }

        const transactionGetReceipt =
            /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );
        const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
            transactionGetReceipt.receipt
        );
        const receiptStatusCode =
            /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);

        status = Status._fromCode(receiptStatusCode);

        if (this._logger) {
            this._logger.debug(
                `[${this._getLogId()}] received receipt status ${status.toString()}`,
            );
        }

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
                return [status, ExecutionState.Retry];
            case Status.Success:
            case Status.FeeScheduleFilePartUploaded:
                return [status, ExecutionState.Finished];
            default:
                return [
                    status,
                    this._validateStatus
                        ? ExecutionState.Error
                        : ExecutionState.Finished,
                ];
        }
    }

    /**
     * @returns {TransactionId}
     */
    _getTransactionId() {
        if (this._transactionId != null) {
            return this._transactionId;
        }

        return super._getTransactionId();
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response, nodeId) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : proto.ResponseCodeEnum.OK,
        );

        switch (status) {
            case Status.Ok:
                // Do nothing
                break;

            default:
                return new PrecheckStatusError({
                    nodeId,
                    status,
                    transactionId: this._getTransactionId(),
                    contractFunctionResult: null,
                });
        }

        const transactionGetReceipt =
            /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );
        const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
            transactionGetReceipt.receipt
        );
        const receiptStatusCode =
            /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);

        status = Status._fromCode(receiptStatusCode);

        if (this._transactionId == null) {
            throw new Error(
                "Failed to construct `ReceiptStatusError` because `transactionId` is `null`",
            );
        }

        return new ReceiptStatusError({
            status,
            transactionId: this._transactionId,
            transactionReceipt: TransactionReceipt._fromProtobuf(
                transactionGetReceipt,
            ),
        });
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (
            this._transactionId != null &&
            this._transactionId.accountId != null
        ) {
            this._transactionId.accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getTransactionReceipts(request);
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const transactionGetReceipt =
            /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            transactionGetReceipt.header
        );
    }

    /**
     * @protected
     * @override
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<TransactionReceipt>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const transactionGetReceipt =
            /** @type {HieroProto.proto.ITransactionGetReceiptResponse} */ (
                response.transactionGetReceipt
            );

        return Promise.resolve(
            TransactionReceipt._fromProtobuf(transactionGetReceipt),
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            transactionGetReceipt: {
                header,
                transactionID:
                    this._transactionId != null
                        ? this._transactionId._toProtobuf()
                        : null,
                includeDuplicates: this._includeDuplicates,
                includeChildReceipts: this._includeChildren,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        return `TransactionReceiptQuery:${this._timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "transactionGetReceipt",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TransactionReceiptQuery._fromProtobuf,
);
// Filename: src/transaction/TransactionRecord.js
// SPDX-License-Identifier: Apache-2.0

import TransactionReceipt from "./TransactionReceipt.js";
import TransactionId from "./TransactionId.js";
import Timestamp from "../Timestamp.js";
import Hbar from "../Hbar.js";
import Transfer from "../Transfer.js";
import ContractFunctionResult from "../contract/ContractFunctionResult.js";
import TokenTransferMap from "../account/TokenTransferMap.js";
import TokenNftTransferMap from "../account/TokenNftTransferMap.js";
import * as HieroProto from "@hashgraph/proto";
import ScheduleId from "../schedule/ScheduleId.js";
import AssessedCustomFee from "../token/AssessedCustomFee.js";
import TokenAssocation from "../token/TokenAssociation.js";
import Key from "../Key.js";
import PublicKey from "../PublicKey.js";
import TokenTransfer from "../token/TokenTransfer.js";
import EvmAddress from "../EvmAddress.js";
import * as hex from "../encoding/hex.js";
import PendingAirdropRecord from "../token/PendingAirdropRecord.js";

/**
 * @typedef {import("../token/TokenId.js").default} TokenId
 * @typedef {import("../token/TokenTransfer.js").TokenTransferJSON} TokenTransferJSON
 * @typedef {import("../account/HbarAllowance.js").default} HbarAllowance
 * @typedef {import("../account/TokenAllowance.js").default} TokenAllowance
 * @typedef {import("../account/TokenNftAllowance.js").default} TokenNftAllowance
 * @typedef {import("./TransactionReceipt.js").TransactionReceiptJSON} TransactionReceiptJSON
 * @typedef {import("../Transfer.js").TransferJSON} TransferJSON
 */

/**
 * @typedef {object} TransactionRecordJSON
 * @property {TransactionReceiptJSON} receipt
 * @property {?string} transactionHash
 * @property {Date} consensusTimestamp
 * @property {string} transactionId
 * @property {string} transactionMemo
 * @property {string} transactionFee
 * @property {TransferJSON[]} transfers
 * @property {TokenTransferMap} tokenTransfers
 * @property {TokenTransferJSON[]} tokenTransfersList
 * @property {?string} scheduleRef
 * @property {AssessedCustomFee[]} assessedCustomFees
 * @property {TokenNftTransferMap} nftTransfers
 * @property {TokenAssocation[]} automaticTokenAssociations
 * @property {Date | null} parentConsensusTimestamp
 * @property {?string} aliasKey
 * @property {TransactionRecord[]} duplicates
 * @property {TransactionRecord[]} children
 * @property {?string} ethereumHash
 * @property {Transfer[]} paidStakingRewards
 * @property {?string} prngBytes
 * @property {?number} prngNumber
 * @property {?string} evmAddress
 */

/**
 * Either the record of processing the first consensus transaction with the given id whose
 * status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
 * <b>or</b>, if no such record exists, the record of processing the first transaction to reach
 * consensus with the given transaction id.
 */
export default class TransactionRecord {
    /**
     * @private
     * @param {object} props
     * @param {ContractFunctionResult} [props.contractFunctionResult]
     * @param {TransactionReceipt} props.receipt
     * @param {Uint8Array} props.transactionHash
     * @param {Timestamp} props.consensusTimestamp
     * @param {TransactionId} props.transactionId
     * @param {string} props.transactionMemo
     * @param {Hbar} props.transactionFee
     * @param {Transfer[]} props.transfers
     * @param {TokenTransferMap} props.tokenTransfers
     * @param {TokenTransfer[]} props.tokenTransfersList
     * @param {?ScheduleId} props.scheduleRef
     * @param {AssessedCustomFee[]} props.assessedCustomFees
     * @param {TokenNftTransferMap} props.nftTransfers
     * @param {TokenAssocation[]} props.automaticTokenAssociations
     * @param {Timestamp | null} props.parentConsensusTimestamp
     * @param {PublicKey | null} props.aliasKey
     * @param {TransactionRecord[]} props.duplicates
     * @param {TransactionRecord[]} props.children
     * @param {HbarAllowance[]} props.hbarAllowanceAdjustments
     * @param {TokenAllowance[]} props.tokenAllowanceAdjustments
     * @param {TokenNftAllowance[]} props.nftAllowanceAdjustments
     * @param {?Uint8Array} props.ethereumHash
     * @param {Transfer[]} props.paidStakingRewards
     * @param {?Uint8Array} props.prngBytes
     * @param {?number} props.prngNumber
     * @param {?EvmAddress} props.evmAddress
     * @param {PendingAirdropRecord[]} props.newPendingAirdrops
     */
    constructor(props) {
        /**
         * The status (reach consensus, or failed, or is unknown) and the ID of
         * any new account/file/instance created.
         *
         * @readonly
         */
        this.receipt = props.receipt;

        /**
         * The hash of the Transaction that executed (not the hash of any Transaction that failed
         * for having a duplicate TransactionID).
         *
         * @readonly
         */
        this.transactionHash = props.transactionHash;

        /**
         * The consensus timestamp (or null if didn't reach consensus yet).
         *
         * @readonly
         */
        this.consensusTimestamp = props.consensusTimestamp;

        /**
         * The ID of the transaction this record represents.
         *
         * @readonly
         */
        this.transactionId = props.transactionId;

        /**
         * The memo that was submitted as part of the transaction (max 100 bytes).
         *
         * @readonly
         */
        this.transactionMemo = props.transactionMemo;

        /**
         * The actual transaction fee charged,
         * not the original transactionFee value from TransactionBody.
         *
         * @readonly
         */
        this.transactionFee = props.transactionFee;

        /**
         * All hbar transfers as a result of this transaction, such as fees, or transfers performed
         * by the transaction, or by a smart contract it calls, or by the creation of threshold
         * records that it triggers.
         *
         * @readonly
         */
        this.transfers = props.transfers;

        /**
         * Record of the value returned by the smart contract function or constructor.
         *
         * @readonly
         */
        this.contractFunctionResult =
            props.contractFunctionResult != null
                ? props.contractFunctionResult
                : null;

        /**
         * All the token transfers from this account
         *
         * @readonly
         */
        this.tokenTransfers = props.tokenTransfers;

        /**
         * All the token transfers from this account
         *
         * @readonly
         */
        this.tokenTransfersList = props.tokenTransfersList;

        /**
         * Reference to the scheduled transaction ID that this transaction record represent
         *
         * @readonly
         */
        this.scheduleRef = props.scheduleRef;

        /**
         * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
         * transaction status resolved to SUCCESS
         *
         * @readonly
         */
        this.assessedCustomFees = props.assessedCustomFees;

        /** @readonly */
        this.nftTransfers = props.nftTransfers;

        /**
         * All token associations implicitly created while handling this transaction
         *
         * @readonly
         */
        this.automaticTokenAssociations = props.automaticTokenAssociations;

        /**
         * In the record of an internal transaction, the consensus timestamp of the user
         * transaction that spawned it.
         *
         * @readonly
         */
        this.parentConsensusTimestamp = props.parentConsensusTimestamp;

        /**
         * In the record of an internal CryptoCreate transaction triggered by a user
         * transaction with a (previously unused) alias, the new account's alias.
         *
         * @readonly
         */
        this.aliasKey = props.aliasKey;

        /**
         * The records of processing all consensus transaction with the same id as the distinguished
         * record above, in chronological order.
         *
         * @readonly
         */
        this.duplicates = props.duplicates;

        /**
         * The records of processing all child transaction spawned by the transaction with the given
         * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
         *
         * @readonly
         */
        this.children = props.children;

        /**
         * @deprecated
         * @readonly
         */
        // eslint-disable-next-line deprecation/deprecation
        this.hbarAllowanceAdjustments = props.hbarAllowanceAdjustments;

        /**
         * @deprecated
         * @readonly
         */
        // eslint-disable-next-line deprecation/deprecation
        this.tokenAllowanceAdjustments = props.tokenAllowanceAdjustments;

        /**
         * @deprecated
         * @readonly
         */
        // eslint-disable-next-line deprecation/deprecation
        this.nftAllowanceAdjustments = props.nftAllowanceAdjustments;

        /**
         * The keccak256 hash of the ethereumData. This field will only be populated for
         * EthereumTransaction.
         *
         * @readonly
         */
        this.ethereumHash = props.ethereumHash;

        /**
         * List of accounts with the corresponding staking rewards paid as a result of a transaction.
         *
         * @readonly
         */
        this.paidStakingRewards = props.paidStakingRewards;

        /**
         * In the record of a PRNG transaction with no output range, a pseudorandom 384-bit string.
         *
         * @readonly
         */
        this.prngBytes = props.prngBytes;

        /**
         * In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string.
         *
         * @readonly
         */
        this.prngNumber = props.prngNumber;

        /**
         * The new default EVM address of the account created by this transaction.
         * This field is populated only when the EVM address is not specified in the related transaction body.
         *
         * @readonly
         */
        this.evmAddress = props.evmAddress;

        /**
         * The new default EVM address of the account created by this transaction.
         * This field is populated only when the EVM address is not specified in the related transaction body.
         *
         * @readonly
         */
        this.newPendingAirdrops = props.newPendingAirdrops;

        Object.freeze(this);
    }

    /**
     * @internal
     * @returns {HieroProto.proto.ITransactionGetRecordResponse}
     */
    _toProtobuf() {
        const tokenTransfers = this.tokenTransfers._toProtobuf();
        const nftTransfers = this.nftTransfers._toProtobuf();

        const tokenTransferLists = [];

        for (const tokenTransfer of tokenTransfers) {
            for (const nftTransfer of nftTransfers) {
                if (
                    tokenTransfer.token != null &&
                    nftTransfer.token != null &&
                    tokenTransfer.token.shardNum ===
                        nftTransfer.token.shardNum &&
                    tokenTransfer.token.realmNum ===
                        nftTransfer.token.realmNum &&
                    tokenTransfer.token.tokenNum === nftTransfer.token.tokenNum
                ) {
                    tokenTransferLists.push({
                        token: tokenTransfer.token,
                        transfers: tokenTransfer.transfers,
                        nftTransfers: tokenTransfer.nftTransfers,
                    });
                } else {
                    tokenTransferLists.push(tokenTransfer);
                    tokenTransferLists.push(nftTransfer);
                }
            }
        }

        const duplicates = this.duplicates.map(
            (record) =>
                /** @type {HieroProto.proto.ITransactionRecord} */ (
                    record._toProtobuf().transactionRecord
                ),
        );
        const children = this.children.map(
            (record) =>
                /** @type {HieroProto.proto.ITransactionRecord} */ (
                    record._toProtobuf().transactionRecord
                ),
        );

        return {
            duplicateTransactionRecords: duplicates,
            childTransactionRecords: children,
            transactionRecord: {
                receipt: this.receipt._toProtobuf().receipt,

                transactionHash:
                    this.transactionHash != null ? this.transactionHash : null,
                consensusTimestamp:
                    this.consensusTimestamp != null
                        ? this.consensusTimestamp._toProtobuf()
                        : null,
                transactionID:
                    this.transactionId != null
                        ? this.transactionId._toProtobuf()
                        : null,
                memo:
                    this.transactionMemo != null ? this.transactionMemo : null,

                transactionFee:
                    this.transactionFee != null
                        ? this.transactionFee.toTinybars()
                        : null,

                contractCallResult:
                    this.contractFunctionResult != null &&
                    !this.contractFunctionResult._createResult
                        ? this.contractFunctionResult._toProtobuf()
                        : null,

                contractCreateResult:
                    this.contractFunctionResult != null &&
                    this.contractFunctionResult._createResult
                        ? this.contractFunctionResult._toProtobuf()
                        : null,

                transferList:
                    this.transfers != null
                        ? {
                              accountAmounts: this.transfers.map((transfer) =>
                                  transfer._toProtobuf(),
                              ),
                          }
                        : null,
                tokenTransferLists,
                scheduleRef:
                    this.scheduleRef != null
                        ? this.scheduleRef._toProtobuf()
                        : null,
                assessedCustomFees: this.assessedCustomFees.map((fee) =>
                    fee._toProtobuf(),
                ),
                automaticTokenAssociations: this.automaticTokenAssociations.map(
                    (association) => association._toProtobuf(),
                ),
                parentConsensusTimestamp:
                    this.parentConsensusTimestamp != null
                        ? this.parentConsensusTimestamp._toProtobuf()
                        : null,
                alias:
                    this.aliasKey != null
                        ? HieroProto.proto.Key.encode(
                              this.aliasKey._toProtobufKey(),
                          ).finish()
                        : null,
                ethereumHash: this.ethereumHash,

                paidStakingRewards: this.paidStakingRewards.map((transfer) =>
                    transfer._toProtobuf(),
                ),

                prngBytes: this.prngBytes,
                prngNumber: this.prngNumber != null ? this.prngNumber : null,
                evmAddress:
                    this.evmAddress != null ? this.evmAddress.toBytes() : null,
                newPendingAirdrops: this.newPendingAirdrops.map((airdrop) =>
                    airdrop.toBytes(),
                ),
            },
        };
    }

    /**
     * @internal
     * @param {HieroProto.proto.ITransactionGetRecordResponse} response
     * @returns {TransactionRecord}
     */
    static _fromProtobuf(response) {
        const record = /** @type {HieroProto.proto.ITransactionRecord} */ (
            response.transactionRecord
        );

        let aliasKey =
            record.alias != null && record.alias.length > 0
                ? Key._fromProtobufKey(
                      HieroProto.proto.Key.decode(record.alias),
                  )
                : null;

        if (!(aliasKey instanceof PublicKey)) {
            aliasKey = null;
        }

        const children =
            response.childTransactionRecords != null
                ? response.childTransactionRecords.map((child) =>
                      TransactionRecord._fromProtobuf({
                          transactionRecord: child,
                      }),
                  )
                : [];

        const duplicates =
            response.duplicateTransactionRecords != null
                ? response.duplicateTransactionRecords.map((duplicate) =>
                      TransactionRecord._fromProtobuf({
                          transactionRecord: duplicate,
                      }),
                  )
                : [];

        const contractFunctionResult =
            record.contractCallResult != null
                ? ContractFunctionResult._fromProtobuf(
                      record.contractCallResult,
                      false,
                  )
                : record.contractCreateResult != null
                  ? ContractFunctionResult._fromProtobuf(
                        record.contractCreateResult,
                        true,
                    )
                  : undefined;

        const newPendingAirdrops =
            record.newPendingAirdrops != null
                ? record.newPendingAirdrops.map((airdrop) =>
                      PendingAirdropRecord.fromBytes(airdrop),
                  )
                : [];

        return new TransactionRecord({
            receipt: TransactionReceipt._fromProtobuf({
                receipt: /** @type {HieroProto.proto.ITransactionReceipt} */ (
                    record.receipt
                ),
            }),
            transactionHash:
                record.transactionHash != null
                    ? record.transactionHash
                    : new Uint8Array(),
            consensusTimestamp: Timestamp._fromProtobuf(
                /** @type {HieroProto.proto.ITimestamp} */
                (record.consensusTimestamp),
            ),
            transactionId: TransactionId._fromProtobuf(
                /** @type {HieroProto.proto.ITransactionID} */ (
                    record.transactionID
                ),
            ),
            transactionMemo: record.memo != null ? record.memo : "",
            transactionFee: Hbar.fromTinybars(
                record.transactionFee != null ? record.transactionFee : 0,
            ),
            transfers: Transfer._fromProtobuf(
                record.transferList != null
                    ? record.transferList.accountAmounts != null
                        ? record.transferList.accountAmounts
                        : []
                    : [],
            ),
            contractFunctionResult,
            tokenTransfers: TokenTransferMap._fromProtobuf(
                record.tokenTransferLists != null
                    ? record.tokenTransferLists
                    : [],
            ),
            tokenTransfersList: TokenTransfer._fromProtobuf(
                record.tokenTransferLists != null
                    ? record.tokenTransferLists
                    : [],
            ),
            scheduleRef:
                record.scheduleRef != null
                    ? ScheduleId._fromProtobuf(record.scheduleRef)
                    : null,
            assessedCustomFees:
                record.assessedCustomFees != null
                    ? record.assessedCustomFees.map((fee) =>
                          AssessedCustomFee._fromProtobuf(fee),
                      )
                    : [],
            nftTransfers: TokenNftTransferMap._fromProtobuf(
                record.tokenTransferLists != null
                    ? record.tokenTransferLists
                    : [],
            ),
            automaticTokenAssociations:
                record.automaticTokenAssociations != null
                    ? record.automaticTokenAssociations.map((association) =>
                          TokenAssocation._fromProtobuf(association),
                      )
                    : [],
            parentConsensusTimestamp:
                record.parentConsensusTimestamp != null
                    ? Timestamp._fromProtobuf(record.parentConsensusTimestamp)
                    : null,
            aliasKey,
            duplicates,
            children,
            hbarAllowanceAdjustments: [],
            tokenAllowanceAdjustments: [],
            nftAllowanceAdjustments: [],
            ethereumHash:
                record.ethereumHash != null ? record.ethereumHash : null,
            paidStakingRewards:
                record.paidStakingRewards != null
                    ? Transfer._fromProtobuf(record.paidStakingRewards)
                    : [],
            prngBytes: record.prngBytes != null ? record.prngBytes : null,
            prngNumber: record.prngNumber != null ? record.prngNumber : null,
            evmAddress:
                record.evmAddress != null
                    ? EvmAddress.fromBytes(record.evmAddress)
                    : null,
            newPendingAirdrops: newPendingAirdrops,
        });
    }

    /**
     * @param {Uint8Array} bytes
     * @returns {TransactionRecord}
     */
    static fromBytes(bytes) {
        return TransactionRecord._fromProtobuf(
            HieroProto.proto.TransactionGetRecordResponse.decode(bytes),
        );
    }

    /**
     * @returns {Uint8Array}
     */
    toBytes() {
        return HieroProto.proto.TransactionGetRecordResponse.encode(
            this._toProtobuf(),
        ).finish();
    }

    /**
     * @returns {TransactionRecordJSON}
     */
    toJSON() {
        return {
            receipt: this.receipt.toJSON(),
            transactionHash: hex.encode(this.transactionHash),
            consensusTimestamp: this.consensusTimestamp.toDate(),
            transactionId: this.transactionId.toString(),
            transactionMemo: this.transactionMemo,
            transactionFee: this.transactionFee.toTinybars().toString(),
            transfers: this.transfers.map((transfer) => transfer.toJSON()),
            tokenTransfers: this.tokenTransfers,
            tokenTransfersList: this.tokenTransfersList.map((transfer) =>
                transfer.toJSON(),
            ),
            scheduleRef: this.scheduleRef?.toString() || null,
            assessedCustomFees: this.assessedCustomFees,
            nftTransfers: this.nftTransfers,
            automaticTokenAssociations: this.automaticTokenAssociations,
            parentConsensusTimestamp:
                this.parentConsensusTimestamp?.toDate() || null,
            aliasKey: this.aliasKey?.toString() || null,
            duplicates: this.duplicates,
            children: this.children,
            ethereumHash:
                this.ethereumHash != null
                    ? hex.encode(this.ethereumHash)
                    : null,
            paidStakingRewards: this.paidStakingRewards,
            prngBytes:
                this.prngBytes != null ? hex.encode(this.prngBytes) : null,
            prngNumber: this.prngNumber,
            evmAddress: this.evmAddress?.toString() || null,
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
// Filename: src/transaction/TransactionRecordQuery.js
// SPDX-License-Identifier: Apache-2.0

import Query, { QUERY_REGISTRY } from "../query/Query.js";
import TransactionRecord from "./TransactionRecord.js";
import TransactionReceipt from "./TransactionReceipt.js";
import TransactionId from "./TransactionId.js";
import Status from "../Status.js";
import PrecheckStatusError from "../PrecheckStatusError.js";
import ReceiptStatusError from "../ReceiptStatusError.js";
import RecordStatusError from "../RecordStatusError.js";
import { ExecutionState } from "../Executable.js";
import * as HieroProto from "@hashgraph/proto";

const { proto } = HieroProto;

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("../account/AccountId.js").default} AccountId
 */

/**
 * Get the record for a transaction.
 * <p>
 * If the transaction requested a record, then the record lasts for one hour, and a state proof is available for it.
 * If the transaction created an account, file, or smart contract instance, then the record will contain the ID for
 * what it created. If the transaction called a smart contract function, then the record contains the result of
 * that call. If the transaction was a cryptocurrency transfer, then the record includes the TransferList
 * which gives the details of that transfer. If the transaction didn't return anything that should be
 * in the record, then the results field will be set to nothing.
 * @augments {Query<TransactionRecord>}
 */
export default class TransactionRecordQuery extends Query {
    /**
     * @param {object} [props]
     * @param {TransactionId} [props.transactionId]
     * @param {boolean} [props.includeChildren]
     * @param {boolean} [props.includeDuplicates]
     * @param {boolean} [props.validateReceiptStatus]
     */
    constructor(props = {}) {
        super();

        /**
         * @private
         * @type {?TransactionId}
         */
        this._transactionId = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeChildren = null;

        /**
         * @private
         * @type {?boolean}
         */
        this._includeDuplicates = null;

        this._validateReceiptStatus = true;

        if (props.transactionId != null) {
            this.setTransactionId(props.transactionId);
        }

        if (props.includeChildren != null) {
            this.setIncludeChildren(props.includeChildren);
        }

        if (props.includeDuplicates != null) {
            this.setIncludeDuplicates(props.includeDuplicates);
        }

        if (props.validateReceiptStatus != null) {
            this.setValidateReceiptStatus(props.validateReceiptStatus);
        }
    }

    /**
     * @returns {?TransactionId}
     */
    get transactionId() {
        return this._transactionId;
    }

    /**
     * @internal
     * @param {HieroProto.proto.IQuery} query
     * @returns {TransactionRecordQuery}
     */
    static _fromProtobuf(query) {
        const record =
            /** @type {HieroProto.proto.ITransactionGetRecordQuery} */ (
                query.transactionGetRecord
            );

        return new TransactionRecordQuery({
            transactionId: record.transactionID
                ? TransactionId._fromProtobuf(record.transactionID)
                : undefined,
            includeChildren:
                record.includeChildRecords != null
                    ? record.includeChildRecords
                    : undefined,
            includeDuplicates:
                record.includeDuplicates != null
                    ? record.includeDuplicates
                    : undefined,
        });
    }

    /**
     * Set the transaction ID for which the record is being requested.
     *
     * @param {TransactionId | string} transactionId
     * @returns {TransactionRecordQuery}
     */
    setTransactionId(transactionId) {
        this._transactionId =
            typeof transactionId === "string"
                ? TransactionId.fromString(transactionId)
                : transactionId.clone();

        return this;
    }

    /**
     * @param {boolean} includeChildren
     * @returns {TransactionRecordQuery}
     */
    setIncludeChildren(includeChildren) {
        this._includeChildren = includeChildren;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeChildren() {
        return this._includeChildren != null ? this._includeChildren : false;
    }

    /**
     * @param {boolean} includeDuplicates
     * @returns {TransactionRecordQuery}
     */
    setIncludeDuplicates(includeDuplicates) {
        this._duplicates = includeDuplicates;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get includeDuplicates() {
        return this._duplicates != null ? this._duplicates : false;
    }

    /**
     * @param {boolean} validateReceiptStatus
     * @returns {this}
     */
    setValidateReceiptStatus(validateReceiptStatus) {
        this._validateReceiptStatus = validateReceiptStatus;
        return this;
    }

    /**
     * @returns {boolean}
     */
    get validateReceiptStatus() {
        return this._validateReceiptStatus;
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @returns {[Status, ExecutionState]}
     */
    _shouldRetry(request, response) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : proto.ResponseCodeEnum.OK,
        );

        if (this._logger) {
            this._logger.debug(
                `[${this._getLogId()}] received node precheck status ${status.toString()}`,
            );
        }

        switch (status) {
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
            case Status.RecordNotFound:
            case Status.PlatformNotActive:
                return [status, ExecutionState.Retry];

            case Status.Ok:
                break;

            default:
                return [status, ExecutionState.Error];
        }

        const transactionGetRecord =
            /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        const header = /** @type {HieroProto.proto.IResponseHeader} */ (
            transactionGetRecord.header
        );

        if (header.responseType === HieroProto.proto.ResponseType.COST_ANSWER) {
            return [status, ExecutionState.Finished];
        }

        const record = /** @type {HieroProto.proto.ITransactionRecord} */ (
            transactionGetRecord.transactionRecord
        );
        const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
            record.receipt
        );
        const receiptStatusCode =
            /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);
        status = Status._fromCode(receiptStatusCode);

        if (this._logger) {
            this._logger.debug(
                `[${this._getLogId()}] received record's receipt ${status.toString()}`,
            );
        }

        switch (status) {
            case Status.Ok:
            case Status.Busy:
            case Status.Unknown:
            case Status.ReceiptNotFound:
            case Status.RecordNotFound:
                return [status, ExecutionState.Retry];

            case Status.Success:
                return [status, ExecutionState.Finished];

            default:
                return [
                    status,
                    this._validateReceiptStatus
                        ? ExecutionState.Error
                        : ExecutionState.Finished,
                ];
        }
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQuery} request
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeId
     * @returns {Error}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapStatusError(request, response, nodeId) {
        const { nodeTransactionPrecheckCode } =
            this._mapResponseHeader(response);

        let status = Status._fromCode(
            nodeTransactionPrecheckCode != null
                ? nodeTransactionPrecheckCode
                : proto.ResponseCodeEnum.OK,
        );
        switch (status) {
            case Status.Ok:
                // Do nothing
                break;

            case Status.ContractRevertExecuted:
                return new RecordStatusError({
                    status,
                    transactionId: this._getTransactionId(),
                    transactionRecord: TransactionRecord._fromProtobuf({
                        transactionRecord:
                            // @ts-ignore
                            response.transactionGetRecord.transactionRecord,
                    }),
                });

            default:
                return new PrecheckStatusError({
                    nodeId,
                    status,
                    transactionId: this._getTransactionId(),
                    contractFunctionResult: null,
                });
        }

        const transactionGetRecord =
            /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        const record = /** @type {HieroProto.proto.ITransactionRecord} */ (
            transactionGetRecord.transactionRecord
        );
        const receipt = /** @type {HieroProto.proto.ITransactionReceipt} */ (
            record.receipt
        );
        const receiptStatusError =
            /** @type {HieroProto.proto.ResponseCodeEnum} */ (receipt.status);

        status = Status._fromCode(receiptStatusError);

        switch (status) {
            case Status.ContractRevertExecuted:
                return new RecordStatusError({
                    status,
                    transactionId: this._getTransactionId(),
                    transactionRecord: TransactionRecord._fromProtobuf({
                        transactionRecord:
                            // @ts-ignore
                            response.transactionGetRecord.transactionRecord,
                    }),
                });

            default:
                return new ReceiptStatusError({
                    status,
                    transactionId: this._getTransactionId(),
                    transactionReceipt: TransactionReceipt._fromProtobuf({
                        receipt,
                    }),
                });
        }
    }

    /**
     * @param {Client} client
     */
    _validateChecksums(client) {
        if (
            this._transactionId != null &&
            this._transactionId.accountId != null
        ) {
            this._transactionId.accountId.validateChecksum(client);
        }
    }

    /**
     * @override
     * @internal
     * @param {Channel} channel
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<HieroProto.proto.IResponse>}
     */
    _execute(channel, request) {
        return channel.crypto.getTxRecordByTxID(request);
    }

    /**
     * @override
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @returns {HieroProto.proto.IResponseHeader}
     */
    _mapResponseHeader(response) {
        const transactionGetRecord =
            /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        return /** @type {HieroProto.proto.IResponseHeader} */ (
            transactionGetRecord.header
        );
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IResponse} response
     * @param {AccountId} nodeAccountId
     * @param {HieroProto.proto.IQuery} request
     * @returns {Promise<TransactionRecord>}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mapResponse(response, nodeAccountId, request) {
        const record =
            /** @type {HieroProto.proto.ITransactionGetRecordResponse} */ (
                response.transactionGetRecord
            );
        return Promise.resolve(TransactionRecord._fromProtobuf(record));
    }

    /**
     * @override
     * @internal
     * @param {HieroProto.proto.IQueryHeader} header
     * @returns {HieroProto.proto.IQuery}
     */
    _onMakeRequest(header) {
        return {
            transactionGetRecord: {
                header,
                transactionID:
                    this._transactionId != null
                        ? this._transactionId._toProtobuf()
                        : null,
                includeChildRecords: this._includeChildren,
                includeDuplicates: this._includeDuplicates,
            },
        };
    }

    /**
     * @returns {string}
     */
    _getLogId() {
        const timestamp =
            this._paymentTransactionId != null &&
            this._paymentTransactionId.validStart != null
                ? this._paymentTransactionId.validStart
                : this._timestamp;

        return `TransactionRecordQuery:${timestamp.toString()}`;
    }
}

QUERY_REGISTRY.set(
    "transactionGetRecord",
    // eslint-disable-next-line @typescript-eslint/unbound-method
    TransactionRecordQuery._fromProtobuf,
);
// Filename: src/transaction/TransactionResponse.js
// SPDX-License-Identifier: Apache-2.0

import ReceiptStatusError from "../ReceiptStatusError.js";
import Status from "../Status.js";
import TransactionReceiptQuery from "./TransactionReceiptQuery.js";
import TransactionRecordQuery from "./TransactionRecordQuery.js";
import AccountId from "../account/AccountId.js";
import TransactionId from "./TransactionId.js";
import * as hex from "../encoding/hex.js";

/**
 * @typedef {import("../client/Client.js").default<*, *>} Client
 * @typedef {import("./TransactionReceipt.js").default} TransactionReceipt
 * @typedef {import("./TransactionRecord.js").default} TransactionRecord
 * @typedef {import("../Signer.js").Signer} Signer
 */

/**
 * @typedef {object} TransactionResponseJSON
 * @property {string} nodeId
 * @property {string} transactionHash
 * @property {string} transactionId
 */

/**
 * When the client sends the node a transaction of any kind, the node
 * replies with this, which simply says that the transaction passed
 * the pre-check (so the node will submit it to the network) or it failed
 * (so it won't). To learn the consensus result, the client should later
 * obtain a receipt (free), or can buy a more detailed record (not free).
 * <br>
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/miscellaneous/transactionresponse">Hedera Documentation</a>
 */
export default class TransactionResponse {
    /**
     * @internal
     * @param {object} props
     * @param {AccountId} props.nodeId
     * @param {Uint8Array} props.transactionHash
     * @param {TransactionId} props.transactionId
     */
    constructor(props) {
        /** @readonly */
        this.nodeId = props.nodeId;

        /** @readonly */
        this.transactionHash = props.transactionHash;

        /** @readonly */
        this.transactionId = props.transactionId;

        Object.freeze(this);
    }

    /**
     * @param {TransactionResponseJSON} json
     * @returns {TransactionResponse}
     */
    static fromJSON(json) {
        return new TransactionResponse({
            nodeId: AccountId.fromString(json.nodeId),
            transactionHash: hex.decode(json.transactionHash),
            transactionId: TransactionId.fromString(json.transactionId),
        });
    }

    /**
     * @param {Client} client
     * @returns {Promise<TransactionReceipt>}
     */
    async getReceipt(client) {
        const receipt = await this.getReceiptQuery().execute(client);

        if (
            receipt.status !== Status.Success &&
            receipt.status !== Status.FeeScheduleFilePartUploaded
        ) {
            throw new ReceiptStatusError({
                transactionReceipt: receipt,
                status: receipt.status,
                transactionId: this.transactionId,
            });
        }

        return receipt;
    }

    /**
     * getRecord is calling getReceipt and in case the receipt status code is not OK, only the receipt is returned.
     *
     * @param {Client} client
     * @returns {Promise<TransactionRecord>}
     */
    async getRecord(client) {
        await this.getReceipt(client);

        return this.getRecordQuery().execute(client);
    }

    /**
     * getVerboseRecord is calling getReceipt and in case the receipt status code is not OK, the record is returned.
     *
     * @param {Client} client
     * @returns {Promise<TransactionRecord>}
     */
    async getVerboseRecord(client) {
        try {
            // The receipt needs to be called in order to wait for transaction to be included in the consensus. Otherwise we are going to get "DUPLICATE_TRANSACTION".
            await this.getReceiptQuery().execute(client);
            return this.getRecordQuery().execute(client);
        } catch (e) {
            return this.getRecordQuery().execute(client);
        }
    }

    /**
     * @param {Signer} signer
     * @returns {Promise<TransactionReceipt>}
     */
    async getReceiptWithSigner(signer) {
        const receipt = await this.getReceiptQuery().executeWithSigner(signer);

        if (receipt.status !== Status.Success) {
            throw new ReceiptStatusError({
                transactionReceipt: receipt,
                status: receipt.status,
                transactionId: this.transactionId,
            });
        }

        return receipt;
    }

    /**
     * @param {Signer} signer
     * @returns {Promise<TransactionRecord>}
     */
    async getRecordWithSigner(signer) {
        await this.getReceiptWithSigner(signer);

        return this.getRecordQuery().executeWithSigner(signer);
    }

    /**
     * @returns {TransactionReceiptQuery}
     */
    getReceiptQuery() {
        return new TransactionReceiptQuery()
            .setTransactionId(this.transactionId)
            .setNodeAccountIds([this.nodeId]);
    }

    /**
     * @returns {TransactionRecordQuery}
     */
    getRecordQuery() {
        return new TransactionRecordQuery()
            .setTransactionId(this.transactionId)
            .setNodeAccountIds([this.nodeId]);
    }

    /**
     * @returns {TransactionResponseJSON}
     */
    toJSON() {
        return {
            nodeId: this.nodeId.toString(),
            transactionHash: hex.encode(this.transactionHash),
            transactionId: this.transactionId.toString(),
        };
    }

    /**
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
// Filename: src/util.js
// SPDX-License-Identifier: Apache-2.0

import BigNumber from "bignumber.js";
import Long from "long";

/**
 * @typedef {import("./Hbar.js").default} Hbar
 */

/**
 * Utility Error Messages
 */
export const REQUIRE_NON_NULL_ERROR = "This value cannot be null | undefined.";
export const REQUIRE_STRING_ERROR = "This value must be a string.";
export const REQUIRE_UINT8ARRAY_ERROR = "This value must be a Uint8Array.";
export const REQUIRE_STRING_OR_UINT8ARRAY_ERROR =
    "This value must be a string or Uint8Array.";
export const REQUIRE_NUMBER_ERROR = "This value must be a Number.";
export const REQUIRE_BIGNUMBER_ERROR = "This value must be a BigNumber.";
export const REQUIRE_ARRAY_ERROR = "The provided variable must be an Array.";
export const REQUIRE_LONG_ERROR = "This value must be a Long.";

export const REQUIRE_TYPE_ERROR =
    "The provided variables are not matching types.";

export const FUNCTION_CONVERT_TO_BIGNUMBER_ERROR =
    "This value must be a String, Number, or BigNumber to be converted.";
export const FUNCTION_CONVERT_TO_NUMBER_ERROR =
    "This value must be a String, Number, or BigNumber to be converted.";
export const FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR =
    "Unable to parse given variable. Returns NaN.";

//Soft Checks

/**
 * Takes any param and returns false if null or undefined.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isNonNull(variable) {
    return variable != null;
}

/**
 * Takes any param and returns true if param variable and type are the same.
 *
 * @param {any | null | undefined} variable
 * @param {any | null | undefined} type
 * @returns {boolean}
 */
export function isType(variable, type) {
    return typeof variable == typeof type;
}

/**
 * Takes any param and returns true if param is not null and of type Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isUint8Array(variable) {
    return isNonNull(variable) && variable instanceof Uint8Array;
}

/**
 * Takes any param and returns true if param is not null and of type Number.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isNumber(variable) {
    return (
        isNonNull(variable) &&
        (typeof variable == "number" || variable instanceof Number)
    );
}

/**
 * Takes any param and returns true if param is not null and of type BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isBigNumber(variable) {
    return isNonNull(variable) && variable instanceof BigNumber;
}

/**
 * Takes any param and returns true if param is not null and of type BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isLong(variable) {
    return isNonNull(variable) && variable instanceof Long;
}

/**
 * Takes any param and returns true if param is not null and of type string.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isString(variable) {
    return isNonNull(variable) && typeof variable == "string";
}

/**
 * Takes any param and returns true if param is not null and type string or Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {boolean}
 */
export function isStringOrUint8Array(variable) {
    return (
        isNonNull(variable) && (isString(variable) || isUint8Array(variable))
    );
}

/**
 * Takes an address as `Uint8Array` and returns whether or not this is a long-zero address
 *
 * @param {Uint8Array} address
 * @returns {boolean}
 */
export function isLongZeroAddress(address) {
    for (let i = 0; i < 12; i++) {
        if (address[i] != 0) {
            return false;
        }
    }
    return true;
}

/**
 * Takes any param and returns false if null or undefined.
 *
 * @template {Long | Hbar} T
 * @param {T} variable
 * @returns {T}
 */
export function requireNotNegative(variable) {
    if (variable.isNegative()) {
        throw new Error("negative value not allowed");
    }

    return variable;
}

/**
 * Takes any param and throws custom error if null or undefined.
 *
 * @param {any} variable
 * @returns {object}
 */
export function requireNonNull(variable) {
    if (!isNonNull(variable)) {
        throw new Error(REQUIRE_NON_NULL_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return variable;
    }
}

/**
 * Takes any param and throws custom error if params are not same type.
 *
 * @param {any | null | undefined} variable
 * @param {any | null | undefined} type
 * @returns {object}
 */
export function requireType(variable, type) {
    if (!isType(variable, type)) {
        throw new Error(REQUIRE_TYPE_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return variable;
    }
}

/**
 * Takes any param and throws custom error if non BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {BigNumber}
 */
export function requireBigNumber(variable) {
    if (!isBigNumber(requireNonNull(variable))) {
        throw new Error(REQUIRE_BIGNUMBER_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {BigNumber} */ (variable);
    }
}

/**
 * Takes any param and throws custom error if non BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {Long}
 */
export function requireLong(variable) {
    if (!isLong(requireNonNull(variable))) {
        throw new Error(REQUIRE_LONG_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {Long} */ (variable);
    }
}

/**
 * Takes any param and throws custom error if non string.
 *
 * @param {any | null | undefined} variable
 * @returns {string}
 */
export function requireString(variable) {
    if (!isString(requireNonNull(variable))) {
        throw new Error(REQUIRE_STRING_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {string} */ (variable);
    }
}

/**
 * Takes any param and throws custom error if non Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {Uint8Array}
 */
export function requireUint8Array(variable) {
    if (!isUint8Array(requireNonNull(variable))) {
        throw new Error(REQUIRE_UINT8ARRAY_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {Uint8Array} */ (variable);
    }
}

/**
 * Takes any param and throws custom error if non Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {number}
 */
export function requireNumber(variable) {
    if (!isNumber(requireNonNull(variable))) {
        throw new Error(REQUIRE_NUMBER_ERROR);
    } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {number} */ (variable);
    }
}

/**
 * Takes any param and throws custom error if null or undefined and not a string or Uint8Array.
 *
 * @param {any | null | undefined} variable
 * @returns {string | Uint8Array}
 */
export function requireStringOrUint8Array(variable) {
    if (isStringOrUint8Array(requireNonNull(variable))) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return /** @type {string | Uint8Array} */ (variable);
    } else {
        throw new Error(REQUIRE_STRING_OR_UINT8ARRAY_ERROR);
    }
}

//Conversions

/**
 * Converts number or string to BigNumber.
 *
 * @param {any | null | undefined} variable
 * @returns {BigNumber}
 */
export function convertToBigNumber(variable) {
    requireNonNull(variable);
    if (
        isBigNumber(variable) ||
        isString(variable) ||
        isNumber(variable) ||
        isLong(variable)
    ) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new BigNumber(variable);
    }
    throw new Error(FUNCTION_CONVERT_TO_BIGNUMBER_ERROR);
}

/**
 * Converts Array of Numbers or Strings to Array of BigNumbers.
 *
 * @param {any | null | undefined} variable
 * @returns {Array<BigNumber>}
 */
export function convertToBigNumberArray(variable) {
    if (variable instanceof Array) {
        return /** @type {Array<BigNumber>} */ (
            variable.map(convertToBigNumber)
        );
    } else {
        throw new Error(REQUIRE_ARRAY_ERROR);
    }
}

/**
 * @param {*} variable
 * @returns {number}
 */
export function convertToNumber(variable) {
    requireNonNull(variable);
    if (
        isBigNumber(variable) ||
        isString(variable) ||
        isNumber(variable) ||
        isLong(variable)
    ) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const num = parseInt(variable);
        if (isNaN(num)) {
            throw new Error(FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR);
        } else {
            return num;
        }
    } else {
        throw new Error(FUNCTION_CONVERT_TO_NUMBER_ERROR);
    }
}

/**
 * Creates a DataView on top of an Uint8Array that could be or not be pooled, ensuring that we don't get out of bounds.
 *
 * @param {Uint8Array | Int8Array} arr
 * @param {number | undefined} offset
 * @param {number | undefined} length
 * @returns {DataView}
 */
export function safeView(arr, offset = 0, length = arr.byteLength) {
    if (!(Number.isInteger(offset) && offset >= 0))
        throw new Error("Invalid offset!");
    if (!(Number.isInteger(length) && length >= 0))
        throw new Error("Invalid length!");
    return new DataView(
        arr.buffer,
        arr.byteOffset + offset,
        Math.min(length, arr.byteLength - offset),
    );
}

/**
 * @param {any} a
 * @param {any} b
 * @param {Set<string>=} ignore
 * @returns {boolean}
 */
export function compare(a, b, ignore = new Set()) {
    if (typeof a === "object" && typeof b === "object") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const aKeys = Object.keys(a);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const bKeys = Object.keys(b);

        if (aKeys.length !== bKeys.length) {
            return false;
        }

        for (let i = 0; i < aKeys.length; i++) {
            if (aKeys[i] !== bKeys[i]) {
                return false;
            }

            if (ignore.has(aKeys[i])) {
                continue;
            }

            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (!compare(a[aKeys[i]], b[bKeys[i]], ignore)) {
                return false;
            }
        }

        return true;
    } else if (typeof a === "number" && typeof b === "number") {
        return a === b;
    } else if (typeof a === "string" && typeof b === "string") {
        return a === b;
    } else if (typeof a === "boolean" && typeof b === "boolean") {
        return a === b;
    } else {
        return false;
    }
}

/**
 * https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 *
 * @template T
 * @param {Array<T>} array
 */
export function shuffle(array) {
    var currentIndex = array.length,
        temporaryValue,
        randomIndex;

    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
}

/**
 * @param {Uint8Array} array1
 * @param {Uint8Array} array2
 * @returns {boolean}
 */
export function arrayEqual(array1, array2) {
    if (array1 === array2) {
        return true;
    }

    if (array1.byteLength !== array2.byteLength) {
        return false;
    }

    const view1 = new DataView(
        array1.buffer,
        array1.byteOffset,
        array1.byteLength,
    );
    const view2 = new DataView(
        array2.buffer,
        array2.byteOffset,
        array2.byteLength,
    );

    let i = array1.byteLength;

    while (i--) {
        if (view1.getUint8(i) !== view2.getUint8(i)) {
            return false;
        }
    }

    return true;
}

/**
 * @description Function that delays an execution for a given time (in milliseconds)
 * @param {number} ms
 * @returns {Promise<void>}
 */
export function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
// Filename: test/browser.test.js
import { test, expect } from "@playwright/test";

test("can execute @hashgraph/sdk within browser", async function ({ page }) {
    page.on("pageerror", async (message) => {
        throw new Error(message);
    });

    await page.goto("http://localhost:9001/");

    await new Promise((resolve) => setTimeout(resolve, 2000));
    const tests = await page.evaluate(() => {
        return Array.from(document.querySelectorAll(".test"))
            .map((test) => {
                const error = test.querySelector(".error");
                return {
                    name: [].reduce.call(test.querySelector("h2").childNodes, function(a, b) { return a + (b.nodeType === 3 ? b.textContent : ''); }, ''),
                    error: error != null ? error.innerText.trim() : null,
                };
            });
    });

    expect(tests.length).toBeGreaterThan(0);
    for (const t of tests) {
        expect(t.error).toBeNull();
    }
});
// Filename: test/integration/AccountBalanceIntegrationTest.js
import { AccountBalanceQuery, Status } from "../../src/exports.js";
import IntegrationTestEnv, {
    Client,
    skipTestDueToNodeJsVersion,
} from "./client/NodeIntegrationTestEnv.js";
import { createFungibleToken } from "./utils/Fixtures.js";

describe("AccountBalanceQuery", function () {
    let clientPreviewNet;
    let clientTestnet;
    let env;

    before(async function () {
        clientPreviewNet = Client.forPreviewnet().setTransportSecurity(true);
        clientTestnet = Client.forTestnet().setTransportSecurity(true);
        env = await IntegrationTestEnv.new({ throwaway: true });
    });

    it("can query balance of node 0.0.3", async function () {
        const balance = await new AccountBalanceQuery()
            .setAccountId("0.0.3")
            .execute(clientTestnet);
        expect(balance.hbars.toTinybars().compare(0)).to.be.equal(1);
    });

    it("can connect to previewnet with TLS", async function () {
        if (skipTestDueToNodeJsVersion(16)) {
            return;
        }

        for (const [address, nodeAccountId] of Object.entries(
            clientPreviewNet.network,
        )) {
            expect(address.endsWith(":50212")).to.be.true;

            await new AccountBalanceQuery()
                .setAccountId(nodeAccountId)
                .setMaxAttempts(10)
                .execute(clientPreviewNet);
        }
    });

    it("can connect to testnet with TLS", async function () {
        if (skipTestDueToNodeJsVersion(16)) {
            return;
        }

        for (const [address, nodeAccountId] of Object.entries(
            clientTestnet.network,
        )) {
            expect(address.endsWith(":50212")).to.be.true;

            await new AccountBalanceQuery()
                .setAccountId(nodeAccountId)
                .setMaxAttempts(10)
                .execute(clientTestnet);
        }
    });

    it("an account that does not exist should return an error", async function () {
        let err = false;

        try {
            await new AccountBalanceQuery()
                .setAccountId("1.0.3")
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId.toString());
        }

        if (!err) {
            throw new Error("query did not error");
        }
    });

    it("should reflect token with no keys", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction
                .setInitialSupply(0)
                .setAdminKey(null)
                .setFreezeKey(null)
                .setPauseKey(null)
                .setWipeKey(null)
                .setFeeScheduleKey(null)
                .setMetadataKey(null)
                .setSupplyKey(null);
        });

        const balances = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(balances.tokens.get(tokenId.toString()).toInt()).to.be.equal(0);
    });

    after(async function () {
        clientPreviewNet.close();
        clientTestnet.close();
        await env.close();
    });
});
// Filename: test/integration/AccountCreateIntegrationTest.js
import {
    AccountCreateTransaction,
    TransferTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TransactionId,
    KeyList,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { deleteAccount } from "./utils/Fixtures.js";

describe("AccountCreate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(account.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toNumber()).to.be.equal(
            new Hbar(2).toTinybars().toNumber(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toNumber()).to.be.equal(0);

        await deleteAccount(env.client, key, (transaction) => {
            transaction
                .setAccountId(account)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(account));
        });
    });

    it("should be able to create an account with an ECDSA private key", async function () {
        const key = PrivateKey.generateECDSA();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const info = await new AccountInfoQuery()
            .setNodeAccountIds([response.nodeId])
            .setAccountId(account)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(account.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toNumber()).to.be.equal(
            new Hbar(2).toTinybars().toNumber(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toNumber()).to.be.equal(0);

        const transaction = new TransferTransaction()
            .setNodeAccountIds([response.nodeId])
            .setTransactionId(TransactionId.generate(account))
            .addHbarTransfer(account, Hbar.fromTinybars(10).negated())
            .addHbarTransfer(env.operatorId, Hbar.fromTinybars(10))
            .freezeWith(env.client);

        await transaction.sign(key);
        await transaction.execute(env.client);
    });

    it("should be executable with only key set", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(account.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toNumber()).to.be.equal(0);
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toNumber()).to.be.equal(0);

        await deleteAccount(env.client, key, (transaction) => {
            transaction.setAccountId(account).setTransferAccountId(operatorId);
        });
    });

    it("should error when key is not set", async function () {
        let status;

        try {
            const response = await new AccountCreateTransaction()
                .setInitialBalance(new Hbar(2))
                .execute(env.client);

            await response.getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.KeyRequired);
    });

    it("should be able to sign transaction and verify transaction signtatures", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const info = await new AccountInfoQuery()
            .setNodeAccountIds([response.nodeId])
            .setAccountId(account)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(account.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toNumber()).to.be.equal(0);
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toNumber()).to.be.equal(0);

        await deleteAccount(env.client, key, (transaction) => {
            transaction
                .setNodeAccountIds([response.nodeId])
                .setAccountId(account)
                .setTransferAccountId(operatorId)
                .freezeWith(env.client);

            key.signTransaction(transaction);

            expect(key.publicKey.verifyTransaction(transaction)).to.be.true;
            expect(operatorKey.verifyTransaction(transaction)).to.be.false;
        });
    });

    it("should create account with a single key passed to `KeyList`", async function () {
        const publicKey = PrivateKey.generateED25519().publicKey;
        const thresholdKey = new KeyList(publicKey, 1);

        let transaction = new AccountCreateTransaction()
            .setKeyWithoutAlias(thresholdKey)
            .setInitialBalance(Hbar.fromTinybars(1))
            .freezeWith(env.client);

        const txAccountCreate = await transaction.execute(env.client);
        const txAccountCreateReceipt = await txAccountCreate.getReceipt(
            env.client,
        );
        const accountId = txAccountCreateReceipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setNodeAccountIds([txAccountCreate.nodeId])
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(accountId.toString());
        expect(info.key.toArray()[0].toString()).to.be.equal(
            publicKey.toString(),
        );
    });

    it("should create account with no alias", async function () {
        // Tests the third row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateECDSA();
        const accountKey = PrivateKey.generateECDSA();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .execute(env.client);

        let receipt = await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(accountKey)
                .freezeWith(env.client)
                .execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(
            info.contractAccountId
                .toString()
                .startsWith("00000000000000000000"),
        ).to.be.true;
    });

    it("should create account with alias from admin key", async function () {
        // Tests the third row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateECDSA();
        const evmAddress = adminKey.publicKey.toEvmAddress();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .execute(env.client);

        let receipt = await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(adminKey)
                .setAlias(evmAddress)
                .freezeWith(env.client)
                .execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should create account with alias derived from ECDSA private admin key", async function () {
        const adminKey = PrivateKey.generateECDSA();
        const evmAddress = adminKey.publicKey.toEvmAddress();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        // create an account with alias derived from admin key
        let receipt = await (
            await new AccountCreateTransaction()
                .setECDSAKeyWithAlias(adminKey)
                .freezeWith(env.client)
                .execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should error when trying to create an account with alias derived from admin key when provided admin key is non-ECDSA private", async function () {
        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        let err = false;

        try {
            await (
                await new AccountCreateTransaction()
                    .setECDSAKeyWithAlias(adminKey)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(
                    "'key' must be an ECDSA private key when 'aliasKey' is not provided.",
                );
        }
        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should create account with alias from admin key with receiver sig required", async function () {
        // Tests the fourth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateECDSA();
        const evmAddress = adminKey.publicKey.toEvmAddress();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        let receipt = await (
            await (
                await new AccountCreateTransaction()
                    .setReceiverSignatureRequired(true)
                    .setKeyWithoutAlias(adminKey)
                    .setAlias(evmAddress)
                    .freezeWith(env.client)
                    .sign(adminKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should create account with alias derived from ECDSA private admin key with receiver sig required", async function () {
        // Tests the fourth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateECDSA();
        const evmAddress = adminKey.publicKey.toEvmAddress();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        // create an account with alias derived from admin key
        let receipt = await (
            await (
                await new AccountCreateTransaction()
                    .setReceiverSignatureRequired(true)
                    .setECDSAKeyWithAlias(adminKey)
                    .freezeWith(env.client)
                    .sign(adminKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should error when trying to create account with alias from admin key with receiver sig required without signature", async function () {
        const adminKey = PrivateKey.generateECDSA();
        const evmAddress = adminKey.publicKey.toEvmAddress();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        let err = false;
        try {
            await (
                await new AccountCreateTransaction()
                    .setReceiverSignatureRequired(true)
                    .setKeyWithoutAlias(adminKey)
                    .setAlias(evmAddress)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should error when trying to create account with alias derived from ECDSA private admin key with receiver sig required without signature", async function () {
        const adminKey = PrivateKey.generateECDSA();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        let err = false;

        try {
            // create an account with alias derived from admin key
            await (
                await new AccountCreateTransaction()
                    .setReceiverSignatureRequired(true)
                    .setECDSAKeyWithAlias(adminKey)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should create account with alias different from admin key", async function () {
        // Tests the fifth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const key = PrivateKey.generateECDSA();
        const evmAddress = key.publicKey.toEvmAddress();

        let receipt = await (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(adminKey)
                    .setAlias(evmAddress)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should create account with admin key and alias derived from different ECDSA private alias key", async function () {
        // Tests the fifth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const aliasKey = PrivateKey.generateECDSA();
        const evmAddress = aliasKey.publicKey.toEvmAddress();

        // create an account with alias derived from ECDSA private alias key
        let receipt = await (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithAlias(adminKey, aliasKey)
                    .freezeWith(env.client)
                    .sign(aliasKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should error when trying to create an account with alias derived from different alias key when provided alias key is non-ECDSA private", async function () {
        const adminKey = PrivateKey.generateED25519();
        const aliasKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        let err = false;

        try {
            await (
                await new AccountCreateTransaction()
                    .setKeyWithAlias(adminKey, aliasKey)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(
                    "'aliasKey' must be an ECDSA private key when provided.",
                );
        }
        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should error when trying to create account with alias different from admin key without signature", async function () {
        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const key = PrivateKey.generateECDSA();
        const evmAddress = key.publicKey.toEvmAddress();

        let err = false;
        try {
            await (
                await new AccountCreateTransaction()
                    .setReceiverSignatureRequired(true)
                    .setKeyWithoutAlias(adminKey)
                    .setAlias(evmAddress)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should error when trying to create account with admin key and alias derived from different ECDSA private alias key without signature", async function () {
        const adminKey = PrivateKey.generateED25519();
        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const aliasKey = PrivateKey.generateECDSA();

        let err = false;
        try {
            await (
                await new AccountCreateTransaction()
                    .setReceiverSignatureRequired(true)
                    .setKeyWithAlias(adminKey, aliasKey)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should create account with alias different from admin key with receiver sig required", async function () {
        // Tests the sixth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const key = PrivateKey.generateECDSA();
        const evmAddress = key.publicKey.toEvmAddress();

        let receipt = await (
            await (
                await (
                    await new AccountCreateTransaction()
                        .setReceiverSignatureRequired(true)
                        .setKeyWithoutAlias(adminKey)
                        .setAlias(evmAddress)
                        .freezeWith(env.client)
                        .sign(key)
                ).sign(adminKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should create account with admin key and alias derived from ECDSA private alias key with receiver sig required", async function () {
        // Tests the sixth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures

        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const aliasKey = PrivateKey.generateECDSA();
        const evmAddress = aliasKey.publicKey.toEvmAddress();

        let receipt = await (
            await (
                await (
                    await new AccountCreateTransaction()
                        .setReceiverSignatureRequired(true)
                        .setKeyWithAlias(adminKey, aliasKey)
                        .freezeWith(env.client)
                        .sign(aliasKey)
                ).sign(adminKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const accountId = receipt.accountId;

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.not.be.null;
        expect(info.contractAccountId.toString()).to.be.equal(
            evmAddress.toString(),
        );
        expect(info.key.toString()).to.be.equal(adminKey.publicKey.toString());
    });

    it("should error when trying to create account with alias different from admin key and receiver sig required without signature", async function () {
        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const key = PrivateKey.generateECDSA();
        const evmAddress = key.publicKey.toEvmAddress();

        let err = false;
        try {
            await (
                await (
                    await new AccountCreateTransaction()
                        .setReceiverSignatureRequired(true)
                        .setKeyWithoutAlias(adminKey)
                        .setAlias(evmAddress)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    it("should error when trying to create account with admin key and alias derived from ECDSA private alias key and receiver sig required without signature", async function () {
        const adminKey = PrivateKey.generateED25519();

        // create an admin account
        await new AccountCreateTransaction()
            .setKeyWithoutAlias(adminKey)
            .freezeWith(env.client)
            .execute(env.client);

        const aliasKey = PrivateKey.generateECDSA();

        let err = false;
        try {
            await (
                await (
                    await new AccountCreateTransaction()
                        .setReceiverSignatureRequired(true)
                        .setKeyWithAlias(adminKey, aliasKey)
                        .freezeWith(env.client)
                        .sign(aliasKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account creation did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/AccountDeleteIntegrationTest.js
import {
    AccountDeleteTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount } from "./utils/Fixtures.js";

describe("AccountDelete", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(accountId.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toInt()).to.be.equal(
            new Hbar(2).toTinybars().toInt(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toInt()).to.be.equal(0);

        await (
            await (
                await new AccountDeleteTransaction()
                    .setAccountId(accountId)
                    .setTransferAccountId(operatorId)
                    .setTransactionId(TransactionId.generate(accountId))
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error with invalid signature", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        let err = false;

        try {
            await (
                await new AccountDeleteTransaction()
                    .setAccountId(accountId)
                    .setTransferAccountId(operatorId)
                    .setTransactionId(TransactionId.generate(accountId))
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        if (!err) {
            throw new Error("account deletion did not error");
        }
    });

    it("should error with no account ID set", async function () {
        let status;

        try {
            await (
                await new AccountDeleteTransaction()
                    .setTransferAccountId(env.operatorId)
                    .freezeWith(env.client)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.AccountIdDoesNotExist);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/AccountIdTest.js
import { AccountId, TokenId } from "../../src/exports.js";
import IntegrationTestEnv, { Client } from "./client/NodeIntegrationTestEnv.js";

describe("AccountId", function () {
    let client;

    before(async function () {
        client = Client.forMainnet();
    });

    it("should generate checksum for account ID", function () {
        const accountId = new AccountId(123);

        expect(accountId.num.toNumber()).to.eql(123);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);

        expect(accountId.toStringWithChecksum(client)).to.be.eql(
            "0.0.123-vfmkw",
        );
    });

    it("should generate checksum for token ID", function () {
        const tokenId = new TokenId(123);

        expect(tokenId.num.toNumber()).to.eql(123);
        expect(tokenId.realm.toNumber()).to.eql(0);
        expect(tokenId.shard.toNumber()).to.eql(0);

        expect(tokenId.toStringWithChecksum(client)).to.be.eql("0.0.123-vfmkw");
    });

    it("should parse previewnet ID with checksum {0.0.123-ghaha}", function () {
        let err = false;

        try {
            AccountId.fromString("0.0.123-ghaha").validateChecksum(
                IntegrationTestEnv.forMainnet(),
            );
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("entity parsing did not err");
        }
    });

    after(async function () {
        client.close();
    });
});
// Filename: test/integration/AccountInfoIntegrationTest.js
import {
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    deleteAccount,
} from "./utils/Fixtures.js";

describe("AccountInfo", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be able to query cost", async function () {
        const operatorId = env.operatorId;

        const cost = await new AccountInfoQuery()
            .setAccountId(operatorId)
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    it("should error on query cost on deleted account with ACCOUNT_DELETED", async function () {
        const newKey = PrivateKey.generate();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(newKey.publicKey)
                .setInitialBalance(new Hbar(10)); // 10 h
        });

        await deleteAccount(env.client, newKey, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(env.operatorId);
        });

        let err;
        try {
            await new AccountInfoQuery()
                .setAccountId(accountId)
                .getCost(env.client);
        } catch (error) {
            err = error.toString().includes(Status.AccountDeleted.toString());
        }

        if (!err) {
            throw new Error("query cost did not error");
        }
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(accountId.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toInt()).to.be.equal(
            new Hbar(2).toTinybars().toInt(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toInt()).to.be.equal(0);

        await deleteAccount(env.client, key, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("should be able to get 300 accounts", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();
        let response = [];
        let info = [];

        for (let i = 0; i < 300; i++) {
            response[i] = await createAccount(env.client, (transaction) => {
                transaction
                    .setKeyWithoutAlias(key.publicKey)
                    .setInitialBalance(new Hbar(2));
            });
        }

        for (let i = 0; i < 300; i++) {
            info[i] = await new AccountInfoQuery()
                .setAccountId(response[i].accountId)
                .execute(env.client);
        }

        for (let i = 0; i < 300; i++) {
            await deleteAccount(env.client, key, (transaction) => {
                transaction
                    .setAccountId(response[i].accountId)
                    .setTransferAccountId(operatorId)
                    .setTransactionId(
                        TransactionId.generate(response[i].accountId),
                    );
            });
        }
    });

    it("should reflect token with no keys", async function () {
        const operatorId = env.operatorId;

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction
                .setSupplyKey(null)
                .setKycKey(null)
                .setWipeKey(null)
                .setFreezeKey(null)
                .setAdminKey(null)
                .setPauseKey(null)
                .setMetadataKey(null)
                .setSupplyKey(null)
                .setFeeScheduleKey(null)
                .setInitialSupply(0);
        });

        const info = await new AccountInfoQuery()
            .setAccountId(operatorId)
            .execute(env.client);

        const relationship = info.tokenRelationships.get(tokenId);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(tokenId.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.null;
        expect(relationship.isFrozen).to.be.null;
    });

    it("should be error with no account ID", async function () {
        let err = false;

        try {
            await new AccountInfoQuery().execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId.toString());
        }

        if (!err) {
            throw new Error("query did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/AccountRecordsIntegrationTest.js
import {
    AccountRecordsQuery,
    Hbar,
    PrivateKey,
    TransactionId,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, deleteAccount } from "./utils/Fixtures.js";

describe("AccountRecords", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        await (
            await new TransferTransaction()
                .addHbarTransfer(accountId, new Hbar(1))
                .addHbarTransfer(operatorId, new Hbar(1).negated())
                .execute(env.client)
        ).getReceipt(env.client);

        const records = await new AccountRecordsQuery()
            .setAccountId(operatorId)
            .setMaxQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(records.length).to.be.gt(0);

        await deleteAccount(env.client, key, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/AccountUpdateIntegrationTest.js
import {
    AccountInfoQuery,
    AccountUpdateTransaction,
    Hbar,
    PrivateKey,
    Status,
    Timestamp,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import Long from "long";
import { createAccount, deleteAccount } from "./utils/Fixtures.js";

describe("AccountUpdate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;

        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key1.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        let info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(accountId.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key1.publicKey.toString());
        expect(info.balance.toTinybars().toInt()).to.be.equal(
            new Hbar(2).toTinybars().toInt(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toInt()).to.be.equal(0);

        const response = await (
            await (
                await new AccountUpdateTransaction()
                    .setAccountId(accountId)
                    .setKey(key2.publicKey)
                    // .setAutoRenewPeriod(777600000)
                    // .setExpirationTime(new Date(Date.now() + 7776000000))
                    .freezeWith(env.client)
                    .sign(key1)
            ).sign(key2)
        ).execute(env.client);

        await response.getReceipt(env.client);

        info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(accountId.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key2.publicKey.toString());
        expect(info.balance.toTinybars().toInt()).to.be.equal(
            new Hbar(2).toTinybars().toInt(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toInt()).to.be.equal(0);

        await deleteAccount(env.client, key2, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    it("should error with invalid auto renew period", async function () {
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key1.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        let err = false;

        try {
            await (
                await (
                    await (
                        await new AccountUpdateTransaction()
                            .setAccountId(accountId)
                            .setKey(key2.publicKey)
                            .setAutoRenewPeriod(777600000)
                            .freezeWith(env.client)
                            .sign(key1)
                    ).sign(key2)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.AutorenewDurationNotInRange.toString());
        }

        await deleteAccount(env.client, key1, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(env.client.operatorAccountId)
                .setTransactionId(TransactionId.generate(accountId));
        });

        if (!err) {
            throw new Error("account update did not error");
        }
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("should error with insufficent tx fee when a large expiration time is set", async function () {
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, {
            key: key1.publicKey,
            initialBalance: new Hbar(2),
        });

        expect(accountId).to.not.be.null;

        let err = false;

        try {
            await (
                await (
                    await (
                        await new AccountUpdateTransaction()
                            .setAccountId(accountId)
                            .setKey(key2.publicKey)
                            .setExpirationTime(new Timestamp(Long.MAX, 0))
                            .freezeWith(env.client)
                            .sign(key1)
                    ).sign(key2)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.InsufficientTxFee.toString());
        }

        if (!err) {
            throw new Error("account update did not error");
        }
    });

    it("should error when account ID is not set", async function () {
        let status;

        try {
            await (
                await new AccountUpdateTransaction()
                    .setKey(env.client.operatorPublicKey)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.AccountIdDoesNotExist);
    });

    it("should execute with only account ID", async function () {
        const key1 = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key1.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        await (
            await (
                await new AccountUpdateTransaction()
                    .setAccountId(accountId)
                    .freezeWith(env.client)
                    .sign(key1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await deleteAccount(env.client, key1, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(env.client.operatorAccountId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    it("should error with invalid signature", async function () {
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key1.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        let err = false;

        try {
            await (
                await (
                    await new AccountUpdateTransaction()
                        .setAccountId(accountId)
                        .setKey(key2.publicKey)
                        .freezeWith(env.client)
                        .sign(key1)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature.toString());
        }

        await deleteAccount(env.client, key1, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(env.client.operatorAccountId)
                .setTransactionId(TransactionId.generate(accountId));
        });

        if (!err) {
            throw new Error("account update did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/AddressBookQueryTest.js
import { AddressBookQuery } from "../../src/exports.js";
import { Client } from "./client/NodeIntegrationTestEnv.js";

describe("AddressBookQuery", function () {
    it("should be query the addressbook on testnet", async function () {
        const client = Client.forTestnet();

        const addressBook = await new AddressBookQuery()
            .setFileId("0.0.102")
            .execute(client);

        expect(addressBook.nodeAddresses.length).to.be.above(0);
        client.close();
    });

    it("should be query the addressbook on mainnet", async function () {
        const client = Client.forMainnet();

        const addressBook = await new AddressBookQuery()
            .setFileId("0.0.102")
            .execute(client);

        expect(addressBook.nodeAddresses.length).to.be.above(0);
        client.close();
    });
});
// Filename: test/integration/ClientConstantsIntegrationTest.js
/* eslint-disable mocha/no-setup-in-describe */
import {
    MAINNET,
    WEB_TESTNET,
    WEB_PREVIEWNET,
    NATIVE_PREVIEWNET,
    NATIVE_TESTNET,
} from "../../src/constants/ClientConstants.js";
import {
    AccountBalance,
    AccountBalanceQuery,
    Hbar,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("ClientConstantsIntegrationTest", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    describe("MAINNET node proxies", function () {
        const proxies = Object.keys(MAINNET);
        proxies.forEach((proxy) => {
            it(`should fetch ${MAINNET[proxy]} account balnace`, async function () {
                const accountBalance = await new AccountBalanceQuery()
                    .setNodeAccountIds([MAINNET[proxy]])
                    .setAccountId(MAINNET[proxy])
                    .execute(env.client);

                expect(accountBalance instanceof AccountBalance).to.be.true;
                expect(accountBalance.hbars instanceof Hbar).to.be.true;
            });
        });
    });

    describe("WEB TESTNET node proxies", function () {
        const proxies = Object.keys(WEB_TESTNET);
        proxies.forEach((proxy) => {
            it(`should fetch ${WEB_TESTNET[proxy]} account balnace`, async function () {
                const accountBalance = await new AccountBalanceQuery()
                    .setNodeAccountIds([WEB_TESTNET[proxy]])
                    .setAccountId(WEB_TESTNET[proxy])
                    .execute(env.client);

                expect(accountBalance instanceof AccountBalance).to.be.true;
                expect(accountBalance.hbars instanceof Hbar).to.be.true;
            });
        });
    });

    describe("WEB PREVIEWNET node proxies", function () {
        const proxies = Object.keys(WEB_PREVIEWNET);
        proxies.forEach((proxy) => {
            it(`should fetch ${WEB_PREVIEWNET[proxy]} account balnace`, async function () {
                const accountBalance = await new AccountBalanceQuery()
                    .setNodeAccountIds([WEB_PREVIEWNET[proxy]])
                    .setAccountId(WEB_PREVIEWNET[proxy])
                    .execute(env.client);

                expect(accountBalance instanceof AccountBalance).to.be.true;
                expect(accountBalance.hbars instanceof Hbar).to.be.true;
            });
        });
    });

    describe("NATIVE PREVIEWNET node proxies", function () {
        const proxies = Object.keys(NATIVE_PREVIEWNET);
        proxies.forEach((proxy) => {
            it(`should fetch ${NATIVE_PREVIEWNET[proxy]} account balnace`, async function () {
                const accountBalance = await new AccountBalanceQuery()
                    .setNodeAccountIds([NATIVE_PREVIEWNET[proxy]])
                    .setAccountId(NATIVE_PREVIEWNET[proxy])
                    .execute(env.client);

                expect(accountBalance instanceof AccountBalance).to.be.true;
                expect(accountBalance.hbars instanceof Hbar).to.be.true;
            });
        });
    });

    describe("NATIVE TESTNET node proxies", function () {
        const proxies = Object.keys(NATIVE_TESTNET);
        proxies.forEach((proxy) => {
            it(`should fetch ${NATIVE_TESTNET[proxy]} account balnace`, async function () {
                const accountBalance = await new AccountBalanceQuery()
                    .setNodeAccountIds([NATIVE_TESTNET[proxy]])
                    .setAccountId(NATIVE_TESTNET[proxy])
                    .execute(env.client);

                expect(accountBalance instanceof AccountBalance).to.be.true;
                expect(accountBalance.hbars instanceof Hbar).to.be.true;
            });
        });
    });
});
// Filename: test/integration/ClientIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountId,
    AccountInfoQuery,
    Hbar,
    LedgerId,
    PrivateKey,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv, { Client } from "./client/NodeIntegrationTestEnv.js";
import { createAccount, deleteAccount } from "./utils/Fixtures.js";

describe("ClientIntegration", function () {
    let env;
    let clientTestnet;
    let clientPreviewNet;

    before(async function () {
        env = await IntegrationTestEnv.new();
        clientTestnet = Client.forTestnet();
        clientPreviewNet = Client.forPreviewnet();
    });

    it("should error when invalid network on entity ID", async function () {
        if (env.client.ledgerId == null) {
            return;
        }

        let err = false;

        let network;
        switch (env.client.ledgerId.toString()) {
            case "mainnet":
                network = "testnet";
                break;
            case "testnet":
                network = "previewnet";
                break;
            case "previewnet":
                network = "mainnet";
                break;
            default:
                throw new Error(
                    `(BUG) operator network is unrecognized value: ${env.client.ledgerId.toString()}`,
                );
        }

        const accountId = AccountId.withNetwork(3, network);

        try {
            await new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(env.client);
        } catch (error) {
            err = true;
        }

        if (!err) {
            throw new Error("query did not error");
        }
    });

    it("can execute with sign on demand", async function () {
        env.client.setSignOnDemand(true);

        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction
                .setKeyWithoutAlias(key.publicKey)
                .setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(info.accountId.toString()).to.be.equal(accountId.toString());
        expect(info.isDeleted).to.be.false;
        expect(info.key.toString()).to.be.equal(key.publicKey.toString());
        expect(info.balance.toTinybars().toNumber()).to.be.equal(
            new Hbar(2).toTinybars().toNumber(),
        );
        expect(info.autoRenewPeriod.seconds.toNumber()).to.be.equal(7776000);
        expect(info.proxyAccountId).to.be.null;
        expect(info.proxyReceived.toTinybars().toNumber()).to.be.equal(0);

        await deleteAccount(env.client, key, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    it("can get bytes without sign on demand", async function () {
        env.client.setSignOnDemand(false);

        const key = PrivateKey.generateED25519();

        const bytes = (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(key.publicKey)
                .setInitialBalance(new Hbar(2))
                .freezeWith(env.client)
                .sign(key)
        ).toBytes();
        expect(bytes.length).to.be.gt(0);
    });

    it("can pingAll", async function () {
        await env.client.pingAll();
    });

    it("should fail on ping", async function () {
        let error = null;
        try {
            await env.client.ping(""); // Non exist Node ID
        } catch (err) {
            error = err;
        }
        expect(error).to.be.an("Error");
    });

    // TODO(2023-11-01 NK) - test is consistently failing and should be enabled once fixed.
    // eslint-disable-next-line mocha/no-skipped-tests
    xit("can set network name on custom network", async function () {
        expect(clientTestnet.ledgerId).to.be.equal(LedgerId.TESTNET);
        expect(clientPreviewNet.ledgerId).to.be.equal(LedgerId.PREVIEWNET);

        await clientTestnet.setNetwork(clientPreviewNet.network);

        expect(clientTestnet.ledgerId).to.be.null;

        clientTestnet.setLedgerId("previewnet");

        expect(clientTestnet.ledgerId).to.be.equal(LedgerId.PREVIEWNET);
    });

    it("can use same proxies of one node", async function () {
        let nodes = {
            "0.testnet.hedera.com:50211": new AccountId(3),
            "34.94.106.61:50211": new AccountId(3),
            "50.18.132.211:50211": new AccountId(3),
            // IP address currently not responding
            // "138.91.142.219:50211": new AccountId(3)
        };

        const clientForNetwork = Client.forNetwork(nodes);
        await clientForNetwork.pingAll();
    });

    it("should return a boolean for client transport security", function () {
        expect(clientTestnet.isTransportSecurity()).to.be.an("boolean");
    });

    it("should return the following error message `defaultMaxQueryPayment must be non-negative` when the user tries to set a negative value to the defaultMaxQueryPayment field", async function () {
        try {
            env.client.setDefaultMaxQueryPayment(new Hbar(1).negated());
        } catch (error) {
            expect(error.message).to.be.equal(
                "defaultMaxQueryPayment must be non-negative",
            );
        }
    });

    it("should set defaultMaxQueryPayment field", async function () {
        const value = new Hbar(100);
        env.client.setDefaultMaxQueryPayment(value);
        expect(env.client.defaultMaxQueryPayment).to.be.equal(value);
    });

    after(async function () {
        await env.close();
        clientTestnet.close();
        clientPreviewNet.close();
    });
});
// Filename: test/integration/ContractBytecodeIntegrationTest.js
import {
    ContractByteCodeQuery,
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
    TransactionReceiptQuery,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

let smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractBytecode", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await new TransactionReceiptQuery()
            .setTransactionId(response.transactionId)
            .execute(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        let file = receipt.fileId;

        receipt = await (
            await new ContractCreateTransaction()
                .setAdminKey(operatorKey)
                .setGas(200000)
                .setConstructorParameters(
                    new ContractFunctionParameters().addString(
                        "Hello from Hedera.",
                    ),
                )
                .setBytecodeFileId(file)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        const bytecode = await new ContractByteCodeQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(2))
            .execute(env.client);

        expect(bytecode.length).to.be.equal(798);

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when contract ID is not set", async function () {
        let err = false;

        try {
            await new ContractByteCodeQuery().execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidContractId);
        }

        if (!err) {
            throw new Error("query did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractCallIntegrationTest.js
import {
    ContractCallQuery,
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

const smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractCallIntegration", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        receipt = await (
            await new ContractCreateTransaction()
                .setAdminKey(operatorKey)
                .setGas(200000)
                .setConstructorParameters(
                    new ContractFunctionParameters().addString(
                        "Hello from Hedera.",
                    ),
                )
                .setBytecodeFileId(file)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        const callQuery = new ContractCallQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .setGas(75000)
            .setFunction("getMessage");

        const cost = await callQuery.getCost(env.client);

        let result = await callQuery
            .setMaxQueryPayment(cost)
            .execute(env.client);

        expect(result.getString(0)).to.be.equal("Hello from Hedera.");

        await (
            await new ContractExecuteTransaction()
                .setContractId(contract)
                .setGas(75000)
                .setFunction(
                    "setMessage",
                    new ContractFunctionParameters().addString("new message"),
                )
                .execute(env.client)
        ).getReceipt(env.client);

        result = await new ContractCallQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(5))
            .setGas(75000)
            .setFunction("getMessage")
            .execute(env.client);

        expect(result.getString(0)).to.be.equal("new message");

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when function to call is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        receipt = await (
            await new ContractCreateTransaction()
                .setAdminKey(operatorKey)
                .setGas(200000)
                .setConstructorParameters(
                    new ContractFunctionParameters().addString(
                        "Hello from Hedera.",
                    ),
                )
                .setBytecodeFileId(file)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await new ContractCallQuery()
                .setContractId(contract)
                .setQueryPayment(new Hbar(1))
                .setGas(75000)
                .setMaxQueryPayment(new Hbar(5))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.ContractRevertExecuted);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("query did not error");
        }
    });

    it("should error when gas is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        receipt = await (
            await new ContractCreateTransaction()
                .setAdminKey(operatorKey)
                .setGas(200000)
                .setConstructorParameters(
                    new ContractFunctionParameters().addString(
                        "Hello from Hedera.",
                    ),
                )
                .setBytecodeFileId(file)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await new ContractCallQuery()
                .setContractId(contract)
                .setQueryPayment(new Hbar(1))
                .setMaxQueryPayment(new Hbar(5))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InsufficientGas);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("query did not error");
        }
    });

    it("should error when contract ID is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        receipt = await (
            await new ContractCreateTransaction()
                .setAdminKey(operatorKey)
                .setGas(200000)
                .setConstructorParameters(
                    new ContractFunctionParameters().addString(
                        "Hello from Hedera.",
                    ),
                )
                .setBytecodeFileId(file)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await new ContractCallQuery()
                .setGas(75000)
                .setFunction("getMessage")
                .setQueryPayment(new Hbar(1))
                .setMaxQueryPayment(new Hbar(5))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidContractId);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("query did not error");
        }
    });

    it("should return error when the gas is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        receipt = await (
            await new ContractCreateTransaction()
                .setAdminKey(operatorKey)
                .setGas(200000)
                .setConstructorParameters(
                    new ContractFunctionParameters().addString(
                        "Hello from Hedera.",
                    ),
                )
                .setBytecodeFileId(file)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        try {
            await new ContractCallQuery()
                .setContractId(contract)
                .setFunction("getMessage")
                .execute(env.client);
        } catch (error) {
            expect(error.status).to.be.eql(Status.InsufficientGas);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractCreateFlowIntegrationTest.js
import {
    ContractCreateFlow,
    ContractFunctionParameters,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

const smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractCreateFlow", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("works", async function () {
        const operatorKey = env.operatorKey.publicKey;

        await new ContractCreateFlow()
            .setBytecode(smartContractBytecode)
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractCreateIntegrationTest.js
import {
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

const smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractCreate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        expect(
            info.adminKey != null ? info.adminKey.toString() : "",
        ).to.be.equal(operatorKey.toString());
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractCreateTransaction]",
        );

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when gas is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let err = false;

        try {
            await (
                await new ContractCreateTransaction()
                    .setAdminKey(operatorKey)
                    .setConstructorParameters(
                        new ContractFunctionParameters().addString(
                            "Hello from Hedera.",
                        ),
                    )
                    .setBytecodeFileId(file)
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InsufficientGas);
        }

        if (!err) {
            throw new Error("contract creation did not error");
        }
    });

    it("should error when contructor parameters are not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let err = false;

        try {
            await (
                await new ContractCreateTransaction()
                    .setAdminKey(operatorKey)
                    .setGas(100000)
                    .setBytecodeFileId(file)
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.ContractRevertExecuted);
        }

        if (!err) {
            throw new Error("contract creation did not error");
        }
    });

    it("should error when bytecode file ID is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let err = false;

        try {
            await (
                await new ContractCreateTransaction()
                    .setAdminKey(operatorKey)
                    .setGas(100000)
                    .setConstructorParameters(
                        new ContractFunctionParameters().addString(
                            "Hello from Hedera.",
                        ),
                    )
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidFileId);
        }

        if (!err) {
            throw new Error("contract creation did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractDeleteIntegrationTest.js
import {
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

let smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractDelete", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        expect(
            info.adminKey != null ? info.adminKey.toString() : "",
        ).to.be.equal(operatorKey.toString());
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractCreateTransaction]",
        );

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when contarct ID is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let err = false;

        try {
            await (
                await new ContractDeleteTransaction().execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidContractId);
        }

        if (!err) {
            throw new Error("contact deletion did not error");
        }
    });

    it("should create contract without admin key which can NOT be deleted", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractCreateTransaction]",
        );

        let status;

        try {
            await (
                await new ContractDeleteTransaction()
                    .setContractId(contract)
                    .setTransferAccountId(env.client.operatorAccountId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.equal(Status.ModifyingImmutableContract);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractExecuteIntegrationTest.js
import {
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
    FileCreateTransaction,
    FileDeleteTransaction,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

let smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractExecute", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        await (
            await new ContractExecuteTransaction()
                .setContractId(contract)
                .setGas(100000)
                .setFunction(
                    "setMessage",
                    new ContractFunctionParameters().addString("new message"),
                )
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when contract ID is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await (
                await new ContractExecuteTransaction()
                    .setGas(100000)
                    .setFunction(
                        "setMessage",
                        new ContractFunctionParameters().addString(
                            "new message",
                        ),
                    )
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidContractId);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("contract execution did not error");
        }
    });

    it("should error when function is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await (
                await new ContractExecuteTransaction()
                    .setContractId(contract)
                    .setGas(100000)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.ContractRevertExecuted);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("contract execution did not error");
        }
    });

    it("should error when gas is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await (
                await new ContractExecuteTransaction()
                    .setContractId(contract)
                    .setFunction(
                        "setMessage",
                        new ContractFunctionParameters().addString(
                            "new message",
                        ),
                    )
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InsufficientGas);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("contract execution did not error");
        }
    });

    it("should error when function's parameter are not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        const contract = receipt.contractId;

        let err = false;

        try {
            await (
                await new ContractExecuteTransaction()
                    .setContractId(contract)
                    .setGas(100000)
                    .setFunction("setMessage")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.ContractRevertExecuted);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("contract execution did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractFunctionParametersIntegrationTest.js
/* eslint-disable mocha/no-setup-in-describe */
import { setTimeout } from "timers/promises";
import {
    FileCreateTransaction,
    ContractCreateTransaction,
    ContractCallQuery,
    Hbar,
    ContractFunctionParameters,
    ContractDeleteTransaction,
    FileAppendTransaction,
    FileDeleteTransaction,
    MirrorNodeContractEstimateQuery,
} from "../../src/exports.js";
import { REQUIRE_ARRAY_ERROR } from "../../src/util.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import BigNumber from "bignumber.js";
import Long from "long";

const EXTREMUM = {
    MAX: "max",
    MIN: "min",
};

const METHOD_TYPE = {
    INT: "int",
    UINT: "uint",
};

const INPUT_TYPE = {
    NUMBER: "number",
    BIG_NUMBER: "BigNumber",
    LONG: "Long",
};
/**
 * @param {number} bitSize
 * @param {string} inputType
 * @returns {{ min: number, max: number}}
 */
const calculateRange = (bitSize, inputType) => {
    // As of ECMA-262 5th Edition, "all the positive and
    // negative integers whose magnitude is no greater
    // than 2^53 are representable in the Number type",
    // which is "representing the doubleprecision 64-bit
    // format IEEE 754 values as specified in the IEEE Standard
    // for Binary Floating-Point Arithmetic".
    // The maximum safe integer in JavaScript is 2^53-1.
    const MAX_EXPONENT = 53;

    let exponent = bitSize - 1;

    if (inputType === INPUT_TYPE.NUMBER && bitSize > MAX_EXPONENT) {
        exponent = MAX_EXPONENT;
    }

    const extremum = 2 ** exponent;

    return {
        min: extremum,
        max: extremum - 1,
    };
};

/**
 * @param {number} bitSize
 * @param {string} inputType
 * @returns {number[]}
 */
const createArray = (bitSize, inputType) => {
    const { min, max } = calculateRange(bitSize, inputType);

    switch (inputType) {
        case INPUT_TYPE.NUMBER:
            return [-min, max];
        case INPUT_TYPE.BIG_NUMBER:
            return [
                new BigNumber(-2).pow(bitSize - 1),
                new BigNumber(2).pow(bitSize - 1).minus(1),
            ];
        case INPUT_TYPE.LONG:
            return [new Long(min).neg(), new Long(max)];
        default:
            return [-min, max];
    }
};

/**
 * @param {string} extremum
 * @param {number} bitSize
 * @param {string} inputType
 * @param {string} methodType
 * @returns {string}
 */
const getDescription = (extremum, bitSize, inputType, methodType) => {
    switch (extremum) {
        case EXTREMUM.MIN:
            return `should return the right min ${methodType}${bitSize} value [${inputType}]`;
        case EXTREMUM.MAX:
            return `should return the right max ${methodType}${bitSize} value [${inputType}]`;
        default:
            return "An error occured.";
    }
};

/**
 * @param {number} bitSize
 * @param {string} inputType
 * @param {string} methodType
 * @returns {string}
 */
const getDescriptionForArrayMethod = (bitSize, inputType, methodType) =>
    `should return the right array of ${methodType}${bitSize} values [${inputType}]`;

let smartContractBytecode =
    "0x608060405234801561001057600080fd5b5061574c80620000216000396000f3fe608060405234801561001057600080fd5b50600436106107bc5760003560e01c8063897831d2116103f5578063c6c18a1c11610215578063e05e91e011610130578063ea5405b3116100c3578063f6e877f411610092578063f6e877f414611719578063f8293f6e1461173f578063f9e6743114611761578063faab75351461177c578063ffb805011461179757600080fd5b8063ea5405b3146116a7578063ef4a8c1b146116c2578063f4e490f5146116dd578063f53552ef146116fe57600080fd5b8063e4081890116100ff578063e408189014611633578063e436d3901461164e578063e4fadc1014611669578063e713cda81461168457600080fd5b8063e05e91e0146115a6578063e066de50146115cc578063e0f53e24146115f2578063e29dc38a1461161857600080fd5b8063d2e43ea2116101a8578063dade0c0b11610177578063dade0c0b14611513578063dbb04ed914611535578063de9fb4841461155e578063df8cfdbe1461158b57600080fd5b8063d2e43ea21461149c578063d32201bb146114b7578063d79d4d40146114d2578063d98dda69146114f857600080fd5b8063cbf2beee116101e4578063cbf2beee14611425578063cdb9e4e814611440578063ce1ccc7a14611466578063d037df461461148157600080fd5b8063c6c18a1c14611395578063c7d8b87e146113bf578063ca692370146113e5578063cbd2e6a51461140057600080fd5b8063aa450f1f11610310578063b989c7ee116102a3578063bd90536a11610272578063bd90536a146112fc578063c05cfd8e14611324578063c3d385b91461133f578063c4596b121461135a578063c503772d1461137557600080fd5b8063b989c7ee14611274578063ba945bdb14611295578063bb6b5243146112bb578063bbcb71ed146112e157600080fd5b8063b79ecc0c116102df578063b79ecc0c146111f7578063b82c0fce14611212578063b834bfe91461122d578063b8da8d161461124e57600080fd5b8063aa450f1f1461117a578063b0dfddc414611195578063b2db404a146111b0578063b4e3e7b1146111d157600080fd5b80639b1794ae11610388578063a1bda12211610357578063a1bda122146110f7578063a284da3114611118578063a401d60d14611133578063a75761f11461115957600080fd5b80639b1794ae1461107a5780639c5663c7146110a05780639d639bcc146110bb578063a08b9f67146110d657600080fd5b806394cd7c80116103c457806394cd7c8014611002578063956ce3d714611023578063967075e31461103e57806398508ba31461105957600080fd5b8063897831d214610f9057806389cd48ed14610fab5780638b61e01314610fc6578063923f5edf14610fe157600080fd5b80633f396e67116105e057806368ef4466116104fb578063779290b31161048e5780637fc360201161045d5780637fc3602014610ef85780638469c40614610f1357806387d062dc14610f2e578063881c8fb714610f4957806388b7e6f514610f6f57600080fd5b8063779290b314610e75578063796a27ea14610e905780637d0dc26214610eb65780637ec32d8414610ed757600080fd5b8063703bd050116104ca578063703bd05014610df857806370a5cb8114610e1357806372a06b4d14610e3957806375546bf214610e5a57600080fd5b806368ef446614610d8057806369993eff14610da15780636a54715c14610dbc5780636a842c3514610ddd57600080fd5b8063545e2113116105735780635e68a6a8116105425780635e68a6a814610d085780635f6a65e314610d23578063628bc3ef14610d3e57806364e008c114610d5f57600080fd5b8063545e211314610ca557806355bed93714610cd257806359adb2df14610a105780635b14551a14610ced57600080fd5b806344e7b037116105af57806344e7b03714610c2e57806347febd6614610c545780634d4ec9c814610c6f5780635154a08414610c8a57600080fd5b80633f396e6714610baf578063407b899b14610bd757806341b3ed9914610bf85780634384e5ee14610c1357600080fd5b8063189cea8e116106db57806333520ec31161066e5780633822abcb1161063d5780633822abcb14610b1c5780633b33ccd314610b375780633b45e6e014610b525780633e1a277114610b735780633ee0a4b514610b9457600080fd5b806333520ec314610ac557806335d794e7146108fa57806336e6630214610ae657806337ff875914610b0157600080fd5b80632ef16e8e116106aa5780632ef16e8e14610a475780632f47a40d14610a685780632f6c1bb414610a89578063324ff91e14610aaa57600080fd5b8063189cea8e146109d45780631e6dccfb146109f557806322937ea914610a105780632528956214610a2c57600080fd5b806310d5455311610753578063129ed5da11610722578063129ed5da1461095757806312cd95a11461097d57806313c5d0991461099e578063155464fa146109b957600080fd5b806310d54553146108d957806311259dcf146108fa578063118b84151461091557806311ec6c901461093657600080fd5b8063060e393a1161078f578063060e393a1461085157806306ac6fe11461086c57806308123e09146108925780630a958dc8146108b857600080fd5b8063017fa10b146107c1578063021d88ab146107ef5780630374543014610815578063048bf1fb14610836575b600080fd5b6107d26107cf36600461184b565b90565b6040516001600160801b0390911681526020015b60405180910390f35b6107fd6107cf366004611884565b6040516001600160601b0390911681526020016107e6565b6108236107cf3660046118b1565b604051600c9190910b81526020016107e6565b6108446107cf366004611947565b6040516107e691906119e3565b61085f6107cf366004611a41565b6040516107e69190611acd565b61087a6107cf366004611b25565b6040516001600160781b0390911681526020016107e6565b6108a06107cf366004611b57565b60405166ffffffffffffff90911681526020016107e6565b6108c66107cf366004611b84565b60405160049190910b81526020016107e6565b6108e76107cf366004611bb1565b60405160119190910b81526020016107e6565b6109086107cf366004611bcc565b6040516107e69190611c51565b6109236107cf366004611c9b565b604051601e9190910b81526020016107e6565b6109446107cf366004611cc8565b60405160139190910b81526020016107e6565b6109656107cf366004611cfa565b6040516001600160981b0390911681526020016107e6565b61098b6107cf366004611d27565b60405160129190910b81526020016107e6565b6109ac6107cf366004611d42565b6040516107e69190611dce565b6109c76107cf366004611e26565b6040516107e69190611eb2565b6109e26107cf366004611f05565b60405160169190910b81526020016107e6565b610a036107cf366004611f32565b6040516107e69190611fbe565b610a1e6107cf366004611ff9565b6040519081526020016107e6565b610a3a6107cf36600461202c565b6040516107e691906120b8565b610a556107cf36600461210e565b604051601d9190910b81526020016107e6565b610a766107cf36600461213b565b604051600a9190910b81526020016107e6565b610a976107cf366004612168565b60405160199190910b81526020016107e6565b610ab86107cf36600461219a565b6040516107e69190612226565b610ad36107cf366004612279565b604051601a9190910b81526020016107e6565b610af46107cf366004612294565b6040516107e69190612320565b610b0f6107cf366004612372565b6040516107e691906123fe565b610b2a6107cf366004612451565b6040516107e691906124dd565b610b456107cf36600461252a565b6040516107e691906125b6565b610b606107cf366004612603565b60405160109190910b81526020016107e6565b610b816107cf366004612630565b604051601c9190910b81526020016107e6565b610ba26107cf36600461265d565b6040516107e691906126e9565b610bbd6107cf36600461273d565b60405168ffffffffffffffffff90911681526020016107e6565b610be56107cf36600461276a565b60405160079190910b81526020016107e6565b610c066107cf36600461279c565b6040516107e69190612828565b610c216107cf366004612869565b6040516107e691906128f5565b610c3c6107cf366004612947565b6040516001600160a01b0390911681526020016107e6565b610c626107cf366004612962565b6040516107e691906129ee565b610c7d6107cf366004612a29565b6040516107e69190612ab5565b610c986107cf366004612b0d565b6040516107e69190612b99565b610cb8610cb3366004612bec565b6117bb565b60408051600093840b81529190920b6020820152016107e6565b610ce06107cf366004612c07565b6040516107e69190612c93565b610cfb6107cf366004612ceb565b6040516107e69190612d77565b610d166107cf366004612db8565b6040516107e69190612e44565b610d316107cf366004612e9a565b6040516107e69190612f26565b610d4c6107cf366004612f7d565b60405160099190910b81526020016107e6565b610d6d6107cf366004612faa565b60405160179190910b81526020016107e6565b610d8e6107cf366004612fc5565b60405160149190910b81526020016107e6565b610daf6107cf366004612fe0565b6040516107e6919061306c565b610dca6107cf3660046130a7565b60405160069190910b81526020016107e6565b610deb6107cf3660046130d4565b6040516107e69190613160565b610e066107cf3660046131ae565b6040516107e6919061323a565b610e216107cf36600461328c565b6040516001600160681b0390911681526020016107e6565b610e476107cf366004612bec565b60405160009190910b81526020016107e6565b610e686107cf3660046132b9565b6040516107e69190613345565b610e836107cf366004613397565b6040516107e69190613423565b610e9e6107cf366004613464565b6040516001600160d81b0390911681526020016107e6565b610ec46107cf366004613491565b604051601b9190910b81526020016107e6565b610ee56107cf3660046134be565b60405160029190910b81526020016107e6565b610f066107cf3660046134d9565b6040516107e69190613565565b610f216107cf3660046135a8565b6040516107e69190613634565b610f3c6107cf366004613675565b6040516107e69190613701565b610f576107cf366004613753565b6040516001600160b01b0390911681526020016107e6565b610f7d6107cf366004613780565b604051600f9190910b81526020016107e6565b610f9e6107cf3660046137b2565b6040516107e6919061383e565b610fb96107cf366004613896565b6040516107e69190613922565b610fd46107cf366004613963565b6040516107e691906139ef565b610fef6107cf366004613a3c565b60405160159190910b81526020016107e6565b6110106107cf366004613a57565b60405160189190910b81526020016107e6565b6110316107cf366004613a72565b6040516107e69190613afe565b61104c6107cf366004613b39565b6040516107e69190613bc5565b6110676107cf366004613c0d565b604051600d9190910b81526020016107e6565b6110886107cf366004613c28565b6040516001600160b81b0390911681526020016107e6565b6110ae6107cf366004613c55565b6040516107e69190613ce1565b6110c96107cf366004613d2f565b6040516107e69190613dbb565b6110e46107cf366004613df8565b604051600b9190910b81526020016107e6565b6111056107cf366004613e13565b60405160019190910b81526020016107e6565b6111266107cf366004613e2e565b6040516107e69190613eba565b6111416107cf366004613ef5565b6040516001600160f01b0390911681526020016107e6565b6111676107cf366004613f10565b60405161ffff90911681526020016107e6565b6111886107cf366004613f3f565b6040516107e69190613fcb565b6111a36107cf366004614009565b6040516107e69190614095565b6111be6107cf3660046140d0565b60405160059190910b81526020016107e6565b6111df6107cf3660046140eb565b6040516001600160701b0390911681526020016107e6565b6112056107cf36600461411d565b6040516107e691906141a9565b6112206107cf366004614200565b6040516107e6919061428c565b61123b6107cf3660046142cc565b604051600e9190910b81526020016107e6565b61125c6107cf3660046142fe565b6040516001600160a81b0390911681526020016107e6565b6112826107cf36600461432b565b60405160039190910b81526020016107e6565b6112a36107cf366004614346565b6040516001600160881b0390911681526020016107e6565b6112c96107cf366004614361565b6040516001600160c81b0390911681526020016107e6565b6112ef6107cf36600461437c565b6040516107e69190614408565b61130f61130a366004611ff9565b6117d3565b604080519283526020830191909152016107e6565b6113326107cf366004614449565b6040516107e691906144d5565b61134d6107cf366004614510565b6040516107e6919061459c565b6113686107cf3660046145d7565b6040516107e69190614663565b6113836107cf3660046146b5565b60405160ff90911681526020016107e6565b6113a36107cf3660046146d0565b6040516affffffffffffffffffffff90911681526020016107e6565b6113cd6107cf3660046146eb565b6040516001600160f81b0390911681526020016107e6565b6113f36107cf366004614706565b6040516107e69190614792565b61140e6107cf3660046147cd565b60405165ffffffffffff90911681526020016107e6565b6114336107cf3660046147e8565b6040516107e69190614874565b61144e6107cf3660046148b5565b6040516001600160e01b0390911681526020016107e6565b6114746107cf3660046148d0565b6040516107e6919061495c565b61148f6107cf3660046149ae565b6040516107e69190614a3a565b6114aa6107cf366004614a7b565b6040516107e69190614b07565b6114c56107cf366004614b54565b6040516107e69190614be0565b6114e06107cf366004614c32565b6040516001600160d01b0390911681526020016107e6565b6115066107cf366004614c4d565b6040516107e69190614cd9565b611526611521366004614d14565b6117e2565b6040516107e693929190614d2f565b6115436107cf366004614d9b565b60405169ffffffffffffffffffff90911681526020016107e6565b61157161156c366004611b84565b611820565b60408051600493840b81529190920b6020820152016107e6565b6115996107cf366004614db6565b6040516107e69190614e42565b6115b46107cf366004614e83565b6040516001600160401b0390911681526020016107e6565b6115da6107cf366004614e9e565b6040516001600160e81b0390911681526020016107e6565b6116006107cf366004614eb9565b6040516001600160c01b0390911681526020016107e6565b6116266107cf366004614ed4565b6040516107e69190614f60565b6116416107cf366004614f9b565b6040516107e69190615027565b61165c6107cf366004615068565b6040516107e691906150f4565b6116776107cf36600461512f565b6040516107e691906151bb565b6116926107cf366004614d14565b60405163ffffffff90911681526020016107e6565b6116b56107cf36600461520b565b6040516107e69190615297565b6116d06107cf3660046152d6565b6040516107e69190615362565b6116eb6107cf3660046153a3565b60405160089190910b81526020016107e6565b61170c6107cf3660046153be565b6040516107e6919061544a565b6117276107cf366004615485565b6040516001600160901b0390911681526020016107e6565b61174d6107cf3660046154a0565b60405162ffffff90911681526020016107e6565b61176f6107cf3660046154bb565b6040516107e69190615547565b61178a6107cf366004615582565b6040516107e6919061560e565b6117a56107cf366004615649565b60405164ffffffffff90911681526020016107e6565b600080826117ca81601461567a565b91509150915091565b600080826117ca8160016156a1565b6000806060836117f36001826156c9565b6040805180820190915260028152614f4b60f01b602082015291945063ffffffff16925090509193909250565b600080826117ca8160016156ed565b80356001600160801b038116811461184657600080fd5b919050565b60006020828403121561185d57600080fd5b6118668261182f565b9392505050565b80356001600160601b038116811461184657600080fd5b60006020828403121561189657600080fd5b6118668261186d565b8035600c81900b811461184657600080fd5b6000602082840312156118c357600080fd5b6118668261189f565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b038111828210171561190a5761190a6118cc565b604052919050565b60006001600160401b0382111561192b5761192b6118cc565b5060051b60200190565b8035601481900b811461184657600080fd5b6000602080838503121561195a57600080fd5b82356001600160401b0381111561197057600080fd5b8301601f8101851361198157600080fd5b803561199461198f82611912565b6118e2565b81815260059190911b820183019083810190878311156119b357600080fd5b928401925b828410156119d8576119c984611935565b825292840192908401906119b8565b979650505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160140b835292840192918401916001016119ff565b50909695505050505050565b80356001600160e81b038116811461184657600080fd5b60006020808385031215611a5457600080fd5b82356001600160401b03811115611a6a57600080fd5b8301601f81018513611a7b57600080fd5b8035611a8961198f82611912565b81815260059190911b82018301908381019087831115611aa857600080fd5b928401925b828410156119d857611abe84611a2a565b82529284019290840190611aad565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160e81b031683529284019291840191600101611ae9565b80356001600160781b038116811461184657600080fd5b600060208284031215611b3757600080fd5b61186682611b0e565b803566ffffffffffffff8116811461184657600080fd5b600060208284031215611b6957600080fd5b61186682611b40565b8035600481900b811461184657600080fd5b600060208284031215611b9657600080fd5b61186682611b72565b8035601181900b811461184657600080fd5b600060208284031215611bc357600080fd5b61186682611b9f565b60006020808385031215611bdf57600080fd5b82356001600160401b03811115611bf557600080fd5b8301601f81018513611c0657600080fd5b8035611c1461198f82611912565b81815260059190911b82018301908381019087831115611c3357600080fd5b928401925b828410156119d857833582529284019290840190611c38565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835183529284019291840191600101611c6d565b8035601e81900b811461184657600080fd5b600060208284031215611cad57600080fd5b61186682611c89565b8035601381900b811461184657600080fd5b600060208284031215611cda57600080fd5b61186682611cb6565b80356001600160981b038116811461184657600080fd5b600060208284031215611d0c57600080fd5b61186682611ce3565b8035601281900b811461184657600080fd5b600060208284031215611d3957600080fd5b61186682611d15565b60006020808385031215611d5557600080fd5b82356001600160401b03811115611d6b57600080fd5b8301601f81018513611d7c57600080fd5b8035611d8a61198f82611912565b81815260059190911b82018301908381019087831115611da957600080fd5b928401925b828410156119d857611dbf84611b40565b82529284019290840190611dae565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835166ffffffffffffff1683529284019291840191600101611dea565b80356001600160c01b038116811461184657600080fd5b60006020808385031215611e3957600080fd5b82356001600160401b03811115611e4f57600080fd5b8301601f81018513611e6057600080fd5b8035611e6e61198f82611912565b81815260059190911b82018301908381019087831115611e8d57600080fd5b928401925b828410156119d857611ea384611e0f565b82529284019290840190611e92565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160c01b031683529284019291840191600101611ece565b8035601681900b811461184657600080fd5b600060208284031215611f1757600080fd5b61186682611ef3565b8035600581900b811461184657600080fd5b60006020808385031215611f4557600080fd5b82356001600160401b03811115611f5b57600080fd5b8301601f81018513611f6c57600080fd5b8035611f7a61198f82611912565b81815260059190911b82018301908381019087831115611f9957600080fd5b928401925b828410156119d857611faf84611f20565b82529284019290840190611f9e565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160050b83529284019291840191600101611fda565b60006020828403121561200b57600080fd5b5035919050565b803569ffffffffffffffffffff8116811461184657600080fd5b6000602080838503121561203f57600080fd5b82356001600160401b0381111561205557600080fd5b8301601f8101851361206657600080fd5b803561207461198f82611912565b81815260059190911b8201830190838101908783111561209357600080fd5b928401925b828410156119d8576120a984612012565b82529284019290840190612098565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835169ffffffffffffffffffff16835292840192918401916001016120d4565b8035601d81900b811461184657600080fd5b60006020828403121561212057600080fd5b611866826120fc565b8035600a81900b811461184657600080fd5b60006020828403121561214d57600080fd5b61186682612129565b8035601981900b811461184657600080fd5b60006020828403121561217a57600080fd5b61186682612156565b80356001600160b81b038116811461184657600080fd5b600060208083850312156121ad57600080fd5b82356001600160401b038111156121c357600080fd5b8301601f810185136121d457600080fd5b80356121e261198f82611912565b81815260059190911b8201830190838101908783111561220157600080fd5b928401925b828410156119d85761221784612183565b82529284019290840190612206565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160b81b031683529284019291840191600101612242565b8035601a81900b811461184657600080fd5b60006020828403121561228b57600080fd5b61186682612267565b600060208083850312156122a757600080fd5b82356001600160401b038111156122bd57600080fd5b8301601f810185136122ce57600080fd5b80356122dc61198f82611912565b81815260059190911b820183019083810190878311156122fb57600080fd5b928401925b828410156119d85761231184611cb6565b82529284019290840190612300565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160130b8352928401929184019160010161233c565b80356001600160f01b038116811461184657600080fd5b6000602080838503121561238557600080fd5b82356001600160401b0381111561239b57600080fd5b8301601f810185136123ac57600080fd5b80356123ba61198f82611912565b81815260059190911b820183019083810190878311156123d957600080fd5b928401925b828410156119d8576123ef8461235b565b825292840192908401906123de565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160f01b03168352928401929184019160010161241a565b8035600681900b811461184657600080fd5b6000602080838503121561246457600080fd5b82356001600160401b0381111561247a57600080fd5b8301601f8101851361248b57600080fd5b803561249961198f82611912565b81815260059190911b820183019083810190878311156124b857600080fd5b928401925b828410156119d8576124ce8461243f565b825292840192908401906124bd565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160060b835292840192918401916001016124f9565b8035600181900b811461184657600080fd5b6000602080838503121561253d57600080fd5b82356001600160401b0381111561255357600080fd5b8301601f8101851361256457600080fd5b803561257261198f82611912565b81815260059190911b8201830190838101908783111561259157600080fd5b928401925b828410156119d8576125a784612518565b82529284019290840190612596565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600190810b84529385019392850192016125d2565b8035601081900b811461184657600080fd5b60006020828403121561261557600080fd5b611866826125f1565b8035601c81900b811461184657600080fd5b60006020828403121561264257600080fd5b6118668261261e565b8035600b81900b811461184657600080fd5b6000602080838503121561267057600080fd5b82356001600160401b0381111561268657600080fd5b8301601f8101851361269757600080fd5b80356126a561198f82611912565b81815260059190911b820183019083810190878311156126c457600080fd5b928401925b828410156119d8576126da8461264b565b825292840192908401906126c9565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600b0b83529284019291840191600101612705565b803568ffffffffffffffffff8116811461184657600080fd5b60006020828403121561274f57600080fd5b61186682612724565b8035600781900b811461184657600080fd5b60006020828403121561277c57600080fd5b61186682612758565b80356001600160d81b038116811461184657600080fd5b600060208083850312156127af57600080fd5b82356001600160401b038111156127c557600080fd5b8301601f810185136127d657600080fd5b80356127e461198f82611912565b81815260059190911b8201830190838101908783111561280357600080fd5b928401925b828410156119d85761281984612785565b82529284019290840190612808565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160d81b031683529284019291840191600101612844565b6000602080838503121561287c57600080fd5b82356001600160401b0381111561289257600080fd5b8301601f810185136128a357600080fd5b80356128b161198f82611912565b81815260059190911b820183019083810190878311156128d057600080fd5b928401925b828410156119d8576128e684611b9f565b825292840192908401906128d5565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160110b83529284019291840191600101612911565b80356001600160a01b038116811461184657600080fd5b60006020828403121561295957600080fd5b61186682612930565b6000602080838503121561297557600080fd5b82356001600160401b0381111561298b57600080fd5b8301601f8101851361299c57600080fd5b80356129aa61198f82611912565b81815260059190911b820183019083810190878311156129c957600080fd5b928401925b828410156119d8576129df8461189f565b825292840192908401906129ce565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600c0b83529284019291840191600101612a0a565b60006020808385031215612a3c57600080fd5b82356001600160401b03811115612a5257600080fd5b8301601f81018513612a6357600080fd5b8035612a7161198f82611912565b81815260059190911b82018301908381019087831115612a9057600080fd5b928401925b828410156119d857612aa68461186d565b82529284019290840190612a95565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160601b031683529284019291840191600101612ad1565b80356001600160e01b038116811461184657600080fd5b60006020808385031215612b2057600080fd5b82356001600160401b03811115612b3657600080fd5b8301601f81018513612b4757600080fd5b8035612b5561198f82611912565b81815260059190911b82018301908381019087831115612b7457600080fd5b928401925b828410156119d857612b8a84612af6565b82529284019290840190612b79565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160e01b031683529284019291840191600101612bb5565b8035600081900b811461184657600080fd5b600060208284031215612bfe57600080fd5b61186682612bda565b60006020808385031215612c1a57600080fd5b82356001600160401b03811115612c3057600080fd5b8301601f81018513612c4157600080fd5b8035612c4f61198f82611912565b81815260059190911b82018301908381019087831115612c6e57600080fd5b928401925b828410156119d857612c8484611b0e565b82529284019290840190612c73565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160781b031683529284019291840191600101612caf565b80356001600160c81b038116811461184657600080fd5b60006020808385031215612cfe57600080fd5b82356001600160401b03811115612d1457600080fd5b8301601f81018513612d2557600080fd5b8035612d3361198f82611912565b81815260059190911b82018301908381019087831115612d5257600080fd5b928401925b828410156119d857612d6884612cd4565b82529284019290840190612d57565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160c81b031683529284019291840191600101612d93565b60006020808385031215612dcb57600080fd5b82356001600160401b03811115612de157600080fd5b8301601f81018513612df257600080fd5b8035612e0061198f82611912565b81815260059190911b82018301908381019087831115612e1f57600080fd5b928401925b828410156119d857612e35846125f1565b82529284019290840190612e24565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160100b83529284019291840191600101612e60565b80356affffffffffffffffffffff8116811461184657600080fd5b60006020808385031215612ead57600080fd5b82356001600160401b03811115612ec357600080fd5b8301601f81018513612ed457600080fd5b8035612ee261198f82611912565b81815260059190911b82018301908381019087831115612f0157600080fd5b928401925b828410156119d857612f1784612e7f565b82529284019290840190612f06565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516affffffffffffffffffffff1683529284019291840191600101612f42565b8035600981900b811461184657600080fd5b600060208284031215612f8f57600080fd5b61186682612f6b565b8035601781900b811461184657600080fd5b600060208284031215612fbc57600080fd5b61186682612f98565b600060208284031215612fd757600080fd5b61186682611935565b60006020808385031215612ff357600080fd5b82356001600160401b0381111561300957600080fd5b8301601f8101851361301a57600080fd5b803561302861198f82611912565b81815260059190911b8201830190838101908783111561304757600080fd5b928401925b828410156119d85761305d84612f98565b8252928401929084019061304c565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160170b83529284019291840191600101613088565b6000602082840312156130b957600080fd5b6118668261243f565b803561ffff8116811461184657600080fd5b600060208083850312156130e757600080fd5b82356001600160401b038111156130fd57600080fd5b8301601f8101851361310e57600080fd5b803561311c61198f82611912565b81815260059190911b8201830190838101908783111561313b57600080fd5b928401925b828410156119d857613151846130c2565b82529284019290840190613140565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835161ffff168352928401929184019160010161317c565b8035600d81900b811461184657600080fd5b600060208083850312156131c157600080fd5b82356001600160401b038111156131d757600080fd5b8301601f810185136131e857600080fd5b80356131f661198f82611912565b81815260059190911b8201830190838101908783111561321557600080fd5b928401925b828410156119d85761322b8461319c565b8252928401929084019061321a565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600d0b83529284019291840191600101613256565b80356001600160681b038116811461184657600080fd5b60006020828403121561329e57600080fd5b61186682613275565b8035601881900b811461184657600080fd5b600060208083850312156132cc57600080fd5b82356001600160401b038111156132e257600080fd5b8301601f810185136132f357600080fd5b803561330161198f82611912565b81815260059190911b8201830190838101908783111561332057600080fd5b928401925b828410156119d857613336846132a7565b82529284019290840190613325565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160180b83529284019291840191600101613361565b80356001600160701b038116811461184657600080fd5b600060208083850312156133aa57600080fd5b82356001600160401b038111156133c057600080fd5b8301601f810185136133d157600080fd5b80356133df61198f82611912565b81815260059190911b820183019083810190878311156133fe57600080fd5b928401925b828410156119d85761341484613380565b82529284019290840190613403565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160701b03168352928401929184019160010161343f565b60006020828403121561347657600080fd5b61186682612785565b8035601b81900b811461184657600080fd5b6000602082840312156134a357600080fd5b6118668261347f565b8035600281900b811461184657600080fd5b6000602082840312156134d057600080fd5b611866826134ac565b600060208083850312156134ec57600080fd5b82356001600160401b0381111561350257600080fd5b8301601f8101851361351357600080fd5b803561352161198f82611912565b81815260059190911b8201830190838101908783111561354057600080fd5b928401925b828410156119d85761355684612724565b82529284019290840190613545565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835168ffffffffffffffffff1683529284019291840191600101613581565b600060208083850312156135bb57600080fd5b82356001600160401b038111156135d157600080fd5b8301601f810185136135e257600080fd5b80356135f061198f82611912565b81815260059190911b8201830190838101908783111561360f57600080fd5b928401925b828410156119d85761362584613275565b82529284019290840190613614565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160681b031683529284019291840191600101613650565b6000602080838503121561368857600080fd5b82356001600160401b0381111561369e57600080fd5b8301601f810185136136af57600080fd5b80356136bd61198f82611912565b81815260059190911b820183019083810190878311156136dc57600080fd5b928401925b828410156119d8576136f2846120fc565b825292840192908401906136e1565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351601d0b8352928401929184019160010161371d565b80356001600160b01b038116811461184657600080fd5b60006020828403121561376557600080fd5b6118668261373c565b8035600f81900b811461184657600080fd5b60006020828403121561379257600080fd5b6118668261376e565b80356001600160881b038116811461184657600080fd5b600060208083850312156137c557600080fd5b82356001600160401b038111156137db57600080fd5b8301601f810185136137ec57600080fd5b80356137fa61198f82611912565b81815260059190911b8201830190838101908783111561381957600080fd5b928401925b828410156119d85761382f8461379b565b8252928401929084019061381e565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160881b03168352928401929184019160010161385a565b80356001600160f81b038116811461184657600080fd5b600060208083850312156138a957600080fd5b82356001600160401b038111156138bf57600080fd5b8301601f810185136138d057600080fd5b80356138de61198f82611912565b81815260059190911b820183019083810190878311156138fd57600080fd5b928401925b828410156119d8576139138461387f565b82529284019290840190613902565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160f81b03168352928401929184019160010161393e565b6000602080838503121561397657600080fd5b82356001600160401b0381111561398c57600080fd5b8301601f8101851361399d57600080fd5b80356139ab61198f82611912565b81815260059190911b820183019083810190878311156139ca57600080fd5b928401925b828410156119d8576139e084611d15565b825292840192908401906139cf565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160120b83529284019291840191600101613a0b565b8035601581900b811461184657600080fd5b600060208284031215613a4e57600080fd5b61186682613a2a565b600060208284031215613a6957600080fd5b611866826132a7565b60006020808385031215613a8557600080fd5b82356001600160401b03811115613a9b57600080fd5b8301601f81018513613aac57600080fd5b8035613aba61198f82611912565b81815260059190911b82018301908381019087831115613ad957600080fd5b928401925b828410156119d857613aef8461261e565b82529284019290840190613ade565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351601c0b83529284019291840191600101613b1a565b60006020808385031215613b4c57600080fd5b82356001600160401b03811115613b6257600080fd5b8301601f81018513613b7357600080fd5b8035613b8161198f82611912565b81815260059190911b82018301908381019087831115613ba057600080fd5b928401925b828410156119d857613bb684612bda565b82529284019290840190613ba5565b602080825282518282018190526000919084820190604085019084805b82811015613c00578451820b84529385019392850192600101613be2565b5091979650505050505050565b600060208284031215613c1f57600080fd5b6118668261319c565b600060208284031215613c3a57600080fd5b61186682612183565b8035600e81900b811461184657600080fd5b60006020808385031215613c6857600080fd5b82356001600160401b03811115613c7e57600080fd5b8301601f81018513613c8f57600080fd5b8035613c9d61198f82611912565b81815260059190911b82018301908381019087831115613cbc57600080fd5b928401925b828410156119d857613cd284613c43565b82529284019290840190613cc1565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600e0b83529284019291840191600101613cfd565b803562ffffff8116811461184657600080fd5b60006020808385031215613d4257600080fd5b82356001600160401b03811115613d5857600080fd5b8301601f81018513613d6957600080fd5b8035613d7761198f82611912565b81815260059190911b82018301908381019087831115613d9657600080fd5b928401925b828410156119d857613dac84613d1c565b82529284019290840190613d9b565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835162ffffff1683529284019291840191600101613dd7565b600060208284031215613e0a57600080fd5b6118668261264b565b600060208284031215613e2557600080fd5b61186682612518565b60006020808385031215613e4157600080fd5b82356001600160401b03811115613e5757600080fd5b8301601f81018513613e6857600080fd5b8035613e7661198f82611912565b81815260059190911b82018301908381019087831115613e9557600080fd5b928401925b828410156119d857613eab84611c89565b82529284019290840190613e9a565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351601e0b83529284019291840191600101613ed6565b600060208284031215613f0757600080fd5b6118668261235b565b600060208284031215613f2257600080fd5b611866826130c2565b803563ffffffff8116811461184657600080fd5b60006020808385031215613f5257600080fd5b82356001600160401b03811115613f6857600080fd5b8301601f81018513613f7957600080fd5b8035613f8761198f82611912565b81815260059190911b82018301908381019087831115613fa657600080fd5b928401925b828410156119d857613fbc84613f2b565b82529284019290840190613fab565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835163ffffffff1683529284019291840191600101613fe7565b6000602080838503121561401c57600080fd5b82356001600160401b0381111561403257600080fd5b8301601f8101851361404357600080fd5b803561405161198f82611912565b81815260059190911b8201830190838101908783111561407057600080fd5b928401925b828410156119d85761408684611b72565b82529284019290840190614075565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160040b835292840192918401916001016140b1565b6000602082840312156140e257600080fd5b61186682611f20565b6000602082840312156140fd57600080fd5b61186682613380565b80356001600160401b038116811461184657600080fd5b6000602080838503121561413057600080fd5b82356001600160401b0381111561414657600080fd5b8301601f8101851361415757600080fd5b803561416561198f82611912565b81815260059190911b8201830190838101908783111561418457600080fd5b928401925b828410156119d85761419a84614106565b82529284019290840190614189565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160401b0316835292840192918401916001016141c5565b803565ffffffffffff8116811461184657600080fd5b6000602080838503121561421357600080fd5b82356001600160401b0381111561422957600080fd5b8301601f8101851361423a57600080fd5b803561424861198f82611912565b81815260059190911b8201830190838101908783111561426757600080fd5b928401925b828410156119d85761427d846141ea565b8252928401929084019061426c565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835165ffffffffffff16835292840192918401916001016142a8565b6000602082840312156142de57600080fd5b61186682613c43565b80356001600160a81b038116811461184657600080fd5b60006020828403121561431057600080fd5b611866826142e7565b8035600381900b811461184657600080fd5b60006020828403121561433d57600080fd5b61186682614319565b60006020828403121561435857600080fd5b6118668261379b565b60006020828403121561437357600080fd5b61186682612cd4565b6000602080838503121561438f57600080fd5b82356001600160401b038111156143a557600080fd5b8301601f810185136143b657600080fd5b80356143c461198f82611912565b81815260059190911b820183019083810190878311156143e357600080fd5b928401925b828410156119d8576143f98461182f565b825292840192908401906143e8565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160801b031683529284019291840191600101614424565b6000602080838503121561445c57600080fd5b82356001600160401b0381111561447257600080fd5b8301601f8101851361448357600080fd5b803561449161198f82611912565b81815260059190911b820183019083810190878311156144b057600080fd5b928401925b828410156119d8576144c68461376e565b825292840192908401906144b5565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600f0b835292840192918401916001016144f1565b6000602080838503121561452357600080fd5b82356001600160401b0381111561453957600080fd5b8301601f8101851361454a57600080fd5b803561455861198f82611912565b81815260059190911b8201830190838101908783111561457757600080fd5b928401925b828410156119d85761458d84612f6b565b8252928401929084019061457c565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160090b835292840192918401916001016145b8565b600060208083850312156145ea57600080fd5b82356001600160401b0381111561460057600080fd5b8301601f8101851361461157600080fd5b803561461f61198f82611912565b81815260059190911b8201830190838101908783111561463e57600080fd5b928401925b828410156119d85761465484611ce3565b82529284019290840190614643565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160981b03168352928401929184019160010161467f565b803560ff8116811461184657600080fd5b6000602082840312156146c757600080fd5b611866826146a4565b6000602082840312156146e257600080fd5b61186682612e7f565b6000602082840312156146fd57600080fd5b6118668261387f565b6000602080838503121561471957600080fd5b82356001600160401b0381111561472f57600080fd5b8301601f8101851361474057600080fd5b803561474e61198f82611912565b81815260059190911b8201830190838101908783111561476d57600080fd5b928401925b828410156119d85761478384611ef3565b82529284019290840190614772565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160160b835292840192918401916001016147ae565b6000602082840312156147df57600080fd5b611866826141ea565b600060208083850312156147fb57600080fd5b82356001600160401b0381111561481157600080fd5b8301601f8101851361482257600080fd5b803561483061198f82611912565b81815260059190911b8201830190838101908783111561484f57600080fd5b928401925b828410156119d8576148658461373c565b82529284019290840190614854565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160b01b031683529284019291840191600101614890565b6000602082840312156148c757600080fd5b61186682612af6565b600060208083850312156148e357600080fd5b82356001600160401b038111156148f957600080fd5b8301601f8101851361490a57600080fd5b803561491861198f82611912565b81815260059190911b8201830190838101908783111561493757600080fd5b928401925b828410156119d85761494d84614319565b8252928401929084019061493c565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160030b83529284019291840191600101614978565b80356001600160901b038116811461184657600080fd5b600060208083850312156149c157600080fd5b82356001600160401b038111156149d757600080fd5b8301601f810185136149e857600080fd5b80356149f661198f82611912565b81815260059190911b82018301908381019087831115614a1557600080fd5b928401925b828410156119d857614a2b84614997565b82529284019290840190614a1a565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160901b031683529284019291840191600101614a56565b60006020808385031215614a8e57600080fd5b82356001600160401b03811115614aa457600080fd5b8301601f81018513614ab557600080fd5b8035614ac361198f82611912565b81815260059190911b82018301908381019087831115614ae257600080fd5b928401925b828410156119d857614af884612129565b82529284019290840190614ae7565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351600a0b83529284019291840191600101614b23565b8035600881900b811461184657600080fd5b60006020808385031215614b6757600080fd5b82356001600160401b03811115614b7d57600080fd5b8301601f81018513614b8e57600080fd5b8035614b9c61198f82611912565b81815260059190911b82018301908381019087831115614bbb57600080fd5b928401925b828410156119d857614bd184614b42565b82529284019290840190614bc0565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160080b83529284019291840191600101614bfc565b80356001600160d01b038116811461184657600080fd5b600060208284031215614c4457600080fd5b61186682614c1b565b60006020808385031215614c6057600080fd5b82356001600160401b03811115614c7657600080fd5b8301601f81018513614c8757600080fd5b8035614c9561198f82611912565b81815260059190911b82018301908381019087831115614cb457600080fd5b928401925b828410156119d857614cca84612267565b82529284019290840190614cb9565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351601a0b83529284019291840191600101614cf5565b600060208284031215614d2657600080fd5b61186682613f2b565b63ffffffff84168152600060206001600160401b0385168184015260606040840152835180606085015260005b81811015614d7857858101830151858201608001528201614d5c565b506000608082860101526080601f19601f83011685010192505050949350505050565b600060208284031215614dad57600080fd5b61186682612012565b60006020808385031215614dc957600080fd5b82356001600160401b03811115614ddf57600080fd5b8301601f81018513614df057600080fd5b8035614dfe61198f82611912565b81815260059190911b82018301908381019087831115614e1d57600080fd5b928401925b828410156119d857614e3384612930565b82529284019290840190614e22565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160a01b031683529284019291840191600101614e5e565b600060208284031215614e9557600080fd5b61186682614106565b600060208284031215614eb057600080fd5b61186682611a2a565b600060208284031215614ecb57600080fd5b61186682611e0f565b60006020808385031215614ee757600080fd5b82356001600160401b03811115614efd57600080fd5b8301601f81018513614f0e57600080fd5b8035614f1c61198f82611912565b81815260059190911b82018301908381019087831115614f3b57600080fd5b928401925b828410156119d857614f5184612758565b82529284019290840190614f40565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160070b83529284019291840191600101614f7c565b60006020808385031215614fae57600080fd5b82356001600160401b03811115614fc457600080fd5b8301601f81018513614fd557600080fd5b8035614fe361198f82611912565b81815260059190911b8201830190838101908783111561500257600080fd5b928401925b828410156119d857615018846142e7565b82529284019290840190615007565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160a81b031683529284019291840191600101615043565b6000602080838503121561507b57600080fd5b82356001600160401b0381111561509157600080fd5b8301601f810185136150a257600080fd5b80356150b061198f82611912565b81815260059190911b820183019083810190878311156150cf57600080fd5b928401925b828410156119d8576150e584613a2a565b825292840192908401906150d4565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160150b83529284019291840191600101615110565b6000602080838503121561514257600080fd5b82356001600160401b0381111561515857600080fd5b8301601f8101851361516957600080fd5b803561517761198f82611912565b81815260059190911b8201830190838101908783111561519657600080fd5b928401925b828410156119d8576151ac846134ac565b8252928401929084019061519b565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160020b835292840192918401916001016151d7565b803564ffffffffff8116811461184657600080fd5b6000602080838503121561521e57600080fd5b82356001600160401b0381111561523457600080fd5b8301601f8101851361524557600080fd5b803561525361198f82611912565b81815260059190911b8201830190838101908783111561527257600080fd5b928401925b828410156119d857615288846151f6565b82529284019290840190615277565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835164ffffffffff16835292840192918401916001016152b3565b600060208083850312156152e957600080fd5b82356001600160401b038111156152ff57600080fd5b8301601f8101851361531057600080fd5b803561531e61198f82611912565b81815260059190911b8201830190838101908783111561533d57600080fd5b928401925b828410156119d85761535384614c1b565b82529284019290840190615342565b6020808252825182820181905260009190848201906040850190845b81811015611a1e5783516001600160d01b03168352928401929184019160010161537e565b6000602082840312156153b557600080fd5b61186682614b42565b600060208083850312156153d157600080fd5b82356001600160401b038111156153e757600080fd5b8301601f810185136153f857600080fd5b803561540661198f82611912565b81815260059190911b8201830190838101908783111561542557600080fd5b928401925b828410156119d85761543b84612156565b8252928401929084019061542a565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160190b83529284019291840191600101615466565b60006020828403121561549757600080fd5b61186682614997565b6000602082840312156154b257600080fd5b61186682613d1c565b600060208083850312156154ce57600080fd5b82356001600160401b038111156154e457600080fd5b8301601f810185136154f557600080fd5b803561550361198f82611912565b81815260059190911b8201830190838101908783111561552257600080fd5b928401925b828410156119d857615538846146a4565b82529284019290840190615527565b6020808252825182820181905260009190848201906040850190845b81811015611a1e57835160ff1683529284019291840191600101615563565b6000602080838503121561559557600080fd5b82356001600160401b038111156155ab57600080fd5b8301601f810185136155bc57600080fd5b80356155ca61198f82611912565b81815260059190911b820183019083810190878311156155e957600080fd5b928401925b828410156119d8576155ff8461347f565b825292840192908401906155ee565b6020808252825182820181905260009190848201906040850190845b81811015611a1e578351601b0b8352928401929184019160010161562a565b60006020828403121561565b57600080fd5b611866826151f6565b634e487b7160e01b600052601160045260246000fd5b600081810b9083900b01607f8113607f198212171561569b5761569b615664565b92915050565b80820182811260008312801582168215821617156156c1576156c1615664565b505092915050565b63ffffffff8281168282160390808211156156e6576156e6615664565b5092915050565b600481810b9083900b01647fffffffff8113647fffffffff198212171561569b5761569b61566456fea264697066735822122059b2a999293b864561fd2a712500441a478d011203453b72f2b4088d8c8a521464736f6c63430008120033";

const bitSizes = [
    8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144,
    152, 160, 168, 176, 184, 192, 200, 208, 216, 224, 232, 240, 248, 256,
];

describe("ContractFunctionParameters", function () {
    let env;
    let newContractId;

    before(async function () {
        env = await IntegrationTestEnv.new({ balance: 100000 });
        // Create a file on Hedera and store the bytecode
        const fileCreateTx = new FileCreateTransaction()
            .setKeys([env.operatorKey])
            .freezeWith(env.client);
        const fileCreateSign = await fileCreateTx.sign(env.operatorKey);
        const fileCreateSubmit = await fileCreateSign.execute(env.client);
        const fileCreateRx = await fileCreateSubmit.getReceipt(env.client);
        const bytecodeFileId = fileCreateRx.fileId;
        console.log(`- The bytecode file ID is: ${bytecodeFileId} \n`);

        //Append contents to the file
        const fileAppendTx = new FileAppendTransaction()
            .setFileId(bytecodeFileId)
            .setContents(smartContractBytecode)
            .setMaxChunks(20)
            .freezeWith(env.client);
        const fileAppendSign = await fileAppendTx.sign(env.operatorKey);
        const fileAppendSubmit = await fileAppendSign.execute(env.client);
        const fileAppendRx = await fileAppendSubmit.getReceipt(env.client);
        console.log(
            "Status of file append is",
            fileAppendRx.status.toString(10),
        );

        // Instantiate the contract instance
        const contractTx = new ContractCreateTransaction()
            //Set the file ID of the Hedera file storing the bytecode
            .setBytecodeFileId(bytecodeFileId)
            //Set the gas to instantiate the contract
            .setGas(500000)
            //Provide the constructor parameters for the contract
            .setConstructorParameters();

        //Submit the transaction to the Hedera test network
        const contractResponse = await contractTx.execute(env.client);

        //Get the receipt of the file create transaction
        const contractReceipt = await contractResponse.getReceipt(env.client);

        await setTimeout(2500);

        //Get the smart contract ID
        newContractId = contractReceipt.contractId;

        //Log the smart contract ID
        console.log("The smart contract ID is " + newContractId);
    });

    bitSizes.forEach((bitSize) => {
        describe(`Tests for addInt${bitSize} method`, function () {
            it(
                getDescription(
                    EXTREMUM.MIN,
                    bitSize,
                    INPUT_TYPE.NUMBER,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}`
                    ](-calculateRange(bitSize, INPUT_TYPE.NUMBER).min);

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(`returnInt${bitSize}`, contractParams)
                            .execute(env.client);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getInt${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        (-calculateRange(bitSize, INPUT_TYPE.NUMBER)
                            .min).toString(10),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MAX,
                    bitSize,
                    INPUT_TYPE.NUMBER,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const functionParams = new ContractFunctionParameters()[
                        `addInt${bitSize}`
                    ](calculateRange(bitSize, INPUT_TYPE.NUMBER).max);

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(`returnInt${bitSize}`, functionParams)
                            .execute(env.client);
                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}`, functionParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getInt${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        calculateRange(bitSize, INPUT_TYPE.NUMBER).max.toString(
                            10,
                        ),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MIN,
                    bitSize,
                    INPUT_TYPE.BIG_NUMBER,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}`
                    ](new BigNumber(-2).pow(bitSize - 1));
                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(`returnInt${bitSize}`, contractParams)
                            .execute(env.client);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getInt${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        new BigNumber(-2).pow(bitSize - 1).toString(10),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MAX,
                    bitSize,
                    INPUT_TYPE.BIG_NUMBER,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}`
                    ](new BigNumber(2).pow(bitSize - 1).minus(1));

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(`returnInt${bitSize}`, contractParams)
                            .execute(env.client);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getInt${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        new BigNumber(2)
                            .pow(bitSize - 1)
                            .minus(1)
                            .toString(10),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MIN,
                    bitSize,
                    INPUT_TYPE.LONG,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}`
                    ](new Long(calculateRange(bitSize).min).neg());

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(`returnInt${bitSize}`, contractParams)
                            .execute(env.client);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getInt${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        new Long(calculateRange(bitSize).min)
                            .neg()
                            .toString(10),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MAX,
                    bitSize,
                    INPUT_TYPE.LONG,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}`
                    ](new Long(calculateRange(bitSize).max));
                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(`returnInt${bitSize}`, contractParams)
                            .execute(env.client);
                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getInt${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        new Long(calculateRange(bitSize).max).toString(10),
                    );
                },
            );
        });

        describe(`Tests for addInt${bitSize}Array method`, function () {
            it(
                getDescriptionForArrayMethod(
                    bitSize,
                    INPUT_TYPE.NUMBER,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const arr = createArray(bitSize, INPUT_TYPE.NUMBER);
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}Array`
                    ](arr);

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(
                                `returnInt${bitSize}Array`,
                                contractParams,
                            )
                            .execute(env.client);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}Array`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    const result = txResponse.getResult([`int${bitSize}[]`])[0];

                    expect(result).to.be.an("array");
                    arr.map((item, i) => {
                        expect(item.toString(10)).to.be.equal(
                            result[i].toString(10),
                        );
                    });
                },
            );

            it(
                getDescriptionForArrayMethod(
                    bitSize,
                    INPUT_TYPE.BIG_NUMBER,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const arr = createArray(bitSize, INPUT_TYPE.BIG_NUMBER);
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}Array`
                    ](arr);

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(
                                `returnInt${bitSize}Array`,
                                contractParams,
                            )
                            .execute(env.client);
                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(
                            `returnInt${bitSize}Array`,
                            new ContractFunctionParameters()[
                                `addInt${bitSize}Array`
                            ](arr),
                        )
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    const result = txResponse.getResult([`int${bitSize}[]`])[0];

                    expect(result).to.be.an("array");
                    arr.map((item, i) => {
                        expect(item.toString(10)).to.be.equal(
                            result[i].toString(10),
                        );
                    });
                },
            );

            it(
                getDescriptionForArrayMethod(
                    bitSize,
                    INPUT_TYPE.LONG,
                    METHOD_TYPE.INT,
                ),
                async function () {
                    const arr = createArray(bitSize, INPUT_TYPE.LONG);
                    const contractParams = new ContractFunctionParameters()[
                        `addInt${bitSize}Array`
                    ](arr);

                    const gasEstimte =
                        await new MirrorNodeContractEstimateQuery()
                            .setContractId(newContractId)
                            .setFunction(
                                `returnInt${bitSize}Array`,
                                contractParams,
                            )
                            .execute(env.client);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}Array`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    const result = txResponse.getResult([`int${bitSize}[]`])[0];

                    expect(result).to.be.an("array");
                    arr.map((item, i) => {
                        expect(item.toString(10)).to.be.equal(
                            result[i].toString(10),
                        );
                    });
                },
            );

            it(`addInt${bitSize}Array method should return an empty array`, async function () {
                const contractParams = new ContractFunctionParameters()[
                    `addInt${bitSize}Array`
                ](
                    // eslint-disable-next-line no-loss-of-precision
                    [],
                );

                const gasEstimte = await new MirrorNodeContractEstimateQuery()
                    .setContractId(newContractId)
                    .setFunction(`returnInt${bitSize}Array`, contractParams)
                    .execute(env.client);
                const contractQuery = new ContractCallQuery()
                    //Set the gas for the query
                    .setGas(gasEstimte)
                    //Set the contract ID to return the request for
                    .setContractId(newContractId)
                    //Set the contract function to call
                    .setFunction(`returnInt${bitSize}Array`, contractParams)
                    //Set the query payment for the node returning the request
                    //This value must cover the cost of the request otherwise will fail
                    .setQueryPayment(new Hbar(10));

                //Submit to a Hedera network
                const txResponse = await contractQuery.execute(env.client);
                const result = txResponse.getResult([`uint${bitSize}[]`])[0];
                expect(result).to.be.an("array").to.have.length(0);
            });

            it(`addInt${bitSize}Array method should throw an error`, async function () {
                const contractParams = new ContractFunctionParameters()[
                    `addInt${bitSize}`
                ](calculateRange(bitSize, INPUT_TYPE.NUMBER).max);

                const gasEstimte = await new MirrorNodeContractEstimateQuery()
                    .setContractId(newContractId)
                    .setFunction(`returnInt${bitSize}`, contractParams)
                    .execute(env.client);
                try {
                    new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(gasEstimte)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnInt${bitSize}Array`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));
                } catch (error) {
                    expect(error).to.be.instanceOf(Error);
                    expect(error.message).to.be.equal(REQUIRE_ARRAY_ERROR);
                }
            });
        });

        describe(`Tests for addUint${bitSize} method`, function () {
            it(
                getDescription(
                    EXTREMUM.MAX,
                    bitSize,
                    INPUT_TYPE.NUMBER,
                    METHOD_TYPE.UINT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}`
                    ](calculateRange(bitSize, INPUT_TYPE.NUMBER).max);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnUint${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getUint${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        calculateRange(bitSize, INPUT_TYPE.NUMBER).max.toString(
                            10,
                        ),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MAX,
                    bitSize,
                    INPUT_TYPE.BIG_NUMBER,
                    METHOD_TYPE.UINT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}`
                    ](new BigNumber(2).pow(bitSize - 1).minus(1));

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnUint${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getUint${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        new BigNumber(2)
                            .pow(bitSize - 1)
                            .minus(1)
                            .toString(10),
                    );
                },
            );

            it(
                getDescription(
                    EXTREMUM.MAX,
                    bitSize,
                    INPUT_TYPE.LONG,
                    METHOD_TYPE.UINT,
                ),
                async function () {
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}`
                    ](new Long(calculateRange(bitSize).max));

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(`returnUint${bitSize}`, contractParams)
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    expect(
                        txResponse[`getUint${bitSize}`](0).toString(10),
                    ).to.be.equal(
                        new Long(calculateRange(bitSize).max).toString(10),
                    );
                },
            );
        });

        describe(`Tests for addUint${bitSize}Array method`, function () {
            it(
                getDescriptionForArrayMethod(
                    bitSize,
                    INPUT_TYPE.NUMBER,
                    METHOD_TYPE.UINT,
                ),
                async function () {
                    const range = calculateRange(bitSize, INPUT_TYPE.NUMBER);
                    const arr = [0, range.min + range.max];
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}Array`
                    ](arr);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(
                            `returnUint${bitSize}Array`,
                            contractParams,
                        )
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    const result = txResponse.getResult([
                        `uint${bitSize}[]`,
                    ])[0];

                    expect(result).to.be.an("array");
                    arr.map((item, i) => {
                        expect(item.toString(10)).to.be.equal(
                            result[i].toString(10),
                        );
                    });
                },
            );

            it(
                getDescriptionForArrayMethod(
                    bitSize,
                    INPUT_TYPE.BIG_NUMBER,
                    METHOD_TYPE.UINT,
                ),
                async function () {
                    const arr = [0, new BigNumber(2).pow(bitSize - 1).minus(1)];
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}Array`
                    ](arr);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(
                            `returnUint${bitSize}Array`,
                            contractParams,
                        )
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    const result = txResponse.getResult([
                        `uint${bitSize}[]`,
                    ])[0];

                    expect(result).to.be.an("array");
                    arr.map((item, i) => {
                        expect(item.toString(10)).to.be.equal(
                            result[i].toString(10),
                        );
                    });
                },
            );

            it(
                getDescriptionForArrayMethod(
                    bitSize,
                    INPUT_TYPE.LONG,
                    METHOD_TYPE.UINT,
                ),
                async function () {
                    const range = calculateRange(bitSize, INPUT_TYPE.NUMBER);
                    const arr = [0, new Long(range.min + range.max)];
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}Array`
                    ](arr);

                    const contractQuery = new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(
                            `returnUint${bitSize}Array`,
                            contractParams,
                        )
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));

                    //Submit to a Hedera network
                    const txResponse = await contractQuery.execute(env.client);
                    const result = txResponse.getResult([
                        `uint${bitSize}[]`,
                    ])[0];

                    expect(result).to.be.an("array");
                    arr.map((item, i) => {
                        expect(item.toString(10)).to.be.equal(
                            result[i].toString(10),
                        );
                    });
                },
            );

            it(`addUint${bitSize}Array method should return an empty array`, async function () {
                const contractParams = new ContractFunctionParameters()[
                    `addUint${bitSize}Array`
                ](
                    // eslint-disable-next-line no-loss-of-precision
                    [],
                );

                const contractQuery = new ContractCallQuery()
                    //Set the gas for the query
                    .setGas(1_500_000)
                    //Set the contract ID to return the request for
                    .setContractId(newContractId)
                    //Set the contract function to call
                    .setFunction(`returnUint${bitSize}Array`, contractParams)
                    //Set the query payment for the node returning the request
                    //This value must cover the cost of the request otherwise will fail
                    .setQueryPayment(new Hbar(10));

                //Submit to a Hedera network
                const txResponse = await contractQuery.execute(env.client);
                const result = txResponse.getResult([`uint${bitSize}[]`])[0];
                expect(result).to.be.an("array").to.have.length(0);
            });

            it(`addUint${bitSize}Array method should throw an error`, async function () {
                try {
                    const contractParams = new ContractFunctionParameters()[
                        `addUint${bitSize}Array`
                    ]();
                    new ContractCallQuery()
                        //Set the gas for the query
                        .setGas(1_500_000)
                        //Set the contract ID to return the request for
                        .setContractId(newContractId)
                        //Set the contract function to call
                        .setFunction(
                            `returnUint${bitSize}Array`,
                            contractParams,
                        )
                        //Set the query payment for the node returning the request
                        //This value must cover the cost of the request otherwise will fail
                        .setQueryPayment(new Hbar(10));
                } catch (error) {
                    expect(error).to.be.instanceOf(Error);
                    expect(error.message).to.be.equal(REQUIRE_ARRAY_ERROR);
                }
            });
        });
    });

    it("should return the right min multiple int8 value", async function () {
        const contractParams = new ContractFunctionParameters().addInt8(-128);
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction(
                "returnInt8Multiple", // return two params: input & input (+) 20 // -128 + 20 = - 108
                contractParams,
            )
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        expect(txResponse.getInt8(0)).to.be.equal(-128);
        expect(txResponse.getInt8(1)).to.be.equal(-108);
    });

    it("should work the right way with 0 uint32 value", async function () {
        const contractParams = new ContractFunctionParameters().addUint32(0);
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction("returnUint32", contractParams)
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        expect(txResponse.getUint32(0)).to.be.equal(0);
    });

    it("should return the right multiple values", async function () {
        const contractParams = new ContractFunctionParameters().addUint32(
            4294967295,
        );
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction("returnMultipleTypeParams", contractParams)
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        const result = txResponse.getResult(["uint32", "uint64", "string"]);
        expect(result[0]).to.be.equal(4294967295); // first param returned by the contrast is in UINT32
        expect(result[1].toNumber()).to.be.equal(4294967294); // second param returned by the contract is in UINT64
        expect(result[2]).to.be.equal("OK"); // third param returned by the contract is in STRING
    });

    it("should return the right multiple int40 values", async function () {
        const contractParams = new ContractFunctionParameters().addInt40(
            549755813885,
        );
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction("returnMultipleInt40", contractParams)
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        expect(txResponse.getInt40(0).toNumber()).to.be.equal(549755813885);
        expect(txResponse.getInt40(1).toNumber()).to.be.equal(549755813886);
    });

    it("should return the right zero uint256 value", async function () {
        const contractParams = new ContractFunctionParameters().addUint256(
            // eslint-disable-next-line no-loss-of-precision
            0,
        );
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction("returnUint256", contractParams)
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        expect(txResponse.getUint256(0).toNumber()).to.be.equal(
            // eslint-disable-next-line no-loss-of-precision
            0,
        );
    });

    it("should return the right 20 decimal uint256 value", async function () {
        const contractParams = new ContractFunctionParameters().addUint256(
            // eslint-disable-next-line no-loss-of-precision
            5000000000000000000000,
        );
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction("returnUint256", contractParams)
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        expect(txResponse.getUint256(0).toNumber()).to.be.equal(
            // eslint-disable-next-line no-loss-of-precision
            5000000000000000000000,
        );
    });

    it("should return the again right uint256 value", async function () {
        const contractParams = new ContractFunctionParameters().addUint256(
            // eslint-disable-next-line no-loss-of-precision
            50,
        );
        const contractQuery = new ContractCallQuery()
            //Set the gas for the query
            .setGas(1_500_000)
            //Set the contract ID to return the request for
            .setContractId(newContractId)
            //Set the contract function to call
            .setFunction("returnUint256", contractParams)
            //Set the query payment for the node returning the request
            //This value must cover the cost of the request otherwise will fail
            .setQueryPayment(new Hbar(10));

        //Submit to a Hedera network
        const txResponse = await contractQuery.execute(env.client);

        expect(txResponse.getUint256(0).toNumber()).to.be.equal(
            // eslint-disable-next-line no-loss-of-precision
            50,
        );
    });

    it("contract create of A nonce, which deploys contract B in CONSTRUCTOR", async function () {
        const SMART_CONTRACT_BYTECODE =
            "6080604052348015600f57600080fd5b50604051601a90603b565b604051809103906000f0801580156035573d6000803e3d6000fd5b50506047565b605c8061009483390190565b603f806100556000396000f3fe6080604052600080fdfea2646970667358221220a20122cbad3457fedcc0600363d6e895f17048f5caa4afdab9e655123737567d64736f6c634300081200336080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122053dfd8835e3dc6fedfb8b4806460b9b7163f8a7248bac510c6d6808d9da9d6d364736f6c63430008120033";

        const fileCreate = await new FileCreateTransaction()
            .setKeys([env.operatorKey])
            .setContents(SMART_CONTRACT_BYTECODE)
            .execute(env.client);

        const fileId = (await fileCreate.getReceipt(env.client)).fileId;

        const contractCreate = await new ContractCreateTransaction()
            .setAdminKey(env.operatorKey)
            .setGas(100000)
            .setBytecodeFileId(fileId)
            .setContractMemo("[e2e::ContractADeploysContractBInConstructor]")
            .execute(env.client);

        const contractCreateRecord = await contractCreate.getRecord(env.client);
        const nonces =
            contractCreateRecord.contractFunctionResult.contractNonces;
        console.log(`contractNonces: ${JSON.stringify(nonces)}`);

        const contractId = contractCreateRecord.receipt.contractId;
        const contractAnonce = nonces.find(
            (nonceInfo) =>
                nonceInfo.contractId.toString() === contractId.toString(),
        );
        const contractBnonce = nonces.find(
            (nonceInfo) =>
                nonceInfo.contractId.toString() !== contractId.toString(),
        );

        expect(contractAnonce.nonce.toNumber()).to.be.equal(2);
        expect(contractBnonce.nonce.toNumber()).to.be.equal(1);

        const contractDeleteTx = await new ContractDeleteTransaction()
            .setTransferAccountId(env.operatorId)
            .setContractId(contractId)
            .execute(env.client);

        const contractDeleteResult = await contractDeleteTx.getReceipt(
            env.client,
        );
        console.log(
            `contractDelete status: ${contractDeleteResult.status.toString()}`,
        );

        const fileDeleteTx = await new FileDeleteTransaction()
            .setFileId(fileId)
            .execute(env.client);

        const fileDeleteResult = await fileDeleteTx.getReceipt(env.client);
        console.log(`fileDelete status: ${fileDeleteResult.status.toString()}`);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractInfoIntegrationTest.js
import {
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

let smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractInfo", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;
        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        expect(
            info.adminKey != null ? info.adminKey.toString() : "",
        ).to.be.equal(operatorKey.toString());
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractCreateTransaction]",
        );

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be able to query when admin key is null", async function () {
        const operatorKey = env.operatorKey.publicKey;
        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        // expect(info.adminKey.toString()).to.be.equal(
        //     info.contractId.toString()
        // );
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractCreateTransaction]",
        );
    });

    it("should error when contract ID is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;
        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let err = false;

        try {
            await new ContractInfoQuery()
                .setQueryPayment(new Hbar(1))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidContractId);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("contract info query did not error");
        }
    });

    it("should be able to query cost", async function () {
        const operatorKey = env.operatorKey.publicKey;
        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        let contract = receipt.contractId;

        const cost = await new ContractInfoQuery()
            .setContractId(contract)
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/ContractUpdateIntegrationTest.js
import {
    ContractCreateTransaction,
    ContractDeleteTransaction,
    ContractFunctionParameters,
    ContractInfoQuery,
    ContractUpdateTransaction,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

let smartContractBytecode =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

describe("ContractUpdate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        expect(
            info.adminKey != null ? info.adminKey.toString() : "",
        ).to.be.equal(operatorKey.toString());
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractCreateTransaction]",
        );

        await (
            await new ContractUpdateTransaction()
                .setContractId(contract)
                .setContractMemo("[e2e::ContractUpdateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new ContractInfoQuery()
            .setContractId(contract)
            .setQueryPayment(new Hbar(5))
            .execute(env.client);

        expect(info.contractId.toString()).to.be.equal(contract.toString());
        expect(info.accountId).to.be.not.null;
        expect(
            info.contractId != null ? info.contractId.toString() : "",
        ).to.be.equal(contract.toString());
        expect(info.adminKey).to.be.not.null;
        expect(
            info.adminKey != null ? info.adminKey.toString() : "",
        ).to.be.equal(operatorKey.toString());
        expect(info.storage.toInt()).to.be.equal(128);
        expect(info.contractMemo).to.be.equal(
            "[e2e::ContractUpdateTransaction]",
        );

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when contract ID is not set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(smartContractBytecode)
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        response = await new ContractCreateTransaction()
            .setAdminKey(operatorKey)
            .setGas(200000)
            .setConstructorParameters(
                new ContractFunctionParameters().addString(
                    "Hello from Hedera.",
                ),
            )
            .setBytecodeFileId(file)
            .setContractMemo("[e2e::ContractCreateTransaction]")
            .execute(env.client);

        receipt = await response.getReceipt(env.client);

        expect(receipt.contractId).to.not.be.null;
        expect(receipt.contractId != null ? receipt.contractId.num > 0 : false)
            .to.be.true;

        let contract = receipt.contractId;

        let err = false;

        try {
            await (
                await new ContractUpdateTransaction()
                    .setContractMemo("[e2e::ContractUpdateTransaction]")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidContractId);
        }

        await (
            await new ContractDeleteTransaction()
                .setContractId(contract)
                .setTransferAccountId(env.client.operatorAccountId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("contract update did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/CryptoTransferIntergationTest.js
import {
    Hbar,
    PrivateKey,
    Status,
    TransactionId,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, deleteAccount } from "./utils/Fixtures.js";

describe("CryptoTransfer", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;

        const { accountId, newKey } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            },
        );

        expect(accountId).to.not.be.null;

        await (
            await new TransferTransaction()
                .addHbarTransfer(accountId, new Hbar(1))
                .addHbarTransfer(operatorId, new Hbar(-1))
                .execute(env.client)
        ).getReceipt(env.client);

        await deleteAccount(env.client, newKey, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    it("should error when there is invalid account amounts", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction.setKeyWithoutAlias(key).setInitialBalance(new Hbar(0));
        });

        expect(accountId).to.not.be.null;

        let err = false;

        try {
            await (
                await new TransferTransaction()
                    .addHbarTransfer(accountId, new Hbar(1))
                    .addHbarTransfer(operatorId, new Hbar(1))
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountAmounts);
        }

        if (!err) {
            throw new Error("Crypto transfer did not error.");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/CustomFeesIntegrationTest.js
import {
    AccountId,
    CustomFixedFee,
    CustomFractionalFee,
    CustomRoyaltyFee,
    Hbar,
    KeyList,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenFeeScheduleUpdateTransaction,
    TokenGrantKycTransaction,
    TokenId,
    TransferTransaction,
    TokenType,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("CustomFees", function () {
    it("User can create a fungible token with a fixed custom fee schedule", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(1);

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction.setCustomFees([fee]);
        });

        expect(tokenId).to.not.be.null;

        await env.close({ token: tokenId });
    });

    it("User can create a fungible token with a fractional fee schedule", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFractionalFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(10)
            .setMax(0)
            .setMin(0);

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction.setCustomFees([fee]);
        });

        expect(tokenId).to.not.be.null;

        await env.close({ token: tokenId });
    });

    it("User cannot create a fungible token with a fractional fee schedule that has a denominator zero", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFractionalFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(0)
            .setMax(0)
            .setMin(0);

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error.toString().includes(Status.FractionDividesByZero);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    it("User cannot create a custom fee schedule over 10 entries", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFractionalFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(0)
            .setMax(0)
            .setMin(0);

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                    fee,
                ]);
            });
        } catch (error) {
            err = error.toString().includes(Status.CustomFeesListTooLong);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    it("User can create custom fixed fee schedule with up to 10 entries", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(1);

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction.setCustomFees([
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
            ]);
        });

        expect(tokenId).to.not.be.null;

        await env.close({ token: tokenId });
    });

    it("User can create custom fractional fee schedule with up to 10 entries", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFractionalFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(10)
            .setMax(0)
            .setMin(0);

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction.setCustomFees([
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
                fee,
            ]);
        });

        expect(tokenId).to.not.be.null;

        await env.close({ token: tokenId });
    });

    it("User has an invalid custom fee collector account ID(s)", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(new AccountId(0xffffffff))
            .setAmount(1);

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error.toString().includes(Status.InvalidCustomFeeCollector);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("User cannot transfer a custom fee schedule token to a fee collecting account that is not associated with it", async function () {
        const env = await IntegrationTestEnv.new();

        const key = PrivateKey.generateED25519();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction.setKeyWithoutAlias(key).setInitialBalance(new Hbar(2));
        });

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(1);

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction.setCustomFees([fee]);
        });

        fee.setFeeCollectorAccountId(accountId);

        let err = false;

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(tokenId)
                    .setCustomFees([fee])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidCustomFeeCollector);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    it("User cannot update a token fee schedule without having a fee schedule key signing the transaction", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(-1);

        let err = false;

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction.setFeeScheduleKey(null);
        });

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(tokenId)
                    .setCustomFees([fee])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.TokenHasNoFeeScheduleKey);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close({ token: tokenId });
    });

    it("User cannot create a token with a fractional fee schedule where the maximum amount is less than the minimum amount", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFractionalFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(10)
            .setMax(10)
            .setMin(11);

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error
                .toString()
                .includes(Status.FractionalFeeMaxAmountLessThanMinAmount);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("User cannot create a token with a custom fractional fee is greater than 1", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFractionalFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(11)
            .setDenominator(10)
            .setMax(0)
            .setMin(0);

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error
                .toString()
                .includes(Status.InvalidCustomFractionalFeesSum);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("User cannot execute the fee schedule update transaction if there is not fee schedule set already", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(1);

        let err = false;

        const tokenId = await createFungibleToken(env.client);

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(tokenId)
                    .setCustomFees([fee])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.CustomScheduleAlreadyHasNoFees);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("User cannot sign the fee schedule update transaction with any key besides the key schedule key", async function () {
        const env = await IntegrationTestEnv.new();

        const { accountId, privateKey } = await createAccount(env.client, {
            initialBalance: new Hbar(2),
        });

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(accountId)
            .setAmount(1);

        let err = false;

        const tokenId = await createFungibleToken(env.client, (transaction) => {
            transaction
                .setFeeScheduleKey(privateKey.publicKey)
                .sign(privateKey);
        });

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(tokenId)
                    .setCustomFees([fee])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidCustomFeeScheduleKey);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    it("User can update a fee schedule using the token fee schedule update transaction and fee schedule key", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(1);

        const token = await createFungibleToken(env.client, (transaction) => {
            transaction.setCustomFees([fee]);
        });

        fee.setAmount(2);

        await (
            await new TokenFeeScheduleUpdateTransaction()
                .setTokenId(token)
                .setCustomFees([fee])
                .execute(env.client)
        ).getReceipt(env.client);

        await env.close({ token });
    });

    it("User cannot have an invalid token ID in the custom fee field", async function () {
        const env = await IntegrationTestEnv.new();

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction.setInitialBalance(new Hbar(2));
        });

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(accountId)
            .setDenominatingTokenId(new TokenId(0xffffffff))
            .setAmount(1);

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenIdInCustomFees);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    it("User can create NFT with RoyaltyFees", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomRoyaltyFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(10)
            .setFallbackFee(
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.operatorId)
                    .setAmount(1),
            );

        const tokenId = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setCustomFees([fee]);
            },
        );

        await env.close({ token: tokenId });
    });

    it("User cannot add RoyaltyFees on FTs", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomRoyaltyFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(1)
            .setDenominator(10)
            .setFallbackFee(
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.operatorId)
                    .setAmount(1),
            );

        let err = false;

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error
                .toString()
                .includes(
                    Status.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique,
                );
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    it("cannot create custom fee with un-associated token fee collector", async function () {
        const env = await IntegrationTestEnv.new();

        const { accountId } = await createAccount(env.client);

        const token = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setTokenType(TokenType.FungibleUnique);
            },
        );

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(accountId)
            .setDenominatingTokenId(token)
            .setAmount(1);

        let err = false;

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(token)
                    .setCustomFees([fee])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.TokenNotAssociatedToFeeCollector);
        }

        if (!err) {
            throw new Error("token fee schedule update did not error");
        }

        await env.close({ token });
    });

    it("cannot create token with a custom fee without a fee schedule key", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setAmount(1);

        let err = false;

        const token = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setFeeScheduleKey(null).setCustomFees([fee]);
            },
        );

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(token)
                    .setCustomFees([fee])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.TokenHasNoFeeScheduleKey);
        }

        if (!err) {
            throw new Error("token fee schedule update did not error");
        }

        await env.close({ token });
    });

    it("cannot create royalty fee with numerator greater than denominator", async function () {
        const env = await IntegrationTestEnv.new();

        const fee = new CustomRoyaltyFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setNumerator(2)
            .setDenominator(1);

        let err = false;

        try {
            await createNonFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error
                .toString()
                .includes(Status.RoyaltyFractionCannotExceedOne);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });

    // Skipping since the test seems setting an empty custom fee list is no longer an error
    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("cannot clear custom fees when no custom fees are present", async function () {
        const env = await IntegrationTestEnv.new();

        let err = false;

        const token = await createNonFungibleToken(env.client);

        try {
            await (
                await new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(token)
                    .setCustomFees([])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.CustomScheduleAlreadyHasNoFees);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close({ token });
    });

    it("cannot create custom with denominating token being an NFT", async function () {
        const env = await IntegrationTestEnv.new();

        let err = false;

        const tokenId = await createNonFungibleToken(env.client);

        const fee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setDenominatingTokenId(tokenId)
            .setAmount(1);

        try {
            await createFungibleToken(env.client, (transaction) => {
                transaction.setCustomFees([fee]);
            });
        } catch (error) {
            err = error
                .toString()
                .includes(Status.CustomFeeDenominationMustBeFungibleCommon);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close({ token: tokenId });
    });

    // Cannot reproduce `CustomFeeChargingExceededMaxRecursionDepth`
    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("cannot have recursive custom fees", async function () {
        const env = await IntegrationTestEnv.new();

        let err = false;

        const { accountId: accountId1, privateKey: privateKey1 } =
            await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            });

        const { accountId: accountId2 } = await createAccount(
            env.client,
            (transaction) => {
                transaction
                    .setKeyWithoutAlias(privateKey1)
                    .setInitialBalance(new Hbar(2));
            },
        );

        const tokenId1 = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setInitialSupply(100);
            },
        );

        const fee2 = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setDenominatingTokenId(tokenId1)
            .setAmount(1);

        const tokenId2 = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setInitialSupply(100).setCustomFees([fee2]);
            },
        );

        const fee1 = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setDenominatingTokenId(tokenId2)
            .setAmount(1);

        await (
            await new TokenFeeScheduleUpdateTransaction()
                .setTokenId(tokenId1)
                .setCustomFees([fee1])
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId1])
                    .setAccountId(accountId1)
                    .freezeWith(env.client)
                    .sign(privateKey1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(tokenId1)
                    .setAccountId(accountId1)
                    .freezeWith(env.client)
                    .sign(privateKey1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId1])
                    .setAccountId(accountId2)
                    .freezeWith(env.client)
                    .sign(privateKey1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(tokenId1)
                    .setAccountId(accountId2)
                    .freezeWith(env.client)
                    .sign(privateKey1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addTokenTransfer(tokenId1, env.operatorId, -10)
                .addTokenTransfer(tokenId1, accountId1, 10)
                .execute(env.client)
        ).getReceipt(env.client);

        try {
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId1, accountId1, -1)
                    .addTokenTransfer(tokenId1, accountId2, 1)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.CustomFeeChargingExceededMaxRecursionDepth);
        }

        if (!err) {
            throw new Error("token transfer did not error");
        }

        await env.close({ token: [tokenId1, tokenId2] });
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("cannot have more than 20 balance changes in a single transfer", async function () {
        const env = await IntegrationTestEnv.new();

        let err = false;

        const { accountId: accountId1, privateKey: key1 } = await createAccount(
            env.client,
        );

        const { accountId: accountId2 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId3 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId4 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId5 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId6 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId7 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId8 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const { accountId: accountId9 } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setKeyWithoutAlias(key1);
            },
        );

        const tokenId1 = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setInitialSupply(100);
            },
        );

        const fee2 = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setDenominatingTokenId(tokenId1)
            .setAmount(1);

        const tokenId2 = await createFungibleToken(
            env.client,
            (transaction) => {
                transaction.setInitialSupply(100).setCustomFees([fee2]);
            },
        );

        const fee1 = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setDenominatingTokenId(tokenId2)
            .setAmount(1);

        await (
            await new TokenFeeScheduleUpdateTransaction()
                .setTokenId(tokenId1)
                .setCustomFees([fee1])
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId1])
                    .setAccountId(accountId1)
                    .freezeWith(env.client)
                    .sign(key1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(tokenId1)
                    .setAccountId(accountId1)
                    .freezeWith(env.client)
                    .sign(key1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId1])
                    .setAccountId(accountId2)
                    .freezeWith(env.client)
                    .sign(key1)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(tokenId1)
                    .setAccountId(accountId2)
                    .freezeWith(env.client)
                    .sign(key1)
            ).execute(env.client)
        ).getReceipt(env.client);

        try {
            await (
                await new TransferTransaction()
                    .addHbarTransfer(env.operatorId, -14)
                    .addHbarTransfer(accountId1, 1)
                    .addHbarTransfer(accountId2, 1)
                    .addHbarTransfer(accountId3, 1)
                    .addHbarTransfer(accountId4, 1)
                    .addHbarTransfer(accountId5, 1)
                    .addHbarTransfer(accountId6, 1)
                    .addHbarTransfer(accountId7, 1)
                    .addHbarTransfer(accountId8, 1)
                    .addHbarTransfer(accountId9, 1)
                    .addHbarTransfer("0.0.3", 1)
                    .addHbarTransfer("0.0.4", 1)
                    .addHbarTransfer("0.0.5", 1)
                    .addHbarTransfer("0.0.6", 1)
                    .addHbarTransfer("0.0.7", 1)
                    .addTokenTransfer(tokenId1, env.operatorId, -2)
                    .addTokenTransfer(tokenId1, accountId1, 1)
                    .addTokenTransfer(tokenId1, accountId2, 1)
                    .addTokenTransfer(tokenId2, env.operatorId, -2)
                    .addTokenTransfer(tokenId2, accountId1, 1)
                    .addTokenTransfer(tokenId2, accountId2, 1)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            console.log(error);
            err = error
                .toString()
                .includes(Status.CustomFeeChargingExceededMaxAccountAmounts);
        }

        if (!err) {
            throw new Error("token transfer did not error");
        }

        await env.close({ token: [tokenId1, tokenId2] });
    });

    it("cannot set invalid schedule key", async function () {
        const env = await IntegrationTestEnv.new();

        let err = false;

        try {
            await createNonFungibleToken(env.client, (transaction) => {
                transaction.setFeeScheduleKey(new KeyList(KeyList.of(), 1));
            });
        } catch (error) {
            err = error.toString().includes(Status.InvalidCustomFeeScheduleKey);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }

        await env.close();
    });
});
// Filename: test/integration/EthereumTransactionIntegrationTest.js
import {
    FileCreateTransaction,
    ContractFunctionParameters,
    ContractCreateTransaction,
    EthereumTransaction,
    PrivateKey,
    TransferTransaction,
    Hbar,
    TransactionResponse,
    TransactionReceipt,
    FileId,
    ContractId,
    Status,
    TransactionRecord,
} from "../../src/exports.js";
import { SMART_CONTRACT_BYTECODE } from "./contents.js";
import * as rlp from "@ethersproject/rlp";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import * as hex from "../../src/encoding/hex.js";

/**
 * @summary E2E-HIP-844
 * @url https://hips.hedera.com/hip/hip-844
 *
 * @description
 * At the moment the ethereum transaction behavior is not stable.
 * Occasionally the test fails with the following error INVALID_ACCOUNT_ID.
 * The test suite will be skipped until the problem is investigated and fixed.
 */

// eslint-disable-next-line mocha/no-skipped-tests
describe.skip("EthereumTransactionIntegrationTest", function () {
    let env, operatorKey, wallet, contractAddress, operatorId;

    before(async function () {
        env = await IntegrationTestEnv.new();
        wallet = env.wallet;
        operatorKey = wallet.getAccountKey();
        operatorId = wallet.getAccountId();
    });

    it("Signer nonce changed on Ethereum transaction", async function () {
        try {
            const fileResponse = await (
                await (
                    await new FileCreateTransaction()
                        .setKeys([wallet.getAccountKey()])
                        .setContents(SMART_CONTRACT_BYTECODE)
                        .setMaxTransactionFee(new Hbar(2))
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet);
            expect(fileResponse).to.be.instanceof(TransactionResponse);

            const fileReceipt = await fileResponse.getReceiptWithSigner(wallet);
            expect(fileReceipt).to.be.instanceof(TransactionReceipt);
            expect(fileReceipt.status).to.be.equal(Status.Success);
            const fileId = fileReceipt.fileId;
            expect(fileId).to.be.instanceof(FileId);

            const contractResponse = await (
                await (
                    await new ContractCreateTransaction()
                        .setAdminKey(operatorKey)
                        .setGas(200000)
                        .setConstructorParameters(
                            new ContractFunctionParameters()
                                .addString("Hello from Hedera.")
                                ._build(),
                        )
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .freezeWithSigner(wallet)
                ).signWithSigner(wallet)
            ).executeWithSigner(wallet);
            expect(contractResponse).to.be.instanceof(TransactionResponse);
            const contractReceipt =
                await contractResponse.getReceiptWithSigner(wallet);
            expect(contractReceipt).to.be.instanceof(TransactionReceipt);
            expect(contractReceipt.status).to.be.equal(Status.Success);
            const contractId = contractReceipt.contractId;
            expect(contractId).to.be.instanceof(ContractId);
            contractAddress = contractId.toSolidityAddress();
        } catch (error) {
            console.error(error);
        }

        const type = "02";
        const chainId = hex.decode("012a");
        const nonce = new Uint8Array();
        const maxPriorityGas = hex.decode("00");
        const maxGas = hex.decode("d1385c7bf0");
        const gasLimit = hex.decode("0249f0");
        const value = new Uint8Array();
        const to = hex.decode(contractAddress);
        const callData = new ContractFunctionParameters()
            .addString("new message")
            ._build("setMessage");
        const accessList = [];

        const encoded = rlp
            .encode([
                chainId,
                nonce,
                maxPriorityGas,
                maxGas,
                gasLimit,
                to,
                value,
                callData,
                accessList,
            ])
            .substring(2);
        expect(typeof encoded).to.equal("string");

        const privateKey = PrivateKey.generateECDSA();
        expect(privateKey).to.be.instanceof(PrivateKey);

        const accountAlias = privateKey.publicKey.toEvmAddress();

        const transfer = await new TransferTransaction()
            .addHbarTransfer(operatorId, new Hbar(10).negated())
            .addHbarTransfer(accountAlias, new Hbar(10))
            .setMaxTransactionFee(new Hbar(1))
            .freezeWithSigner(wallet);

        const transferResponse = await transfer.executeWithSigner(wallet);
        expect(transferResponse).to.be.instanceof(TransactionResponse);
        const transferReceipt =
            await transferResponse.getReceiptWithSigner(wallet);
        expect(transferReceipt).to.be.instanceof(TransactionReceipt);
        expect(transferReceipt.status).to.be.equal(Status.Success);

        const signedBytes = privateKey.sign(hex.decode(type + encoded));
        const middleOfSignedBytes = signedBytes.length / 2;
        const r = signedBytes.slice(0, middleOfSignedBytes);
        const s = signedBytes.slice(middleOfSignedBytes, signedBytes.length);
        const v = hex.decode("01"); // recovery id

        const data = rlp
            .encode([
                chainId,
                nonce,
                maxPriorityGas,
                maxGas,
                gasLimit,
                to,
                value,
                callData,
                accessList,
                v,
                r,
                s,
            ])
            .substring(2);
        expect(typeof data).to.equal("string");
        const ethereumData = hex.decode(type + data);
        expect(ethereumData.length).to.be.gt(0);

        const response = await (
            await (
                await new EthereumTransaction()
                    .setEthereumData(ethereumData)
                    .freezeWithSigner(wallet)
            ).signWithSigner(wallet)
        ).executeWithSigner(wallet);
        const record = await response.getRecordWithSigner(wallet);
        expect(record).to.be.instanceof(TransactionRecord);
        expect(response).to.be.instanceof(TransactionResponse);

        const receipt = await response.getReceiptWithSigner(wallet);
        expect(receipt).to.be.instanceof(TransactionReceipt);
        expect(receipt.status).to.be.equal(Status.Success);
    });
});
// Filename: test/integration/FileAppendIntegrationTest.js
import {
    AccountId,
    FileAppendTransaction,
    FileContentsQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Hbar,
    Status,
    Timestamp,
    TransactionId,
} from "../../src/exports.js";
import { bigContents } from "./contents.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("FileAppend", function () {
    let env;
    let newContentsLength;
    let newContents;
    let operatorKey;

    before(async function () {
        env = await IntegrationTestEnv.new();
        newContentsLength = 5000;
        newContents = generateUInt8Array(newContentsLength);
        operatorKey = env.operatorKey.publicKey;
    });

    it("should be executable", async function () {
        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;
        expect(info.keys.toArray().length).to.be.equal(1);

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileAppendTransaction()
                .setFileId(file)
                .setContents("[e2e::FileAppendTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(56);
        expect(info.isDeleted).to.be.false;
        expect(info.keys.toArray().length).to.be.equal(1);

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be chunk contents", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;
        expect(info.keys.toArray().length).to.be.equal(1);

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileAppendTransaction()
                .setFileId(file)
                .setContents(bigContents)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(13523);
        expect(info.isDeleted).to.be.false;
        expect(info.keys.toArray().length).to.be.equal(1);

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error with no file ID set", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let err = false;

        try {
            await (
                await new FileAppendTransaction()
                    .setContents("[e2e::FileAppendTransaction]")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidFileId);
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("file append transaction did not error");
        }
    });

    it("should not error with no contents appended", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        await (
            await new FileAppendTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should keep content after deserialization", async function () {
        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        expect(fileId).to.not.be.null;
        expect(fileId != null ? fileId.num > 0 : false).to.be.true;

        const tx = new FileAppendTransaction()
            .setFileId(fileId)
            .setContents(newContents);

        const txBytes = tx.toBytes();
        const txFromBytes = FileAppendTransaction.fromBytes(txBytes);

        await (await txFromBytes.execute(env.client)).getReceipt(env.client);

        const content = await new FileInfoQuery()
            .setFileId(fileId)
            .execute(env.client);

        expect(content.size.toInt()).to.be.equal(newContentsLength);
    });

    it("should be able to freeze after deserialize", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        expect(fileId).to.not.be.null;
        expect(fileId != null ? fileId.num > 0 : false).to.be.true;

        const tx = new FileAppendTransaction()
            .setFileId(fileId)
            .setContents(newContents);

        const txBytes = tx.toBytes();
        const txFromBytes = FileAppendTransaction.fromBytes(txBytes);

        txFromBytes.freezeWith(env.client);

        expect(txFromBytes.isFrozen()).to.be.true;
    });

    it("should be able to work with one chunk", async function () {
        const CHUNK_SIZE = 4096;
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        expect(fileId).to.not.be.null;
        expect(fileId != null ? fileId.num > 0 : false).to.be.true;

        const tx = await new FileAppendTransaction()
            .setFileId(fileId)
            .setContents(generateUInt8Array(CHUNK_SIZE))
            .setChunkSize(CHUNK_SIZE)
            .execute(env.client);

        const receipt = await tx.getReceipt(env.client);
        expect(receipt.status).to.be.equal(Status.Success);

        const fileInfo = await new FileContentsQuery()
            .setFileId(fileId)
            .execute(env.client);

        expect(fileInfo.length).to.be.equal(CHUNK_SIZE);
    });

    it("should be able to sign transaction with 1 chunk", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        const txBytes = new FileAppendTransaction()
            .setFileId(fileId)
            .setContents(Buffer.from("test"))
            .toBytes();

        const fromBytesTx = FileAppendTransaction.fromBytes(txBytes).freezeWith(
            env.client,
        );
        // should start empty before adding signature
        expect(fromBytesTx._signerPublicKeys).to.be.empty;

        // should have 1 signature after adding signature
        const signature = env.operatorKey.signTransaction(fromBytesTx);
        fromBytesTx.addSignature(env.operatorKey.publicKey, signature);
        expect(fromBytesTx._signerPublicKeys).to.have.length(1);

        const receipt = await (
            await fromBytesTx.execute(env.client)
        ).getReceipt(env.client);
        expect(receipt.status).to.be.equal(Status.Success);
    });

    it("should keep transaction id after non-frozen deserialization", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        const chunkInterval = 230;
        const validStart = Timestamp.fromDate(new Date());

        const tx = new FileAppendTransaction()
            .setTransactionId(
                TransactionId.withValidStart(env.operatorId, validStart),
            )
            .setFileId(fileId)
            .setChunkInterval(chunkInterval)
            .setChunkSize(1000)
            .setContents(newContents);

        const txBytes = tx.toBytes();
        const txFromBytes = FileAppendTransaction.fromBytes(txBytes);

        expect(
            txFromBytes.transactionId.accountId._toProtobuf(),
        ).to.be.deep.equal(env.operatorId?._toProtobuf());
        expect(txFromBytes.transactionId.validStart).to.be.deep.equal(
            validStart,
        );

        txFromBytes._transactionIds.list.forEach(
            (transactionId, index, array) => {
                if (index > 0) {
                    const previousTimestamp = array[index - 1].validStart;
                    const currentTimestamp = transactionId.validStart;
                    const difference =
                        currentTimestamp.nanos - previousTimestamp.nanos;
                    expect(difference).to.be.equal(chunkInterval);
                }
            },
        );

        txFromBytes.freezeWith(env.client);
        await txFromBytes.sign(env.operatorKey);

        const receipt = await (
            await txFromBytes.execute(env.client)
        ).getReceipt(env.client);
        expect(receipt.status).to.be.equal(Status.Success);
    });

    it("should keep chunk size, chunk interval and correct max chunks after deserialization", async function () {
        const operatorKey = env.operatorKey.publicKey;
        const chunkSize = 1024;
        const chunkInterval = 230;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        const tx = new FileAppendTransaction()
            .setFileId(fileId)
            .setChunkSize(chunkSize)
            .setChunkInterval(chunkInterval)
            .setMaxChunks(99999)
            .setContents(newContents);

        const txBytes = tx.toBytes();
        const txFromBytes = FileAppendTransaction.fromBytes(txBytes);

        expect(txFromBytes.chunkSize).to.be.equal(1024);
        expect(txFromBytes.maxChunks).to.be.equal(
            txFromBytes.getRequiredChunks(),
        );
        expect(txFromBytes.chunkInterval).to.be.equal(230);

        txFromBytes.freezeWith(env.client);
        await txFromBytes.sign(env.operatorKey);

        const receipt = await (
            await txFromBytes.execute(env.client)
        ).getReceipt(env.client);
        expect(receipt.status).to.be.equal(Status.Success);
    });

    it("should return transaction bytes when content is empty", async function () {
        const operatorKey = env.operatorKey.publicKey;
        const validStart = Timestamp.fromDate(new Date());

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents(Buffer.from(""))
            .execute(env.client);

        let { fileId } = await response.getReceipt(env.client);

        const transaction = new FileAppendTransaction()
            .setTransactionId(
                TransactionId.withValidStart(env.operatorId, validStart),
            )
            .setFileId(fileId);

        const transactionBytes = transaction.toBytes();

        const deserializedTransaction =
            FileAppendTransaction.fromBytes(transactionBytes);

        expect(transactionBytes.length).to.be.greaterThan(0);
        expect(transaction.transactionId).to.be.deep.equal(
            deserializedTransaction.transactionId,
        );
    });

    it("should serialize an incomplete transaction with node account ids set", async function () {
        const chunkSize = 1024;
        const chunkInterval = 230;
        const nodeAccountIds = [
            AccountId.fromString("0.0.3"),
            AccountId.fromString("0.0.4"),
        ];
        const tx = new FileAppendTransaction()
            .setNodeAccountIds(nodeAccountIds)
            .setChunkSize(chunkSize)
            .setChunkInterval(chunkInterval)
            .setMaxChunks(99999)
            .setContents(newContents);

        const txBytes = tx.toBytes();
        const txFromBytes = FileAppendTransaction.fromBytes(txBytes);

        expect(txFromBytes.nodeAccountIds).to.have.length(2);
        expect(txFromBytes.nodeAccountIds[0]).to.be.deep.equal(
            nodeAccountIds[0],
        );
        expect(txFromBytes.nodeAccountIds[1]).to.be.deep.equal(
            nodeAccountIds[1],
        );
        expect(txFromBytes.chunkSize).to.be.equal(1024);
        expect(txFromBytes.chunkInterval).to.be.equal(230);
        expect(txFromBytes.maxChunks).to.be.equal(
            txFromBytes.getRequiredChunks(),
        );
        expect(txFromBytes.contents).to.be.deep.equal(newContents);
    });

    after(async function () {
        await env.close();
    });
});

function generateUInt8Array(length) {
    const uint8Array = new Uint8Array(length);
    return uint8Array.fill(1);
}
// Filename: test/integration/FileContentsIntegrationTest.js
import {
    FileContentsQuery,
    FileCreateTransaction,
    FileDeleteTransaction,
    Hbar,
    Status,
} from "../../src/exports.js";
import * as utf8 from "../../src/encoding/utf8.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("FileContents", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        const contents = await new FileContentsQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(utf8.decode(contents)).to.be.equal(
            "[e2e::FileCreateTransaction]",
        );

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable with empty contents", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        const contents = await new FileContentsQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        expect(utf8.decode(contents)).to.be.equal("");

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when file ID is not set", async function () {
        let err = false;

        try {
            await new FileContentsQuery().execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidFileId);
        }

        if (!err) {
            throw new Error("file contents query did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/FileCreateIntegrationTest.js
import {
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Hbar,
    Status,
    Timestamp,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("FileCreate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable with empty contents", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable with no keys", async function () {
        let response = await new FileCreateTransaction().execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;
    });

    it("should error with too large expiration time", async function () {
        let status;
        const timestamp = new Timestamp(Date.now() / 1000 + 9999999999, 0);
        const operatorKey = env.operatorKey.publicKey;

        try {
            await (
                await new FileCreateTransaction()
                    .setKeys([operatorKey])
                    .setContents("[e2e::FileCreateTransaction]")
                    .setExpirationTime(timestamp)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.AutorenewDurationNotInRange);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/FileDeleteIntegrationTest.js
import {
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("FileDelete", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when file ID is not set", async function () {
        let err = false;

        try {
            await (
                await new FileDeleteTransaction().execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidFileId);
        }

        if (!err) {
            throw new Error("file deletion did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/FileInfoIntegrationTest.js
import {
    FileCreateTransaction,
    FileDeleteTransaction,
    FileInfoQuery,
    Hbar,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("FileInfo", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        const info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable with empty contents", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        const info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(0);
        expect(info.isDeleted).to.be.false;

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable with no keys", async function () {
        const response = await new FileCreateTransaction().execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        const info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(0);
        expect(info.isDeleted).to.be.false;
        expect(info.keys.toArray().length).to.be.equal(0);
    });

    it("should be able to query cost", async function () {
        const operatorKey = env.operatorKey.publicKey;

        const response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);
        let file = receipt.fileId;

        const cost = await new FileInfoQuery()
            .setFileId(file)
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/FileUpdateIntegrationTest.js
import {
    FileCreateTransaction,
    FileDeleteTransaction,
    FileUpdateTransaction,
    FileInfoQuery,
    Hbar,
    Status,
    AccountId,
    PrivateKey,
} from "../../src/exports.js";
import IntegrationTestEnv, { Client } from "./client/NodeIntegrationTestEnv.js";

describe("FileUpdate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let response = await new FileCreateTransaction()
            .setKeys([operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let receipt = await response.getReceipt(env.client);

        expect(receipt.fileId).to.not.be.null;
        expect(receipt.fileId != null ? receipt.fileId.num > 0 : false).to.be
            .true;

        const file = receipt.fileId;

        let info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileUpdateTransaction()
                .setFileId(file)
                .setContents("[e2e::FileUpdateTransaction]")
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new FileInfoQuery()
            .setFileId(file)
            .setQueryPayment(new Hbar(22))
            .execute(env.client);

        expect(info.fileId.toString()).to.be.equal(file.toString());
        expect(info.size.toInt()).to.be.equal(28);
        expect(info.isDeleted).to.be.false;

        // There should only be one key
        for (const key of info.keys) {
            expect(key.toString()).to.be.equal(operatorKey.toString());
        }

        await (
            await new FileDeleteTransaction()
                .setFileId(file)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when file ID is not set", async function () {
        let err = false;

        try {
            await (
                await new FileUpdateTransaction()
                    .setContents("[e2e::FileUpdateTransaction]")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidFileId);
        }

        if (!err) {
            throw new Error("file update did not error");
        }
    });

    it("should not error when FEE_SCHEDULE_FILE_PART_UPLOADED response", async function () {
        const OPERATOR_ID = AccountId.fromString("0.0.2");
        const OPERATOR_KEY = PrivateKey.fromStringED25519(
            "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137",
        );
        const FEES_FILE_ID = "0.0.111";
        const DUMMY_TEXT = "Hello, Hedera!";

        const client = Client.forLocalNode().setOperator(
            OPERATOR_ID,
            OPERATOR_KEY,
        );

        await (
            await new FileUpdateTransaction()
                .setFileId(FEES_FILE_ID)
                .setContents(DUMMY_TEXT)
                .execute(client)
        ).getReceipt(client);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/FreezeTransactionIntegrationTest.js
import {
    Timestamp,
    FreezeTransaction,
    FreezeType,
    // TransactionResponse,
    // TransactionReceipt,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("FreezeTransaction", function () {
    let client;

    before(async function () {
        const env = await IntegrationTestEnv.new();
        client = env.client;
    });

    it("should be executable but not supported", async function () {
        const seconds = Math.round(Date.now() / 1000);
        const validStart = new Timestamp(seconds, 0);

        const transaction = new FreezeTransaction()
            .setStartTimestamp(validStart)
            .setFreezeType(new FreezeType(1))
            .freezeWith(client);
        expect(transaction.startTimestamp).to.be.equal(validStart);
        expect(transaction.freezeType).to.be.instanceof(FreezeType);

        try {
            await transaction.execute(client);
        } catch (error) {
            expect(error.status).to.be.equal(Status.NotSupported);
        }

        client.close();
    });
});
// Filename: test/integration/GetCostIntegrationTest.js
import {
    AccountBalanceQuery,
    AccountInfoQuery,
    Hbar,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("GetCost", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;

        const cost = await new AccountInfoQuery()
            .setAccountId(operatorId)
            .getCost(env.client);

        await new AccountInfoQuery()
            .setAccountId(operatorId)
            .setQueryPayment(cost)
            .execute(env.client);
    });

    it("should be executable when max query payment is large", async function () {
        const operatorId = env.operatorId;

        env.client.setMaxQueryPayment(new Hbar(100));

        const cost = await new AccountInfoQuery()
            .setAccountId(operatorId)
            .getCost(env.client);

        await new AccountInfoQuery()
            .setAccountId(operatorId)
            .setQueryPayment(cost)
            .execute(env.client);
    });

    it("should be executable when max query payment is small", async function () {
        const operatorId = env.operatorId;

        env.client.setMaxQueryPayment(new Hbar(1));

        const cost = await new AccountInfoQuery()
            .setAccountId(operatorId)
            .getCost(env.client);

        await new AccountInfoQuery()
            .setAccountId(operatorId)
            .setQueryPayment(cost)
            .execute(env.client);
    });

    it("should be executable when free queries have set zero cost", async function () {
        const operatorId = env.operatorId;

        await new AccountInfoQuery()
            .setAccountId(operatorId)
            .setQueryPayment(new Hbar(1))
            .execute(env.client);

        await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .setQueryPayment(new Hbar(0))
            .execute(env.client);
    });

    it("should be executable when paid queries have set large cost", async function () {
        const operatorId = env.operatorId;

        await new AccountInfoQuery()
            .setAccountId(operatorId)
            .setQueryPayment(new Hbar(10))
            .execute(env.client);

        await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .setQueryPayment(new Hbar(0))
            .execute(env.client);
    });

    it("should error when paid query are set to zero", async function () {
        const operatorId = env.operatorId;

        let err = false;
        try {
            await new AccountInfoQuery()
                .setAccountId(operatorId)
                .setQueryPayment(new Hbar(0))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InsufficientTxFee);
        }

        if (!err) {
            throw new Error("GetCost did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/LiveHashIntegrationTest.js
import {
    Hbar,
    LiveHashAddTransaction,
    LiveHashDeleteTransaction,
    LiveHashQuery,
    PrivateKey,
    TransactionId,
} from "../../src/exports.js";
import * as hex from "../../src/encoding/hex.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, deleteAccount } from "./utils/Fixtures.js";
import Long from "long";

describe("LiveHash", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const _hash = hex.decode(
            "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002",
        );

        const operatorId = env.operatorId;
        let errorThrown = false;

        const key = PrivateKey.generateED25519();
        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction.setKeyWithoutAlias(key).setInitialBalance(new Hbar(2));
        });

        expect(accountId).to.not.be.null;

        try {
            await new LiveHashAddTransaction()
                .setAccountId(accountId)
                .setDuration(Long.fromInt(30))
                .setHash(_hash)
                .setKeys(key)
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
        errorThrown = false;

        try {
            await new LiveHashDeleteTransaction()
                .setAccountId(accountId)
                .setHash(_hash)
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
        errorThrown = false;

        try {
            await new LiveHashQuery()
                .setAccountId(accountId)
                .setHash(_hash)
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;

        await deleteAccount(env.client, key, (transaction) => {
            transaction
                .setAccountId(accountId)
                .setTransferAccountId(operatorId)
                .setTransactionId(TransactionId.generate(accountId));
        });
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/LocalWalletTest.js
import { Wallet, LocalProvider } from "../../src/index.js";

describe("LocalWallet", function () {
    it("can fetch wallet's info", async function () {
        const wallet = new Wallet(
            process.env.OPERATOR_ID,
            process.env.OPERATOR_KEY,
            new LocalProvider(),
        );

        const info = await wallet.getAccountInfo();

        expect(info.accountId.compare(wallet.getAccountId())).to.be.equal(0);
    });
});
// Filename: test/integration/MirrorNodeContractEstimateQuery.js
import { setTimeout } from "timers/promises";
import {
    MirrorNodeContractCallQuery,
    ContractCreateTransaction,
    FileCreateTransaction,
    ContractFunctionParameters,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("MirrorNodeContractCallQuery", function () {
    let env;

    beforeEach(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should get contract message", async function () {
        const BYTECODE =
            "60806040526040518060400160405280600581526020017f68656c6c6f0000000000000000000000000000000000000000000000000000008152505f90816100479190610293565b50348015610053575f80fd5b50610362565b5f81519050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806100d457607f821691505b6020821081036100e7576100e6610090565b5b50919050565b5f819050815f5260205f209050919050565b5f6020601f8301049050919050565b5f82821b905092915050565b5f600883026101497fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8261010e565b610153868361010e565b95508019841693508086168417925050509392505050565b5f819050919050565b5f819050919050565b5f61019761019261018d8461016b565b610174565b61016b565b9050919050565b5f819050919050565b6101b08361017d565b6101c46101bc8261019e565b84845461011a565b825550505050565b5f90565b6101d86101cc565b6101e38184846101a7565b505050565b5b81811015610206576101fb5f826101d0565b6001810190506101e9565b5050565b601f82111561024b5761021c816100ed565b610225846100ff565b81016020851015610234578190505b610248610240856100ff565b8301826101e8565b50505b505050565b5f82821c905092915050565b5f61026b5f1984600802610250565b1980831691505092915050565b5f610283838361025c565b9150826002028217905092915050565b61029c82610059565b67ffffffffffffffff8111156102b5576102b4610063565b5b6102bf82546100bd565b6102ca82828561020a565b5f60209050601f8311600181146102fb575f84156102e9578287015190505b6102f38582610278565b86555061035a565b601f198416610309866100ed565b5f5b828110156103305784890151825560018201915060208501945060208101905061030b565b8683101561034d5784890151610349601f89168261025c565b8355505b6001600288020188555050505b505050505050565b6102178061036f5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063ce6d41de1461002d575b5f80fd5b61003561004b565b6040516100429190610164565b60405180910390f35b60605f8054610059906101b1565b80601f0160208091040260200160405190810160405280929190818152602001828054610085906101b1565b80156100d05780601f106100a7576101008083540402835291602001916100d0565b820191905f5260205f20905b8154815290600101906020018083116100b357829003601f168201915b5050505050905090565b5f81519050919050565b5f82825260208201905092915050565b5f5b838110156101115780820151818401526020810190506100f6565b5f8484015250505050565b5f601f19601f8301169050919050565b5f610136826100da565b61014081856100e4565b93506101508185602086016100f4565b6101598161011c565b840191505092915050565b5f6020820190508181035f83015261017c818461012c565b905092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b5f60028204905060018216806101c857607f821691505b6020821081036101db576101da610184565b5b5091905056fea26469706673582212202a86c27939bfab6d4a2c61ebbf096d8424e17e22dfdd42320f6e2654863581e964736f6c634300081a0033";
        const { fileId } = await (
            await new FileCreateTransaction()
                .setContents(BYTECODE)
                .execute(env.client)
        ).getReceipt(env.client);

        const { contractId } = await (
            await new ContractCreateTransaction()
                .setBytecodeFileId(fileId)
                .setGas(200000)
                .execute(env.client)
        ).getReceipt(env.client);

        // wait 5 seconds for MN to update
        await setTimeout(10000);

        const result = await new MirrorNodeContractCallQuery()
            .setContractId(contractId)
            .setBlockNumber("latest")
            .setFunction("getMessage", new ContractFunctionParameters())
            .execute(env.client);
        expect(result).to.not.be.null;
    });
});
// Filename: test/integration/MirrorNodeContractQuery.js
import { setTimeout } from "timers/promises";
import {
    MirrorNodeContractCallQuery,
    ContractCreateTransaction,
    FileCreateTransaction,
    ContractFunctionParameters,
    MirrorNodeContractEstimateQuery,
    ContractId,
    Hbar,
    ContractExecuteTransaction,
    ContractCallQuery,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount } from "./utils/Fixtures.js";

describe("MirrorNodeContractQuery", function () {
    let env, contractId;
    const ADDRESS = "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4";

    beforeEach(async function () {
        env = await IntegrationTestEnv.new();

        const BYTECODE =
            "6080604052348015600e575f80fd5b50335f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506104a38061005b5f395ff3fe608060405260043610610033575f3560e01c8063607a4427146100375780637065cb4814610053578063893d20e81461007b575b5f80fd5b610051600480360381019061004c919061033c565b6100a5565b005b34801561005e575f80fd5b50610079600480360381019061007491906103a2565b610215565b005b348015610086575f80fd5b5061008f6102b7565b60405161009c91906103dc565b60405180910390f35b3373ffffffffffffffffffffffffffffffffffffffff165f8054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146100fb575f80fd5b805f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600181908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505f8173ffffffffffffffffffffffffffffffffffffffff166108fc3490811502906040515f60405180830381858888f19350505050905080610211576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102089061044f565b60405180910390fd5b5050565b805f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550600181908060018154018082558091505060019003905f5260205f20015f9091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b5f805f9054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61030b826102e2565b9050919050565b61031b81610301565b8114610325575f80fd5b50565b5f8135905061033681610312565b92915050565b5f60208284031215610351576103506102de565b5b5f61035e84828501610328565b91505092915050565b5f610371826102e2565b9050919050565b61038181610367565b811461038b575f80fd5b50565b5f8135905061039c81610378565b92915050565b5f602082840312156103b7576103b66102de565b5b5f6103c48482850161038e565b91505092915050565b6103d681610367565b82525050565b5f6020820190506103ef5f8301846103cd565b92915050565b5f82825260208201905092915050565b7f5472616e73666572206661696c656400000000000000000000000000000000005f82015250565b5f610439600f836103f5565b915061044482610405565b602082019050919050565b5f6020820190508181035f8301526104668161042d565b905091905056fea26469706673582212206c46ddb2acdbcc4290e15be83eb90cd0b2ce5bd82b9bfe58a0709c5aec96305564736f6c634300081a0033";
        const { fileId } = await (
            await new FileCreateTransaction()
                .setContents(BYTECODE)
                .execute(env.client)
        ).getReceipt(env.client);

        contractId = (
            await (
                await new ContractCreateTransaction()
                    .setBytecodeFileId(fileId)
                    .setGas(200000)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).contractId;

        await setTimeout(5000);
    });

    it("should get contract owner", async function () {
        const gas = await new MirrorNodeContractEstimateQuery()
            .setContractId(contractId)
            .setFunction("getOwner")
            .execute(env.client);

        expect(gas).to.be.gt(0);

        const result = await new MirrorNodeContractCallQuery()
            .setContractId(contractId)
            .setBlockNumber("latest")
            .setFunction("getOwner")
            .setGasLimit(gas)
            .execute(env.client);
        expect(result).to.not.be.null;
        const ownerMirrorNode = result.substring(26);

        const resultNode = await new ContractCallQuery()
            .setContractId(contractId)
            .setGas(gas)
            .setFunction("getOwner")
            .execute(env.client);
        const ownerConsensusNode = resultNode.getAddress(0);

        expect(ownerMirrorNode).to.equal(ownerConsensusNode);
    });

    it("should return default gas when contract is not deployed", async function () {
        const NON_EXISTING_CONTRACT = new ContractId(12341234);
        const DEFAULT_GAS = 22892;

        const gasUsed = await new MirrorNodeContractEstimateQuery()
            .setContractId(NON_EXISTING_CONTRACT)
            .setFunction("getOwner")
            .execute(env.client);

        expect(gasUsed).to.equal(DEFAULT_GAS);
    });

    it("should fail when gas limit is too low", async function () {
        const LOW_GAS = 100;
        let err = false;
        try {
            await new MirrorNodeContractCallQuery()
                .setContractId(contractId)
                .setGasLimit(LOW_GAS)
                .setFunction("getOwner")
                .execute(env.client);
        } catch (e) {
            err = true;
        }
        expect(err).to.be.true;
    });

    it("should fail when sender is not sent", async function () {
        const LOW_GAS = 100;
        let err = false;

        try {
            await new MirrorNodeContractEstimateQuery()
                .setContractId(contractId)
                .setFunction(
                    "addOwnerAndTransfer",
                    new ContractFunctionParameters().addAddress(ADDRESS),
                )
                .execute(env.client);
        } catch (e) {
            err = true;
        }
        expect(err).to.be.true;
        err = false;

        try {
            await new MirrorNodeContractCallQuery()
                .setGasLimit(LOW_GAS)
                .setContractId(contractId)
                .setFunction(
                    "addOwnerAndTransfer",
                    new ContractFunctionParameters().addAddress(ADDRESS),
                )
                .execute(env.client);
        } catch (e) {
            err = true;
        }
        expect(err).to.be.true;
    });

    it("should simulate when sender is set", async function () {
        const owner = (
            await new MirrorNodeContractCallQuery()
                .setContractId(contractId)
                .setFunction("getOwner")
                .execute(env.client)
        ).substring(26);

        const { accountId } = await createAccount(env.client, (transaction) => {
            transaction.setInitialBalance(new Hbar(10));
        });

        const newOwnerSolidityAddress = accountId.toSolidityAddress();

        await setTimeout(3000);

        const gas = await new MirrorNodeContractEstimateQuery()
            .setContractId(contractId)
            .setFunction(
                "addOwnerAndTransfer",
                new ContractFunctionParameters().addAddress(
                    newOwnerSolidityAddress,
                ),
            )
            .setSenderEvmAddress(owner)
            .execute(env.client);

        await new ContractExecuteTransaction()
            .setContractId(contractId)
            .setFunction(
                "addOwnerAndTransfer",
                new ContractFunctionParameters().addAddress(
                    newOwnerSolidityAddress,
                ),
            )
            .setGas(gas)
            .setPayableAmount(new Hbar(1))
            .execute(env.client);
    });
});
// Filename: test/integration/NetworkVersionInfoIntegrationTest.js
import { NetworkVersionInfoQuery } from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("NetworkVersionInfo", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        try {
            await new NetworkVersionInfoQuery().execute(env.client);
        } catch {
            // Do nothing
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/NftAllowancesIntegrationTest.js
import {
    AccountAllowanceApproveTransaction,
    AccountAllowanceDeleteTransaction,
    Hbar,
    NftId,
    Status,
    TransactionId,
    TokenAssociateTransaction,
    TokenMintTransaction,
    TokenNftInfoQuery,
    TokenType,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, createNonFungibleToken } from "./utils/Fixtures.js";

describe("TokenNftAllowances", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("Cannot transfer on behalf of `spender` account without allowance approval", async function () {
        let status;

        const { accountId: spenderAccountId, newKey: spenderKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        const { accountId: receiverAccountId } = await createAccount(
            env.client,
            (transaction) => transaction.setInitialBalance(new Hbar(2)),
        );

        const nftTokenId = await createNonFungibleToken(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(spenderAccountId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(nftTokenId)
                    .addMetadata(Uint8Array.of(0x01))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const nft1 = new NftId(nftTokenId, serials[0]);

        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);
        try {
            await (
                await (
                    await new TransferTransaction()
                        .addApprovedNftTransfer(
                            nft1,
                            env.operatorId,
                            receiverAccountId,
                        )
                        .setTransactionId(onBehalfOfTransactionId)
                        .freezeWith(env.client)
                        .sign(spenderKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.TokenNotAssociatedToAccount);
    });

    it("Cannot transfer on behalf of `spender` account after removing the allowance approval", async function () {
        // Use createAccount fixture
        const { accountId: spenderAccountId, newKey: spenderKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        const { accountId: receiverAccountId, newKey: receiverKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        // Use createNonFungibleToken fixture
        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false),
        );

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(spenderAccountId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(receiverAccountId)
                    .freezeWith(env.client)
                    .sign(receiverKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(nftTokenId)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const nft1 = new NftId(nftTokenId, serials[0]);
        const nft2 = new NftId(nftTokenId, serials[1]);

        await new AccountAllowanceApproveTransaction()
            .approveTokenNftAllowance(nft1, env.operatorId, spenderAccountId)
            .approveTokenNftAllowance(nft2, env.operatorId, spenderAccountId)
            .execute(env.client);

        await (
            await new AccountAllowanceDeleteTransaction()
                .deleteAllTokenNftAllowances(nft2, env.operatorId)
                .execute(env.client)
        ).getReceipt(env.client);

        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);
        await (
            await (
                await new TransferTransaction()
                    .addApprovedNftTransfer(
                        nft1,
                        env.operatorId,
                        receiverAccountId,
                    )
                    .setTransactionId(onBehalfOfTransactionId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const info = await new TokenNftInfoQuery()
            .setNftId(nft1)
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(
            receiverAccountId.toString(),
        );

        let err = false;
        const onBehalfOfTransactionId2 =
            TransactionId.generate(spenderAccountId);
        try {
            await (
                await (
                    await new TransferTransaction()
                        .addApprovedNftTransfer(
                            nft2,
                            env.operatorId,
                            receiverAccountId,
                        )
                        .setTransactionId(onBehalfOfTransactionId2)
                        .freezeWith(env.client)
                        .sign(spenderKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.SpenderDoesNotHaveAllowance);
        }

        expect(err).to.be.true;
    });

    it("Cannot remove single serial number allowance when the allowance is given for all serials at once", async function () {
        // Use createAccount fixture
        const { accountId: spenderAccountId, newKey: spenderKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        const { accountId: receiverAccountId, newKey: receiverKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        // Use createNonFungibleToken fixture
        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false),
        );

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(spenderAccountId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(receiverAccountId)
                    .freezeWith(env.client)
                    .sign(receiverKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(nftTokenId)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const nft1 = new NftId(nftTokenId, serials[0]);
        const nft2 = new NftId(nftTokenId, serials[1]);

        await new AccountAllowanceApproveTransaction()
            .approveTokenNftAllowanceAllSerials(
                nftTokenId,
                env.operatorId,
                spenderAccountId,
            )
            .execute(env.client);

        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);
        await (
            await (
                await new TransferTransaction()
                    .addApprovedNftTransfer(
                        nft1,
                        env.operatorId,
                        receiverAccountId,
                    )
                    .setTransactionId(onBehalfOfTransactionId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        // hopefully in the future this should end up with a precheck error provided from services
        await (
            await new AccountAllowanceDeleteTransaction()
                .deleteAllTokenNftAllowances(nft2, env.operatorId)
                .execute(env.client)
        ).getReceipt(env.client);

        const onBehalfOfTransactionId2 =
            TransactionId.generate(spenderAccountId);
        await (
            await (
                await new TransferTransaction()
                    .addApprovedNftTransfer(
                        nft2,
                        env.operatorId,
                        receiverAccountId,
                    )
                    .setTransactionId(onBehalfOfTransactionId2)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const infoNft1 = await new TokenNftInfoQuery()
            .setNftId(nft1)
            .execute(env.client);

        const infoNft2 = await new TokenNftInfoQuery()
            .setNftId(nft2)
            .execute(env.client);

        expect(infoNft1[0].accountId.toString()).to.be.equal(
            receiverAccountId.toString(),
        );

        expect(infoNft2[0].accountId.toString()).to.be.equal(
            receiverAccountId.toString(),
        );
    });

    it("Account, which given the allowance for all serials at once, should be able to give allowances for single serial numbers to other accounts", async function () {
        const {
            accountId: delegatingSpenderAccountId,
            newKey: delegatingSpenderKey,
        } = await createAccount(env.client, (transaction) =>
            transaction.setInitialBalance(new Hbar(2)),
        );

        const { accountId: spenderAccountId, newKey: spenderKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        const { accountId: receiverAccountId, newKey: receiverKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(new Hbar(2)),
            );

        // Use createNonFungibleToken fixture
        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false),
        );

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(delegatingSpenderAccountId)
                    .freezeWith(env.client)
                    .sign(delegatingSpenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([nftTokenId])
                    .setAccountId(receiverAccountId)
                    .freezeWith(env.client)
                    .sign(receiverKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(nftTokenId)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const nft1 = new NftId(nftTokenId, serials[0]);
        const nft2 = new NftId(nftTokenId, serials[1]);

        await (
            await new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowanceAllSerials(
                    nftTokenId,
                    env.operatorId,
                    delegatingSpenderAccountId,
                )
                .execute(env.client)
        ).getReceipt(env.client);

        env.client.setOperator(
            delegatingSpenderAccountId,
            delegatingSpenderKey,
        );

        await (
            await new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowanceWithDelegatingSpender(
                    nft1,
                    env.operatorId,
                    spenderAccountId,
                    delegatingSpenderAccountId,
                )
                .freezeWith(env.client)
                .execute(env.client)
        ).getReceipt(env.client);

        env.client.setOperator(env.operatorId, env.operatorKey);

        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);
        await (
            await (
                await new TransferTransaction()
                    .addApprovedNftTransfer(
                        nft1,
                        env.operatorId,
                        receiverAccountId,
                    )
                    .setTransactionId(onBehalfOfTransactionId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;
        const onBehalfOfTransactionId2 =
            TransactionId.generate(spenderAccountId);
        try {
            await (
                await (
                    await new TransferTransaction()
                        .addApprovedNftTransfer(
                            nft2,
                            env.operatorId,
                            receiverAccountId,
                        )
                        .setTransactionId(onBehalfOfTransactionId2)
                        .freezeWith(env.client)
                        .sign(spenderKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.SpenderDoesNotHaveAllowance);
        }

        expect(err).to.be.true;

        const infoNft1 = await new TokenNftInfoQuery()
            .setNftId(nft1)
            .execute(env.client);

        const infoNft2 = await new TokenNftInfoQuery()
            .setNftId(nft2)
            .execute(env.client);

        expect(infoNft1[0].accountId.toString()).to.be.equal(
            receiverAccountId.toString(),
        );
        expect(infoNft2[0].accountId.toString()).to.be.equal(
            env.operatorId.toString(),
        );
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/PrivateKey.js
import {
    PrivateKey,
    Hbar,
    AccountId,
    KeyList,
    Status,
    FileAppendTransaction,
    FileCreateTransaction,
    TransactionId,
    Mnemonic,
    AccountUpdateTransaction,
} from "../../src/exports.js";
import dotenv from "dotenv";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount } from "./utils/Fixtures.js";
import SignatureMap from "../../src/transaction/SignatureMap.js";

import { proto } from "@hashgraph/proto";
import { expect } from "chai";

dotenv.config();

describe("PrivateKey signTransaction", function () {
    let env, user1Key, user2Key, keyList;

    // Setting up the environment and creating a new account with a key list
    before(async function () {
        env = await IntegrationTestEnv.new();

        user1Key = PrivateKey.generate();
        user2Key = PrivateKey.generate();
        keyList = new KeyList([user1Key.publicKey, user2Key.publicKey]);

        // Create account
        const { accountId } = await createAccount(env.client, (transaction) => {
            return transaction
                .setInitialBalance(new Hbar(2))
                .setKeyWithoutAlias(keyList);
        });

        expect(accountId).to.exist;
    });

    it("should be able to sign tx with priv key that is <32 bytes from mnemonic", async function () {
        const MNEMONIC_SHORT_PRIVATE_KEY_STRING =
            "marriage bounce fiscal express wink wire trick allow faith mandate base bone";
        const mnemonic = await Mnemonic.fromString(
            MNEMONIC_SHORT_PRIVATE_KEY_STRING,
        );
        const privateKey = await mnemonic.toStandardECDSAsecp256k1PrivateKey();

        const { accountId } = await createAccount(env.client, (transaction) => {
            return transaction
                .setInitialBalance(new Hbar(2))
                .setKeyWithoutAlias(privateKey);
        });

        const { status } = await (
            await (
                await new AccountUpdateTransaction()
                    .setAccountId(accountId)
                    .setAccountMemo("test")
                    .freezeWith(env.client)
                    .sign(privateKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        expect(status).to.be.equal(Status.Success);
    });

    // this skip is temporary before we add SOLO for the CI tests
    // as currently its unable to run the test with multiple nodes
    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("File Append Transaction Execution with Multiple Nodes", async function () {
        // Create file
        let response = await new FileCreateTransaction()
            .setKeys([env.operatorKey])
            .setContents("[e2e::FileCreateTransaction]")
            .execute(env.client);

        let createTxReceipt = await response.getReceipt(env.client);
        const file = createTxReceipt.fileId;

        // Append content to the file
        const fileAppendTx = new FileAppendTransaction()
            .setFileId(file)
            .setContents("test")
            .setChunkSize(1)
            .setNodeAccountIds([
                new AccountId(3),
                new AccountId(4),
                new AccountId(5),
            ])
            .freezeWith(env.client);

        const sigMap = new SignatureMap();
        fileAppendTx._signedTransactions.list.forEach((signedTx) => {
            const sig = env.operatorKey.sign(signedTx.bodyBytes);
            const decodedTx = proto.TransactionBody.decode(signedTx.bodyBytes);
            const nodeId = AccountId._fromProtobuf(decodedTx.nodeAccountID);
            const transactionId = TransactionId._fromProtobuf(
                decodedTx.transactionID,
            );

            sigMap.addSignature(
                nodeId,
                transactionId,
                env.operatorKey.publicKey,
                sig,
            );
        });

        //console.log(sigMap);

        fileAppendTx.addSignature(env.operatorKey.publicKey, sigMap);

        // Execute the signed transaction
        const receipt = await (
            await fileAppendTx.execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.status).to.be.equal(Status.Success);
    });
});
// Filename: test/integration/QueryIntegrationTest.js
import { expect } from "chai";

import { AccountId, AccountInfoQuery } from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("Transaction flows", function () {
    let env, client;

    // Setting up the environment and creating a new account with a key list
    before(async function () {
        env = await IntegrationTestEnv.new();
        client = env.client;
    });

    it("Execute Query with invalid accountId within an array with valid one", async function () {
        const signTransferTransaction = new AccountInfoQuery()
            .setAccountId("0.0.3")
            .setNodeAccountIds([
                // invalid node account id
                new AccountId(111),
                // valid node account id
                new AccountId(3),
            ]);

        await signTransferTransaction.execute(client);
    });

    it("Execute Query with only invalid accountId ", async function () {
        const signTransferTransaction = new AccountInfoQuery()
            .setAccountId("0.0.3")
            .setNodeAccountIds([
                // invalid node account id
                new AccountId(111),
            ]);

        try {
            await signTransferTransaction.execute(client);
        } catch (error) {
            // Attempting to execute the transaction with a node that is not in the client's node list
            expect(error.message).to.be.equal(
                "Attempting to execute a transaction against node 0.0.111, which is not included in the Client's node list. Please review your Client configuration.",
            );
        }
    });
});
// Filename: test/integration/ScheduleCreateIntegrationTest.js
import { setTimeout } from "timers/promises";
import {
    Hbar,
    KeyList,
    PrivateKey,
    ScheduleInfoQuery,
    ScheduleSignTransaction,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
    AccountBalanceQuery,
    ScheduleCreateTransaction,
    TransferTransaction,
    Timestamp,
    AccountUpdateTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount } from "./utils/Fixtures.js";

describe("ScheduleCreate", function () {
    let env;

    const ONE_DAY_IN_NANOS = 60 * 60 * 24 * 1_000_000_000;
    const ONE_YEAR_IN_NANOS = ONE_DAY_IN_NANOS * 365;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;
        const operatorId = env.operatorId;

        const key1 = PrivateKey.generateED25519();

        // Submit Key
        const key2 = PrivateKey.generateED25519();

        const key3 = PrivateKey.generateED25519();

        const keyList = KeyList.of(
            key1.publicKey,
            key2.publicKey,
            key3.publicKey,
        );

        const { accountId } = await createAccount(env.client, (transaction) =>
            transaction
                .setInitialBalance(new Hbar(50))
                .setKeyWithoutAlias(keyList),
        );

        expect(accountId).to.be.not.null;

        const topicId = (
            await (
                await new TopicCreateTransaction()
                    .setAdminKey(operatorKey)
                    .setAutoRenewAccountId(operatorId)
                    .setTopicMemo("HCS Topic_")
                    .setSubmitKey(key2)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).topicId;

        const transaction = new TopicMessageSubmitTransaction()
            .setTopicId(topicId)
            .setMessage("scheduled hcs message");

        const scheduled = transaction
            .schedule()
            .setPayerAccountId(operatorId)
            .setAdminKey(operatorKey)
            .freezeWith(env.client);

        const scheduleId = (
            await (await scheduled.execute(env.client)).getReceipt(env.client)
        ).scheduleId;

        const info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        const infoTransaction = /** @type {TopicMessageSubmitTransaction} */ (
            info.scheduledTransaction
        );

        // TODO: Remove when `ScheduleInfo.scheduledTransaction` works without serializing to bytes
        transaction.topicId._checksum = null;

        expect(info.scheduleId.toString()).to.be.equal(scheduleId.toString());
        expect(infoTransaction.topicId.toString()).to.be.equal(
            transaction.topicId.toString(),
        );
        expect(infoTransaction.message.length).to.be.equal(
            transaction.message.length,
        );
        expect(infoTransaction.nodeAccountIds).to.be.null;

        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(key2)
            ).execute(env.client)
        ).getReceipt(env.client);

        await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);
    });

    it("should be able to query cost", async function () {
        const operatorKey = env.operatorKey.publicKey;
        const operatorId = env.operatorId;

        const key1 = PrivateKey.generateED25519();

        // Submit Key
        const key2 = PrivateKey.generateED25519();

        const key3 = PrivateKey.generateED25519();

        const keyList = KeyList.of(
            key1.publicKey,
            key2.publicKey,
            key3.publicKey,
        );

        const { accountId } = await createAccount(env.client, (transaction) =>
            transaction
                .setInitialBalance(new Hbar(10))
                .setKeyWithoutAlias(keyList),
        );

        expect(accountId).to.be.not.null;

        const topicId = (
            await (
                await new TopicCreateTransaction()
                    .setAdminKey(operatorKey)
                    .setAutoRenewAccountId(operatorId)
                    .setTopicMemo("HCS Topic_")
                    .setSubmitKey(key2)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).topicId;

        const transaction = new TopicMessageSubmitTransaction()
            .setTopicId(topicId)
            .setMessage("scheduled hcs message");

        const scheduled = transaction
            .schedule()
            .setPayerAccountId(operatorId)
            .setAdminKey(operatorKey)
            .freezeWith(env.client);

        const scheduleId = (
            await (await scheduled.execute(env.client)).getReceipt(env.client)
        ).scheduleId;

        const cost = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    it("should be able to encode/decode scheduled transaction", async function () {
        const tx = new TransferTransaction()
            .addHbarTransfer(env.operatorId, Hbar.fromTinybars(1))
            .addHbarTransfer("0.0.1023", Hbar.fromTinybars(1).negated());

        const scheduledTx = new ScheduleCreateTransaction()
            .setScheduledTransaction(tx)
            .freezeWith(env.client);

        const sch = scheduledTx._getScheduledTransactionBody();
        expect(sch.scheduleCreate.scheduledTransactionBody).not.to.be.null;

        const bytes = scheduledTx.toBytes();
        const tx2 = ScheduleCreateTransaction.fromBytes(bytes);

        const sch2 = tx2._getScheduledTransactionBody();
        expect(sch2.scheduleCreate.scheduledTransactionBody).not.to.be.null;
    });

    it("should not schedule 1 year into the future", async function () {
        const operatorId = env.operatorId;

        const { accountId: receiverId } = await createAccount(env.client);
        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, Hbar.from("-1"))
            .addHbarTransfer(receiverId, Hbar.from("1"));

        let err = false;

        try {
            await (
                await transaction
                    .schedule()
                    .setExpirationTime(
                        Timestamp.generate().plusNanos(ONE_YEAR_IN_NANOS),
                    )
                    .setScheduleMemo("HIP-423 Integration Test")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes(
                "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE",
            );
        }
        expect(err).to.be.true;
    });

    it("should not schedule in the past", async function () {
        const operatorId = env.operatorId;

        const { accountId: receiverId } = await createAccount(env.client);
        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, Hbar.from("-1"))
            .addHbarTransfer(receiverId, Hbar.from("1"));

        let err = false;

        try {
            await (
                await transaction
                    .schedule()
                    .setExpirationTime(Timestamp.generate().plusNanos(-1))
                    .setScheduleMemo("HIP-423 Integration Test")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes(
                "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME",
            );
        }
        expect(err).to.be.true;
    });

    it("should sign schedule and wait for expiry", async function () {
        const operatorId = env.operatorId;

        const { accountId: receiverId, newKey: privateKey } =
            await createAccount(env.client, (transaction) =>
                transaction.setInitialBalance(Hbar.from(1)),
            );

        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, Hbar.from("1"))
            .addHbarTransfer(receiverId, Hbar.from("-1"));

        const { scheduleId } = await (
            await transaction
                .schedule()
                .setExpirationTime(
                    Timestamp.generate().plusNanos(ONE_DAY_IN_NANOS),
                )
                .setWaitForExpiry(true)
                .setScheduleMemo("HIP-423 Integration Test")
                .execute(env.client)
        ).getReceipt(env.client);

        const info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        expect(info.executed).to.be.null;

        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(privateKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const postSignInfo = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        expect(postSignInfo.executed).to.be.null;
    });

    it("should sign schedule with multisig", async function () {
        const operatorId = env.operatorId;

        const privateKey1 = PrivateKey.generateED25519();
        const privateKey2 = PrivateKey.generateED25519();
        const privateKey3 = PrivateKey.generateED25519();

        const keyList = KeyList.of(
            privateKey1.publicKey,
            privateKey2.publicKey,
            privateKey3.publicKey,
        );

        const { accountId: receiverId } = await createAccount(
            env.client,
            (transaction) =>
                transaction
                    .setKeyWithoutAlias(keyList)
                    .setInitialBalance(Hbar.from(1)),
        );

        const transaction = new TransferTransaction()
            .addHbarTransfer(operatorId, Hbar.from("1"))
            .addHbarTransfer(receiverId, Hbar.from("-1"));

        const { scheduleId } = await (
            await transaction
                .schedule()
                .setExpirationTime(
                    Timestamp.generate().plusNanos(ONE_DAY_IN_NANOS),
                )
                .setScheduleMemo("Multisig Test")
                .execute(env.client)
        ).getReceipt(env.client);

        // Sign the schedule with the first private key
        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(privateKey1)
            ).execute(env.client)
        ).getReceipt(env.client);

        // Sign the schedule with the second private key
        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(privateKey2)
            ).execute(env.client)
        ).getReceipt(env.client);

        // Verify that the schedule is still not executed
        const info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        expect(info.executed).to.be.null;

        // Sign the schedule with the third private key
        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(privateKey3)
            ).execute(env.client)
        ).getReceipt(env.client);

        // Now the schedule should be executed
        const postSignInfo = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        expect(postSignInfo.executed).to.be.not.null;
    });

    it("should sign with multisig and update signing requirements", async function () {
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();

        const keyList = new KeyList(
            [key1.publicKey, key2.publicKey, key3.publicKey],
            2,
        );

        const { accountId } = await createAccount(env.client, (transaction) =>
            transaction
                .setKeyWithoutAlias(keyList)
                .setInitialBalance(new Hbar(10)),
        );

        // Create the transaction
        const transfer = new TransferTransaction()
            .addHbarTransfer(accountId, new Hbar(1).negated())
            .addHbarTransfer(env.operatorId, new Hbar(1));

        // Schedule the transaction
        const { scheduleId } = await (
            await transfer
                .schedule()
                .setExpirationTime(
                    Timestamp.generate().plusNanos(ONE_DAY_IN_NANOS),
                )
                .setScheduleMemo("HIP-423 Integration Test")
                .execute(env.client)
        ).getReceipt(env.client);

        let info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        // Verify the transaction is not executed
        expect(info.executed).to.be.null;

        // Sign with one key
        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(key1)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        // Verify the transaction is still not executed
        expect(info.executed).to.be.null;

        // Update the signing requirements

        await (
            await (
                await (
                    await (
                        await new AccountUpdateTransaction()
                            .setAccountId(accountId)
                            .setKey(key3)
                            .freezeWith(env.client)
                            .sign(key1)
                    ).sign(key2)
                ).sign(key3)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        // Verify the transaction is still not executed
        expect(info.executed).to.be.null;

        // Sign with the updated key
        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(key3)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        // Verify the transaction is executed
        expect(info.executed).to.not.be.null;
    });

    it("should execute with short expiration time", async function () {
        const hasJitter = false;
        const SHORT_EXPIRATION_TIME = 10_000;

        const { accountId, newKey } = await createAccount(
            env.client,
            (transaction) => transaction.setInitialBalance(new Hbar(10)),
        );

        const transfer = new TransferTransaction()
            .addHbarTransfer(accountId, new Hbar(1).negated())
            .addHbarTransfer(env.operatorId, new Hbar(1));

        var { scheduleId } = await (
            await transfer
                .schedule()
                .setExpirationTime(
                    Timestamp.generate(hasJitter).plusNanos(10_000_000_000),
                )
                .setWaitForExpiry(true)
                .setScheduleMemo("HIP-423 Integration Test")
                .execute(env.client)
        ).getReceipt(env.client);

        let info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        expect(info.executed).to.equal(null);

        await (
            await (
                await new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .freezeWith(env.client)
                    .sign(newKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(env.client);

        expect(info.executed).to.equal(null);

        const balanceBefore = await new AccountBalanceQuery()
            .setAccountId(accountId)
            .execute(env.client);

        await setTimeout(SHORT_EXPIRATION_TIME);

        const balanceAfter = await new AccountBalanceQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(balanceAfter.hbars.toTinybars().toNumber()).to.be.lte(
            balanceBefore.hbars.toTinybars().toNumber(),
        );
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/SystemIntegrationTest.js
import {
    ContractId,
    FileId,
    SystemDeleteTransaction,
    Timestamp,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("SystemIntegration", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable when file id is not set", async function () {
        let errorThrown = false;

        try {
            await new SystemDeleteTransaction()
                .setContractId(new ContractId(10))
                .setExpirationTime(Timestamp.generate())
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
    });

    it("should be executable when contract id is not set", async function () {
        let errorThrown = false;

        try {
            await new SystemDeleteTransaction()
                .setFileId(new FileId(10))
                .setExpirationTime(Timestamp.generate())
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
    });

    it("should be executable when file id and expiratiion time are not set", async function () {
        let errorThrown = false;

        try {
            await new SystemDeleteTransaction()
                .setContractId(new ContractId(10))
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
    });

    it("should be executable when contract id and expiration time are not set", async function () {
        let errorThrown = false;

        try {
            await new SystemDeleteTransaction()
                .setFileId(new FileId(10))
                .execute(env.client);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenAirdropIntegrationTest.js
import {
    TokenAirdropTransaction,
    TokenMintTransaction,
    PrivateKey,
    NftId,
    AccountBalanceQuery,
    CustomFixedFee,
    TokenAssociateTransaction,
    TransferTransaction,
    Hbar,
    AccountId,
    TokenId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("TokenAirdropIntegrationTest", function () {
    let env;
    const INITIAL_SUPPLY = 1000;

    beforeEach(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should transfer tokens when the account is associated", async function () {
        const ftTokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("ffff")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction.setTokenName("FFFFF").setTokenSymbol("FFF"),
        );

        const mintResponse = await new TokenMintTransaction()
            .setTokenId(nftTokenId)
            .addMetadata(Buffer.from("-"))
            .execute(env.client);

        const { serials } = await mintResponse.getReceipt(env.client);

        const { accountId: receiverId } = await createAccount(
            env.client,
            (transaction) => transaction.setMaxAutomaticTokenAssociations(-1),
        );

        // airdrop the tokens
        const transactionResponse = await new TokenAirdropTransaction()
            .addNftTransfer(
                new NftId(nftTokenId, serials[0]),
                env.operatorId,
                receiverId,
            )
            .addTokenTransfer(ftTokenId, receiverId, INITIAL_SUPPLY)
            .addTokenTransfer(ftTokenId, env.operatorId, -INITIAL_SUPPLY)
            .execute(env.client);

        const { newPendingAirdrops } = await transactionResponse.getRecord(
            env.client,
        );
        expect(newPendingAirdrops.length).to.be.eq(0);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        const receiverBalance = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        expect(operatorBalance.tokens.get(ftTokenId).toInt()).to.be.eq(0);
        expect(receiverBalance.tokens.get(ftTokenId).toInt()).to.be.eq(
            INITIAL_SUPPLY,
        );

        expect(operatorBalance.tokens.get(nftTokenId).toInt()).to.be.eq(0);
        expect(receiverBalance.tokens.get(nftTokenId).toInt()).to.be.eq(1);
    });

    it("tokens should be in pending state when no automatic association", async function () {
        const ftTokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("ffff")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction.setTokenName("FFFFF").setTokenSymbol("FFF"),
        );

        const mintResponse = await new TokenMintTransaction()
            .setTokenId(nftTokenId)
            .addMetadata(Buffer.from("-"))
            .execute(env.client);

        const { serials } = await mintResponse.getReceipt(env.client);

        const { accountId: receiverId } = await createAccount(env.client);

        const airdropTokenResponse = await new TokenAirdropTransaction()
            .addTokenTransfer(ftTokenId, receiverId, INITIAL_SUPPLY)
            .addTokenTransfer(ftTokenId, env.operatorId, -INITIAL_SUPPLY)
            .addNftTransfer(nftTokenId, serials[0], env.operatorId, receiverId)
            .execute(env.client);

        const airdropTokenRecord = await airdropTokenResponse.getRecord(
            env.client,
        );

        const { newPendingAirdrops } = airdropTokenRecord;

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);
        const receiverBalance = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        // FT checks
        expect(operatorBalance.tokens.get(ftTokenId).toInt()).to.be.eq(
            INITIAL_SUPPLY,
        );
        expect(receiverBalance.tokens.get(ftTokenId)).to.be.eq(null);

        // NFT checks
        expect(operatorBalance.tokens.get(nftTokenId).toInt()).to.be.eq(1);
        expect(receiverBalance.tokens.get(nftTokenId)).to.be.eq(null);

        // record check
        expect(newPendingAirdrops.length).to.be.eq(2);
        expect(newPendingAirdrops[0].airdropId.senderId).deep.equal(
            env.operatorId,
        );
        expect(newPendingAirdrops[0].airdropId.receiverId).deep.equal(
            receiverId,
        );
        expect(newPendingAirdrops[0].airdropId.tokenId).deep.equal(ftTokenId);
        expect(newPendingAirdrops[0].airdropId.nftId).to.equal(null);

        expect(newPendingAirdrops[1].airdropId.senderId).deep.equal(
            env.operatorId,
        );
        expect(newPendingAirdrops[1].airdropId.receiverId).deep.equal(
            receiverId,
        );
        expect(newPendingAirdrops[1].airdropId.tokenId).deep.equal(null);
        expect(newPendingAirdrops[1].airdropId.nftId.tokenId).to.deep.equal(
            nftTokenId,
        );

        expect(
            newPendingAirdrops[1].airdropId.nftId.serial.toString(),
        ).to.deep.equal(serials[0].toString());
    });

    it("should create hollow account when airdropping tokens and transfers them", async function () {
        const ftTokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("ffff")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction.setTokenName("FFFFF").setTokenSymbol("FFF"),
        );

        const mintResponse = await new TokenMintTransaction()
            .setTokenId(nftTokenId)
            .addMetadata(Buffer.from("metadata"))
            .execute(env.client);

        const { serials } = await mintResponse.getReceipt(env.client);

        const receiverPrivateKey = PrivateKey.generateED25519();
        const aliasAccountId = receiverPrivateKey.publicKey.toAccountId(0, 0);

        const airdropTokenResponse = await new TokenAirdropTransaction()
            .addTokenTransfer(ftTokenId, aliasAccountId, INITIAL_SUPPLY)
            .addTokenTransfer(ftTokenId, env.operatorId, -INITIAL_SUPPLY)
            .addNftTransfer(
                nftTokenId,
                serials[0],
                env.operatorId,
                aliasAccountId,
            )
            .execute(env.client);

        await airdropTokenResponse.getReceipt(env.client);

        const aliasBalance = await new AccountBalanceQuery()
            .setAccountId(aliasAccountId)
            .execute(env.client);
        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(aliasBalance.tokens.get(ftTokenId).toInt()).to.be.eq(
            INITIAL_SUPPLY,
        );
        expect(operatorBalance.tokens.get(ftTokenId).toInt()).to.be.eq(0);

        expect(aliasBalance.tokens.get(nftTokenId).toInt()).to.be.eq(1);
        expect(operatorBalance.tokens.get(nftTokenId).toInt()).to.be.eq(0);
    });

    it("should airdrop with custom fees", async function () {
        const FEE_AMOUNT = 1;

        const { accountId: receiverId } = await createAccount(
            env.client,
            (transaction) => transaction.setMaxAutomaticTokenAssociations(-1),
        );

        const feeTokenId = await createFungibleToken(
            env.client,
            (transaction) =>
                transaction
                    .setTokenName("fee")
                    .setTokenSymbol("FEE")
                    .setInitialSupply(INITIAL_SUPPLY),
        );

        let customFixedFee = new CustomFixedFee()
            .setFeeCollectorAccountId(env.operatorId)
            .setDenominatingTokenId(feeTokenId)
            .setAmount(FEE_AMOUNT)
            .setAllCollectorsAreExempt(true);

        const tokenWithFeeId = await createFungibleToken(
            env.client,
            (transaction) =>
                transaction
                    .setTokenName("tokenWithFee")
                    .setTokenSymbol("TWF")
                    .setInitialSupply(INITIAL_SUPPLY)
                    .setCustomFees([customFixedFee]),
        );

        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction
                    .setTokenName("tokenWithFee")
                    .setTokenSymbol("TWF")
                    .setCustomFees([customFixedFee]),
        );

        const mintResponse = await new TokenMintTransaction()
            .setTokenId(nftTokenId)
            .addMetadata(Buffer.from("-"))
            .execute(env.client);

        const { serials } = await mintResponse.getReceipt(env.client);

        const { accountId: senderAccountId, newKey: senderPrivateKey } =
            await createAccount(env.client, (transaction) =>
                transaction
                    .setMaxAutomaticTokenAssociations(-1)
                    .setInitialBalance(new Hbar(10)),
            );

        await (
            await (
                await new TokenAssociateTransaction()
                    .setAccountId(senderAccountId)
                    .setTokenIds([tokenWithFeeId, feeTokenId, nftTokenId])
                    .freezeWith(env.client)
                    .sign(senderPrivateKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addTokenTransfer(
                    tokenWithFeeId,
                    env.operatorId,
                    -INITIAL_SUPPLY,
                )
                .addTokenTransfer(
                    tokenWithFeeId,
                    senderAccountId,
                    INITIAL_SUPPLY,
                )
                .addNftTransfer(
                    nftTokenId,
                    serials[0],
                    env.operatorId,
                    senderAccountId,
                )
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addTokenTransfer(feeTokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(feeTokenId, senderAccountId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAirdropTransaction()
                    .addTokenTransfer(
                        tokenWithFeeId,
                        receiverId,
                        INITIAL_SUPPLY,
                    )
                    .addTokenTransfer(
                        tokenWithFeeId,
                        senderAccountId,
                        -INITIAL_SUPPLY,
                    )
                    .addNftTransfer(
                        nftTokenId,
                        serials[0],
                        senderAccountId,
                        receiverId,
                    )
                    .freezeWith(env.client)
                    .sign(senderPrivateKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        // check if fees are collected
        const DISTINCT_TRANSACTIONS = 2;
        expect(operatorBalance.tokens.get(tokenWithFeeId).toInt()).to.be.eq(0);
        expect(operatorBalance.tokens.get(feeTokenId).toInt()).to.be.eq(
            DISTINCT_TRANSACTIONS,
        );

        const receiverBalance = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);
        expect(receiverBalance.tokens.get(tokenWithFeeId).toInt()).to.be.eq(
            INITIAL_SUPPLY,
        );

        const senderBalance = await new AccountBalanceQuery()
            .setAccountId(senderAccountId)
            .execute(env.client);
        expect(senderBalance.tokens.get(tokenWithFeeId).toInt()).to.be.eq(0);
        expect(senderBalance.tokens.get(feeTokenId).toInt()).to.be.eq(
            INITIAL_SUPPLY - DISTINCT_TRANSACTIONS * FEE_AMOUNT,
        );
        expect(senderBalance.tokens.get(nftTokenId).toInt()).to.be.eq(0);
        expect(receiverBalance.tokens.get(nftTokenId).toInt()).to.be.eq(1);
    });

    it("should airdrop with receiver sig set to true", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("FFFFFFFFFF")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const nftTokenId = await createNonFungibleToken(
            env.client,
            (transaction) =>
                transaction.setTokenName("FFFFFFFFFF").setTokenSymbol("FFF"),
        );

        const mintResponse = await new TokenMintTransaction()
            .setTokenId(nftTokenId)
            .addMetadata(Buffer.from("-"))
            .execute(env.client);

        const { serials } = await mintResponse.getReceipt(env.client);

        const receiverPrivateKey = PrivateKey.generateECDSA();

        const { accountId: receiverId } = await createAccount(
            env.client,
            (transaction) => {
                transaction
                    .setInitialBalance(new Hbar(10))
                    .setKeyWithoutAlias(receiverPrivateKey.publicKey)
                    .setReceiverSignatureRequired(true)
                    .freezeWith(env.client)
                    .sign(receiverPrivateKey);
            },
        );

        let err = false;
        try {
            const airdropTokenResponse = await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addNftTransfer(
                    nftTokenId,
                    serials[0],
                    env.operatorId,
                    receiverId,
                )
                .execute(env.client);

            await airdropTokenResponse.getReceipt(env.client);
        } catch (error) {
            if (error.message.includes("INVALID_SIGNATURE")) {
                err = true;
            }
        }

        expect(err).to.be.eq(false);
    });

    it("should not airdrop with invalid tx body", async function () {
        let err = false;
        const tokenId = new TokenId(1);
        const accountId = new AccountId(1);

        try {
            await (
                await new TokenAirdropTransaction().execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            if (error.message.includes("EMPTY_TOKEN_TRANSFER_BODY")) {
                err = true;
            }
        }
        expect(err).to.be.eq(true);

        err = false;
        try {
            await (
                await new TokenAirdropTransaction()
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addTokenTransfer(tokenId, accountId, 1)
                    .addNftTransfer(new NftId(tokenId, 1), accountId, accountId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            if (error.message.includes("INVALID_TRANSACTION_BODY")) {
                err = true;
            }
        }
        expect(err).to.be.eq(true);
    });
});
// Filename: test/integration/TokenAllowancesIntegrationTest.js
import {
    AccountAllowanceApproveTransaction,
    Hbar,
    Status,
    TransactionId,
    TokenAssociateTransaction,
    FileCreateTransaction,
    FileAppendTransaction,
    ContractCreateTransaction,
    TransferTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
    TransactionRecordQuery,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, createFungibleToken } from "./utils/Fixtures.js";

let smartContractBytecode =
    "0x608060405234801561001057600080fd5b5061050e806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806315dacbea1461004e578063a983361a14610076578063e1f21c6714610089578063e7092b411461009c575b005b61006161005c3660046103db565b6100bd565b60405190151581526020015b60405180910390f35b61004c6100843660046103db565b61016e565b610061610097366004610425565b610248565b6100af6100aa366004610399565b6102f0565b60405190815260200161006d565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b1790529151600092839290881691610121919061049f565b600060405180830381855af49150503d806000811461015c576040519150601f19603f3d011682016040523d82523d6000602084013e610161565b606091505b5090979650505050505050565b6040516323b872dd60e01b81526001600160a01b038481166004830152838116602483015260448201839052600091908616906323b872dd90606401602060405180830381600087803b1580156101c457600080fd5b505af11580156101d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101fc9190610460565b9050806102415760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8811985a5b1959608a1b604482015260640160405180910390fd5b5050505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663095ea7b360e01b17905291516000928392908716916102a4919061049f565b600060405180830381855af49150503d80600081146102df576040519150601f19603f3d011682016040523d82523d6000602084013e6102e4565b606091505b50909695505050505050565b604051636eb1769f60e11b81526001600160a01b03838116600483015282811660248301526000919085169063dd62ed3e9060440160206040518083038186803b15801561033d57600080fd5b505afa158015610351573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103759190610487565b949350505050565b80356001600160a01b038116811461039457600080fd5b919050565b6000806000606084860312156103ad578283fd5b6103b68461037d565b92506103c46020850161037d565b91506103d26040850161037d565b90509250925092565b600080600080608085870312156103f0578081fd5b6103f98561037d565b93506104076020860161037d565b92506104156040860161037d565b9396929550929360600135925050565b600080600060608486031215610439578283fd5b6104428461037d565b92506104506020850161037d565b9150604084013590509250925092565b600060208284031215610471578081fd5b81518015158114610480578182fd5b9392505050565b600060208284031215610498578081fd5b5051919050565b60008251815b818110156104bf57602081860181015185830152016104a5565b818111156104cd5782828501525b50919091019291505056fea2646970667358221220231931d69934dec3bcbd24b8ab4267e454b799a4d72f33d2ebc42c9f42ce374964736f6c63430008040033";

describe("TokenAllowances", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("Cannot transfer on behalf of `spender` account without allowance approval", async function () {
        let status;
        const { accountId: spenderAccountId, newKey: spenderKey } =
            await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            });

        const { accountId: receiverAccountId } = await createAccount(
            env.client,
            (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            },
        );

        const tokenId = await createFungibleToken(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId])
                    .setAccountId(spenderAccountId)
                    .freezeWith(env.client)
                    .sign(spenderKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);
        try {
            await (
                await (
                    await new TransferTransaction()
                        .addApprovedTokenTransfer(tokenId, spenderAccountId, -1)
                        .addApprovedTokenTransfer(tokenId, receiverAccountId, 1)
                        .setTransactionId(onBehalfOfTransactionId)
                        .freezeWith(env.client)
                        .sign(spenderKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.TokenNotAssociatedToAccount);
    });

    it("Can transfer on behalf of `spender` account with allowance approval", async function () {
        const { accountId: spenderAccountId, newKey: spenderKey } =
            await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            });

        const { accountId: receiverAccountId, newKey: receiverKey } =
            await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            });

        const tokenId = await createFungibleToken(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId])
                    .setAccountId(receiverAccountId)
                    .freezeWith(env.client)
                    .sign(receiverKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        // Give `spender` allowance for Token
        const receiverApproveTx =
            new AccountAllowanceApproveTransaction().approveTokenAllowance(
                tokenId,
                env.operatorId,
                spenderAccountId,
                100,
            );

        const approveRx = await receiverApproveTx.execute(env.client);

        const approveReceipt = await approveRx.getReceipt(env.client);
        console.log(
            `Approve spender allowance - status: ${approveReceipt.status}`,
        );

        let err = false;
        const onBehalfOfTransactionId =
            TransactionId.generate(spenderAccountId);
        try {
            await (
                await (
                    await new TransferTransaction()
                        .addApprovedTokenTransfer(tokenId, spenderAccountId, -1)
                        .addApprovedTokenTransfer(tokenId, receiverAccountId, 1)
                        .setTransactionId(onBehalfOfTransactionId)
                        .freezeWith(env.client)
                        .sign(spenderKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.SpenderDoesNotHaveAllowance);
        }

        expect(err).to.be.true;
    });

    it("Can set `spender` account to be ContractId instead of AccountId", async function () {
        const { accountId: receiverAccountId, newKey: receiverKey } =
            await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(2));
            });

        const tokenId = await createFungibleToken(env.client);

        // Create a file on Hedera and store the bytecode
        const fileCreateTx = new FileCreateTransaction()
            .setKeys([env.operatorKey])
            .freezeWith(env.client);
        const fileCreateSign = await fileCreateTx.sign(env.operatorKey);
        const fileCreateSubmit = await fileCreateSign.execute(env.client);
        const fileCreateRx = await fileCreateSubmit.getReceipt(env.client);
        const bytecodeFileId = fileCreateRx.fileId;

        //Append contents to the file

        const fileAppendTx = new FileAppendTransaction()
            .setFileId(bytecodeFileId)
            .setContents(smartContractBytecode)
            .setMaxChunks(10)
            .freezeWith(env.client);
        const fileAppendSign = await fileAppendTx.sign(env.operatorKey);
        const fileAppendSubmit = await fileAppendSign.execute(env.client);
        const fileAppendRx = await fileAppendSubmit.getReceipt(env.client);
        console.log("Status of file append is", fileAppendRx.status.toString());

        // Instantiate the contract instance
        const contractTx = await new ContractCreateTransaction()
            //Set the file ID of the Hedera file storing the bytecode
            .setAdminKey(env.operatorKey)
            .setBytecodeFileId(bytecodeFileId)
            //Set the gas to instantiate the contract
            .setGas(100000)
            //Provide the constructor parameters for the contract
            .setConstructorParameters();

        //Submit the transaction to the Hedera test network
        const contractResponse = await contractTx.execute(env.client);

        //Get the receipt of the file create transaction
        const contractReceipt = await contractResponse.getReceipt(env.client);

        //Get the smart contract ID
        const contractId = contractReceipt.contractId;

        console.log("Contract ID is:", contractId.toString());

        //Associate Token with Contract
        const tokenAssociateTransactionWithContract =
            await new TokenAssociateTransaction()
                .setAccountId(contractId.toString())
                .setTokenIds([tokenId])
                .freezeWith(env.client);

        const signedTxForAssociateTokenWithContract =
            await tokenAssociateTransactionWithContract.sign(env.operatorKey);
        const txResponseAssociatedTokenWithContract =
            await signedTxForAssociateTokenWithContract.execute(env.client);
        const txReceipt2 =
            await txResponseAssociatedTokenWithContract.getReceipt(env.client);
        console.log(
            "The associate token to contract transaction consensus is",
            txReceipt2.status.toString(),
        );

        //Associate Token with Receiver
        const tokenAssociateTransactionWithContract1 =
            await new TokenAssociateTransaction()
                .setAccountId(receiverAccountId.toString())
                .setTokenIds([tokenId])
                .freezeWith(env.client);

        const signedTxForAssociateTokenWithContract1 =
            await tokenAssociateTransactionWithContract1.sign(receiverKey);
        const txResponseAssociatedTokenWithContract1 =
            await signedTxForAssociateTokenWithContract1.execute(env.client);
        const txReceipt21 =
            await txResponseAssociatedTokenWithContract1.getReceipt(env.client);
        console.log(
            "The associate token to receiver transaction consensus is",
            txReceipt21.status.toString(),
        );

        // Give `spender` allowance for Token
        const receiverApproveTx =
            new AccountAllowanceApproveTransaction().approveTokenAllowance(
                tokenId,
                env.operatorId,
                contractId,
                100,
            );

        const approveRx = await receiverApproveTx.execute(env.client);

        const approveReceipt = await approveRx.getReceipt(env.client);
        console.log(
            `Approve spender allowance - status: ${approveReceipt.status}`,
        );

        // Get Allowances
        const checkAllowance = new ContractExecuteTransaction()
            .setContractId(contractId)
            .setGas(1500000)
            .setFunction(
                "getAllowance",
                new ContractFunctionParameters()
                    .addAddress(tokenId.toSolidityAddress())
                    .addAddress(env.operatorId.toSolidityAddress())
                    .addAddress(contractId.toSolidityAddress()),
            );

        const checkAllowanceTx = await checkAllowance.execute(env.client);
        const txRecord = await checkAllowanceTx.getRecord(env.client);

        const recQuery = await new TransactionRecordQuery()
            .setTransactionId(txRecord.transactionId)
            .setIncludeChildren(true)
            .execute(env.client);
        const allowanceSize = recQuery.contractFunctionResult.getUint256(0);

        console.log(`Contract has an allowance of ${allowanceSize}`);

        expect(allowanceSize.toNumber()).to.equal(100);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenAssociateIntegrationTest.js
import {
    AccountAllowanceApproveTransaction,
    AccountBalanceQuery,
    AccountUpdateTransaction,
    Hbar,
    NftId,
    AccountInfoQuery,
    Status,
    TokenAssociateTransaction,
    TokenMintTransaction,
    TransactionId,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("TokenAssociate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new({ balance: 1000 });
    });

    it("should be executable", async function () {
        const { accountId, newKey: key } = await createAccount(
            env.client,
            (transaction) => transaction.setInitialBalance(new Hbar(2)),
        );

        const token = await createFungibleToken(env.client, (transaction) => {
            transaction
                .setKycKey(env.client.operatorPublicKey)
                .setDecimals(3)
                .setInitialSupply(1000000);
        });

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(accountId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const balances = await new AccountBalanceQuery()
            .setAccountId(accountId)
            .execute(env.client);

        expect(balances.tokens.get(token).toInt()).to.be.equal(0);

        const info = await new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(env.client);

        const relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.false;
        expect(relationship.isFrozen).to.be.false;
    });

    it("should be executable even when no token IDs are set", async function () {
        const operatorId = env.operatorId;

        await (
            await new TokenAssociateTransaction()
                .setAccountId(operatorId)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when account ID is not set", async function () {
        const token = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000),
        );

        let err = false;

        try {
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token association did not error");
        }
    });

    describe("Max Auto Associations", function () {
        let receiverKey, receiverId;
        const TOKEN_SUPPLY = 100,
            TRANSFER_AMOUNT = 10;

        beforeEach(async function () {
            const accountCreateResult = await createAccount(env.client);

            receiverId = accountCreateResult.accountId;
            receiverKey = accountCreateResult.newKey;
        });

        describe("Limited Auto Associations", function () {
            it("should revert FT transfer when no auto associations left", async function () {
                // update account to have one auto association
                const accountUpdateTx = await new AccountUpdateTransaction()
                    .setAccountId(receiverId)
                    .setMaxAutomaticTokenAssociations(1)
                    .freezeWith(env.client)
                    .sign(receiverKey);

                await (
                    await accountUpdateTx.execute(env.client)
                ).getReceipt(env.client);

                const tokenId1 = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const tokenId2 = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const sendTokenToReceiverTx = await new TransferTransaction()
                    .addTokenTransfer(
                        tokenId1,
                        env.operatorId,
                        -TRANSFER_AMOUNT,
                    )
                    .addTokenTransfer(tokenId1, receiverId, TRANSFER_AMOUNT)
                    .execute(env.client);

                await sendTokenToReceiverTx.getReceipt(env.client);

                const sendTokenToReceiverTx2 = await new TransferTransaction()
                    .addTokenTransfer(
                        tokenId2,
                        env.operatorId,
                        -TRANSFER_AMOUNT,
                    )
                    .addTokenTransfer(tokenId2, receiverId, TRANSFER_AMOUNT)
                    .freezeWith(env.client)
                    .execute(env.client);

                let err = false;

                try {
                    await sendTokenToReceiverTx2.getReceipt(env.client);
                } catch (error) {
                    err = error
                        .toString()
                        .includes(Status.NoRemainingAutomaticAssociations);
                }

                if (!err) {
                    throw new Error(
                        "Token transfer did not error with NO_REMAINING_AUTOMATIC_ASSOCIATIONS",
                    );
                }
            });

            it("should revert NFTs transfer when no auto associations left", async function () {
                const accountUpdateTx = await new AccountUpdateTransaction()
                    .setAccountId(receiverId)
                    .setMaxAutomaticTokenAssociations(1)
                    .freezeWith(env.client)
                    .sign(receiverKey);

                await (
                    await accountUpdateTx.execute(env.client)
                ).getReceipt(env.client);

                // create token 1
                const tokenId1 = await createNonFungibleToken(env.client);

                // mint a token in token 1
                const tokenMintSignedTransaction =
                    await new TokenMintTransaction()
                        .setTokenId(tokenId1)
                        .setMetadata([Buffer.from("-")])
                        .execute(env.client);

                const { serials } = await tokenMintSignedTransaction.getReceipt(
                    env.client,
                );

                // transfer the token to receiver

                const transferTxSign = await new TransferTransaction()
                    .addNftTransfer(
                        tokenId1,
                        serials[0],
                        env.operatorId,
                        receiverId,
                    )
                    .execute(env.client);

                await transferTxSign.getReceipt(env.client);

                // create token 2
                const tokenId2 = await createNonFungibleToken(env.client);

                // mint token 2
                const tokenMintSignedTransaction2 =
                    await new TokenMintTransaction()
                        .setTokenId(tokenId2)
                        .addMetadata(Buffer.from("-"))
                        .execute(env.client);

                const serials2 = (
                    await tokenMintSignedTransaction2.getReceipt(env.client)
                ).serials;

                let err = false;

                try {
                    const transferToken2Response =
                        await new TransferTransaction()
                            .addNftTransfer(
                                tokenId2,
                                serials2[0],
                                env.operatorId,
                                receiverId,
                            )
                            .execute(env.client);

                    await transferToken2Response.getReceipt(env.client);
                } catch (error) {
                    err = error
                        .toString()
                        .includes(Status.NoRemainingAutomaticAssociations);
                }

                if (!err) {
                    throw new Error(
                        "Token transfer did not error with NO_REMAINING_AUTOMATIC_ASSOCIATIONS",
                    );
                }
            });

            it("should contain sent balance when transfering FT to account with manual token association", async function () {
                const tokenId = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const tokenAssociateTransaction =
                    await new TokenAssociateTransaction()
                        .setAccountId(receiverId)
                        .setTokenIds([tokenId])
                        .freezeWith(env.client)
                        .sign(receiverKey);

                await (
                    await tokenAssociateTransaction.execute(env.client)
                ).getReceipt(env.client);

                const sendTokenToReceiverTx = await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -TRANSFER_AMOUNT)
                    .addTokenTransfer(tokenId, receiverId, TRANSFER_AMOUNT)
                    .execute(env.client);

                await sendTokenToReceiverTx.getReceipt(env.client);

                const tokenBalance = await new AccountBalanceQuery()
                    .setAccountId(receiverId)
                    .execute(env.client);

                expect(tokenBalance.tokens.get(tokenId).toInt()).to.be.equal(
                    TRANSFER_AMOUNT,
                );
            });

            it("should contain sent balance when transfering NFT to account with manual token association", async function () {
                const tokenId = await createNonFungibleToken(env.client);

                const tokenAssociateTransaction =
                    await new TokenAssociateTransaction()
                        .setAccountId(receiverId)
                        .setTokenIds([tokenId])
                        .freezeWith(env.client)
                        .sign(receiverKey);

                await (
                    await tokenAssociateTransaction.execute(env.client)
                ).getReceipt(env.client);

                const tokenMintTx = await new TokenMintTransaction()
                    .setTokenId(tokenId)
                    .setMetadata([Buffer.from("-")])
                    .freezeWith(env.client)
                    .sign(env.operatorKey);

                const { serials } = await (
                    await tokenMintTx.execute(env.client)
                ).getReceipt(env.client);

                const sendTokenToReceiverTx = await new TransferTransaction()
                    .addNftTransfer(
                        tokenId,
                        serials[0],
                        env.operatorId,
                        receiverId,
                    )
                    .execute(env.client);

                await sendTokenToReceiverTx.getReceipt(env.client);

                const tokenBalance = await new AccountBalanceQuery()
                    .setAccountId(receiverId)
                    .execute(env.client);

                expect(tokenBalance.tokens.get(tokenId).toInt()).to.be.equal(1);
            });
        });

        describe("Unlimited Auto Associations", function () {
            it("receiver should contain FTs when transfering to account with unlimited auto associations", async function () {
                const tokenId1 = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const tokenId2 = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const updateUnlimitedAutomaticAssociations =
                    await new AccountUpdateTransaction()
                        .setAccountId(receiverId)
                        .setMaxAutomaticTokenAssociations(-1)
                        .freezeWith(env.client)
                        .sign(receiverKey);

                await (
                    await updateUnlimitedAutomaticAssociations.execute(
                        env.client,
                    )
                ).getReceipt(env.client);

                const tokenTransferResponse = await new TransferTransaction()
                    .addTokenTransfer(
                        tokenId1,
                        env.operatorId,
                        -TRANSFER_AMOUNT,
                    )
                    .addTokenTransfer(tokenId1, receiverId, TRANSFER_AMOUNT)
                    .execute(env.client);

                await tokenTransferResponse.getReceipt(env.client);

                const tokenTransferResponse2 = await new TransferTransaction()
                    .addTokenTransfer(
                        tokenId2,
                        env.operatorId,
                        -TRANSFER_AMOUNT,
                    )
                    .addTokenTransfer(tokenId2, receiverId, TRANSFER_AMOUNT)
                    .execute(env.client);

                await tokenTransferResponse2.getReceipt(env.client);

                const newTokenBalance = (
                    await new AccountBalanceQuery()
                        .setAccountId(receiverId)
                        .execute(env.client)
                ).tokens.get(tokenId1);

                const newTokenBalance2 = (
                    await new AccountBalanceQuery()
                        .setAccountId(receiverId)
                        .execute(env.client)
                ).tokens.get(tokenId2);

                expect(newTokenBalance.toInt()).to.equal(TRANSFER_AMOUNT);
                expect(newTokenBalance2.toInt()).to.equal(TRANSFER_AMOUNT);
            });

            it("receiver should contain NFTs when transfering to account with unlimited auto associations", async function () {
                const tokenId1 = await createNonFungibleToken(env.client);

                const tokenId2 = await createNonFungibleToken(env.client);

                const mintTokenTx = await new TokenMintTransaction()
                    .setTokenId(tokenId1)
                    .setMetadata([Buffer.from("-")])
                    .execute(env.client);

                const { serials } = await mintTokenTx.getReceipt(env.client);

                const mintTokenTx2 = await new TokenMintTransaction()
                    .setTokenId(tokenId2)
                    .setMetadata([Buffer.from("-")])
                    .execute(env.client);

                await mintTokenTx2.getReceipt(env.client);

                const updateUnlimitedAutomaticAssociations =
                    await new AccountUpdateTransaction()
                        .setAccountId(receiverId)
                        .setMaxAutomaticTokenAssociations(-1)
                        .freezeWith(env.client)
                        .sign(receiverKey);

                await (
                    await updateUnlimitedAutomaticAssociations.execute(
                        env.client,
                    )
                ).getReceipt(env.client);

                const tokenTransferResponse = await new TransferTransaction()
                    .addNftTransfer(
                        tokenId1,
                        serials[0],
                        env.operatorId,
                        receiverId,
                    )
                    .execute(env.client);

                await tokenTransferResponse.getReceipt(env.client);

                const tokenTransferResponse2 = await new TransferTransaction()
                    .addNftTransfer(tokenId2, 1, env.operatorId, receiverId)
                    .execute(env.client);

                await tokenTransferResponse2.getReceipt(env.client);

                const newTokenBalance = (
                    await new AccountBalanceQuery()
                        .setAccountId(receiverId)
                        .execute(env.client)
                ).tokens.get(tokenId1);

                const newTokenBalance2 = (
                    await new AccountBalanceQuery()
                        .setAccountId(receiverId)
                        .execute(env.client)
                ).tokens.get(tokenId2);

                expect(newTokenBalance.toInt()).to.equal(1);
                expect(newTokenBalance2.toInt()).to.equal(1);
            });

            it("receiver should have token balance even if it has given allowance to spender", async function () {
                const { accountId: spenderAccountId, newKey: spenderKey } =
                    await createAccount(env.client, (transaction) => {
                        transaction
                            .setInitialBalance(new Hbar(1))
                            .setMaxAutomaticTokenAssociations(-1);
                    });

                const unlimitedAutoAssociationReceiverTx =
                    await new AccountUpdateTransaction()
                        .setAccountId(receiverId)
                        .setMaxAutomaticTokenAssociations(-1)
                        .freezeWith(env.client)
                        .sign(receiverKey);

                await (
                    await unlimitedAutoAssociationReceiverTx.execute(env.client)
                ).getReceipt(env.client);

                const tokenId1 = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const tokenAllowanceTx =
                    await new AccountAllowanceApproveTransaction()
                        .approveTokenAllowance(
                            tokenId1,
                            env.operatorId,
                            spenderAccountId,
                            TRANSFER_AMOUNT,
                        )
                        .execute(env.client);

                await tokenAllowanceTx.getReceipt(env.client);

                const onBehalfOfTransactionId =
                    TransactionId.generate(spenderAccountId);
                const tokenTransferApprovedSupply =
                    await new TransferTransaction()
                        .setTransactionId(onBehalfOfTransactionId)
                        .addApprovedTokenTransfer(
                            tokenId1,
                            env.operatorId,
                            -TRANSFER_AMOUNT,
                        )
                        .addTokenTransfer(tokenId1, receiverId, TRANSFER_AMOUNT)
                        .freezeWith(env.client)
                        .sign(spenderKey);

                await (
                    await tokenTransferApprovedSupply.execute(env.client)
                ).getReceipt(env.client);

                const tokenBalanceReceiver = await new AccountBalanceQuery()
                    .setAccountId(receiverId)
                    .execute(env.client);

                const tokenBalanceSpender = await new AccountBalanceQuery()
                    .setAccountId(spenderAccountId)
                    .execute(env.client);

                const tokenBalanceTreasury = await new AccountBalanceQuery()
                    .setAccountId(env.operatorId)
                    .execute(env.client);

                expect(
                    tokenBalanceReceiver.tokens.get(tokenId1).toInt(),
                ).to.equal(TRANSFER_AMOUNT);

                expect(tokenBalanceSpender.tokens.get(tokenId1)).to.equal(null);

                expect(
                    tokenBalanceTreasury.tokens.get(tokenId1).toInt(),
                ).to.equal(TOKEN_SUPPLY - TRANSFER_AMOUNT);
            });

            it("receiver should have nft even if it has given allowance to spender", async function () {
                const unlimitedAutoAssociationReceiverTx =
                    await new AccountUpdateTransaction()
                        .setAccountId(receiverId)
                        .setMaxAutomaticTokenAssociations(-1)
                        .freezeWith(env.client)
                        .sign(receiverKey);

                await (
                    await unlimitedAutoAssociationReceiverTx.execute(env.client)
                ).getReceipt(env.client);

                const { accountId: spenderAccountId, newKey: spenderKey } =
                    await createAccount(env.client, (transaction) => {
                        transaction
                            .setInitialBalance(new Hbar(1))
                            .setMaxAutomaticTokenAssociations(-1);
                    });

                const tokenId = await createNonFungibleToken(env.client);

                await (
                    await new TokenMintTransaction()
                        .setTokenId(tokenId)
                        .setMetadata([Buffer.from("-")])
                        .execute(env.client)
                ).getReceipt(env.client);

                const nftId = new NftId(tokenId, 1);
                const nftAllowanceTx =
                    await new AccountAllowanceApproveTransaction()
                        .approveTokenNftAllowance(
                            nftId,
                            env.operatorId,
                            spenderAccountId,
                        )
                        .execute(env.client);

                await nftAllowanceTx.getReceipt(env.client);

                // Generate TransactionId from spender's account id in order
                // for the transaction to be to be executed on behalf of the spender
                const onBehalfOfTransactionId =
                    TransactionId.generate(spenderAccountId);

                const nftTransferToReceiver = await new TransferTransaction()
                    .addApprovedNftTransfer(nftId, env.operatorId, receiverId)
                    .setTransactionId(onBehalfOfTransactionId)
                    .freezeWith(env.client)
                    .sign(spenderKey);

                await (
                    await nftTransferToReceiver.execute(env.client)
                ).getReceipt(env.client);

                const tokenBalanceReceiver = await new AccountBalanceQuery()
                    .setAccountId(receiverId)
                    .execute(env.client);

                const tokenBalanceSpender = await new AccountBalanceQuery()
                    .setAccountId(spenderAccountId)
                    .execute(env.client);

                const tokenBalanceTreasury = await new AccountBalanceQuery()
                    .setAccountId(env.operatorId)
                    .execute(env.client);

                expect(
                    tokenBalanceReceiver.tokens.get(tokenId).toInt(),
                ).to.equal(1);

                expect(tokenBalanceSpender.tokens.get(tokenId)).to.equal(null);

                expect(
                    tokenBalanceTreasury.tokens.get(tokenId).toInt(),
                ).to.equal(0);
            });

            it("receiver with unlimited auto associations should have FTs with decimal when sender transfers FTs", async function () {
                const tokenId = await createFungibleToken(
                    env.client,
                    (transaction) => {
                        transaction.setInitialSupply(TOKEN_SUPPLY);
                    },
                );

                const { accountId: receiverAccountId } = await createAccount(
                    env.client,
                    (transaction) => {
                        transaction.setMaxAutomaticTokenAssociations(-1);
                    },
                );

                await (
                    await new TokenAssociateTransaction()
                        .setAccountId(receiverAccountId)
                        .setTokenIds([tokenId])
                        .freezeWith(env.client)
                        .sign(receiverKey)
                ).execute(env.client);

                const tokenTransferResponse = await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -TRANSFER_AMOUNT)
                    .addTokenTransfer(
                        tokenId,
                        receiverAccountId,
                        TRANSFER_AMOUNT,
                    )
                    .execute(env.client);

                await tokenTransferResponse.getReceipt(env.client);

                const receiverBalance = (
                    await new AccountBalanceQuery()
                        .setAccountId(receiverAccountId)
                        .execute(env.client)
                ).tokens
                    .get(tokenId)
                    .toInt();

                expect(receiverBalance).to.equal(TRANSFER_AMOUNT);
            });

            it("should revert when auto association is set to less than -1", async function () {
                let err = false;

                try {
                    const accountUpdateTx = await new AccountUpdateTransaction()
                        .setAccountId(receiverId)
                        .setMaxAutomaticTokenAssociations(-2)
                        .freezeWith(env.client)
                        .sign(receiverKey);
                    await (
                        await accountUpdateTx.execute(env.client)
                    ).getReceipt(env.client);
                } catch (error) {
                    err = error
                        .toString()
                        .includes(Status.InvalidMaxAutoAssociations);
                }

                if (!err) {
                    throw new Error("Token association did not error");
                }

                try {
                    await createAccount(env.client, (transaction) => {
                        transaction
                            .setKeyWithoutAlias(receiverKey)
                            .setMaxAutomaticTokenAssociations(-2);
                    });
                } catch (error) {
                    err = error
                        .toString()
                        .includes(Status.InvalidMaxAutoAssociations);
                }

                if (!err) {
                    throw new Error("Token association did not error");
                }
            });
        });
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenBurnIntegrationTest.js
import {
    Status,
    TokenBurnTransaction,
    AccountBalanceQuery,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("TokenBurn", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const token = await createFungibleToken(env.client);

        await (
            await new TokenBurnTransaction()
                .setAmount(10)
                .setTokenId(token)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when token ID is not set", async function () {
        let err = false;

        try {
            await (
                await new TokenBurnTransaction()
                    .setAmount(10)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token Burn did not error");
        }
    });

    it("should not error when amount is not set", async function () {
        const operatorId = env.operatorId;

        const token = await createFungibleToken(env.client);

        let err = false;

        try {
            await (
                await new TokenBurnTransaction()
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error;
        }

        const accountBalance = await new AccountBalanceQuery()
            .setAccountId(operatorId)
            .execute(env.client);

        expect(
            accountBalance.tokens._map.get(token.toString()).toNumber(),
        ).to.be.equal(1000000);

        if (err) {
            throw new Error("token burn did error");
        }
    });

    it("cannot burn token with invalid metadata", async function () {
        const token = await createNonFungibleToken(env.client);

        let err = false;

        try {
            await (
                await new TokenBurnTransaction()
                    .setTokenId(token)
                    .setAmount(1)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenBurnMetadata);
        }

        if (!err) {
            throw new Error("token mint did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenCancelAirdropTransaction.js
import { expect } from "chai";
import {
    TokenAirdropTransaction,
    TokenMintTransaction,
    TokenCancelAirdropTransaction,
    AccountBalanceQuery,
    TokenFreezeTransaction,
    TokenAssociateTransaction,
    TokenPauseTransaction,
    TokenDeleteTransaction,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("TokenCancelAirdropIntegrationTest", function () {
    let env;
    const INITIAL_SUPPLY = 1000;

    beforeEach(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should cancel the tokens when they are in pending state", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client);

        const { serials } = await (
            await new TokenMintTransaction()
                .setTokenId(nftId)
                .addMetadata(Buffer.from("-"))
                .execute(env.client)
        ).getReceipt(env.client);

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
                .execute(env.client)
        ).getRecord(env.client);

        const [airdrop] = newPendingAirdrops;
        const { airdropId } = airdrop;
        await new TokenCancelAirdropTransaction()
            .addPendingAirdropId(airdropId)
            .execute(env.client);

        const ownerBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(ownerBalance.tokens.get(tokenId).toInt()).to.be.eq(
            INITIAL_SUPPLY,
        );
        expect(ownerBalance.tokens.get(nftId).toInt()).to.be.eq(1);
    });

    it("should cancel the token when token's frozen", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client);

        const { serials } = await (
            await new TokenMintTransaction()
                .setTokenId(nftId)
                .addMetadata(Buffer.from("-"))
                .execute(env.client)
        ).getReceipt(env.client);

        const { accountId: receiverId, newKey: receiverKey } =
            await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await new TokenAssociateTransaction()
                .setAccountId(receiverId)
                .setTokenIds([nftId])
                .freezeWith(env.client)
                .sign(receiverKey)
        ).execute(env.client);

        await (
            await new TokenFreezeTransaction()
                .setTokenId(tokenId)
                .setAccountId(env.operatorId)
                .execute(env.client)
        ).getReceipt(env.client);

        const [airdrop] = newPendingAirdrops;
        const { airdropId } = airdrop;
        await new TokenCancelAirdropTransaction()
            .addPendingAirdropId(airdropId)
            .execute(env.client);

        const ownerBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(ownerBalance.tokens.get(tokenId).toInt()).to.equal(
            INITIAL_SUPPLY,
        );
        expect(ownerBalance.tokens.get(nftId).toInt()).to.equal(1);
    });

    it("should cancel the token if paused", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setInitialSupply(INITIAL_SUPPLY)
                .setPauseKey(env.operatorKey),
        );

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await new TokenPauseTransaction()
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);

        const [airdrop] = newPendingAirdrops;
        const { airdropId } = airdrop;
        await new TokenCancelAirdropTransaction()
            .addPendingAirdropId(airdropId)
            .execute(env.client);

        const ownerBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(ownerBalance.tokens.get(tokenId).toInt()).to.equal(
            INITIAL_SUPPLY,
        );
    });

    it("should cancel the token if token is deleted", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("FFFFFFFFF")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY)
                .setAdminKey(env.operatorKey),
        );

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await new TokenDeleteTransaction()
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);

        const [airdrop] = newPendingAirdrops;
        const { airdropId } = airdrop;
        await new TokenCancelAirdropTransaction()
            .addPendingAirdropId(airdropId)
            .execute(env.client);

        const ownerBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(ownerBalance.tokens.get(tokenId).toInt()).to.equal(
            INITIAL_SUPPLY,
        );
    });

    it("should cancel the tokens to multiple receivers when they are in pending state", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("FFFFFF")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client, (transaction) =>
            transaction.setTokenName("nft").setTokenSymbol("NFT"),
        );

        // mint nfts
        const tokenMintResponse = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);

        const { serials } = await tokenMintResponse.getReceipt(env.client);

        const tokenMintResponse2 = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);

        const { serials: serials2 } = await tokenMintResponse2.getReceipt(
            env.client,
        );

        const { accountId: receiverId } = await createAccount(env.client);
        const { accountId: receiverId2 } = await createAccount(env.client);

        // airdrop ft and nft
        let tx = await new TokenAirdropTransaction()
            .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
            .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY / 2)
            .addTokenTransfer(tokenId, receiverId2, INITIAL_SUPPLY / 2)
            .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
            .addNftTransfer(nftId, serials2[0], env.operatorId, receiverId2)
            .execute(env.client);

        // get airdrop ids for both FT and NFTs
        const { newPendingAirdrops } = await tx.getRecord(env.client);
        const pendingAirdropIds = newPendingAirdrops.map(
            (pendingAirdrop) => pendingAirdrop.airdropId,
        );

        await (
            await new TokenCancelAirdropTransaction()
                .setPendingAirdropIds(pendingAirdropIds)
                .freezeWith(env.client)
                .execute(env.client)
        ).getReceipt(env.client);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(operatorBalance.tokens.get(tokenId).toInt()).to.be.equal(
            INITIAL_SUPPLY,
        );
        expect(operatorBalance.tokens.get(nftId).toInt()).to.be.equal(2);
    });

    it("should cancel the tokens when they are in pending state with multiple airdrop ids", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("FFFFFF")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client, (transaction) =>
            transaction.setTokenName("nft").setTokenSymbol("NFT"),
        );

        // mint nfts
        const tokenMintResponse = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);
        const { serials } = await tokenMintResponse.getReceipt(env.client);

        const tokenMintResponse2 = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);

        const { serials: serials2 } = await tokenMintResponse2.getReceipt(
            env.client,
        );

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        const { newPendingAirdrops: newPendingAirdrops2 } = await (
            await new TokenAirdropTransaction()
                .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
                .addNftTransfer(nftId, serials2[0], env.operatorId, receiverId)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await new TokenCancelAirdropTransaction()
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .addPendingAirdropId(newPendingAirdrops2[0].airdropId)
                .addPendingAirdropId(newPendingAirdrops2[1].airdropId)
                .execute(env.client)
        ).getReceipt(env.client);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(operatorBalance.tokens.get(tokenId).toInt()).to.be.equal(
            INITIAL_SUPPLY,
        );
        expect(operatorBalance.tokens.get(nftId).toInt()).to.be.equal(2);
    });

    it("should not be able to cancel the tokens when they are not airdropped", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction
                .setTokenName("FFFFFFFFF")
                .setTokenSymbol("FFF")
                .setInitialSupply(INITIAL_SUPPLY),
        );

        const { accountId: receiverId } = await createAccount(env.client);
        const { accountId: randomAccountId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        let err = false;
        try {
            await (
                await new TokenCancelAirdropTransaction()
                    .setTransactionId(TransactionId.generate(randomAccountId))
                    .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes("INVALID_SIGNATURE");
        }

        expect(err).to.be.true;
    });

    it("should not be able to cancel the tokens when they are already canceled", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client);

        const { serials } = await (
            await new TokenMintTransaction()
                .setTokenId(nftId)
                .addMetadata(Buffer.from("-"))
                .execute(env.client)
        ).getReceipt(env.client);

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await new TokenCancelAirdropTransaction()
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .execute(env.client)
        ).getReceipt(env.client);

        // recancel already canceled airdrop
        let err = false;
        try {
            await (
                await new TokenCancelAirdropTransaction()
                    .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes("INVALID_PENDING_AIRDROP_ID");
        }
        expect(err).to.be.true;
    });

    it("should not be able to cancel the tokens with empty list", async function () {
        let err = false;
        try {
            await new TokenCancelAirdropTransaction().execute(env.client);
        } catch (error) {
            err = error.message.includes("EMPTY_PENDING_AIRDROP_ID_LIST");
        }
        expect(err).to.be.true;
    });

    it("cannot cancel the tokens with duplicate entries", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(100),
        );

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -100)
                .addTokenTransfer(tokenId, receiverId, 100)
                .execute(env.client)
        ).getRecord(env.client);

        let err = false;
        try {
            await new TokenCancelAirdropTransaction()
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .execute(env.client);
        } catch (error) {
            err = error.message.includes("PENDING_AIRDROP_ID_REPEATED");
        }

        expect(err).to.be.true;
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenClaimAirdropTransaction.js
import { expect } from "chai";
import {
    AccountBalanceQuery,
    TokenAirdropTransaction,
    TokenAssociateTransaction,
    TokenMintTransaction,
    TokenPauseTransaction,
    TokenClaimAirdropTransaction,
    TokenDeleteTransaction,
    TokenFreezeTransaction,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("TokenClaimAirdropIntegrationTest", function () {
    let env, tx;
    const INITIAL_SUPPLY = 1000;

    beforeEach(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should claim the tokens when they are in pending state", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client);

        // Mint NFTs
        const tokenMintResponse = await new TokenMintTransaction()
            .setTokenId(nftId)
            .addMetadata(Buffer.from("-"))
            .execute(env.client);

        const { serials } = await tokenMintResponse.getReceipt(env.client);

        const { accountId: receiverId, newKey: receiverPrivateKey } =
            await createAccount(env.client);

        // Airdrop FT and NFT
        tx = await new TokenAirdropTransaction()
            .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
            .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
            .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
            .execute(env.client);

        // Get airdrop IDs for both FT and NFTs
        const { newPendingAirdrops } = await tx.getRecord(env.client);
        const [pendingAirdrop, pendingAirdropNft] = newPendingAirdrops;
        const { airdropId } = pendingAirdrop;
        const { airdropId: airdropNftId } = pendingAirdropNft;

        // Claim airdrop
        await (
            await (
                await new TokenClaimAirdropTransaction()
                    .addPendingAirdropId(airdropId)
                    .addPendingAirdropId(airdropNftId)
                    .freezeWith(env.client)
                    .sign(receiverPrivateKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        // Check balances
        const receiverBalance = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        expect(receiverBalance.tokens.get(tokenId).toInt()).to.be.equal(
            INITIAL_SUPPLY,
        );
        expect(receiverBalance.tokens.get(nftId).toInt()).to.be.equal(1);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(operatorBalance.tokens.get(tokenId).toInt()).to.be.equal(0);
        expect(operatorBalance.tokens.get(nftId).toInt()).to.be.equal(0);
    });

    it("should claim the tokens to multiple receivers when they are in pending state", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client);

        // Mint NFTs
        const tokenMintResponse = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);

        const { serials } = await tokenMintResponse.getReceipt(env.client);

        const tokenMintResponse2 = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);

        const { serials: serials2 } = await tokenMintResponse2.getReceipt(
            env.client,
        );

        const { accountId: receiverId, newKey: receiverPrivateKey } =
            await createAccount(env.client);
        const { accountId: receiverId2, newKey: receiverPrivateKey2 } =
            await createAccount(env.client);

        // Airdrop FT and NFT
        tx = await new TokenAirdropTransaction()
            .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
            .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY / 2)
            .addTokenTransfer(tokenId, receiverId2, INITIAL_SUPPLY / 2)
            .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
            .addNftTransfer(nftId, serials2[0], env.operatorId, receiverId2)
            .execute(env.client);

        // Get airdrop IDs for both FT and NFTs
        const { newPendingAirdrops } = await tx.getRecord(env.client);
        const pendingAirdropIds = newPendingAirdrops.map(
            (pendingAirdrop) => pendingAirdrop.airdropId,
        );

        await (
            await (
                await (
                    await new TokenClaimAirdropTransaction()
                        .setPendingAirdropIds(pendingAirdropIds)
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).sign(receiverPrivateKey2)
            ).execute(env.client)
        ).getReceipt(env.client);

        const receiverBalance = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        const receiverBalance2 = await new AccountBalanceQuery()
            .setAccountId(receiverId2)
            .execute(env.client);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(receiverBalance.tokens.get(tokenId).toInt()).to.be.equal(
            INITIAL_SUPPLY / 2,
        );

        expect(receiverBalance.tokens.get(nftId).toInt()).to.be.equal(1);

        expect(receiverBalance2.tokens.get(tokenId).toInt()).to.be.equal(
            INITIAL_SUPPLY / 2,
        );
        expect(receiverBalance2.tokens.get(nftId).toInt()).to.be.equal(1);

        expect(operatorBalance.tokens.get(tokenId).toInt()).to.be.equal(0);
        expect(operatorBalance.tokens.get(nftId).toInt()).to.be.equal(0);
    });

    it("should claim the tokens when they are in pending state with multiple airdrop ids", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client);

        // Mint NFTs
        const tokenMintResponse = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);
        const { serials } = await tokenMintResponse.getReceipt(env.client);

        const tokenMintResponse2 = await new TokenMintTransaction()
            .addMetadata(Buffer.from("-"))
            .setTokenId(nftId)
            .execute(env.client);

        const { serials: serials2 } = await tokenMintResponse2.getReceipt(
            env.client,
        );

        const { accountId: receiverId, newKey: receiverKey } =
            await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        const { newPendingAirdrops: newPendingAirdrops2 } = await (
            await new TokenAirdropTransaction()
                .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
                .addNftTransfer(nftId, serials2[0], env.operatorId, receiverId)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await (
                await new TokenClaimAirdropTransaction()
                    .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                    .addPendingAirdropId(newPendingAirdrops2[0].airdropId)
                    .addPendingAirdropId(newPendingAirdrops2[1].airdropId)
                    .freezeWith(env.client)
                    .sign(receiverKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        const receiverBalance = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        expect(receiverBalance.tokens.get(tokenId).toInt()).to.be.equal(
            INITIAL_SUPPLY,
        );
        expect(receiverBalance.tokens.get(nftId).toInt()).to.be.equal(2);

        const operatorBalance = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(operatorBalance.tokens.get(tokenId).toInt()).to.be.equal(0);
        expect(operatorBalance.tokens.get(nftId).toInt()).to.be.equal(0);
    });

    it("should not be able to claim the tokens when they are not airdropped", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const { accountId: receiverId } = await createAccount(env.client);
        const { accountId: randomAccountId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        let err = false;
        try {
            await (
                await new TokenClaimAirdropTransaction()
                    .setTransactionId(TransactionId.generate(randomAccountId))
                    .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes("INVALID_SIGNATURE");
        }
        expect(err).to.be.true;
    });

    it("should not be able to claim the tokens when they are already claimed", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(INITIAL_SUPPLY),
        );

        const nftId = await createNonFungibleToken(env.client, (transaction) =>
            transaction.setTokenName("nft").setTokenSymbol("NFT"),
        );

        const { serials } = await (
            await new TokenMintTransaction()
                .setTokenId(nftId)
                .addMetadata(Buffer.from("-"))
                .execute(env.client)
        ).getReceipt(env.client);

        const { accountId: receiverId, newKey: receiverKey } =
            await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addNftTransfer(nftId, serials[0], env.operatorId, receiverId)
                .addTokenTransfer(tokenId, env.operatorId, -INITIAL_SUPPLY)
                .addTokenTransfer(tokenId, receiverId, INITIAL_SUPPLY)
                .execute(env.client)
        ).getRecord(env.client);

        await (
            await (
                await new TokenClaimAirdropTransaction()
                    .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                    .freezeWith(env.client)
                    .sign(receiverKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        // Reclaim already claimed airdrop
        let err = false;
        try {
            await (
                await (
                    await new TokenClaimAirdropTransaction()
                        .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                        .freezeWith(env.client)
                        .sign(receiverKey)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes("INVALID_PENDING_AIRDROP_ID");
        }
        expect(err).to.be.true;
    });

    it("should not be able to claim the tokens with empty list", async function () {
        let err = false;
        try {
            await new TokenClaimAirdropTransaction().execute(env.client);
        } catch (error) {
            err = error.message.includes("EMPTY_PENDING_AIRDROP_ID_LIST");
        }
        expect(err).to.be.true;
    });

    it("should not claim the tokens with duplicate entries", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(100),
        );

        const { accountId: receiverId } = await createAccount(env.client);

        const { newPendingAirdrops } = await (
            await new TokenAirdropTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -100)
                .addTokenTransfer(tokenId, receiverId, 100)
                .execute(env.client)
        ).getRecord(env.client);

        let err = false;
        try {
            await new TokenClaimAirdropTransaction()
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .addPendingAirdropId(newPendingAirdrops[0].airdropId)
                .execute(env.client);
        } catch (error) {
            err = error.message.includes("PENDING_AIRDROP_ID_REPEATED");
        }

        expect(err).to.be.true;
    });

    it("should not be able to claim tokens when token is paused", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(100),
        );

        await (
            await new TokenPauseTransaction()
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);

        const { accountId: receiverId } = await createAccount(env.client);

        let err = false;
        try {
            await (
                await new TokenAirdropTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -100)
                    .addTokenTransfer(tokenId, receiverId, 100)
                    .execute(env.client)
            ).getRecord(env.client);
        } catch (error) {
            err = error.message.includes("TOKEN_IS_PAUSED");
        }
        expect(err).to.be.true;
    });

    it("should not be able to claim tokens when token is deleted", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(100),
        );

        await (
            await new TokenDeleteTransaction()
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);

        const { accountId: receiverId } = await createAccount(env.client);

        let err = false;
        try {
            await (
                await new TokenAirdropTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -100)
                    .addTokenTransfer(tokenId, receiverId, 100)
                    .execute(env.client)
            ).getRecord(env.client);
        } catch (error) {
            err = error.message.includes("TOKEN_WAS_DELETED");
        }
        expect(err).to.be.true;
    });

    it("should not be able to claim tokens when token is frozen", async function () {
        const tokenId = await createFungibleToken(env.client, (transaction) =>
            transaction.setInitialSupply(100),
        );

        const { accountId: receiverId, newKey: receiverKey } =
            await createAccount(env.client);

        await (
            await new TokenAssociateTransaction()
                .setAccountId(receiverId)
                .setTokenIds([tokenId])
                .freezeWith(env.client)
                .sign(receiverKey)
        ).execute(env.client);

        await (
            await new TokenFreezeTransaction()
                .setAccountId(receiverId)
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);

        let err = false;
        try {
            await (
                await new TokenAirdropTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -100)
                    .addTokenTransfer(tokenId, receiverId, 100)
                    .execute(env.client)
            ).getRecord(env.client);
        } catch (error) {
            err = error.message.includes("ACCOUNT_FROZEN_FOR_TOKEN");
        }
        expect(err).to.be.true;
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenCreateIntegrationTest.js
import {
    PrivateKey,
    Status,
    Timestamp,
    TokenCreateTransaction,
    TokenDeleteTransaction,
    TokenInfoQuery,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { DEFAULT_AUTO_RENEW_PERIOD } from "../../src/transaction/Transaction.js";

describe("TokenCreate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();
        const key4 = PrivateKey.generateED25519();

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(key1)
            .setFreezeKey(key2)
            .setWipeKey(key3)
            .setSupplyKey(key4)
            .setFreezeDefault(false)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const info = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(info.tokenId.toString()).to.eql(tokenId.toString());
        expect(info.name).to.eql("ffff");
        expect(info.symbol).to.eql("F");
        expect(info.decimals).to.eql(3);
        expect(info.totalSupply.toInt()).to.eql(1000000);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.kycKey.toString()).to.eql(key1.publicKey.toString());
        expect(info.freezeKey.toString()).to.eql(key2.publicKey.toString());
        expect(info.wipeKey.toString()).to.eql(key3.publicKey.toString());
        expect(info.supplyKey.toString()).to.eql(key4.publicKey.toString());
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.eql(
            DEFAULT_AUTO_RENEW_PERIOD.toInt(),
        );
        expect(info.defaultFreezeStatus).to.be.false;
        expect(info.defaultKycStatus).to.be.false;
        expect(info.isDeleted).to.be.false;
        expect(info.expirationTime).to.be.not.null;
    });

    it("should be executable with minimal properties set", async function () {
        const operatorId = env.operatorId;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const info = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(info.tokenId.toString()).to.eql(tokenId.toString());
        expect(info.name).to.eql("ffff");
        expect(info.symbol).to.eql("F");
        expect(info.decimals).to.eql(0);
        expect(info.totalSupply.toInt()).to.eql(0);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.autoRenewAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.eql(
            DEFAULT_AUTO_RENEW_PERIOD.toInt(),
        );
        expect(info.kycKey).to.be.null;
        expect(info.freezeKey).to.be.null;
        expect(info.wipeKey).to.be.null;
        expect(info.supplyKey).to.be.null;
        expect(info.defaultFreezeStatus).to.be.null;
        expect(info.defaultKycStatus).to.be.null;
        expect(info.isDeleted).to.be.false;
        expect(info.expirationTime).to.be.not.null;

        let err = false;

        try {
            await (
                await new TokenDeleteTransaction()
                    .setTokenId(tokenId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.TokenIsImmutable);
        }

        if (!err) {
            throw new Error("token deletion did not error");
        }
    });

    it("when autoRenewAccountId is set", async function () {
        const operatorId = env.operatorId;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const info = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
    });

    it("when expirationTime is set", async function () {
        const operatorId = env.operatorId;
        const DAYS_45_IN_SECONDS = 3888000;
        const expirationTime = new Timestamp(
            Math.floor(Date.now() / 1000 + DAYS_45_IN_SECONDS),
            0,
        );

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .setExpirationTime(expirationTime)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const info = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(info.expirationTime).to.be.not.null;
        expect(info.expirationTime.toString()).to.be.eql(
            expirationTime.toString(),
        );
    });

    it("expirationTime should override autoRenewPeriod", async function () {
        const operatorId = env.operatorId;
        const DAYS_90_IN_SECONDS = 7776000;
        const expirationTime = new Timestamp(
            Math.floor(Date.now() / 1000 + DAYS_90_IN_SECONDS),
            0,
        );

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .setExpirationTime(expirationTime)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const info = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.equal(0);
        expect(info.expirationTime.seconds.toInt()).to.equal(
            expirationTime.seconds.toInt(),
        );
    });

    it("should error when token name is not set", async function () {
        const env = await IntegrationTestEnv.new();
        const operatorId = env.operatorId;

        let err = false;

        try {
            await (
                await new TokenCreateTransaction()
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(operatorId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.MissingTokenName);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }
    });

    it("should error when token symbol is not set", async function () {
        const operatorId = env.operatorId;

        let err = false;

        try {
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTreasuryAccountId(operatorId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.MissingTokenSymbol);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }
    });

    it("should error when treasury account ID is not set", async function () {
        let err = false;

        try {
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.InvalidTreasuryAccountForToken);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }
    });

    it("should error when admin key does not sign transaction", async function () {
        const operatorId = env.operatorId;

        let err = false;

        try {
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(PrivateKey.generateED25519())
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature);
        }

        if (!err) {
            throw new Error("token creation did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenDeleteIntegrationTest.js
import { TokenDeleteTransaction, Status } from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createFungibleToken } from "./utils/Fixtures.js";

describe("TokenDelete", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const tokenId = await createFungibleToken(env.client);

        await (
            await new TokenDeleteTransaction()
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error with no token ID set", async function () {
        let err = false;

        try {
            await (
                await new TokenDeleteTransaction().execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token deletion did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenDissociateIntegrationTest.js
import {
    AccountBalanceQuery,
    AccountInfoQuery,
    Status,
    TokenAssociateTransaction,
    TokenDissociateTransaction,
    TokenGrantKycTransaction,
    TokenMintTransaction,
    TransferTransaction,
    Hbar,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import {
    createAccount,
    createFungibleToken,
    createNonFungibleToken,
} from "./utils/Fixtures.js";

describe("TokenDissociate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const { accountId: account, newKey: key } = await createAccount(
            env.client,
            (transaction) => transaction.setInitialBalance(new Hbar(2)),
        );

        const token = await createFungibleToken(env.client, (transaction) => {
            transaction.setKycKey(env.client.operatorPublicKey);
        });

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let balances = await new AccountBalanceQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(balances.tokens.get(token).toInt()).to.be.equal(0);

        let info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        const relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.false;
        expect(relationship.isFrozen).to.be.false;

        await (
            await (
                await new TokenDissociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        balances = await new AccountBalanceQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(balances.tokens.get(token)).to.be.null;

        info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(info.tokenRelationships.get(token)).to.be.null;
    });

    it("should be executable even when no token IDs are set", async function () {
        const operatorId = env.operatorId;

        await (
            await new TokenDissociateTransaction()
                .setAccountId(operatorId)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when account ID is not set", async function () {
        const env = await IntegrationTestEnv.new();

        const tokenId = await createFungibleToken(env.client);

        let err = false;

        try {
            await (
                await new TokenDissociateTransaction()
                    .setTokenIds([tokenId])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token association did not error");
        }
    });

    it("cannot dissociate account which owns NFTs", async function () {
        const { accountId, newKey: key } = await createAccount(env.client);

        const tokenId = await createNonFungibleToken(
            env.client,
            (transaction) => {
                transaction.setKycKey(env.client.operatorPublicKey);
            },
        );

        await (
            await new TokenMintTransaction()
                .setMetadata([Uint8Array.of([0, 1, 2])])
                .setTokenId(tokenId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([tokenId])
                    .setAccountId(accountId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(tokenId)
                    .setAccountId(accountId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addNftTransfer(tokenId, 1, env.operatorId, accountId)
                .execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await (
                    await new TokenDissociateTransaction()
                        .setTokenIds([tokenId])
                        .setAccountId(accountId)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.AccountStillOwnsNfts);
        }

        if (!err) {
            throw new Error("token update did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenFreezeIntegrationTest.js
import {
    AccountInfoQuery,
    Status,
    TokenAssociateTransaction,
    TokenFreezeTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, createFungibleToken } from "./utils/Fixtures.js";

describe("TokenFreeze", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const { accountId: account, newKey: key } = await createAccount(
            env.client,
        );

        const token = await createFungibleToken(env.client, (transaction) =>
            transaction.setKycKey(env.client.operatorPublicKey),
        );

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenFreezeTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        const relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.false;
        expect(relationship.isFrozen).to.be.true;
    });

    it("should be executable with no tokens set", async function () {
        const { accountId: account, newKey: key } = await createAccount(
            env.client,
        );

        let err = false;

        try {
            await (
                await (
                    await new TokenFreezeTransaction()
                        .setAccountId(account)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token freeze did not error");
        }
    });

    it("should error when account ID is not set", async function () {
        const token = await createFungibleToken(env.client);

        let err = false;

        try {
            await (
                await new TokenFreezeTransaction()
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token freeze did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenGrantKycIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenGrantKyc", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        const relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.true;
        expect(relationship.isFrozen).to.be.false;
    });

    it("should be executable even when no token IDs are set", async function () {
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        let err = false;

        try {
            await (
                await (
                    await new TokenGrantKycTransaction()
                        .setAccountId(account)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token grant kyc did not error");
        }
    });

    it("should error when account ID is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token association did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenInfoIntegrationTest.js
import {
    AccountCreateTransaction,
    Hbar,
    PrivateKey,
    Status,
    TokenCreateTransaction,
    TokenInfoQuery,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenInfo", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();
        const key4 = PrivateKey.generateED25519();
        const key5 = PrivateKey.generateED25519();

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(key1)
            .setFreezeKey(key2)
            .setWipeKey(key3)
            .setSupplyKey(key4)
            .setMetadataKey(key5)
            .setFreezeDefault(false)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const info = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(info.tokenId.toString()).to.eql(tokenId.toString());
        expect(info.name).to.eql("ffff");
        expect(info.symbol).to.eql("F");
        expect(info.decimals).to.eql(3);
        expect(info.totalSupply.toInt()).to.eql(1000000);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.kycKey.toString()).to.eql(key1.publicKey.toString());
        expect(info.freezeKey.toString()).to.eql(key2.publicKey.toString());
        expect(info.wipeKey.toString()).to.eql(key3.publicKey.toString());
        expect(info.supplyKey.toString()).to.eql(key4.publicKey.toString());
        expect(info.metadataKey.toString()).to.eql(key5.publicKey.toString());
        expect(info.autoRenewAccountId.toString()).to.eql(
            operatorId.toString(),
        );
        expect(info.defaultFreezeStatus).to.be.false;
        expect(info.defaultKycStatus).to.be.false;
        expect(info.isDeleted).to.be.false;

        expect(info.autoRenewPeriod).to.be.not.null;
        expect(info.expirationTime).to.be.not.null;
    });

    it("should be executable with minimal properties set", async function () {
        const operatorId = env.operatorId;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let info = await new TokenInfoQuery()
            .setTokenId(token)
            .execute(env.client);

        expect(info.tokenId.toString()).to.eql(token.toString());
        expect(info.name).to.eql("ffff");
        expect(info.symbol).to.eql("F");
        expect(info.decimals).to.eql(0);
        expect(info.totalSupply.toInt()).to.eql(0);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.adminKey).to.be.null;
        expect(info.kycKey).to.be.null;
        expect(info.freezeKey).to.be.null;
        expect(info.wipeKey).to.be.null;
        expect(info.supplyKey).to.be.null;
        expect(info.metadataKey).to.be.null;
        expect(info.defaultFreezeStatus).to.be.null;
        expect(info.defaultKycStatus).to.be.null;
        expect(info.isDeleted).to.be.false;
        expect(info.autoRenewPeriod).to.be.not.null;
        expect(info.expirationTime).to.be.not.null;
    });

    it("should be able to query cost", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();
        const key4 = PrivateKey.generateED25519();

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(key1)
            .setFreezeKey(key2)
            .setWipeKey(key3)
            .setSupplyKey(key4)
            .setFreezeDefault(false)
            .execute(env.client);

        const tokenId = (await response.getReceipt(env.client)).tokenId;

        const cost = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    it("should error when token ID is not set", async function () {
        let err = false;

        try {
            await new TokenInfoQuery().execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token info query did not error");
        }
    });

    it("should set autorenew account from transaction ID", async function () {
        // Create a new account with 10 Hbar
        const accountKey = PrivateKey.generateECDSA();
        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(accountKey.publicKey)
            .setInitialBalance(new Hbar(10))
            .execute(env.client);

        const { accountId } = await response.getReceipt(env.client);

        // Create transaction ID with the new account
        const txId = TransactionId.generate(accountId);

        const { tokenId } = await (
            await (
                await new TokenCreateTransaction()
                    .setTransactionId(txId)
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setTreasuryAccountId(accountId)
                    .freezeWith(env.client)
                    .sign(accountKey)
            ).execute(env.client)
        ).getReceipt(env.client);

        console.log("tokenId", tokenId);
        // Query token info
        const info = await new TokenInfoQuery()

            .setTokenId(tokenId)
            .execute(env.client);

        // Verify autoRenewAccountId matches the account that created the token
        expect(info.autoRenewAccountId.toString()).to.equal(
            accountId.toString(),
        );
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenMintIntegrationTest.js
import {
    Status,
    TokenCreateTransaction,
    TokenMintTransaction,
    TokenSupplyType,
    TokenType,
    Transaction,
    TokenInfoQuery,
    Long,
} from "../../src/exports.js";
import { wait } from "../../src/util.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenMint", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        await (
            await new TokenMintTransaction()
                .setAmount(10)
                .setTokenId(token)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("toBytes/fromBytes", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let mint = new TokenMintTransaction()
            .setAmount(10)
            .setTokenId(token)
            .freezeWith(env.client);

        let mintBytes = mint.toBytes();

        let mintFromBytes = Transaction.fromBytes(mintBytes);

        await (await mintFromBytes.execute(env.client)).getReceipt(env.client);
    });

    it("should error when token ID is not set", async function () {
        let err = false;

        try {
            await (
                await new TokenMintTransaction()
                    .setAmount(10)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token Mint did not error");
        }
    });

    it("should not error when amount is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error;
        }

        if (err) {
            throw new Error("token mint did error");
        }
    });

    it("User cannot mint more than the tokens defined max supply value", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(0)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .setMaxSupply(10)
            .setSupplyType(TokenSupplyType.Finite)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenMintTransaction()
                    .setAmount(11)
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.TokenMaxSupplyReached);
        }

        if (!err) {
            throw new Error("token mint did not error");
        }
    });

    it("cannot mint token with invalid metadata", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .setMaxSupply(10)
            .setTokenType(TokenType.NonFungibleUnique)
            .setSupplyType(TokenSupplyType.Finite)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .setAmount(1)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenMintMetadata);
        }

        if (!err) {
            throw new Error("token mint did not error");
        }
    });

    it("should retrieve the correct token balance", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const tokenCreateTransaction = await new TokenCreateTransaction()
            .setTokenName("Token")
            .setTokenSymbol("T")
            .setTokenType(TokenType.FungibleCommon)
            .setDecimals(8)
            .setTreasuryAccountId(operatorId)
            .setSupplyKey(operatorKey)
            .execute(env.client);

        const tokenCreateTransactionReceipt =
            await tokenCreateTransaction.getReceipt(env.client);
        const tokenId = tokenCreateTransactionReceipt.tokenId;

        const amount = Long.fromValue("25817858423044461");

        await new TokenMintTransaction()
            .setTokenId(tokenId)
            .setAmount(amount)
            .execute(env.client);

        await wait(5000);

        const tokenInfo = await new TokenInfoQuery()
            .setTokenId(tokenId)
            .execute(env.client);

        expect(tokenInfo.totalSupply.toString()).to.be.equal(amount.toString());
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenNftIntegrationTest.js
import {
    AccountCreateTransaction,
    Hbar,
    NftId,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenBurnTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
    TokenMintTransaction,
    TokenNftInfoQuery,
    TokenType,
    TokenWipeTransaction,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenNft", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("Should be able to transfer NFT", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const serial = serials[0];

        let info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(
            env.operatorId.toString(),
        );

        await (
            await new TransferTransaction()
                .addNftTransfer(token, serial, env.operatorId, account)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(account.toString());

        await (
            await new TokenWipeTransaction()
                .setTokenId(token)
                .setAccountId(account)
                .setSerials([serial])
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TokenBurnTransaction()
                .setTokenId(token)
                .setSerials([serials[1]])
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be able to query cost", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const serial = serials[0];

        let cost = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    it("Cannot burn NFTs when NFT is not owned by treasury", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .addMetadata(Uint8Array.of(0x01))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        const serial = serials[0];

        let info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(
            env.operatorId.toString(),
        );

        await (
            await new TransferTransaction()
                .addNftTransfer(token, serial, env.operatorId, account)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(account.toString());

        let err = false;

        try {
            await (
                await new TokenBurnTransaction()
                    .setTokenId(token)
                    .setSerials([serials[0]])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.TreasuryMustOwnBurnedNft);
        }

        expect(err).to.be.true;
    });

    it("Cannot mint NFTs if metadata too big", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .addMetadata(
                        Uint8Array.of(
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                            0x00,
                        ),
                    )
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.MetadataTooLong);
        }

        expect(err).to.be.true;
    });

    it("Cannot query NFT info by invalid NftId", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TokenMintTransaction()
                .setTokenId(token)
                .addMetadata(Uint8Array.of(0x01))
                .addMetadata(Uint8Array.of(0x02))
                .execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await new TokenNftInfoQuery()
                .setNftId(new NftId(token, 3))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidNftId);
        }

        expect(err).to.be.true;
    });

    it("Cannot query NFT info by invalid NftId Serial Number", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await new TokenNftInfoQuery()
                .setNftId(new NftId(token, 0))
                .execute(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenNftSerialNumber);
        }

        expect(err).to.be.true;
    });

    it("Cannot transfer NFTs you don't own", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        let serial = serials[0];

        let info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(
            env.operatorId.toString(),
        );

        await (
            await new TransferTransaction()
                .addNftTransfer(token, serial, env.operatorId, account)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(account.toString());

        serial = serials[1];

        let err = false;

        try {
            await (
                await (
                    await new TransferTransaction()
                        .addNftTransfer(token, serial, account, env.operatorId)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.SenderDoesNotOwnNftSerialNo);
        }

        expect(err).to.be.true;

        serial = serials[0];

        await (
            await new TokenWipeTransaction()
                .setTokenId(token)
                .setAccountId(account)
                .setSerials([serial])
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("Cannot wipe accounts NFTs if the account doesn't own them", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key)
                    .setInitialBalance(new Hbar(2))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        const serials = (
            await (
                await new TokenMintTransaction()
                    .setTokenId(token)
                    .addMetadata(Uint8Array.of(0x01))
                    .addMetadata(Uint8Array.of(0x02))
                    .execute(env.client)
            ).getReceipt(env.client)
        ).serials;

        let serial = serials[0];

        let info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(
            env.operatorId.toString(),
        );

        await (
            await new TransferTransaction()
                .addNftTransfer(token, serial, env.operatorId, account)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new TokenNftInfoQuery()
            .setNftId(new NftId(token, serial))
            .execute(env.client);

        expect(info[0].accountId.toString()).to.be.equal(account.toString());

        serial = serials[1];

        let err = false;

        try {
            await (
                await new TokenWipeTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .setSerials([serial])
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.AccountDoesNotOwnWipedNft);
        }

        expect(err).to.be.true;
    });

    after(function () {
        env.client.close();
    });
});
// Filename: test/integration/TokenNftsUpdateTransactionIntegrationTest.js
import {
    TokenCreateTransaction,
    TokenType,
    PrivateKey,
    TokenMintTransaction,
    TokenUpdateNftsTransaction,
    TokenNftInfoQuery,
    NftId,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenUpdateNftsTransaction", function () {
    let client,
        operatorId,
        operatorKey,
        metadata,
        newMetadata,
        metadataKey,
        tokenName,
        tokenSymbol,
        supplyKey,
        wrongMetadataKey,
        nftCount;

    before(async function () {
        const env = await IntegrationTestEnv.new();
        client = env.client;
        operatorId = env.operatorId;
        operatorKey = env.operatorKey;
        metadata = new Uint8Array([1]);
        newMetadata = new Uint8Array([1, 2]);
        metadataKey = PrivateKey.generateECDSA();
        supplyKey = PrivateKey.generateECDSA();
        tokenName = "Test";
        tokenSymbol = "T";
        wrongMetadataKey = PrivateKey.generateECDSA();
        nftCount = 4;
    });

    it("should update the metadata of entire NFT collection", async function () {
        const createTokenTx = new TokenCreateTransaction()
            .setTokenName(tokenName)
            .setTokenSymbol(tokenSymbol)
            .setAdminKey(operatorKey)
            .setSupplyKey(supplyKey)
            .setMetadataKey(metadataKey)
            .setTreasuryAccountId(operatorId)
            .setTokenType(TokenType.NonFungibleUnique);

        const createTokenTxResponse = await createTokenTx.execute(client);
        const createTokenTxReceipt =
            await createTokenTxResponse.getReceipt(client);
        const tokenId = createTokenTxReceipt.tokenId;

        const tokenMintTx = new TokenMintTransaction()
            .setMetadata(generateMetadataList(metadata, nftCount))
            .setTokenId(tokenId)
            .freezeWith(client);

        const tokenMintResponse = await (
            await tokenMintTx.sign(supplyKey)
        ).execute(client);
        const tokenMintReceipt = await tokenMintResponse.getReceipt(client);
        const serials = tokenMintReceipt.serials;

        const metadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            metadatas.every(
                (mt) => mt === Buffer.from(metadata).toString("hex"),
            ),
        ).to.be.true;

        await (
            await (
                await new TokenUpdateNftsTransaction()
                    .setTokenId(tokenId)
                    .setSerialNumbers(serials)
                    .setMetadata(newMetadata)
                    .freezeWith(client)
                    .sign(metadataKey)
            ).execute(client)
        ).getReceipt(client);

        const newMetadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            newMetadatas.every(
                (mt) => mt === Buffer.from(newMetadata).toString("hex"),
            ),
        ).to.be.true;
    });

    it("should update the NFT's metadata", async function () {
        const createTokenTx = new TokenCreateTransaction()
            .setTokenName(tokenName)
            .setTokenSymbol(tokenSymbol)
            .setAdminKey(operatorKey)
            .setSupplyKey(supplyKey)
            .setMetadataKey(metadataKey)
            .setTreasuryAccountId(operatorId)
            .setTokenType(TokenType.NonFungibleUnique);

        const createTokenTxResponse = await createTokenTx.execute(client);
        const createTokenTxReceipt =
            await createTokenTxResponse.getReceipt(client);
        const tokenId = createTokenTxReceipt.tokenId;

        const tokenMintTx = new TokenMintTransaction()
            .setMetadata(generateMetadataList(metadata, nftCount))
            .setTokenId(tokenId)
            .freezeWith(client);

        const tokenMintResponse = await (
            await tokenMintTx.sign(supplyKey)
        ).execute(client);
        const tokenMintReceipt = await tokenMintResponse.getReceipt(client);
        const serials = tokenMintReceipt.serials;

        const metadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            metadatas.every(
                (mt) => mt === Buffer.from(metadata).toString("hex"),
            ),
        ).to.be.true;

        await (
            await (
                await new TokenUpdateNftsTransaction()
                    .setTokenId(tokenId)
                    .setSerialNumbers([serials[0], serials[1]])
                    .setMetadata(newMetadata)
                    .freezeWith(client)
                    .sign(metadataKey)
            ).execute(client)
        ).getReceipt(client);

        const newMetadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            newMetadatas.map(
                (mt) => mt === Buffer.from(newMetadata).toString("hex"),
            ),
        ).to.deep.eql([true, true, false, false]);
    });

    it("should NOT update the NFT's metadata", async function () {
        const createTokenTx = new TokenCreateTransaction()
            .setTokenName(tokenName)
            .setTokenSymbol(tokenSymbol)
            .setAdminKey(operatorKey)
            .setSupplyKey(supplyKey)
            .setMetadataKey(metadataKey)
            .setTreasuryAccountId(operatorId)
            .setTokenType(TokenType.NonFungibleUnique);

        const createTokenTxResponse = await createTokenTx.execute(client);
        const createTokenTxReceipt =
            await createTokenTxResponse.getReceipt(client);
        const tokenId = createTokenTxReceipt.tokenId;

        const tokenMintTx = new TokenMintTransaction()
            .setMetadata(generateMetadataList(metadata, nftCount))
            .setTokenId(tokenId)
            .freezeWith(client);

        const tokenMintResponse = await (
            await tokenMintTx.sign(supplyKey)
        ).execute(client);
        const tokenMintReceipt = await tokenMintResponse.getReceipt(client);
        const serials = tokenMintReceipt.serials;

        const metadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            metadatas.every(
                (mt) => mt === Buffer.from(metadata).toString("hex"),
            ),
        ).to.be.true;

        await (
            await (
                await new TokenUpdateNftsTransaction()
                    .setTokenId(tokenId)
                    .setSerialNumbers(serials)
                    .freezeWith(client)
                    .sign(metadataKey)
            ).execute(client)
        ).getReceipt(client);

        const sameMetadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            sameMetadatas.every(
                (mt) => mt === Buffer.from(metadata).toString("hex"),
            ),
        ).to.be.true;
    });

    it("should earse the metadata of entire NFT collection", async function () {
        const createTokenTx = new TokenCreateTransaction()
            .setTokenName(tokenName)
            .setTokenSymbol(tokenSymbol)
            .setAdminKey(operatorKey)
            .setSupplyKey(supplyKey)
            .setMetadataKey(metadataKey)
            .setTreasuryAccountId(operatorId)
            .setTokenType(TokenType.NonFungibleUnique);

        const createTokenTxResponse = await createTokenTx.execute(client);
        const createTokenTxReceipt =
            await createTokenTxResponse.getReceipt(client);
        const tokenId = createTokenTxReceipt.tokenId;

        const tokenMintTx = new TokenMintTransaction()
            .setMetadata(generateMetadataList(metadata, nftCount))
            .setTokenId(tokenId)
            .freezeWith(client);

        const tokenMintResponse = await (
            await tokenMintTx.sign(supplyKey)
        ).execute(client);
        const tokenMintReceipt = await tokenMintResponse.getReceipt(client);
        const serials = tokenMintReceipt.serials;

        const metadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            metadatas.every(
                (mt) => mt === Buffer.from(metadata).toString("hex"),
            ),
        ).to.be.true;

        await (
            await (
                await new TokenUpdateNftsTransaction()
                    .setTokenId(tokenId)
                    .setMetadata([])
                    .setSerialNumbers(serials)
                    .freezeWith(client)
                    .sign(metadataKey)
            ).execute(client)
        ).getReceipt(client);

        const sameMetadatas = await geNftsMetadata(client, tokenId, serials);
        expect(
            sameMetadatas.every(
                (mt) => mt === Buffer.from(new Uint8Array()).toString("hex"),
            ),
        ).to.be.true;
    });

    it("should NOT update the NFTs metadata if the metadataKey is NOT set", async function () {
        try {
            const createTokenTx = new TokenCreateTransaction()
                .setTokenName(tokenName)
                .setTokenSymbol(tokenSymbol)
                .setAdminKey(operatorKey)
                .setSupplyKey(supplyKey)
                .setTreasuryAccountId(operatorId)
                .setTokenType(TokenType.NonFungibleUnique);

            const createTokenTxResponse = await createTokenTx.execute(client);
            const createTokenTxReceipt =
                await createTokenTxResponse.getReceipt(client);
            const tokenId = createTokenTxReceipt.tokenId;

            const tokenMintTx = new TokenMintTransaction()
                .setMetadata(generateMetadataList(metadata, nftCount))
                .setTokenId(tokenId)
                .freezeWith(client);

            const tokenMintResponse = await (
                await tokenMintTx.sign(supplyKey)
            ).execute(client);
            const tokenMintReceipt = await tokenMintResponse.getReceipt(client);

            const serials = tokenMintReceipt.serials;

            const tokenUpdateNftsTx = new TokenUpdateNftsTransaction()
                .setTokenId(tokenId)
                .setSerialNumbers(serials)
                .setMetadata(newMetadata)
                .freezeWith(client);

            await (
                await (
                    await tokenUpdateNftsTx.sign(metadataKey)
                ).execute(client)
            ).getReceipt(client);
        } catch (error) {
            expect(error.status).to.be.eql(Status.InvalidSignature);
        }
    });

    it("should NOT update the NFTs metadata when the transaction is not signed with the metadataKey", async function () {
        try {
            const createTokenTx = new TokenCreateTransaction()
                .setTokenName(tokenName)
                .setTokenSymbol(tokenSymbol)
                .setAdminKey(operatorKey)
                .setMetadataKey(metadataKey)
                .setSupplyKey(supplyKey)
                .setTreasuryAccountId(operatorId)
                .setTokenType(TokenType.NonFungibleUnique);

            const createTokenTxResponse = await createTokenTx.execute(client);
            const createTokenTxReceipt =
                await createTokenTxResponse.getReceipt(client);
            const tokenId = createTokenTxReceipt.tokenId;

            const tokenMintTx = new TokenMintTransaction()
                .setMetadata(generateMetadataList(metadata, nftCount))
                .setTokenId(tokenId)
                .freezeWith(client);

            const tokenMintResponse = await (
                await tokenMintTx.sign(supplyKey)
            ).execute(client);
            const tokenMintReceipt = await tokenMintResponse.getReceipt(client);

            const serials = tokenMintReceipt.serials;

            const tokenUpdateNftsTx = new TokenUpdateNftsTransaction()
                .setTokenId(tokenId)
                .setSerialNumbers(serials)
                .setMetadata(newMetadata)
                .freezeWith(client);

            await (
                await (
                    await tokenUpdateNftsTx.sign(wrongMetadataKey)
                ).execute(client)
            ).getReceipt(client);
        } catch (error) {
            expect(error.status).to.be.eql(Status.InvalidSignature);
        }
    });
});

function generateMetadataList(metadata, count) {
    const list = [];

    for (let index = 0; index < count; index++) {
        list.push(metadata);
    }
    return list;
}

async function geNftsMetadata(client, tokenId, serials) {
    const metadatas = [];

    for (let index = 0; index < serials.length; index++) {
        const nftId = new NftId(tokenId, serials[index]);
        const nftInfo = await new TokenNftInfoQuery()
            .setNftId(nftId)
            .execute(client);
        metadatas.push(nftInfo[0].metadata.toString("hex"));
    }

    return metadatas;
}
// Filename: test/integration/TokenRejectFlowIntegrationTest.js
import {
    AccountBalanceQuery,
    AccountCreateTransaction,
    Hbar,
    NftId,
    PrivateKey,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenMintTransaction,
    TokenRejectFlow,
    TokenType,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenRejectIntegrationTest", function () {
    let env;

    it("can execute TokenRejectFlow for fungible tokens", async function () {
        env = await IntegrationTestEnv.new();
        const FULL_TREASURY_BALANCE = 1000000;

        // create token
        const tokenCreateTx = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(FULL_TREASURY_BALANCE)
            .setTreasuryAccountId(env.operatorId)
            .setPauseKey(env.operatorKey)
            .setAdminKey(env.operatorKey)
            .setSupplyKey(env.operatorKey)
            .execute(env.client);

        let tokenId1 = (await tokenCreateTx.getReceipt(env.client)).tokenId;

        // create token
        const tokenCreateTx2 = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(env.operatorId)
            .setPauseKey(env.operatorKey)
            .setAdminKey(env.operatorKey)
            .setSupplyKey(env.operatorKey)
            .execute(env.client);

        let tokenId2 = (await tokenCreateTx2.getReceipt(env.client)).tokenId;
        // create receiver account
        let receiverPrivateKey = await PrivateKey.generateECDSA();
        const receiverCreateAccount = await new AccountCreateTransaction()
            .setKeyWithoutAlias(receiverPrivateKey)
            .setInitialBalance(new Hbar(1))
            .execute(env.client);

        let receiverId = (await receiverCreateAccount.getReceipt(env.client))
            .accountId;

        await (
            await new TokenAssociateTransaction()
                .setAccountId(receiverId)
                .setTokenIds([tokenId1, tokenId2])
                .freezeWith(env.client)
                .sign(receiverPrivateKey)
        ).execute(env.client);

        await (
            await new TransferTransaction()
                .addTokenTransfer(tokenId1, env.operatorId, -100)
                .addTokenTransfer(tokenId1, receiverId, 100)
                .addTokenTransfer(tokenId2, env.operatorId, -100)
                .addTokenTransfer(tokenId2, receiverId, 100)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TokenRejectFlow()
                .setOwnerId(receiverId)
                .setTokenIds([tokenId1, tokenId2])
                .freezeWith(env.client)
                .sign(receiverPrivateKey)
        ).execute(env.client);

        const receiverBalanceQuery = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        const treasuryBalanceQuery = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(receiverBalanceQuery.tokens.get(tokenId1)).to.be.eq(null);
        expect(receiverBalanceQuery.tokens.get(tokenId2)).to.be.eq(null);
        expect(treasuryBalanceQuery.tokens.get(tokenId1).toInt()).to.be.eq(
            FULL_TREASURY_BALANCE,
        );
        expect(treasuryBalanceQuery.tokens.get(tokenId2).toInt()).to.be.eq(
            FULL_TREASURY_BALANCE,
        );

        let err;
        try {
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId1, receiverId, 100)
                    .addTokenTransfer(tokenId1, env.operatorId, -100)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes("TOKEN_NOT_ASSOCIATED_TO_ACCOUNT");
        }

        if (!err) {
            throw new Error(
                "Token should not be associated with receiver account",
            );
        }
    });

    it("can execute TokenRejectFlow for non-fungible tokens", async function () {
        env = await IntegrationTestEnv.new();

        // create token
        const tokenCreateTx = await new TokenCreateTransaction()
            .setTokenType(TokenType.NonFungibleUnique)
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(env.operatorId)
            .setPauseKey(env.operatorKey)
            .setAdminKey(env.operatorKey)
            .setSupplyKey(env.operatorKey)
            .execute(env.client);

        let { tokenId } = await tokenCreateTx.getReceipt(env.client);

        // create receiver account
        let receiverPrivateKey = await PrivateKey.generateECDSA();
        const receiverCreateAccount = await new AccountCreateTransaction()
            .setKeyWithoutAlias(receiverPrivateKey)
            .setInitialBalance(new Hbar(1))
            .execute(env.client);

        let { accountId: receiverId } = await receiverCreateAccount.getReceipt(
            env.client,
        );

        await (
            await new TokenAssociateTransaction()
                .setAccountId(receiverId)
                .setTokenIds([tokenId])
                .freezeWith(env.client)
                .sign(receiverPrivateKey)
        ).execute(env.client);

        await new TokenMintTransaction()
            .setTokenId(tokenId)
            .addMetadata(Buffer.from("====="))
            .execute(env.client);

        const nftId = new NftId(tokenId, 1);
        await (
            await new TransferTransaction()
                .addNftTransfer(nftId, env.operatorId, receiverId)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TokenRejectFlow()
                .setOwnerId(receiverId)
                .setNftIds([nftId])
                .freezeWith(env.client)
                .sign(receiverPrivateKey)
        ).execute(env.client);

        const receiverBalanceQuery = await new AccountBalanceQuery()
            .setAccountId(receiverId)
            .execute(env.client);

        const treasuryBalanceQuery = await new AccountBalanceQuery()
            .setAccountId(env.operatorId)
            .execute(env.client);

        expect(receiverBalanceQuery.tokens.get(tokenId)).to.eq(null);
        expect(treasuryBalanceQuery.tokens.get(tokenId).toInt()).to.be.eq(1);

        let err;
        try {
            await (
                await new TransferTransaction()
                    .addNftTransfer(nftId, env.operatorId, receiverId)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.message.includes("TOKEN_NOT_ASSOCIATED_TO_ACCOUNT");
        }

        if (!err) {
            throw new Error(
                "Token should not be associated with receiver account",
            );
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenRejectIntegrationTest.js
import { expect } from "chai";
import {
    AccountAllowanceApproveTransaction,
    AccountBalanceQuery,
    AccountCreateTransaction,
    AccountUpdateTransaction,
    Hbar,
    NftId,
    PrivateKey,
    TokenCreateTransaction,
    TokenFreezeTransaction,
    TokenMintTransaction,
    TokenPauseTransaction,
    TokenRejectTransaction,
    TokenType,
    TransactionId,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenRejectIntegrationTest", function () {
    let env, tokenId, receiverId, receiverPrivateKey;
    const INITIAL_SUPPLY = 1000000;

    describe("Fungible Tokens", function () {
        beforeEach(async function () {
            env = await IntegrationTestEnv.new();

            // create token
            const tokenCreateResponse = await new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(INITIAL_SUPPLY)
                .setTreasuryAccountId(env.operatorId)
                .setPauseKey(env.operatorKey)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .setFreezeKey(env.operatorKey)
                .execute(env.client);

            tokenId = (await tokenCreateResponse.getReceipt(env.client))
                .tokenId;

            // create receiver account
            receiverPrivateKey = await PrivateKey.generateECDSA();
            const receiverCreateAccount = await new AccountCreateTransaction()
                .setKeyWithoutAlias(receiverPrivateKey)
                .setInitialBalance(new Hbar(1))
                .setMaxAutomaticTokenAssociations(-1)
                .execute(env.client);

            receiverId = (await receiverCreateAccount.getReceipt(env.client))
                .accountId;
        });

        it("should execute TokenReject Tx", async function () {
            // create another token
            const tokenCreateResponse2 = await new TokenCreateTransaction()
                .setTokenName("ffff2")
                .setTokenSymbol("F2")
                .setDecimals(3)
                .setInitialSupply(INITIAL_SUPPLY)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .execute(env.client);

            const { tokenId: tokenId2 } = await tokenCreateResponse2.getReceipt(
                env.client,
            );

            // transfer tokens of both types to receiver
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -1)
                    .addTokenTransfer(tokenId, receiverId, 1)
                    .addTokenTransfer(tokenId2, env.operatorId, -1)
                    .addTokenTransfer(tokenId2, receiverId, 1)
                    .execute(env.client)
            ).getReceipt(env.client);

            // reject tokens
            await (
                await (
                    await new TokenRejectTransaction()
                        .setTokenIds([tokenId, tokenId2])
                        .setOwnerId(receiverId)
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            const tokenBalanceReceiverQuery = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);

            const tokenBalanceReceiver = tokenBalanceReceiverQuery.tokens
                .get(tokenId)
                .toInt();
            const tokenBalanceReceiver2 = tokenBalanceReceiverQuery.tokens
                .get(tokenId2)
                .toInt();

            const tokenBalanceTreasuryQuery = await new AccountBalanceQuery()
                .setAccountId(env.operatorId)
                .execute(env.client);

            const tokenBalanceTreasury = tokenBalanceTreasuryQuery.tokens
                .get(tokenId)
                .toInt();
            const tokenBalanceTreasury2 = tokenBalanceTreasuryQuery.tokens
                .get(tokenId)
                .toInt();

            expect(tokenBalanceReceiver).to.be.equal(0);
            expect(tokenBalanceReceiver2).to.be.equal(0);

            expect(tokenBalanceTreasury).to.be.equal(INITIAL_SUPPLY);
            expect(tokenBalanceTreasury2).to.be.equal(INITIAL_SUPPLY);
        });

        it("should return token back when receiver has receiverSigRequired is true", async function () {
            const TREASURY_TOKENS_AMOUNT = 1000000;

            await new AccountUpdateTransaction()
                .setAccountId(env.operatorId)
                .setReceiverSignatureRequired(true)
                .execute(env.client);

            const transferTransactionResponse = await new TransferTransaction()
                .addTokenTransfer(tokenId, env.operatorId, -1)
                .addTokenTransfer(tokenId, receiverId, 1)
                .execute(env.client);

            await transferTransactionResponse.getReceipt(env.client);

            const tokenRejectResponse = await (
                await new TokenRejectTransaction()
                    .addTokenId(tokenId)
                    .setOwnerId(receiverId)
                    .freezeWith(env.client)
                    .sign(receiverPrivateKey)
            ).execute(env.client);

            await tokenRejectResponse.getReceipt(env.client);

            const tokenBalanceTreasuryQuery = await new AccountBalanceQuery()
                .setAccountId(env.operatorId)
                .execute(env.client);

            const tokenBalanceTreasury = tokenBalanceTreasuryQuery.tokens
                .get(tokenId)
                .toInt();
            expect(tokenBalanceTreasury).to.be.equal(TREASURY_TOKENS_AMOUNT);

            const tokenBalanceReceiverQuery = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);
            const tokenBalanceReceiver = tokenBalanceReceiverQuery.tokens
                .get(tokenId)
                .toInt();
            expect(tokenBalanceReceiver).to.equal(0);
        });

        // temporary disabled until issue re nfts will be resolved on services side
        // eslint-disable-next-line mocha/no-skipped-tests
        it.skip("should not return spender allowance to zero after owner rejects FT", async function () {
            const spenderAccountPrivateKey = PrivateKey.generateED25519();
            const spenderAccountResponse = await new AccountCreateTransaction()
                .setMaxAutomaticTokenAssociations(-1)
                .setInitialBalance(new Hbar(10))
                .setKeyWithoutAlias(spenderAccountPrivateKey)
                .execute(env.client);

            const { accountId: spenderAccountId } =
                await spenderAccountResponse.getReceipt(env.client);

            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -1)
                    .addTokenTransfer(tokenId, receiverId, 1)
                    .execute(env.client)
            ).getReceipt(env.client);

            await (
                await (
                    await new AccountAllowanceApproveTransaction()
                        .approveTokenAllowance(
                            tokenId,
                            receiverId,
                            spenderAccountId,
                            10,
                        )
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            await (
                await (
                    await new TokenRejectTransaction()
                        .addTokenId(tokenId)
                        .setOwnerId(receiverId)
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            // Confirm that token reject transaction has returned funds
            const balanceReceiverPre = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);

            const balanceTreasuryPre = await new AccountBalanceQuery()
                .setAccountId(env.operatorId)
                .execute(env.client);

            expect(balanceReceiverPre.tokens.get(tokenId).toInt()).to.eq(0);
            expect(balanceTreasuryPre.tokens.get(tokenId).toInt()).to.eq(
                INITIAL_SUPPLY,
            );

            // after token reject transaction receiver doesn't have balance
            // so we need some tokens back from treasury
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -1)
                    .addTokenTransfer(tokenId, receiverId, 1)
                    .execute(env.client)
            ).getReceipt(env.client);

            const transactionId = TransactionId.generate(spenderAccountId);
            await (
                await (
                    await new TransferTransaction()
                        .addApprovedTokenTransfer(tokenId, receiverId, -1)
                        .addTokenTransfer(tokenId, spenderAccountId, 1)
                        .setTransactionId(transactionId)
                        .freezeWith(env.client)
                        .sign(spenderAccountPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            // Confirm spender has transfered tokens
            const tokenBalanceReceiverPost = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);

            expect(tokenBalanceReceiverPost.tokens.get(tokenId).toInt()).to.eq(
                0,
            );

            const tokenBalanceSpenderPost = await new AccountBalanceQuery()
                .setAccountId(spenderAccountId)
                .execute(env.client);

            expect(tokenBalanceSpenderPost.tokens.get(tokenId).toInt()).to.eq(
                1,
            );
        });

        describe("should throw an error", function () {
            it("when paused FT", async function () {
                await (
                    await new TokenPauseTransaction()
                        .setTokenId(tokenId)
                        .execute(env.client)
                ).getReceipt(env.client);

                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -1)
                    .addTokenTransfer(tokenId, receiverId, 1)
                    .execute(env.client);

                const tokenRejectTx = await new TokenRejectTransaction()
                    .addTokenId(tokenId)
                    .setOwnerId(receiverId)
                    .freezeWith(env.client)
                    .sign(receiverPrivateKey);

                try {
                    await (
                        await tokenRejectTx.execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("TOKEN_IS_PAUSED");
                }
            });

            it("when FT is frozen", async function () {
                // transfer token to receiver
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -1)
                    .addTokenTransfer(tokenId, receiverId, 1)
                    .execute(env.client);

                // freeze token
                await (
                    await new TokenFreezeTransaction()
                        .setTokenId(tokenId)
                        .setAccountId(receiverId)
                        .execute(env.client)
                ).getReceipt(env.client);

                try {
                    // reject token on frozen account for thsi token
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .addTokenId(tokenId)
                                .setOwnerId(receiverId)
                                .freezeWith(env.client)
                                .sign(receiverPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("ACCOUNT_FROZEN_FOR_TOKEN");
                }
            });

            it("when there's a duplicated token reference", async function () {
                await (
                    await new TransferTransaction()
                        .addTokenTransfer(tokenId, env.operatorId, -1)
                        .addTokenTransfer(tokenId, receiverId, 1)
                        .execute(env.client)
                ).getReceipt(env.client);

                try {
                    await new TokenRejectTransaction()
                        .setTokenIds([tokenId, tokenId])
                        .execute(env.client);
                } catch (err) {
                    expect(err.message).to.include("TOKEN_REFERENCE_REPEATED");
                }
            });

            it("when user does not have balance", async function () {
                // create receiver account
                const receiverPrivateKey = PrivateKey.generateED25519();
                const { accountId: emptyBalanceUserId } = await (
                    await new AccountCreateTransaction()
                        .setKeyWithoutAlias(receiverPrivateKey)
                        .setMaxAutomaticTokenAssociations(-1)
                        .execute(env.client)
                ).getReceipt(env.client);

                await (
                    await new TransferTransaction()
                        .addTokenTransfer(tokenId, env.operatorId, -1000)
                        .addTokenTransfer(tokenId, receiverId, 1000)
                        .execute(env.client)
                ).getReceipt(env.client);

                const transactionId =
                    await TransactionId.generate(emptyBalanceUserId);
                try {
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .setOwnerId(emptyBalanceUserId)
                                .addTokenId(tokenId)
                                .setTransactionId(transactionId)
                                .freezeWith(env.client)
                                .sign(receiverPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include(
                        "INSUFFICIENT_PAYER_BALANCE",
                    );
                }
            });

            it("when trasury account rejects token", async function () {
                try {
                    await (
                        await new TokenRejectTransaction()
                            .addTokenId(tokenId)
                            .execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("ACCOUNT_IS_TREASURY");
                }
            });

            it("when more than 11 tokens in token list for RejectToken transaction", async function () {
                const tokenIds = [];

                for (let i = 0; i < 11; i++) {
                    const { tokenId } = await (
                        await new TokenCreateTransaction()
                            .setTokenName("ffff")
                            .setTokenSymbol("F")
                            .setTokenType(TokenType.FungibleCommon)
                            .setInitialSupply(1000)
                            .setTreasuryAccountId(env.operatorId)
                            .setAdminKey(env.operatorKey)
                            .setSupplyKey(env.operatorKey)
                            .execute(env.client)
                    ).getReceipt(env.client);
                    tokenIds.push(tokenId);
                }
                try {
                    await (
                        await new TokenRejectTransaction()
                            .setTokenIds(tokenIds)
                            .execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include(
                        "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED",
                    );
                }
            });
        });
    });

    describe("Non-Fungible Tokens", function () {
        let tokenId, receiverPrivateKey, receiverId, nftId;

        beforeEach(async function () {
            env = await IntegrationTestEnv.new();
            const tokenCreateResponse = await new TokenCreateTransaction()
                .setTokenType(TokenType.NonFungibleUnique)
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .setPauseKey(env.operatorKey)
                .setFreezeKey(env.operatorKey)
                .execute(env.client);

            tokenId = (await tokenCreateResponse.getReceipt(env.client))
                .tokenId;

            receiverPrivateKey = await PrivateKey.generateECDSA();
            receiverId = (
                await (
                    await new AccountCreateTransaction()
                        .setKeyWithoutAlias(receiverPrivateKey)
                        .setMaxAutomaticTokenAssociations(-1)
                        .execute(env.client)
                ).getReceipt(env.client)
            ).accountId;

            nftId = new NftId(tokenId, 1);
            await (
                await new TokenMintTransaction()
                    .setTokenId(tokenId)
                    .setMetadata(Buffer.from("-"))
                    .execute(env.client)
            ).getReceipt(env.client);
        });

        it("should execute TokenReject Tx", async function () {
            const tokenCreateResponse2 = await new TokenCreateTransaction()
                .setTokenType(TokenType.NonFungibleUnique)
                .setTokenName("ffff2")
                .setTokenSymbol("F2")
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .execute(env.client);

            const { tokenId: tokenId2 } = await tokenCreateResponse2.getReceipt(
                env.client,
            );

            const nftId2 = new NftId(tokenId2, 1);
            await (
                await new TokenMintTransaction()
                    .setTokenId(tokenId2)
                    .setMetadata(Buffer.from("-"))
                    .execute(env.client)
            ).getReceipt(env.client);

            await (
                await new TransferTransaction()
                    .addNftTransfer(nftId, env.operatorId, receiverId)
                    .addNftTransfer(nftId2, env.operatorId, receiverId)
                    .execute(env.client)
            ).getReceipt(env.client);

            await (
                await (
                    await await new TokenRejectTransaction()
                        .setNftIds([nftId, nftId2])
                        .setOwnerId(receiverId)
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            const tokenBalanceReceiverQuery = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);

            const tokenBalanceTreasuryQuery = await new AccountBalanceQuery()
                .setAccountId(env.operatorId)
                .execute(env.client);

            const tokenBalanceReceiver = tokenBalanceReceiverQuery.tokens
                .get(tokenId)
                .toInt();
            const tokenBalanceReceiver2 = tokenBalanceReceiverQuery.tokens
                .get(tokenId2)
                .toInt();

            const tokenBalanceTreasury = tokenBalanceTreasuryQuery.tokens
                .get(tokenId)
                .toInt();
            const tokenBalanceTreasury2 = tokenBalanceTreasuryQuery.tokens
                .get(tokenId2)
                .toInt();

            expect(tokenBalanceTreasury).to.be.equal(1);
            expect(tokenBalanceTreasury2).to.be.equal(1);

            expect(tokenBalanceReceiver).to.be.equal(0);
            expect(tokenBalanceReceiver2).to.be.equal(0);
        });

        it("should return tokens back to treasury receiverSigRequired is true", async function () {
            await new AccountUpdateTransaction()
                .setAccountId(env.operatorId)
                .setReceiverSignatureRequired(true)
                .execute(env.client);

            const transferTransactionResponse = await new TransferTransaction()
                .addNftTransfer(nftId, env.operatorId, receiverId)
                .freezeWith(env.client)
                .execute(env.client);

            await transferTransactionResponse.getReceipt(env.client);

            const tokenRejectResponse = await (
                await new TokenRejectTransaction()
                    .addNftId(nftId)
                    .setOwnerId(receiverId)
                    .freezeWith(env.client)
                    .sign(receiverPrivateKey)
            ).execute(env.client);

            await tokenRejectResponse.getReceipt(env.client);

            const tokenBalanceTreasuryQuery = await new AccountBalanceQuery()
                .setAccountId(env.operatorId)
                .execute(env.client);

            const tokenBalanceTreasury = tokenBalanceTreasuryQuery.tokens
                .get(tokenId)
                .toInt();
            expect(tokenBalanceTreasury).to.be.equal(1);

            const tokenBalanceReceiverQuery = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);

            const tokenBalanceReceiver = tokenBalanceReceiverQuery.tokens
                .get(tokenId)
                .toInt();
            expect(tokenBalanceReceiver).to.equal(0);
        });

        // temporary disabled until issue re nfts will be resolved on services side
        // eslint-disable-next-line mocha/no-skipped-tests
        it.skip("should return spender allowance to 0 after owner rejects NFT", async function () {
            // create spender account
            const spenderAccountPrivateKey = PrivateKey.generateED25519();
            const spenderAccountResponse = await new AccountCreateTransaction()
                .setMaxAutomaticTokenAssociations(-1)
                .setInitialBalance(new Hbar(10))
                .setKeyWithoutAlias(spenderAccountPrivateKey)
                .execute(env.client);

            const { accountId: spenderAccountId } =
                await spenderAccountResponse.getReceipt(env.client);

            // transfer nft to receiver
            await (
                await new TransferTransaction()
                    .addNftTransfer(nftId, env.operatorId, receiverId)
                    .execute(env.client)
            ).getReceipt(env.client);

            // approve nft allowance
            await (
                await (
                    await new AccountAllowanceApproveTransaction()
                        .approveTokenNftAllowance(
                            nftId,
                            receiverId,
                            spenderAccountId,
                        )
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            // reject nft
            await (
                await (
                    await new TokenRejectTransaction()
                        .addNftId(nftId)
                        .setOwnerId(receiverId)
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            // transfer nft from receiver to spender using allowance
            try {
                const transactionId = TransactionId.generate(spenderAccountId);
                await (
                    await (
                        await new TransferTransaction()
                            .addApprovedNftTransfer(
                                nftId,
                                receiverId,
                                spenderAccountId,
                            )
                            .setTransactionId(transactionId)
                            .freezeWith(env.client)
                            .sign(spenderAccountPrivateKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (err) {
                expect(err.message).to.include(
                    "SPENDER_DOES_NOT_HAVE_ALLOWANCE",
                );
            }
        });

        describe("should throw an error", function () {
            it("when paused NFT", async function () {
                await (
                    await new TokenPauseTransaction()
                        .setTokenId(tokenId)
                        .execute(env.client)
                ).getReceipt(env.client);

                await new TransferTransaction()
                    .addNftTransfer(nftId, env.operatorId, receiverId)
                    .execute(env.client);
                const tokenRejectTx = await new TokenRejectTransaction()
                    .addTokenId(tokenId)
                    .setOwnerId(receiverId)
                    .freezeWith(env.client)
                    .sign(receiverPrivateKey);

                try {
                    await (
                        await tokenRejectTx.execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("TOKEN_IS_PAUSED");
                }
            });

            it("when NFT is frozen", async function () {
                // transfer token to receiver
                await new TransferTransaction()
                    .addNftTransfer(nftId, env.operatorId, receiverId)
                    .execute(env.client);

                // freeze token
                await (
                    await new TokenFreezeTransaction()
                        .setTokenId(tokenId)
                        .setAccountId(receiverId)
                        .execute(env.client)
                ).getReceipt(env.client);

                try {
                    // reject token on frozen account for thsi token
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .addTokenId(tokenId)
                                .setOwnerId(receiverId)
                                .freezeWith(env.client)
                                .sign(receiverPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("ACCOUNT_FROZEN_FOR_TOKEN");
                }
            });

            it("when using Fungible Token id when referencing NFTs", async function () {
                // transfer to receiver
                await (
                    await new TransferTransaction()
                        .addNftTransfer(nftId, env.operatorId, receiverId)
                        .execute(env.client)
                ).getReceipt(env.client);

                try {
                    // reject nft using addTokenId
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .setOwnerId(receiverId)
                                .addTokenId(tokenId)
                                .freezeWith(env.client)
                                .sign(receiverPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include(
                        "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON",
                    );
                }

                try {
                    // reject nft using setTokenIds
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .setOwnerId(receiverId)
                                .setTokenIds([tokenId])
                                .freezeWith(env.client)
                                .sign(receiverPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include(
                        "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON",
                    );
                }
            });

            it("when there's a duplicated token reference", async function () {
                // transfer nft to receiver
                await (
                    await new TransferTransaction()
                        .addNftTransfer(nftId, env.operatorId, receiverId)
                        .execute(env.client)
                ).getReceipt(env.client);

                // reject nft
                try {
                    await new TokenRejectTransaction()
                        .setNftIds([nftId, nftId])
                        .execute(env.client);
                } catch (err) {
                    expect(err.message).to.include("TOKEN_REFERENCE_REPEATED");
                }
            });

            it("when user does not have balance", async function () {
                // transfer nft to receiver
                await (
                    await new TransferTransaction()
                        .addNftTransfer(nftId, env.operatorId, receiverId)
                        .execute(env.client)
                ).getReceipt(env.client);
                const transactionId = await TransactionId.generate(receiverId);

                try {
                    // reject nft
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .setOwnerId(receiverId)
                                .addNftId(nftId)
                                .setTransactionId(transactionId)
                                .freezeWith(env.client)
                                .sign(receiverPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include(
                        "INSUFFICIENT_PAYER_BALANCE",
                    );
                }
            });

            it("when wrong signature of owner", async function () {
                // transfer token to receiver
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.operatorId, -1000)
                    .addTokenTransfer(tokenId, receiverId, 1000);

                try {
                    // reject token with wrong signature
                    const WRONG_SIGNATURE = PrivateKey.generateED25519();
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .addTokenId(tokenId)
                                .setOwnerId(receiverId)
                                .freezeWith(env.client)
                                .sign(WRONG_SIGNATURE)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("INVALID_SIGNATURE");
                }
            });

            it("when wrong owner id", async function () {
                // generate wrong owner account
                const wrongOwnerPrivateKey = PrivateKey.generateED25519();
                const { accountId: wrongOwnerId } = await (
                    await new AccountCreateTransaction()
                        .setKeyWithoutAlias(wrongOwnerPrivateKey)
                        .setMaxAutomaticTokenAssociations(-1)
                        .execute(env.client)
                ).getReceipt(env.client);

                // transfer token to receiver
                await (
                    await new TransferTransaction()
                        .addNftTransfer(nftId, env.operatorId, receiverId)
                        .execute(env.client)
                ).getReceipt(env.client);

                try {
                    // reject token with wrong token id
                    await (
                        await (
                            await new TokenRejectTransaction()
                                .addNftId(nftId)
                                .setOwnerId(wrongOwnerId)
                                .freezeWith(env.client)
                                .sign(wrongOwnerPrivateKey)
                        ).execute(env.client)
                    ).getReceipt(env.client);
                } catch (err) {
                    expect(err.message).to.include("INVALID_OWNER_ID");
                }
            });
        });
    });

    describe("Other", function () {
        beforeEach(async function () {
            env = await IntegrationTestEnv.new();

            // create token
            const tokenCreateResponse = await new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(env.operatorId)
                .setPauseKey(env.operatorKey)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .execute(env.client);

            tokenId = (await tokenCreateResponse.getReceipt(env.client))
                .tokenId;

            // create receiver account
            receiverPrivateKey = await PrivateKey.generateECDSA();
            const receiverCreateAccountResponse =
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(receiverPrivateKey)
                    .setInitialBalance(new Hbar(1))
                    .setMaxAutomaticTokenAssociations(-1)
                    .execute(env.client);

            receiverId = (
                await receiverCreateAccountResponse.getReceipt(env.client)
            ).accountId;
        });

        it("should execute TokenReject tx with mixed type of tokens in one tx", async function () {
            // create NFT collection
            const tokenCreateResponse = await new TokenCreateTransaction()
                .setTokenType(TokenType.NonFungibleUnique)
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .execute(env.client);
            const { tokenId: nftId } = await tokenCreateResponse.getReceipt(
                env.client,
            );
            const nftSerialId = new NftId(nftId, 1);

            // create FT
            const tokenCreateResponse2 = await new TokenCreateTransaction()
                .setTokenName("ffff2")
                .setTokenSymbol("F2")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(env.operatorKey)
                .setSupplyKey(env.operatorKey)
                .execute(env.client);
            const { tokenId: ftId } = await tokenCreateResponse2.getReceipt(
                env.client,
            );

            await (
                await new TokenMintTransaction()
                    .setTokenId(nftId)
                    .setMetadata(Buffer.from("-"))
                    .execute(env.client)
            ).getReceipt(env.client);

            const tokenTransferResponse = await new TransferTransaction()
                .addTokenTransfer(ftId, env.operatorId, -1)
                .addTokenTransfer(ftId, receiverId, 1)
                .addNftTransfer(nftSerialId, env.operatorId, receiverId)
                .execute(env.client);

            await tokenTransferResponse.getReceipt(env.client);

            // reject tokens
            await (
                await (
                    await new TokenRejectTransaction()
                        .addTokenId(ftId)
                        .addNftId(nftSerialId)
                        .setOwnerId(receiverId)
                        .freezeWith(env.client)
                        .sign(receiverPrivateKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            // check token balance of receiver
            const tokenBalanceReceiverQuery = await new AccountBalanceQuery()
                .setAccountId(receiverId)
                .execute(env.client);

            const tokenBalanceFTReceiver = tokenBalanceReceiverQuery.tokens
                .get(ftId)
                .toInt();
            const tokenBalanceNFTReceiver = tokenBalanceReceiverQuery.tokens
                .get(nftId)
                .toInt();

            expect(tokenBalanceFTReceiver).to.be.equal(0);
            expect(tokenBalanceNFTReceiver).to.be.equal(0);

            // check token balance of treasury
            const tokenBalanceTreasuryQuery = await new AccountBalanceQuery()
                .setAccountId(env.operatorId)
                .execute(env.client);

            const tokenBalanceTreasury = tokenBalanceTreasuryQuery.tokens
                .get(ftId)
                .toInt();
            const tokenBalance2Treasury = tokenBalanceTreasuryQuery.tokens
                .get(nftId)
                .toInt();

            expect(tokenBalanceTreasury).to.be.equal(1000000);
            expect(tokenBalance2Treasury).to.be.equal(1);
        });

        it("should throw if RejectToken transaction has empty token id list", async function () {
            try {
                await (
                    await new TokenRejectTransaction().execute(env.client)
                ).getReceipt(env.client);
            } catch (err) {
                expect(err.message).to.include("EMPTY_TOKEN_REFERENCE_LIST");
            }
        });
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenRevokeKycIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
    TokenRevokeKycTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenRevokeKyc", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        let relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.true;
        expect(relationship.isFrozen).to.be.false;

        await (
            await (
                await new TokenRevokeKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.false;
        expect(relationship.isFrozen).to.be.false;
    });

    it("should be executable even when no token IDs are set", async function () {
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        let err = false;

        try {
            await (
                await (
                    await new TokenRevokeKycTransaction()
                        .setAccountId(account)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token revoke kyc did not error");
        }
    });

    it("should error when account ID is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenRevokeKycTransaction()
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token association did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenTransferIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountInfoQuery,
    AccountUpdateTransaction,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
    TokenMintTransaction,
    TokenSupplyType,
    TokenType,
    TokenWipeTransaction,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenTransfer", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addTokenTransfer(token, account, 10)
                .addTokenTransfer(token, env.operatorId, -10)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TokenWipeTransaction()
                .setTokenId(token)
                .setAccountId(account)
                .setAmount(10)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should not error when no amount is transferred", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(10000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await new TransferTransaction()
                    .addTokenTransfer(token, account, 0)
                    .addTokenTransfer(token, env.operatorId, 0)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error;
        }

        if (err) {
            throw new Error("Token transfer did error.");
        }
    });

    it("should error when no  is transferred", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(0)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await new TransferTransaction()
                    .addTokenTransfer(token, account, 10)
                    .addTokenTransfer(token, env.operatorId, -10)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InsufficientTokenBalance);
        }

        if (!err) {
            throw new Error("Token transfer did not error.");
        }
    });

    it("cannot transfer NFT as if it were FT", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key.publicKey)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFeeScheduleKey(env.operatorKey)
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setSupplyType(TokenSupplyType.Finite)
                    .setMaxSupply(10)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await new TokenMintTransaction()
                .setMetadata([Uint8Array.of([0, 1, 2])])
                .setTokenId(token)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await new TransferTransaction()
                    .addTokenTransfer(token, env.operatorId, -1)
                    .addTokenTransfer(token, account, 1)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(
                    Status.AccountAmountTransfersOnlyAllowedForFungibleCommon,
                );
        }

        if (!err) {
            throw new Error("token update did not error");
        }
    });

    it("automatically associates to account", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .setMaxAutomaticTokenAssociations(10)
            .execute(env.client);

        const receipt = await response.getReceipt(env.client);

        expect(receipt.accountId).to.not.be.null;
        const account = receipt.accountId;

        let info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(info.maxAutomaticTokenAssociations.toInt()).to.be.equal(10);

        await (
            await (
                await new AccountUpdateTransaction()
                    .setAccountId(account)
                    .setMaxAutomaticTokenAssociations(1)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        expect(info.maxAutomaticTokenAssociations.toInt()).to.be.equal(1);

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        const record = await (
            await new TransferTransaction()
                .addTokenTransfer(token, account, 10)
                .addTokenTransfer(token, env.operatorId, -10)
                .execute(env.client)
        ).getRecord(env.client);

        expect(record.automaticTokenAssociations.length).to.be.equal(1);
        expect(
            record.automaticTokenAssociations[0].accountId.toString(),
        ).to.be.equal(account.toString());
        expect(
            record.automaticTokenAssociations[0].tokenId.toString(),
        ).to.be.equal(token.toString());

        await (
            await new TokenWipeTransaction()
                .setTokenId(token)
                .setAccountId(account)
                .setAmount(10)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenUnfreezeIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenFreezeTransaction,
    TokenUnfreezeTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenUnfreeze", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenFreezeTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        let relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.false;
        expect(relationship.isFrozen).to.be.true;

        await (
            await (
                await new TokenUnfreezeTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.false;
        expect(relationship.isFrozen).to.be.false;
    });

    it("should be executable even when no token IDs are set", async function () {
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        let err = false;

        try {
            await (
                await (
                    await new TokenUnfreezeTransaction()
                        .setAccountId(account)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token revoke kyc did not error");
        }
    });

    it("should error when account ID is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenUnfreezeTransaction()
                    .setTokenId(token)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token association did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TokenUpdateIntegrationTest.js
import {
    AccountCreateTransaction,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
    TokenInfoQuery,
    TokenMintTransaction,
    TokenSupplyType,
    TokenType,
    TokenUpdateTransaction,
    TransferTransaction,
    KeyList,
    TokenKeyValidation,
    PublicKey,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TokenUpdate", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new({ balance: 1000 });
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();
        const key4 = PrivateKey.generateED25519();
        const key5 = PrivateKey.generateED25519();
        const metadataKey = PrivateKey.generateED25519();
        const newMetadataKey = PrivateKey.generateED25519();
        const metadata = new Uint8Array([1]);

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(key1)
            .setFreezeKey(key2)
            .setWipeKey(key3)
            .setSupplyKey(key4)
            .setFreezeDefault(false)
            .setPauseKey(key5)
            .setMetadata(metadata)
            .setMetadataKey(metadataKey)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let info = await new TokenInfoQuery()
            .setTokenId(token)
            .execute(env.client);

        expect(info.tokenId.toString()).to.eql(token.toString());
        expect(info.name).to.eql("ffff");
        expect(info.symbol).to.eql("F");
        expect(info.decimals).to.eql(3);
        expect(info.totalSupply.toInt()).to.eql(1000000);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.kycKey.toString()).to.eql(key1.publicKey.toString());
        expect(info.freezeKey.toString()).to.eql(key2.publicKey.toString());
        expect(info.wipeKey.toString()).to.eql(key3.publicKey.toString());
        expect(info.supplyKey.toString()).to.eql(key4.publicKey.toString());
        expect(info.pauseKey.toString()).to.eql(key5.publicKey.toString());
        expect(info.metadataKey.toString()).to.eql(
            metadataKey.publicKey.toString(),
        );
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.metadata).to.eql(metadata);
        expect(info.defaultFreezeStatus).to.be.false;
        expect(info.defaultKycStatus).to.be.false;
        expect(info.isDeleted).to.be.false;

        expect(info.autoRenewPeriod).to.be.not.null;
        expect(info.expirationTime).to.be.not.null;

        await (
            await new TokenUpdateTransaction()
                .setTokenId(token)
                .setTokenName("aaaa")
                .setTokenSymbol("A")
                .setMetadataKey(newMetadataKey)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new TokenInfoQuery().setTokenId(token).execute(env.client);

        expect(info.tokenId.toString()).to.eql(token.toString());
        expect(info.name).to.eql("aaaa");
        expect(info.symbol).to.eql("A");
        expect(info.decimals).to.eql(3);
        expect(info.totalSupply.toInt()).to.eql(1000000);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.kycKey.toString()).to.eql(key1.publicKey.toString());
        expect(info.freezeKey.toString()).to.eql(key2.publicKey.toString());
        expect(info.wipeKey.toString()).to.eql(key3.publicKey.toString());
        expect(info.supplyKey.toString()).to.eql(key4.publicKey.toString());
        expect(info.metadataKey.toString()).to.eql(
            newMetadataKey.publicKey.toString(),
        );
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            env.client.operatorAccountId.toString(),
        );
        expect(info.metadata).to.eql(metadata);
        expect(info.defaultFreezeStatus).to.be.false;
        expect(info.defaultKycStatus).to.be.false;
        expect(info.isDeleted).to.be.false;
        expect(info.autoRenewPeriod).to.be.not.null;
        expect(info.expirationTime).to.be.not.null;
    });

    it("should be able to update treasury", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();
        const key4 = PrivateKey.generateED25519();
        const key5 = PrivateKey.generateED25519();

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(key1)
            .setFreezeKey(key2)
            .setWipeKey(key3)
            .setSupplyKey(key4)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        const treasuryAccountId = (
            await (
                await (
                    await new AccountCreateTransaction()
                        .setKeyWithoutAlias(key5)
                        .freezeWith(env.client)
                        .sign(key5)
                ).execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        let info = await new TokenInfoQuery()
            .setTokenId(token)
            .execute(env.client);

        expect(info.tokenId.toString()).to.eql(token.toString());
        expect(info.name).to.eql("ffff");
        expect(info.symbol).to.eql("F");
        expect(info.decimals).to.eql(3);
        expect(info.totalSupply.toInt()).to.eql(1000000);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            operatorId.toString(),
        );
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.kycKey.toString()).to.eql(key1.publicKey.toString());
        expect(info.freezeKey.toString()).to.eql(key2.publicKey.toString());
        expect(info.wipeKey.toString()).to.eql(key3.publicKey.toString());
        expect(info.supplyKey.toString()).to.eql(key4.publicKey.toString());
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.defaultFreezeStatus).to.be.false;
        expect(info.defaultKycStatus).to.be.false;
        expect(info.isDeleted).to.be.false;
        expect(info.autoRenewPeriod).to.be.not.null;
        expect(info.expirationTime).to.be.not.null;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(treasuryAccountId)
                    .freezeWith(env.client)
                    .sign(key5)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenUpdateTransaction()
                    .setTokenId(token)
                    .setTokenName("aaaa")
                    .setTokenSymbol("A")
                    .setTreasuryAccountId(treasuryAccountId)
                    .freezeWith(env.client)
                    .sign(key5)
            ).execute(env.client)
        ).getReceipt(env.client);

        info = await new TokenInfoQuery().setTokenId(token).execute(env.client);

        expect(info.tokenId.toString()).to.eql(token.toString());
        expect(info.name).to.eql("aaaa");
        expect(info.symbol).to.eql("A");
        expect(info.decimals).to.eql(3);
        expect(info.totalSupply.toInt()).to.eql(1000000);
        expect(info.treasuryAccountId.toString()).to.be.equal(
            treasuryAccountId.toString(),
        );
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.kycKey.toString()).to.eql(key1.publicKey.toString());
        expect(info.freezeKey.toString()).to.eql(key2.publicKey.toString());
        expect(info.wipeKey.toString()).to.eql(key3.publicKey.toString());
        expect(info.supplyKey.toString()).to.eql(key4.publicKey.toString());
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            env.client.operatorAccountId.toString(),
        );
        expect(info.defaultFreezeStatus).to.be.false;
        expect(info.defaultKycStatus).to.be.false;
        expect(info.isDeleted).to.be.false;
        expect(info.autoRenewPeriod).to.be.not.null;
        expect(info.expirationTime).to.be.not.null;
    });

    it("should be executable when no properties except token ID are set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateED25519();
        const key3 = PrivateKey.generateED25519();
        const key4 = PrivateKey.generateED25519();

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(key1)
            .setFreezeKey(key2)
            .setWipeKey(key3)
            .setSupplyKey(key4)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        await (
            await new TokenUpdateTransaction()
                .setTokenId(token)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error updating immutable token", async function () {
        const operatorId = env.operatorId;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setTreasuryAccountId(operatorId)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let status;

        try {
            await (
                await new TokenUpdateTransaction()
                    .setTokenId(token)
                    .setTokenName("aaaa")
                    .setTokenSymbol("A")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.TokenIsImmutable);
    });

    it("should error when token ID is not set", async function () {
        let err = false;

        try {
            await (
                await new TokenUpdateTransaction().execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token update did not error");
        }
    });

    it("should return error when updating immutable token", async function () {
        let status;
        const operatorId = env.operatorId;

        try {
            const response = await new TokenCreateTransaction()
                .setTokenSymbol("F")
                .setTokenName("ffff")
                .setTreasuryAccountId(operatorId)
                .execute(env.client);

            const token = (await response.getReceipt(env.client)).tokenId;

            await (
                await new TokenUpdateTransaction()
                    .setTokenId(token)
                    .setTokenName("aaaa")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            status = error.status;
        }

        expect(status).to.be.eql(Status.TokenIsImmutable);
    });

    it("should error when admin key does not sign transaction", async function () {
        const operatorId = env.operatorId;
        const key = PrivateKey.generateED25519();

        const response = await (
            await new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(operatorId)
                .setAdminKey(key)
                .freezeWith(env.client)
                .sign(key)
        ).execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenUpdateTransaction()
                    .setTokenId(token)
                    .setTokenName("aaaa")
                    .setTokenSymbol("A")
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidSignature);
        }

        if (!err) {
            throw new Error("token update did not error");
        }
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("cannot change current treasury until no NFTs are owned", async function () {
        const key = PrivateKey.generateED25519();

        const account = (
            await (
                await new AccountCreateTransaction()
                    .setKeyWithoutAlias(key.publicKey)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(env.operatorId)
                    .setAdminKey(env.operatorKey)
                    .setKycKey(env.operatorKey)
                    .setFreezeKey(env.operatorKey)
                    .setWipeKey(env.operatorKey)
                    .setSupplyKey(env.operatorKey)
                    .setFeeScheduleKey(env.operatorKey)
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setSupplyType(TokenSupplyType.Infinite)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TokenMintTransaction()
                .setMetadata([
                    Uint8Array.of([0, 1, 2]),
                    Uint8Array.of([3, 4, 5]),
                ])
                .setTokenId(token)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addNftTransfer(token, 1, env.operatorId, account)
                .execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await (
                    await new TokenUpdateTransaction()
                        .setTokenId(token)
                        .setTreasuryAccountId(account)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error
                .toString()
                .includes(Status.CurrentTreasuryStillOwnsNfts);
        }

        if (!err) {
            throw new Error("token update did not error");
        }
    });

    describe("[HIP-646] Fungible Token Metadata Field", function () {
        it("should update the metadata of token after signing the transaction with metadata key", async function () {
            let tokenInfo;
            const operatorId = env.operatorId;
            const metadataKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setTokenType(TokenType.FungibleCommon)
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(operatorId)
                .setMetadata(metadata)
                .setMetadataKey(metadataKey);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (
                    await tokenUpdateTx.sign(metadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should update the metadata of token after signing the transaction with admin key", async function () {
            const operatorId = env.operatorId;
            const adminKey = env.operatorKey;
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);
            let tokenInfo;

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setTokenType(TokenType.FungibleCommon)
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(operatorId)
                .setAdminKey(adminKey)
                .setMetadata(metadata);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (await tokenUpdateTx.sign(adminKey)).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should NOT update the metadata of token when the new metadata is NOT set", async function () {
            const operatorId = env.operatorId;
            const adminKey = env.operatorKey;
            const metadata = new Uint8Array([1]);
            let tokenInfo;

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setTokenType(TokenType.FungibleCommon)
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(operatorId)
                .setAdminKey(adminKey)
                .setMetadata(metadata);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .freezeWith(env.client);

            await (
                await (await tokenUpdateTx.sign(adminKey)).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(metadata);
        });

        it("should earse the metadata of token after signing the transaction with metadata key", async function () {
            let tokenInfo;
            const operatorId = env.operatorId;
            const metadataKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array();

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setTokenType(TokenType.FungibleCommon)
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(operatorId)
                .setMetadata(metadata)
                .setMetadataKey(metadataKey);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (
                    await tokenUpdateTx.sign(metadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should earse the metadata of token after signing the transaction with admin key", async function () {
            const operatorId = env.operatorId;
            const adminKey = env.operatorKey;
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array();
            let tokenInfo;

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setTokenType(TokenType.FungibleCommon)
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(operatorId)
                .setMetadata(metadata)
                .setAdminKey(adminKey);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (await tokenUpdateTx.sign(adminKey)).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should NOT update the metadata of token when the transaction is not signed with metadata or admin key", async function () {
            let status;
            const operatorId = env.operatorId;
            const adminKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();
            const wrongKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);

            try {
                const tokenCreateTx = new TokenCreateTransaction()
                    .setTokenName("Test")
                    .setTokenSymbol("T")
                    .setTokenType(TokenType.FungibleCommon)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(adminKey)
                    .setMetadata(metadata)
                    .setMetadataKey(metadataKey);

                const tokenCreateTxresponse = await tokenCreateTx.execute(
                    env.client,
                );
                const tokenCreateTxReceipt =
                    await tokenCreateTxresponse.getReceipt(env.client);
                const tokenId = tokenCreateTxReceipt.tokenId;

                const tokenUpdateTx = new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadata(newMetadata)
                    .freezeWith(env.client);

                await (
                    await (
                        await tokenUpdateTx.sign(wrongKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }
            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("should NOT update the metadata of token if the metadata or admin keys are NOT set", async function () {
            let status;
            const operatorId = env.operatorId;
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);

            try {
                const tokenCreateTx = new TokenCreateTransaction()
                    .setTokenName("Test")
                    .setTokenSymbol("T")
                    .setTokenType(TokenType.FungibleCommon)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setMetadata(metadata);

                const tokenCreateTxresponse = await tokenCreateTx.execute(
                    env.client,
                );
                const tokenCreateTxReceipt =
                    await tokenCreateTxresponse.getReceipt(env.client);
                const tokenId = tokenCreateTxReceipt.tokenId;

                const tokenUpdateTx = new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadata(newMetadata)
                    .freezeWith(env.client);

                await (
                    await tokenUpdateTx.execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }
            expect(status).to.be.eql(Status.TokenIsImmutable);
        });
    });

    describe("[HIP-765] Non Fungible Token Metadata Field", function () {
        it("should update the metadata of token after signing the transaction with metadata key", async function () {
            const operatorId = env.operatorId;
            const metadataKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);
            let tokenInfo;

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setSupplyKey(supplyKey)
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(operatorId)
                .setMetadata(metadata)
                .setMetadataKey(metadataKey);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (
                    await tokenUpdateTx.sign(metadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should update the metadata of token after signing the transaction with admin key", async function () {
            let tokenInfo;
            const operatorId = env.operatorId;
            const adminKey = env.operatorKey;
            const supplyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setSupplyKey(supplyKey)
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(operatorId)
                .setAdminKey(adminKey)
                .setMetadata(metadata);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (await tokenUpdateTx.sign(adminKey)).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should NOT update the metadata of token when the new metadata is NOT set", async function () {
            let tokenInfo;
            const operatorId = env.operatorId;
            const adminKey = env.operatorKey;
            const supplyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setSupplyKey(supplyKey)
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(operatorId)
                .setAdminKey(adminKey)
                .setMetadata(metadata);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .freezeWith(env.client);

            await (
                await (await tokenUpdateTx.sign(adminKey)).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(metadata);
        });

        it("should earse the metadata of token after signing the transaction with metadata key", async function () {
            const operatorId = env.operatorId;
            const metadataKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array();
            let tokenInfo;

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setSupplyKey(supplyKey)
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(operatorId)
                .setMetadata(metadata)
                .setMetadataKey(metadataKey);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (
                    await tokenUpdateTx.sign(metadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should earse the metadata of token after signing the transaction with admin key", async function () {
            const operatorId = env.operatorId;
            const adminKey = env.operatorKey;
            const suppyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array();
            let tokenInfo;

            const tokenCreateTx = new TokenCreateTransaction()
                .setTokenName("Test")
                .setTokenSymbol("T")
                .setSupplyKey(suppyKey)
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(operatorId)
                .setAdminKey(adminKey)
                .setMetadata(metadata);

            const tokenCreateTxresponse = await tokenCreateTx.execute(
                env.client,
            );
            const tokenCreateTxReceipt = await tokenCreateTxresponse.getReceipt(
                env.client,
            );
            const tokenId = tokenCreateTxReceipt.tokenId;

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);
            expect(tokenInfo.metadata).to.eql(metadata);

            const tokenUpdateTx = new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setMetadata(newMetadata)
                .freezeWith(env.client);

            await (
                await (await tokenUpdateTx.sign(adminKey)).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.metadata).to.eql(newMetadata);
        });

        it("should NOT update the metadata of token when the transaction is not signed with metadata or admin key", async function () {
            let status;
            const operatorId = env.operatorId;
            const adminKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();
            const wrongKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);

            try {
                const tokenCreateTx = new TokenCreateTransaction()
                    .setTokenName("Test")
                    .setTokenSymbol("T")
                    .setSupplyKey(supplyKey)
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(adminKey)
                    .setMetadata(metadata)
                    .setMetadataKey(metadataKey);

                const tokenCreateTxresponse = await tokenCreateTx.execute(
                    env.client,
                );
                const tokenCreateTxReceipt =
                    await tokenCreateTxresponse.getReceipt(env.client);
                const tokenId = tokenCreateTxReceipt.tokenId;

                const tokenUpdateTx = new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadata(newMetadata)
                    .freezeWith(env.client);

                await (
                    await (
                        await tokenUpdateTx.sign(wrongKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }
            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("should NOT update the metadata of token if the metadata or admin keys are NOT set", async function () {
            let status;
            const operatorId = env.operatorId;
            const supplyKey = PrivateKey.generateED25519();
            const metadata = new Uint8Array([1]);
            const newMetadata = new Uint8Array([1, 2]);

            try {
                const tokenCreateTx = new TokenCreateTransaction()
                    .setTokenName("Test")
                    .setTokenSymbol("T")
                    .setSupplyKey(supplyKey)
                    .setTokenType(TokenType.NonFungibleUnique)
                    .setTreasuryAccountId(operatorId)
                    .setMetadata(metadata);

                const tokenCreateTxresponse = await tokenCreateTx.execute(
                    env.client,
                );
                const tokenCreateTxReceipt =
                    await tokenCreateTxresponse.getReceipt(env.client);
                const tokenId = tokenCreateTxReceipt.tokenId;

                const tokenUpdateTx = new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadata(newMetadata)
                    .freezeWith(env.client);

                await (
                    await tokenUpdateTx.execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }
            expect(status).to.be.eql(Status.TokenIsImmutable);
        });
    });

    describe("[HIP-540] Change or remove existing keys from a token", function () {
        it("Can make the token immutable when updating all of its keys to an empty KeyList, signing with an Admin Key, and setting the key verification mode to NO_VALIDATION.", async function () {
            const adminKey = PrivateKey.generateED25519();
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newKey = KeyList.of();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            await (
                await (
                    await new TokenUpdateTransaction()
                        .setTokenId(tokenId)
                        .setKeyVerificationMode(TokenKeyValidation.NoValidation)
                        .setAdminKey(newKey)
                        .setWipeKey(newKey)
                        .setFreezeKey(newKey)
                        .setPauseKey(newKey)
                        .setSupplyKey(newKey)
                        .setFeeScheduleKey(newKey)
                        .setMetadataKey(newKey)
                        .freezeWith(env.client)
                        .sign(adminKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey).to.be.null;
            expect(tokenInfo.wipeKey).to.be.null;
            expect(tokenInfo.freezeKey).to.be.null;
            expect(tokenInfo.pauseKey).to.be.null;
            expect(tokenInfo.supplyKey).to.be.null;
            expect(tokenInfo.feeScheduleKey).to.be.null;
            expect(tokenInfo.metadataKey).to.be.null;
        });

        it("Can remove all of token's lower-privilege keys when updating them to an empty KeyList, signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION", async function () {
            const adminKey = PrivateKey.generateED25519();
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const emptyKeyList = KeyList.of();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            await (
                await (
                    await new TokenUpdateTransaction()
                        .setTokenId(tokenId)
                        .setKeyVerificationMode(
                            TokenKeyValidation.FullValidation,
                        )
                        .setWipeKey(emptyKeyList)
                        .setFreezeKey(emptyKeyList)
                        .setPauseKey(emptyKeyList)
                        .setSupplyKey(emptyKeyList)
                        .setFeeScheduleKey(emptyKeyList)
                        .setMetadataKey(emptyKeyList)
                        .freezeWith(env.client)
                        .sign(adminKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey).to.be.null;
            expect(tokenInfo.freezeKey).to.be.null;
            expect(tokenInfo.pauseKey).to.be.null;
            expect(tokenInfo.supplyKey).to.be.null;
            expect(tokenInfo.feeScheduleKey).to.be.null;
            expect(tokenInfo.metadataKey).to.be.null;
        });

        it("Can update all of token's lower-privilege keys to an unusable key (i.e. all-zeros key) when signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION and then set all lower-privilege keys back by signing with an Admin Key and setting key verification mode to NO_VALIDATION", async function () {
            const adminKey = PrivateKey.generateED25519();
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            await (
                await (
                    await new TokenUpdateTransaction()
                        .setTokenId(tokenId)
                        .setKeyVerificationMode(
                            TokenKeyValidation.FullValidation,
                        )
                        .setWipeKey(unusableKey)
                        .setFreezeKey(unusableKey)
                        .setPauseKey(unusableKey)
                        .setSupplyKey(unusableKey)
                        .setFeeScheduleKey(unusableKey)
                        .setMetadataKey(unusableKey)
                        .freezeWith(env.client)
                        .sign(adminKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(unusableKey.toString());
            expect(tokenInfo.freezeKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                unusableKey.toString(),
            );

            await (
                await (
                    await new TokenUpdateTransaction()
                        .setTokenId(tokenId)
                        .setKeyVerificationMode(TokenKeyValidation.NoValidation)
                        .setWipeKey(wipeKey)
                        .setFreezeKey(freezeKey)
                        .setPauseKey(pauseKey)
                        .setSupplyKey(supplyKey)
                        .setFeeScheduleKey(feeScheduleKey)
                        .setMetadataKey(metadataKey)
                        .freezeWith(env.client)
                        .sign(adminKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );
        });

        it("Can update all of token's lower-privilege keys when signing with an Admin Key and new respective lower-privilege key, and setting key verification mode to FULL_VALIDATION", async function () {
            const adminKey = PrivateKey.generateED25519();
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newWipeKey = PrivateKey.generateED25519();
            const newFreezeKey = PrivateKey.generateED25519();
            const newPauseKey = PrivateKey.generateED25519();
            const newSupplyKey = PrivateKey.generateED25519();
            const newFeeScheduleKey = PrivateKey.generateED25519();
            const newMetadataKey = PrivateKey.generateED25519();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            await (
                await (
                    await new TokenUpdateTransaction()
                        .setTokenId(tokenId)
                        .setKeyVerificationMode(
                            TokenKeyValidation.FullValidation,
                        )
                        .setWipeKey(newWipeKey)
                        .setFreezeKey(newFreezeKey)
                        .setPauseKey(newPauseKey)
                        .setSupplyKey(newSupplyKey)
                        .setFeeScheduleKey(newFeeScheduleKey)
                        .setMetadataKey(newMetadataKey)
                        .freezeWith(env.client)
                        .sign(adminKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                newWipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                newFreezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                newPauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                newSupplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                newFeeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                newMetadataKey.publicKey.toString(),
            );
        });

        it("Cannot make the token immutable when updating all of its keys to an empty KeyList, signing with a key that is different from an Admin Key, and setting the key verification mode to NO_VALIDATION", async function () {
            const adminKey = PrivateKey.generateED25519();
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newKey = KeyList.of();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setAdminKey(newKey)
                            .setWipeKey(newKey)
                            .setFreezeKey(newKey)
                            .setPauseKey(newKey)
                            .setSupplyKey(newKey)
                            .setFeeScheduleKey(newKey)
                            .setMetadataKey(newKey)
                            .freezeWith(env.client)
                            .sign(env.operatorKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Cannot make a token immutable when updating all of its keys to an unusable key (i.e. all-zeros key), signing with a key that is different from an Admin Key, and setting the key verification mode to NO_VALIDATION", async function () {
            const adminKey = PrivateKey.generateED25519();
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setAdminKey(unusableKey)
                            .setWipeKey(unusableKey)
                            .setFreezeKey(unusableKey)
                            .setPauseKey(unusableKey)
                            .setSupplyKey(unusableKey)
                            .setFeeScheduleKey(unusableKey)
                            .setMetadataKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(env.operatorKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Cannot update the Admin Key to an unusable key (i.e. all-zeros key), signing with an Admin Key, and setting the key verification mode to NO_VALIDATION", async function () {
            const adminKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setAdminKey(adminKey)
                .setSupplyKey(supplyKey)
                .freezeWith(env.client);

            let response = await (
                await token.sign(adminKey)
            ).execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.adminKey.toString()).to.eql(
                adminKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setAdminKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(adminKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Can update all of token’s lower-privilege keys to an unusable key (i.e. all-zeros key), when signing with a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            await (
                await (
                    await (
                        await (
                            await (
                                await (
                                    await (
                                        await new TokenUpdateTransaction()
                                            .setTokenId(tokenId)
                                            .setKeyVerificationMode(
                                                TokenKeyValidation.NoValidation,
                                            )
                                            .setWipeKey(unusableKey)
                                            .setFreezeKey(unusableKey)
                                            .setPauseKey(unusableKey)
                                            .setSupplyKey(unusableKey)
                                            .setFeeScheduleKey(unusableKey)
                                            .setMetadataKey(unusableKey)
                                            .freezeWith(env.client)
                                            .sign(wipeKey)
                                    ).sign(freezeKey)
                                ).sign(pauseKey)
                            ).sign(supplyKey)
                        ).sign(feeScheduleKey)
                    ).sign(metadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(unusableKey.toString());
            expect(tokenInfo.freezeKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                unusableKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                unusableKey.toString(),
            );
        });

        it("Can update all of token’s lower-privilege keys when signing with an old respective lower-privilege key and a new respective lower-privilege key, and setting key verification mode to FULL_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newWipeKey = PrivateKey.generateED25519();
            const newFreezeKey = PrivateKey.generateED25519();
            const newPauseKey = PrivateKey.generateED25519();
            const newSupplyKey = PrivateKey.generateED25519();
            const newFeeScheduleKey = PrivateKey.generateED25519();
            const newMetadataKey = PrivateKey.generateED25519();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );
            await (
                await (
                    await (
                        await (
                            await (
                                await (
                                    await (
                                        await (
                                            await (
                                                await (
                                                    await (
                                                        await (
                                                            await (
                                                                await new TokenUpdateTransaction()
                                                                    .setTokenId(
                                                                        tokenId,
                                                                    )
                                                                    .setKeyVerificationMode(
                                                                        TokenKeyValidation.FullValidation,
                                                                    )
                                                                    .setWipeKey(
                                                                        newWipeKey,
                                                                    )
                                                                    .setFreezeKey(
                                                                        newFreezeKey,
                                                                    )
                                                                    .setPauseKey(
                                                                        newPauseKey,
                                                                    )
                                                                    .setSupplyKey(
                                                                        newSupplyKey,
                                                                    )
                                                                    .setFeeScheduleKey(
                                                                        newFeeScheduleKey,
                                                                    )
                                                                    .setMetadataKey(
                                                                        newMetadataKey,
                                                                    )
                                                                    .freezeWith(
                                                                        env.client,
                                                                    )
                                                                    .sign(
                                                                        wipeKey,
                                                                    )
                                                            ).sign(newWipeKey)
                                                        ).sign(freezeKey)
                                                    ).sign(newFreezeKey)
                                                ).sign(pauseKey)
                                            ).sign(newPauseKey)
                                        ).sign(supplyKey)
                                    ).sign(newSupplyKey)
                                ).sign(feeScheduleKey)
                            ).sign(newFeeScheduleKey)
                        ).sign(metadataKey)
                    ).sign(newMetadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                newWipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                newFreezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                newPauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                newSupplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                newFeeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                newMetadataKey.publicKey.toString(),
            );
        });

        it("Can update all of token's lower-privilege keys when signing ONLY with an old respective lower-privilege key and setting key verification mode to NO_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newWipeKey = PrivateKey.generateED25519();
            const newFreezeKey = PrivateKey.generateED25519();
            const newPauseKey = PrivateKey.generateED25519();
            const newSupplyKey = PrivateKey.generateED25519();
            const newFeeScheduleKey = PrivateKey.generateED25519();
            const newMetadataKey = PrivateKey.generateED25519();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );
            await (
                await (
                    await (
                        await (
                            await (
                                await (
                                    await (
                                        await new TokenUpdateTransaction()
                                            .setTokenId(tokenId)
                                            .setKeyVerificationMode(
                                                TokenKeyValidation.NoValidation,
                                            )
                                            .setWipeKey(newWipeKey)
                                            .setFreezeKey(newFreezeKey)
                                            .setPauseKey(newPauseKey)
                                            .setSupplyKey(newSupplyKey)
                                            .setFeeScheduleKey(
                                                newFeeScheduleKey,
                                            )
                                            .setMetadataKey(newMetadataKey)
                                            .freezeWith(env.client)
                                            .sign(wipeKey)
                                    ).sign(freezeKey)
                                ).sign(pauseKey)
                            ).sign(supplyKey)
                        ).sign(feeScheduleKey)
                    ).sign(metadataKey)
                ).execute(env.client)
            ).getReceipt(env.client);

            tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                newWipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                newFreezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                newPauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                newSupplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                newFeeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                newMetadataKey.publicKey.toString(),
            );
        });

        it("Cannot remove all of token's lower-privilege keys when updating them to an empty KeyList, signing with a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newKey = KeyList.of();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await (
                            await (
                                await (
                                    await (
                                        await (
                                            await new TokenUpdateTransaction()
                                                .setTokenId(tokenId)
                                                .setKeyVerificationMode(
                                                    TokenKeyValidation.NoValidation,
                                                )
                                                .setWipeKey(newKey)
                                                .setFreezeKey(newKey)
                                                .setPauseKey(newKey)
                                                .setSupplyKey(newKey)
                                                .setFeeScheduleKey(newKey)
                                                .setMetadataKey(newKey)
                                                .freezeWith(env.client)
                                                .sign(wipeKey)
                                        ).sign(freezeKey)
                                    ).sign(pauseKey)
                                ).sign(supplyKey)
                            ).sign(feeScheduleKey)
                        ).sign(metadataKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.TokenIsImmutable);
        });

        it("Cannot update all of token’s lower-privilege keys to an unusable key (i.e. all-zeros key), when signing with a key that is different from a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setWipeKey(unusableKey)
                            .setFreezeKey(unusableKey)
                            .setPauseKey(unusableKey)
                            .setSupplyKey(unusableKey)
                            .setFeeScheduleKey(unusableKey)
                            .setMetadataKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(env.operatorKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Cannot update all of token's lower-privilege keys to an unusable key (i.e. all-zeros key), when signing ONLY with an old respective lower-privilege key, and setting key verification mode to FULL_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setWipeKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(wipeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setFreezeKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(freezeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setPauseKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(pauseKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setSupplyKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(supplyKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setFeeScheduleKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(feeScheduleKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setMetadataKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(metadataKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Cannot update all of token's lower-privilege to an unusable key (i.e. all-zeros key), when signing with an old respective lower-privilege key and a new respective lower-privilege key, and setting key verification mode to FULL_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const newWipeKey = PrivateKey.generateED25519();
            const newFreezeKey = PrivateKey.generateED25519();
            const newPauseKey = PrivateKey.generateED25519();
            const newSupplyKey = PrivateKey.generateED25519();
            const newFeeScheduleKey = PrivateKey.generateED25519();
            const newMetadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await (
                            await new TokenUpdateTransaction()
                                .setTokenId(tokenId)
                                .setKeyVerificationMode(
                                    TokenKeyValidation.FullValidation,
                                )
                                .setWipeKey(unusableKey)
                                .freezeWith(env.client)
                                .sign(wipeKey)
                        ).sign(newWipeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await (
                            await new TokenUpdateTransaction()
                                .setTokenId(tokenId)
                                .setKeyVerificationMode(
                                    TokenKeyValidation.FullValidation,
                                )
                                .setFreezeKey(unusableKey)
                                .freezeWith(env.client)
                                .sign(freezeKey)
                        ).sign(newFreezeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await (
                            await new TokenUpdateTransaction()
                                .setTokenId(tokenId)
                                .setKeyVerificationMode(
                                    TokenKeyValidation.FullValidation,
                                )
                                .setPauseKey(unusableKey)
                                .freezeWith(env.client)
                                .sign(pauseKey)
                        ).sign(newPauseKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await (
                            await new TokenUpdateTransaction()
                                .setTokenId(tokenId)
                                .setKeyVerificationMode(
                                    TokenKeyValidation.FullValidation,
                                )
                                .setSupplyKey(unusableKey)
                                .freezeWith(env.client)
                                .sign(supplyKey)
                        ).sign(newSupplyKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await (
                            await new TokenUpdateTransaction()
                                .setTokenId(tokenId)
                                .setKeyVerificationMode(
                                    TokenKeyValidation.FullValidation,
                                )
                                .setFeeScheduleKey(unusableKey)
                                .freezeWith(env.client)
                                .sign(feeScheduleKey)
                        ).sign(newFeeScheduleKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await (
                            await new TokenUpdateTransaction()
                                .setTokenId(tokenId)
                                .setKeyVerificationMode(
                                    TokenKeyValidation.FullValidation,
                                )
                                .setMetadataKey(unusableKey)
                                .freezeWith(env.client)
                                .sign(metadataKey)
                        ).sign(newMetadataKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Cannot update all of token's lower-privilege keys when signing ONLY with an old respective lower-privilege key and setting key verification mode to FULL_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const unusableKey = PublicKey.unusableKey();

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setWipeKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(wipeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setFreezeKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(freezeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setPauseKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(pauseKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setSupplyKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(supplyKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setFeeScheduleKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(feeScheduleKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.FullValidation,
                            )
                            .setMetadataKey(unusableKey)
                            .freezeWith(env.client)
                            .sign(metadataKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSignature);
        });

        it("Cannot update all of token's lower-privilege keys when updating them to a keys with an invalid structure and signing with an old respective lower-privilege and setting key verification mode to NO_VALIDATION", async function () {
            const wipeKey = PrivateKey.generateED25519();
            const freezeKey = PrivateKey.generateED25519();
            const pauseKey = PrivateKey.generateED25519();
            const supplyKey = PrivateKey.generateED25519();
            const feeScheduleKey = PrivateKey.generateED25519();
            const metadataKey = PrivateKey.generateED25519();

            const structurallyInvalidKey = PublicKey.fromString(
                "000000000000000000000000000000000000000000000000000000000000000000",
            );

            let token = new TokenCreateTransaction()
                .setTokenName("Token")
                .setTokenSymbol("T")
                .setTokenType(TokenType.NonFungibleUnique)
                .setTreasuryAccountId(env.operatorId)
                .setWipeKey(wipeKey)
                .setFreezeKey(freezeKey)
                .setPauseKey(pauseKey)
                .setSupplyKey(supplyKey)
                .setFeeScheduleKey(feeScheduleKey)
                .setMetadataKey(metadataKey)
                .freezeWith(env.client);

            let response = await token.execute(env.client);
            const tokenId = (await response.getReceipt(env.client)).tokenId;

            let tokenInfo = await new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(env.client);

            expect(tokenInfo.name).to.eql(token.tokenName);
            expect(tokenInfo.symbol).to.eql(token.tokenSymbol);
            expect(tokenInfo.tokenType).to.eql(token.tokenType);
            expect(tokenInfo.treasuryAccountId.toString()).to.eql(
                token.treasuryAccountId.toString(),
            );
            expect(tokenInfo.wipeKey.toString()).to.eql(
                wipeKey.publicKey.toString(),
            );
            expect(tokenInfo.freezeKey.toString()).to.eql(
                freezeKey.publicKey.toString(),
            );
            expect(tokenInfo.pauseKey.toString()).to.eql(
                pauseKey.publicKey.toString(),
            );
            expect(tokenInfo.supplyKey.toString()).to.eql(
                supplyKey.publicKey.toString(),
            );
            expect(tokenInfo.feeScheduleKey.toString()).to.eql(
                feeScheduleKey.publicKey.toString(),
            );
            expect(tokenInfo.metadataKey.toString()).to.eql(
                metadataKey.publicKey.toString(),
            );

            let status;

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setWipeKey(structurallyInvalidKey)
                            .freezeWith(env.client)
                            .sign(wipeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidWipeKey);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setFreezeKey(structurallyInvalidKey)
                            .freezeWith(env.client)
                            .sign(freezeKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidFreezeKey);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setPauseKey(structurallyInvalidKey)
                            .freezeWith(env.client)
                            .sign(pauseKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidPauseKey);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setSupplyKey(structurallyInvalidKey)
                            .freezeWith(env.client)
                            .sign(supplyKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidSupplyKey);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setFeeScheduleKey(structurallyInvalidKey)
                            .freezeWith(env.client)
                            .sign(feeScheduleKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidCustomFeeScheduleKey);

            try {
                await (
                    await (
                        await new TokenUpdateTransaction()
                            .setTokenId(tokenId)
                            .setKeyVerificationMode(
                                TokenKeyValidation.NoValidation,
                            )
                            .setMetadataKey(structurallyInvalidKey)
                            .freezeWith(env.client)
                            .sign(metadataKey)
                    ).execute(env.client)
                ).getReceipt(env.client);
            } catch (error) {
                status = error.status;
            }

            expect(status).to.be.eql(Status.InvalidMetadataKey);
        });
    });

    after(async function () {
        if (env != null) {
            env.close();
        }
    });
});
// Filename: test/integration/TokenWipeIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountInfoQuery,
    Hbar,
    PrivateKey,
    Status,
    TokenAssociateTransaction,
    TokenCreateTransaction,
    TokenGrantKycTransaction,
    TokenWipeTransaction,
    TransferTransaction,
    Transaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import Long from "long";

describe("TokenWipe", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TransferTransaction()
                .addTokenTransfer(token, account, 10)
                .addTokenTransfer(token, env.operatorId, -10)
                .execute(env.client)
        ).getReceipt(env.client);

        let info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        let relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(10);
        expect(relationship.isKycGranted).to.be.true;
        expect(relationship.isFrozen).to.be.false;

        await (
            await new TokenWipeTransaction()
                .setTokenId(token)
                .setAccountId(account)
                .setAmount(10)
                .execute(env.client)
        ).getReceipt(env.client);

        info = await new AccountInfoQuery()
            .setAccountId(account)
            .execute(env.client);

        relationship = info.tokenRelationships.get(token);

        expect(relationship).to.be.not.null;
        expect(relationship.tokenId.toString()).to.be.equal(token.toString());
        expect(relationship.balance.toInt()).to.be.equal(0);
        expect(relationship.isKycGranted).to.be.true;
        expect(relationship.isFrozen).to.be.false;
    });

    it("should error when token ID is not set", async function () {
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        let err = false;

        try {
            await (
                await (
                    await new TokenWipeTransaction()
                        .setAccountId(account)
                        .setAmount(10)
                        .freezeWith(env.client)
                        .sign(key)
                ).execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTokenId);
        }

        if (!err) {
            throw new Error("token wipe did not error");
        }
    });

    it("should error when account ID is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setDecimals(3)
            .setInitialSupply(1000000)
            .setTreasuryAccountId(operatorId)
            .setAdminKey(operatorKey)
            .setKycKey(operatorKey)
            .setFreezeKey(operatorKey)
            .setWipeKey(operatorKey)
            .setSupplyKey(operatorKey)
            .setFreezeDefault(false)
            .execute(env.client);

        const token = (await response.getReceipt(env.client)).tokenId;

        let err = false;

        try {
            await (
                await new TokenWipeTransaction()
                    .setTokenId(token)
                    .setAmount(10)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidAccountId);
        }

        if (!err) {
            throw new Error("token wipe did not error");
        }
    });

    it("should not error when amount is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;

        await (
            await (
                await new TokenAssociateTransaction()
                    .setTokenIds([token])
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await (
            await (
                await new TokenGrantKycTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        let err = false;

        try {
            await (
                await new TokenWipeTransaction()
                    .setTokenId(token)
                    .setAccountId(account)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error;
        }

        if (err) {
            throw new Error("token wipe did error");
        }
    });

    it("should convert fromBytes", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;
        const key = PrivateKey.generateED25519();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setInitialBalance(new Hbar(2))
            .execute(env.client);

        const account = (await response.getReceipt(env.client)).accountId;
        const serials = [1, 2, 3];

        const token = (
            await (
                await new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(operatorId)
                    .setAdminKey(operatorKey)
                    .setKycKey(operatorKey)
                    .setFreezeKey(operatorKey)
                    .setWipeKey(operatorKey)
                    .setSupplyKey(operatorKey)
                    .setFreezeDefault(false)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).tokenId;
        const transaction = new TokenWipeTransaction()
            .setTokenId(token)
            .setAccountId(account)
            .setSerials(serials)
            .freezeWith(env.client)
            .toBytes();

        const restoredTransaction = Transaction.fromBytes(transaction);

        expect(restoredTransaction.serials).to.be.an("array");
        expect(restoredTransaction.serials).to.have.length(3);
        expect(restoredTransaction.serials.toString()).to.deep.eql(
            serials.map((number) => Long.fromNumber(number)).toString(),
        );
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TopicCreateIntegrationTest.js
import {
    AccountBalanceQuery,
    AccountCreateTransaction,
    CustomFeeLimit,
    CustomFixedFee,
    Hbar,
    PrivateKey,
    PublicKey,
    Status,
    TokenId,
    TopicCreateTransaction,
    TopicDeleteTransaction,
    TopicInfoQuery,
    TopicMessageSubmitTransaction,
    TopicUpdateTransaction,
    TransactionId,
    TransferTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { createAccount, createFungibleToken } from "./utils/Fixtures.js";

/**
 * @typedef {import("./client/BaseIntegrationTestEnv.js").default} BaseIntegrationTestEnv
 */

describe("TopicCreate", function () {
    /**
     * @type {BaseIntegrationTestEnv}
     */
    let env;

    beforeEach(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        const info = await new TopicInfoQuery()
            .setTopicId(topic)
            .execute(env.client);

        expect(info.topicId.toString()).to.eql(topic.toString());
        expect(info.topicMemo).to.eql("");
        expect(info.runningHash.length).to.be.eql(48);
        expect(info.sequenceNumber.toInt()).to.eql(0);
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.submitKey.toString()).to.eql(operatorKey.toString());
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.be.eql(7776000);
        expect(info.expirationTime).to.be.not.null;

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable when no fields are set", async function () {
        const response = await new TopicCreateTransaction().execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        const info = await new TopicInfoQuery()
            .setTopicId(topic)
            .execute(env.client);

        expect(info.topicId.toString()).to.eql(topic.toString());
        expect(info.topicMemo).to.eql("");
        expect(info.runningHash.length).to.be.eql(48);
        expect(info.sequenceNumber.toInt()).to.eql(0);
        expect(info.adminKey).to.be.null;
        expect(info.submitKey).to.be.null;
        // as per HIP-1021 autoRenewAccountId should be set to the operator account id
        expect(info.autoRenewAccountId.toString()).to.equal(
            env.client.operatorAccountId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.be.eql(7776000);
        expect(info.expirationTime).to.be.not.null;
    });

    it("should set autorenew account from transaction ID", async function () {
        // Create a new account with 10 Hbar
        const accountKey = PrivateKey.generateECDSA();
        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(accountKey.publicKey)
            .setInitialBalance(new Hbar(10))
            .execute(env.client);

        const { accountId } = await response.getReceipt(env.client);

        // Create transaction ID with the new account
        const txId = TransactionId.generate(accountId);

        // Create and freeze token transaction
        const frozenTxn = await (
            await new TopicCreateTransaction()
                .setTransactionId(txId)
                .freezeWith(env.client)
                .sign(accountKey)
        ).execute(env.client);

        const { topicId } = await frozenTxn.getReceipt(env.client);

        // Query token info
        const info = await new TopicInfoQuery()
            .setNodeAccountIds([frozenTxn.nodeId])
            .setTopicId(topicId)
            .execute(env.client);

        console.log("created account id", accountId);
        console.log("topic account id", info.autoRenewAccountId);

        // Verify autoRenewAccountId matches the account that created the token
        expect(info.autoRenewAccountId.toString()).to.equal(
            accountId.toString(),
        );
    });

    describe("HIP-991: Permissionless revenue generating topics", function () {
        it("creates and updates revenue generating topic", async function () {
            const feeExemptKeys = [
                PrivateKey.generateECDSA(),
                PrivateKey.generateECDSA(),
            ];

            const denominatingTokenId1 = await createFungibleToken(env.client);
            const amount1 = 1;

            const denominatingTokenId2 = await createFungibleToken(
                env.client,
                (transaction) => {
                    transaction.setTokenName("denom2").setTokenSymbol("D2");
                },
            );

            const amount2 = 2;

            const customFixedFees = [
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.client.operatorAccountId)
                    .setDenominatingTokenId(denominatingTokenId1)
                    .setAmount(amount1),
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.client.operatorAccountId)
                    .setDenominatingTokenId(denominatingTokenId2)
                    .setAmount(amount2),
            ];

            const response = await new TopicCreateTransaction()
                .setFeeScheduleKey(env.client.operatorPublicKey)
                .setSubmitKey(env.client.operatorPublicKey)
                .setAdminKey(env.client.operatorPublicKey)
                .setFeeExemptKeys(feeExemptKeys)
                .setCustomFees(customFixedFees)
                .execute(env.client);

            const topicId = (await response.getReceipt(env.client)).topicId;

            const info = await new TopicInfoQuery()
                .setTopicId(topicId)
                .execute(env.client);

            expect(info.feeScheduleKey.toString()).to.eql(
                env.client.operatorPublicKey.toString(),
            );

            feeExemptKeys.forEach((feeExemptKey, index) => {
                expect(info.feeExemptKeys[index].toString()).to.eql(
                    feeExemptKey.publicKey.toString(),
                );
            });

            customFixedFees.forEach((customFixedFee, index) => {
                expect(info.customFees[index].amount.toString()).to.eql(
                    customFixedFee.amount.toString(),
                );
                expect(
                    info.customFees[index].denominatingTokenId.toString(),
                ).to.eql(customFixedFee.denominatingTokenId.toString());
            });

            // Update the revenue generating topic
            const newFeeExemptKeys = [
                PrivateKey.generateECDSA(),
                PrivateKey.generateECDSA(),
            ];

            const newFeeScheduleKey = PrivateKey.generateECDSA();

            const newAmount1 = 3;

            const newDenominatingTokenId1 = await createFungibleToken(
                env.client,
                (transaction) => {
                    transaction.setTokenName("Favor").setTokenSymbol("FVR");
                },
            );

            const newAmount2 = 4;

            const newDenominatingTokenId2 = await createFungibleToken(
                env.client,
                (transaction) => {
                    transaction.setTokenName("Duty").setTokenSymbol("DUT");
                },
            );

            const newCustomFixedFees = [
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.client.operatorAccountId)
                    .setAmount(newAmount1)
                    .setDenominatingTokenId(newDenominatingTokenId1),
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.client.operatorAccountId)
                    .setAmount(newAmount2)
                    .setDenominatingTokenId(newDenominatingTokenId2),
            ];

            const updateResponse = await new TopicUpdateTransaction()
                .setTopicId(topicId)
                .setFeeExemptKeys(newFeeExemptKeys)
                .setFeeScheduleKey(newFeeScheduleKey.publicKey)
                .setCustomFees(newCustomFixedFees)
                .execute(env.client);

            await updateResponse.getReceipt(env.client);

            const updatedInfo = await new TopicInfoQuery()
                .setTopicId(topicId)
                .execute(env.client);

            expect(updatedInfo.feeScheduleKey.toString()).to.eql(
                newFeeScheduleKey.publicKey.toString(),
            );

            newFeeExemptKeys.forEach((feeExemptKey, index) => {
                expect(updatedInfo.feeExemptKeys[index].toString()).to.eql(
                    feeExemptKey.publicKey.toString(),
                );
            });

            newCustomFixedFees.forEach((customFixedFee, index) => {
                expect(updatedInfo.customFees[index].amount.toString()).to.eql(
                    customFixedFee.amount.toString(),
                );
                expect(
                    updatedInfo.customFees[
                        index
                    ].denominatingTokenId.toString(),
                ).to.eql(customFixedFee.denominatingTokenId.toString());
            });
        });

        it("should fail to create a revenue generating topic with invalid fee exempt key", async function () {
            const feeExemptKey = PrivateKey.generateECDSA();

            const feeExemptKeyListWithDuplicates = [feeExemptKey, feeExemptKey];

            // Duplicate exempt key - fails with FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS
            try {
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeExemptKeys(feeExemptKeyListWithDuplicates)
                    .execute(env.client);
            } catch (e) {
                expect(
                    e.message.includes(
                        Status.FeeExemptKeyListContainsDuplicatedKeys.toString(),
                    ),
                ).to.be.true;
            }

            const invalidKey = PublicKey.fromString(
                "000000000000000000000000000000000000000000000000000000000000000000",
            );

            // Invalid exempt key - fails with INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST

            try {
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeExemptKeys([invalidKey])
                    .execute(env.client);
            } catch (e) {
                expect(
                    e.message.includes(
                        Status.InvalidKeyInFeeExemptKeyList.toString(),
                    ),
                ).to.be.true;
            }

            // Create a list with 11 keys
            const feeExemptKeyListExceedingLimit = [
                ...new Array(11).fill(null).map(PrivateKey.generateECDSA),
            ];

            // Set 11 keys - fails with MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED

            try {
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeExemptKeys(feeExemptKeyListExceedingLimit)
                    .execute(env.client);
            } catch (e) {
                expect(
                    e.message.includes(
                        Status.MaxEntriesForFeeExemptKeyListExceeded.toString(),
                    ),
                ).to.be.true;
            }
        });

        it("should fail to update fee schedule key", async function () {
            // Create a revenue generating topic without fee schedule key
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .execute(env.client)
            ).getReceipt(env.client);

            const newFeeScheduleKey = PrivateKey.generateECDSA();

            // Update the revenue generating topic with new fee schedule key - fails with FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED

            try {
                await new TopicUpdateTransaction()
                    .setTopicId(topicId)
                    .setFeeScheduleKey(newFeeScheduleKey.publicKey)
                    .execute(env.client);
            } catch (e) {
                expect(
                    e.message.includes(
                        Status.FeeScheduleKeyCannotBeUpdated.toString(),
                    ),
                ).to.be.true;
            }
        });

        it("should fail to update custom fees", async function () {
            // Create a revenue generating topic without fee schedule key
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .execute(env.client)
            ).getReceipt(env.client);

            const denominatingTokenId1 = await createFungibleToken(env.client);
            const amount1 = 1;

            const denominatingTokenId2 = await createFungibleToken(
                env.client,
                (transaction) => {
                    transaction.setTokenName("denom2").setTokenSymbol("D2");
                },
            );

            const amount2 = 2;

            const customFixedFees = [
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.client.operatorAccountId)
                    .setDenominatingTokenId(denominatingTokenId1)
                    .setAmount(amount1),
                new CustomFixedFee()
                    .setFeeCollectorAccountId(env.client.operatorAccountId)
                    .setDenominatingTokenId(denominatingTokenId2)
                    .setAmount(amount2),
            ];

            // Update the revenue generating topic with new custom fees - fails with FEE_SCHEDULE_KEY_NOT_SET
            try {
                await new TopicUpdateTransaction()
                    .setTopicId(topicId)
                    .setCustomFees(customFixedFees)
                    .execute(env.client);
            } catch (e) {
                expect(
                    e.message.includes(Status.FeeScheduleKeyNotSet.toString()),
                ).to.be.true;
            }
        });

        it("should charge hbars with limit", async function () {
            const hbar = 100_000_000;

            const customFixedFee = new CustomFixedFee()
                .setFeeCollectorAccountId(env.client.operatorAccountId)
                .setAmount(hbar / 2);

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .addCustomFee(customFixedFee)

                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer with 1 Hbar
            const {
                accountId: payerAccountId,
                newKey: payerAccountPrivateKey,
            } = await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(1));
            });

            const customFeeLimit = new CustomFeeLimit()
                .setAccountId(payerAccountId)
                .setFees([customFixedFee]);

            // Submit a message to the revenue generating topic with custom fee limit
            env.client.setOperator(payerAccountId, payerAccountPrivateKey);

            const submitMessageResponse =
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .addCustomFeeLimit(customFeeLimit)
                    .freezeWith(env.client)
                    .execute(env.client);

            await submitMessageResponse.getReceipt(env.client);

            env.client.setOperator(env.operatorId, env.operatorKey);

            // Verify the custom fee charged

            const accountInfo = await new AccountBalanceQuery()
                .setAccountId(payerAccountId)
                .execute(env.client);

            expect(accountInfo.hbars.toTinybars().toNumber()).to.be.below(
                hbar / 2,
            );
        });

        it("should charge tokens with limit", async function () {
            const tokenId = await createFungibleToken(env.client);

            const customFixedFee = new CustomFixedFee()
                .setAmount(1)
                .setDenominatingTokenId(tokenId)
                .setFeeCollectorAccountId(env.client.operatorAccountId);

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .addCustomFee(customFixedFee)

                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer
            const {
                accountId: payerAccountId,
                newKey: payerAccountPrivateKey,
            } = await createAccount(env.client, (transaction) => {
                transaction.setMaxAutomaticTokenAssociations(-1);
            });

            // Send tokens to payer
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.client.operatorAccountId, -1)
                    .addTokenTransfer(tokenId, payerAccountId, 1)
                    .execute(env.client)
            ).getReceipt(env.client);

            const customFeeLimit = new CustomFeeLimit()
                .setAccountId(payerAccountId)
                .setFees([
                    new CustomFixedFee()
                        .setAmount(1)
                        .setDenominatingTokenId(tokenId),
                ]);

            // Submit a message to the revenue generating topic with custom fee limit
            env.client.setOperator(payerAccountId, payerAccountPrivateKey);

            const submitMessageResponse =
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .addCustomFeeLimit(customFeeLimit)
                    .freezeWith(env.client)
                    .execute(env.client);

            await submitMessageResponse.getReceipt(env.client);

            env.client.setOperator(env.operatorId, env.operatorKey);

            // Verify the custom fee charged

            const accountInfo = await new AccountBalanceQuery()
                .setAccountId(payerAccountId)
                .execute(env.client);

            expect(accountInfo.tokens.get(tokenId).toNumber()).to.be.eql(0);
        });

        it("should charge tokens without limit", async function () {
            const tokenId = await createFungibleToken(env.client);

            const customFixedFee = new CustomFixedFee()
                .setAmount(1)
                .setDenominatingTokenId(tokenId)
                .setFeeCollectorAccountId(env.client.operatorAccountId);

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .addCustomFee(customFixedFee)

                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer
            const {
                accountId: payerAccountId,
                newKey: payerAccountPrivateKey,
            } = await createAccount(env.client, (transaction) => {
                transaction.setMaxAutomaticTokenAssociations(-1);
            });

            // Send tokens to payer
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.client.operatorAccountId, -1)
                    .addTokenTransfer(tokenId, payerAccountId, 1)
                    .execute(env.client)
            ).getReceipt(env.client);

            // Submit a message to the revenue generating topic without custom fee limit
            env.client.setOperator(payerAccountId, payerAccountPrivateKey);

            const submitMessageResponse =
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .freezeWith(env.client)
                    .execute(env.client);

            await submitMessageResponse.getReceipt(env.client);

            env.client.setOperator(env.operatorId, env.operatorKey);

            // Verify the custom fee charged

            const accountInfo = await new AccountBalanceQuery()
                .setAccountId(payerAccountId)
                .execute(env.client);

            expect(accountInfo.tokens.get(tokenId).toNumber()).to.be.eql(0);
        });

        it("should not charge hbars for fee exempt keys", async function () {
            const hbar = 100_000_000;

            const customFixedFee = new CustomFixedFee()
                .setFeeCollectorAccountId(env.client.operatorAccountId)
                .setAmount(hbar / 2);

            const feeExemptKey1 = PrivateKey.generateECDSA();
            const feeExemptKey2 = PrivateKey.generateECDSA();

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .setFeeExemptKeys([feeExemptKey1, feeExemptKey2])
                    .addCustomFee(customFixedFee)
                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer with 1 Hbar and fee exempt key
            const { accountId: payerAccountId } = await createAccount(
                env.client,
                (transaction) => {
                    transaction.setInitialBalance(new Hbar(1));
                    transaction.setKeyWithoutAlias(feeExemptKey1);
                },
            );

            // Submit a message to the revenue generating topic without custom fee limit
            env.client.setOperator(payerAccountId, feeExemptKey1);

            const submitMessageResponse =
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .execute(env.client);

            await submitMessageResponse.getReceipt(env.client);

            env.client.setOperator(env.operatorId, env.operatorKey);

            // Verify the custom fee is not charged

            const accountInfo = await new AccountBalanceQuery()
                .setAccountId(payerAccountId)
                .execute(env.client);

            expect(accountInfo.hbars.toTinybars().toNumber()).to.be.above(
                hbar / 2,
            );
        });

        it("should not charge tokens for fee exempt keys", async function () {
            const tokenId = await createFungibleToken(env.client);

            const customFixedFee = new CustomFixedFee()
                .setDenominatingTokenId(tokenId)
                .setFeeCollectorAccountId(env.client.operatorAccountId)
                .setAmount(1);

            const feeExemptKey1 = PrivateKey.generateECDSA();
            const feeExemptKey2 = PrivateKey.generateECDSA();

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .setFeeExemptKeys([feeExemptKey1, feeExemptKey2])
                    .addCustomFee(customFixedFee)

                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer with fee exempt key and unlimited token associations
            const { accountId: payerAccountId } = await createAccount(
                env.client,
                (transaction) => {
                    transaction
                        .setKeyWithoutAlias(feeExemptKey1.publicKey)
                        .setMaxAutomaticTokenAssociations(-1);
                },
            );

            // Send tokens to payer
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.client.operatorAccountId, -1)
                    .addTokenTransfer(tokenId, payerAccountId, 1)
                    .execute(env.client)
            ).getReceipt(env.client);

            // Submit a message to the revenue generating topic without custom fee limit
            env.client.setOperator(payerAccountId, feeExemptKey1);

            const submitMessageResponse =
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .execute(env.client);

            await submitMessageResponse.getReceipt(env.client);

            env.client.setOperator(env.operatorId, env.operatorKey);

            // Verify the custom fee is not charged

            const accountInfo = await new AccountBalanceQuery()
                .setAccountId(payerAccountId)
                .execute(env.client);

            expect(accountInfo.tokens.get(tokenId).toNumber()).to.eql(1);
        });

        it("should not charge hbars with lower limit", async function () {
            const hbar = 100_000_000;

            const customFixedFee = new CustomFixedFee()
                .setFeeCollectorAccountId(env.client.operatorAccountId)
                .setAmount(hbar / 2);

            // Create a revenue generating topic with Hbar custom fee
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .addCustomFee(customFixedFee)

                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer with 1 Hbar
            const {
                accountId: payerAccountId,
                newKey: payerAccountPrivateKey,
            } = await createAccount(env.client, (transaction) => {
                transaction.setInitialBalance(new Hbar(1));
            });

            // Set custom fee limit with lower amount than the custom fee
            const customFeeLimit = new CustomFeeLimit()
                .setAccountId(payerAccountId)
                .setFees([new CustomFixedFee().setAmount(hbar / 2 - 1)]);

            // Submit a message to the revenue generating topic with custom fee limit
            env.client.setOperator(payerAccountId, payerAccountPrivateKey);

            try {
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .addCustomFeeLimit(customFeeLimit)
                    .freezeWith(env.client)
                    .execute(env.client);
            } catch (e) {
                expect(e.message).to.include(Status.MaxCustomFeeLimitExceeded);
            }
        });

        it("should not charge tokens with lower limit", async function () {
            const tokenId = await createFungibleToken(env.client);

            const customFixedFee = new CustomFixedFee()
                .setAmount(2)
                .setDenominatingTokenId(tokenId)
                .setFeeCollectorAccountId(env.client.operatorAccountId);

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .addCustomFee(customFixedFee)
                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer with unlimited token associacions
            const {
                accountId: payerAccountId,
                newKey: payerAccountPrivateKey,
            } = await createAccount(env.client, (transaction) => {
                transaction.setMaxAutomaticTokenAssociations(-1);
            });

            // Send tokens to payer
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.client.operatorAccountId, -2)
                    .addTokenTransfer(tokenId, payerAccountId, 2)
                    .execute(env.client)
            ).getReceipt(env.client);

            // Set custom fee limit with lower amount than the custom fee
            const customFeeLimit = new CustomFeeLimit()
                .setAccountId(payerAccountId)
                .setFees([
                    new CustomFixedFee()
                        .setAmount(1)
                        .setDenominatingTokenId(tokenId),
                ]);

            // Submit a message to the revenue generating topic with custom fee limit
            env.client.setOperator(payerAccountId, payerAccountPrivateKey);

            // Submit a message to the revenue generating topic with custom fee limit - fails with MAX_CUSTOM_FEE_LIMIT_EXCEEDED
            try {
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .addCustomFeeLimit(customFeeLimit)
                    .freezeWith(env.client)
                    .execute(env.client);
            } catch (e) {
                expect(e.message).to.include(Status.MaxCustomFeeLimitExceeded);
            }
        });

        it("should not execute with invalid custom fee limit", async function () {
            const tokenId = await createFungibleToken(env.client);

            const customFixedFee = new CustomFixedFee()
                .setAmount(2)
                .setDenominatingTokenId(tokenId)
                .setFeeCollectorAccountId(env.client.operatorAccountId);

            // Create a revenue generating topic
            const { topicId } = await (
                await new TopicCreateTransaction()
                    .setAdminKey(env.client.operatorPublicKey)
                    .setFeeScheduleKey(env.client.operatorPublicKey)
                    .addCustomFee(customFixedFee)

                    .execute(env.client)
            ).getReceipt(env.client);

            // Create payer with unlimited token associacions
            const {
                accountId: payerAccountId,
                newKey: payerAccountPrivateKey,
            } = await createAccount(env.client, (transaction) => {
                transaction.setMaxAutomaticTokenAssociations(-1);
            });

            // Send tokens to payer
            await (
                await new TransferTransaction()
                    .addTokenTransfer(tokenId, env.client.operatorAccountId, -2)
                    .addTokenTransfer(tokenId, payerAccountId, 2)
                    .execute(env.client)
            ).getReceipt(env.client);

            // Set custom fee limit with lower amount than the custom fee
            let customFeeLimit = new CustomFeeLimit()
                .setAccountId(payerAccountId)
                .setFees([
                    new CustomFixedFee()
                        .setAmount(1)
                        .setDenominatingTokenId(new TokenId(0)),
                ]);

            // Submit a message to the revenue generating topic with custom fee limit
            env.client.setOperator(payerAccountId, payerAccountPrivateKey);

            // Submit a message to the revenue generating topic with invalid custom fee limit - fails with NO_VALID_MAX_CUSTOM_FEE
            try {
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .addCustomFeeLimit(customFeeLimit)
                    .freezeWith(env.client)
                    .execute(env.client);
            } catch (e) {
                expect(e.message).to.include(Status.NoValidMaxCustomFee);
            }

            customFeeLimit = new CustomFeeLimit()
                .setAccountId(payerAccountId)
                .setFees([
                    new CustomFixedFee()
                        .setAmount(1)
                        .setDenominatingTokenId(tokenId),
                    new CustomFixedFee()
                        .setAmount(2)
                        .setDenominatingTokenId(tokenId),
                ]);
            // Submit a message to the revenue generating topic - fails with DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST
            try {
                await new TopicMessageSubmitTransaction()
                    .setMessage("Hello, Hedera!")
                    .setTopicId(topicId)
                    .addCustomFeeLimit(customFeeLimit)
                    .freezeWith(env.client)
                    .execute(env.client);
            } catch (e) {
                expect(e.message).to.include(
                    Status.DuplicateDenominationInMaxCustomFeeList,
                );
            }
        });
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TopicDeleteIntegrationTest.js
import {
    Status,
    TopicCreateTransaction,
    TopicDeleteTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TopicDelete", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should error when deleting immutable topic", async function () {
        const response = await new TopicCreateTransaction().execute(env.client);
        const topic = (await response.getReceipt(env.client)).topicId;

        let err = false;

        try {
            await (
                await new TopicDeleteTransaction()
                    .setTopicId(topic)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.Unauthorized);
        }

        if (!err) {
            throw new Error("topic deletion did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TopicInfoIntegrationTest.js
import {
    TopicCreateTransaction,
    TopicDeleteTransaction,
    TopicInfoQuery,
    Status,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TopicInfo", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new();
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        const info = await new TopicInfoQuery()
            .setTopicId(topic)
            .execute(env.client);

        expect(info.topicId.toString()).to.eql(topic.toString());
        expect(info.topicMemo).to.eql("");
        expect(info.runningHash.length).to.be.eql(48);
        expect(info.sequenceNumber.toInt()).to.eql(0);
        expect(info.adminKey.toString()).to.eql(operatorKey.toString());
        expect(info.submitKey.toString()).to.eql(operatorKey.toString());
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            operatorId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.be.eql(7776000);
        expect(info.expirationTime).to.be.not.null;
        expect(info.metadataKey).to.be.not.null;
        expect(info.metadata).to.be.not.null;

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);
    });

    it("should be executable when no fields are set", async function () {
        const response = await new TopicCreateTransaction().execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        const info = await new TopicInfoQuery()
            .setTopicId(topic)
            .execute(env.client);

        expect(info.topicId.toString()).to.eql(topic.toString());
        expect(info.topicMemo).to.eql("");
        expect(info.runningHash.length).to.be.eql(48);
        expect(info.sequenceNumber.toInt()).to.eql(0);
        expect(info.adminKey).to.be.null;
        expect(info.submitKey).to.be.null;
        expect(info.autoRenewAccountId.toString()).to.be.eql(
            env.operatorId.toString(),
        );
        expect(info.autoRenewPeriod.seconds.toInt()).to.be.eql(7776000);
        expect(info.expirationTime).to.be.not.null;
    });

    it("should be able to query cost", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        const cost = await new TopicInfoQuery()
            .setTopicId(topic)
            .getCost(env.client);

        expect(cost.toTinybars().toInt()).to.be.at.least(1);
    });

    it("should error on query cost on deleted topic with INVALID_TOPIC_ID", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);

        let err;
        try {
            await new TopicInfoQuery().setTopicId(topic).getCost(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTopicId.toString());
        }

        if (!err) {
            throw new Error("query cost did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TopicMessageIntegrationTest.js
import { setTimeout } from "timers/promises";
import {
    Status,
    TopicCreateTransaction,
    TopicDeleteTransaction,
    TopicMessageQuery,
    TopicMessageSubmitTransaction,
} from "../../src/exports.js";
import { bigContents } from "./contents.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TopicMessage", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new({ throwaway: true });
    });

    // eslint-disable-next-line mocha/no-skipped-tests
    it.skip("should be executable", async function () {
        const operatorKey = env.operatorKey.publicKey;

        let finished = false;
        const contents = "Hello from Hiero SDK JS";

        const { topicId } = await (
            await new TopicCreateTransaction()
                .setAdminKey(operatorKey)
                .execute(env.client)
        ).getReceipt(env.client);

        // wait for mirror node to see new topic id
        await setTimeout(2500);

        new TopicMessageQuery()
            .setTopicId(topicId)
            .setStartTime(0)
            .setLimit(1)
            .setCompletionHandler(() => {
                finished = true;
            })
            // eslint-disable-next-line no-unused-vars
            .subscribe(env.client, (_) => {
                // Do nothing
            });

        // waiting for mirror node
        await setTimeout(2500);
        await (
            await new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage(contents)
                .execute(env.client)
        ).getReceipt(env.client);

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(env.client)
        ).getReceipt(env.client);

        // waiting for setCompletionHandler to be executed
        await setTimeout(1000);

        if (!finished) {
            throw new Error("Failed to receive message in 30s");
        }
    });

    it("should be executable with large message", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        // Skip this test if we do not have a mirror network
        if (env.client.mirrorNetwork.length == 0) {
            return;
        }

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        let finished = false;

        // waiting for mirror node to see the new topic
        await setTimeout(1000);
        new TopicMessageQuery()
            .setTopicId(topic)
            .setStartTime(0)
            .setLimit(14)
            .setCompletionHandler(() => {
                finished = true;
            })
            // eslint-disable-next-line no-unused-vars
            .subscribe(env.client, (_) => {
                // Do nothing
            });

        await setTimeout(1000);
        const startTime = Date.now();

        await (
            await new TopicMessageSubmitTransaction()
                .setTopicId(topic)
                .setMessage(bigContents)
                .setMaxChunks(14)
                .execute(env.client)
        ).getReceipt(env.client);

        while (!finished && Date.now() < startTime + 45000) {
            //NOSONAR
            await setTimeout(2000);
        }

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);

        // need to wait for completionHandler to be called
        await setTimeout(1000);

        if (!finished) {
            throw new Error("Failed to receive message in 45s");
        }
    });

    it("should error when topic ID is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        // Skip this test if we do not have a mirror network
        if (env.client.mirrorNetwork.length == 0) {
            return;
        }

        // Skip this test if we do not have a mirror network
        if (env.client.mirrorNetwork.length == 0) {
            return;
        }

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        const contents = "Hello from Hiero SDK JS";

        let err = false;

        try {
            await (
                await new TopicMessageSubmitTransaction()
                    .setMessage(contents)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTopicId);
        }

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("topic message did not error");
        }
    });

    it("should error when message is not set", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        // Skip this test if we do not have a mirror network
        if (env.client.mirrorNetwork.length == 0) {
            return;
        }

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const topic = (await response.getReceipt(env.client)).topicId;

        let err = false;

        try {
            await (
                await new TopicMessageSubmitTransaction()
                    .setTopicId(topic)
                    .execute(env.client)
            ).getReceipt(env.client);
        } catch (error) {
            err = error.toString().includes(Status.InvalidTopicMessage);
        }

        await (
            await new TopicDeleteTransaction()
                .setTopicId(topic)
                .execute(env.client)
        ).getReceipt(env.client);

        if (!err) {
            throw new Error("topic message did not error");
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TopicMessageQueryTest.js
import { setTimeout } from "timers/promises";
import {
    TopicMessageQuery,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
    TopicDeleteTransaction,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TopicMessageQuery", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new({ throwaway: true });
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        const operatorKey = env.operatorKey.publicKey;

        const response = await new TopicCreateTransaction()
            .setAdminKey(operatorKey)
            .setSubmitKey(operatorKey)
            .setAutoRenewAccountId(operatorId)
            .execute(env.client);

        const { topicId } = await response.getReceipt(env.client);
        const contents = "Hello from Hiero SDK JS";
        let expectedContents = "";

        let finished = false;

        // wait for mirror node to receive the new topic
        await setTimeout(5000);
        new TopicMessageQuery()
            .setTopicId(topicId)
            .setLimit(1)
            // eslint-disable-next-line no-unused-vars
            .subscribe(env.client, (topic, _) => {
                finished = true;
                expectedContents = Buffer.from(topic.contents).toString(
                    "utf-8",
                );
            });

        await setTimeout(2000);
        await (
            await new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage(contents)
                .execute(env.client)
        ).getReceipt(env.client);

        await new TopicDeleteTransaction()
            .setTopicId(topicId)
            .execute(env.client);

        //NOSONAR
        await setTimeout(5000);

        if (!finished) {
            throw new Error("Did not receive message from query");
        }
        expect(expectedContents).to.equal(contents);
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TransactionIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountDeleteTransaction,
    AccountId,
    FileCreateTransaction,
    Hbar,
    PrivateKey,
    TokenCreateTransaction,
    TransferTransaction,
    TransactionReceipt,
    TransactionResponse,
    Transaction,
    TransactionId,
    Timestamp,
    AccountUpdateTransaction,
    KeyList,
    Status,
} from "../../src/exports.js";
import * as hex from "../../src/encoding/hex.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";
import { expect } from "chai";
import { Client } from "./client/NodeIntegrationTestEnv.js";

describe("TransactionIntegration", function () {
    it("should be executable", async function () {
        const env = await IntegrationTestEnv.new();
        const operatorId = env.operatorId;
        expect(operatorId).to.not.be.null;

        const key = PrivateKey.generateED25519();

        const transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .freezeWith(env.client)
            .signWithOperator(env.client);

        const expectedHash = await transaction.getTransactionHash();

        const response = await transaction.execute(env.client);

        const record = await response.getRecord(env.client);

        expect(hex.encode(expectedHash)).to.be.equal(
            hex.encode(record.transactionHash),
        );

        const account = record.receipt.accountId;
        expect(account).to.not.be.null;

        await (
            await (
                await new AccountDeleteTransaction()
                    .setAccountId(account)
                    .setTransferAccountId(operatorId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);

        await env.close();
    });

    it("signs on demand", async function () {
        const env = await IntegrationTestEnv.new();
        env.client.setSignOnDemand(true);

        const fileId = (
            await (
                await new FileCreateTransaction()
                    .setContents("test")
                    .execute(env.client)
            ).getReceipt(env.client)
        ).fileId;

        expect(fileId.num).to.not.be.equal(0);

        await env.close();
    });

    it("signs correctly", async function () {
        const env = await IntegrationTestEnv.new();
        const key = PrivateKey.generateED25519();

        let transaction = await (
            await new TokenCreateTransaction()
                .setAdminKey(key.publicKey)
                .freezeWith(env.client)
                .sign(key)
        ).signWithOperator(env.client);

        expect(
            transaction._signedTransactions.list[0].sigMap.sigPair.length,
        ).to.eql(2);

        transaction = await (
            await new TokenCreateTransaction()
                .setAdminKey(key.publicKey)
                .freezeWith(env.client)
                .signWithOperator(env.client)
        ).sign(key);

        expect(
            transaction._signedTransactions.list[0].sigMap.sigPair.length,
        ).to.eql(2);

        await env.close();
    });

    it("issue-327", async function () {
        const env = await IntegrationTestEnv.new();
        const privateKey1 = PrivateKey.generateED25519();
        const privateKey2 = PrivateKey.generateED25519();
        const privateKey3 = PrivateKey.generateED25519();
        const privateKey4 = PrivateKey.generateED25519();
        const publicKey1 = privateKey1.publicKey;
        const publicKey2 = privateKey2.publicKey;
        const publicKey3 = privateKey3.publicKey;
        const publicKey4 = privateKey4.publicKey;

        const nodeAccountId = Object.values(env.client.network)[0];

        const transaction = new TransferTransaction()
            .setNodeAccountIds([nodeAccountId])
            .addHbarTransfer(
                env.client.operatorAccountId,
                new Hbar(1).negated(),
            )
            .addHbarTransfer(new AccountId(3), new Hbar(1))
            .freezeWith(env.client);

        const signature1 = privateKey1.signTransaction(transaction);
        const signature2 = privateKey2.signTransaction(transaction);
        const signature3 = privateKey3.signTransaction(transaction);

        transaction
            .addSignature(publicKey1, signature1)
            .addSignature(publicKey2, signature2)
            .addSignature(publicKey3, signature3);

        const signatures = transaction.getSignatures();

        const nodeSignatures = signatures.get(nodeAccountId);

        const publicKey1Signature = nodeSignatures
            .get(transaction.transactionId)
            .get(publicKey1);
        const publicKey2Signature = nodeSignatures
            .get(transaction.transactionId)
            .get(publicKey2);
        const publicKey3Signature = nodeSignatures
            .get(transaction.transactionId)
            .get(publicKey3);
        const publicKey4Signature = nodeSignatures
            .get(transaction.transactionId)
            .get(publicKey4);

        expect(publicKey1Signature).to.be.not.null;
        expect(publicKey2Signature).to.be.not.null;
        expect(publicKey3Signature).to.be.not.null;
        expect(publicKey4Signature).to.be.null;

        await env.close();
    });

    describe("HIP-745 - create incomplete transaction", function () {
        let env, operatorId, recipientKey, recipientId, client, wallet;

        beforeEach(async function () {
            env = await IntegrationTestEnv.new();
            operatorId = env.operatorId;
            recipientKey = PrivateKey.generateECDSA();
            recipientId = recipientKey.publicKey.toAccountId(0, 0);
            client = env.client;
            wallet = env.wallet;
        });

        afterEach(function () {
            client.close();
        });

        /** @description: example serialize-deserialize-1.js */
        it("should serialize and deserialize the so-called signed transaction, and execute it", async function () {
            try {
                // 1. Create transaction and freeze it
                const transaction = new TransferTransaction()
                    .addHbarTransfer(operatorId, new Hbar(-1))
                    .addHbarTransfer(recipientId, new Hbar(1))
                    .freezeWith(client);

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );

                // 4. Sign and execute transaction
                const response = await (
                    await transactionFromBytes.sign(recipientKey)
                ).execute(client);
                expect(response).to.be.instanceof(TransactionResponse);
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(false);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(false);

                // 5. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-2.js */
        it("should serialize and deserialize the so-called signed transaction after being signed, and execute it", async function () {
            try {
                // 1. Create transaction and freeze it
                let transaction = new TransferTransaction()
                    .addHbarTransfer(operatorId, new Hbar(-1))
                    .addHbarTransfer(recipientId, new Hbar(1))
                    .freezeWith(client);

                // 2. Sign transaction
                await transaction.sign(recipientKey);

                // 3. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 4. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(false);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(false);

                // 5. Execute transaction
                const response = await transactionFromBytes.execute(client);
                expect(response).to.be.instanceof(TransactionResponse);

                // 6. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-3.js */
        it("should serialize and deserialize so-called incomplete transaction, and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new TransferTransaction()
                    .addHbarTransfer(operatorId, new Hbar(-1))
                    .addHbarTransfer(recipientId, new Hbar(1));

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Freeze, sign and execute transaction
                const response = await (
                    await transactionFromBytes
                        .freezeWith(client)
                        .sign(recipientKey)
                ).execute(client);
                expect(response).to.be.instanceof(TransactionResponse);

                // 5. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-4.js */
        it("should serialize and deserialize so-called incomplete transaction, set node account ids and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new TransferTransaction()
                    .addHbarTransfer(operatorId, new Hbar(-1))
                    .addHbarTransfer(recipientId, new Hbar(1));

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                let transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Set node account ids
                const nodeAccountId = new AccountId(3);
                transactionFromBytes.setNodeAccountIds([nodeAccountId]);

                expect(
                    transactionFromBytes._nodeAccountIds.get(0).toString(),
                ).to.be.equal(nodeAccountId.toString());

                // 5. Freeze, sign and execute transaction
                const response = await (
                    await transactionFromBytes
                        .freezeWith(client)
                        .sign(recipientKey)
                ).execute(client);
                expect(response).to.be.instanceof(TransactionResponse);

                // 6. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-5.js */
        it("should serialize and deserialize so-called incomplete transaction, set transaction id and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new TransferTransaction()
                    .addHbarTransfer(operatorId, new Hbar(-1))
                    .addHbarTransfer(recipientId, new Hbar(1));

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                let transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Set transaction id
                const validStart = new Timestamp(
                    Math.floor(Date.now() / 1000),
                    0,
                );
                const transactionId = new TransactionId(operatorId, validStart);
                transactionFromBytes.setTransactionId(transactionId);

                expect(
                    transactionFromBytes._transactionIds.get(0).toString(),
                ).to.be.equal(transactionId.toString());

                // 5. Freeze, sign and execute transaction
                const response = await (
                    await transactionFromBytes
                        .freezeWith(client)
                        .sign(recipientKey)
                ).execute(client);
                expect(response).to.be.instanceof(TransactionResponse);

                // 6. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-6.js */
        it("should serialize and deserialize so-called incomplete transaction, update and execute it", async function () {
            const amount = new Hbar(1);
            try {
                // 1. Create transaction
                const transaction = new TransferTransaction().addHbarTransfer(
                    operatorId,
                    amount.negated(),
                );

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);
                expect(transactionFromBytes._hbarTransfers.length).to.be.equal(
                    1,
                );

                // 4. Check the transaction type and use particular method of
                // the corresponding class in order to update the transaction
                if (transactionFromBytes instanceof TransferTransaction) {
                    transactionFromBytes.addHbarTransfer(recipientId, amount);
                }

                expect(transactionFromBytes._hbarTransfers.length).to.be.equal(
                    2,
                );
                expect(
                    transactionFromBytes._hbarTransfers[1].accountId.toString(),
                ).to.be.equal(recipientId.toString());
                expect(
                    transactionFromBytes._hbarTransfers[1].amount.toString(),
                ).to.be.equal(amount.toString());

                // 4. Freeze, sign and execute transaction
                const response = await (
                    await transactionFromBytes
                        .freezeWith(client)
                        .sign(recipientKey)
                ).execute(client);
                expect(response).to.be.instanceof(TransactionResponse);

                // 5. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-7.js */
        it("should serialize and deserialize so-called signed transaction (chunked), and execute it", async function () {
            try {
                // 1. Create transaction and freeze it
                const transaction = await new FileCreateTransaction()
                    .setKeys([wallet.getAccountKey()])
                    .setContents("[e2e::FileCreateTransaction]")
                    .freezeWithSigner(wallet);

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);

                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );

                // 4. Sign and execute transaction
                const response = await (
                    await transactionFromBytes.signWithSigner(wallet)
                ).executeWithSigner(wallet);
                expect(response).to.be.instanceof(TransactionResponse);

                // 5. Get a receipt
                const receipt = await response.getReceiptWithSigner(wallet);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-8.js */
        it("should serialize and deserialize so-called incomplete transaction (chunked), and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new FileCreateTransaction()
                    .setKeys([wallet.getAccountKey()])
                    .setContents("[e2e::FileCreateTransaction]");

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);
                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Freeze, sign and execute transaction
                const response = await (
                    await (
                        await transactionFromBytes.freezeWithSigner(wallet)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet);
                expect(response).to.be.instanceof(TransactionResponse);

                // 5. Get a receipt
                const receipt = await response.getReceiptWithSigner(wallet);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-9.js */
        it("should serialize and deserialize so-called incomplete transaction (chunked), update and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new FileCreateTransaction()
                    .setKeys([wallet.getAccountKey()])
                    .setContents("[e2e::FileCreateTransaction]");

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);
                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Check the transaction type and use particular method of
                // the corresponding class in order to update the transaction
                if (transactionFromBytes instanceof FileCreateTransaction) {
                    transactionFromBytes.setFileMemo("Test");
                }
                expect(transactionFromBytes.fileMemo).to.be.equal("Test");

                // 5. Freeze, sign and execute transaction
                const response = await (
                    await (
                        await transactionFromBytes.freezeWithSigner(wallet)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet);
                expect(response).to.be.instanceof(TransactionResponse);

                // 6. Get a receipt
                const receipt = await response.getReceiptWithSigner(wallet);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-10.js */
        it("should serialize and deserialize so-called incomplete transaction (chunked), set transaction id and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new FileCreateTransaction()
                    .setKeys([wallet.getAccountKey()])
                    .setContents("[e2e::FileCreateTransaction]");

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                let transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);
                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Set transaction id
                const validStart = new Timestamp(
                    Math.floor(Date.now() / 1000),
                    0,
                );
                const transactionId = new TransactionId(operatorId, validStart);
                transactionFromBytes.setTransactionId(transactionId);
                expect(
                    transactionFromBytes._transactionIds.get(0).toString(),
                ).to.be.equal(transactionId.toString());

                // 5. Freeze, sign and execute transaction
                const response = await (
                    await (
                        await transactionFromBytes.freezeWithSigner(wallet)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet);
                expect(response).to.be.instanceof(TransactionResponse);

                // 6. Get a receipt
                const receipt = await response.getReceiptWithSigner(wallet);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-11.js */
        it("should serialize and deserialize so-called incomplete transaction (chunked), set node account ids and execute it", async function () {
            try {
                // 1. Create transaction
                const transaction = new FileCreateTransaction()
                    .setKeys([wallet.getAccountKey()])
                    .setContents("[e2e::FileCreateTransaction]");

                // 2. Serialize transaction into bytes
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction from bytes
                let transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);
                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(true);

                // 4. Set node accoutn ids
                const nodeAccountId = new AccountId(3);
                transactionFromBytes.setNodeAccountIds([nodeAccountId]);
                expect(
                    transactionFromBytes._nodeAccountIds.get(0).toString(),
                ).to.be.equal(nodeAccountId.toString());

                // 5. Freeze, sign and execute transaction
                const response = await (
                    await (
                        await transactionFromBytes.freezeWithSigner(wallet)
                    ).signWithSigner(wallet)
                ).executeWithSigner(wallet);
                expect(response).to.be.instanceof(TransactionResponse);

                // 6. Get a receipt
                const receipt = await response.getReceiptWithSigner(wallet);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });

        /** @description: example serialize-deserialize-12.js */
        it("should create, serialize and deserialize so-called incomplete transaction, then freeze it, serialize and deserialize it again, and execute it", async function () {
            try {
                // Create transaction id
                const transactionId = new TransactionId(
                    operatorId,
                    Timestamp.fromDate(new Date()),
                );
                expect(transactionId).to.be.instanceof(TransactionId);

                // 1. Create a transaction
                const transaction = new AccountUpdateTransaction()
                    .setTransactionId(transactionId)
                    .setAccountId(operatorId)
                    .setAccountMemo("Hello");

                // 2. Serialize transaction
                const transactionBytes = transaction.toBytes();

                // 3. Deserialize transaction
                const transactionFromBytes =
                    Transaction.fromBytes(transactionBytes);
                expect(hex.encode(transactionBytes)).to.be.equal(
                    hex.encode(transactionFromBytes.toBytes()),
                );
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(true);
                expect(transactionFromBytes._transactionIds.length).to.be.equal(
                    1,
                );

                // 4. Freeze transaction
                transactionFromBytes.freezeWith(client);

                // 5. Serialize transaction after being frozen
                const transactionBytesAfterBeingFrozen =
                    transactionFromBytes.toBytes();

                // 6. Deserialize transaction again
                const transactionFromBytesAfterBeingFrozen =
                    Transaction.fromBytes(transactionBytesAfterBeingFrozen);
                expect(
                    transactionFromBytes._nodeAccountIds.isEmpty,
                ).to.be.equal(false);
                expect(
                    transactionFromBytes._transactionIds.isEmpty,
                ).to.be.equal(false);

                // 7. Execute transaction
                const response =
                    await transactionFromBytesAfterBeingFrozen.execute(client);
                expect(response).to.be.instanceof(TransactionResponse);

                // 8. Get a receipt
                const receipt = await response.getReceipt(client);
                expect(receipt).to.be.an.instanceof(TransactionReceipt);
                expect(receipt.status.toString()).to.be.equal("SUCCESS");
            } catch (error) {
                console.log(error);
            }
        });
    });

    describe("Transaction Signature Manipulation Flow", function () {
        let env, user1Key, user2Key, createdAccountId, keyList;

        // Setting up the environment and creating a new account with a key list
        before(async function () {
            env = await IntegrationTestEnv.new();

            user1Key = PrivateKey.generate();
            user2Key = PrivateKey.generate();
            keyList = new KeyList([user1Key.publicKey, user2Key.publicKey]);

            // Create account
            const createAccountTransaction = new AccountCreateTransaction()
                .setInitialBalance(new Hbar(2))
                .setKeyWithoutAlias(keyList);

            const createResponse = await createAccountTransaction.execute(
                env.client,
            );
            const createReceipt = await createResponse.getReceipt(env.client);

            createdAccountId = createReceipt.accountId;

            expect(createdAccountId).to.exist;
        });

        /** @description: example multi-node-multi-signature-remove.js */
        it("Transaction with Signature Removal and Re-addition", async function () {
            // Step 1: Create and sign transfer transaction
            const transferTransaction = new TransferTransaction()
                .addHbarTransfer(createdAccountId, new Hbar(-1))
                .addHbarTransfer("0.0.3", new Hbar(1))
                .setNodeAccountIds([
                    new AccountId(3),
                    new AccountId(4),
                    new AccountId(5),
                ])
                .freezeWith(env.client);

            // Step 2: Serialize and sign the transaction
            const transferTransactionBytes = transferTransaction.toBytes();
            const user1Signatures =
                user1Key.signTransaction(transferTransaction);
            const user2Signatures =
                user2Key.signTransaction(transferTransaction);

            // Step 3: Deserialize the transaction and add signatures
            const signedTransaction = Transaction.fromBytes(
                transferTransactionBytes,
            );
            signedTransaction.addSignature(user1Key.publicKey, user1Signatures);
            signedTransaction.addSignature(user2Key.publicKey, user2Signatures);

            const getSignaturesNumberPerNode = () =>
                signedTransaction._signedTransactions.list[0].sigMap.sigPair
                    .length;

            // Test if the transaction for a node has 2 signatures
            expect(getSignaturesNumberPerNode()).to.be.equal(2);

            // Step 4: Remove the signature for user1 from the transaction
            signedTransaction.removeSignature(user1Key.publicKey);

            // Test if the transaction for a node has 1 signature after removal
            expect(getSignaturesNumberPerNode()).to.be.equal(1);

            // Step 5: Re-add the removed signature
            signedTransaction.addSignature(user1Key.publicKey, user1Signatures);

            // Test if the transaction for a node has 2 signatures after adding back the signature
            expect(getSignaturesNumberPerNode()).to.be.equal(2);

            // Step 6: Execute the signed transaction
            const result = await signedTransaction.execute(env.client);
            const receipt = await result.getReceipt(env.client);

            // Step 7: Verify the transaction status
            expect(receipt.status).to.be.equal(Status.Success);
        });

        /** @description: example multi-node-multi-signature-removeAll.js */
        it("Transaction with All Signature Removal", async function () {
            // Step 1: Create and sign transfer transaction
            const transferTransaction = new TransferTransaction()
                .addHbarTransfer(createdAccountId, new Hbar(-1))
                .addHbarTransfer("0.0.3", new Hbar(1))
                .setNodeAccountIds([
                    new AccountId(3),
                    new AccountId(4),
                    new AccountId(5),
                ])
                .freezeWith(env.client);

            // Step 2: Serialize and sign the transaction
            const transferTransactionBytes = transferTransaction.toBytes();
            const user1Signatures =
                user1Key.signTransaction(transferTransaction);
            const user2Signatures =
                user2Key.signTransaction(transferTransaction);

            // Step 3: Deserialize the transaction and add signatures
            const signedTransaction = Transaction.fromBytes(
                transferTransactionBytes,
            );
            signedTransaction.addSignature(user1Key.publicKey, user1Signatures);
            signedTransaction.addSignature(user2Key.publicKey, user2Signatures);

            const getSignaturesNumberPerNode = () =>
                signedTransaction._signedTransactions.list[0].sigMap.sigPair
                    .length;

            // Test if the transaction for a node has 2 signatures
            expect(getSignaturesNumberPerNode()).to.be.equal(2);

            // Step 4: Remove the signature for user1 from the transaction
            signedTransaction.removeAllSignatures();

            // Test if the transaction for a node has 0 signatures after removal
            expect(getSignaturesNumberPerNode()).to.be.equal(0);

            // Step 5: Try to execute the transaction without any signatures and expect it to fail
            try {
                const result = await signedTransaction.execute(env.client);
                await result.getReceipt(env.client);

                // If we get here, the transaction did not fail as expected
                throw new Error(
                    "Transaction should have failed due to missing signatures",
                );
            } catch (error) {
                // Expect the error to be due to an invalid signature
                expect(error.message).to.include("INVALID_SIGNATURE");
            }
        });
    });

    describe("Transaction flows", function () {
        let env, operatorId, operatorKey, client;

        // Setting up the environment and creating a new account with a key list
        before(async function () {
            env = await IntegrationTestEnv.new();

            operatorId = env.operatorId;
            operatorKey = env.operatorKey;
            client = env.client;
        });

        it("Creating, Signing, and Submitting a Transaction Using the Client with a Known Address Book", async function () {
            // For simplicity, sending back to the operator
            const recipientAccountId = env.operatorId;

            // Create, sign, and execute the transfer transaction
            const transferTx = await new TransferTransaction()
                .addHbarTransfer(operatorId, Hbar.fromTinybars(-1)) // Sender
                .addHbarTransfer(recipientAccountId, Hbar.fromTinybars(1)) // Recipient
                .freezeWith(client)
                .sign(operatorKey);

            const response = await transferTx.execute(client);

            // Get and validate receipt
            const receipt = await response.getReceipt(client);
            expect(receipt.status.toString()).to.be.equal("SUCCESS");

            // Get and validate record
            const record = await response.getRecord(client);
            expect(record.transactionId.accountId.toString()).to.be.equal(
                operatorId.toString(),
            );
        });

        it(`Creating, Signing, and Submitting a Transaction Using the Client with a Known Address Book.
          In Addition, Serialize and Deserialize the Signed Transaction `, async function () {
            // For simplicity, sending back to the operator
            const recipientAccountId = env.operatorId;

            const transaction = new TransferTransaction()
                .addHbarTransfer(operatorId, Hbar.fromTinybars(-1)) // Sender
                .addHbarTransfer(recipientAccountId, Hbar.fromTinybars(1)) // Recipient
                .freezeWith(client);

            // Sign the transaction
            await transaction.sign(operatorKey);

            // Serialize the transaction to bytes
            const transactionBytes = transaction.toBytes();

            // Deserialize the transaction from bytes
            const transactionFromBytes =
                Transaction.fromBytes(transactionBytes);

            // Execute the transaction
            const executedTransaction =
                await transactionFromBytes.execute(client);

            const record = await executedTransaction.getRecord(client);
            expect(record.transactionId.accountId.toString()).to.equal(
                operatorId.toString(),
            );
        });

        it("Creating, Signing, and Executing a Transaction with a Non-Existent Node Account ID", async function () {
            // For simplicity, sending back to the operator
            const recipientAccountId = env.operatorId;

            // Create a transfer transaction and point it to an unknown node account ID (10000)
            const signTransferTransaction = await new TransferTransaction()
                .addHbarTransfer(operatorId, Hbar.fromTinybars(-1))
                .addHbarTransfer(recipientAccountId, Hbar.fromTinybars(1))
                .setNodeAccountIds([
                    new AccountId(10000),
                    new AccountId(10001),
                    new AccountId(10002),
                ]) // Non-existent node account IDs
                .freezeWith(client)
                .sign(operatorKey);

            try {
                await signTransferTransaction.execute(client);
            } catch (error) {
                expect(error.message).to.be.equal(
                    // Attempting to execute the transaction with a node that is not in the client's node list
                    "Attempting to execute a transaction against nodes 0.0.10000, 0.0.10001 ..., which are not included in the Client's node list. Please review your Client configuration.",
                );
            }
        });

        it("Creating, Signing, and Executing a Transaction with a Non-Existent Node Account ID and an Existent one", async function () {
            // For simplicity, sending back to the operator
            const recipientAccountId = env.operatorId;

            const signTransferTransaction = await new TransferTransaction()
                .addHbarTransfer(operatorId, Hbar.fromTinybars(-1))
                .addHbarTransfer(recipientAccountId, Hbar.fromTinybars(1))
                .setNodeAccountIds([new AccountId(10000), new AccountId(3)])
                .freezeWith(client)
                .sign(operatorKey);

            const transferTransactionReceipt = await (
                await signTransferTransaction.execute(client)
            ).getReceipt(client);

            expect(transferTransactionReceipt.status.toString()).to.be.equal(
                "SUCCESS",
            );
        });

        it("Creating transaction with clientTwo and executing it with clientOne which nodes aren't the same", async function () {
            // For simplicity, sending back to the operator
            const recipientAccountId = operatorId;
            const clientOne = client;

            const clientTwoNodes = {
                "54.176.199.109:50211": new AccountId(7),
                "35.155.49.147:50211": new AccountId(8),
                "127.0.0.1:50211": new AccountId(3),
                "34.106.102.218:50211": new AccountId(8),
            };

            // Create clientTwo with different nodes, most of them incorrect
            const clientTwo = Client.forNetwork(clientTwoNodes).setOperator(
                operatorId,
                operatorKey,
            );

            // Construct the transaction with clientTwo
            const signTransferTransaction = await new TransferTransaction()
                .addHbarTransfer(operatorId, Hbar.fromTinybars(-1)) //Sending account
                .addHbarTransfer(recipientAccountId, Hbar.fromTinybars(1)) //Receiving account
                .freezeWith(clientTwo)
                .sign(operatorKey);

            // Execute the transaction with clientOne
            const signTransferTxExecution =
                await signTransferTransaction.execute(clientOne);

            // Get the receipt
            const signTransferTxReceipt =
                await signTransferTxExecution.getReceipt(clientOne);

            expect(signTransferTxReceipt.status.toString()).to.be.equal(
                "SUCCESS",
            );
        });
    });
});
// Filename: test/integration/TransactionReceiptIntegrationTest.js
import {
    AccountCreateTransaction,
    AccountId,
    Hbar,
    KeyList,
    PrivateKey,
    TopicCreateTransaction,
    TopicMessageSubmitTransaction,
    TransactionId,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TransactionReceipt", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new({ throwaway: true });
    });

    it("should exist in the `ReceiptStatusError`", async function () {
        const operatorKey = env.operatorKey.publicKey;
        const operatorId = env.operatorId;

        const key1 = PrivateKey.generateED25519();

        // Submit Key
        const key2 = PrivateKey.generateED25519();

        const key3 = PrivateKey.generateED25519();

        const keyList = KeyList.of(
            key1.publicKey,
            key2.publicKey,
            key3.publicKey,
        );

        const response = await new AccountCreateTransaction()
            .setInitialBalance(new Hbar(50))
            .setKeyWithoutAlias(keyList)
            .execute(env.client);

        expect((await response.getReceipt(env.client)).accountId).to.be.not
            .null;

        const topicId = (
            await (
                await new TopicCreateTransaction()
                    .setAdminKey(operatorKey)
                    .setAutoRenewAccountId(operatorId)
                    .setTopicMemo("HCS Topic_")
                    .setSubmitKey(key2)
                    .execute(env.client)
            ).getReceipt(env.client)
        ).topicId;

        const transaction = new TopicMessageSubmitTransaction()
            .setTopicId(topicId)
            .setMessage("scheduled hcs message");

        const scheduled1 = transaction
            .schedule()
            .setPayerAccountId(operatorId)
            .setAdminKey(operatorKey)
            .freezeWith(env.client);

        const scheduled2 = transaction
            .schedule()
            .setPayerAccountId(operatorId)
            .setAdminKey(operatorKey)
            .freezeWith(env.client);

        await (await scheduled1.execute(env.client)).getReceipt(env.client);

        try {
            await (await scheduled2.execute(env.client)).getReceipt(env.client);
        } catch (error) {
            const expected = TransactionId.withValidStart(
                new AccountId(scheduled1.transactionId.accountId),
                scheduled1.transactionId.validStart,
            );
            const actual = TransactionId.withValidStart(
                new AccountId(
                    error.transactionReceipt.scheduledTransactionId.accountId,
                ),
                error.transactionReceipt.scheduledTransactionId.validStart,
            );
            expect(expected.toString()).to.be.equal(actual.toString());
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TransactionRecordIntegrationTest.js
import {
    FileCreateTransaction,
    ContractCreateTransaction,
    FileAppendTransaction,
    ContractExecuteTransaction,
    ContractFunctionParameters,
} from "../../src/exports.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TransactionRecord", function () {
    let env;
    const contractByteCode =
        "0x608060405234801561001057600080fd5b50610594806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c8063368b87721461006757806353f2a8a31461009057806380acb9e6146100b1578063ce6d41de146100c4578063e21f37ce146100cc578063f7753390146100d4575b600080fd5b61007a610075366004610406565b6100dc565b60405161008791906104ba565b60405180910390f35b6100a361009e3660046104a2565b610112565b604051908152602001610087565b61007a6100bf366004610441565b610177565b61007a6101c2565b61007a610254565b61007a6102e2565b80516060906100f29060009060208501906102ef565b50506040805180820190915260028152614f4b60f01b6020820152919050565b6000606482116101735760405162461bcd60e51b815260206004820152602260248201527f546865206e756d62657220697320736d616c6c6572207468616e2068756e6472604482015261195960f21b606482015260840160405180910390fd5b5090565b815160609061018d9060009060208601906102ef565b5081516101a19060019060208501906102ef565b50506040805180820190915260028152614f4b60f01b602082015292915050565b6060600080546101d19061050d565b80601f01602080910402602001604051908101604052809291908181526020018280546101fd9061050d565b801561024a5780601f1061021f5761010080835404028352916020019161024a565b820191906000526020600020905b81548152906001019060200180831161022d57829003601f168201915b5050505050905090565b600080546102619061050d565b80601f016020809104026020016040519081016040528092919081815260200182805461028d9061050d565b80156102da5780601f106102af576101008083540402835291602001916102da565b820191906000526020600020905b8154815290600101906020018083116102bd57829003601f168201915b505050505081565b600180546102619061050d565b8280546102fb9061050d565b90600052602060002090601f01602090048101928261031d5760008555610363565b82601f1061033657805160ff1916838001178555610363565b82800160010185558215610363579182015b82811115610363578251825591602001919060010190610348565b506101739291505b80821115610173576000815560010161036b565b600082601f83011261038f578081fd5b813567ffffffffffffffff808211156103aa576103aa610548565b604051601f8301601f19908116603f011681019082821181831017156103d2576103d2610548565b816040528381528660208588010111156103ea578485fd5b8360208701602083013792830160200193909352509392505050565b600060208284031215610417578081fd5b813567ffffffffffffffff81111561042d578182fd5b6104398482850161037f565b949350505050565b60008060408385031215610453578081fd5b823567ffffffffffffffff8082111561046a578283fd5b6104768683870161037f565b9350602085013591508082111561048b578283fd5b506104988582860161037f565b9150509250929050565b6000602082840312156104b3578081fd5b5035919050565b6000602080835283518082850152825b818110156104e6578581018301518582016040015282016104ca565b818111156104f75783604083870101525b50601f01601f1916929092016040019392505050565b600181811c9082168061052157607f821691505b6020821081141561054257634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052604160045260246000fdfea26469706673582212206369861146f0c706a48e951145ffca721f1fe7e98b0fb535d02d2e0b4195be0664736f6c63430008040033";

    before(async function () {
        env = await IntegrationTestEnv.new({ throwaway: true });
    });

    it("should return the verbose record log when a transaction failed ", async function () {
        const privateKey = env.operatorKey;

        // Create a file on Hedera and store the bytecode
        const fileCreateTx = new FileCreateTransaction()
            .setKeys([privateKey])
            .freezeWith(env.client);
        const fileCreateSign = await fileCreateTx.sign(privateKey);
        const fileCreateSubmit = await fileCreateSign.execute(env.client);
        const fileCreateRx = await fileCreateSubmit.getReceipt(env.client);
        const bytecodeFileId = fileCreateRx.fileId;
        console.log(`- The bytecode file ID is: ${bytecodeFileId} \n`);

        //Append contents to the file
        const fileAppendTx = new FileAppendTransaction()
            .setFileId(bytecodeFileId)
            .setContents(contractByteCode)
            .setMaxChunks(10)
            .freezeWith(env.client);
        const fileAppendSign = await fileAppendTx.sign(privateKey);
        const fileAppendSubmit = await fileAppendSign.execute(env.client);
        const fileAppendRx = await fileAppendSubmit.getReceipt(env.client);
        console.log("Status of file append is", fileAppendRx.status.toString());

        // Instantiate the contract instance
        const contractTx = await new ContractCreateTransaction()
            //Set the file ID of the Hedera file storing the bytecode
            .setBytecodeFileId(bytecodeFileId)
            //Set the gas to instantiate the contract
            .setGas(100000)
            //Provide the constructor parameters for the contract
            .setConstructorParameters();

        //Submit the transaction to the Hedera test network
        const contractResponse = await contractTx.execute(env.client);

        //Get the receipt of the file create transaction
        const contractReceipt = await contractResponse.getReceipt(env.client);

        //Get the smart contract ID
        const newContractId = contractReceipt.contractId;

        //Log the smart contract ID
        console.log("The smart contract ID is " + newContractId);

        const contractExecuteTx = new ContractExecuteTransaction()
            .setContractId(newContractId)
            .setGas(750000)
            .setFunction(
                "setDataRequire",
                new ContractFunctionParameters().addUint256(10),
            )
            .freezeWith(env.client);

        try {
            const signedTx = await contractExecuteTx.sign(privateKey);
            const contractExecuteSubmit = await signedTx.execute(env.client);

            // Get transaction record information
            await contractExecuteSubmit.getVerboseRecord(env.client);
        } catch (err) {
            expect(err.transactionRecord.transactionFee).not.to.be.null;
        }
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/TransactionResponseTest.js
import {
    AccountCreateTransaction,
    AccountDeleteTransaction,
    PrivateKey,
} from "../../src/exports.js";
import * as hex from "../../src/encoding/hex.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("TransactionResponse", function () {
    let env;

    before(async function () {
        env = await IntegrationTestEnv.new({ throwaway: true });
    });

    it("should be executable", async function () {
        const operatorId = env.operatorId;
        expect(operatorId).to.not.be.null;

        const key = PrivateKey.generateED25519();

        const transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .execute(env.client);

        const record = await transaction.getRecord(env.client);

        expect(hex.encode(record.transactionHash)).to.be.equal(
            hex.encode(transaction.transactionHash),
        );

        const account = record.receipt.accountId;
        expect(account).to.not.be.null;

        await (
            await (
                await new AccountDeleteTransaction()
                    .setAccountId(account)
                    .setTransferAccountId(operatorId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);
    });

    it("should make a transaction receipt query available", async function () {
        const operatorId = env.operatorId;
        expect(operatorId).to.not.be.null;

        const key = PrivateKey.generateED25519();

        const transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .execute(env.client);

        const transactionReceiptQuery = transaction.getReceiptQuery();
        expect(transactionReceiptQuery).to.not.be.null;

        const record = await transaction.getRecord(env.client);

        const account = record.receipt.accountId;
        expect(account).to.not.be.null;

        await (
            await (
                await new AccountDeleteTransaction()
                    .setAccountId(account)
                    .setTransferAccountId(operatorId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);
    });

    it("should make a transaction record query available", async function () {
        const operatorId = env.operatorId;
        expect(operatorId).to.not.be.null;

        const key = PrivateKey.generateED25519();

        const transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key.publicKey)
            .execute(env.client);

        const transactionRecordQuery = transaction.getRecordQuery();
        expect(transactionRecordQuery).to.not.be.null;

        const record = await transaction.getRecord(env.client);

        const account = record.receipt.accountId;
        expect(account).to.not.be.null;

        await (
            await (
                await new AccountDeleteTransaction()
                    .setAccountId(account)
                    .setTransferAccountId(operatorId)
                    .freezeWith(env.client)
                    .sign(key)
            ).execute(env.client)
        ).getReceipt(env.client);
    });

    it("should return nextExchangeRate in receipt", async function () {
        const operatorId = env.operatorId;
        expect(operatorId).to.not.be.null;

        const key = PrivateKey.generateED25519();

        const receipt = await (
            await new AccountCreateTransaction()
                .setKeyWithoutAlias(key.publicKey)
                .execute(env.client)
        ).getReceipt(env.client);

        expect(receipt.nextExchangeRate).to.not.be.null;
    });

    after(async function () {
        await env.close();
    });
});
// Filename: test/integration/WalletIntegrationTest.js
import { expect } from "chai";
import {
    AccountCreateTransaction,
    Hbar,
    PrivateKey,
    TransferTransaction,
} from "../../src/exports.js";
import { Wallet, LocalProvider } from "../../src/index.js";
import IntegrationTestEnv from "./client/NodeIntegrationTestEnv.js";

describe("WalletIntegration", function () {
    it("should create a wallet (ECDSA)", async function () {
        const wallet = await Wallet.createRandomECDSA();
        expect(wallet.getAccountKey()).to.not.equal(null);
        expect(wallet.getAccountId()).to.not.equal(null);
    });

    it("should create a wallet (ED25519)", async function () {
        const wallet = await Wallet.createRandomED25519();
        expect(wallet.getAccountKey()).to.not.equal(null);
        expect(wallet.getAccountId()).to.not.equal(null);
    });

    it("issue-1530", async function () {
        const env = await IntegrationTestEnv.new();

        // Generate a key for the signer
        const signerKey = PrivateKey.generateED25519();

        // Create account id for the signer
        let createTransaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(signerKey)
            .setInitialBalance(new Hbar(5))
            .signWithOperator(env.client);

        const response = await createTransaction.execute(env.client);
        const record = await response.getRecord(env.client);
        const signerId = record.receipt.accountId;

        const wallet = new Wallet(signerId, signerKey, new LocalProvider());

        // The operator and the signer are different
        expect(env.operatorId).not.to.eql(signerId);

        let transferTx = new TransferTransaction()
            .addHbarTransfer(signerId, new Hbar(-1))
            .addHbarTransfer(env.operatorId, new Hbar(1));

        wallet.populateTransaction(transferTx);

        const tx = await wallet.call(transferTx);
        const transferRecord = await tx.getRecord(env.client);
        expect(transferRecord.transactionId.accountId).to.eql(signerId);

        await env.close();
    });
});
// Filename: test/integration/client/BaseIntegrationTestEnv.js
import {
    PrivateKey,
    AccountCreateTransaction,
    TokenDeleteTransaction,
    Hbar,
    AccountId,
    Wallet,
} from "../../../src/exports.js";
import LocalProvider from "../../../src/LocalProvider.js";

/**
 * @typedef {import("../../../src/exports.js").TokenId} TokenId
 * @typedef {import("../../../src/client/Client.js").Client<*, *>} Client
 */

export default class BaseIntegrationTestEnv {
    /**
     * @param {object} options
     * @property {Client} props.client
     * @property {PublicKey} options.originalOperatorKey
     * @property {AccountId} options.originalOperatorId
     * @property {PrivateKey} options.originalOperatorKey
     * @property {AccountId} options.newOperatorKey
     * @property {AccountId[]} options.newOperatorId
     * @property {Wallet} options.wallet
     */
    constructor(options) {
        /** @type {Client} */
        this.client = options.client;

        /** @type {PrivateKey} */
        this.operatorKey = options.newOperatorKey;

        /** @type {AccountId} */
        this.operatorId = options.newOperatorId;

        /** @type {PrivateKey} */
        this.originalOperatorKey = options.originalOperatorKey;

        /** @type {AccountId} */
        this.originalOperatorId = options.originalOperatorId;

        this.throwaway = options.throwaway;

        /** @type {Wallet} */
        this.wallet = options.wallet;

        Object.freeze(this);
    }

    /**
     * @param {object} [options]
     * @property {Client<*, *>} options.client
     * @property {{ [key: string]: string}} options.env
     * @property {number} [options.nodeAccountIds]
     * @property {number} [options.balance]
     * @property {boolean} [options.throwaway]
     */
    static async new(options = {}) {
        let client, wallet;

        if (
            options.env.HEDERA_NETWORK != null &&
            options.env.HEDERA_NETWORK == "previewnet"
        ) {
            client = options.client.forPreviewnet();
        } else if (
            options.env.HEDERA_NETWORK != null &&
            options.env.HEDERA_NETWORK == "testnet"
        ) {
            client = options.client.forTestnet();
        } else if (
            (options.env.HEDERA_NETWORK != null &&
                options.env.HEDERA_NETWORK == "localhost") ||
            options.env.HEDERA_NETWORK == "local-node"
        ) {
            client = options.client.forNetwork({
                "127.0.0.1:50211": new AccountId(3),
            });
        } else if (options.env.CONFIG_FILE != null) {
            client = await options.client.fromConfigFile(
                options.env.CONFIG_FILE,
            );
        } else {
            throw new Error(
                "Failed to construct client for IntegrationTestEnv",
            );
        }

        if (
            options.env.OPERATOR_ID != null &&
            options.env.OPERATOR_KEY != null
        ) {
            const operatorId = AccountId.fromString(options.env.OPERATOR_ID);
            const operatorKey = PrivateKey.fromStringED25519(
                options.env.OPERATOR_KEY,
            );

            client.setOperator(operatorId, operatorKey);
            client.setMirrorNetwork(options.env.HEDERA_NETWORK);
        }

        expect(client.operatorAccountId).to.not.be.null;
        expect(client.operatorPublicKey).to.not.be.null;

        const originalOperatorKey = client.operatorAccountKey;
        const originalOperatorId = client.operatorAccountId;

        client
            .setMaxNodeAttempts(1)
            .setNodeMinBackoff(0)
            .setNodeMaxBackoff(0)
            .setNodeMinReadmitPeriod(0)
            .setNodeMaxReadmitPeriod(0);

        const network = {};
        const nodeAccountIds =
            options.nodeAccountIds != null ? options.nodeAccountIds : 1;
        for (const [key, value] of Object.entries(client.network)) {
            network[key] = value;

            if (Object.keys(network).length >= nodeAccountIds) {
                break;
            }
        }
        client.setNetwork(network);

        const newOperatorKey = PrivateKey.generateECDSA();

        const response = await new AccountCreateTransaction()
            .setKeyWithoutAlias(newOperatorKey)
            .setInitialBalance(
                new Hbar(options.balance != null ? options.balance : 100),
            )
            .execute(client);

        const newOperatorId = (await response.getReceipt(client)).accountId;

        client.setOperator(newOperatorId, newOperatorKey);

        wallet = new Wallet(newOperatorId, newOperatorKey, new LocalProvider());

        return new BaseIntegrationTestEnv({
            client: client,
            wallet: wallet,
            originalOperatorKey: originalOperatorKey,
            originalOperatorId: originalOperatorId,
            newOperatorKey: newOperatorKey,
            newOperatorId: newOperatorId,
            throwaway: options.throwaway,
        });
    }

    /**
     * @param {object} [options]
     * @property {TokenId | TokenId[]} token
     */
    async close(options = {}) {
        if (options.token != null) {
            if (!Array.isArray(options.token)) {
                options.token = [options.token];
            }

            for (const token of options.token) {
                await (
                    await new TokenDeleteTransaction()
                        .setTokenId(token)
                        .execute(this.client)
                ).getReceipt(this.client);
            }
        }

        // if (!this.throwaway && this.operatorId.toString() !== this.originalOperatorId.toString()) {
        //     await (await new AccountDeleteTransaction()
        //         .setAccountId(this.operatorId)
        //         .setTransferAccountId(this.originalOperatorId)
        //         .execute(this.client)
        //     ).getReceipt(this.client);
        // }

        this.client.close();
    }
}
// Filename: test/integration/client/NodeIntegrationTestEnv.js
import Wallet from "../../../src/Wallet.js";
import Client from "../../../src/client/NodeClient.js";
import BaseIntegrationTestEnv from "./BaseIntegrationTestEnv.js";
import dotenv from "dotenv";

dotenv.config();

export { Client };

/**
 * @typedef {number} minVersion
 */
export function skipTestDueToNodeJsVersion(minVersion) {
    if (
        process == null ||
        process.versions == null ||
        process.versions.node == null ||
        parseInt(process.versions.node.split(".")[0]) < minVersion
    ) {
        console.log("skipping test due to unsupported nodejs version");
        return true;
    }
}

export default class IntegrationTestEnv extends BaseIntegrationTestEnv {
    /**
     * @param {object} [options]
     * @property {number} [options.nodeAccountIds]
     * @property {number} [options.balance]
     * @property {boolean} [options.throwaway]
     */
    static async new(options = {}) {
        return BaseIntegrationTestEnv.new({
            client: Client,
            wallet: Wallet,
            env: process.env,
            nodeAccountIds: options.nodeAccountIds,
            balance: options.balance,
            throwaway: options.throwaway,
        });
    }
}
// Filename: test/integration/client/TestnetIntegrationTestEnv.js
import Client from "../../../src/client/NodeClient.js";
import BaseIntegrationTestEnv from "./BaseIntegrationTestEnv.js";

export { Client };

export function skipTestDueToNodeJsVersion() {
    return true;
}

export default class TestnetIntegrationTestEnv extends BaseIntegrationTestEnv {
    /**
     * @param {object} [options]
     * @property {number} [options.nodeAccountIds]
     * @property {number} [options.balance]
     * @property {boolean} [options.throwaway]
     */
    static async new(options = {}) {
        return BaseIntegrationTestEnv.new({
            client: Client,
            env: {
                OPERATOR_ID: "0.0.8920",
                OPERATOR_KEY:
                    "07f9f9c355d32c5c93a50024b596ed3ccc39954ba1963c68ac21cb7802fd5f83",
                HEDERA_NETWORK: "testnet",
            },
            nodeAccountIds: options.nodeAccountIds,
            balance: options.balance,
            throwaway: options.throwaway,
        });
    }
}
// Filename: test/integration/client/WebIntegrationTestEnv.js
import Client from "../../src/client/WebClient.js";
import BaseIntegrationTestEnv from "./BaseIntegrationTestEnv.js";

export { Client };

export function skipTestDueToNodeJsVersion() {
    return true;
}

export default class IntegrationTestEnv extends BaseIntegrationTestEnv {
    /**
     * @param {object} [options]
     * @property {number} [options.nodeAccountIds]
     * @property {number} [options.balance]
     * @property {boolean} [options.throwaway]
     */
    static async new(options = {}) {
        return BaseIntegrationTestEnv.new({
            client: Client,
            env: {
                OPERATOR_ID: "0.0.8920",
                OPERATOR_KEY:
                    "07f9f9c355d32c5c93a50024b596ed3ccc39954ba1963c68ac21cb7802fd5f83",
                HEDERA_NETWORK: "testnet",
            },
            nodeAccountIds: options.nodeAccountIds,
            balance: options.balance,
            throwaway: options.throwaway,
        });
    }
}
// Filename: test/integration/contents.js
export const bigContents = `
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.

Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.

Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.

Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.

Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.

Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.

Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.

Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.

Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.

In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.

Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.

Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.

Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.

Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.

Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.

Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.

Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.

Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.

Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.

Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.

Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.

In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.
`;

export const SMART_CONTRACT_BYTECODE =
    "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";
// Filename: test/integration/utils/Fixtures.js
import {
    AccountCreateTransaction,
    AccountDeleteTransaction,
    Hbar,
    PrivateKey,
    TokenCreateTransaction,
    TokenSupplyType,
    TokenType,
} from "../../../src/exports.js";
/**
 * @typedef {import("../../../src/token/TokenId.js") } TokenId
 * @typedef {import("../../../src/client/Client.js").default<ChannelT, MirrorChannelT>} Client
 */

/**
 * @param {Client} client
 * @param {?(transaction: TokenCreateTransaction) => TokenCreateTransaction} transactionModifier
 * @returns {Promise<TokenId>}
 */
export const createFungibleToken = async (client, transactionModifier) => {
    const transaction = new TokenCreateTransaction()
        .setTokenName("ffff")
        .setTokenSymbol("F")
        .setTokenMemo("asdf")
        .setDecimals(18)
        .setInitialSupply(1_000_000)
        .setTreasuryAccountId(client.operatorAccountId)
        .setFreezeKey(client.operatorPublicKey)
        .setPauseKey(client.operatorPublicKey)
        .setWipeKey(client.operatorPublicKey)
        .setFeeScheduleKey(client.operatorPublicKey)
        .setMetadataKey(client.operatorPublicKey)
        .setSupplyKey(client.operatorPublicKey)
        .setAdminKey(client.operatorPublicKey)
        .setSupplyType(TokenSupplyType.Infinite)
        .setTokenType(TokenType.FungibleCommon);

    if (transactionModifier) {
        transactionModifier(transaction);
    }

    const tokenId = (
        await (await transaction.execute(client)).getReceipt(client)
    ).tokenId;

    return tokenId;
};

/**
 * @param {Client} client
 * @param {?(transaction: TokenCreateTransaction) => TokenCreateTransaction} transactionModifier
 * @returns {Promise<TokenId>}
 */
export const createNonFungibleToken = async (client, transactionModifier) => {
    const transaction = new TokenCreateTransaction()
        .setTokenName("ffff")
        .setTokenSymbol("F")
        .setTokenMemo("asdf")
        .setDecimals(0)
        .setInitialSupply(0)
        .setMaxSupply(10)
        .setSupplyType(TokenSupplyType.Finite)
        .setTokenType(TokenType.NonFungibleUnique)
        .setTreasuryAccountId(client.operatorAccountId)
        .setFreezeKey(client.operatorPublicKey)
        .setPauseKey(client.operatorPublicKey)
        .setWipeKey(client.operatorPublicKey)
        .setFeeScheduleKey(client.operatorPublicKey)
        .setMetadataKey(client.operatorPublicKey)
        .setSupplyKey(client.operatorPublicKey)
        .setAdminKey(client.operatorPublicKey);

    if (transactionModifier) {
        transactionModifier(transaction);
    }

    const tokenId = (
        await (await transaction.execute(client)).getReceipt(client)
    ).tokenId;

    return tokenId;
};

/**
 * @param {Client} client
 * @param {?(transaction: AccountCreateTransaction) => AccountCreateTransaction} transactionModifier
 * @returns {Promise<{ accountId: string | null, newKey: PrivateKey }>}
 */
export const createAccount = async (client, transactionModifier) => {
    const newKey = PrivateKey.generateECDSA();

    const accountCreateTransaction = new AccountCreateTransaction()
        .setKeyWithoutAlias(newKey)
        .setInitialBalance(new Hbar(1));

    if (transactionModifier) {
        transactionModifier(accountCreateTransaction);
    }

    const { accountId } = await (
        await accountCreateTransaction.execute(client)
    ).getReceipt(client);

    return { accountId, newKey };
};

/**
 * @param {Client} client
 * @param {PrivateKey} accountPrivateKey
 * @param {?(transaction: AccountDeleteTransaction) => Promise<AccountDeleteTransaction>} transactionModifier
 * @returns {Promise<void>}
 */
export const deleteAccount = async (
    client,
    accountPrivateKey,
    transactionModifier,
) => {
    const accountDeleteTransaction = new AccountDeleteTransaction();

    if (transactionModifier) {
        await transactionModifier(accountDeleteTransaction);
    }

    if (!accountDeleteTransaction.isFrozen()) {
        accountDeleteTransaction.freezeWith(client);
    }

    await (
        await (
            await accountDeleteTransaction.sign(accountPrivateKey)
        ).execute(client)
    ).getReceipt(client);
};
// Filename: test/unit/AccountAllowanceApproveTransaction.js
import { expect } from "chai";

import Long from "long";

import {
    AccountAllowanceApproveTransaction,
    AccountId,
    Hbar,
    NftId,
    Timestamp,
    TokenId,
    Transaction,
    TransactionId,
} from "../../src/index.js";

describe("AccountAllowanceApproveTransaction", function () {
    it("should round trip from bytes and maintain order", function () {
        const tokenId1 = new TokenId(1);
        const tokenId2 = new TokenId(141);
        const serialNumber1 = Long.fromNumber(3);
        const serialNumber2 = Long.fromNumber(4);
        const nftId1 = new NftId(tokenId2, serialNumber1);
        const nftId2 = new NftId(tokenId2, serialNumber2);
        const spenderAccountId1 = new AccountId(7);
        const spenderAccountId2 = new AccountId(7890);
        const nodeAccountId = new AccountId(10, 11, 12);
        const timestamp1 = new Timestamp(14, 15);
        const hbarAmount = Hbar.fromTinybars(100);
        const tokenAmount = Long.fromNumber(101);
        const ownerAccountId = new AccountId(20);

        let transaction = new AccountAllowanceApproveTransaction()
            .setTransactionId(
                TransactionId.withValidStart(spenderAccountId1, timestamp1),
            )
            .setNodeAccountIds([nodeAccountId])
            .approveHbarAllowance(ownerAccountId, spenderAccountId1, hbarAmount)
            .approveTokenAllowance(
                tokenId1,
                ownerAccountId,
                spenderAccountId1,
                tokenAmount,
            )
            .approveTokenNftAllowance(nftId1, ownerAccountId, spenderAccountId1)
            .approveTokenNftAllowance(nftId2, ownerAccountId, spenderAccountId1)
            .approveTokenNftAllowance(nftId2, ownerAccountId, spenderAccountId2)
            .approveTokenNftAllowanceAllSerials(
                tokenId1,
                ownerAccountId,
                spenderAccountId1,
            )
            .freeze();

        transaction = Transaction.fromBytes(transaction.toBytes());

        const data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            cryptoAllowances: [
                {
                    owner: ownerAccountId._toProtobuf(),
                    amount: hbarAmount.toTinybars(),
                    spender: spenderAccountId1._toProtobuf(),
                },
            ],
            nftAllowances: [
                {
                    owner: ownerAccountId._toProtobuf(),
                    serialNumbers: [serialNumber1, serialNumber2],
                    spender: spenderAccountId1._toProtobuf(),
                    tokenId: tokenId2._toProtobuf(),
                    approvedForAll: null,
                    delegatingSpender: null,
                },
                {
                    owner: ownerAccountId._toProtobuf(),
                    serialNumbers: [serialNumber2],
                    spender: spenderAccountId2._toProtobuf(),
                    tokenId: tokenId2._toProtobuf(),
                    approvedForAll: null,
                    delegatingSpender: null,
                },
                {
                    owner: ownerAccountId._toProtobuf(),
                    serialNumbers: null,
                    spender: spenderAccountId1._toProtobuf(),
                    tokenId: tokenId1._toProtobuf(),
                    approvedForAll: { value: true },
                    delegatingSpender: null,
                },
            ],
            tokenAllowances: [
                {
                    owner: ownerAccountId._toProtobuf(),
                    amount: tokenAmount,
                    spender: spenderAccountId1._toProtobuf(),
                    tokenId: tokenId1._toProtobuf(),
                },
            ],
        });
    });
});
// Filename: test/unit/AccountAllowanceDeleteTransaction.js
import {
    AccountAllowanceDeleteTransaction,
    AccountId,
    Transaction,
    TransactionId,
    TokenId,
    NftId,
} from "../../src/index.js";
import Long from "long";

describe("AccountAllowanceDeleteTransaction", function () {
    it("[from|to]Bytes", async function () {
        const tokenId = TokenId.fromString("1.2.3");
        const serialNumber = Long.fromNumber(4);
        const operatorId = AccountId.fromString("5.6.7");
        const nftId = new NftId(tokenId, serialNumber);
        const transactionId = TransactionId.fromString(
            `${operatorId.toString()}@8.9`,
        );
        const nodeAccountId = AccountId.fromString("10.11.12");
        const transaction = new AccountAllowanceDeleteTransaction()
            .setNodeAccountIds([nodeAccountId])
            .setTransactionId(transactionId)
            .deleteAllTokenNftAllowances(nftId, operatorId)
            .freeze();

        const bytes = transaction.toBytes();
        Transaction.fromBytes(bytes);
    });
});
// Filename: test/unit/AccountCreateTransaction.js
import { expect } from "chai";

import Long from "long";

import {
    PrivateKey,
    AccountCreateTransaction,
    AccountId,
    Timestamp,
    Transaction,
    TransactionId,
    EvmAddress,
} from "../../src/index.js";

describe("AccountCreateTransaction", function () {
    describe("setECDSAKeyWithAlias", function () {
        /** @type {PrivateKey} */
        let privateEcdsaAccountKey;

        beforeEach(function () {
            privateEcdsaAccountKey = PrivateKey.generateECDSA();
        });

        it("should throw when transaction is frozen", function () {
            const transaction = new AccountCreateTransaction()
                .setNodeAccountIds([new AccountId(3)])
                .setTransactionId(TransactionId.generate(new AccountId(3)));

            transaction.freeze();

            expect(() => {
                transaction.setECDSAKeyWithAlias(privateEcdsaAccountKey);
            }).to.throw(Error);
        });

        it("should throw when a non-private ECDSA key is provided", function () {
            const publicAccountKey = PrivateKey.generateECDSA().publicKey;

            expect(() => {
                new AccountCreateTransaction().setECDSAKeyWithAlias(
                    publicAccountKey,
                );
            }).to.throw(Error);
        });

        it("should throw when a non-ECDSA private key is provided", function () {
            const privateEd25519AccountKey = PrivateKey.generateED25519();

            expect(() => {
                new AccountCreateTransaction().setECDSAKeyWithAlias(
                    privateEd25519AccountKey,
                );
            }).to.throw(Error);
        });

        it("should set correct account key and derived alias", function () {
            const transaction =
                new AccountCreateTransaction().setECDSAKeyWithAlias(
                    privateEcdsaAccountKey,
                );

            expect(transaction.key.toString()).to.equal(
                privateEcdsaAccountKey.toString(),
            );

            expect(transaction.alias.toString()).to.equal(
                privateEcdsaAccountKey.publicKey.toEvmAddress(),
            );
        });
    });

    describe("setKeyWithAlias", function () {
        /** @type {Key} */
        let accountKey;

        /** @type {PrivateKey} */
        let privateEcdsaAliasKey;

        beforeEach(function () {
            accountKey = PrivateKey.generateECDSA().publicKey;
            privateEcdsaAliasKey = PrivateKey.generateECDSA();
        });

        it("should throw when transaction is frozen", function () {
            const transaction = new AccountCreateTransaction()
                .setNodeAccountIds([new AccountId(3)])
                .setTransactionId(TransactionId.generate(new AccountId(3)));

            transaction.freeze();

            expect(() => {
                transaction.setKeyWithAlias(accountKey, privateEcdsaAliasKey);
            }).to.throw(Error);
        });

        it("should throw when a non-private alias key is provided", function () {
            const nonPrivateAliasKey = PrivateKey.generateECDSA().publicKey;

            expect(() => {
                new AccountCreateTransaction().setKeyWithAlias(
                    accountKey,
                    nonPrivateAliasKey,
                );
            }).to.throw(Error);
        });

        it("when a non-ECDSA private aliasKey is provided should throw", function () {
            const nonPrivateEcdsaAliasKey = PrivateKey.generateED25519();

            expect(() => {
                new AccountCreateTransaction().setKeyWithAlias(
                    accountKey,
                    nonPrivateEcdsaAliasKey,
                );
            }).to.throw(Error);
        });

        it("should set correct account key and alias derived from the alias key", function () {
            const transaction = new AccountCreateTransaction().setKeyWithAlias(
                accountKey,
                privateEcdsaAliasKey,
            );

            expect(transaction.key.toString()).to.equal(accountKey.toString());

            expect(transaction.alias.toString()).to.equal(
                privateEcdsaAliasKey.publicKey.toEvmAddress(),
            );
        });
    });

    describe("setKeyWithoutAlias", function () {
        it("should throw when transaction is frozen", function () {
            const transaction = new AccountCreateTransaction()
                .setNodeAccountIds([new AccountId(3)])
                .setTransactionId(TransactionId.generate(new AccountId(3)));

            transaction.freeze();

            const accountKey = PrivateKey.generateECDSA();
            expect(() => {
                transaction.setKeyWithoutAlias(accountKey);
            }).to.throw(Error);
        });

        it("should set correct account key without modifying the alias when key is provided", function () {
            const accountKey = PrivateKey.generateECDSA();
            const aliasKey = PrivateKey.generateECDSA();

            const transaction = new AccountCreateTransaction().setAlias(
                aliasKey.publicKey.toEvmAddress(),
            );

            transaction.setKeyWithoutAlias(accountKey);

            expect(transaction.key.toString()).to.equal(accountKey.toString());

            expect(transaction.alias.toString()).to.equal(
                aliasKey.publicKey.toEvmAddress(),
            );
        });
    });

    it("should round trip from bytes and maintain order", function () {
        const key1 = PrivateKey.generateECDSA();
        const spenderAccountId1 = new AccountId(7);
        const nodeAccountId = new AccountId(10, 11, 12);
        const timestamp1 = new Timestamp(14, 15);
        const evmAddress = key1.publicKey.toEvmAddress();

        let transaction = new AccountCreateTransaction()
            .setTransactionId(
                TransactionId.withValidStart(spenderAccountId1, timestamp1),
            )
            .setAlias(evmAddress)
            .setNodeAccountIds([nodeAccountId])
            .freeze();

        transaction = Transaction.fromBytes(transaction.toBytes());

        const data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            alias: EvmAddress.fromString(evmAddress).toBytes(),
            autoRenewPeriod: {
                seconds: Long.fromValue(7776000),
            },
            declineReward: false,
            initialBalance: Long.ZERO,
            key: null,
            maxAutomaticTokenAssociations: 0,
            memo: "",
            proxyAccountID: null,
            receiveRecordThreshold: Long.fromString("9223372036854775807"),
            receiverSigRequired: false,
            sendRecordThreshold: Long.fromString("9223372036854775807"),
            stakedAccountId: null,
            stakedNodeId: null,
        });
    });
});
// Filename: test/unit/AccountId.js
import { expect } from "chai";

import { AccountId, PublicKey } from "../../src/index.js";

import BigNumber from "bignumber.js";
import EvmAddress from "../../src/EvmAddress.js";

describe("AccountId", function () {
    it("constructors", function () {
        expect(new AccountId(3).toString()).to.be.equal("0.0.3");
        expect(new AccountId(1, 2, 3).toString()).to.be.equal("1.2.3");
        expect(
            new AccountId({
                shard: 1,
                realm: 2,
                num: 3,
            }).toString(),
        ).to.be.equal("1.2.3");
        expect(
            new AccountId(
                1,
                2,
                0,
                PublicKey.fromString(
                    "302a300506032b657003210008d5a4eebdb9b8451b64d8ad1ff502b493590e513e5e9c9f810dd3258f298542",
                ),
            ).toString(),
        ).to.be.equal(
            "1.2.302a300506032b657003210008d5a4eebdb9b8451b64d8ad1ff502b493590e513e5e9c9f810dd3258f298542",
        );
        expect(AccountId.fromString("1.2.3").toString()).to.be.equal("1.2.3");
        expect(
            AccountId.fromString(
                "1.2.302a300506032b657003210008d5a4eebdb9b8451b64d8ad1ff502b493590e513e5e9c9f810dd3258f298542",
            ).toString(),
        ).to.be.equal(
            "1.2.302a300506032b657003210008d5a4eebdb9b8451b64d8ad1ff502b493590e513e5e9c9f810dd3258f298542",
        );
        expect(
            new AccountId(
                1,
                2,
                0,
                undefined,
                EvmAddress.fromString(
                    "0011223344556677889900112233445566778899",
                ),
            ).toString(),
        ).to.be.equal("1.2.0011223344556677889900112233445566778899");
    });

    it("clones with alias key", function () {
        expect(
            AccountId.fromString(
                "1.2.302a300506032b657003210008d5a4eebdb9b8451b64d8ad1ff502b493590e513e5e9c9f810dd3258f298542",
            )
                .clone()
                .toString(),
        ).to.be.equal(
            "1.2.302a300506032b657003210008d5a4eebdb9b8451b64d8ad1ff502b493590e513e5e9c9f810dd3258f298542",
        );
    });

    it("should construct from (shard, realm, num)", function () {
        const accountId = new AccountId(10, 50, 25050);

        expect(accountId.num.toNumber()).to.eql(25050);
        expect(accountId.realm.toNumber()).to.eql(50);
        expect(accountId.shard.toNumber()).to.eql(10);
    });

    it("should construct from (0, 0, 0)", function () {
        const accountId = new AccountId(0, 0, 0);

        expect(accountId.num.toNumber()).to.eql(0);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);
    });

    it("should construct from (num)", function () {
        const accountId = new AccountId(25050);

        expect(accountId.num.toNumber()).to.eql(25050);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);
    });

    it("should parse {shard}.{realm}.{num}", function () {
        const accountId = AccountId.fromString("10.50.25050");

        expect(accountId.num.toNumber()).to.eql(25050);
        expect(accountId.realm.toNumber()).to.eql(50);
        expect(accountId.shard.toNumber()).to.eql(10);
    });

    it("should parse 0.0.0", function () {
        const accountId = AccountId.fromString("0.0.0");

        expect(accountId.num.toNumber()).to.eql(0);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);
    });

    it("should parse {num}", function () {
        const accountId = AccountId.fromString("25050");

        expect(accountId.num.toNumber()).to.eql(25050);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);
    });

    it("should error with invalid string", function () {
        let err = false;

        try {
            AccountId.fromString("asdfasf");
        } catch {
            err = true;
        }

        try {
            AccountId.fromString(" .0.1");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("`AccountId.fromString()` did not error");
        }

        try {
            AccountId.fromString("");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("`AccountId.fromString()` did not error");
        }

        try {
            AccountId.fromString("0.0");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("`AccountId.fromString()` did not error");
        }

        try {
            AccountId.fromString("0.0.");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("`AccountId.fromString()` did not error");
        }

        try {
            AccountId.fromString("0.0.a");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("`AccountId.fromString()` did not error");
        }

        try {
            AccountId.fromString("0.0.-a");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("`AccountId.fromString()` did not error");
        }
    });

    it("should error when string negative numbers are directly passed to constructor", function () {
        let err = false;

        try {
            AccountId.fromString("0.0.-1");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }

        try {
            AccountId.fromString("-1.-1.-1");
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }

        try {
            new AccountId(0, 0, -1);
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }

        try {
            new AccountId(-1, -1, -1);
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }

        try {
            new AccountId(-1);
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }

        try {
            new AccountId(new BigNumber(-1));
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }

        try {
            new AccountId(
                new BigNumber(-1),
                new BigNumber(-1),
                new BigNumber(-1),
            );
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error(
                "`AccountId.constructor` with negative numbers did not error",
            );
        }
    });
});
// Filename: test/unit/AccountInfoMocking.js
import { expect } from "chai";
import {
    Hbar,
    MaxQueryPaymentExceeded,
    AccountInfoQuery,
    AccountId,
    FileCreateTransaction,
    TransactionId,
    TransferTransaction,
} from "../../src/index.js";
import Mocker, { UNAVAILABLE, INTERNAL, PRIVATE_KEY } from "./Mocker.js";
import Long from "long";
import { proto } from "@hashgraph/proto";
import * as hex from "../../src/encoding/hex.js";

const ACCOUNT_INFO_QUERY_COST_RESPONSE = {
    cryptoGetInfo: {
        header: {
            nodeTransactionPrecheckCode: 0,
            responseType: 2,
            cost: Long.fromNumber(25),
        },
    },
};

const ACCOUNT_INFO_QUERY_RESPONSE = {
    cryptoGetInfo: {
        header: { nodeTransactionPrecheckCode: 0 },
        accountInfo: {
            accountID: {
                shardNum: Long.ZERO,
                realmNum: Long.ZERO,
                accountNum: Long.fromNumber(3),
            },
            key: {
                ed25519: PRIVATE_KEY.publicKey.toBytesRaw(),
            },
            expirationTime: {
                seconds: Long.fromNumber(10),
                nanos: 9,
            },
            alias: null,
        },
    },
};

describe("AccountInfoMocking", function () {
    let client;
    let servers;

    afterEach(function () {
        client.close();
        servers.close();
    });

    it("payment transaction is correctly constructed", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    call: () => {
                        return ACCOUNT_INFO_QUERY_COST_RESPONSE;
                    },
                },
                {
                    call: (request) => {
                        const transaction = TransferTransaction.fromBytes(
                            proto.Transaction.encode(
                                request.cryptoGetInfo.header.payment,
                            ).finish(),
                        );
                        const hbarTransfers = transaction.hbarTransfers;
                        expect(hbarTransfers.size).to.be.equal(2);
                        expect(
                            hbarTransfers
                                .get(client.operatorAccountId)
                                .toTinybars()
                                .toInt(),
                        ).to.be.lt(0);
                        expect(
                            hbarTransfers
                                .get(Object.values(client.network)[0])
                                .toTinybars()
                                .toInt(),
                        ).to.be.gt(0);
                        return ACCOUNT_INFO_QUERY_RESPONSE;
                    },
                },
            ],
        ]));

        const info = await new AccountInfoQuery()
            .setAccountId("0.0.3")
            .execute(client);

        expect(info.accountId.toString()).to.be.equal("0.0.3");
    });

    it("should retry on UNAVAILABLE", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { error: UNAVAILABLE },
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ],
        ]));

        const info = await new AccountInfoQuery()
            .setAccountId("0.0.3")
            .execute(client);

        expect(info.accountId.toString()).to.be.equal("0.0.3");
    });

    it("should error when cost is greater than max cost set on client", async function () {
        let errorName;

        ({ client, servers } = await Mocker.withResponses([
            [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ],
        ]));

        client.setDefaultMaxQueryPayment(Hbar.fromTinybars(10));

        try {
            await new AccountInfoQuery()
                .setAccountId("0.0.3")
                .execute(client, 1);
        } catch (error) {
            errorName = error.name;
        }

        expect(errorName).to.be.eql("MaxQueryPaymentExceededError");
    });

    it("setQueryPayemnt() avoids querying actual cost", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [{ response: ACCOUNT_INFO_QUERY_RESPONSE }],
        ]));

        const query = new AccountInfoQuery()
            .setAccountId("0.0.3")
            .setQueryPayment(Hbar.fromTinybars(10));

        await query.execute(client, 1);

        expect(query._queryPayment.toTinybars().toInt()).to.be.equal(10);
    }, 15000);

    it("setQueryPayemnt() + setMaxQueryPayment() avoids querying actual cost", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [{ response: ACCOUNT_INFO_QUERY_RESPONSE }],
        ]));

        const query = new AccountInfoQuery()
            .setAccountId("0.0.3")
            .setMaxQueryPayment(Hbar.fromTinybars(1))
            .setQueryPayment(Hbar.fromTinybars(10));

        await query.execute(client, 1);

        expect(query._queryPayment.toTinybars().toInt()).to.be.equal(10);
    });

    it("actual cost is compared to Client.maxQueryPayment if Query.setMaxQueryPayment is not used", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ],
        ]));

        client.setDefaultMaxQueryPayment(Hbar.fromTinybars(24));

        let err = false;

        const query = new AccountInfoQuery().setAccountId("0.0.3");

        try {
            await query.execute(client, 1);
        } catch (error) {
            err = error instanceof MaxQueryPaymentExceeded;
        }

        expect(err).to.be.true;
    });

    it("actual cost is compared to Query.setMaxQueryPayment when set", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ],
        ]));

        let err = false;

        const query = new AccountInfoQuery()
            .setMaxQueryPayment(Hbar.fromTinybars(24))
            .setAccountId("0.0.3");

        try {
            await query.execute(client, 1);
        } catch (error) {
            err = error instanceof MaxQueryPaymentExceeded;
        }

        expect(err).to.be.true;
    });

    it("should not error when cost is less than max cost set on request", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ],
        ]));

        let err = false;

        try {
            await new AccountInfoQuery()
                .setAccountId("0.0.3")
                .setMaxQueryPayment(Hbar.fromTinybars(28))
                .execute(client, 1);
        } catch (error) {
            err = error instanceof MaxQueryPaymentExceeded;
        }

        expect(err).to.be.false;
    });

    it("should retry on `INTERNAL` and retry multiple nodes", async function () {
        const responses1 = [
            { error: INTERNAL },
            { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
            { error: INTERNAL },
            { error: INTERNAL },
        ];

        const responses2 = [
            { error: INTERNAL },
            { error: INTERNAL },
            { response: ACCOUNT_INFO_QUERY_RESPONSE },
        ];

        ({ client, servers } = await Mocker.withResponses([
            responses1,
            responses2,
        ]));

        const info = await new AccountInfoQuery()
            .setNodeAccountIds([new AccountId(3), new AccountId(4)])
            .setAccountId("0.0.3")
            .execute(client);

        expect(info.accountId.toString()).to.be.equal("0.0.3");
    });

    it("should be able to execute after getting transaction hashes", async function () {
        const responses1 = [{ response: { nodeTransactionPrecheckCode: 0 } }];

        ({ client, servers } = await Mocker.withResponses([responses1]));

        client.setSignOnDemand(true);

        const transaction = await new FileCreateTransaction()
            .setContents("hello 1")
            .freezeWith(client)
            .signWithOperator(client);

        const hash = await transaction.getTransactionHash();
        const response = await transaction.execute(client);

        expect(hash.length).to.be.equal(48);
        expect(hex.encode(hash)).to.be.equal(
            hex.encode(response.transactionHash),
        );
    });

    it("should be able to execute after getting transaction hashes with sign on demand disabled", async function () {
        const responses1 = [{ response: { nodeTransactionPrecheckCode: 0 } }];

        ({ client, servers } = await Mocker.withResponses([responses1]));

        const transaction = await new FileCreateTransaction()
            .setContents("hello 1")
            .freezeWith(client)
            .signWithOperator(client);

        const hash = await transaction.getTransactionHash();
        const response = await transaction.execute(client);

        expect(hash.length).to.be.equal(48);
        expect(hex.encode(hash)).to.be.equal(
            hex.encode(response.transactionHash),
        );
    });

    it("should generate new transaction ID when TRANSACTION_EXPIRED is return", async function () {
        const transactionIds = new Set();
        const callResponses = [
            {
                nodeTransactionPrecheckCode:
                    proto.ResponseCodeEnum.TRANSACTION_EXPIRED,
            },
            { nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK },
        ];

        /**
         * @type {(request: proto.ITransaction, index: number) => proto.ITransactionResponse}
         */
        const call = (request, index) => {
            expect(request.signedTransactionBytes).to.not.be.null;
            const signedTransaction = proto.SignedTransaction.decode(
                request.signedTransactionBytes,
            );

            expect(signedTransaction.bodyBytes).to.not.be.null;
            const transactionBody = proto.TransactionBody.decode(
                signedTransaction.bodyBytes,
            );

            expect(transactionBody.transactionId).to.not.be.null;
            const transactionId = TransactionId._fromProtobuf(
                transactionBody.transactionID,
            ).toString();
            expect(transactionId).to.not.be.equal("");

            expect(transactionIds.has(transactionId)).to.be.false;
            transactionIds.add(transactionId);

            // Verify signatures exist
            expect(Mocker.verifySignatures(signedTransaction)).to.be.true;

            return callResponses[index];
        };

        const responses1 = [{ call }, { call }, { call }];

        ({ client, servers } = await Mocker.withResponses([responses1]));

        client.setSignOnDemand(true);

        await new FileCreateTransaction()
            .setContents("hello 1")
            .execute(client);
    });

    it("should error `TRANSACTION_EXPIRED` is return and client disabled transaction regeneration", async function () {
        const responses1 = [
            {
                response: {
                    nodeTransactionPrecheckCode:
                        proto.ResponseCodeEnum.TRANSACTION_EXPIRED,
                },
            },
        ];

        ({ client, servers } = await Mocker.withResponses([responses1]));

        client.setSignOnDemand(true);

        try {
            await new FileCreateTransaction()
                .setTransactionId(
                    TransactionId.fromString("0.0.1854@1651168054.29348185"),
                )
                .setContents("hello 1")
                .setRegenerateTransactionId(false)
                .execute(client);
        } catch (error) {
            if (
                error.message !==
                "transaction 0.0.1854@1651168054.029348185 failed precheck with status TRANSACTION_EXPIRED against node account id 0.0.3"
            ) {
                throw error;
            }
        }
    });

    it("should still regenerate transaction IDs on `TRANSACTION_EXPIRED` when client disabled it, but transaction re-enabled it", async function () {
        const transactionIds = new Set();
        const callResponses = [
            {
                nodeTransactionPrecheckCode:
                    proto.ResponseCodeEnum.TRANSACTION_EXPIRED,
            },
            { nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK },
        ];

        /**
         * @type {(request: proto.ITransaction, index: number) => proto.ITransactionResponse}
         */
        const call = (request, index) => {
            expect(request.signedTransactionBytes).to.not.be.null;
            const signedTransaction = proto.SignedTransaction.decode(
                request.signedTransactionBytes,
            );

            expect(signedTransaction.bodyBytes).to.not.be.null;
            const transactionBody = proto.TransactionBody.decode(
                signedTransaction.bodyBytes,
            );

            expect(transactionBody.transactionId).to.not.be.null;
            const transactionId = TransactionId._fromProtobuf(
                transactionBody.transactionID,
            ).toString();
            expect(transactionId).to.not.be.equal("");

            expect(transactionIds.has(transactionId)).to.be.false;
            transactionIds.add(transactionId);

            // Verify signatures exist
            expect(Mocker.verifySignatures(signedTransaction)).to.be.true;

            return callResponses[index];
        };

        const responses1 = [{ call }, { call }, { call }];

        ({ client, servers } = await Mocker.withResponses([responses1]));

        client.setSignOnDemand(true);
        client.setDefaultRegenerateTransactionId(false);

        await new FileCreateTransaction()
            .setRegenerateTransactionId(true)
            .setContents("hello 1")
            .execute(client);
    });

    it("should timeout if Client.setRequestTimeout is set", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
            ],
        ]));

        client.setRequestTimeout(1);

        let err = false;

        try {
            await new AccountInfoQuery().setAccountId("0.0.3").execute(client);
        } catch (error) {
            err = error.message == "timeout exceeded";
        }

        if (!err) {
            throw new Error("request didn't timeout");
        }
    });

    it("should timeout if Executable.execute(client, requestTimeout) is set", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
            ],
        ]));

        let err = false;

        try {
            await new AccountInfoQuery()
                .setAccountId("0.0.3")
                .execute(client, 1);
        } catch (error) {
            err = error.message == "timeout exceeded";
        }

        if (!err) {
            throw new Error("request didn't timeout");
        }
    });

    it("should timeout if gRPC deadline is reached", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
            ],
        ]));

        let err = false;

        try {
            await new AccountInfoQuery()
                .setAccountId("0.0.3")
                .setGrpcDeadline(1)
                .execute(client);
        } catch (error) {
            err = error.message == "grpc deadline exceeded";
        }

        if (!err) {
            throw new Error("request didn't timeout");
        }
    });

    it("should timeout immediately", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
            ],
        ]));

        let err = false;

        try {
            await new AccountInfoQuery()
                .setAccountId("0.0.3")
                .execute(client, 1);
        } catch (error) {
            err = error.message === "timeout exceeded";
        }

        expect(err).to.be.true;
    });

    it("should doesn't timeout immediately", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
            ],
        ]));

        let err = false;

        try {
            await new AccountInfoQuery()
                .setAccountId("0.0.3")
                .execute(client, 10000);
        } catch (error) {
            err = error.message === "timeout exceeded";
        }

        expect(err).to.be.false;
    });

    it("should throw an error if trying to execute the transaction with node which is not within client`s node list", async function () {
        const responses1 = [{ response: { nodeTransactionPrecheckCode: 0 } }];

        ({ client, servers } = await Mocker.withResponses([responses1]));

        client.setSignOnDemand(true);

        const transaction = new FileCreateTransaction()
            .setContents("hello 1")
            .freezeWith(client);

        // Sets the nodeAccountIds to a different list, but doesn't lock the list
        // this simulates when `freezeWith()` sets the node account IDs to a list
        // without locking it, but this list overwritten when executing.
        transaction._nodeAccountIds.setList([new AccountId(4)]);
        await transaction.signWithOperator(client);

        try {
            await transaction.execute(client);
        } catch (error) {
            // Attempting to execute the transaction with a node that is not in the client's node list
            expect(error.message).to.be.equal(
                "Attempting to execute a transaction against node 0.0.4, which is not included in the Client's node list. Please review your Client configuration.",
            );
        }
    });

    it("should demonstrate UNAVAILABLE behavior with multiple nodes", async function () {
        ({ client, servers } = await Mocker.withResponses([
            // First node (0.0.3)
            [
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
                { error: UNAVAILABLE },
            ],
            // Second node (0.0.4)
            [
                { error: UNAVAILABLE },
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ],
        ]));

        const info = await new AccountInfoQuery()
            .setNodeAccountIds([new AccountId(3), new AccountId(4)])
            .setAccountId("0.0.3")
            .execute(client);

        expect(info.accountId.toString()).to.be.equal("0.0.3");
    });

    describe("Node health checks", function () {
        beforeEach(async function () {
            const responses1 = [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ];

            const responses2 = [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ];

            const responses3 = [
                { response: ACCOUNT_INFO_QUERY_COST_RESPONSE },
                { response: ACCOUNT_INFO_QUERY_RESPONSE },
            ];

            ({ client, servers } = await Mocker.withResponses([
                responses1,
                responses2,
                responses3,
            ]));
        });

        it("should throw error because every node is unhealthy", async function () {
            // Make node 3 unhealthy
            client._network._network.get("0.0.3")[0]._readmitTime =
                Date.now() + 100 * 10010;

            // Make node 4 unhealthy
            client._network._network.get("0.0.4")[0]._readmitTime =
                Date.now() + 100 * 10010;

            try {
                await new AccountInfoQuery()
                    .setNodeAccountIds([new AccountId(3), new AccountId(4)])
                    .setAccountId("0.0.3")
                    .execute(client);
                throw new Error("should have thrown");
            } catch (error) {
                expect(error.message).to.equal(
                    "Network connectivity issue: All nodes are unhealthy. Original node list: 0.0.3, 0.0.4",
                );
            }
        });

        it("should skip unhealthy node and execute with healthy node", async function () {
            // Make node 3 unhealthy
            client._network._network.get("0.0.3")[0]._readmitTime =
                Date.now() + 100 * 10010;

            const info = await new AccountInfoQuery()
                .setNodeAccountIds([new AccountId(3), new AccountId(4)])
                .setAccountId("0.0.3")
                .execute(client);

            expect(info.accountId.toString()).to.be.equal("0.0.3");
        });

        it("should execute with last healthy node when multiple nodes are unhealthy", async function () {
            // Make nodes 3 and 5 unhealthy
            client._network._network.get("0.0.3")[0]._readmitTime =
                Date.now() + 100 * 10010;
            client._network._network.get("0.0.5")[0]._readmitTime =
                Date.now() + 100 * 10010;

            const info = await new AccountInfoQuery()
                .setNodeAccountIds([
                    new AccountId(3),
                    new AccountId(4),
                    new AccountId(5),
                ])
                .execute(client);

            expect(info.accountId.toString()).to.be.equal("0.0.3");
        });
    });
});
// Filename: test/unit/AccountInfoQuery.js
import { AccountId, Query, AccountInfoQuery } from "../../src/index.js";

describe("AccountInfo", function () {
    it("[to|from]Bytes()", async function () {
        const accountId = new AccountId(10);

        const query = Query.fromBytes(
            new AccountInfoQuery().setAccountId(accountId).toBytes(),
        );

        expect(query instanceof AccountInfoQuery).to.be.true;

        expect(query.accountId.toString()).to.be.equal(accountId.toString());
    });
});
// Filename: test/unit/AccountUpdateTransaction.js
import { AccountUpdateTransaction } from "../../src/index.js";

describe("AccountUpdateTransaction", function () {
    describe("deserialization of optional parameters", function () {
        let tx, txBytes, tx2;

        before(function () {
            tx = new AccountUpdateTransaction();
            txBytes = tx.toBytes();
            tx2 = AccountUpdateTransaction.fromBytes(txBytes);
        });

        it("should deserialize with accountMemo being null", function () {
            expect(tx.accountMemo).to.be.null;
            expect(tx2.accountMemo).to.be.null;
        });

        it("should deserialize with declineReward, receiverSignatureRequired being null", function () {
            expect(tx.declineStakingRewards).to.be.null;
            expect(tx2.declineStakingRewards).to.be.null;

            expect(tx.receiverSignatureRequired).to.be.null;
            expect(tx2.receiverSignatureRequired).to.be.null;
        });

        it("should deserialize with maxAutomaticTokenAssociations being null", function () {
            expect(tx.maxAutomaticTokenAssociations).to.be.null;
            expect(tx2.maxAutomaticTokenAssociations).to.be.null;
        });
    });
});
// Filename: test/unit/AirdropCancelTransaction.js
import { AccountId, TokenId } from "../../src/exports.js";
import TokenCancelAirdropTransaction from "../../src/token/TokenCancelAirdropTransaction.js";
import PendingAirdropId from "../../src/token/PendingAirdropId.js";

describe("TokenAirdropCancelTransaction", function () {
    it("from | to bytes", async function () {
        const pendingAirdropId = new PendingAirdropId({
            tokenId: new TokenId(0, 0, 123),
            serial: 456,
            senderId: new AccountId(0, 0, 789),
            receiverId: new AccountId(0, 0, 987),
        });

        const tx = new TokenCancelAirdropTransaction({
            pendingAirdropIds: [pendingAirdropId],
        });
        console.log(tx.toBytes());

        const tx2 = TokenCancelAirdropTransaction.fromBytes(tx.toBytes());

        expect(tx2.pendingAirdropIds[0]).to.deep.equal(pendingAirdropId);
    });
});
// Filename: test/unit/AirdropClaimTransaction.js
import { AccountId, TokenId } from "../../src/exports.js";
import TokenClaimAirdropTransaction from "../../src/token/TokenClaimAirdropTransaction.js";
import PendingAirdropId from "../../src/token/PendingAirdropId.js";

describe("TokenClaimAirdropTransaction", function () {
    it("from | to bytes", async function () {
        const pendingAirdropId = new PendingAirdropId({
            tokenId: new TokenId(0, 0, 123),
            serial: 456,
            senderId: new AccountId(0, 0, 789),
            receiverId: new AccountId(0, 0, 987),
        });
        const tx = new TokenClaimAirdropTransaction({
            pendingAirdropIds: [pendingAirdropId],
        });

        const tx2 = TokenClaimAirdropTransaction.fromBytes(tx.toBytes());

        expect(tx2.pendingAirdropIds[0]).to.deep.equal(pendingAirdropId);
    });
});
// Filename: test/unit/ChecksumValidation.js
import { expect } from "chai";

import { AccountId } from "../../src/index.js";

import Client from "../../src/client/NodeClient.js";

describe("ChecksumValidation", function () {
    it("should parse mainnet ID with checksum {0.0.123-vfmkw}", function () {
        const accountId = AccountId.fromString("0.0.123-vfmkw");

        expect(accountId.num.toNumber()).to.eql(123);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);

        expect(
            accountId.toStringWithChecksum(
                Client.forMainnet({ scheduleNetworkUpdate: false }),
            ),
        ).to.be.eql("0.0.123-vfmkw");
    });

    it("should parse testnet ID with checksum {0.0.123-esxsf}", function () {
        const accountId = AccountId.fromString("0.0.123-esxsf");

        expect(accountId.num.toNumber()).to.eql(123);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);

        expect(
            accountId.toStringWithChecksum(
                Client.forTestnet({ scheduleNetworkUpdate: false }),
            ),
        ).to.be.eql("0.0.123-esxsf");
    });

    it("should parse previewnet ID with checksum {0.0.123-ogizo}", function () {
        const accountId = AccountId.fromString("0.0.123-ogizo");

        expect(accountId.num.toNumber()).to.eql(123);
        expect(accountId.realm.toNumber()).to.eql(0);
        expect(accountId.shard.toNumber()).to.eql(0);

        expect(
            accountId.toStringWithChecksum(
                Client.forPreviewnet({ scheduleNetworkUpdate: false }),
            ),
        ).to.be.eql("0.0.123-ogizo");
    });
});
// Filename: test/unit/ContractCreateFlowMocking.js
import { expect } from "chai";
import {
    ContractCreateFlow,
    Transaction,
    PrivateKey,
} from "../../src/index.js";
import Mocker, { TRANSACTION_RECEIPT_SUCCESS_RESPONSE } from "./Mocker.js";
import { proto } from "@hashgraph/proto";
import { bigContents } from "../integration/contents.js";

describe("ContractCreateFlowMocking", function () {
    let client;
    let servers;
    let wallet;

    afterEach(function () {
        client.close();
        servers.close();
    });

    it("signs all transactions", async function () {
        const key = PrivateKey.generate();

        const verifyTransactionCall = (request) => {
            const transaction = Transaction.fromBytes(
                proto.Transaction.encode({
                    signedTransactionBytes: request.signedTransactionBytes,
                }).finish(),
            );

            expect(key.publicKey.verifyTransaction(transaction)).to.be.true;

            return { nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK };
        };

        ({ client, servers } = await Mocker.withResponses([
            [
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        await new ContractCreateFlow()
            .setBytecode(bigContents)
            .sign(key)
            .execute(client);
    });

    it("signs all transactions with wallet", async function () {
        const key = PrivateKey.generate();

        const verifyTransactionCall = (request) => {
            const transaction = Transaction.fromBytes(
                proto.Transaction.encode({
                    signedTransactionBytes: request.signedTransactionBytes,
                }).finish(),
            );

            expect(key.publicKey.verifyTransaction(transaction)).to.be.true;

            return { nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK };
        };

        ({ wallet, servers } = await Mocker.withResponses([
            [
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { call: verifyTransactionCall },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        await new ContractCreateFlow()
            .setBytecode(bigContents)
            .sign(key)
            .executeWithSigner(wallet);
    });
});
// Filename: test/unit/ContractFunctionParameters.js
import { ContractFunctionParameters } from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";

import BigNumber from "bignumber.js";

const int32 = 16909060;

const bytes = new Uint8Array(10);
bytes[1] = 1;
bytes[4] = 4;
bytes[9] = 8;

const maxInt64 = new BigNumber("0x7FFFFFFFFFFFFFFF", 16);

const str = "this is a grin: \uD83D\uDE01";

const strArray = ["one", "two"];

describe("ContractFunctionParameters", function () {
    it("should convert number to BigNumber in addUint256()", function () {
        const contractFunctionParameters = new ContractFunctionParameters();

        const num = 111;
        const cfp = contractFunctionParameters.addUint256(num);

        const bigNum = BigNumber(111);
        contractFunctionParameters.addUint256(bigNum);

        expect(cfp._arguments[0].value).to.eql(cfp._arguments[1].value);
    });

    it("should convert number to BigNumber in addUint24()", function () {
        const contractFunctionParameters = new ContractFunctionParameters();

        const num = 111;
        const cfp = contractFunctionParameters.addUint24(num);

        const bigNum = BigNumber(111);
        contractFunctionParameters.addUint24(bigNum);

        expect(cfp._arguments[0].value).to.eql(cfp._arguments[1].value);
    });

    it("should convert number to BigNumber in addInt24()", function () {
        const contractFunctionParameters = new ContractFunctionParameters();

        const num = 111;
        const cfp = contractFunctionParameters.addInt24(num);

        const bigNum = BigNumber(111);
        contractFunctionParameters.addInt24(bigNum);

        expect(cfp._arguments[0].value).to.eql(cfp._arguments[1].value);
    });

    it("should convert number to BigNumber in addUint256Array()", function () {
        const contractFunctionParameters = new ContractFunctionParameters();

        const numArray = [111, 1112];

        const cfp = contractFunctionParameters.addUint256Array(numArray);

        const bigArray = [new BigNumber(111), new BigNumber(1112)];

        contractFunctionParameters.addUint256Array(bigArray);

        expect(cfp._arguments[0].value).to.eql(cfp._arguments[1].value);
    });

    it("encodes correctly using function selector", function () {
        const bytes2 = new Uint8Array(32);
        bytes2[0] = 255;
        bytes2[31] = 255;

        const params = new ContractFunctionParameters()
            .addInt32(int32)
            .addBytes(bytes)
            .addInt64(maxInt64)
            .addBytes(bytes2)
            .addString(str);

        const finished = params._build("f");
        const funcHash = hex.encode(finished.slice(0, 4));
        const firstParam = hex.encode(finished.slice(32 * 0 + 4, 32 * 1 + 4));
        const secondParam = hex.encode(finished.slice(32 * 1 + 4, 32 * 2 + 4));
        const thirdParam = hex.encode(finished.slice(32 * 2 + 4, 32 * 3 + 4));
        const forthParam = hex.encode(finished.slice(32 * 3 + 4, 32 * 4 + 4));
        const fifthParam = hex.encode(finished.slice(32 * 4 + 4, 32 * 5 + 4));
        const secondParamDataLength = hex.encode(
            finished.slice(32 * 5 + 4, 32 * 6 + 4),
        );
        const secondParamData = hex.encode(
            finished.slice(32 * 6 + 4, 32 * 7 + 4),
        );
        const fourthParamDataLength = hex.encode(
            finished.slice(32 * 7 + 4, 32 * 8 + 4),
        );
        const fourthParamData = hex.encode(
            finished.slice(32 * 8 + 4, 32 * 9 + 4),
        );
        const fifthParamDataLength = hex.encode(
            finished.slice(32 * 9 + 4, 32 * 10 + 4),
        );
        const fifthParamData = hex.encode(
            finished.slice(32 * 10 + 4, 32 * 11 + 4),
        );
        expect(funcHash).to.be.equal("b54f97cf");
        expect(firstParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000001020304",
        );
        expect(secondParam).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000000a0",
        );
        expect(thirdParam).to.be.equal(
            "0000000000000000000000000000000000000000000000007fffffffffffffff",
        );
        expect(forthParam).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000000e0",
        );
        expect(fifthParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000120",
        );
        expect(secondParamDataLength).to.be.equal(
            "000000000000000000000000000000000000000000000000000000000000000a",
        );
        expect(secondParamData).to.be.equal(
            "0001000004000000000800000000000000000000000000000000000000000000",
        );
        expect(fourthParamDataLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000020",
        );
        expect(fourthParamData).to.be.equal(
            "ff000000000000000000000000000000000000000000000000000000000000ff",
        );
        expect(fifthParamDataLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000014",
        );
        expect(fifthParamData).to.be.equal(
            "746869732069732061206772696e3a20f09f9881000000000000000000000000",
        );
        expect(finished.length).to.be.equal(356);
    });

    it("encodes correctly using generic addParam", function () {
        const params = new ContractFunctionParameters()
            .addInt32(int32)
            .addInt32(int32)
            .addInt64(maxInt64)
            .addString(str)
            .addInt32(1515)
            .addStringArray(strArray);

        const finished = params._build("f");
        const funcHash = hex.encode(finished.slice(0, 4));
        const firstParam = hex.encode(finished.slice(32 * 0 + 4, 32 * 1 + 4));
        const secondParam = hex.encode(finished.slice(32 * 1 + 4, 32 * 2 + 4));
        const thirdParam = hex.encode(finished.slice(32 * 2 + 4, 32 * 3 + 4));
        const forthParam = hex.encode(finished.slice(32 * 3 + 4, 32 * 4 + 4));
        const fifthParam = hex.encode(finished.slice(32 * 4 + 4, 32 * 5 + 4));
        const sixthParam = hex.encode(finished.slice(32 * 5 + 4, 32 * 6 + 4));
        const fourthParamDataLength = hex.encode(
            finished.slice(32 * 6 + 4, 32 * 7 + 4),
        );
        const fourthParamData = hex.encode(
            finished.slice(32 * 7 + 4, 32 * 8 + 4),
        );
        const sixthParamDataLength = hex.encode(
            finished.slice(32 * 8 + 4, 32 * 9 + 4),
        );
        const sixthParamFirstElOff = hex.encode(
            finished.slice(32 * 9 + 4, 32 * 10 + 4),
        );
        const sixthParamSecondElOff = hex.encode(
            finished.slice(32 * 10 + 4, 32 * 11 + 4),
        );
        const sixthParamFirstElLen = hex.encode(
            finished.slice(32 * 11 + 4, 32 * 12 + 4),
        );
        const sixthParamFirstEl = hex.encode(
            finished.slice(32 * 12 + 4, 32 * 13 + 4),
        );
        const sixthParamSecondElLen = hex.encode(
            finished.slice(32 * 13 + 4, 32 * 14 + 4),
        );
        const sixthParamSecondEl = hex.encode(
            finished.slice(32 * 14 + 4, 32 * 15 + 4),
        );
        expect(funcHash).to.be.equal("a27fc6f6");
        expect(firstParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000001020304",
        );
        expect(secondParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000001020304",
        );
        expect(thirdParam).to.be.equal(
            "0000000000000000000000000000000000000000000000007fffffffffffffff",
        );
        expect(forthParam).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000000c0",
        );
        expect(fifthParam).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000005eb",
        );
        expect(sixthParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000100",
        );
        expect(fourthParamDataLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000014",
        );
        expect(fourthParamData).to.be.equal(
            "746869732069732061206772696e3a20f09f9881000000000000000000000000",
        );
        expect(sixthParamDataLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(sixthParamFirstElOff).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000040",
        );
        expect(sixthParamSecondElOff).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000080",
        );
        expect(sixthParamFirstElLen).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000003",
        );
        expect(sixthParamFirstEl).to.be.equal(
            "6f6e650000000000000000000000000000000000000000000000000000000000",
        );
        expect(sixthParamSecondElLen).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000003",
        );
        expect(sixthParamSecondEl).to.be.equal(
            "74776f0000000000000000000000000000000000000000000000000000000000",
        );
        expect(finished.length).to.be.equal(484);
    });

    it("encodes correctly without name", function () {
        const params = new ContractFunctionParameters()
            .addInt32(int32)
            .addInt32(int32)
            .addInt64(maxInt64)
            .addString(str)
            .addInt32(1515)
            .addStringArray(strArray);

        const finished = params._build(null);
        const firstParam = hex.encode(finished.slice(32 * 0, 32 * 1));
        const secondParam = hex.encode(finished.slice(32 * 1, 32 * 2));
        const thirdParam = hex.encode(finished.slice(32 * 2, 32 * 3));
        const forthParam = hex.encode(finished.slice(32 * 3, 32 * 4));
        const fifthParam = hex.encode(finished.slice(32 * 4, 32 * 5));
        const sixthParam = hex.encode(finished.slice(32 * 5, 32 * 6));
        const fourthParamDataLength = hex.encode(
            finished.slice(32 * 6, 32 * 7),
        );
        const fourthParamData = hex.encode(finished.slice(32 * 7, 32 * 8));
        const sixthParamDataLength = hex.encode(finished.slice(32 * 8, 32 * 9));
        const sixthParamFirstElOff = hex.encode(
            finished.slice(32 * 9, 32 * 10),
        );
        const sixthParamSecondElOff = hex.encode(
            finished.slice(32 * 10, 32 * 11),
        );
        const sixthParamFirstElLen = hex.encode(
            finished.slice(32 * 11, 32 * 12),
        );
        const sixthParamFirstEl = hex.encode(finished.slice(32 * 12, 32 * 13));
        const sixthParamSecondElLen = hex.encode(
            finished.slice(32 * 13, 32 * 14),
        );
        const sixthParamSecondEl = hex.encode(finished.slice(32 * 14, 32 * 15));
        expect(firstParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000001020304",
        );
        expect(secondParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000001020304",
        );
        expect(thirdParam).to.be.equal(
            "0000000000000000000000000000000000000000000000007fffffffffffffff",
        );
        expect(forthParam).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000000c0",
        );
        expect(fifthParam).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000005eb",
        );
        expect(sixthParam).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000100",
        );
        expect(fourthParamDataLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000014",
        );
        expect(fourthParamData).to.be.equal(
            "746869732069732061206772696e3a20f09f9881000000000000000000000000",
        );
        expect(sixthParamDataLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(sixthParamFirstElOff).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000040",
        );
        expect(sixthParamSecondElOff).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000080",
        );
        expect(sixthParamFirstElLen).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000003",
        );
        expect(sixthParamFirstEl).to.be.equal(
            "6f6e650000000000000000000000000000000000000000000000000000000000",
        );
        expect(sixthParamSecondElLen).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000003",
        );
        expect(sixthParamSecondEl).to.be.equal(
            "74776f0000000000000000000000000000000000000000000000000000000000",
        );
        expect(finished.length).to.be.equal(480);
    });

    it("encodes address", function () {
        const params = new ContractFunctionParameters().addAddress(
            "888937961a6E3D313e481a2c5BAd9791fD11ea5b",
        );

        const finished = params._build(null);
        const firstParam = hex.encode(finished.slice(32 * 0, 32 * 1));
        expect(firstParam).to.be.equal(
            "000000000000000000000000888937961a6e3d313e481a2c5bad9791fd11ea5b",
        );
        expect(finished.length).to.be.equal(32);
    });

    it("encodes address with 0x prefix", function () {
        const params = new ContractFunctionParameters().addAddress(
            "0x888937961a6E3D313e481a2c5BAd9791fD11ea5b",
        );

        const finished = params._build(null);
        const firstParam = hex.encode(finished.slice(32 * 0, 32 * 1));
        expect(firstParam).to.be.equal(
            "000000000000000000000000888937961a6e3d313e481a2c5bad9791fd11ea5b",
        );
        expect(finished.length).to.be.equal(32);
    });

    it("encodes arrays correctly", function () {
        const params = new ContractFunctionParameters()
            .addInt256(maxInt64)
            .addInt32Array([1111, 2222])
            .addInt64Array([new BigNumber(3333), new BigNumber(4444)])
            .addInt256Array([new BigNumber(5555), new BigNumber(6666)])
            .addAddressArray([
                "888937961a6E3D313e481a2c5BAd9791fD11ea5b",
                "ffffffffffffffffffffffffffffffffffffffff",
            ])
            .addInt256Array([new BigNumber(7777), new BigNumber(8888)]);

        const finished = params._build(null);
        const firstParam = hex.encode(finished.slice(32 * 0, 32 * 1));
        const secondOffset = hex.encode(finished.slice(32 * 1, 32 * 2));
        const thirdOffset = hex.encode(finished.slice(32 * 2, 32 * 3));
        const forthOffset = hex.encode(finished.slice(32 * 3, 32 * 4));
        const fifthOffset = hex.encode(finished.slice(32 * 4, 32 * 5));
        const sixthOffset = hex.encode(finished.slice(32 * 5, 32 * 6));
        const secondLength = hex.encode(finished.slice(32 * 6, 32 * 7));
        const secondFirstValue = hex.encode(finished.slice(32 * 7, 32 * 8));
        const secondSecondValue = hex.encode(finished.slice(32 * 8, 32 * 9));
        const thirdLength = hex.encode(finished.slice(32 * 9, 32 * 10));
        const thirdFirstValue = hex.encode(finished.slice(32 * 10, 32 * 11));
        const thirdSecondValue = hex.encode(finished.slice(32 * 11, 32 * 12));
        const forthLength = hex.encode(finished.slice(32 * 12, 32 * 13));
        const forthFirstValue = hex.encode(finished.slice(32 * 13, 32 * 14));
        const forthSecondValue = hex.encode(finished.slice(32 * 14, 32 * 15));
        const fifthLength = hex.encode(finished.slice(32 * 15, 32 * 16));
        const fifthFirstValue = hex.encode(finished.slice(32 * 16, 32 * 17));
        const fifthSecondValue = hex.encode(finished.slice(32 * 17, 32 * 18));
        const sixthLength = hex.encode(finished.slice(32 * 18, 32 * 19));
        const sixthFirstValue = hex.encode(finished.slice(32 * 19, 32 * 20));
        const sixthSecondValue = hex.encode(finished.slice(32 * 20, 32 * 21));
        expect(firstParam).to.be.equal(
            "0000000000000000000000000000000000000000000000007fffffffffffffff",
        );
        expect(secondOffset).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000000c0",
        );
        expect(thirdOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000120",
        );
        expect(forthOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000180",
        );
        expect(fifthOffset).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000001e0",
        );
        expect(sixthOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000240",
        );
        expect(secondLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(secondFirstValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000457",
        );
        expect(secondSecondValue).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000008ae",
        );
        expect(thirdLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(thirdFirstValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000d05",
        );
        expect(thirdSecondValue).to.be.equal(
            "000000000000000000000000000000000000000000000000000000000000115c",
        );
        expect(forthLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(forthFirstValue).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000015b3",
        );
        expect(forthSecondValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000001a0a",
        );
        expect(fifthLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(fifthFirstValue).to.be.equal(
            "000000000000000000000000888937961a6e3d313e481a2c5bad9791fd11ea5b",
        );
        expect(fifthSecondValue).to.be.equal(
            "000000000000000000000000ffffffffffffffffffffffffffffffffffffffff",
        );
        expect(sixthLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(sixthFirstValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000001e61",
        );
        expect(sixthSecondValue).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000022b8",
        );
        expect(finished.length).to.be.equal(672);
    });

    it("encodes uint arrays correctly", function () {
        const params = new ContractFunctionParameters()
            .addUint256(maxInt64)
            .addUint32Array([1111, 2222])
            .addUint64Array([new BigNumber(3333), new BigNumber(4444)])
            .addUint256Array([new BigNumber(5555), new BigNumber(6666)])
            .addAddressArray([
                "888937961a6E3D313e481a2c5BAd9791fD11ea5b",
                "ffffffffffffffffffffffffffffffffffffffff",
            ])
            .addUint256Array([new BigNumber(7777), new BigNumber(8888)]);

        const finished = params._build(null);
        const firstParam = hex.encode(finished.slice(32 * 0, 32 * 1));
        const secondOffset = hex.encode(finished.slice(32 * 1, 32 * 2));
        const thirdOffset = hex.encode(finished.slice(32 * 2, 32 * 3));
        const forthOffset = hex.encode(finished.slice(32 * 3, 32 * 4));
        const fifthOffset = hex.encode(finished.slice(32 * 4, 32 * 5));
        const sixthOffset = hex.encode(finished.slice(32 * 5, 32 * 6));
        const secondLength = hex.encode(finished.slice(32 * 6, 32 * 7));
        const secondFirstValue = hex.encode(finished.slice(32 * 7, 32 * 8));
        const secondSecondValue = hex.encode(finished.slice(32 * 8, 32 * 9));
        const thirdLength = hex.encode(finished.slice(32 * 9, 32 * 10));
        const thirdFirstValue = hex.encode(finished.slice(32 * 10, 32 * 11));
        const thirdSecondValue = hex.encode(finished.slice(32 * 11, 32 * 12));
        const forthLength = hex.encode(finished.slice(32 * 12, 32 * 13));
        const forthFirstValue = hex.encode(finished.slice(32 * 13, 32 * 14));
        const forthSecondValue = hex.encode(finished.slice(32 * 14, 32 * 15));
        const fifthLength = hex.encode(finished.slice(32 * 15, 32 * 16));
        const fifthFirstValue = hex.encode(finished.slice(32 * 16, 32 * 17));
        const fifthSecondValue = hex.encode(finished.slice(32 * 17, 32 * 18));
        const sixthLength = hex.encode(finished.slice(32 * 18, 32 * 19));
        const sixthFirstValue = hex.encode(finished.slice(32 * 19, 32 * 20));
        const sixthSecondValue = hex.encode(finished.slice(32 * 20, 32 * 21));
        expect(firstParam).to.be.equal(
            "0000000000000000000000000000000000000000000000007fffffffffffffff",
        );
        expect(secondOffset).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000000c0",
        );
        expect(thirdOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000120",
        );
        expect(forthOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000180",
        );
        expect(fifthOffset).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000001e0",
        );
        expect(sixthOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000240",
        );
        expect(secondLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(secondFirstValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000457",
        );
        expect(secondSecondValue).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000008ae",
        );
        expect(thirdLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(thirdFirstValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000d05",
        );
        expect(thirdSecondValue).to.be.equal(
            "000000000000000000000000000000000000000000000000000000000000115c",
        );
        expect(forthLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(forthFirstValue).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000015b3",
        );
        expect(forthSecondValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000001a0a",
        );
        expect(fifthLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(fifthFirstValue).to.be.equal(
            "000000000000000000000000888937961a6e3d313e481a2c5bad9791fd11ea5b",
        );
        expect(fifthSecondValue).to.be.equal(
            "000000000000000000000000ffffffffffffffffffffffffffffffffffffffff",
        );
        expect(sixthLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000002",
        );
        expect(sixthFirstValue).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000001e61",
        );
        expect(sixthSecondValue).to.be.equal(
            "00000000000000000000000000000000000000000000000000000000000022b8",
        );
        expect(finished.length).to.be.equal(672);
    });

    it("encodes bytes32 correctly", function () {
        const bytes = new Uint8Array(32);
        bytes.set([0xff, 0xff], 10);

        const params = new ContractFunctionParameters().addBytes32(bytes);

        const finished = params._build(null);
        const firstParam = hex.encode(finished.slice(32 * 0, 32 * 1));
        expect(firstParam).to.be.equal(
            "00000000000000000000ffff0000000000000000000000000000000000000000",
        );
        expect(finished.length).to.be.equal(32);
    });

    it("encodes bytes of size > 32 and size % 32 === 0 correctly", function () {
        const bytes = new Uint8Array(64);
        bytes.set([0xff, 0xff], 10);

        const params = new ContractFunctionParameters().addBytes(bytes);

        const finished = params._build(null);
        const firstOffset = hex.encode(finished.slice(32 * 0, 32 * 1));
        const firstLength = hex.encode(finished.slice(32 * 1, 32 * 2));
        const firstValuePart1 = hex.encode(finished.slice(32 * 2, 32 * 3));
        const firstValuePart2 = hex.encode(finished.slice(32 * 3, 32 * 4));
        expect(firstOffset).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000020",
        );
        expect(firstLength).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000040",
        );
        expect(firstValuePart1).to.be.equal(
            "00000000000000000000ffff0000000000000000000000000000000000000000",
        );
        expect(firstValuePart2).to.be.equal(
            "0000000000000000000000000000000000000000000000000000000000000000",
        );
        expect(finished.length).to.be.equal(128);
    });
});
// Filename: test/unit/ContractFunctionResult.js
import {
    AccountId,
    ContractFunctionResult,
    ContractId,
    ContractNonceInfo,
} from "../../src/exports.js";
import * as hex from "../../src/encoding/hex.js";
import { BigNumber } from "@ethersproject/bignumber";

describe("ContractFunctionResult", function () {
    it("provides results correctly", async function () {
        const CALL_RESULT_HEX =
            "00000000000000000000000000000000000000000000000000000000ffffffff" +
            "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF" +
            "00000000000000000000000011223344556677889900aabbccddeeff00112233" +
            "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" +
            "00000000000000000000000000000000000000000000000000000000000000c0" +
            "0000000000000000000000000000000000000000000000000000000000000100" +
            "000000000000000000000000000000000000000000000000000000000000000d" +
            "48656c6c6f2c20776f726c642100000000000000000000000000000000000000" +
            "0000000000000000000000000000000000000000000000000000000000000014" +
            "48656c6c6f2c20776f726c642c20616761696e21000000000000000000000000";

        const callResult = hex.decode(CALL_RESULT_HEX);
        const evmAddress = hex.decode(
            "98329e006610472e6B372C080833f6D79ED833cf",
        );
        const nonce = new ContractNonceInfo({
            contractId: AccountId.fromString("1.2.3"),
            nonce: 10,
        });

        const result = new ContractFunctionResult({
            contractId: ContractId.fromString("1.2.3")._toProtobuf(),
            bytes: callResult,
            evmAddress: evmAddress,
            senderAccountId: AccountId.fromString("1.2.3")._toProtobuf(),
            contractNonces: [nonce],
        });

        expect(result.getBool(0)).to.be.true;
        expect(result.getInt32(0)).to.be.equal(-1);
        expect(result.getInt64(0).toString()).to.be.equal(
            (BigNumber.from(1).shl(32) - BigNumber.from(1)).toString(),
        );
        expect(result.getInt256(0).toString()).to.be.equal(
            (BigNumber.from(1).shl(32) - BigNumber.from(1)).toString(),
        );
        expect(result.getInt256(1).toString()).to.be.equal(
            (BigNumber.from(1).shl(255) - BigNumber.from(1))
                .toExponential(76)
                .replace("8e+76", "7e+76"),
        );
        expect(result.getAddress(2)).to.be.equal(
            "11223344556677889900aabbccddeeff00112233",
        );

        //expect(result.getUint32(3)).to.be.equal(-1);
        //expect(result.getUint64(3)).to.be.equal(-1);
        expect(result.getUint256(3).toString()).to.be.equal(
            (BigNumber.from(1).shl(256) - BigNumber.from(1))
                .toExponential(77)
                .replace("36e+77", "35e+77"),
        );

        expect(result.getString(4)).to.be.equal("Hello, world!");
        expect(result.getString(5)).to.be.equal("Hello, world, again!");

        expect(result.senderAccountId.toString()).to.be.equal(
            AccountId.fromString("1.2.3")._toProtobuf().toString(),
        );
        expect(result.contractId.toString()).to.be.equal(
            ContractId.fromString("1.2.3")._toProtobuf().toString(),
        );
        expect(result.evmAddress).to.be.equal(evmAddress);
        expect(result.contractNonces).to.include(nonce);
    });
});
// Filename: test/unit/ContractId.js
import { expect } from "chai";

import { ContractId } from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";
import Long from "long";

describe("ContractId", function () {
    const evmAddress = "0011223344556677889900112233445577889900";

    it("fromString() with num", function () {
        expect(ContractId.fromString(`1.2.3`).toString()).to.be.equal(`1.2.3`);
    });

    it("fromString() with evmAddress", function () {
        expect(
            ContractId.fromString(`1.2.${evmAddress}`).toString(),
        ).to.be.equal(`1.2.${evmAddress}`);
    });

    it("toSolidityAddress() to prioritize evmAddress", function () {
        const emvAddresContractId = ContractId.fromEvmAddress(1, 2, evmAddress);

        expect(emvAddresContractId.toString()).to.be.equal(`1.2.${evmAddress}`);
        expect(emvAddresContractId.toSolidityAddress()).to.be.equal(evmAddress);
    });

    it("toString() to prioritize evmAddress", function () {
        const emvAddresContractId = ContractId.fromEvmAddress(1, 2, evmAddress);

        expect(emvAddresContractId.toString()).to.be.equal(`1.2.${evmAddress}`);
    });

    it("toProtobuf() with evmAddres", function () {
        const emvAddresContractId = ContractId.fromEvmAddress(1, 2, evmAddress);

        expect(emvAddresContractId._toProtobuf()).to.deep.equal({
            shardNum: Long.fromNumber(1),
            realmNum: Long.fromNumber(2),
            contractNum: Long.ZERO,
            evmAddress: hex.decode(evmAddress),
        });
    });

    it("toProtobuf() with evmAddress", function () {
        const contractId = new ContractId(1, 2, 3);

        expect(contractId._toProtobuf()).to.deep.equal({
            shardNum: Long.fromNumber(1),
            realmNum: Long.fromNumber(2),
            contractNum: Long.fromNumber(3),
            evmAddress: null,
        });
    });

    it("should return the contract id from long zero address", function () {
        const shard = 0,
            realm = 0,
            num = 5;
        const ADDRESS_LENGTH = 42;
        const contractId = new ContractId(shard, realm, num);
        const longZeroAddress = contractId
            .toSolidityAddress()
            .padStart(ADDRESS_LENGTH, "0x");

        const contractIdFromAddress = ContractId.fromEvmAddress(
            shard,
            realm,
            longZeroAddress,
        );

        expect(contractId).to.deep.equal(contractIdFromAddress);
    });
});
// Filename: test/unit/ContractNonceInfo.js
import { ContractId, ContractNonceInfo } from "../../src/exports.js";

describe("ContractNonceInfo", function () {
    it("provides nonce correctly", async function () {
        const info = new ContractNonceInfo({
            contractId: ContractId.fromString("1.2.3"),
            nonce: 2,
        });

        const contractId = {
            shardNum: 1,
            realmNum: 2,
            contractNum: 3,
            evmAddress: null,
        };

        expect(info.contractId.shard.toNumber()).to.be.equal(
            contractId.shardNum,
        );
        expect(info.contractId.realm.toNumber()).to.be.equal(
            contractId.realmNum,
        );
        expect(info.contractId.num.toNumber()).to.be.equal(
            contractId.contractNum,
        );
        expect(info.contractId.evmAddress).to.be.equal(contractId.evmAddress);
        expect(info.nonce).to.be.equal(2);
    });
});
// Filename: test/unit/ContractUpdateTransaction.js
import { ContractUpdateTransaction } from "../../src/index.js";

describe("ContractUpdateTransaction", function () {
    describe("deserialization of optional parameters", function () {
        it("should deserialize with contractMemo being null", function () {
            const tx = new ContractUpdateTransaction();
            const tx2 = ContractUpdateTransaction.fromBytes(tx.toBytes());

            expect(tx.contractMemo).to.be.null;
            expect(tx2.contractMemo).to.be.null;
        });
    });
});
// Filename: test/unit/CustomFeeLimit.js
import {
    AccountId,
    CustomFeeLimit,
    CustomFixedFee,
    TokenId,
} from "../../src/index.js";

describe("CustomFeeLimit", function () {
    it("should set the correct account id", function () {
        const accountId = new AccountId(0, 0, 2);
        const customFeeLimit = new CustomFeeLimit().setAccountId(accountId);

        expect(customFeeLimit.getAccountId().toString()).to.eql(
            accountId.toString(),
        );
    });

    it("should set the correct custom fixed fees", function () {
        const tokenId = new TokenId(0);

        const amount = 100;

        const fixedFee = new CustomFixedFee()
            .setAmount(amount)
            .setDenominatingTokenId(tokenId);

        const customFeeLimit = new CustomFeeLimit().setFees([fixedFee]);

        expect(customFeeLimit.getFees()[0].amount.toString()).to.eql(
            amount.toString(),
        );

        expect(
            customFeeLimit.getFees()[0].denominatingTokenId.toString(),
        ).to.eql(tokenId.toString());
    });
});
// Filename: test/unit/DelegateContractId.js
import { expect } from "chai";

import { ContractId, DelegateContractId, Key } from "../../src/index.js";
import Long from "long";

describe("DelegateContractId", function () {
    it("constructors", function () {
        expect(() => new DelegateContractId(3)).to.not.throw();
        expect(() => new DelegateContractId(0, 0, 3)).to.not.throw();
        expect(
            () => new DelegateContractId({ shard: 0, realm: 0, num: 3 }),
        ).to.not.throw();
    });

    it(".[to|from]Protobuf()", function () {
        const id = new DelegateContractId(1, 2, 3);
        const idProto = {
            shardNum: Long.fromNumber(1),
            realmNum: Long.fromNumber(2),
            contractNum: Long.fromNumber(3),
            evmAddress: null,
        };
        const idProtoKey = {
            delegatableContractId: idProto,
        };
        const keyToId = Key._fromProtobufKey(idProtoKey);

        expect(id.toString()).to.be.equal("1.2.3");

        expect(id._toProtobuf()).to.deep.equal(idProto);
        expect(id._toProtobufKey()).to.deep.equal(idProtoKey);
        expect(
            DelegateContractId._fromProtobuf(idProto).toString(),
        ).to.deep.equal("1.2.3");
        expect(keyToId.toString()).to.deep.equal("1.2.3");
        expect(keyToId instanceof DelegateContractId).to.be.true;
        expect(keyToId instanceof ContractId).to.be.true;
    });
});
// Filename: test/unit/EcdsaPrivateKey.js
import { expect } from "chai";

import { Mnemonic, PrivateKey } from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";
import * as bip32 from "../../packages/cryptography/src/primitive/bip32.js";

const RAW_KEY =
    "8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048";
const DER_PRIVATE_KEY =
    "3030020100300706052b8104000a04220420e06ecd79f00124bfc030b0321006683a6a579be7602f2eb52ca73e2901880682";
const DER_PRIVATE_KEY_BYTES = new Uint8Array([
    48, 48, 2, 1, 0, 48, 7, 6, 5, 43, 129, 4, 0, 10, 4, 34, 4, 32, 224, 110,
    205, 121, 240, 1, 36, 191, 192, 48, 176, 50, 16, 6, 104, 58, 106, 87, 155,
    231, 96, 47, 46, 181, 44, 167, 62, 41, 1, 136, 6, 130,
]);
const DER_PUBLIC_KEY =
    "302d300706052b8104000a032200033697a2b3f9f0b9f4831b39986f7f3885636a3e8622a0bc3814a4a56f7ecdc4f1";
const STRESS_TEST_ITERATION_COUNT = 100;

describe("EcdsaPrivateKey", function () {
    it("generate should return object", function () {
        PrivateKey.generateECDSA();
    });

    it("generateAsync should return object", async function () {
        await PrivateKey.generateECDSAAsync();
    });

    it("fromStringRaw and fromStringDer work", function () {
        PrivateKey.fromStringDer(
            hex.encode(PrivateKey.fromStringECDSA(RAW_KEY).toBytesDer()),
        );
    });

    it("should return a public key from a der private key", function () {
        const publicKey =
            PrivateKey.fromStringDer(DER_PRIVATE_KEY).publicKey.toStringDer();
        expect(publicKey).to.be.equal(DER_PUBLIC_KEY);
    });

    it("should return a public key from a raw private key", function () {
        expect(
            PrivateKey.fromStringECDSA(RAW_KEY).publicKey.toStringRaw(),
        ).to.be.equal(
            "02703a9370b0443be6ae7c507b0aec81a55e94e4a863b9655360bd65358caa6588",
        );
    });

    it("SLIP10 test vector 1", async function () {
        // generate master PrivateKey with 'fromSeedECDSAsecp256k1()' and child key derivation
        // and test them against the provided constants which are always the source of truth
        // source - https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-1-for-secp256k1

        const CHAIN_CODE1 =
            "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508";
        const PRIVATE_KEY1 =
            "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35";
        const PUBLIC_KEY1 =
            "0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2";

        const CHAIN_CODE2 =
            "47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141";
        const PRIVATE_KEY2 =
            "edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea";
        const PUBLIC_KEY2 =
            "035a784662a4a20a65bf6aab9ae98a6c068a81c52e4b032c0fb5400c706cfccc56";

        const CHAIN_CODE3 =
            "2a7857631386ba23dacac34180dd1983734e444fdbf774041578e9b6adb37c19";
        const PRIVATE_KEY3 =
            "3c6cb8d0f6a264c91ea8b5030fadaa8e538b020f0a387421a12de9319dc93368";
        const PUBLIC_KEY3 =
            "03501e454bf00751f24b1b489aa925215d66af2234e3891c3b21a52bedb3cd711c";

        const CHAIN_CODE4 =
            "04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f";
        const PRIVATE_KEY4 =
            "cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca";
        const PUBLIC_KEY4 =
            "0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2";

        const CHAIN_CODE5 =
            "cfb71883f01676f587d023cc53a35bc7f88f724b1f8c2892ac1275ac822a3edd";
        const PRIVATE_KEY5 =
            "0f479245fb19a38a1954c5c7c0ebab2f9bdfd96a17563ef28a6a4b1a2a764ef4";
        const PUBLIC_KEY5 =
            "02e8445082a72f29b75ca48748a914df60622a609cacfce8ed0e35804560741d29";

        const CHAIN_CODE6 =
            "c783e67b921d2beb8f6b389cc646d7263b4145701dadd2161548a8b078e65e9e";
        const PRIVATE_KEY6 =
            "471b76e389e528d6de6d816857e012c5455051cad6660850e58372a6c3e6e7c8";
        const PUBLIC_KEY6 =
            "022a471424da5e657499d1ff51cb43c47481a03b1e77f951fe64cec9f5a48f7011";

        const seed = hex.decode("000102030405060708090a0b0c0d0e0f");

        // Chain m
        const key1 = await PrivateKey.fromSeedECDSAsecp256k1(seed);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(PUBLIC_KEY1).to.contain(key1.publicKey.toStringRaw());

        // Chain m/0'
        const key2 = await key1.derive(bip32.toHardenedIndex(0));
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(PUBLIC_KEY2).to.contain(key2.publicKey.toStringRaw());

        // Chain m/0'/1
        const key3 = await key2.derive(1);
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(PUBLIC_KEY3).to.contain(key3.publicKey.toStringRaw());

        // Chain m/0'/1/2'
        const key4 = await key3.derive(bip32.toHardenedIndex(2));
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(PUBLIC_KEY4).to.contain(key4.publicKey.toStringRaw());

        // Chain m/0'/1/2'/2
        const key5 = await key4.derive(2);
        expect(hex.encode(key5.chainCode)).to.be.equal(CHAIN_CODE5);
        expect(key5.toStringRaw()).to.be.equal(PRIVATE_KEY5);
        expect(PUBLIC_KEY5).to.contain(key5.publicKey.toStringRaw());

        // Chain m/0'/1/2'/2/1000000000
        const key6 = await key5.derive(1000000000);
        expect(hex.encode(key6.chainCode)).to.be.equal(CHAIN_CODE6);
        expect(key6.toStringRaw()).to.be.equal(PRIVATE_KEY6);
        expect(PUBLIC_KEY6).to.contain(key6.publicKey.toStringRaw());
    });

    it("SLIP10 test vector 2", async function () {
        // generate master PrivateKey with 'fromSeedECDSAsecp256k1()' and child key derivation
        // and test them against the provided constants which are always the source of truth
        // source - https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-2-for-secp256k1

        const CHAIN_CODE1 =
            "60499f801b896d83179a4374aeb7822aaeaceaa0db1f85ee3e904c4defbd9689";
        const PRIVATE_KEY1 =
            "4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e";
        const PUBLIC_KEY1 =
            "03cbcaa9c98c877a26977d00825c956a238e8dddfbd322cce4f74b0b5bd6ace4a7";

        const CHAIN_CODE2 =
            "f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c";
        const PRIVATE_KEY2 =
            "abe74a98f6c7eabee0428f53798f0ab8aa1bd37873999041703c742f15ac7e1e";
        const PUBLIC_KEY2 =
            "02fc9e5af0ac8d9b3cecfe2a888e2117ba3d089d8585886c9c826b6b22a98d12ea";

        const CHAIN_CODE3 =
            "be17a268474a6bb9c61e1d720cf6215e2a88c5406c4aee7b38547f585c9a37d9";
        const PRIVATE_KEY3 =
            "877c779ad9687164e9c2f4f0f4ff0340814392330693ce95a58fe18fd52e6e93";
        const PUBLIC_KEY3 =
            "03c01e7425647bdefa82b12d9bad5e3e6865bee0502694b94ca58b666abc0a5c3b";

        const CHAIN_CODE4 =
            "f366f48f1ea9f2d1d3fe958c95ca84ea18e4c4ddb9366c336c927eb246fb38cb";
        const PRIVATE_KEY4 =
            "704addf544a06e5ee4bea37098463c23613da32020d604506da8c0518e1da4b7";
        const PUBLIC_KEY4 =
            "03a7d1d856deb74c508e05031f9895dab54626251b3806e16b4bd12e781a7df5b9";

        const CHAIN_CODE5 =
            "637807030d55d01f9a0cb3a7839515d796bd07706386a6eddf06cc29a65a0e29";
        const PRIVATE_KEY5 =
            "f1c7c871a54a804afe328b4c83a1c33b8e5ff48f5087273f04efa83b247d6a2d";
        const PUBLIC_KEY5 =
            "02d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0";

        const CHAIN_CODE6 =
            "9452b549be8cea3ecb7a84bec10dcfd94afe4d129ebfd3b3cb58eedf394ed271";
        const PRIVATE_KEY6 =
            "bb7d39bdb83ecf58f2fd82b6d918341cbef428661ef01ab97c28a4842125ac23";
        const PUBLIC_KEY6 =
            "024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c";

        const seed = hex.decode(
            "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
        );

        // Chain m
        const key1 = await PrivateKey.fromSeedECDSAsecp256k1(seed);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(PUBLIC_KEY1).to.contain(key1.publicKey.toStringRaw());

        // Chain m/0
        const key2 = await key1.derive(0);
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(PUBLIC_KEY2).to.contain(key2.publicKey.toStringRaw());

        // Chain m/0/2147483647'
        const key3 = await key2.derive(bip32.toHardenedIndex(2147483647));
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(PUBLIC_KEY3).to.contain(key3.publicKey.toStringRaw());

        // Chain m/0/2147483647'/1
        const key4 = await key3.derive(1);
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(PUBLIC_KEY4).to.contain(key4.publicKey.toStringRaw());

        // Chain m/0/2147483647'/1/2147483646'
        const key5 = await key4.derive(bip32.toHardenedIndex(2147483646));
        expect(hex.encode(key5.chainCode)).to.be.equal(CHAIN_CODE5);
        expect(key5.toStringRaw()).to.be.equal(PRIVATE_KEY5);
        expect(PUBLIC_KEY5).to.contain(key5.publicKey.toStringRaw());

        // Chain m/0/2147483647'/1/2147483646'/2
        const key6 = await key5.derive(2);
        expect(hex.encode(key6.chainCode)).to.be.equal(CHAIN_CODE6);
        expect(key6.toStringRaw()).to.be.equal(PRIVATE_KEY6);
        expect(PUBLIC_KEY6).to.contain(key6.publicKey.toStringRaw());
    });

    it("PEM import test vectors", async function () {
        const TEST_VECTOR_PEM_PASSPHRASE = "asdasd123";

        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        const PRIVATE_KEY_PEM1 =
            "-----BEGIN EC PRIVATE KEY-----\n" +
            "MHQCAQEEIG8I+jKi+iGVa7ttbfnlnML5AdvPugbgBWnseYjrle6qoAcGBSuBBAAK\n" +
            "oUQDQgAEqf5BmMeBzkU1Ra9UAbZJo3tytVOlb7erTc36LRLP20mOLU7+mFY+3Cfe\n" +
            "fAZgBtPXRAmDtRvYGODswAalW85GKA==\n" +
            "-----END EC PRIVATE KEY-----";
        const PRIVATE_KEY1 =
            "6f08fa32a2fa21956bbb6d6df9e59cc2f901dbcfba06e00569ec7988eb95eeaa";
        const PUBLIC_KEY1 =
            "02a9fe4198c781ce453545af5401b649a37b72b553a56fb7ab4dcdfa2d12cfdb49";

        const PRIVATE_KEY_PEM2 =
            "-----BEGIN EC PRIVATE KEY-----\n" +
            "MFQCAQEEIOHyhclwHbha3f281Kvd884rhBzltxGJxCZyaQCagH9joAcGBSuBBAAK\n" +
            "oSQDIgACREr6gFZa4K7hBP+bA25VdgQ+0ABFgM+g5RYw/W6T1Og=\n" +
            "-----END EC PRIVATE KEY-----";
        const PRIVATE_KEY2 =
            "e1f285c9701db85addfdbcd4abddf3ce2b841ce5b71189c4267269009a807f63";
        const PUBLIC_KEY2 =
            "02444afa80565ae0aee104ff9b036e5576043ed0004580cfa0e51630fd6e93d4e8";

        const PRIVATE_KEY_PEM3 =
            "-----BEGIN EC PRIVATE KEY-----\n" +
            "Proc-Type: 4,ENCRYPTED\n" +
            "DEK-Info: AES-128-CBC,0046A9EED8D16F0CAA66A197CE8BE8BD\n" +
            "\n" +
            "9VU9gReUmrn4XywjMx0F0A3oGzpHIksEXma72TCSdcxI7zHy0mtzuGq4Wd25O38s\n" +
            "H9c6kvhTPS1N/c6iNhx154B0HUoND8jvAvfxbGR/R87vpZJsOoKCmRxGqrxG8HER\n" +
            "FIHQ1jy16DrAbU95kDyLsiF1dy2vUY/HoqFZwxl/IVc=\n" +
            "-----END EC PRIVATE KEY-----";
        const PRIVATE_KEY3 =
            "cf49eb5206c1b0468854d6ea7b370590619625514f71ff93608a18465e4012ad";
        const PUBLIC_KEY3 =
            "025f0d14a7562d6319e5b8f91620d2ce9ad13d9abf21cfe9bd0a092c0f35bf1701";

        const PRIVATE_KEY_PEM4 =
            "-----BEGIN EC PRIVATE KEY-----\n" +
            "Proc-Type: 4,ENCRYPTED\n" +
            "DEK-Info: AES-128-CBC,4A9B3B987EC2EFFA405818327D14FFF7\n" +
            "\n" +
            "Wh756RkK5fn1Ke2denR1OYfqE9Kr4BXhgrEMTU/6o0SNhMULUhWGHrCWvmNeEQwp\n" +
            "ZVZYUxgYoTlJBeREzKAZithcvxIcTbQfLABo1NZbjA6YKqAqlGpM6owwL/f9e2ST\n" +
            "-----END EC PRIVATE KEY-----";
        const PRIVATE_KEY4 =
            "c0d3e16ba5a1abbeac4cd327a3c3c1cc10438431d0bac019054e573e67768bb5";
        const PUBLIC_KEY4 =
            "02065f736378134c53c7a2ee46f199fb93b9b32337be4e95660677046476995544";

        const ecdsaPrivateKey1 = await PrivateKey.fromPem(PRIVATE_KEY_PEM1);
        expect(ecdsaPrivateKey1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(ecdsaPrivateKey1.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY1,
        );

        const ecdsaPrivateKey2 = await PrivateKey.fromPem(PRIVATE_KEY_PEM2);
        expect(ecdsaPrivateKey2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(ecdsaPrivateKey2.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY2,
        );

        const ecdsaPrivateKey3 = await PrivateKey.fromPem(
            PRIVATE_KEY_PEM3,
            TEST_VECTOR_PEM_PASSPHRASE,
        );
        expect(ecdsaPrivateKey3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(ecdsaPrivateKey3.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY3,
        );

        const ecdsaPrivateKey4 = await PrivateKey.fromPem(
            PRIVATE_KEY_PEM4,
            TEST_VECTOR_PEM_PASSPHRASE,
        );
        expect(ecdsaPrivateKey4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(ecdsaPrivateKey4.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY4,
        );
    });

    it("DER import test vectors", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        const PRIVATE_KEY_DER1 =
            "3030020100300706052b8104000a042204208c2cdc9575fe67493443967d74958fd7808a3787fd3337e99cfeebbc7566b586";
        const PRIVATE_KEY1 =
            "8c2cdc9575fe67493443967d74958fd7808a3787fd3337e99cfeebbc7566b586";
        const PUBLIC_KEY1 =
            "028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd";

        const PRIVATE_KEY_DER2 =
            "30540201010420ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffda00706052b8104000aa124032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";
        const PRIVATE_KEY2 =
            "ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffd";
        const PUBLIC_KEY2 =
            "036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";

        const PRIVATE_KEY_DER3 =
            "307402010104208927647ad12b29646a1d051da8453462937bb2c813c6815cac6c0b720526ffc6a00706052b8104000aa14403420004aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a6597795f855ddcad2377e22259d1fcb4e0f1d35e8f2056300c15070bcbfce3759cc9d";
        const PRIVATE_KEY3 =
            "8927647ad12b29646a1d051da8453462937bb2c813c6815cac6c0b720526ffc6";
        const PUBLIC_KEY3 =
            "03aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a65977";

        const PRIVATE_KEY_DER4 =
            "302e0201010420a6170a6aa6389a5bd3a3a8f9375f57bd91aa7f7d8b8b46ce0b702e000a21a5fea00706052b8104000a";
        const PRIVATE_KEY4 =
            "a6170a6aa6389a5bd3a3a8f9375f57bd91aa7f7d8b8b46ce0b702e000a21a5fe";
        const PUBLIC_KEY4 =
            "03b69a75a5ddb1c0747e995d47555019e5d8a28003ab5202bd92f534361fb4ec8a";

        const ecdsaPrivateKey1 = PrivateKey.fromStringDer(PRIVATE_KEY_DER1);
        expect(ecdsaPrivateKey1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(ecdsaPrivateKey1.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY1,
        );

        const ecdsaPrivateKey2 = PrivateKey.fromStringDer(PRIVATE_KEY_DER2);
        expect(ecdsaPrivateKey2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(ecdsaPrivateKey2.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY2,
        );

        const ecdsaPrivateKey3 = PrivateKey.fromStringDer(PRIVATE_KEY_DER3);
        expect(ecdsaPrivateKey3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(ecdsaPrivateKey3.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY3,
        );

        const ecdsaPrivateKey4 = PrivateKey.fromStringDer(PRIVATE_KEY_DER4);
        expect(ecdsaPrivateKey4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(ecdsaPrivateKey4.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY4,
        );
    });

    it("should return private key from bytes", async function () {
        const privateKeyFromBytes = PrivateKey.fromBytesECDSA(
            DER_PRIVATE_KEY_BYTES,
        );
        const publicKeyDer = privateKeyFromBytes.toStringDer();
        expect(publicKeyDer).to.be.equal(DER_PRIVATE_KEY);
    });

    it("should return a constructed aliasKey accountId", async function () {
        const privateKey = PrivateKey.generateECDSA();
        const publicKey = privateKey.publicKey;

        const aliasAccountId = publicKey.toAccountId(0, 0);

        expect(aliasAccountId.toString()).to.be.equal(
            `0.0.${publicKey.toString()}`,
        );
    });

    it("should return type of the private key", async function () {
        const privateKey = PrivateKey.generateECDSA();

        expect(privateKey.type).to.be.string("secp256k1");
    });

    it("should produce consistent public key from 12 word mnemonic and fromStringECDSA", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate12();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardECDSAsecp256k1PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromStringECDSA(
                privateKeyFromMnemonic.toStringDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });

    it("should produce consistent public key from 12 word mnemonic and fromBytesECDSA", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate12();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardECDSAsecp256k1PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromBytesECDSA(
                privateKeyFromMnemonic.toBytesDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });

    it("should produce consistent public key from 24 word mnemonic and fromStringECDSA", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardECDSAsecp256k1PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromStringECDSA(
                privateKeyFromMnemonic.toStringDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });

    it("should produce consistent public key from 24 word mnemonic and fromBytesECDSA", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardECDSAsecp256k1PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromBytesECDSA(
                privateKeyFromMnemonic.toBytesDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });
});
// Filename: test/unit/Ed25519PrivateKey.js
import { expect } from "chai";

import { Mnemonic, PrivateKey } from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";

const RAW_KEY =
    "302e020100300506032b657004220420a7bd8982bb05415bbc1e2dc2ae6aced66cba5eb871a4afd1579f8620b8c00d37";
// ED25519 key
const DER_PRIVATE_KEY =
    "302e020100300506032b6570042204203a056f85d71921be62466f5e93a4af0aa2e09a9eb4b2d839e06d805366659a74";
const DER_PRIVATE_KEY_BYTES = new Uint8Array([
    58, 5, 111, 133, 215, 25, 33, 190, 98, 70, 111, 94, 147, 164, 175, 10, 162,
    224, 154, 158, 180, 178, 216, 57, 224, 109, 128, 83, 102, 101, 154, 116,
]);
const DER_PUBLIC_KEY =
    "302a300506032b65700321004a6892f034d2d1c9b1a76acca8e34884055172f4210a0c02e3c7d55084f224d1";

const STRESS_TEST_ITERATION_COUNT = 100;

describe("Ed25519PrivateKey", function () {
    it("generate should return  object", function () {
        PrivateKey.generateED25519();
    });

    it("generateAsync should return  object", async function () {
        await PrivateKey.generateED25519Async();
    });

    it("fromStringDer works", function () {
        PrivateKey.fromStringDer(
            hex.encode(PrivateKey.fromStringED25519(RAW_KEY).toBytesDer()),
        );
    });

    it("should return a public key from a der private key", function () {
        const publicKey =
            PrivateKey.fromStringDer(DER_PRIVATE_KEY).publicKey.toStringDer();
        expect(publicKey).to.be.equal(DER_PUBLIC_KEY);
    });

    it("should return a public key from a raw private key", function () {
        expect(
            PrivateKey.fromStringED25519(RAW_KEY).publicKey.toStringRaw(),
        ).to.be.equal(
            "b0c169d4e4b6b70f5a6d7beecd892e009390e1a113821f5d761b21725c39ac91",
        );
    });

    it("SLIP10 test vector 1", async function () {
        // generate master PrivateKey with 'fromSeedED25519' and child key derivation
        // and test them against the provided constants which are always the source of truth
        // source - https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-1-for-ed25519

        const CHAIN_CODE1 =
            "90046a93de5380a72b5e45010748567d5ea02bbf6522f979e05c0d8d8ca9fffb";
        const PRIVATE_KEY1 =
            "2b4be7f19ee27bbf30c667b642d5f4aa69fd169872f8fc3059c08ebae2eb19e7";
        const PUBLIC_KEY1 =
            "00a4b2856bfec510abab89753fac1ac0e1112364e7d250545963f135f2a33188ed";

        const CHAIN_CODE2 =
            "8b59aa11380b624e81507a27fedda59fea6d0b779a778918a2fd3590e16e9c69";
        const PRIVATE_KEY2 =
            "68e0fe46dfb67e368c75379acec591dad19df3cde26e63b93a8e704f1dade7a3";
        const PUBLIC_KEY2 =
            "008c8a13df77a28f3445213a0f432fde644acaa215fc72dcdf300d5efaa85d350c";

        const CHAIN_CODE3 =
            "a320425f77d1b5c2505a6b1b27382b37368ee640e3557c315416801243552f14";
        const PRIVATE_KEY3 =
            "b1d0bad404bf35da785a64ca1ac54b2617211d2777696fbffaf208f746ae84f2";
        const PUBLIC_KEY3 =
            "001932a5270f335bed617d5b935c80aedb1a35bd9fc1e31acafd5372c30f5c1187";

        const CHAIN_CODE4 =
            "2e69929e00b5ab250f49c3fb1c12f252de4fed2c1db88387094a0f8c4c9ccd6c";
        const PRIVATE_KEY4 =
            "92a5b23c0b8a99e37d07df3fb9966917f5d06e02ddbd909c7e184371463e9fc9";
        const PUBLIC_KEY4 =
            "00ae98736566d30ed0e9d2f4486a64bc95740d89c7db33f52121f8ea8f76ff0fc1";

        const CHAIN_CODE5 =
            "8f6d87f93d750e0efccda017d662a1b31a266e4a6f5993b15f5c1f07f74dd5cc";
        const PRIVATE_KEY5 =
            "30d1dc7e5fc04c31219ab25a27ae00b50f6fd66622f6e9c913253d6511d1e662";
        const PUBLIC_KEY5 =
            "008abae2d66361c879b900d204ad2cc4984fa2aa344dd7ddc46007329ac76c429c";

        const CHAIN_CODE6 =
            "68789923a0cac2cd5a29172a475fe9e0fb14cd6adb5ad98a3fa70333e7afa230";
        const PRIVATE_KEY6 =
            "8f94d394a8e8fd6b1bc2f3f49f5c47e385281d5c17e65324b0f62483e37e8793";
        const PUBLIC_KEY6 =
            "003c24da049451555d51a7014a37337aa4e12d41e485abccfa46b47dfb2af54b7a";

        const seed = hex.decode("000102030405060708090a0b0c0d0e0f");

        // Chain m
        const key1 = await PrivateKey.fromSeedED25519(seed);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(PUBLIC_KEY1).to.contain(key1.publicKey.toStringRaw());

        // Chain m/0'
        const key2 = await key1.derive(0);
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(PUBLIC_KEY2).to.contain(key2.publicKey.toStringRaw());

        // Chain m/0'/1'
        const key3 = await key2.derive(1);
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(PUBLIC_KEY3).to.contain(key3.publicKey.toStringRaw());

        // Chain m/0'/1'/2'
        const key4 = await key3.derive(2);
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(PUBLIC_KEY4).to.contain(key4.publicKey.toStringRaw());

        // Chain m/0'/1'/2'/2'
        const key5 = await key4.derive(2);
        expect(hex.encode(key5.chainCode)).to.be.equal(CHAIN_CODE5);
        expect(key5.toStringRaw()).to.be.equal(PRIVATE_KEY5);
        expect(PUBLIC_KEY5).to.contain(key5.publicKey.toStringRaw());

        // Chain m/0'/1'/2'/2'/1000000000'
        const key6 = await key5.derive(1000000000);
        expect(hex.encode(key6.chainCode)).to.be.equal(CHAIN_CODE6);
        expect(key6.toStringRaw()).to.be.equal(PRIVATE_KEY6);
        expect(PUBLIC_KEY6).to.contain(key6.publicKey.toStringRaw());
    });

    it("SLIP10 test vector 2", async function () {
        // generate master PrivateKey with 'fromSeedED25519' and child key derivation
        // and test them against the provided constants which are always the source of truth
        // source - https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-2-for-ed25519

        const CHAIN_CODE1 =
            "ef70a74db9c3a5af931b5fe73ed8e1a53464133654fd55e7a66f8570b8e33c3b";
        const PRIVATE_KEY1 =
            "171cb88b1b3c1db25add599712e36245d75bc65a1a5c9e18d76f9f2b1eab4012";
        const PUBLIC_KEY1 =
            "008fe9693f8fa62a4305a140b9764c5ee01e455963744fe18204b4fb948249308a";

        const CHAIN_CODE2 =
            "0b78a3226f915c082bf118f83618a618ab6dec793752624cbeb622acb562862d";
        const PRIVATE_KEY2 =
            "1559eb2bbec5790b0c65d8693e4d0875b1747f4970ae8b650486ed7470845635";
        const PUBLIC_KEY2 =
            "0086fab68dcb57aa196c77c5f264f215a112c22a912c10d123b0d03c3c28ef1037";

        const CHAIN_CODE3 =
            "138f0b2551bcafeca6ff2aa88ba8ed0ed8de070841f0c4ef0165df8181eaad7f";
        const PRIVATE_KEY3 =
            "ea4f5bfe8694d8bb74b7b59404632fd5968b774ed545e810de9c32a4fb4192f4";
        const PUBLIC_KEY3 =
            "005ba3b9ac6e90e83effcd25ac4e58a1365a9e35a3d3ae5eb07b9e4d90bcf7506d";

        const CHAIN_CODE4 =
            "73bd9fff1cfbde33a1b846c27085f711c0fe2d66fd32e139d3ebc28e5a4a6b90";
        const PRIVATE_KEY4 =
            "3757c7577170179c7868353ada796c839135b3d30554bbb74a4b1e4a5a58505c";
        const PUBLIC_KEY4 =
            "002e66aa57069c86cc18249aecf5cb5a9cebbfd6fadeab056254763874a9352b45";

        const CHAIN_CODE5 =
            "0902fe8a29f9140480a00ef244bd183e8a13288e4412d8389d140aac1794825a";
        const PRIVATE_KEY5 =
            "5837736c89570de861ebc173b1086da4f505d4adb387c6a1b1342d5e4ac9ec72";
        const PUBLIC_KEY5 =
            "00e33c0f7d81d843c572275f287498e8d408654fdf0d1e065b84e2e6f157aab09b";

        const CHAIN_CODE6 =
            "5d70af781f3a37b829f0d060924d5e960bdc02e85423494afc0b1a41bbe196d4";
        const PRIVATE_KEY6 =
            "551d333177df541ad876a60ea71f00447931c0a9da16f227c11ea080d7391b8d";
        const PUBLIC_KEY6 =
            "0047150c75db263559a70d5778bf36abbab30fb061ad69f69ece61a72b0cfa4fc0";

        const seed = hex.decode(
            "fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542",
        );

        // Chain m
        const key1 = await PrivateKey.fromSeedED25519(seed);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(PUBLIC_KEY1).to.contain(key1.publicKey.toStringRaw());

        // Chain m/0'
        const key2 = await key1.derive(0);
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(PUBLIC_KEY2).to.contain(key2.publicKey.toStringRaw());

        // Chain m/0'/2147483647'
        const key3 = await key2.derive(2147483647);
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(PUBLIC_KEY3).to.contain(key3.publicKey.toStringRaw());

        // Chain m/0'/2147483647'/1'
        const key4 = await key3.derive(1);
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(PUBLIC_KEY4).to.contain(key4.publicKey.toStringRaw());

        // Chain m/0'/2147483647'/1'/2147483646'
        const key5 = await key4.derive(2147483646);
        expect(hex.encode(key5.chainCode)).to.be.equal(CHAIN_CODE5);
        expect(key5.toStringRaw()).to.be.equal(PRIVATE_KEY5);
        expect(PUBLIC_KEY5).to.contain(key5.publicKey.toStringRaw());

        // Chain m/0'/2147483647'/1'/2147483646'/2'
        const key6 = await key5.derive(2);
        expect(hex.encode(key6.chainCode)).to.be.equal(CHAIN_CODE6);
        expect(key6.toStringRaw()).to.be.equal(PRIVATE_KEY6);
        expect(PUBLIC_KEY6).to.contain(key6.publicKey.toStringRaw());
    });

    it("PEM import test vectors", async function () {
        const TEST_VECTOR_PEM_PASSPHRASE = "asdasd123";

        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        const PRIVATE_KEY_PEM1 =
            "-----BEGIN PRIVATE KEY-----\n" +
            "MC4CAQAwBQYDK2VwBCIEIOgbjaHgEqF7PY0t2dUf2VU0u1MRoKii/fywDlze4lvl\n" +
            "-----END PRIVATE KEY-----";
        const PRIVATE_KEY1 =
            "e81b8da1e012a17b3d8d2dd9d51fd95534bb5311a0a8a2fdfcb00e5cdee25be5";
        const PUBLIC_KEY1 =
            "f7b9aa4a8e4eee94e4277dfe757d8d7cde027e7cd5349b7d8e6ee21c9b9395be";

        const PRIVATE_KEY_PEM2 =
            "-----BEGIN ENCRYPTED PRIVATE KEY-----\n" +
            "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAiho4GvPxvL6wICCAAw\n" +
            "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEIdsubXR0QvxXGSprqDuDXwEQJZl\n" +
            "OBtwm2p2P7WrWE0OnjGxUe24fWwdrvJUuguFtH3FVWc8C5Jbxgbyxsuzbf+utNL6\n" +
            "0ey+WdbGL06Bw0HGqs8=\n" +
            "-----END ENCRYPTED PRIVATE KEY-----";
        const PRIVATE_KEY2 =
            "fa0857e963946d5f5e035684c40354d3cd3dcc80c0fb77beac2ef7c4b5271599";
        const PUBLIC_KEY2 =
            "202af61e141465d4bf2c356d37d18bd026c246bde4eb73258722ad11f790be4e";

        const ed25519PrivateKey1 = await PrivateKey.fromPem(PRIVATE_KEY_PEM1);
        expect(ed25519PrivateKey1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(ed25519PrivateKey1.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY1,
        );

        const ed25519PrivateKey2 = await PrivateKey.fromPem(
            PRIVATE_KEY_PEM2,
            TEST_VECTOR_PEM_PASSPHRASE,
        );
        expect(ed25519PrivateKey2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(ed25519PrivateKey2.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY2,
        );
    });

    it("DER import test vectors", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PRIVATE_KEY_DER1 =
            "302e020100300506032b657004220420feb858a4a69600a5eef2d9c76f7fb84fc0b6627f29e0ab17e160f640c267d404";
        var PRIVATE_KEY1 =
            "feb858a4a69600a5eef2d9c76f7fb84fc0b6627f29e0ab17e160f640c267d404";
        var PUBLIC_KEY1 =
            "8ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d";

        var ed25519PrivateKey1 = PrivateKey.fromStringDer(PRIVATE_KEY_DER1);
        expect(ed25519PrivateKey1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(ed25519PrivateKey1.publicKey.toStringRaw()).to.be.equal(
            PUBLIC_KEY1,
        );
    });

    it("should return private key from bytes", async function () {
        const privateKeyFromBytes = PrivateKey.fromBytesED25519(
            DER_PRIVATE_KEY_BYTES,
        );
        const publicKeyDer = privateKeyFromBytes.toStringDer();
        expect(publicKeyDer).to.be.equal(DER_PRIVATE_KEY);
    });

    it("should return a constructed aliasKey accountId", async function () {
        const privateKey = PrivateKey.generateED25519();
        const publicKey = privateKey.publicKey;

        const aliasAccountId = publicKey.toAccountId(0, 0);

        expect(aliasAccountId.toString()).to.be.equal(
            `0.0.${publicKey.toString()}`,
        );
    });

    it("should return type of the private key", async function () {
        const privateKey = PrivateKey.generateED25519();

        expect(privateKey.type).to.be.string("ED25519");
    });

    it("should produce consistent public key from 12 word mnemonic and fromStringED25519", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate12();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardEd25519PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromStringED25519(
                privateKeyFromMnemonic.toStringDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });

    it("should produce consistent public key from 12 word mnemonic and fromBytesED25519", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate12();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardEd25519PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromBytesED25519(
                privateKeyFromMnemonic.toBytesDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });

    it("should produce consistent public key from 24 word mnemonic and fromStringED5519", async function () {
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardEd25519PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromStringED25519(
                privateKeyFromMnemonic.toStringDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });

    it("should produce consistent public key from 24 word mnemonic and fromBytesED25519", async function () {
        this.timeout(120000);
        for (let i = 0; i < STRESS_TEST_ITERATION_COUNT; i++) {
            const mnemonic = await Mnemonic.generate();
            const privateKeyFromMnemonic =
                await mnemonic.toStandardEd25519PrivateKey();
            const publicKeyFromMnemonic = privateKeyFromMnemonic.publicKey;

            const privateKeyFromString = PrivateKey.fromBytesED25519(
                privateKeyFromMnemonic.toBytesDer(),
            );
            const publicKeyFromString = privateKeyFromString.publicKey;

            if (
                publicKeyFromMnemonic.toStringDer() !==
                publicKeyFromString.toStringDer()
            ) {
                console.log(
                    "Public key from mnemonic: ",
                    publicKeyFromMnemonic,
                );
                console.log("Public key from string: ", publicKeyFromString);
                throw new Error("Public key mismatch");
            }
        }
    });
});
// Filename: test/unit/EntityIdHelper.js
import { expect } from "chai";

import BigNumber from "bignumber.js";
import Long from "long";
import * as EntityIdHelper from "../../src/EntityIdHelper.js";

describe("EntityIdHelper", function () {
    it("should return hex encoded solidity address using toSolidityAddress", function () {
        let address = EntityIdHelper.toSolidityAddress([
            new Long(1),
            new Long(1),
            new Long(1),
        ]);
        const addressExpected = "0000000100000000000000010000000000000001";
        expect(address).to.eql(addressExpected);

        address = EntityIdHelper.toSolidityAddress([1, 1, 1]);
        expect(address).to.eql(addressExpected);

        address = EntityIdHelper.toSolidityAddress([
            new BigNumber(1),
            new BigNumber(1),
            new BigNumber(1),
        ]);
        expect(address).to.eql(addressExpected);

        address = EntityIdHelper.toSolidityAddress(["1", "1", "1"]);
        expect(address).to.eql(addressExpected);
    });

    it("should prove to|fromSolidityAddress are reversible", function () {
        const arrayLong = [new Long(11), new Long(12), new Long(13)];

        const address = EntityIdHelper.fromSolidityAddress(
            EntityIdHelper.toSolidityAddress(arrayLong),
        );

        expect(address).to.eql(arrayLong);
    });

    it("should deserialise ed25519 alias to public key", function () {
        const alias = "CIQBOMQE74WV37E4XU7GJAJJUP727KUVABF7KY2QF5IC5JIEPZUFK3I";
        const publicKey =
            "173204ff2d5dfc9cbd3e648129a3ffafaa95004bf563502f502ea5047e68556d";
        const result = EntityIdHelper.aliasToPublicKey(alias);
        expect(result.toStringRaw()).to.eql(publicKey);
    });

    it("should deserialise ecdsa alias to public key", function () {
        const alias =
            "HIQQHWKEWBU4IMVRHQKA7ZWXRB5MTVOE3VVIZH75H7ASQSIKXUEDCEGU";
        const publicKey =
            "03d944b069c432b13c140fe6d7887ac9d5c4dd6a8c9ffd3fc128490abd083110d4";
        const result = EntityIdHelper.aliasToPublicKey(alias);
        expect(result.toStringRaw()).to.eql(publicKey);
    });

    it("should error on hollow account alias to public key", function () {
        const alias = "ADYQKZW5EGPUZ63YPBMLTEE2I2ATDXAL";
        let errorThrown = false;
        try {
            EntityIdHelper.aliasToPublicKey(alias);
        } catch (_) {
            errorThrown = true;
        }

        expect(errorThrown).to.be.true;
    });

    it("should deserialise alias to evm address", function () {
        const alias = "ADYQKZW5EGPUZ63YPBMLTEE2I2ATDXAL";
        const evmAddress = "0x00f10566dd219f4cfb787858b9909a468131dc0b";
        const result = EntityIdHelper.aliasToEvmAddress(alias);
        expect(result).to.eql(evmAddress);
    });

    it("should serialize ed25519 public key to alias", function () {
        const alias = "CIQBOMQE74WV37E4XU7GJAJJUP727KUVABF7KY2QF5IC5JIEPZUFK3I";
        const publicKey =
            "173204ff2d5dfc9cbd3e648129a3ffafaa95004bf563502f502ea5047e68556d";
        const result = EntityIdHelper.publicKeyToAlias(publicKey);
        expect(result).to.eql(alias);
    });

    it("should serialize ecdsa public key to alias", function () {
        const alias =
            "HIQQHWKEWBU4IMVRHQKA7ZWXRB5MTVOE3VVIZH75H7ASQSIKXUEDCEGU";
        const publicKey =
            "03d944b069c432b13c140fe6d7887ac9d5c4dd6a8c9ffd3fc128490abd083110d4";
        const result = EntityIdHelper.publicKeyToAlias(publicKey);
        expect(result).to.eql(alias);
    });

    it("should serialize hollow account evmAddress key to alias", function () {
        const alias = "ADYQKZW5EGPUZ63YPBMLTEE2I2ATDXAL";
        const evmAddress = "0x00f10566dd219f4cfb787858b9909a468131dc0b";
        const result = EntityIdHelper.publicKeyToAlias(evmAddress);
        expect(result).to.eql(alias);
    });
});
// Filename: test/unit/EthereumFlowMocking.js
import { expect } from "chai";

import * as hex from "../../src/encoding/hex.js";
import * as rlp from "@ethersproject/rlp";
import { proto } from "@hashgraph/proto";
import Mocker from "./Mocker.js";
import { EthereumFlow, FileId } from "../../src/index.js";

const TRANSACTION_RECEIPT_SUCCESS_RESPONSE = {
    transactionGetReceipt: {
        header: {
            nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
        },
        receipt: {
            status: proto.ResponseCodeEnum.SUCCESS,
        },
    },
};

const TRANSACTION_RESPONSE_SUCCESS = {
    nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
};

const bytes = hex.decode(
    "f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792",
);

const callDataFileId = FileId.fromString("0.0.1");

describe("EthereumFlowMocking", function () {
    let client;
    let servers;

    afterEach(function () {
        client.close();
        servers.close();
    });

    it("doesn't truncate ethereum data if it's not long enough", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        expect(
                            transactionBody.ethereumTransaction.ethereumData,
                        ).to.deep.equal(bytes);

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        await (
            await new EthereumFlow().setEthereumData(bytes).execute(client)
        ).getReceipt(client);
    });

    it("errors if ethereum data is not provided", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        expect(
                            transactionBody.ethereumTransaction.ethereumData,
                        ).to.deep.equal(bytes);

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        try {
            await new EthereumFlow().execute(client);
        } catch (error) {
            if (
                !error.message.startsWith(
                    "cannot submit ethereum transaction with no ethereum data",
                )
            ) {
                throw error;
            }
        }
    });

    it("extracts the calldata if it's too large", async function () {
        const decoded = rlp.decode(bytes);
        const longCallData = "0x" + "00".repeat(5121);
        decoded[5] = longCallData;
        const encoded = hex.decode(rlp.encode(decoded));
        decoded[5] = "0x";
        const encodedWithoutCallData = hex.decode(rlp.encode(decoded));

        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileCreate = transactionBody.fileCreate;
                        expect(
                            `0x${fileCreate.contents.toString()}`,
                        ).to.deep.equal(
                            // includes 0x prefix
                            longCallData.substring(0, 4098),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileAppend = transactionBody.fileAppend;
                        expect(fileAppend.contents.toString()).to.deep.equal(
                            longCallData.substring(4098, 8194),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                // Yes, you need 4 receipt responses here. One happens in
                // `FileAppendTransaction.executeAll()` in a loop, and the next
                // is for `TransactionResponse.getReceipt()`
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const ethereumTransaction =
                            transactionBody.ethereumTransaction;
                        expect(ethereumTransaction.ethereumData).to.deep.equal(
                            encodedWithoutCallData,
                        );
                        expect(
                            FileId._fromProtobuf(
                                ethereumTransaction.callData,
                            ).toString(),
                        ).to.equal(callDataFileId.toString());

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        await (
            await new EthereumFlow().setEthereumData(encoded).execute(client)
        ).getReceipt(client);
    });

    it("extracts the calldata if it's too large and try to deploy it by chunks, but thrown", async function () {
        const decoded = rlp.decode(bytes);
        const longCallData = "0x" + "00".repeat(7000);
        decoded[5] = longCallData;
        const encoded = hex.decode(rlp.encode(decoded));
        decoded[5] = "0x";
        const encodedWithoutCallData = hex.decode(rlp.encode(decoded));

        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileCreate = transactionBody.fileCreate;
                        expect(
                            `0x${fileCreate.contents.toString()}`,
                        ).to.deep.equal(
                            // includes 0x prefix
                            longCallData.substring(0, 4098),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileAppend = transactionBody.fileAppend;
                        expect(fileAppend.contents.toString()).to.deep.equal(
                            longCallData.substring(4098, 8194),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileAppend = transactionBody.fileAppend;
                        expect(fileAppend.contents.toString()).to.deep.equal(
                            longCallData.substring(8194, 12290),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                // Yes, you need 4 receipt responses here. One happens in
                // `FileAppendTransaction.executeAll()` in a loop, and the next
                // is for `TransactionResponse.getReceipt()`
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const ethereumTransaction =
                            transactionBody.ethereumTransaction;
                        expect(ethereumTransaction.ethereumData).to.deep.equal(
                            encodedWithoutCallData,
                        );
                        expect(
                            FileId._fromProtobuf(
                                ethereumTransaction.callData,
                            ).toString(),
                        ).to.equal(callDataFileId.toString());

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        let error = null;
        try {
            await new EthereumFlow()
                .setEthereumData(encoded)
                .setMaxChunks(2)
                .execute(client);
        } catch (err) {
            error = err;
        }
        expect(error).to.be.an("Error");
    });

    it("extracts the calldata if it's too large and deploy it by the right amount of chunks", async function () {
        const decoded = rlp.decode(bytes);
        const longCallData = "0x" + "00".repeat(7000);
        decoded[5] = longCallData;
        const encoded = hex.decode(rlp.encode(decoded));
        decoded[5] = "0x";
        const encodedWithoutCallData = hex.decode(rlp.encode(decoded));

        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileCreate = transactionBody.fileCreate;
                        expect(
                            `0x${fileCreate.contents.toString()}`,
                        ).to.deep.equal(
                            // includes 0x prefix
                            longCallData.substring(0, 4098),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileAppend = transactionBody.fileAppend;
                        expect(fileAppend.contents.toString()).to.deep.equal(
                            longCallData.substring(4098, 8194),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const fileAppend = transactionBody.fileAppend;
                        expect(fileAppend.contents.toString()).to.deep.equal(
                            longCallData.substring(8194, 12290),
                        );

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                {
                    response: {
                        transactionGetReceipt: {
                            header: {
                                nodeTransactionPrecheckCode:
                                    proto.ResponseCodeEnum.OK,
                            },
                            receipt: {
                                status: proto.ResponseCodeEnum.SUCCESS,
                                fileID: callDataFileId._toProtobuf(),
                            },
                        },
                    },
                },
                // Yes, you need 4 receipt responses here. One happens in
                // `FileAppendTransaction.executeAll()` in a loop, and the next
                // is for `TransactionResponse.getReceipt()`
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    call: (request) => {
                        const transactionBody = proto.TransactionBody.decode(
                            proto.SignedTransaction.decode(
                                request.signedTransactionBytes,
                            ).bodyBytes,
                        );

                        const ethereumTransaction =
                            transactionBody.ethereumTransaction;
                        expect(ethereumTransaction.ethereumData).to.deep.equal(
                            encodedWithoutCallData,
                        );
                        expect(
                            FileId._fromProtobuf(
                                ethereumTransaction.callData,
                            ).toString(),
                        ).to.equal(callDataFileId.toString());

                        return { response: TRANSACTION_RESPONSE_SUCCESS };
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]));

        await (
            await new EthereumFlow()
                .setEthereumData(encoded)
                .setMaxChunks(3)
                .execute(client)
        ).getReceipt(client);
    });
});
// Filename: test/unit/EthereumTransaction.js
import { expect } from "chai";

import Long from "long";

import * as hex from "../../src/encoding/hex.js";
import {
    EthereumTransaction,
    AccountId,
    Timestamp,
    FileId,
    Transaction,
    TransactionId,
    Hbar,
} from "../../src/index.js";

describe("EthereumTransaction", function () {
    it("toProtobuf with FileId", function () {
        const ethereumData = hex.decode("00112233445566778899");
        const callData = new FileId(1);
        const maxGasAllowance = Hbar.fromTinybars(Long.fromNumber(10));
        const accountId1 = new AccountId(7);
        const nodeAccountId = new AccountId(10, 11, 12);
        const timestamp1 = new Timestamp(14, 15);

        let transaction = new EthereumTransaction()
            .setTransactionId(
                TransactionId.withValidStart(accountId1, timestamp1),
            )
            .setNodeAccountIds([nodeAccountId])
            .setEthereumData(ethereumData)
            .setCallDataFileId(callData)
            .setMaxGasAllowanceHbar(maxGasAllowance)
            .freeze();

        transaction = Transaction.fromBytes(transaction.toBytes());

        const data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            ethereumData,
            callData: callData._toProtobuf(),
            maxGasAllowance: maxGasAllowance.toTinybars(),
        });
    });

    it("toProtobuf with Uint8Array", function () {
        const ethereumData = hex.decode("00112233445566778899");
        const maxGasAllowance = Hbar.fromTinybars(Long.fromNumber(10));
        const accountId1 = new AccountId(7);
        const nodeAccountId = new AccountId(10, 11, 12);
        const timestamp1 = new Timestamp(14, 15);

        let transaction = new EthereumTransaction()
            .setTransactionId(
                TransactionId.withValidStart(accountId1, timestamp1),
            )
            .setNodeAccountIds([nodeAccountId])
            .setEthereumData(ethereumData)
            .setMaxGasAllowanceHbar(maxGasAllowance)
            .freeze();

        transaction = Transaction.fromBytes(transaction.toBytes());

        const data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            ethereumData,
            callData: null,
            maxGasAllowance: maxGasAllowance.toTinybars(),
        });
    });
});
// Filename: test/unit/EthereumTransactionData.js
import { expect } from "chai";

import * as hex from "../../src/encoding/hex.js";
import { EthereumTransactionData } from "../../src/index.js";

const rawTxType0 = hex.decode(
    "f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792",
);

const rawTxType1 = hex.decode(
    "01f85f01010a0a9400000000000000000000000000000000000000010a80c080a038ba8bdbcd8684ff089b8efaf7b5aaf2071a11ab01b6cc65757af79f1199f2efa0570b83f85d578427becab466ced52da857e2a9e48bf9ec5850cc2f541e9305e9",
);

// These byte fail to be decoded by @ethersproject/rlp
// const rawTxType0TrimmedLastBytes =
//                 hex.decode("f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290000");
//
const rawTxType2 = hex.decode(
    "02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66",
);

describe("EthereumTransactionData", function () {
    it("can decode and encode back into original bytes", function () {
        expect(
            EthereumTransactionData.fromBytes(rawTxType0).toBytes(),
        ).to.deep.equal(rawTxType0);
        expect(
            EthereumTransactionData.fromBytes(rawTxType1).toBytes(),
        ).to.deep.equal(rawTxType1);
        expect(
            EthereumTransactionData.fromBytes(rawTxType2).toBytes(),
        ).to.deep.equal(rawTxType2);
    });
});
// Filename: test/unit/ExchangeRate.js
import "mocha";
import { ExchangeRate } from "../../src/index.js";

describe("ExchangeRate", function () {
    it("fromBytes", function () {
        const date = new Date("February 24, 2022 15:00:00 UTC");
        const exchangeRate = ExchangeRate._fromProtobuf(
            new ExchangeRate({
                expirationTime: date,
            })._toProtobuf(),
        );

        expect(exchangeRate.expirationTime.toString()).to.be.equal(
            date.toString(),
        );
    });
});
// Filename: test/unit/Executable.js
import { RST_STREAM } from "../../src/Executable.js";

describe("Executable", function () {
    it("RST_STREAM regex matches actual response returned", function () {
        expect(
            RST_STREAM.test(
                "Error: 13 INTERNAL: Received RST_STREAM with code 0",
            ),
        ).to.be.true;
    });
});
// Filename: test/unit/FeeDataType.js
import * as HieroProto from "@hashgraph/proto";
import { FeeDataType } from "../../src/exports.js";

describe("FeeDataType", function () {
    it("has all variants", function () {
        for (const [s, code] of Object.entries(HieroProto.proto.SubType)) {
            expect(FeeDataType._fromCode(code).toString()).to.be.equal(s);
        }
    });
});
// Filename: test/unit/FileAppendMocking.js
import { FileAppendTransaction } from "../../src/index.js";
import Mocker, {
    UNAVAILABLE,
    TRANSACTION_RECEIPT_SUCCESS_RESPONSE,
    TRANSACTION_RECEIPT_FAILED_RESPONSE,
} from "./Mocker.js";
import { bigContents } from "../integration/contents.js";
import { proto } from "@hashgraph/proto";

describe("FileAppendMocking", function () {
    it("works", async function () {
        const { client, servers } = await Mocker.withResponses([
            [
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_SUCCESS_RESPONSE },
            ],
        ]);

        const transaction = new FileAppendTransaction()
            // Default changed to 4096
            .setChunkSize(2048)
            .setFileId("0.0.3")
            .setContents(bigContents)
            .freezeWith(client);

        const responses = await transaction.executeAll(client);

        expect(responses[0].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[0].toString(),
        );
        expect(responses[1].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[1].toString(),
        );
        expect(responses[2].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[2].toString(),
        );
        expect(responses[3].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[3].toString(),
        );
        expect(responses[4].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[4].toString(),
        );
        expect(responses[5].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[5].toString(),
        );
        expect(responses[6].transactionId.toString()).to.be.equal(
            transaction._transactionIds.list[6].toString(),
        );

        servers.close();
    });

    it("fails if any inner transaction fails", async function () {
        const { client, servers } = await Mocker.withResponses([
            [
                {
                    response: {
                        nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
                    },
                },
                { response: TRANSACTION_RECEIPT_FAILED_RESPONSE },
            ],
        ]);

        let err = false;

        try {
            await new FileAppendTransaction()
                // Default changed to 4096
                .setChunkSize(2048)
                .setFileId("0.0.3")
                .setContents(bigContents)
                .execute(client);
        } catch (error) {
            err = error.toString().includes("INVALID_FILE_ID");
        }

        if (!err) {
            throw new Error("did not error");
        }

        servers.close();
    });

    it("errors with max retries in case of BUSY precheck", async function () {
        const { client, servers } = await Mocker.withResponses([
            [
                {
                    response: {
                        nodeTransactionPrecheckCode:
                            proto.ResponseCodeEnum.BUSY,
                    },
                },
            ],
        ]);

        try {
            await new FileAppendTransaction()
                // Default changed to 4096
                .setChunkSize(2048)
                .setContents("a")
                .setMaxAttempts(1)
                .execute(client);
        } catch (error) {
            if (
                error.message !==
                "max attempts of 1 was reached for request with last error being: BUSY"
            ) {
                throw error;
            }
        }

        servers.close();
    });

    it("errors with max retries in case of UNAVAILABLE grpc status", async function () {
        const { client, servers } = await Mocker.withResponses([
            [{ error: UNAVAILABLE }],
        ]);

        try {
            await new FileAppendTransaction()
                // Default changed to 4096
                .setChunkSize(2048)
                .setContents("a")
                .setMaxAttempts(1)
                .execute(client);
        } catch (error) {
            if (
                error.message !==
                "max attempts of 1 was reached for request with last error being: GrpcServiceError: gRPC service failed with: Status: UNAVAILABLE, Code: 14: node is UNAVAILABLE"
            ) {
                throw error;
            }
        }

        servers.close();
    });
});
// Filename: test/unit/FileAppendTransaction.js
import { expect } from "chai";

import {
    FileAppendTransaction,
    AccountId,
    Timestamp,
    Hbar,
    TransactionId,
    FileId,
} from "../../src/index.js";
import Long from "long";

describe("FileAppendTransaction", function () {
    const spenderAccountId1 = new AccountId(7);
    const fileId = new FileId(8);
    const nodeAccountId = new AccountId(10, 11, 12);
    const timestamp1 = new Timestamp(14, 15);
    const fee = new Hbar(5);
    const chunkSize = 1000;
    const smallContent = "abcdef";

    it("setChunkSize()", function () {
        const bigContent =
            "1".repeat(1000) + "2".repeat(1000) + "3".repeat(1000);

        let transaction = new FileAppendTransaction()
            .setTransactionId(
                TransactionId.withValidStart(spenderAccountId1, timestamp1),
            )
            .setNodeAccountIds([nodeAccountId])
            .setFileId(fileId)
            .setChunkSize(chunkSize)
            .setContents(bigContent)
            .freeze();

        const transactionId = transaction.transactionId;

        expect(transaction._transactionIds.list.length).to.be.equal(3);
        expect(transaction._nodeAccountIds.list.length).to.be.equal(1);
        expect(transaction.chunkSize).to.be.equal(chunkSize);
        expect(transaction.contents.toString()).to.be.equal(bigContent);
        expect(transaction.fileId).to.be.deep.equal(fileId);

        let body = transaction._makeTransactionBody(nodeAccountId);

        expect(body.transactionID).to.deep.equal(transactionId._toProtobuf());

        expect(body.transactionFee).to.deep.equal(fee.toTinybars());
        expect(body.memo).to.be.equal("");
        expect(body.transactionID).to.deep.equal(
            transaction._transactionIds.list[0]._toProtobuf(),
        );
        expect(body.nodeAccountID).to.deep.equal(nodeAccountId._toProtobuf());
        expect(body.transactionValidDuration).to.deep.equal({
            seconds: Long.fromNumber(120),
        });
        expect(body.fileAppend.fileID).to.deep.equal(fileId._toProtobuf());
        expect(body.fileAppend.contents.length).to.be.equal(1000);
        expect(body.fileAppend.contents[0]).to.be.equal(49);

        transaction._transactionIds.advance();
        body = transaction._makeTransactionBody(nodeAccountId);

        expect(body.transactionFee).to.deep.equal(fee.toTinybars());
        expect(body.memo).to.be.equal("");
        expect(body.transactionID).to.deep.equal(
            transaction._transactionIds.list[1]._toProtobuf(),
        );
        expect(body.nodeAccountID).to.deep.equal(nodeAccountId._toProtobuf());
        expect(body.transactionValidDuration).to.deep.equal({
            seconds: Long.fromNumber(120),
        });
        expect(body.fileAppend.fileID).to.deep.equal(fileId._toProtobuf());
        expect(body.fileAppend.contents.length).to.be.equal(1000);
        expect(body.fileAppend.contents[0]).to.be.equal(50);

        transaction._transactionIds.advance();
        body = transaction._makeTransactionBody(nodeAccountId);

        expect(body.transactionFee).to.deep.equal(fee.toTinybars());
        expect(body.memo).to.be.equal("");
        expect(body.transactionID).to.deep.equal(
            transaction._transactionIds.list[2]._toProtobuf(),
        );
        expect(body.nodeAccountID).to.deep.equal(nodeAccountId._toProtobuf());
        expect(body.transactionValidDuration).to.deep.equal({
            seconds: Long.fromNumber(120),
        });
        expect(body.fileAppend.fileID).to.deep.equal(fileId._toProtobuf());
        expect(body.fileAppend.contents.length).to.be.equal(1000);
        expect(body.fileAppend.contents[0]).to.be.equal(51);
    });

    it("setChunkInterval()", function () {
        const contents = "1".repeat(1000) + "2".repeat(1000) + "3".repeat(1000);
        const chunkInterval = 200;

        let transaction = new FileAppendTransaction()
            .setTransactionId(
                TransactionId.withValidStart(spenderAccountId1, timestamp1),
            )
            .setNodeAccountIds([nodeAccountId])
            .setFileId(fileId)
            .setChunkSize(chunkSize)
            .setContents(contents)
            .setChunkInterval(chunkInterval)
            .freeze();

        expect(transaction._transactionIds.list.length).to.be.equal(3);
        const requiredChunks = contents.length / chunkSize;

        let body = transaction._makeTransactionBody(nodeAccountId);

        expect(body.transactionID).to.deep.equal(
            transaction._transactionIds.list[0]._toProtobuf(),
        );

        for (let i = 1; i < requiredChunks; i++) {
            transaction._transactionIds.advance();
            body = transaction._makeTransactionBody(nodeAccountId);
            expect(body.transactionID).to.deep.equal(
                transaction._transactionIds.list[i]._toProtobuf(),
            );

            expect(
                transaction._transactionIds.list[i].validStart.nanos.sub(
                    transaction._transactionIds.list[i - 1].validStart.nanos,
                ),
            ).to.deep.equal(Long.fromNumber(chunkInterval));
        }

        expect(
            transaction._transactionIds.list[
                requiredChunks - 1
            ].validStart.nanos.sub(
                transaction._transactionIds.list[0].validStart.nanos,
            ),
        ).to.deep.equal(Long.fromNumber(chunkInterval * (requiredChunks - 1)));
    });

    it("should not be able to build transaction with more chunks than maxRequiredChunks", function () {
        let transaction = new FileAppendTransaction()
            .setContents(smallContent)
            .setChunkSize(1)
            .setMaxChunks(smallContent.length - 1);

        expect(() => {
            transaction.toBytes();
        }).to.throw(
            `cannot build \`FileAppendTransaction\` with more than ${
                smallContent.length - 1
            } chunks`,
        );
    });

    it("should not be able to build all signed transaction with more than allowed chunks", async function () {
        const transaction = new FileAppendTransaction()
            .setNodeAccountIds([new AccountId(3)])
            .setTransactionId(TransactionId.generate(new AccountId(1)))
            .setContents(smallContent)
            .setChunkSize(1)
            .setMaxChunks(smallContent.length - 1)
            .freeze();

        expect(() => {
            transaction.toBytes();
        }).to.throw(
            `cannot build \`FileAppendTransaction\` with more than ${
                smallContent.length - 1
            } chunks`,
        );
    });

    it("should be able to build all signed transaction", async function () {
        const transaction = new FileAppendTransaction()
            .setNodeAccountIds([new AccountId(3)])
            .setTransactionId(TransactionId.generate(new AccountId(1)))
            .setContents(smallContent)
            .setChunkSize(1)
            .freeze();

        expect(transaction.isFrozen()).to.be.true;

        // calling toBytes will sign all transactions
        transaction.toBytes();

        expect(transaction._transactions.length).to.equal(smallContent.length);
        expect(transaction._signedTransactions.length).to.equal(
            smallContent.length,
        );
    });

    it("should set maxChunk if set in constructor", function () {
        const maxChunks = 10;
        const tx = new FileAppendTransaction({ maxChunks });
        expect(tx.maxChunks).to.equal(maxChunks);
    });

    it("should set chunkSize if set in constructor", function () {
        const chunkSize = 10;
        const tx = new FileAppendTransaction({ chunkSize });
        expect(tx.chunkSize).to.equal(chunkSize);
    });

    it("should not be able to set scheduled message with bigger content than chunkSize", async function () {
        const tx = new FileAppendTransaction()
            .setContents(smallContent)
            .setChunkSize(1);

        expect(() => {
            tx.schedule();
        }).to.throw(
            `cannot schedule \`FileAppendTransaction\` with message over ${tx.chunkSize} bytes`,
        );
    });
});
// Filename: test/unit/FileUpdateTransaction.js
import { FileUpdateTransaction } from "../../src/index.js";

describe("FileUpdateTransaction", function () {
    describe("deserialization of optional parameters", function () {
        it("should deserialize with fileMemo being null", function () {
            const tx = new FileUpdateTransaction();
            const tx2 = FileUpdateTransaction.fromBytes(tx.toBytes());

            expect(tx.fileMemo).to.be.null;
            expect(tx2.fileMemo).to.be.null;
        });
    });
});
// Filename: test/unit/FreezeTransaction.js
import { expect } from "chai";

import { FreezeTransaction, Timestamp, FreezeType } from "../../src/index.js";

describe("FreezeTransaction", function () {
    it("create transaction and set ", function () {
        const seconds = Math.round(Date.now() / 1000);
        const validStart = new Timestamp(seconds, 0);
        const freezeType = new FreezeType(1);

        const transaction = new FreezeTransaction()
            .setStartTimestamp(validStart)
            .setFreezeType(freezeType);

        expect(transaction).to.be.instanceof(FreezeTransaction);
        expect(transaction.startTimestamp).to.be.equal(validStart);
        expect(transaction.freezeType).to.be.instanceof(FreezeType);
        expect(transaction.freezeType.toString()).to.be.equal(
            freezeType.toString(),
        );
    });
});
// Filename: test/unit/Hbar.js
import { expect } from "chai";

import { Hbar, HbarUnit } from "../../src/index.js";

describe("Hbar", function () {
    it("should pass regex, convert, and reverse [to|from]String", function () {
        let check = [
            ["0 ℏ", "0 tℏ"],
            ["1 tℏ", "1 tℏ"],
            ["1 μℏ", "100 tℏ"],
            ["1 mℏ", "0.001 ℏ"],
            ["1 ℏ", "1 ℏ"],
            ["1 kℏ", "1000 ℏ"],
            ["1 Mℏ", "1000000 ℏ"],
            ["1 Gℏ", "1000000000 ℏ"],

            ["+0 ℏ", "0 tℏ"],
            ["+1 tℏ", "1 tℏ"],
            ["+1 μℏ", "100 tℏ"],
            ["+1 mℏ", "0.001 ℏ"],
            ["+1 ℏ", "1 ℏ"],
            ["+1 kℏ", "1000 ℏ"],
            ["+1 Mℏ", "1000000 ℏ"],
            ["+1 Gℏ", "1000000000 ℏ"],

            ["-0 ℏ", "0 tℏ"],
            ["-1 tℏ", "-1 tℏ"],
            ["-1 μℏ", "-100 tℏ"],
            ["-1 mℏ", "-0.001 ℏ"],
            ["-1 ℏ", "-1 ℏ"],
            ["-1 kℏ", "-1000 ℏ"],
            ["-1 Mℏ", "-1000000 ℏ"],
            ["-1 Gℏ", "-1000000000 ℏ"],
        ];

        check.forEach((element) => {
            expect(element[1]).to.equal(Hbar.fromString(element[0]).toString());
        });
    });

    it("should not pass regex", function () {
        let check = [
            "1 ",
            "-1 ",
            "+1 ",
            "1.151 ",
            "-1.151 ",
            "+1.151 ",
            "1.",
            "1.151.",
            ".1",
            "1.151 uℏ",
            "1.151 h",
        ];

        check.forEach((element) => {
            try {
                Hbar.fromString(element);
                throw new Error();
            } catch (error) {
                let result = error
                    .toString()
                    .includes("invalid argument provided");
                if (!result) {
                    throw new Error(
                        "Expected Hbar.fromString(" +
                            element +
                            ") to throw an error.",
                    );
                }
                expect(result).to.be.true;
            }
        });
    });

    it("should append default unit Hbar", function () {
        /**
         * fromString strips + and should append the default Hbar unit when none are present
         */
        const unit = HbarUnit.Hbar._symbol;
        let check = ["1", "-1", "+1", "1.151", "-1.151", "+1.151"];

        check.forEach((element) => {
            expect(element.replace("+", "") + " " + unit).to.equal(
                Hbar.fromString(element).toString(),
            );
        });
    });

    it('should throw error "Hbar in tinybars contains decimals"', function () {
        let check = ["1.151 tℏ", "1.151 μℏ", "1.151", "-1.151", "+1.151"];

        check.forEach((element) => {
            try {
                Hbar.fromString(element);
            } catch (error) {
                expect(
                    error
                        .toString()
                        .includes("Hbar in tinybars contains decimals"),
                ).to.equal(true);
            }
        });
    });
});
// Filename: test/unit/HbarAllowance.js
import { expect } from "chai";

import { HbarAllowance, AccountId, Hbar } from "../../src/index.js";

describe("HbarAllowance", function () {
    it("toProtobuf()", function () {
        const ownerAccountId = new AccountId(3);
        const spenderAccountId = new AccountId(4);
        const hbarAmount = Hbar.fromTinybars(100);

        const allowance = new HbarAllowance({
            ownerAccountId,
            spenderAccountId,
            amount: hbarAmount,
        });

        expect(allowance._toProtobuf()).to.deep.equal({
            owner: ownerAccountId._toProtobuf(),
            spender: spenderAccountId._toProtobuf(),
            amount: hbarAmount.toTinybars(),
        });
    });
});
// Filename: test/unit/LedgerId.js
import { expect } from "chai";

import { LedgerId } from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";

const MAINNET = "mainnet";
const HEX_MAINNET = hex.encode(new Uint8Array([0]));

const TESTNET = "testnet";
const HEX_TESTNET = hex.encode(new Uint8Array([1]));

const PREVIEWNET = "previewnet";
const HEX_PREVIEWNET = hex.encode(new Uint8Array([2]));

const LOCAL_NODE = "local-node";
const HEX_LOCAL_NODE = hex.encode(new Uint8Array([3]));

const OTHER = "other";
const HEX_OTHER = hex.encode(new Uint8Array([4]));

describe("LedgerId", function () {
    function assertIsLocalNode(ledgerId) {
        // A local node LedgerId stringifies itself with its human-readable name
        expect(ledgerId.toString()).to.eql(LOCAL_NODE);
        // A local node LedgerId self-classifies correctly
        expect(ledgerId.isMainnet()).to.eql(false);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);
        expect(ledgerId.isLocalNode()).to.eql(true);
    }

    it("fromString() given human-readable name behaves as expected", function () {
        const localNodeId = LedgerId.fromString(LOCAL_NODE);
        assertIsLocalNode(localNodeId);
    });

    it("fromString() given hexed form behaves as expected", function () {
        const localNodeId = LedgerId.fromString(HEX_LOCAL_NODE);
        assertIsLocalNode(localNodeId);
    });

    it('fromString returns LedgerId from strings/hex "mainnet", "testnet", "previewnet"', function () {
        expect(LedgerId.fromString(MAINNET).toString()).to.eql(MAINNET);
        expect(LedgerId.fromString(MAINNET).isMainnet()).to.eql(true);
        expect(LedgerId.fromString(MAINNET).isTestnet()).to.eql(false);
        expect(LedgerId.fromString(MAINNET).isPreviewnet()).to.eql(false);
        expect(LedgerId.fromString(MAINNET).isLocalNode()).to.eql(false);

        expect(LedgerId.fromString(HEX_MAINNET).toString()).to.eql(MAINNET);
        expect(LedgerId.fromString(HEX_MAINNET).isMainnet()).to.eql(true);
        expect(LedgerId.fromString(HEX_MAINNET).isTestnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_MAINNET).isPreviewnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_MAINNET).isLocalNode()).to.eql(false);

        expect(LedgerId.fromString(TESTNET).toString()).to.eql(TESTNET);
        expect(LedgerId.fromString(TESTNET).isMainnet()).to.eql(false);
        expect(LedgerId.fromString(TESTNET).isTestnet()).to.eql(true);
        expect(LedgerId.fromString(TESTNET).isPreviewnet()).to.eql(false);

        expect(LedgerId.fromString(HEX_TESTNET).toString()).to.eql(TESTNET);
        expect(LedgerId.fromString(HEX_TESTNET).isMainnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_TESTNET).isTestnet()).to.eql(true);
        expect(LedgerId.fromString(HEX_TESTNET).isPreviewnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_TESTNET).isLocalNode()).to.eql(false);

        expect(LedgerId.fromString(PREVIEWNET).toString()).to.eql(PREVIEWNET);
        expect(LedgerId.fromString(PREVIEWNET).isMainnet()).to.eql(false);
        expect(LedgerId.fromString(PREVIEWNET).isTestnet()).to.eql(false);
        expect(LedgerId.fromString(PREVIEWNET).isPreviewnet()).to.eql(true);
        expect(LedgerId.fromString(PREVIEWNET).isLocalNode()).to.eql(false);

        expect(LedgerId.fromString(HEX_PREVIEWNET).toString()).to.eql(
            PREVIEWNET,
        );
        expect(LedgerId.fromString(HEX_PREVIEWNET).isMainnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_PREVIEWNET).isTestnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_PREVIEWNET).isPreviewnet()).to.eql(true);
        expect(LedgerId.fromString(HEX_PREVIEWNET).isLocalNode()).to.eql(false);

        try {
            LedgerId.fromString(OTHER);
        } catch (error) {
            expect(error.message).to.eql("Default reached for fromString");
        }

        expect(LedgerId.fromString(HEX_OTHER).toString()).to.eql("04");
        expect(LedgerId.fromString(HEX_OTHER).isMainnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_OTHER).isTestnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_OTHER).isPreviewnet()).to.eql(false);
        expect(LedgerId.fromString(HEX_OTHER).isLocalNode()).to.eql(false);
    });

    it("isMainnet|Testnet|Previewnet|Other returns boolean", function () {
        let ledgerId = LedgerId.fromString("0");
        expect(ledgerId.isMainnet()).to.eql(true);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);
        ledgerId = LedgerId.fromString(MAINNET);
        expect(ledgerId.isMainnet()).to.eql(true);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);
        ledgerId = LedgerId.fromBytes(new Uint8Array([0]));
        expect(ledgerId.isMainnet()).to.eql(true);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);

        ledgerId = LedgerId.fromString("1");
        expect(ledgerId.isTestnet()).to.eql(true);
        expect(ledgerId.isMainnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);
        ledgerId = LedgerId.fromString(TESTNET);
        expect(ledgerId.isTestnet()).to.eql(true);
        expect(ledgerId.isMainnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);
        ledgerId = LedgerId.fromBytes(new Uint8Array([1]));
        expect(ledgerId.isTestnet()).to.eql(true);
        expect(ledgerId.isMainnet()).to.eql(false);
        expect(ledgerId.isPreviewnet()).to.eql(false);

        ledgerId = LedgerId.fromString("2");
        expect(ledgerId.isPreviewnet()).to.eql(true);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isMainnet()).to.eql(false);
        ledgerId = LedgerId.fromString(PREVIEWNET);
        expect(ledgerId.isPreviewnet()).to.eql(true);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isMainnet()).to.eql(false);
        ledgerId = LedgerId.fromBytes(new Uint8Array([2]));
        expect(ledgerId.isPreviewnet()).to.eql(true);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isMainnet()).to.eql(false);

        ledgerId = LedgerId.fromBytes(new Uint8Array([4]));
        expect(ledgerId.isPreviewnet()).to.eql(false);
        expect(ledgerId.isTestnet()).to.eql(false);
        expect(ledgerId.isMainnet()).to.eql(false);
    });
});
// Filename: test/unit/LoggerTest.js
import { Logger, LogLevel, Transaction } from "../../src/exports.js";
import { Client } from "../../src/index.js";
import { tmpdir } from "node:os";
import fs from "fs";
import { spy } from "sinon";

describe("Logger", function () {
    it("set and get log level correctly inside the `Client` object", async function () {
        const client = Client.forPreviewnet({
            scheduleNetworkUpdate: false,
        });

        //during initialization of the `Client`, there is no logger set
        expect(client.logger).to.be.null;

        //set logger with info level of logging to the `Client`
        let infoLogger = new Logger(LogLevel.Info);
        client.setLogger(infoLogger);

        //check if the log level is in fact `info`
        expect(client.logger.level).to.be.equal(LogLevel.Info);

        //change the level of the logger to `warn` and check
        //if it is the same when extracted from the `Client`
        infoLogger.setLevel(LogLevel.Warn);
        expect(client.logger.level).to.be.equal(LogLevel.Warn);

        //silence the logger and check if it changed inside the `Client`
        infoLogger.setSilent(true);
        expect(client.logger.level).to.be.equal(LogLevel.Silent);
    });

    it("set and get log level correctly inside the `Transaction` object", async function () {
        const transaction = new Transaction();

        //during initialization of the `Transaction`, there is no logger set
        expect(transaction.logger).to.be.null;

        //set logger with info level of logging to the `Transaction`
        let infoLogger = new Logger(LogLevel.Info);
        transaction.setLogger(infoLogger);

        //check if the log level is in fact `info`
        expect(transaction.logger.level).to.be.equal(LogLevel.Info);

        //change the level of the logger to `warn` and check
        //if it is the same when extracted from the `Transaction`
        infoLogger.setLevel(LogLevel.Warn);
        expect(transaction.logger.level).to.be.equal(LogLevel.Warn);

        //silence the logger and check if it changed inside the `Transaction`
        infoLogger.setSilent(true);
        expect(transaction.logger.level).to.be.equal(LogLevel.Silent);
    });

    it("check the possible log levels on the logger", async function () {
        const transaction = new Transaction();
        //during initialization of the `Transaction`, there is no logger set
        expect(transaction.logger).to.be.null;

        //set logger with info level of logging to the `Transaction`
        const infoLogger = new Logger(LogLevel.Info);
        const levels = Object.values(infoLogger.levels);

        expect(levels).to.include("trace");
        expect(levels).to.include("debug");
        expect(levels).to.include("info");
        expect(levels).to.include("warn");
        expect(levels).to.include("error");
        expect(levels).to.include("fatal");
    });

    it("check that it can write to a log file", function () {
        const logFile = `${tmpdir()}/test.log`;
        fs.rmSync(logFile, { force: true });
        const logger = new Logger(LogLevel.Trace, logFile);
        let assertionCount = 0;
        for (const level of Object.values(LogLevel)) {
            if (level === LogLevel.Silent) continue;
            logger[level](`This is a test ${level} message`);

            const logContent = fs.readFileSync(logFile, "utf8");
            expect(logContent).to.contain(`This is a test ${level} message`);
            expect(logContent).to.contain(
                level.toString().toUpperCase(),
                `should contain ${level.toString().toUpperCase()}`,
            );
            assertionCount += 2;
        }
        expect(assertionCount).to.be.equal(
            12,
            "should have made 12 assertions",
        );
    });

    it("check that it can write to stdout", function () {
        let assertionCount = 0;
        const logger = new Logger(LogLevel.Trace);
        for (const level of Object.values(LogLevel)) {
            if (level === LogLevel.Silent) continue;
            const loggerLogSpy = spy(logger._logger, level);
            logger[level](`This is a test ${level} message`);
            expect(loggerLogSpy.calledWith(`This is a test ${level} message`))
                .to.be.true;
            assertionCount++;
        }
        expect(assertionCount).to.be.equal(6, "should have made 6 assertions");
    });

    it("check that silent blocks output", function () {
        const logFile = `${tmpdir()}/test2.log`;
        fs.rmSync(logFile, { force: true });
        const logger = new Logger(LogLevel.Trace, logFile);
        expect(logger.silent).to.be.equal(false);
        logger.warn("This is a test warn message");
        logger.setSilent(true);
        expect(logger.silent).to.be.equal(true);
        logger.fatal("This is a test fatal message");
        logger.setSilent(false);
        logger.error("This is a test error message");
        const logContent = fs.readFileSync(logFile, "utf8");
        expect(logger.silent).to.be.equal(false);
        expect(logContent).to.contain("This is a test warn message");
        expect(logContent).to.contain("This is a test error message");
        expect(logContent).to.not.contain("This is a test fatal message");
    });
});
// Filename: test/unit/ManagedNodeAddress.js
import ManagedNodeAddress from "../../src/ManagedNodeAddress.js";

describe("ManagedNodeAddress", function () {
    it("fromString", function () {
        const ipAddress = ManagedNodeAddress.fromString("35.237.200.180:50211");
        expect(ipAddress.address).to.be.equal("35.237.200.180");
        expect(ipAddress.port).to.be.equal(50211);
        expect(ipAddress.toString()).to.be.equal("35.237.200.180:50211");

        const ipAddressSecure = ipAddress.toSecure();
        expect(ipAddressSecure.address).to.be.equal("35.237.200.180");
        expect(ipAddressSecure.port).to.be.equal(50212);
        expect(ipAddressSecure.toString()).to.be.equal("35.237.200.180:50212");

        const ipAddressInsecure = ipAddressSecure.toInsecure();
        expect(ipAddressInsecure.address).to.be.equal("35.237.200.180");
        expect(ipAddressInsecure.port).to.be.equal(50211);
        expect(ipAddressInsecure.toString()).to.be.equal(
            "35.237.200.180:50211",
        );

        const urlAddress = ManagedNodeAddress.fromString(
            "0.testnet.hedera.com:50211",
        );
        expect(urlAddress.address).to.be.equal("0.testnet.hedera.com");
        expect(urlAddress.port).to.be.equal(50211);
        expect(urlAddress.toString()).to.be.equal("0.testnet.hedera.com:50211");

        const urlAddressSecure = urlAddress.toSecure();
        expect(urlAddressSecure.address).to.be.equal("0.testnet.hedera.com");
        expect(urlAddressSecure.port).to.be.equal(50212);
        expect(urlAddressSecure.toString()).to.be.equal(
            "0.testnet.hedera.com:50212",
        );

        const urlAddressInsecure = urlAddressSecure.toInsecure();
        expect(urlAddressInsecure.address).to.be.equal("0.testnet.hedera.com");
        expect(urlAddressInsecure.port).to.be.equal(50211);
        expect(urlAddressInsecure.toString()).to.be.equal(
            "0.testnet.hedera.com:50211",
        );

        const mirrorNodeAddress = ManagedNodeAddress.fromString(
            "testnet.mirrornode.hedera.com:443",
        );
        expect(mirrorNodeAddress.address).to.be.equal(
            "testnet.mirrornode.hedera.com",
        );
        expect(mirrorNodeAddress.port).to.be.equal(443);
        expect(mirrorNodeAddress.toString()).to.be.equal(
            "testnet.mirrornode.hedera.com:443",
        );

        const mirrorNodeAddressSecure = mirrorNodeAddress.toSecure();
        expect(mirrorNodeAddressSecure.address).to.be.equal(
            "testnet.mirrornode.hedera.com",
        );
        expect(mirrorNodeAddressSecure.port).to.be.equal(443);
        expect(mirrorNodeAddressSecure.toString()).to.be.equal(
            "testnet.mirrornode.hedera.com:443",
        );

        let err = false;
        try {
            ManagedNodeAddress.fromString(
                "this is a random string with spaces:443",
            );
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("fromString did not error");
        }

        err = false;
        try {
            ManagedNodeAddress.fromString(
                "mainnet-public.mirrornode.hedera.com:notarealport",
            );
        } catch {
            err = true;
        }

        if (!err) {
            throw new Error("fromString did not error");
        }
    });
});
// Filename: test/unit/MaxAttemptsOrTimeoutError.js
import {
    AccountId,
    TransferTransaction,
    Hbar,
    MaxAttemptsOrTimeoutError,
} from "../../src/index.js";
import Mocker from "./Mocker.js";

describe("MaxAttemptsOrTimeoutError", function () {
    let message;
    let nodeAccountId;
    let error;

    beforeEach(function () {
        message = "Test error message";
        nodeAccountId = "0.0.3";

        error = new MaxAttemptsOrTimeoutError(message, nodeAccountId);
    });

    it("should create an instance with correct properties", function () {
        expect(error).to.be.instanceOf(MaxAttemptsOrTimeoutError);
        expect(error.message).to.be.equal(message);
        expect(error.nodeAccountId).to.be.equal(nodeAccountId);
    });

    it("toJSON should return correct JSON representation", function () {
        const expectedJson = {
            message,
            nodeAccountId,
        };

        expect(error.toJSON()).to.be.deep.equal(expectedJson);
    });

    it("toString should return a JSON string", function () {
        const expectedString = JSON.stringify({
            message,
            nodeAccountId,
        });

        expect(error.toString()).to.be.equal(expectedString);
    });

    it("valueOf should return the same result as toJSON", function () {
        expect(error.valueOf()).to.be.deep.equal(error.toJSON());
    });

    describe("Transaction execution errors", function () {
        let client, transaction;

        beforeEach(async function () {
            const setup = await Mocker.withResponses([]);
            client = setup.client;
            transaction = new TransferTransaction()
                .addHbarTransfer("0.0.2", new Hbar(1))
                .setNodeAccountIds([new AccountId(5)]);
        });

        it("should throw a timeout error when the timeout exceeds", async function () {
            // Set the client's request timeout to 0 for testing
            client.setRequestTimeout(0);
            transaction = transaction.freezeWith(client);

            try {
                await transaction.execute(client);
                throw new Error("Expected request to time out but it didn't.");
            } catch (error) {
                expect(error.message).to.include("timeout exceeded");
                expect(error.nodeAccountId).to.equal("0.0.5");
            }
        });

        it("should throw a max attempts error when max attempts is reached", async function () {
            // Set the transaction's max attempts to 0 for testing
            transaction = transaction.setMaxAttempts(0).freezeWith(client);

            try {
                await transaction.execute(client);
                throw new Error(
                    "Expected request to fail due to max attempts being reached.",
                );
            } catch (error) {
                expect(error.message).to.include(
                    "max attempts of 0 was reached for request with last error being:",
                );
                expect(error.nodeAccountId).to.equal("0.0.5");
            }
        });
    });
});
// Filename: test/unit/MirrorNodeContractCallQuery.js
import { AccountId, MirrorNodeContractCallQuery } from "../../src/exports.js";

describe("MirrorNodeContractCallQuery", function () {
    const SENDER = new AccountId(1);
    const CONTRACT_ID = new AccountId(1);
    const VALUE = 100;
    const GAS_LIMIT = 100;
    const GAS_PRICE = 100;
    const BLOCK_NUMBER = 100;

    it("should throw an error without calldata", async function () {
        const query = new MirrorNodeContractCallQuery()
            .setBlockNumber(BLOCK_NUMBER)
            .setSender(SENDER)
            .setValue(VALUE)
            .setGasLimit(GAS_LIMIT)
            .setGasPrice(GAS_PRICE)
            .setContractId(CONTRACT_ID);

        let err = false;
        try {
            await query.execute();
        } catch (e) {
            err = e.message.includes("Call data is required.");
        }
        expect(err).to.equal(true);
    });
});
// Filename: test/unit/MirrorNodeContractEstimateQuery.js
import {
    AccountId,
    MirrorNodeContractEstimateQuery,
} from "../../src/exports.js";

describe("MirrorNodeContractCallQuery", function () {
    const SENDER = new AccountId(1);
    const CONTRACT_ID = new AccountId(1);
    const VALUE = 100;
    const GAS_LIMIT = 100;
    const GAS_PRICE = 100;
    const BLOCK_NUMBER = 100;

    it("should throw an error without calldata", async function () {
        const query = new MirrorNodeContractEstimateQuery()
            .setBlockNumber(BLOCK_NUMBER)
            .setSender(SENDER)
            .setValue(VALUE)
            .setGasLimit(GAS_LIMIT)
            .setGasPrice(GAS_PRICE)
            .setContractId(CONTRACT_ID);

        let err = false;
        try {
            await query.execute();
        } catch (e) {
            err = e.message.includes("Call data is required.");
        }
        expect(err).to.equal(true);
    });
});
// Filename: test/unit/MirrorNodeContractQuery.js
import { AccountId } from "../../src/exports.js";
import MirrorNodeContractQuery from "../../src/query/MirrorNodeContractQuery.js";

describe("MirrorNodeContractQuery", function () {
    const SENDER = new AccountId(1);
    const SENDER_EVM_ADDRESS = "0000000000000000000000000000000000000001";
    const CONTRACT_EVM_ADDRESS = "0000000000000000000000000000000000000001";
    const CONTRACT_ID = new AccountId(1);
    const FUNCTION_NAME = "getMessage";
    const FUNCTION_SELECTOR = new Uint8Array([206, 109, 65, 222]); // getMessage()
    const VALUE = 100;
    const GAS_LIMIT = 100;
    const GAS_PRICE = 100;
    const BLOCK_NUMBER = 100;

    it("should set query parameters", function () {
        const query = new MirrorNodeContractQuery()
            .setBlockNumber(BLOCK_NUMBER)
            .setSender(SENDER)
            .setFunction(FUNCTION_NAME)
            .setValue(VALUE)
            .setGasLimit(GAS_LIMIT)
            .setGasPrice(GAS_PRICE)
            .setContractId(CONTRACT_ID);

        expect(query.sender).to.be.instanceOf(AccountId);
        expect(query.senderEvmAddress).to.be.equal(SENDER_EVM_ADDRESS);
        expect(query.contractEvmAddress).to.be.equal(CONTRACT_EVM_ADDRESS);
        expect(query.callData).to.be.deep.equal(FUNCTION_SELECTOR);
        expect(query.value).to.be.equal(VALUE);
        expect(query.gasLimit).to.be.equal(GAS_LIMIT);
        expect(query.gasPrice).to.be.equal(GAS_PRICE);
        expect(query.blockNumber).to.be.equal(BLOCK_NUMBER);
        expect(query.contractId).to.be.equal(CONTRACT_ID);
    });

    it("should throw an error when no contract id sent", async function () {
        const query = new MirrorNodeContractQuery()
            .setBlockNumber(BLOCK_NUMBER)
            .setSender(SENDER)
            .setFunction(FUNCTION_NAME)
            .setValue(VALUE)
            .setGasLimit(GAS_LIMIT)
            .setGasPrice(GAS_PRICE);

        let err = false;
        try {
            query.contractEvmAddress;
        } catch (e) {
            err = e.message.includes("Contract ID is not set");
        }
        expect(err).to.be.true;
    });

    it("should not be able to perform MN request without contract id", async function () {
        const query = new MirrorNodeContractQuery()
            .setBlockNumber(BLOCK_NUMBER)
            .setSender(SENDER)
            .setFunction(FUNCTION_NAME)
            .setValue(VALUE)
            .setGasLimit(GAS_LIMIT)
            .setGasPrice(GAS_PRICE);

        let err = false;
        try {
            await query.performMirrorNodeRequest("", "");
        } catch (e) {
            err = e.message.includes("Contract ID is not set");
        }
        expect(err).to.be.true;
    });
});
// Filename: test/unit/Mnemonic.js
import { expect } from "chai";

import { Mnemonic } from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";
import * as bip32 from "../../packages/cryptography/src/primitive/bip32.js";

const MNEMONIC_LEGACY_V1_STRING =
    "jolly kidnap tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure";
const MNEMONIC_LEGACY_V2_STRING =
    "obvious favorite remain caution remove laptop base vacant increase video erase pass sniff sausage knock grid argue salt romance way alone fever slush dune";
const MNEMONIC_24_WORD_STRING =
    "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home";
const MNEMONIC_12_WORD_STRING =
    "finish furnace tomorrow wine mass goose festival air palm easy region guilt";

describe("Mnemonic", function () {
    it("Legacy V1 mnemonic test", async function () {
        const PRIVATE_KEY1 =
            "00c2f59212cb3417f0ee0d38e7bd876810d04f2dd2cb5c2d8f26ff406573f2bd";
        const PUBLIC_KEY1 =
            "0c5bb4624df6b64c2f07a8cb8753945dd42d4b9a2ed4c0bf98e87ef154f473e9";

        const PRIVATE_KEY2 =
            "fae0002d2716ea3a60c9cd05ee3c4bb88723b196341b68a02d20975f9d049dc6";
        const PUBLIC_KEY2 =
            "f40f9fdb1f161c31ed656794ada7af8025e8b5c70e538f38a4dfb46a0a6b0392";

        const PRIVATE_KEY3 =
            "882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf";
        const PUBLIC_KEY3 =
            "53c6b451e695d6abc52168a269316a0d20deee2331f612d4fb8b2b379e5c6854";

        const PRIVATE_KEY4 =
            "6890dc311754ce9d3fc36bdf83301aa1c8f2556e035a6d0d13c2cccdbbab1242";
        const PUBLIC_KEY4 =
            "45f3a673984a0b4ee404a1f4404ed058475ecd177729daa042e437702f7791e9";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_LEGACY_V1_STRING);

        // Chain m
        const key1 = await mnemonic.toLegacyPrivateKey();
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(key1.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        // Chain m/0
        const key2 = await key1.legacyDerive(0);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(key2.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        // Chain m/-1
        const key3 = await key1.legacyDerive(-1);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(key3.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY3);

        // Chain m/1099511627775
        const key4 = await key1.legacyDerive(parseInt("1099511627775L"));
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(key4.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY4);
    });

    it("Legacy V2 mnemonic test", async function () {
        const PRIVATE_KEY1 =
            "98aa82d6125b5efa04bf8372be7931d05cd77f5ef3330b97d6ee7c006eaaf312";
        const PUBLIC_KEY1 =
            "e0ce688d614f22f96d9d213ca513d58a7d03d954fe45790006e6e86b25456465";

        const PRIVATE_KEY2 =
            "2b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb";
        const PUBLIC_KEY2 =
            "0e19f99800b007cc7c82f9d85b73e0f6e48799469450caf43f253b48c4d0d91a";

        const PRIVATE_KEY3 =
            "caffc03fdb9853e6a91a5b3c57a5c0031d164ce1c464dea88f3114786b5199e5";
        const PUBLIC_KEY3 =
            "9fe11da3fcfba5d28a6645ecb611a9a43dbe6014b102279ba1d34506ea86974b";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_LEGACY_V2_STRING);

        // Chain m
        const key1 = await mnemonic.toLegacyPrivateKey();
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(key1.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        // Chain m/0
        const key2 = await key1.legacyDerive(0);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(key2.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        // Chain m/-1
        const key3 = await key1.legacyDerive(-1);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(key3.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY3);
    });

    it("Mnemonic test", async function () {
        const expectedPrivateKey =
            "302e020100300506032b657004220420853f15aecd22706b105da1d709b4ac05b4906170c2b9c7495dff9af49e1391da";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const key = await mnemonic.toEd25519PrivateKey();

        expect(expectedPrivateKey).to.contain(key.toStringRaw());
        expect(key.toStringDer()).to.be.equal(expectedPrivateKey);
    });

    it("Mnemonic passphrase test", async function () {
        const passphrase = "\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE";
        const expectedPrivateKey =
            "302e020100300506032b6570042204203fefe1000db9485372851d542453b07e7970de4e2ecede7187d733ac037f4d2c";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const key = await mnemonic.toEd25519PrivateKey(passphrase);

        expect(expectedPrivateKey).to.contain(key.toStringRaw());
        expect(key.toStringDer()).to.be.equal(expectedPrivateKey);
    });

    it("BIP39 test vector", async function () {
        const PASSPHRASE = "TREZOR";

        // The 18-word mnemonics are not supported by the SDK
        const MNEMONIC_STRINGS = [
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
            "legal winner thank year wave sausage worth useful legal winner thank yellow",
            "letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
            "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
            "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
            "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
            "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
            "ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic",
            "hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length",
            "scheme spot photo card baby mountain device kick cradle pact join borrow",
            "panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside",
            "cat swing flag economy stadium alone churn speed unique patch report train",
            "all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform",
            "vessel ladder alter error federal sibling chat ability sun glass valve picture",
            "void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold",
        ];

        const EXPECTED_SEEDS = [
            "c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
            "2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
            "d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
            "ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
            "bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
            "bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
            "c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
            "dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
            "274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028",
            "64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440",
            "ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612",
            "72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d",
            "deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5",
            "26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d",
            "2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f",
            "01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998",
        ];

        for (let i = 0; i < MNEMONIC_STRINGS.length; i++) {
            const seed = await (
                await Mnemonic.fromString(MNEMONIC_STRINGS[i])
            ).toSeed(PASSPHRASE);
            expect(hex.encode(seed)).to.be.equal(EXPECTED_SEEDS[i]);
        }
    });

    it("Mnemonic.toStandardED25519PrivateKey() test vector 1", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1422330626
        const CHAIN_CODE1 =
            "404914563637c92d688deb9d41f3f25cbe8d6659d859cc743712fcfac72d7eda";
        const PRIVATE_KEY1 =
            "f8dcc99a1ced1cc59bc2fee161c26ca6d6af657da9aa654da724441343ecd16f";
        const PUBLIC_KEY1 =
            "2e42c9f5a5cdbde64afa65ce3dbaf013d5f9ff8d177f6ef4eb89fbe8c084ec0d";

        const CHAIN_CODE2 =
            "9c2b0073ac934696cd0b52c6c521b9bd1902aac134380a737282fdfe29014bf1";
        const PRIVATE_KEY2 =
            "e978a6407b74a0730f7aeb722ad64ab449b308e56006c8bff9aad070b9b66ddf";
        const PUBLIC_KEY2 =
            "c4b33dca1f83509f17b69b2686ee46b8556143f79f4b9df7fe7ed3864c0c64d0";

        const CHAIN_CODE3 =
            "699344acc5e07c77eb63b154b4c5c3d33cab8bf85ee21bea4cc29ab7f0502259";
        const PRIVATE_KEY3 =
            "abeca64d2337db386e289482a252334c68c7536daaefff55dc169ddb77fbae28";
        const PUBLIC_KEY3 =
            "fd311925a7a04b38f7508931c6ae6a93e5dc4394d83dafda49b051c0017d3380";

        const CHAIN_CODE4 =
            "e5af7c95043a912af57a6e031ddcad191677c265d75c39954152a2733c750a3b";
        const PRIVATE_KEY4 =
            "9a601db3e24b199912cec6573e6a3d01ffd3600d50524f998b8169c105165ae5";
        const PUBLIC_KEY4 =
            "cf525500706faa7752dca65a086c9381d30d72cc67f23bf334f330579074a890";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const passphrase = "some pass";

        // Chain m/44'/3030'/0'/0'/0'
        const key1 = await mnemonic.toStandardEd25519PrivateKey("", 0);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(key1.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0'/2147483647'
        const key2 = await mnemonic.toStandardEd25519PrivateKey("", 2147483647);
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(key2.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0'/0', passphrase: "some pass"
        const key3 = await mnemonic.toStandardEd25519PrivateKey(passphrase, 0);
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(key3.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0'/2147483647', passphrase: "some pass"
        const key4 = await mnemonic.toStandardEd25519PrivateKey(
            passphrase,
            2147483647,
        );
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(key4.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY4);
    });

    it("Mnemonic.toStandardED25519PrivateKey() test vector 2", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1424761224
        const CHAIN_CODE1 =
            "48c89d67e9920e443f09d2b14525213ff83b245c8b98d63747ea0801e6d0ff3f";
        const PRIVATE_KEY1 =
            "020487611f3167a68482b0f4aacdeb02cc30c52e53852af7b73779f67eeca3c5";
        const PUBLIC_KEY1 =
            "2d047ff02a2091f860633f849ea2024b23e7803cfd628c9bdd635010cbd782d3";

        const CHAIN_CODE2 =
            "c0bcdbd9df6d8a4f214f20f3e5c7856415b68be34a1f406398c04690818bea16";
        const PRIVATE_KEY2 =
            "d0c4484480944db698dd51936b7ecc81b0b87e8eafc3d5563c76339338f9611a";
        const PUBLIC_KEY2 =
            "a1a2573c2c45bd57b0fd054865b5b3d8f492a6e1572bf04b44471e07e2f589b2";

        const CHAIN_CODE3 =
            "998a156855ab5398afcde06164b63c5523ff2c8900db53962cc2af191df59e1c";
        const PRIVATE_KEY3 =
            "d06630d6e4c17942155819bbbe0db8306cd989ba7baf3c29985c8455fbefc37f";
        const PUBLIC_KEY3 =
            "6bd0a51e0ca6fcc8b13cf25efd0b4814978bcaca7d1cf7dbedf538eb02969acb";

        const CHAIN_CODE4 =
            "19d99506a5ce2dc0080092068d278fe29b85ffb8d9c26f8956bfca876307c79c";
        const PRIVATE_KEY4 =
            "a095ef77ee88da28f373246e9ae143f76e5839f680746c3f921e90bf76c81b08";
        const PUBLIC_KEY4 =
            "35be6a2a37ff6bbb142e9f4d9b558308f4f75d7c51d5632c6a084257455e1461";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_12_WORD_STRING);
        const passphrase = "some pass";

        // Chain m/44'/3030'/0'/0'/0'
        const key1 = await mnemonic.toStandardEd25519PrivateKey("", 0);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(key1.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0'/2147483647'
        const key2 = await mnemonic.toStandardEd25519PrivateKey("", 2147483647);
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(key2.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0'/0', passphrase: "some pass"
        const key3 = await mnemonic.toStandardEd25519PrivateKey(passphrase, 0);
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(key3.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0'/2147483647', passphrase: "some pass"
        const key4 = await mnemonic.toStandardEd25519PrivateKey(
            passphrase,
            2147483647,
        );
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(key4.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY4);
    });

    it("Mnemonic.toStandardED25519PrivateKey() should fail when index is pre-hardened", async function () {
        const mnemonic = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const hardenedIndex = bip32.toHardenedIndex(10);
        const expectedError = new Error("the index should not be pre-hardened");

        try {
            await mnemonic.toStandardEd25519PrivateKey("", hardenedIndex);
        } catch (error) {
            expect(error.message).to.be.equal(expectedError.message);
        }
    });

    it("Mnemonic.toStandardECDSAsecp256k1PrivateKey() test vector", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1422330626
        const CHAIN_CODE1 =
            "7717bc71194c257d4b233e16cf48c24adef630052f874a262d19aeb2b527620d";
        const PRIVATE_KEY1 =
            "0fde7bfd57ae6ec310bdd8b95967d98e8762a2c02da6f694b152cf9860860ab8";
        const PUBLIC_KEY1 =
            "03b1c064b4d04d52e51f6c8e8bb1bff75d62fa7b1446412d5901d424f6aedd6fd4";

        const CHAIN_CODE2 =
            "e333da4bd9e21b5dbd2b0f6d88bad02f0fa24cf4b70b2fb613368d0364cdf8af";
        const PRIVATE_KEY2 =
            "aab7d720a32c2d1ea6123f58b074c865bb07f6c621f14cb012f66c08e64996bb";
        const PUBLIC_KEY2 =
            "03a0ea31bb3562f8a309b1436bc4b2f537301778e8a5e12b68cec26052f567a235";

        const CHAIN_CODE3 =
            "0ff552587f6baef1f0818136bacac0bb37236473f6ecb5a8c1cc68a716726ed1";
        const PRIVATE_KEY3 =
            "6df5ed217cf6d5586fdf9c69d39c843eb9d152ca19d3e41f7bab483e62f6ac25";
        const PUBLIC_KEY3 =
            "0357d69bb36fee569838fe7b325c07ca511e8c1b222873cde93fc6bb541eb7ecea";

        const CHAIN_CODE4 =
            "3a5048e93aad88f1c42907163ba4dce914d3aaf2eea87b4dd247ca7da7530f0b";
        const PRIVATE_KEY4 =
            "80df01f79ee1b1f4e9ab80491c592c0ef912194ccca1e58346c3d35cb5b7c098";
        const PUBLIC_KEY4 =
            "039ebe79f85573baa065af5883d0509a5634245f7864ddead76a008c9e42aa758d";

        const CHAIN_CODE5 =
            "e54254940db58ef4913a377062ac6e411daebf435ad592d262d5a66d808a8b94";
        const PRIVATE_KEY5 =
            "60cb2496a623e1201d4e0e7ce5da3833cd4ec7d6c2c06bce2bcbcbc9dfef22d6";
        const PUBLIC_KEY5 =
            "02b59f348a6b69bd97afa80115e2d5331749b3c89c61297255430c487d6677f404";

        const CHAIN_CODE6 =
            "cb23165e9d2d798c85effddc901a248a1a273fab2a56fe7976df97b016e7bb77";
        const PRIVATE_KEY6 =
            "100477c333028c8849250035be2a0a166a347a5074a8a727bce1db1c65181a50";
        const PUBLIC_KEY6 =
            "03d10ebfa2d8ff2cd34aa96e5ef59ca2e69316b4c0996e6d5f54b6932fe51be560";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const passphrase = "some pass";

        // Chain m/44'/3030'/0'/0/0
        const key1 = await mnemonic.toStandardECDSAsecp256k1PrivateKey("", 0);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(key1.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0/0'
        const key2 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            "",
            bip32.toHardenedIndex(0),
        );
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(key2.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0/0, passphrase "some pass"
        const key3 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            0,
        );
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(key3.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0/0', passphrase "some pass"
        const key4 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            bip32.toHardenedIndex(0),
        );
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(key4.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY4);

        // Chain m/44'/3030'/0'/0/2147483647, passphrase "some pass"
        const key5 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            2147483647,
        );
        expect(hex.encode(key5.chainCode)).to.be.equal(CHAIN_CODE5);
        expect(key5.toStringRaw()).to.be.equal(PRIVATE_KEY5);
        expect(key5.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY5);

        // Chain m/44'/3030'/0'/0/2147483647', passphrase "some pass"
        const key6 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            bip32.toHardenedIndex(2147483647),
        );
        expect(hex.encode(key6.chainCode)).to.be.equal(CHAIN_CODE6);
        expect(key6.toStringRaw()).to.be.equal(PRIVATE_KEY6);
        expect(key6.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY6);
    });

    it("Mnemonic.toStandardECDSAsecp256k1PrivateKey() test vector 2", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1424761224
        const CHAIN_CODE1 =
            "e76e0480faf2790e62dc1a7bac9dce51db1b3571fd74d8e264abc0d240a55d09";
        const PRIVATE_KEY1 =
            "f033824c20dd9949ad7a4440f67120ee02a826559ed5884077361d69b2ad51dd";
        const PUBLIC_KEY1 =
            "0294bf84a54806989a74ca4b76291d386914610b40b610d303162b9e495bc06416";

        const CHAIN_CODE2 =
            "60c39c6a77bd68c0aaabfe2f4711dc9c2247214c4f4dae15ad4cb76905f5f544";
        const PRIVATE_KEY2 =
            "962f549dafe2d9c8091ac918cb4fc348ab0767353f37501067897efbc84e7651";
        const PUBLIC_KEY2 =
            "027123855357fd41d28130fbc59053192b771800d28ef47319ef277a1a032af78f";

        const CHAIN_CODE3 =
            "911a1095b64b01f7f3a06198df3d618654e5ed65862b211997c67515e3167892";
        const PRIVATE_KEY3 =
            "c139ebb363d7f441ccbdd7f58883809ec0cc3ee7a122ef67974eec8534de65e8";
        const PUBLIC_KEY3 =
            "0293bdb1507a26542ed9c1ec42afe959cf8b34f39daab4bf842cdac5fa36d50ef7";

        const CHAIN_CODE4 =
            "64173f2dcb1d65e15e787ef882fa15f54db00209e2dab16fa1661244cd98e95c";
        const PRIVATE_KEY4 =
            "87c1d8d4bb0cebb4e230852f2a6d16f6847881294b14eb1d6058b729604afea0";
        const PUBLIC_KEY4 =
            "03358e7761a422ca1c577f145fe845c77563f164b2c93b5b34516a8fa13c2c0888";

        const CHAIN_CODE5 =
            "a7250c2b07b368a054f5c91e6a3dbe6ca3bbe01eb0489fe8778304bd0a19c711";
        const PRIVATE_KEY5 =
            "2583170ee745191d2bb83474b1de41a1621c47f6e23db3f2bf413a1acb5709e4";
        const PUBLIC_KEY5 =
            "03f9eb27cc73f751e8e476dd1db79037a7df2c749fa75b6cc6951031370d2f95a5";

        const CHAIN_CODE6 =
            "66a1175e7690e3714d53ffce16ee6bb4eb02065516be2c2ad6bf6c9df81ec394";
        const PRIVATE_KEY6 =
            "f2d008cd7349bdab19ed85b523ba218048f35ca141a3ecbc66377ad50819e961";
        const PUBLIC_KEY6 =
            "027b653d04958d4bf83dd913a9379b4f9a1a1e64025a691830a67383bc3157c044";

        const mnemonic = await Mnemonic.fromString(MNEMONIC_12_WORD_STRING);
        const passphrase = "some pass";

        // Chain m/44'/3030'/0'/0/0
        const key1 = await mnemonic.toStandardECDSAsecp256k1PrivateKey("", 0);
        expect(hex.encode(key1.chainCode)).to.be.equal(CHAIN_CODE1);
        expect(key1.toStringRaw()).to.be.equal(PRIVATE_KEY1);
        expect(key1.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0/0'
        const key2 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            "",
            bip32.toHardenedIndex(0),
        );
        expect(hex.encode(key2.chainCode)).to.be.equal(CHAIN_CODE2);
        expect(key2.toStringRaw()).to.be.equal(PRIVATE_KEY2);
        expect(key2.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0/0, passphrase "some pass"
        const key3 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            0,
        );
        expect(hex.encode(key3.chainCode)).to.be.equal(CHAIN_CODE3);
        expect(key3.toStringRaw()).to.be.equal(PRIVATE_KEY3);
        expect(key3.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0/0', passphrase "some pass"
        const key4 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            bip32.toHardenedIndex(0),
        );
        expect(hex.encode(key4.chainCode)).to.be.equal(CHAIN_CODE4);
        expect(key4.toStringRaw()).to.be.equal(PRIVATE_KEY4);
        expect(key4.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY4);

        // Chain m/44'/3030'/0'/0/2147483647, passphrase "some pass"
        const key5 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            2147483647,
        );
        expect(hex.encode(key5.chainCode)).to.be.equal(CHAIN_CODE5);
        expect(key5.toStringRaw()).to.be.equal(PRIVATE_KEY5);
        expect(key5.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY5);

        // Chain m/44'/3030'/0'/0/2147483647', passphrase "some pass"
        const key6 = await mnemonic.toStandardECDSAsecp256k1PrivateKey(
            passphrase,
            bip32.toHardenedIndex(2147483647),
        );
        expect(hex.encode(key6.chainCode)).to.be.equal(CHAIN_CODE6);
        expect(key6.toStringRaw()).to.be.equal(PRIVATE_KEY6);
        expect(key6.publicKey.toStringRaw()).to.be.equal(PUBLIC_KEY6);
    });

    it("Mnemonic.calculateDerivationPathValues() test vector", async function () {
        const DPATH_1 = "m/44'/60'/0'/0/0";
        const DPATH_2 = "m/44/60/0/2147483647'/2147483646'";

        const mnemonic1 = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const result1 = await mnemonic1.calculateDerivationPathValues(DPATH_1);
        const result2 = await mnemonic1.calculateDerivationPathValues(DPATH_2);

        // NOTE that 0x80000000 == 2147483648
        expect(result1).to.deep.equal([
            -2147483604, -2147483588, -2147483648, 0, 0,
        ]);
        expect(result2).to.deep.equal([44, 60, 0, -1, -2]);
    });

    it("Mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath() test vector", async function () {
        const DPATH_1 = "m/44'/60'/0'/0/0";
        const PASSPHRASE_1 = "";
        const CHAIN_CODE_1 =
            "58a9ee31eaf7499abc01952b44dbf0a2a5d6447512367f09d99381c9605bf9e8";
        const PRIVATE_KEY_1 =
            "78f9545e40025cf7da9126a4d6a861ae34031d1c74c3404df06110c9fde371ad";
        const PUBLIC_KEY_1 =
            "02a8f4c22eea66617d4f119e3a951b93f584949bbfee90bd555305402da6c4e569";

        const DPATH_2 = "m/44'/60'/0'/0/1";
        const PASSPHRASE_2 = "";
        const CHAIN_CODE_2 =
            "6dcfc7a4914bd0e75b94a2f38afee8c247b34810202a2c64fe599ee1b88afdc9";
        const PRIVATE_KEY_2 =
            "77ca263661ebdd5a8b33c224aeff5e7bf67eedacee68a1699d97ee8929d7b130";
        const PUBLIC_KEY_2 =
            "03e84c9be9be53ad722038cc1943e79df27e5c1d31088adb4f0e62444f4dece683";

        const DPATH_3 = "m/44'/60'/0'/0/2";
        const PASSPHRASE_3 = "";
        const CHAIN_CODE_3 =
            "c8c798d2b3696be1e7a29d1cea205507eedc2057006b9ef1cde1b4e346089e17";
        const PRIVATE_KEY_3 =
            "31c24292eac951279b659c335e44a2e812d0f1a228b1d4d87034874d376e605a";
        const PUBLIC_KEY_3 =
            "0207ff3faf4055c1aa7a5ad94d6ff561fac35b9ae695ef486706243667d2b4d10e";

        const mnemonic1 = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const key1 =
            await mnemonic1.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
                PASSPHRASE_1,
                DPATH_1,
            );
        expect(hex.encode(key1.chainCode)).to.equal(CHAIN_CODE_1);
        expect(key1.toStringRaw()).to.equal(PRIVATE_KEY_1);
        expect(key1.publicKey.toStringRaw()).to.include(PUBLIC_KEY_1);

        const mnemonic2 = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const key2 =
            await mnemonic2.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
                PASSPHRASE_2,
                DPATH_2,
            );
        expect(hex.encode(key2.chainCode)).to.equal(CHAIN_CODE_2);
        expect(key2.toStringRaw()).to.equal(PRIVATE_KEY_2);
        expect(key2.publicKey.toStringRaw()).to.include(PUBLIC_KEY_2);

        const mnemonic3 = await Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        const key3 =
            await mnemonic3.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
                PASSPHRASE_3,
                DPATH_3,
            );
        expect(hex.encode(key3.chainCode)).to.equal(CHAIN_CODE_3);
        expect(key3.toStringRaw()).to.equal(PRIVATE_KEY_3);
        expect(key3.publicKey.toStringRaw()).to.include(PUBLIC_KEY_3);
    });
});
// Filename: test/unit/Mocker.js
import {
    FileId,
    PrivateKey,
    PublicKey,
    Client,
    Wallet,
    LocalProvider,
} from "../../src/index.js";
import * as grpc from "@grpc/grpc-js";
import * as loader from "@grpc/proto-loader";
import { proto } from "@hashgraph/proto";

/**
 * @template {*} RequestType
 * @template {*} ResponseType
 * @typedef {import("grpc").handleUnaryCall<RequestType, ResponseType>} grpc.handleUnaryCall<RequestType, ResponseType>
 */

/**
 * @namespace com
 * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
 */

export const PRIVATE_KEY = PrivateKey.fromString(
    "302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d",
);

const PROTOS = [
    "./packages/proto/src/proto/mirror/consensus_service.proto",
    "./packages/proto/src/proto/mirror/mirror_network_service.proto",
    "./packages/proto/src/proto/sdk/transaction_list.proto",
    "./packages/proto/src/proto/services/basic_types.proto",
    "./packages/proto/src/proto/services/consensus_create_topic.proto",
    "./packages/proto/src/proto/services/consensus_delete_topic.proto",
    "./packages/proto/src/proto/services/consensus_get_topic_info.proto",
    "./packages/proto/src/proto/services/consensus_service.proto",
    "./packages/proto/src/proto/services/consensus_submit_message.proto",
    "./packages/proto/src/proto/services/consensus_topic_info.proto",
    "./packages/proto/src/proto/services/consensus_update_topic.proto",
    "./packages/proto/src/proto/services/contract_call.proto",
    "./packages/proto/src/proto/services/contract_call_local.proto",
    "./packages/proto/src/proto/services/contract_create.proto",
    "./packages/proto/src/proto/services/contract_delete.proto",
    "./packages/proto/src/proto/services/contract_get_bytecode.proto",
    "./packages/proto/src/proto/services/contract_get_info.proto",
    "./packages/proto/src/proto/services/contract_get_records.proto",
    "./packages/proto/src/proto/services/contract_update.proto",
    "./packages/proto/src/proto/services/crypto_add_live_hash.proto",
    "./packages/proto/src/proto/services/crypto_adjust_allowance.proto",
    "./packages/proto/src/proto/services/crypto_approve_allowance.proto",
    "./packages/proto/src/proto/services/crypto_create.proto",
    "./packages/proto/src/proto/services/crypto_delete.proto",
    "./packages/proto/src/proto/services/crypto_delete_live_hash.proto",
    "./packages/proto/src/proto/services/crypto_get_account_balance.proto",
    "./packages/proto/src/proto/services/crypto_get_account_records.proto",
    "./packages/proto/src/proto/services/crypto_get_info.proto",
    "./packages/proto/src/proto/services/crypto_get_live_hash.proto",
    "./packages/proto/src/proto/services/crypto_get_stakers.proto",
    "./packages/proto/src/proto/services/crypto_service.proto",
    "./packages/proto/src/proto/services/crypto_transfer.proto",
    "./packages/proto/src/proto/services/crypto_update.proto",
    "./packages/proto/src/proto/services/custom_fees.proto",
    "./packages/proto/src/proto/services/duration.proto",
    "./packages/proto/src/proto/services/exchange_rate.proto",
    "./packages/proto/src/proto/services/file_append.proto",
    "./packages/proto/src/proto/services/file_create.proto",
    "./packages/proto/src/proto/services/file_delete.proto",
    "./packages/proto/src/proto/services/file_get_contents.proto",
    "./packages/proto/src/proto/services/file_get_info.proto",
    "./packages/proto/src/proto/services/file_service.proto",
    "./packages/proto/src/proto/services/file_update.proto",
    "./packages/proto/src/proto/services/freeze.proto",
    "./packages/proto/src/proto/services/freeze_service.proto",
    "./packages/proto/src/proto/services/freeze_type.proto",
    "./packages/proto/src/proto/services/history_proof_key_publication.proto",
    "./packages/proto/src/proto/services/history_proof_signature.proto",
    "./packages/proto/src/proto/services/history_proof_vote.proto",
    "./packages/proto/src/proto/services/freeze_type.proto",
    "./packages/proto/src/proto/services/freeze_type.proto",
    "./packages/proto/src/proto/services/get_by_key.proto",
    "./packages/proto/src/proto/services/get_by_solidity_id.proto",
    "./packages/proto/src/proto/services/network_get_execution_time.proto",
    "./packages/proto/src/proto/services/network_get_version_info.proto",
    "./packages/proto/src/proto/services/network_service.proto",
    "./packages/proto/src/proto/services/query.proto",
    "./packages/proto/src/proto/services/query_header.proto",
    "./packages/proto/src/proto/services/response.proto",
    "./packages/proto/src/proto/services/response_code.proto",
    "./packages/proto/src/proto/services/response_header.proto",
    "./packages/proto/src/proto/services/schedulable_transaction_body.proto",
    "./packages/proto/src/proto/services/schedule_create.proto",
    "./packages/proto/src/proto/services/schedule_delete.proto",
    "./packages/proto/src/proto/services/schedule_get_info.proto",
    "./packages/proto/src/proto/services/schedule_service.proto",
    "./packages/proto/src/proto/services/schedule_sign.proto",
    "./packages/proto/src/proto/services/smart_contract_service.proto",
    "./packages/proto/src/proto/services/system_delete.proto",
    "./packages/proto/src/proto/services/system_undelete.proto",
    "./packages/proto/src/proto/services/throttle_definitions.proto",
    "./packages/proto/src/proto/services/timestamp.proto",
    "./packages/proto/src/proto/services/token_associate.proto",
    "./packages/proto/src/proto/services/token_burn.proto",
    "./packages/proto/src/proto/services/token_create.proto",
    "./packages/proto/src/proto/services/token_delete.proto",
    "./packages/proto/src/proto/services/token_dissociate.proto",
    "./packages/proto/src/proto/services/token_fee_schedule_update.proto",
    "./packages/proto/src/proto/services/token_freeze_account.proto",
    "./packages/proto/src/proto/services/token_get_account_nft_infos.proto",
    "./packages/proto/src/proto/services/token_get_info.proto",
    "./packages/proto/src/proto/services/token_get_nft_info.proto",
    "./packages/proto/src/proto/services/token_get_nft_infos.proto",
    "./packages/proto/src/proto/services/token_grant_kyc.proto",
    "./packages/proto/src/proto/services/token_mint.proto",
    "./packages/proto/src/proto/services/token_pause.proto",
    "./packages/proto/src/proto/services/token_revoke_kyc.proto",
    "./packages/proto/src/proto/services/token_service.proto",
    "./packages/proto/src/proto/services/token_unfreeze_account.proto",
    "./packages/proto/src/proto/services/token_unpause.proto",
    "./packages/proto/src/proto/services/token_update.proto",
    "./packages/proto/src/proto/services/token_wipe_account.proto",
    "./packages/proto/src/proto/services/transaction.proto",
    "./packages/proto/src/proto/services/transaction_contents.proto",
    "./packages/proto/src/proto/services/transaction_get_fast_record.proto",
    "./packages/proto/src/proto/services/transaction_get_receipt.proto",
    "./packages/proto/src/proto/services/transaction_get_record.proto",
    "./packages/proto/src/proto/services/transaction_receipt.proto",
    "./packages/proto/src/proto/services/transaction_record.proto",
    "./packages/proto/src/proto/services/transaction_response.proto",
    "./packages/proto/src/proto/services/unchecked_submit.proto",
    "./packages/proto/src/proto/services/event_consensus_data.proto",
    "./packages/proto/src/proto/services/event_core.proto",
    "./packages/proto/src/proto/services/event_descriptor.proto",
    "./packages/proto/src/proto/services/event_transaction.proto",
    "./packages/proto/src/proto/services/gossip_event.proto",
    "./packages/proto/src/proto/services/state_signature_transaction.proto",
    "./packages/proto/src/proto/services/state/entity/entity_counts.proto",
];

export const ABORTED = {
    name: "ABORTED",
    message: "no response found",
    code: 10,
};

export const UNAVAILABLE = {
    name: "UNAVAILABLE",
    message: "node is UNAVAILABLE",
    code: 14,
};

export const INTERNAL = {
    name: "INTERNAL",
    message: "Received RST_STREAM with code 0",
    code: 13,
};

/**
 * @namespace {proto}
 * @typedef {import("@hashgraph/proto").Response} proto.Response
 * @typedef {import("@hashgraph/proto").Query} proto.Query
 * @typedef {import("@hashgraph/proto").TransactionResponse} proto.TransactionResponse
 */

const fileId = FileId.fromString("0.0.141");
const contractId = FileId.fromString("0.0.142");

export const TRANSACTION_RECEIPT_SUCCESS_RESPONSE = {
    transactionGetReceipt: {
        header: {
            nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
        },
        receipt: {
            status: proto.ResponseCodeEnum.SUCCESS,
            fileID: fileId._toProtobuf(),
            contractID: contractId._toProtobuf(),
        },
    },
};

export const TRANSACTION_RECEIPT_FAILED_RESPONSE = {
    transactionGetReceipt: {
        header: {
            nodeTransactionPrecheckCode: proto.ResponseCodeEnum.OK,
        },
        receipt: {
            status: proto.ResponseCodeEnum.INVALID_FILE_ID,
        },
    },
};

/**
 * @typedef {object} Response
 * @property {(request: proto.Transaction | proto.Query, index?: number) => proto.Response | proto.TransactionResponse} [call]
 * @property {proto.Response | proto.TransactionResponse | com.hedera.mirror.api.proto.IConsensusTopicResponse} [response]
 * @property {grpc.ServiceError} [error]
 */

class GrpcServer {
    /**
     * @param {string | string[]} paths
     * @param {string} name
     */
    constructor(paths) {
        this.server = new grpc.Server();

        const pkgs = /** @type {grpc.GrpcObject} */ (
            grpc.loadPackageDefinition(loader.loadSync(paths))
        );

        const proto = /** @type {grpc.GrpcObject} */ (pkgs.proto);
        const mirror = /** @type {grpc.GrpcObject} */ (
            pkgs.com.hedera.mirror.api.proto
        );

        this.services = [];

        function addPackageServices(services, pkg) {
            for (const [key, value] of Object.entries(pkg)) {
                if (typeof value !== "function") {
                    continue;
                }

                const service =
                    /** @type {grpc.ServiceDefinition<grpc.UntypedServiceImplementation>} */ (
                        /** @type {grpc.GrpcObject} */ (pkg[key])["service"]
                    );

                if (service == null) {
                    continue;
                }

                services.push(service);
            }
        }

        addPackageServices(this.services, mirror);
        addPackageServices(this.services, proto);

        Object.freeze(this);
    }

    /**
     * Adds a service to the gRPC server
     *
     * @param {?Response[]} responses
     * @returns {this}
     */
    addResponses(responses) {
        /** @type {grpc.UntypedServiceImplementation} */
        const router = {};

        let index = 0;

        for (const service of this.services) {
            for (const key of Object.keys(service)) {
                router[key] =
                    /** @type {grpc.handleUnaryCall<any, any> | grpc.handleServerStreamingCall<any, any>} */ (
                        call,
                        callback,
                    ) => {
                        if (
                            index >= responses.length ||
                            responses[index] == null
                        ) {
                            if (callback != null) {
                                callback(
                                    {
                                        name: "ABORTED",
                                        message: `no response found for index ${index}`,
                                        code: 10,
                                    },
                                    null,
                                );
                            } else {
                                call.end();
                            }

                            return;
                        }

                        const request = call.request;
                        const response = responses[index];

                        let value = null;
                        let error = null;

                        if (response.response != null) {
                            value = response.response;
                        }

                        if (response.call != null) {
                            try {
                                value = response.call(request, index);
                            } catch (err) {
                                callback(
                                    {
                                        name: "ABORTED",
                                        message: `responses[${index}].call failed with error: ${err.toString()} and stack trace: ${
                                            err.stack
                                        }`,
                                        code: 10,
                                    },
                                    null,
                                );
                                return;
                            }
                        }

                        if (response.error != null) {
                            error = response.error;
                        } else if (value == null) {
                            error = ABORTED;
                        }

                        if (callback != null) {
                            callback(error, value);
                        } else {
                            call.write(value);
                        }

                        index += 1;

                        if (index == responses.length && callback == null) {
                            call.end();
                        }
                    };
            }

            this.server.addService(service, router);
        }

        return this;
    }

    /**
     * @param {string} port
     * @param {grpc.ServerCredentials} creds
     * @returns {Promise<this>}
     */
    listen(port, creds = grpc.ServerCredentials.createInsecure()) {
        return new Promise((resolve, reject) =>
            this.server.bindAsync(port, creds, (error) => {
                if (error != null) {
                    reject(error);
                    return;
                }

                this.server.start();
                resolve(this);
            }),
        );
    }

    close() {
        this.server.forceShutdown();
    }
}

export default class Mocker {
    /**
     * Creates a mock server and client with the given responses
     *
     * @param {?Response[][]} responses
     * @returns {Promise<{servers: GrpcServers, client: NodeClient}>}
     */
    static async withResponses(responses) {
        const servers = new GrpcServers();

        for (const response of responses) {
            servers.addServer(response);
        }

        const client = await servers.listen();
        const operatorId = "0.0.1854";
        client.setOperator(operatorId, PRIVATE_KEY);

        const provider = LocalProvider.fromClient(client);
        const wallet = new Wallet(operatorId, PRIVATE_KEY, provider);

        return { client, wallet, servers };
    }

    /**
     * @param {proto.ISignedTransaction | null | undefined} signedTransaction
     * @returns {boolean}
     */
    static verifySignatures(signedTransaction) {
        if (
            signedTransaction.bodyBytes == null ||
            signedTransaction.sigMap == null ||
            signedTransaction.sigMap.sigPair == null ||
            signedTransaction.sigMap.sigPair.length === 0
        ) {
            return false;
        }

        for (const sigPair of signedTransaction.sigMap.sigPair) {
            let verified = false;

            if (sigPair.ed25519 != null) {
                verified = PublicKey.fromBytesED25519(
                    sigPair.pubKeyPrefix,
                ).verify(signedTransaction.bodyBytes, sigPair.ed25519);
            } else if (sigPair.ECDSASecp256k1 != null) {
                verified = PublicKey.fromBytesECDSA(
                    sigPair.pubKeyPrefix,
                ).verify(signedTransaction.bodyBytes, sigPair.ECDSASecp256k1);
            }

            if (!verified) {
                return false;
            }
        }

        return true;
    }
}

class GrpcServers {
    constructor() {
        /** @type {GrpcServer[]} */
        this._servers = [];

        /** @type {string[]} */
        this._addresses = [];

        /** @type {string[]} */
        this._nodeAccountIds = [];

        this._index = 0;
    }

    /**
     * @param {Response[]} responses
     * @returns {this}
     */
    addServer(responses) {
        const address = `0.0.0.0:${50213 + this._index}`;
        const nodeAccountId = `0.0.${3 + this._index}`;
        const server = new GrpcServer(PROTOS).addResponses(responses);

        this._servers.push(server);
        this._addresses.push(address);
        this._nodeAccountIds.push(nodeAccountId);

        this._index += 1;

        return this;
    }

    /**
     * @returns {Promise<Client>}
     */
    async listen() {
        const network = {};

        for (let i = 0; i < this._servers.length; i++) {
            const server = this._servers[i];
            const address = this._addresses[i];
            network[address] = this._nodeAccountIds[i];

            await server.listen(address);
        }

        return new Client({ network, scheduleNetworkUpdate: false })
            .setMirrorNetwork(Object.keys(network))
            .setNodeMinBackoff(0)
            .setNodeMaxBackoff(0)
            .setNodeMinReadmitPeriod(0)
            .setNodeMaxReadmitPeriod(0);
    }

    close() {
        for (const server of this._servers) {
            server.close();
        }
    }
}
// Filename: test/unit/NodeClient.js
import { expect } from "chai";
import { Client, LedgerId } from "../../src/index.js";
import AccountId from "../../src/account/AccountId.js";
import NodeClient from "../../src/client/NodeClient.js";
import MirrorNode from "../../src/MirrorNode.js";

const ledgerId = LedgerId.LOCAL_NODE;

describe("Client", function () {
    it("should support multiple IPs per node account ID", async function () {
        let nodes = {
            "0.testnet.hedera.com:50211": "0.0.3",
            "34.94.106.61:50211": "0.0.3",
            "50.18.132.211:50211": "0.0.3",
            "138.91.142.219:50211": "0.0.3",
        };

        const client = Client.forNetwork(nodes, {
            scheduleNetworkUpdate: false,
        });

        let network = client.network;

        expect(Object.entries(network).length).to.be.equal(4);
        expect(network["0.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.3",
        );
        expect(network["34.94.106.61:50211"].toString()).to.be.equal("0.0.3");
        expect(network["50.18.132.211:50211"].toString()).to.be.equal("0.0.3");
        expect(network["138.91.142.219:50211"].toString()).to.be.equal("0.0.3");
    });

    it("should correctly construct and update network", async function () {
        let nodes = {
            "0.testnet.hedera.com:50211": "0.0.3",
        };

        const client = Client.forNetwork(nodes, {
            scheduleNetworkUpdate: false,
        });

        let network = client.network;

        expect(Object.entries(network).length).to.be.equal(1);
        expect(network["0.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.3",
        );

        client.setNetwork(nodes);
        network = client.network;

        expect(Object.entries(network).length).to.be.equal(1);
        expect(network["0.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.3",
        );

        nodes["1.testnet.hedera.com:50211"] = "0.0.4";

        client.setNetwork(nodes);
        network = client.network;

        expect(Object.entries(network).length).to.be.equal(2);
        expect(network["0.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.3",
        );
        expect(network["1.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.4",
        );

        nodes["2.testnet.hedera.com:50211"] = "0.0.5";

        client.setNetwork(nodes);
        network = client.network;

        expect(Object.entries(network).length).to.be.equal(3);
        expect(network["0.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.3",
        );
        expect(network["1.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.4",
        );
        expect(network["2.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.5",
        );

        nodes = {
            "2.testnet.hedera.com:50211": "0.0.5",
        };

        client.setNetwork(nodes);
        network = client.network;

        expect(Object.entries(network).length).to.be.equal(1);
        expect(network["2.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.5",
        );

        nodes = {
            "2.testnet.hedera.com:50211": "0.0.6",
        };

        client.setNetwork(nodes);
        network = client.network;

        expect(Object.entries(network).length).to.be.equal(1);
        expect(network["2.testnet.hedera.com:50211"].toString()).to.be.equal(
            "0.0.6",
        );
    });

    describe("local-node factories work", function () {
        const consensusNodes = { "127.0.0.1:50211": new AccountId(3) };
        const mirrorNodes = ["127.0.0.1:5600"];

        function assertIsLocalNode(client) {
            expect(client.network).to.deep.equal(consensusNodes);
            expect(client.mirrorNetwork).to.deep.equal(mirrorNodes);
            expect(client.ledgerId).to.equal(ledgerId);
        }

        it("recognizes local node by name", function () {
            const client = Client.forNetwork("local-node", {
                scheduleNetworkUpdate: false,
            });
            assertIsLocalNode(client);
        });

        it("builds explicit local node client", function () {
            const client = Client.forLocalNode();
            assertIsLocalNode(client);
        });

        it("allows setting local node network", function () {
            const client = new NodeClient({ scheduleNetworkUpdate: false });
            client.setNetwork("local-node");
            client.setMirrorNetwork("local-node");
            assertIsLocalNode(client);
        });

        it("destructures props for local node", function () {
            const client = new NodeClient({
                network: "local-node",
                mirrorNodes: "local-node",
                scheduleNetworkUpdate: false,
            });
            assertIsLocalNode(client);
        });
    });

    it("should correctly construct and update mirror network", async function () {
        let nodes = ["testnet.mirrornode.hedera.com:443"];

        const client = Client.forNetwork(
            {},
            { scheduleNetworkUpdate: false },
        ).setMirrorNetwork(nodes);

        let network = client.mirrorNetwork;

        expect(network.length).to.be.equal(1);
        expect(network.includes("testnet.mirrornode.hedera.com:443")).to.be
            .true;

        client.setMirrorNetwork(nodes);
        network = client.mirrorNetwork;

        expect(network.length).to.be.equal(1);
        expect(network.includes("testnet.mirrornode.hedera.com:443")).to.be
            .true;

        nodes.push("hcs.testnet1.mirrornode.hedera.com:5600");

        client.setMirrorNetwork(nodes);
        network = client.mirrorNetwork;

        expect(network.length).to.be.equal(2);
        expect(network.includes("testnet.mirrornode.hedera.com:443")).to.be
            .true;
        expect(network.includes("hcs.testnet1.mirrornode.hedera.com:5600")).to
            .be.true;

        nodes = ["hcs.testnet1.mirrornode.hedera.com:5600"];

        client.setMirrorNetwork(nodes);
        network = client.mirrorNetwork;

        expect(network.length).to.be.equal(1);
        expect(network.includes("hcs.testnet1.mirrornode.hedera.com:5600")).to
            .be.true;
    });

    it("should maintain TLS after setting a mirror network with TLS", function () {
        const client = Client.forNetwork({}, { scheduleNetworkUpdate: false })
            .setTransportSecurity(true)
            .setMirrorNetwork(["mainnet-public.mirrornode.hedera.com:443"]);

        expect(client.mirrorNetwork).to.deep.equal([
            "mainnet-public.mirrornode.hedera.com:443",
        ]);
    });

    describe("forMirrorNetwork method tests", function () {
        let client;

        it("should create a NodeClient with the specified mirror network", async function () {
            const networkAddress = "testnet.mirrornode.hedera.com:443";

            client = await Client.forMirrorNetwork(networkAddress);

            expect(client).to.be.instanceOf(NodeClient);

            expect(client._mirrorNetwork._network.has(networkAddress)).to.be
                .true;

            const mirrorNode =
                client._mirrorNetwork._network.get(networkAddress)[0];

            expect(mirrorNode).to.be.an.instanceof(MirrorNode);
            expect(mirrorNode._address).to.not.be.undefined;
        });

        it("should throw an error if network name is unknown", async function () {
            try {
                await Client.forMirrorNetwork("unknown-net");
            } catch (error) {
                expect(error.message).to.equal(
                    "failed to parse address: unknown-net",
                );
            }
        });

        it("should set a default update period for network address book query", async function () {
            client = await NodeClient.forMirrorNetwork("testnet");
            expect(client._networkUpdatePeriod).to.equal(10000);
        });

        afterEach(async function () {
            await client.close();
        });
    });
});
// Filename: test/unit/NodeCreateTransaction.js
import {
    AccountId,
    Hbar,
    NodeCreateTransaction,
    PrivateKey,
    ServiceEndpoint,
    Timestamp,
    TransactionId,
} from "../../src/index.js";

describe("NodeCreateTransaction", function () {
    // setting these variables outside of the beforeEach function to avoid
    // as there is a lint setting that doesnt allow function calls
    // in the describe block
    let tx,
        accountId,
        nodeAccountIds,
        gossipCaCertificate,
        gossipEndpoints,
        serviceEndpoints;

    const VALID_START = new Timestamp(1596210382, 0);
    const DESCRIPTION = "Test Description";
    const IMMUTABLE_ERROR = "transaction is immutable";

    beforeEach(function () {
        const IP_AddressV4 = Uint8Array.of(127, 0, 0, 1);
        accountId = AccountId.fromString("0.6.9");
        nodeAccountIds = [
            AccountId.fromString("0.0.5005"),
            AccountId.fromString("0.0.5006"),
        ];
        gossipCaCertificate = Buffer.from("gossipCaCertificate");
        gossipEndpoints = [new ServiceEndpoint().setIpAddressV4(IP_AddressV4)];
        serviceEndpoints = [new ServiceEndpoint().setIpAddressV4(IP_AddressV4)];

        const TEST_ADMIN_KEY = PrivateKey.fromStringED25519(
            "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b",
        ).publicKey;

        tx = new NodeCreateTransaction()
            .setNodeAccountIds(nodeAccountIds)
            .setTransactionId(
                TransactionId.withValidStart(nodeAccountIds[0], VALID_START),
            )
            .setAccountId(accountId)
            .setDescription(DESCRIPTION)
            .setGossipCaCertificate(gossipCaCertificate)
            .setCertificateHash(gossipCaCertificate) // TODO: change this vlaue to a proper one
            .setAdminKey(TEST_ADMIN_KEY)
            .setServiceEndpoints(serviceEndpoints)
            .setGossipEndpoints(gossipEndpoints)
            .setMaxTransactionFee(new Hbar(1));
    });

    it("should convert from and to bytes", function () {
        const tx2 = NodeCreateTransaction.fromBytes(tx.toBytes());

        tx.nodeAccountIds.forEach((_, index) => {
            expect(tx.nodeAccountIds[index].toString()).to.equal(
                tx2.nodeAccountIds[index].toString(),
            );
        });
        expect(tx.transactionId.toString()).to.equal(
            tx2.transactionId.toString(),
        );
        expect(tx.accountId.toString()).to.equal(tx2.accountId.toString());
        expect(tx.description).to.equal(tx2.description);
        expect(tx.gossipCaCertificate.equals(tx2.gossipCaCertificate)).to.be
            .true;
        expect(tx.certificateHash.equals(tx2.certificateHash)).to.be.true;
        expect(tx.adminKey.toString()).to.equal(tx2.adminKey.toString());
        expect(tx.maxTransactionFee.toTinybars().toInt()).to.equal(
            tx2.maxTransactionFee.toTinybars().toInt(),
        );
        tx.serviceEndpoints.forEach((_, index) => {
            const TX_IPV4_BUFFER = Buffer.from(
                tx.serviceEndpoints[index]._ipAddressV4,
            );
            const TX2_IPV4_BUFFER = tx2.serviceEndpoints[index]._ipAddressV4;
            expect(TX_IPV4_BUFFER).to.deep.equal(TX2_IPV4_BUFFER);
        });
        tx.gossipEndpoints.forEach((_, index) => {
            const TX_IPV4_BUFFER = Buffer.from(
                tx.gossipEndpoints[index]._ipAddressV4,
            );
            const TX2_IPV4_BUFFER = tx2.gossipEndpoints[index]._ipAddressV4;
            expect(TX_IPV4_BUFFER).to.deep.equal(TX2_IPV4_BUFFER);
        });
    });

    it("should change account id", function () {
        const newAccountId = AccountId.fromString("0.4.20");
        tx.setAccountId(newAccountId);
        expect(tx.accountId.toString()).to.equal(newAccountId.toString());
    });

    it("should not change accound id if frozen", function () {
        const newAccountId = AccountId.fromString("0.4.20");
        tx.freeze();
        let err = false;
        try {
            tx.setAccountId(newAccountId);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });

    it("should change description", function () {
        const NEW_DESCRIPTION = "New Description";
        tx.setDescription(NEW_DESCRIPTION);
        expect(tx.description).to.equal(NEW_DESCRIPTION);
    });

    it("should not change description if frozen", function () {
        const NEW_DESCRIPTION = "New Description";
        tx.freeze();
        let err = false;
        try {
            tx.setDescription(NEW_DESCRIPTION);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });

    it("should change admin key", function () {
        const NEW_ADMIN_KEY = PrivateKey.fromStringED25519(
            "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b",
        ).publicKey;
        tx.setAdminKey(NEW_ADMIN_KEY);
        expect(tx.adminKey.toString()).to.equal(NEW_ADMIN_KEY.toString());
    });

    it("should not change admin key if frozen", function () {
        const NEW_ADMIN_KEY = PrivateKey.fromStringED25519(
            "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b",
        ).publicKey;
        tx.freeze();
        let err = false;
        try {
            tx.setAdminKey(NEW_ADMIN_KEY);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });

    it("should change certificate", function () {
        const NEW_CERTIFICATE = Buffer.from("newCertificate");
        tx.setGossipCaCertificate(NEW_CERTIFICATE);
        expect(tx.gossipCaCertificate.equals(NEW_CERTIFICATE)).to.be.true;
    });

    it("should not change certificate if frozen", function () {
        const NEW_CERTIFICATE = Buffer.from("newCertificate");
        tx.freeze();
        let err = false;
        try {
            tx.setGossipCaCertificate(NEW_CERTIFICATE);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });

    it("should change certificate hash", function () {
        const NEW_CERTIFICATE = Buffer.from("certificate_hash");
        tx.setCertificateHash(NEW_CERTIFICATE);
        expect(tx.certificateHash.equals(NEW_CERTIFICATE)).to.be.true;
    });

    it("should not change certificate hash if frozen", function () {
        const NEW_CERTIFICATE = Buffer.from("certificate_hash");
        tx.freeze();
        let err = false;
        try {
            tx.setCertificateHash(NEW_CERTIFICATE);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });

    it("should change gossip endpoints", function () {
        const NEW_GOSSIP_ENDPOINTS = [
            new ServiceEndpoint().setIpAddressV4(Uint8Array.of(127, 0, 0, 2)),
        ];
        tx.setGossipEndpoints(NEW_GOSSIP_ENDPOINTS);
        expect(tx.gossipEndpoints).to.deep.equal(NEW_GOSSIP_ENDPOINTS);
    });

    it("should not change gossip endpoints if frozen", function () {
        const NEW_GOSSIP_ENDPOINTS = [
            new ServiceEndpoint().setIpAddressV4(Uint8Array.of(127, 0, 0, 2)),
        ];
        tx.freeze();
        let err = false;
        try {
            tx.setGossipEndpoints(NEW_GOSSIP_ENDPOINTS);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });

    it("should change service endpoints", function () {
        const NEW_SERVICE_ENDPOINTS = [
            new ServiceEndpoint().setIpAddressV4(Uint8Array.of(127, 0, 0, 2)),
        ];
        tx.setServiceEndpoints(NEW_SERVICE_ENDPOINTS);
        expect(tx.serviceEndpoints).to.deep.equal(NEW_SERVICE_ENDPOINTS);
    });

    it("should not change service endpoints if frozen", function () {
        const NEW_SERVICE_ENDPOINTS = [
            new ServiceEndpoint().setIpAddressV4(Uint8Array.of(127, 0, 0, 2)),
        ];
        tx.freeze();
        let err = false;
        try {
            tx.setServiceEndpoints(NEW_SERVICE_ENDPOINTS);
        } catch (error) {
            err = error.toString().includes(IMMUTABLE_ERROR);
        }

        expect(err).to.be.true;
    });
});
// Filename: test/unit/NodeDeleteTransaction.js
import {
    AccountId,
    Hbar,
    NodeDeleteTransaction,
    Timestamp,
    TransactionId,
} from "../../src/index.js";

describe("NodeDeleteTransaction", function () {
    let tx;

    beforeEach(function () {
        const NODE_ID = 420,
            VALID_START = new Timestamp(1596210382, 0);

        tx = new NodeDeleteTransaction()
            .setNodeAccountIds([
                AccountId.fromString("0.0.5005"),
                AccountId.fromString("0.0.5006"),
            ])
            .setTransactionId(
                TransactionId.withValidStart(
                    AccountId.fromString("0.0.5006"),
                    VALID_START,
                ),
            )
            .setNodeId(NODE_ID)
            .setMaxTransactionFee(new Hbar(1));
    });

    it("should convert from and to bytes", function () {
        const tx2 = NodeDeleteTransaction.fromBytes(tx.toBytes());
        tx.nodeAccountIds.forEach((_, index) => {
            expect(tx.nodeAccountIds[index].toString()).to.equal(
                tx2.nodeAccountIds[index].toString(),
            );
        });
        expect(tx.transactionId.toString()).to.equal(
            tx2.transactionId.toString(),
        );
    });

    it("should return node id", function () {
        expect(tx.nodeId).to.equal(420);
    });

    it("should set node id", function () {
        tx.setNodeId(421);
        expect(tx.nodeId).to.equal(421);
    });
});
// Filename: test/unit/NodeUpdateTransaction.js
import {
    AccountId,
    Hbar,
    NodeUpdateTransaction,
    PrivateKey,
    ServiceEndpoint,
    Timestamp,
    TransactionId,
} from "../../src/index.js";

describe("NodeUpdateTransaction", function () {
    const IMMUTABLE_ERROR = "transaction is immutable";

    it("should convert from and to bytes", function () {
        const NODE_ACCOUNT_IDS = [
            AccountId.fromString("0.0.5005"),
            AccountId.fromString("0.0.5006"),
        ];
        const IP_AddressV4 = Uint8Array.of(127, 0, 0, 1);
        const VALID_START = new Timestamp(1596210382, 0);
        const NODE_ID = 420;
        const DESCRIPTION = "Test Description";
        const ACCOUNT_ID = AccountId.fromString("0.6.9");
        const ADMIN_KEY = PrivateKey.fromStringED25519(
            "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b",
        ).publicKey;

        const GOSSIP_CA_CERTIFICATE = Buffer.from("gossipCaCertificate");
        const GRPC_CERTIFICATE_HASH = Buffer.from("grpcCertificateHash");
        const GOSSIP_ENDPOINTS = [
            new ServiceEndpoint().setIpAddressV4(IP_AddressV4),
        ];
        const SERVICE_ENDPOINTS = [
            new ServiceEndpoint().setIpAddressV4(IP_AddressV4),
        ];

        const tx = new NodeUpdateTransaction()
            .setNodeAccountIds(NODE_ACCOUNT_IDS)
            .setTransactionId(
                TransactionId.withValidStart(ACCOUNT_ID, VALID_START),
            )
            .setNodeId(NODE_ID)
            .setAccountId(ACCOUNT_ID)
            .setDescription(DESCRIPTION)
            .setGossipEndpoints(GOSSIP_ENDPOINTS)
            .setGossipCaCertificate(GOSSIP_CA_CERTIFICATE)
            .setServiceEndpoints(SERVICE_ENDPOINTS)
            .setCertificateHash(GRPC_CERTIFICATE_HASH)
            .setAdminKey(ADMIN_KEY)
            .setMaxTransactionFee(new Hbar(1));

        const tx2 = NodeUpdateTransaction.fromBytes(tx.toBytes());

        tx.nodeAccountIds.forEach((_, index) => {
            expect(tx.nodeAccountIds[index].toString()).to.equal(
                tx2.nodeAccountIds[index].toString(),
            );
        });

        expect(tx.transactionId.toString()).to.equal(
            tx2.transactionId.toString(),
        );
        expect(tx.nodeId).to.equal(tx2.nodeId.toInt());
        expect(tx.accountId.toString()).to.equal(tx2.accountId.toString());
        expect(tx.description).to.equal(tx2.description);
        expect(tx.maxTransactionFee.toTinybars().toInt()).to.equal(
            tx2.maxTransactionFee.toTinybars().toInt(),
        );

        expect(tx.gossipEndpoints[0].toString()).to.equal(
            tx2.gossipEndpoints[0].toString(),
        );
        expect(tx.gossipCaCertificate.toString()).to.equal(
            tx2.gossipCaCertificate.toString(),
        );
        expect(tx.serviceEndpoints[0].toString()).to.equal(
            tx2.serviceEndpoints[0].toString(),
        );
        expect(tx.certificateHash.toString()).to.equal(
            tx2.certificateHash.toString(),
        );
        expect(tx.adminKey.toString()).to.equal(tx2.adminKey.toString());
    });

    it("should change account id", function () {
        const newAccountId = AccountId.fromString("0.4.20");
        const tx = new NodeUpdateTransaction().setAccountId(newAccountId);
        expect(tx.accountId.toString()).to.equal(newAccountId.toString());
    });

    it("should change node id", function () {
        const newNodeId = 421;
        const tx = new NodeUpdateTransaction().setNodeId(newNodeId);
        expect(tx.nodeId).to.equal(newNodeId);
    });

    it("should change description", function () {
        const newDescription = "New Description";
        const tx = new NodeUpdateTransaction().setDescription(newDescription);
        expect(tx.description).to.equal(newDescription);
    });

    it("should change gossip endpoints", function () {
        const NEW_IP_AddressV4 = Uint8Array.of(127, 0, 0, 2);
        const newGossipEndpoints = [
            new ServiceEndpoint().setIpAddressV4(NEW_IP_AddressV4),
        ];
        const tx = new NodeUpdateTransaction().setGossipEndpoints(
            newGossipEndpoints,
        );
        expect(tx.gossipEndpoints[0].toString()).to.equal(
            newGossipEndpoints[0].toString(),
        );
    });

    it("should change service endpoints", function () {
        const NEW_IP_AddressV4 = Uint8Array.of(127, 0, 0, 2);
        const newServiceEndpoints = [
            new ServiceEndpoint().setIpAddressV4(NEW_IP_AddressV4),
        ];
        const tx = new NodeUpdateTransaction().setServiceEndpoints(
            newServiceEndpoints,
        );
        expect(tx.serviceEndpoints[0].toString()).to.equal(
            newServiceEndpoints[0].toString(),
        );
    });

    it("should change gossip ca certificate", function () {
        const newGossipCaCertificate = Buffer.from("newGossipCaCertificate");
        const tx = new NodeUpdateTransaction().setGossipCaCertificate(
            newGossipCaCertificate,
        );
        expect(tx.gossipCaCertificate.toString()).to.equal(
            newGossipCaCertificate.toString(),
        );
    });

    it("should change certificate hash", function () {
        const newCertificateHash = Buffer.from("newCertificateHash");
        const tx = new NodeUpdateTransaction().setCertificateHash(
            newCertificateHash,
        );
        expect(tx.certificateHash.toString()).to.equal(
            newCertificateHash.toString(),
        );
    });

    it("should change admin key", function () {
        const newAdminKey = PrivateKey.fromStringED25519(
            "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b",
        ).publicKey;
        const tx = new NodeUpdateTransaction().setAdminKey(newAdminKey);
        expect(tx.adminKey.toString()).to.equal(newAdminKey.toString());
    });

    it("should change max transaction fee", function () {
        const newMaxTransactionFee = new Hbar(1);
        const tx = new NodeUpdateTransaction().setMaxTransactionFee(
            newMaxTransactionFee,
        );
        expect(tx.maxTransactionFee.toTinybars().toInt()).to.equal(
            newMaxTransactionFee.toTinybars().toInt(),
        );
    });

    describe("frozen transaction", function () {
        let tx;

        before(function () {
            const ACCOUNT_ID = AccountId.fromString("0.4.20");
            const VALID_START = new Timestamp(1596210382, 0);

            tx = new NodeUpdateTransaction()
                .setNodeAccountIds([AccountId.fromString("0.0.3")])
                .setTransactionId(
                    TransactionId.withValidStart(ACCOUNT_ID, VALID_START),
                )
                .freeze();
        });

        it("should not change node account id", function () {
            const NODE_ACCOUNT_IDS = [
                AccountId.fromString("0.0.5007"),
                AccountId.fromString("0.0.5008"),
            ];
            let err = false;
            try {
                tx.setNodeAccountIds(NODE_ACCOUNT_IDS);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }

            expect(err).to.be.true;
        });

        it("should not change node id", function () {
            let err = false;
            try {
                tx.setNodeId(421);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });

        it("should not change account id", function () {
            let err = false;
            const ACCOUNT_ID = AccountId.fromString("0.4.20");
            try {
                tx.setAccountId(ACCOUNT_ID);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });

        it("should not change description", function () {
            let err = false;
            const DESCRIPTION = "New Description";
            try {
                tx.setDescription(DESCRIPTION);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });

        it("should not change gossip endpoints", function () {
            let err = false;
            const NEW_IP_AddressV4 = Uint8Array.of(127, 0, 0, 2);
            const newGossipEndpoints = [
                new ServiceEndpoint().setIpAddressV4(NEW_IP_AddressV4),
            ];
            try {
                tx.setGossipEndpoints(newGossipEndpoints);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });

        it("should not change service endpoints", function () {
            let err = false;
            const NEW_IP_AddressV4 = Uint8Array.of(127, 0, 0, 2);
            const newServiceEndpoints = [
                new ServiceEndpoint().setIpAddressV4(NEW_IP_AddressV4),
            ];
            try {
                tx.setServiceEndpoints(newServiceEndpoints);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });

        it("should not change gossip ca certificate", function () {
            let err = false;
            const newGossipCaCertificate = Buffer.from(
                "newGossipCaCertificate",
            );
            try {
                tx.setGossipCaCertificate(newGossipCaCertificate);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });

        it("should not change certificate hash", function () {
            let err = false;
            const newCertificateHash = Buffer.from("newCertificateHash");
            try {
                tx.setCertificateHash(newCertificateHash);
            } catch (error) {
                err = error.toString().includes(IMMUTABLE_ERROR);
            }
            expect(err).to.be.true;
        });
    });

    describe("deserialization of optional parameters", function () {
        it("should deserialize with gossipCaCertificate, grpcCertificateHash being null", function () {
            const tx = new NodeUpdateTransaction();
            const tx2 = NodeUpdateTransaction.fromBytes(tx.toBytes());

            expect(tx.gossipCaCertificate).to.be.null;
            expect(tx.certificateHash).to.be.null;
            expect(tx2.gossipCaCertificate).to.be.null;
            expect(tx2.certificateHash).to.be.null;
        });

        it("should deserialize with description being null", function () {
            const tx = new NodeUpdateTransaction();
            const tx2 = NodeUpdateTransaction.fromBytes(tx.toBytes());

            expect(tx.description).to.be.null;
            expect(tx2.description).to.be.null;
        });
    });
});
// Filename: test/unit/PendingAirdropId.js
import { expect } from "chai";
import {
    NftId,
    TokenId,
    AccountId,
    PendingAirdropId,
} from "../../src/index.js";

describe("PendingAirdropId", function () {
    let nftId, tokenId, serial, senderId, receiverId;

    beforeEach(function () {
        serial = 0;
        tokenId = new TokenId(0, 0, 1);
        nftId = new NftId(tokenId, serial);
        senderId = new AccountId(0, 0, 1);
        receiverId = new AccountId(0, 0, 2);
    });

    it("should populate PendingAirdropId from constructor", function () {
        const pendingAirdropId = new PendingAirdropId({
            nftId,
            senderId,
            receiverId,
        });

        expect(pendingAirdropId.nftId).to.eql(nftId);
        expect(pendingAirdropId.senderId).to.eql(senderId);
        expect(pendingAirdropId.receiverId).to.eql(receiverId);
    });

    it("should set nftId", function () {
        const pendingAirdropId = new PendingAirdropId().setNftId(nftId);
        expect(pendingAirdropId.nftId).to.eql(nftId);
        expect(pendingAirdropId.tokenId).to.eql(null);
    });

    it("should set tokenId", function () {
        const pendingAirdropId = new PendingAirdropId().setTokenId(tokenId);
        expect(pendingAirdropId.tokenId).to.eql(tokenId);
        expect(pendingAirdropId.nftId).to.eql(null);
    });

    it("should set senderId", function () {
        const pendingAirdropId = new PendingAirdropId().setSenderid(senderId);
        expect(pendingAirdropId.senderId).to.eql(senderId);
    });

    it("should set receiverId", function () {
        const pendingAirdropId = new PendingAirdropId().setReceiverId(
            receiverId,
        );
        expect(pendingAirdropId.receiverId).to.eql(receiverId);
    });

    it("should not be able to call fromBytes", async function () {
        const pendingAirdropId = new PendingAirdropId({
            senderId,
            receiverId,
        });

        const proto = pendingAirdropId.toBytes();

        let error = false;
        try {
            PendingAirdropId.fromBytes(proto);
        } catch (err) {
            error = err.message.includes(
                "Either fungibleTokenType or nonFungibleToken is required",
            );
        }

        expect(error).to.eql(true);
    });
});
// Filename: test/unit/PrivateKey.js
import { expect } from "chai";

import {
    AccountId,
    FileAppendTransaction,
    PrivateKey,
    Timestamp,
    Transaction,
    TransactionId,
    TransferTransaction,
} from "../../src/index.js";
import SignatureMap from "../../src/transaction/SignatureMap.js";

describe("PrivateKey signTransaction", function () {
    let privateKey, transaction;

    beforeEach(function () {
        const validStart = new Timestamp(Math.floor(Date.now() / 1000), 0);
        const txId = new TransactionId(new AccountId(0), validStart);
        privateKey = PrivateKey.generate();
        transaction = new TransferTransaction()
            .setNodeAccountIds([new AccountId(3)])
            .setTransactionId(txId)
            .freeze();
    });

    it("should add zeroes at the beginning of <32 bytes private key", async function () {
        const EXPECTED_PRIVATE_KEY =
            "0000000000000000fd2fe3d732d3412140accab21b4b7303ff05f9c9127542cd";
        const derPrefix = "3030020100300706052b8104000a04220420";
        const EXPECTED_DER_PRIVATE_KEY = derPrefix + EXPECTED_PRIVATE_KEY;

        const SHORT_PRIVATE_KEY =
            PrivateKey.fromStringECDSA(EXPECTED_PRIVATE_KEY);

        expect(SHORT_PRIVATE_KEY.toStringRaw()).to.equal(EXPECTED_PRIVATE_KEY);
        expect(SHORT_PRIVATE_KEY.toStringDer()).to.equal(
            EXPECTED_DER_PRIVATE_KEY,
        );
    });

    it("should sign transaction and add signature", function () {
        const { bodyBytes } = transaction._signedTransactions.list[0];
        const sig = privateKey.sign(bodyBytes);

        const sigMap = new SignatureMap().addSignature(
            new AccountId(3),
            transaction.transactionId,
            privateKey.publicKey,
            sig,
        );

        transaction.addSignature(privateKey.publicKey, sigMap);

        const sigPairMaps = transaction.getSignatures().getFlatSignatureList();
        for (const sigPairMap of sigPairMaps) {
            expect(sigPairMap.get(privateKey.publicKey)).to.equal(sig);
        }
    });

    it("should throw an error if bodyBytes are missing", async function () {
        // Set bodyBytes to null to simulate missing bodyBytes
        const mockedTransaction = new Transaction();
        mockedTransaction._signedTransactions.setList([
            {
                sigMap: {
                    sigPair: [],
                },
                bodyBytes: null,
            },
        ]);

        try {
            privateKey.signTransaction(mockedTransaction);
        } catch (err) {
            expect(err.message).to.equal("Body bytes are missing");
        }
        const sigs = mockedTransaction.getSignatures().getFlatSignatureList();
        expect(sigs.length).to.equal(0);
    });

    it("should sign transaction and add multiple signature", function () {
        const contents = "Hello, World!";
        const multisignatureTransaction = new FileAppendTransaction()
            .setContents(contents)
            .setChunkSize(1)
            .setNodeAccountIds([new AccountId(3)])
            .setTransactionId(
                new TransactionId(new AccountId(0), new Timestamp(0, 0)),
            )
            .freeze();

        const sigs = multisignatureTransaction._signedTransactions.list.map(
            (tx) => {
                return privateKey.sign(tx.bodyBytes);
            },
        );

        const sigMap = new SignatureMap();
        sigs.forEach((sig, index) => {
            const txId = multisignatureTransaction._transactionIds.list[index];
            sigMap.addSignature(
                new AccountId(3),
                txId,
                privateKey.publicKey,
                sig,
            );
        });
        multisignatureTransaction.addSignature(privateKey.publicKey, sigMap);

        const txSigPairMaps = multisignatureTransaction
            .getSignatures()
            .getFlatSignatureList();

        /*  Check if all the signatures are added to the transaction. This works 
            because the transaction signatures are added in the same order as the
            sigmap signatures.
        */
        for (const txSigPairMap of txSigPairMaps) {
            expect(txSigPairMap.get(privateKey.publicKey)).to.equal(
                sigs.shift(),
            );
        }
        expect(txSigPairMaps.length).to.equal(contents.length);
    });
});
// Filename: test/unit/PrngTransaction.js
import {
    PrngTransaction,
    Transaction,
    AccountId,
    Timestamp,
    TransactionId,
} from "../../src/index.js";

describe("PrngTransaction", function () {
    it("should return range when create transaction from Bytes", async function () {
        const spenderAccountId = new AccountId(1);
        const timestamp = new Timestamp(14, 15);

        let transaction = await new PrngTransaction()
            .setTransactionId(
                TransactionId.withValidStart(spenderAccountId, timestamp),
            )
            .setNodeAccountIds([spenderAccountId])
            .setRange(100)
            .freeze();

        const transactionToBytes = transaction.toBytes();

        const transactionFromBytes = Transaction.fromBytes(transactionToBytes);

        expect(transactionFromBytes.range).to.eql(100);
    });
});
// Filename: test/unit/PublicKey.js
import {
    AccountId,
    PrivateKey,
    PublicKey,
    TransactionId,
    TransferTransaction,
    Transaction,
} from "../../src/index.js";

describe("PublicKey", function () {
    it("`verifyTransaction` works", async function () {
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateECDSA();
        const nodeAccountId = new AccountId(6);

        let transaction = new TransferTransaction()
            .setTransactionId(TransactionId.generate(new AccountId(5)))
            .setNodeAccountIds([nodeAccountId])
            .addHbarTransfer("0.0.3", -1)
            .addHbarTransfer("0.0.4", 1)
            .freeze();

        await transaction.sign(key1);
        await transaction.sign(key2);

        expect(key1.publicKey.verifyTransaction(transaction)).to.be.true;
        expect(key2.publicKey.verifyTransaction(transaction)).to.be.true;

        let signaturesNodeId = transaction.getSignatures().get(nodeAccountId);
        let txSignatures = signaturesNodeId.get(transaction.transactionId);
        expect(txSignatures.size).to.be.equal(2);

        for (const [publicKey, ,] of txSignatures) {
            expect(publicKey.verifyTransaction(transaction)).to.be.true;
        }

        const bytes = transaction.toBytes();

        transaction = Transaction.fromBytes(bytes);

        expect(key1.publicKey.verifyTransaction(transaction)).to.be.true;
        expect(key2.publicKey.verifyTransaction(transaction)).to.be.true;

        const sigMap = transaction.getSignatures();
        expect(sigMap.size).to.be.equal(1);

        txSignatures = signaturesNodeId.get(transaction.transactionId);
        expect(txSignatures.size).to.be.equal(2);
        for (const [publicKey, ,] of txSignatures) {
            expect(publicKey.verifyTransaction(transaction)).to.be.true;
        }
    });

    it("verify `fromStringECDSA()` works", async function () {
        const ecdsaStringKey =
            "302d300706052b8104000a0322000245f219afdfc8e61b9f6879fa7c8a16a94b35471662afa302993d7d9a29564f81";
        const publicKeyECDSA = PublicKey.fromStringECDSA(ecdsaStringKey);

        expect(publicKeyECDSA.toString()).to.be.equal(ecdsaStringKey);
    });

    it("verify `fromStringED25519()` works", async function () {
        const ed25519StringKey =
            "302a300506032b6570032100bc46c36d8aeb94270064edb8d3d4d5d29446e1bb2f36cc47b2c9b755ef0aac25";
        const publicKeyED25519 = PublicKey.fromStringED25519(
            "302a300506032b6570032100bc46c36d8aeb94270064edb8d3d4d5d29446e1bb2f36cc47b2c9b755ef0aac25",
        );

        expect(publicKeyED25519.toString()).to.be.equal(ed25519StringKey);
    });

    it("ECDSA DER import test vectors", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        const PUBLIC_KEY_DER1 =
            "302d300706052b8104000a032200028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd";
        const PUBLIC_KEY1 =
            "028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd";

        const PUBLIC_KEY_DER2 =
            "3036301006072a8648ce3d020106052b8104000a032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";
        const PUBLIC_KEY2 =
            "036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";

        const PUBLIC_KEY_DER3 =
            "3056301006072a8648ce3d020106052b8104000a03420004aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a6597795f855ddcad2377e22259d1fcb4e0f1d35e8f2056300c15070bcbfce3759cc9d";
        const PUBLIC_KEY3 =
            "03aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a65977";

        const ecdsaPublicKey1 = PublicKey.fromString(PUBLIC_KEY_DER1);
        expect(ecdsaPublicKey1.toStringRaw()).to.be.equal(PUBLIC_KEY1);

        const ecdsaPublicKey2 = PublicKey.fromString(PUBLIC_KEY_DER2);
        expect(ecdsaPublicKey2.toStringRaw()).to.be.equal(PUBLIC_KEY2);

        const ecdsaPublicKey3 = PublicKey.fromString(PUBLIC_KEY_DER3);
        expect(ecdsaPublicKey3.toStringRaw()).to.be.equal(PUBLIC_KEY3);
    });

    it("ED25519 DER import test vectors", async function () {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        const PUBLIC_KEY_DER1 =
            "302a300506032b65700321008ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d";
        const PUBLIC_KEY1 =
            "8ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d";

        const ed25519PublicKey1 = PublicKey.fromString(PUBLIC_KEY_DER1);
        expect(ed25519PublicKey1.toStringRaw()).to.be.equal(PUBLIC_KEY1);
    });
});
// Filename: test/unit/RequestType.js
import * as HieroProto from "@hashgraph/proto";
import { RequestType } from "../../src/exports.js";

describe("RequestType", function () {
    it("has all the response codes", function () {
        for (const [s, code] of Object.entries(
            HieroProto.proto.HederaFunctionality,
        )) {
            expect(RequestType._fromCode(code).toString()).to.be.equal(s);
        }
    });
});
// Filename: test/unit/Serialize.js
import { expect } from "chai";

import {
    AccountId,
    Hbar,
    PrivateKey,
    Timestamp,
    Transaction,
    TransactionId,
    TransferTransaction,
} from "../../src/index.js";

import * as hex from "../../src/encoding/hex.js";

const PRIVATE_KEY1 =
    "302e020100300506032b657004220420ba0cc58a039afe36f3bd1f1c4ef44750268b35b5388dcae326752816da33be3f";
const PRIVATE_KEY2 =
    "302e020100300506032b6570042204202421c0faec4b8cb59214ed6c46e351637678d5b5cff811fd9855fa25b98519b6";
const SERIALIZED =
    "0ace022acb020a7a0a150a080880d4818e061000120708001000189a05180012060800100018071880c2d72f2202087832225472616e73616374696f6e202864652973657269616c697a6174696f6e2074657374722c0a2a0a130a080800100018c0c4071091a6afa5f80218000a130a080800100018f1f7271092a6afa5f802180012cc010a640a20d6868558baa9c23e2308ccc75a0f11176727a16cbb1e8312c2eb727cc517b1c91a403e0e34b9f2ad0655e6e6f7eae7e63175f8ba94d22b0be0085a839fdb8e3b9c796fc312c513fa4ec97bed4ba7741b9815a259fff444ff0ed2a2f0f1b530a9790b0a640a2036d767d5857eaf6a665886103f434464cd06ce56f00bf6b6b67ca0906350aea11a40071a4cee4bf1b8d9a5e79256f58d752ba3457f20c0da5639d1514fb21b5374c97e82a1c793e792f22e9777220163fc4c7e876ad62dd79385006e26c8bd0f2b05";

const params = {
    nodeId: AccountId.fromString("0.0.7"),
    operatorId: AccountId.fromString("0.0.666"),
    senderId: AccountId.fromString("0.0.123456"),
    recipientId: AccountId.fromString("0.0.654321"),
    validStart: Timestamp.fromDate(new Date(1640000000000)),
    amount: Hbar.fromTinybars("50505050505"),
    fee: Hbar.fromTinybars("100000000"),
    memo: "Transaction (de)serialization test",
};

function serialize(tx) {
    return hex.encode(tx.toBytes());
}

function deserialize(s) {
    return Transaction.fromBytes(hex.decode(s));
}

/**
 *
 * @param {Transaction} tx
 * @param {SignatureMap} privateKeyHex
 * @returns
 */
function sign(tx, privateKeyHex) {
    return PrivateKey.fromBytes(hex.decode(privateKeyHex)).signTransaction(tx);
}

function buildTx(params) {
    const transactionId = TransactionId.withValidStart(
        params.operatorId,
        params.validStart,
    );
    const unbuiltTx = new TransferTransaction()
        .setMaxTransactionFee(params.fee)
        .setTransactionId(transactionId)
        .setNodeAccountIds([params.nodeId])
        .setTransactionMemo(params.memo)
        .addHbarTransfer(params.senderId, params.amount.negated())
        .addHbarTransfer(params.recipientId, params.amount);
    return unbuiltTx.freeze();
}

describe("Mix signing and serialization", function () {
    it("Sign then serialize", function () {
        const tx = buildTx(params);
        sign(tx, PRIVATE_KEY1);
        sign(tx, PRIVATE_KEY2);
        const serialized = serialize(tx);
        expect(serialized).equals(SERIALIZED);
    });

    it("Call serialize before signing without using it", function () {
        const tx = buildTx(params);
        serialize(tx);
        sign(tx, PRIVATE_KEY1);
        sign(tx, PRIVATE_KEY2);
        const serialized = serialize(tx);
        expect(serialized).equals(SERIALIZED);
    });

    it("Call serialize between signing without using it", function () {
        const tx = buildTx(params);
        sign(tx, PRIVATE_KEY1);
        serialize(tx);
        sign(tx, PRIVATE_KEY2);
        const serialized = serialize(tx);
        expect(serialized).equals(SERIALIZED);
    });

    it("Serialize, deserialize then sign", function () {
        let tx = buildTx(params);
        tx = deserialize(serialize(tx));
        sign(tx, PRIVATE_KEY1);
        sign(tx, PRIVATE_KEY2);
        const serialized = serialize(tx);
        expect(serialized).equals(SERIALIZED);
    });

    it("Sign, serialize, deserialize then sign again", function () {
        let tx = buildTx(params);
        sign(tx, PRIVATE_KEY1);
        tx = deserialize(serialize(tx));
        sign(tx, PRIVATE_KEY2);
        const serialized = serialize(tx);
        expect(serialized).equals(SERIALIZED);
    });

    it("Sign then serialize, deserialize", function () {
        let tx = buildTx(params);
        sign(tx, PRIVATE_KEY1);
        sign(tx, PRIVATE_KEY2);
        tx = deserialize(serialize(tx));
        const serialized = serialize(tx);
        expect(serialized).equals(SERIALIZED);
    });
});
// Filename: test/unit/Status.js
import * as HieroProto from "@hashgraph/proto";
import { Status } from "../../src/exports.js";

describe("Status", function () {
    it("has all the response codes", function () {
        for (const [s, code] of Object.entries(
            HieroProto.proto.ResponseCodeEnum,
        )) {
            expect(Status._fromCode(code).toString()).to.be.equal(s);
        }
    });
});
// Filename: test/unit/Timestamp.js
import { Timestamp } from "../../src/index.js";

describe("Timestamp", function () {
    it("plusNanos works correctly", async function () {
        let timestamp = new Timestamp(0, 999999998);

        expect(timestamp.seconds.toInt()).to.be.eql(0);
        expect(timestamp.nanos.toInt()).to.be.eql(999999998);

        timestamp = timestamp.plusNanos(1);

        expect(timestamp.seconds.toInt()).to.be.eql(0);
        expect(timestamp.nanos.toInt()).to.be.eql(999999999);

        timestamp = timestamp.plusNanos(1);

        expect(timestamp.seconds.toInt()).to.be.eql(1);
        expect(timestamp.nanos.toInt()).to.be.eql(0);

        timestamp = timestamp.plusNanos(1);

        expect(timestamp.seconds.toInt()).to.be.eql(1);
        expect(timestamp.nanos.toInt()).to.be.eql(1);
    });

    it("fromDate()", function () {
        let timestamp = Timestamp.fromDate(999999998);

        expect(timestamp.seconds.toInt()).to.be.eql(0);
        expect(timestamp.nanos.toInt()).to.be.eql(999999998);
    });
});
// Filename: test/unit/TokenAirdropTransaction.js
import { expect } from "chai";
import {
    AccountId,
    TokenAirdropTransaction,
    NftId,
    TokenId,
} from "../../src/index.js";

describe("TokenAirdropTransaction", function () {
    it("from | toBytes", async function () {
        const SENDER = new AccountId(0, 0, 100);
        const RECEIVER = new AccountId(0, 0, 101);
        const TOKEN_IDS = [
            new TokenId(0, 0, 1),
            new TokenId(0, 0, 2),
            new TokenId(0, 0, 3),
            new TokenId(0, 0, 4),
        ];
        const NFT_IDS = [
            new NftId(TOKEN_IDS[0], 1),
            new NftId(TOKEN_IDS[0], 2),
        ];
        const AMOUNT = 1000;
        const EXPECTED_DECIMALS = 1;

        const transaction = new TokenAirdropTransaction()
            .addTokenTransfer(TOKEN_IDS[0], SENDER, AMOUNT)
            .addTokenTransferWithDecimals(
                TOKEN_IDS[1],
                SENDER,
                AMOUNT,
                EXPECTED_DECIMALS,
            )
            .addApprovedTokenTransfer(TOKEN_IDS[2], SENDER, AMOUNT)
            .addApprovedTokenTransferWithDecimals(
                TOKEN_IDS[3],
                SENDER,
                AMOUNT,
                EXPECTED_DECIMALS,
            )
            .addNftTransfer(NFT_IDS[0], SENDER, RECEIVER)
            .addApprovedNftTransfer(NFT_IDS[1], SENDER, RECEIVER);

        const txBytes = transaction.toBytes();
        const tx = TokenAirdropTransaction.fromBytes(txBytes);

        // normal token transfer
        const tokenNormalTransfer = tx._tokenTransfers[0];
        expect(tokenNormalTransfer.tokenId).to.deep.equal(TOKEN_IDS[0]);
        expect(tokenNormalTransfer.accountId).to.deep.equal(SENDER);
        expect(tokenNormalTransfer.amount.toInt()).to.equal(AMOUNT);

        // token transfer with decimals
        const tokenTransferWithDecimals = tx._tokenTransfers[1];
        expect(tokenTransferWithDecimals.tokenId).to.deep.equal(TOKEN_IDS[1]);
        expect(tokenTransferWithDecimals.accountId).to.deep.equal(SENDER);
        expect(tokenTransferWithDecimals.amount.toInt()).to.equal(AMOUNT);

        expect(tokenTransferWithDecimals.expectedDecimals).to.equal(
            EXPECTED_DECIMALS,
        );

        // approved token transfer
        const approvedTokenTransfer = tx._tokenTransfers[2];
        expect(approvedTokenTransfer.tokenId).to.deep.equal(TOKEN_IDS[2]);
        expect(approvedTokenTransfer.accountId).to.deep.equal(SENDER);
        expect(approvedTokenTransfer.amount.toInt()).to.equal(AMOUNT);
        expect(approvedTokenTransfer.isApproved).to.equal(true);

        // approved token transfer with decimals
        const approvedTokenTransferWithDecimals = tx._tokenTransfers[3];
        expect(approvedTokenTransferWithDecimals.tokenId).to.deep.equal(
            TOKEN_IDS[3],
        );
        expect(approvedTokenTransferWithDecimals.accountId).to.deep.equal(
            SENDER,
        );
        expect(approvedTokenTransferWithDecimals.amount.toInt()).to.equal(
            AMOUNT,
        );
        expect(approvedTokenTransferWithDecimals.isApproved).to.equal(true);
        expect(approvedTokenTransferWithDecimals.expectedDecimals).to.equal(
            EXPECTED_DECIMALS,
        );

        // nft transfer
        const nftTransfer = tx._nftTransfers[0];
        expect(nftTransfer.tokenId).to.deep.equal(NFT_IDS[0].tokenId);
        expect(nftTransfer.serialNumber).to.deep.equal(NFT_IDS[0].serial);
        expect(nftTransfer.senderAccountId).to.deep.equal(SENDER);
        expect(nftTransfer.receiverAccountId).to.deep.equal(RECEIVER);

        // approved nft transfer
        const approvedNftTransfer = tx._nftTransfers[1];
        expect(approvedNftTransfer.tokenId).to.deep.equal(NFT_IDS[1].tokenId);
        expect(approvedNftTransfer.serialNumber).to.deep.equal(
            NFT_IDS[1].serial,
        );
        expect(approvedNftTransfer.senderAccountId).to.deep.equal(SENDER);
        expect(approvedNftTransfer.receiverAccountId).to.deep.equal(RECEIVER);
        expect(approvedNftTransfer.isApproved).to.equal(true);
    });
});
// Filename: test/unit/TokenAllowance.js
import { expect } from "chai";

import { TokenAllowance, AccountId, TokenId } from "../../src/index.js";
import Long from "long";

describe("TokenAllowance", function () {
    it("toProtobuf()", function () {
        const ownerAccountId = new AccountId(3);
        const tokenId = new TokenId(1);
        const spenderAccountId = new AccountId(4);
        const tokenAmount = Long.fromNumber(100);

        const allowance = new TokenAllowance({
            ownerAccountId,
            tokenId,
            spenderAccountId,
            amount: tokenAmount,
        });

        expect(allowance._toProtobuf()).to.deep.equal({
            owner: ownerAccountId._toProtobuf(),
            tokenId: tokenId._toProtobuf(),
            spender: spenderAccountId._toProtobuf(),
            amount: tokenAmount,
        });
    });
});
// Filename: test/unit/TokenCreateTransaction.js
import {
    PrivateKey,
    Hbar,
    TokenCreateTransaction,
    TransactionId,
    AccountId,
    Timestamp,
} from "../../src/index.js";
import Long from "long";
import { DEFAULT_AUTO_RENEW_PERIOD } from "../../src/transaction/Transaction.js";

describe("TokenCreateTransaction", function () {
    it("encodes to correct protobuf", function () {
        const key1 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204205fc37fbd55631722b7ab5ec8e31696f6d3f818a15c5258a1529de7d4a1def6e2",
        );
        const key2 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420b5e15b70109fe6e11d1d6d06b20d27b494aa05a28a8bc84c627d9be66e179391",
        );
        const key3 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204202b5dc9915d5b6829592f4562a3d099e7b1bdd48da347e351da8d31cd41653016",
        );
        const key4 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204205a8571fe4badbc6bd76f03170f5ec4bdc69f2edb93f133477d0ef8f9e17a0f3a",
        );
        const key5 = PrivateKey.fromStringDer(
            "302e020100300506032b65700422042081c36f46db2bc4e7d993a23718a158c9fffa96719d7e72b3823d8bc9b973d596",
        );
        const key6 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420ff498f69b92ea43a0a8fd6e4a7036e5f8b5f23e527b0443bc309cc4ff5b75303",
        );
        const key7 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420542b4d4a318a1ae5f91071f34c8d900b1150e83d15fe71d22b8581e1203f99ad",
        );
        const key8 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204205447805ce906170817e2bd4e26f4ea1fd5bbc38a2532c7f66b7d7a24f60ee9d5",
        );
        const metadata = new Uint8Array([1, 2, 3, 4, 5]);
        const autoRenewAccountId = new AccountId(10);
        const treasuryAccountId = new AccountId(11);

        const expirationTime = new Timestamp(
            Math.floor(
                Date.now() / 1000 + DEFAULT_AUTO_RENEW_PERIOD.toNumber(),
            ),
            0,
        );

        const transaction = new TokenCreateTransaction()
            .setMaxTransactionFee(new Hbar(30))
            .setTransactionId(
                TransactionId.withValidStart(
                    new AccountId(1),
                    new Timestamp(2, 3),
                ),
            )
            .setTokenName("name")
            .setTokenSymbol("symbol")
            .setTokenMemo("memo")
            .setDecimals(7)
            .setTreasuryAccountId(treasuryAccountId)
            .setAutoRenewAccountId(autoRenewAccountId)
            .setExpirationTime(expirationTime)
            .setAdminKey(key1)
            .setKycKey(key2)
            .setFreezeKey(key3)
            .setPauseKey(key4)
            .setWipeKey(key5)
            .setSupplyKey(key6)
            .setFeeScheduleKey(key7)
            .setMetadata(metadata)
            .setMetadataKey(key8)
            .setNodeAccountIds([new AccountId(4)])
            .setTransactionMemo("random memo")
            .freeze();

        const protobuf = transaction._makeTransactionBody();

        expect(protobuf).to.deep.include({
            tokenCreation: {
                name: "name",
                symbol: "symbol",
                memo: "memo",
                supplyType: null,
                tokenType: null,
                maxSupply: null,
                initialSupply: null,
                freezeDefault: null,
                customFees: [],
                decimals: 7,
                autoRenewAccount: autoRenewAccountId._toProtobuf(),
                autoRenewPeriod: null,
                expiry: expirationTime._toProtobuf(),
                treasury: treasuryAccountId._toProtobuf(),
                adminKey: {
                    ed25519: key1.publicKey.toBytesRaw(),
                },
                kycKey: {
                    ed25519: key2.publicKey.toBytesRaw(),
                },
                freezeKey: {
                    ed25519: key3.publicKey.toBytesRaw(),
                },
                pauseKey: {
                    ed25519: key4.publicKey.toBytesRaw(),
                },
                wipeKey: {
                    ed25519: key5.publicKey.toBytesRaw(),
                },
                supplyKey: {
                    ed25519: key6.publicKey.toBytesRaw(),
                },
                feeScheduleKey: {
                    ed25519: key7.publicKey.toBytesRaw(),
                },
                metadata: metadata,
                metadataKey: {
                    ed25519: key8.publicKey.toBytesRaw(),
                },
            },
            transactionFee: new Hbar(30).toTinybars(),
            memo: "random memo",
            transactionID: {
                accountID: {
                    accountNum: Long.fromNumber(1),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                    alias: null,
                },
                transactionValidStart: {
                    seconds: Long.fromNumber(2),
                    nanos: 3,
                },
                scheduled: false,
                nonce: null,
            },
            nodeAccountID: null,
            transactionValidDuration: {
                seconds: Long.fromNumber(120),
            },
        });
    });
});
// Filename: test/unit/TokenNftAllowance.js
import { expect } from "chai";

import { TokenNftAllowance, TokenId, AccountId } from "../../src/index.js";
import Long from "long";

describe("TokenNftAllowance", function () {
    it("toProtobuf() with serial numbers", function () {
        const tokenId = new TokenId(1);
        const serial = Long.fromNumber(3);
        const spenderAccountId = new AccountId(4);
        const ownerAccountId = new AccountId(3);

        const allowance = new TokenNftAllowance({
            ownerAccountId,
            tokenId,
            spenderAccountId,
            serialNumbers: [serial],
            allSerials: false,
            delegatingSpender: null,
        });

        expect(allowance._toProtobuf()).to.deep.equal({
            owner: ownerAccountId._toProtobuf(),
            tokenId: tokenId._toProtobuf(),
            spender: spenderAccountId._toProtobuf(),
            serialNumbers: [serial],
            approvedForAll: null,
            delegatingSpender: null,
        });
    });

    it("toProtobuf() with no serial numbers", function () {
        const ownerAccountId = new AccountId(3);
        const tokenId = new TokenId(1);
        const spenderAccountId = new AccountId(4);

        const allowance = new TokenNftAllowance({
            ownerAccountId,
            tokenId,
            spenderAccountId,
            serialNumbers: null,
            allSerials: true,
            delegatingSpender: null,
        });

        expect(allowance._toProtobuf()).to.deep.equal({
            owner: ownerAccountId._toProtobuf(),
            tokenId: tokenId._toProtobuf(),
            spender: spenderAccountId._toProtobuf(),
            serialNumbers: null,
            approvedForAll: { value: true },
            delegatingSpender: null,
        });
    });
});
// Filename: test/unit/TokenPauseTransaction.js
import {
    TokenUnpauseTransaction,
    TransactionId,
    AccountId,
    Timestamp,
} from "../../src/index.js";
import Long from "long";

describe("TokenUnpauseTransaction", function () {
    it("encodes to correct protobuf", function () {
        const transaction = new TokenUnpauseTransaction()
            .setTransactionId(
                TransactionId.withValidStart(
                    new AccountId(1),
                    new Timestamp(2, 3),
                ),
            )
            .setNodeAccountIds([new AccountId(4)])
            .setTokenId("0.0.5")
            .setTransactionMemo("random memo")
            .freeze();

        const protobuf = transaction._makeTransactionBody();

        expect(protobuf).to.deep.include({
            tokenUnpause: {
                token: {
                    tokenNum: Long.fromNumber(5),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                },
            },
            transactionFee: Long.fromNumber(200000000),
            memo: "random memo",
            transactionID: {
                accountID: {
                    accountNum: Long.fromNumber(1),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                    alias: null,
                },
                transactionValidStart: {
                    seconds: Long.fromNumber(2),
                    nanos: 3,
                },
                scheduled: false,
                nonce: null,
            },
            nodeAccountID: null,
            transactionValidDuration: {
                seconds: Long.fromNumber(120),
            },
        });
    });
});
// Filename: test/unit/TokenRejectFlow.js
/* eslint-disable mocha/no-setup-in-describe */

import {
    AccountId,
    Client,
    NftId,
    TokenId,
    TokenRejectFlow,
} from "../../src/index.js";

describe("TokenRejectFlow", function () {
    let tokenIds = [
        TokenId.fromString("1.2.3"),
        TokenId.fromString("1.2.4"),
        TokenId.fromString("1.2.5"),
    ];

    let nftIds = [
        new NftId(tokenIds[0], 1),
        new NftId(tokenIds[1], 2),
        new NftId(tokenIds[2], 3),
    ];

    let tx;

    it("should set owner id", function () {
        const owner = new AccountId(1);
        tx = new TokenRejectFlow().setOwnerId(owner);
        expect(tx.ownerId.toString()).to.equal(owner.toString());
    });

    it("set owner id when frozen", async function () {
        const client = Client.forLocalNode();
        tx = new TokenRejectFlow().addNftId(nftIds[0]).freezeWith(client);

        let err = false;
        try {
            tx.setOwnerId(new AccountId(2));
        } catch (error) {
            err = true;
        }

        expect(err).to.equal(true);
    });

    it("should set token ids", function () {
        const tx = new TokenRejectFlow().setTokenIds(tokenIds);
        expect(tx.tokenIds).to.deep.equal(tokenIds);
    });

    it("should not be able to set token ids frozen", function () {
        const client = Client.forLocalNode();
        const tx = new TokenRejectFlow().setTokenIds().freezeWith(client);
        let err = false;
        try {
            tx.setTokenIds(tokenIds);
        } catch (error) {
            err = true;
        }

        expect(err).to.equal(true);
    });

    it("should be able to set token nft ids", function () {
        const tx = new TokenRejectFlow().setNftIds(nftIds);
        expect(tx.nftIds).to.deep.equal(nftIds);
    });

    it("should not be able to set nft ids frozen", function () {
        const client = Client.forLocalNode();
        const tx = new TokenRejectFlow().setNftIds().freezeWith(client);
        let err = false;
        try {
            tx.setNftIds(nftIds);
        } catch (error) {
            err = true;
        }

        expect(err).to.equal(true);
    });
});
// Filename: test/unit/TokenRejectTransaction.js
/* eslint-disable mocha/no-setup-in-describe */
import {
    AccountId,
    NftId,
    Timestamp,
    TokenId,
    TokenRejectTransaction,
    Transaction,
    TransactionId,
} from "../../src/index.js";

describe("Transaction", function () {
    const owner = new AccountId(1);
    const tokenIds = [new TokenId(2)];
    const nftId = new NftId(tokenIds[0], 3);

    it("encodes to correct protobuf", async function () {
        const owner = new AccountId(1);
        const tokenReject = new TokenRejectTransaction()
            .setOwnerId(owner)
            .setTokenIds(tokenIds)
            .setNftIds([nftId]);

        const protobuf = await tokenReject._makeTransactionData();
        expect(protobuf).to.deep.include({
            owner: owner._toProtobuf(),
            rejections: [
                {
                    fungibleToken: tokenIds[0]._toProtobuf(),
                },
                {
                    nft: nftId._toProtobuf(),
                },
            ],
        });
    });

    it("decodes from protobuf", async function () {
        const tx = new TokenRejectTransaction()
            .setOwnerId(owner)
            .setTokenIds(tokenIds)
            .setNftIds([nftId]);

        const decodedBackTx = Transaction.fromBytes(tx.toBytes());
        expect(tx.ownerId.toString()).to.equal(
            decodedBackTx.ownerId.toString(),
        );
        expect(tx.tokenIds.toString()).to.equal(
            decodedBackTx.tokenIds.toString(),
        );
        expect(tx.nftIds.toString()).to.equal(decodedBackTx.nftIds.toString());
    });

    it("should set owner id", function () {
        const owner = new AccountId(1);
        const tx = new TokenRejectTransaction().setOwnerId(owner);
        expect(tx.ownerId).to.equal(owner);
    });

    it("should revert when updating owner id while frozen", function () {
        const owner = new AccountId(1);
        const timestamp = new Timestamp(14, 15);

        const tx = new TokenRejectTransaction()
            .setTransactionId(TransactionId.withValidStart(owner, timestamp))
            .setNodeAccountIds([new AccountId(10, 11, 12)])
            .freeze();

        expect(() => tx.setOwnerId(new AccountId(2))).to.throw(
            "transaction is immutable; it has at least one signature or has been explicitly frozen",
        );
    });

    it("should set token ids", function () {
        const tokenIds = [new TokenId(1), new TokenId(2)];
        const tx = new TokenRejectTransaction().setTokenIds(tokenIds);
        expect(tx.tokenIds).to.deep.equal(tokenIds);
    });

    it("should revert when updating token ids when frozen", function () {
        const tokenIds = [new TokenId(1), new TokenId(2)];
        const owner = new AccountId(1);
        const timestamp = new Timestamp(14, 15);

        const tx = new TokenRejectTransaction()
            .setNodeAccountIds([new AccountId(10, 11, 12)])
            .setTransactionId(TransactionId.withValidStart(owner, timestamp))
            .freeze();
        expect(() => tx.setTokenIds(tokenIds)).to.throw(
            "transaction is immutable; it has at least one signature or has been explicitly frozen",
        );
    });

    it("should set nft ids", function () {
        const nftIds = [new NftId(1), new NftId(2)];
        const tx = new TokenRejectTransaction().setNftIds(nftIds);
        expect(tx.nftIds).to.deep.equal(nftIds);
    });

    it("should revert when updating nft ids when frozen", function () {
        const nftIds = [new NftId(1), new NftId(2)];
        const owner = new AccountId(1);
        const timestamp = new Timestamp(14, 15);

        const tx = new TokenRejectTransaction()
            .setNodeAccountIds([new AccountId(10, 11, 12)])
            .setTransactionId(TransactionId.withValidStart(owner, timestamp))
            .freeze();
        expect(() => tx.setNftIds(nftIds)).to.throw(
            "transaction is immutable; it has at least one signature or has been explicitly frozen",
        );
    });
});
// Filename: test/unit/TokenTransfer.js
import TokenTransfer from "../../src/token/TokenTransfer.js";

describe("TokenTransfer", function () {
    describe("_fromProtobuf with optional parameters", function () {
        it("should deserialize with expectedDecimals being null", function () {
            const transfer = new TokenTransfer({
                tokenId: "0.0.123",
                accountId: "0.0.456",
                amount: 100,
                expectedDecimals: null,
                isApproved: true,
            });

            const transfersProtobuf = [
                {
                    token: transfer.tokenId._toProtobuf(),
                    expectedDecimals: {},
                    transfers: [transfer._toProtobuf()],
                },
            ];

            const [transferFromProtobuf] =
                TokenTransfer._fromProtobuf(transfersProtobuf);

            expect(transferFromProtobuf.expectedDecimals).to.be.null;
        });
    });
});
// Filename: test/unit/TokenUnpauseTransaction.js
import {
    TokenPauseTransaction,
    TransactionId,
    AccountId,
    Timestamp,
} from "../../src/index.js";
import Long from "long";

describe("TokenPauseTransaction", function () {
    it("encodes to correct protobuf", function () {
        const transaction = new TokenPauseTransaction()
            .setTransactionId(
                TransactionId.withValidStart(
                    new AccountId(1),
                    new Timestamp(2, 3),
                ),
            )
            .setNodeAccountIds([new AccountId(4)])
            .setTokenId("0.0.5")
            .setTransactionMemo("random memo")
            .freeze();

        const protobuf = transaction._makeTransactionBody();

        expect(protobuf).to.deep.include({
            tokenPause: {
                token: {
                    tokenNum: Long.fromNumber(5),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                },
            },
            transactionFee: Long.fromNumber(200000000),
            memo: "random memo",
            transactionID: {
                accountID: {
                    accountNum: Long.fromNumber(1),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                    alias: null,
                },
                transactionValidStart: {
                    seconds: Long.fromNumber(2),
                    nanos: 3,
                },
                scheduled: false,
                nonce: null,
            },
            nodeAccountID: null,
            transactionValidDuration: {
                seconds: Long.fromNumber(120),
            },
        });
    });
});
// Filename: test/unit/TokenUpdateNftsTransaction.js
import { TokenUpdateNftsTransaction } from "../../src/index.js";
import TransactionId from "../../src/transaction/TransactionId.js";
import AccountId from "../../src/account/AccountId.js";

describe("TokenUpdateNftsTransaction", function () {
    it("should create from a protobuf", function () {
        const tokenId = "0.0.123";
        const serials = [1, 2, 3];
        const metadata = new Uint8Array([1, 2, 3]);

        /**
         * @type {HieroProto.proto.ITokenUpdateNftsTransactionBody}
         */
        const body = {
            tokenUpdateNfts: {
                token: { shardNum: 0, realmNum: 0, tokenNum: 123 },
                serialNumbers: serials,
                metadata: { value: metadata },
            },
        };

        const transactions = [{ body }];
        const signedTransactions = [{}];
        const transactionIds = [TransactionId.generate(new AccountId(1))];
        const nodeIds = [new AccountId(3)];
        const bodies = [body];

        const transaction = TokenUpdateNftsTransaction._fromProtobuf(
            transactions,
            signedTransactions,
            transactionIds,
            nodeIds,
            bodies,
        );

        expect(transaction._tokenId.toString()).to.eql(tokenId);
        expect(transaction._serialNumbers).to.eql(serials);
        expect(transaction._metadata).to.eql(metadata);
    });

    it("should _metadata equal to null", async function () {
        const tx = new TokenUpdateNftsTransaction();
        const tx2 = TokenUpdateNftsTransaction.fromBytes(tx.toBytes());

        expect(tx._metadata).to.be.null;
        expect(tx2._metadata).to.be.null;
    });
});
// Filename: test/unit/TokenUpdateTransaction.js
import {
    PrivateKey,
    TokenUpdateTransaction,
    TransactionId,
    AccountId,
    Timestamp,
    TokenKeyValidation,
} from "../../src/index.js";
import Long from "long";

describe("TokenUpdateTransaction", function () {
    it("encodes to correct protobuf", function () {
        const key1 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204205fc37fbd55631722b7ab5ec8e31696f6d3f818a15c5258a1529de7d4a1def6e2",
        );
        const key2 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420b5e15b70109fe6e11d1d6d06b20d27b494aa05a28a8bc84c627d9be66e179391",
        );
        const key3 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204202b5dc9915d5b6829592f4562a3d099e7b1bdd48da347e351da8d31cd41653016",
        );
        const key4 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204205a8571fe4badbc6bd76f03170f5ec4bdc69f2edb93f133477d0ef8f9e17a0f3a",
        );
        const key5 = PrivateKey.fromStringDer(
            "302e020100300506032b65700422042081c36f46db2bc4e7d993a23718a158c9fffa96719d7e72b3823d8bc9b973d596",
        );
        const key6 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420ff498f69b92ea43a0a8fd6e4a7036e5f8b5f23e527b0443bc309cc4ff5b75303",
        );
        const key7 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420542b4d4a318a1ae5f91071f34c8d900b1150e83d15fe71d22b8581e1203f99ad",
        );
        const key8 = PrivateKey.fromStringDer(
            "302e020100300506032b6570042204205447805ce906170817e2bd4e26f4ea1fd5bbc38a2532c7f66b7d7a24f60ee9d5",
        );
        const metadata = new Uint8Array([1, 2, 3, 4, 5]);
        const autoRenewAccountId = new AccountId(10);
        const treasuryAccountId = new AccountId(11);

        const transaction = new TokenUpdateTransaction()
            .setTransactionId(
                TransactionId.withValidStart(
                    new AccountId(1),
                    new Timestamp(2, 3),
                ),
            )
            .setTokenName("name")
            .setTokenSymbol("symbol")
            .setTokenMemo("memo")
            .setTreasuryAccountId(treasuryAccountId)
            .setAutoRenewAccountId(autoRenewAccountId)
            .setAdminKey(key1)
            .setKycKey(key2)
            .setFreezeKey(key3)
            .setPauseKey(key4)
            .setWipeKey(key5)
            .setSupplyKey(key6)
            .setFeeScheduleKey(key7)
            .setMetadata(metadata)
            .setMetadataKey(key8)
            .setNodeAccountIds([new AccountId(4)])
            .setTokenId("0.0.5")
            .setTransactionMemo("random memo")
            .freeze();

        const protobuf = transaction._makeTransactionBody();

        expect(protobuf).to.deep.include({
            tokenUpdate: {
                token: {
                    tokenNum: Long.fromNumber(5),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                },
                name: "name",
                symbol: "symbol",
                memo: {
                    value: "memo",
                },
                autoRenewAccount: autoRenewAccountId._toProtobuf(),
                autoRenewPeriod: null,
                expiry: null,
                treasury: treasuryAccountId._toProtobuf(),
                keyVerificationMode:
                    TokenKeyValidation.FullValidation.valueOf(),
                adminKey: {
                    ed25519: key1.publicKey.toBytesRaw(),
                },
                kycKey: {
                    ed25519: key2.publicKey.toBytesRaw(),
                },
                freezeKey: {
                    ed25519: key3.publicKey.toBytesRaw(),
                },
                pauseKey: {
                    ed25519: key4.publicKey.toBytesRaw(),
                },
                wipeKey: {
                    ed25519: key5.publicKey.toBytesRaw(),
                },
                supplyKey: {
                    ed25519: key6.publicKey.toBytesRaw(),
                },
                feeScheduleKey: {
                    ed25519: key7.publicKey.toBytesRaw(),
                },
                metadata: {
                    value: metadata,
                },
                metadataKey: {
                    ed25519: key8.publicKey.toBytesRaw(),
                },
            },
            transactionFee: Long.fromNumber(200000000),
            memo: "random memo",
            transactionID: {
                accountID: {
                    accountNum: Long.fromNumber(1),
                    shardNum: Long.fromNumber(0),
                    realmNum: Long.fromNumber(0),
                    alias: null,
                },
                transactionValidStart: {
                    seconds: Long.fromNumber(2),
                    nanos: 3,
                },
                scheduled: false,
                nonce: null,
            },
            nodeAccountID: null,
            transactionValidDuration: {
                seconds: Long.fromNumber(120),
            },
        });
    });

    it("all properties should be equal to their initial values", async function () {
        const tx = new TokenUpdateTransaction();
        const tx2 = TokenUpdateTransaction.fromBytes(tx.toBytes());

        expect(tx.tokenId).to.be.null;
        expect(tx.tokenName).to.be.null;
        expect(tx.tokenSymbol).to.be.null;
        expect(tx.treasuryAccountId).to.be.null;
        expect(tx.adminKey).to.be.null;
        expect(tx.kycKey).to.be.null;
        expect(tx.freezeKey).to.be.null;
        expect(tx.wipeKey).to.be.null;
        expect(tx.supplyKey).to.be.null;
        expect(tx.autoRenewAccountId).to.be.null;
        expect(tx.expirationTime).to.be.null;
        expect(tx.autoRenewPeriod).to.be.null;
        expect(tx.tokenMemo).to.be.null;
        expect(tx.feeScheduleKey).to.be.null;
        expect(tx.pauseKey).to.be.null;
        expect(tx.metadata).to.be.null;

        expect(tx2.tokenId).to.be.null;
        expect(tx2.tokenName).to.be.null;
        expect(tx2.tokenSymbol).to.be.null;
        expect(tx2.treasuryAccountId).to.be.null;
        expect(tx2.adminKey).to.be.null;
        expect(tx2.kycKey).to.be.null;
        expect(tx2.freezeKey).to.be.null;
        expect(tx2.wipeKey).to.be.null;
        expect(tx2.supplyKey).to.be.null;
        expect(tx2.autoRenewAccountId).to.be.null;
        expect(tx2.expirationTime).to.be.null;
        expect(tx2.autoRenewPeriod).to.be.null;
        expect(tx2.tokenMemo).to.be.null;
        expect(tx2.feeScheduleKey).to.be.null;
        expect(tx2.pauseKey).to.be.null;
        expect(tx2.metadata).to.be.null;
    });
});
// Filename: test/unit/TopicCreateTransaction.js
import { expect } from "chai";

import {
    TopicCreateTransaction,
    TokenId,
    CustomFixedFee,
    PrivateKey,
} from "../../src/index.js";

describe("TopicCreateTransaction", function () {
    describe("HIP-991: Permissionless revenue generating topics", function () {
        it("should set correct the fee schedule key", function () {
            const feeScheduleKey = PrivateKey.generateECDSA();
            const topicCreateTransaction =
                new TopicCreateTransaction().setFeeScheduleKey(feeScheduleKey);

            expect(
                topicCreateTransaction.getFeeScheduleKey().toString(),
            ).to.eql(feeScheduleKey.toString());
        });

        it("should set fee exempt keys", function () {
            const feeExemptKeys = [
                PrivateKey.generateECDSA(),
                PrivateKey.generateECDSA(),
            ];

            const topicCreateTransaction =
                new TopicCreateTransaction().setFeeExemptKeys(feeExemptKeys);

            feeExemptKeys.forEach((feeExemptKey, index) => {
                expect(
                    topicCreateTransaction.getFeeExemptKeys()[index].toString(),
                ).to.eql(feeExemptKey.toString());
            });
        });

        it("should add fee exempt key to empty list", function () {
            const feeExemptKeyToBeAdded = PrivateKey.generateECDSA();

            const topicCreateTransaction =
                new TopicCreateTransaction().addFeeExemptKey(
                    feeExemptKeyToBeAdded,
                );

            expect(feeExemptKeyToBeAdded.toString()).to.eql(
                topicCreateTransaction.getFeeExemptKeys()[0].toString(),
            );
        });

        it("should add fee exempt key to list", function () {
            const feeExemptKey = PrivateKey.generateECDSA();

            const topicCreateTransaction =
                new TopicCreateTransaction().setFeeExemptKeys([feeExemptKey]);

            const feeExemptKeyToBeAdded = PrivateKey.generateECDSA();

            topicCreateTransaction.addFeeExemptKey(feeExemptKeyToBeAdded);

            [feeExemptKey, feeExemptKeyToBeAdded].forEach(
                (feeExemptKey, index) => {
                    expect(
                        topicCreateTransaction
                            .getFeeExemptKeys()
                            // eslint-disable-next-line no-unexpected-multiline
                            [index].toString(),
                    ).to.eql(feeExemptKey.toString());
                },
            );
        });

        it("should set topic custom fees", function () {
            const customFixedFees = [
                new CustomFixedFee()
                    .setAmount(1)
                    .setDenominatingTokenId(new TokenId(0)),
                new CustomFixedFee()
                    .setAmount(2)
                    .setDenominatingTokenId(new TokenId(1)),
                new CustomFixedFee()
                    .setAmount(3)
                    .setDenominatingTokenId(new TokenId(2)),
            ];

            const topicCreateTransaction =
                new TopicCreateTransaction().setCustomFees(customFixedFees);

            customFixedFees.forEach((customFixedFee, index) => {
                expect(
                    topicCreateTransaction.getCustomFees()[index].amount,
                ).to.eql(customFixedFee.amount);
                expect(
                    topicCreateTransaction
                        .getCustomFees()
                        // eslint-disable-next-line no-unexpected-multiline
                        [index].denominatingTokenId.toString(),
                ).to.eql(customFixedFee.denominatingTokenId.toString());
            });
        });

        it("should add topic custom fee to list", function () {
            const customFixedFees = [
                new CustomFixedFee()
                    .setAmount(1)
                    .setDenominatingTokenId(new TokenId(0)),
                new CustomFixedFee()
                    .setAmount(2)
                    .setDenominatingTokenId(new TokenId(1)),
                new CustomFixedFee()
                    .setAmount(3)
                    .setDenominatingTokenId(new TokenId(2)),
            ];

            const customFixedFeeToBeAdded = new CustomFixedFee()
                .setAmount(4)
                .setDenominatingTokenId(new TokenId(3));

            const expectedCustomFees = [
                ...customFixedFees,
                customFixedFeeToBeAdded,
            ];

            const topicCreateTransaction =
                new TopicCreateTransaction().setCustomFees(customFixedFees);

            topicCreateTransaction.addCustomFee(customFixedFeeToBeAdded);

            expectedCustomFees.forEach((customFixedFee, index) => {
                expect(
                    topicCreateTransaction
                        .getCustomFees()
                        // eslint-disable-next-line no-unexpected-multiline
                        [index].amount.toString(),
                ).to.eql(customFixedFee.amount.toString());
                expect(
                    topicCreateTransaction
                        .getCustomFees()
                        // eslint-disable-next-line no-unexpected-multiline
                        [index].denominatingTokenId.toString(),
                ).to.eql(customFixedFee.denominatingTokenId.toString());
            });
        });

        it("should add topic custom fee to empty list", function () {
            const customFixedFeeToBeAdded = new CustomFixedFee()
                .setAmount(4)
                .setDenominatingTokenId(new TokenId(3));

            const topicCreateTransaction =
                new TopicCreateTransaction().addCustomFee(
                    customFixedFeeToBeAdded,
                );

            expect(topicCreateTransaction.getCustomFees().length).to.eql(1);
            expect(
                topicCreateTransaction.getCustomFees()[0].amount.toString(),
            ).to.eql(customFixedFeeToBeAdded.amount.toString());
            expect(
                topicCreateTransaction
                    .getCustomFees()[0]
                    .denominatingTokenId.toString(),
            ).to.eql(customFixedFeeToBeAdded.denominatingTokenId.toString());
        });
    });
});
// Filename: test/unit/TopicInfo.js
import { expect } from "chai";
import Duration from "../../src/Duration.js";
import {
    AccountId,
    CustomFixedFee,
    LedgerId,
    Long,
    PrivateKey,
    Timestamp,
    TokenId,
    TopicId,
    TopicInfo,
} from "../../src/index.js";

describe("TopicInfo", function () {
    it("encodes to correct protobuf", function () {
        const adminKey = PrivateKey.generateED25519();
        const submitKey = PrivateKey.generateED25519();
        const feeScheduleKey = PrivateKey.generateED25519();
        const feeExemptKeys = [
            PrivateKey.generateED25519(),
            PrivateKey.generateED25519(),
        ];

        const denominatingTokenId = new TokenId(0);
        const amount = 100;

        const customFees = [
            new CustomFixedFee({ denominatingTokenId, amount }),
        ];
        const autoRenewAccountId = new AccountId(1, 2, 3);
        const autoRenewPeriod = new Duration(123);
        const topicId = new TopicId(0);
        const topicMemo = "topic";
        const runningHash = Uint8Array.from([0]);
        const expirationTime = new Timestamp(123, 456);
        const sequenceNumber = 0;
        const ledgerId = LedgerId.MAINNET;

        const topicInfo = new TopicInfo({
            topicId,
            topicMemo,
            runningHash,
            sequenceNumber,
            expirationTime,
            adminKey,
            submitKey,
            feeScheduleKey,
            feeExemptKeys,
            customFees,
            autoRenewAccountId,
            autoRenewPeriod,
            ledgerId,
        });

        const expectedProtobuf = {
            topicID: topicId._toProtobuf(),
            topicInfo: {
                memo: topicMemo,
                runningHash: runningHash,
                sequenceNumber: sequenceNumber,
                expirationTime: expirationTime._toProtobuf(),
                adminKey: adminKey._toProtobufKey(),
                submitKey: submitKey._toProtobufKey(),
                feeScheduleKey: feeScheduleKey._toProtobufKey(),
                customFees: customFees.map((fee) => fee._toProtobuf()),
                feeExemptKeyList: feeExemptKeys.map((key) =>
                    key._toProtobufKey(),
                ),
                autoRenewAccount: autoRenewAccountId._toProtobuf(),
                autoRenewPeriod: autoRenewPeriod,
            },
        };

        expect(topicInfo._toProtobuf()).to.deep.equal(expectedProtobuf);
    });

    it("decodes from correct protobuf", function () {
        const adminKey = PrivateKey.generateED25519().publicKey;
        const submitKey = PrivateKey.generateED25519().publicKey;
        const feeScheduleKey = PrivateKey.generateED25519().publicKey;
        const feeExemptKeys = [
            PrivateKey.generateED25519().publicKey,
            PrivateKey.generateED25519().publicKey,
        ];
        const denominatingTokenId = new TokenId(0);
        const amount = 100;
        const customFees = [
            new CustomFixedFee({ denominatingTokenId, amount }),
        ];
        const autoRenewAccountId = new AccountId(1, 2, 3);
        const autoRenewPeriod = new Duration(123);
        const topicId = new TopicId(0);
        const topicMemo = "topic";
        const runningHash = Uint8Array.from([0]);
        const expirationTime = new Timestamp(123, 456);
        const sequenceNumber = Long.fromString("0");

        const expectedProtobuf = {
            topicID: topicId._toProtobuf(),
            topicInfo: {
                memo: topicMemo,
                runningHash: runningHash,
                sequenceNumber: sequenceNumber.toBytes(),
                expirationTime: expirationTime._toProtobuf(),
                adminKey: adminKey._toProtobufKey(),
                submitKey: submitKey._toProtobufKey(),
                feeScheduleKey: feeScheduleKey._toProtobufKey(),
                customFees: customFees.map((fee) => fee._toProtobuf()),
                feeExemptKeyList: feeExemptKeys.map((key) =>
                    key._toProtobufKey(),
                ),
                autoRenewAccount: autoRenewAccountId._toProtobuf(),
                autoRenewPeriod: autoRenewPeriod,
            },
        };

        const topicInfo = new TopicInfo({
            topicId,
            topicMemo,
            runningHash,
            sequenceNumber,
            expirationTime,
            adminKey,
            submitKey,
            feeScheduleKey,
            feeExemptKeys,
            customFees,
            autoRenewAccountId,
            autoRenewPeriod,
            ledgerId: null,
        });

        expect(TopicInfo._fromProtobuf(expectedProtobuf)).to.deep.equal(
            topicInfo,
        );
    });

    it("should decode/encode correctly", function () {
        const adminKey = PrivateKey.generateED25519().publicKey;
        const submitKey = PrivateKey.generateED25519().publicKey;
        const autoRenewAccountId = new AccountId(1, 2, 3);
        const autoRenewPeriod = new Duration(123);
        const topicId = new TopicId(0);
        const topicMemo = "topic";
        const runningHash = Uint8Array.from([0]);
        const expirationTime = new Timestamp(123, 456);
        const sequenceNumber = Long.fromString("0");

        const topicInfo = new TopicInfo({
            topicId,
            topicMemo,
            runningHash,
            sequenceNumber,
            expirationTime,
            adminKey,
            submitKey,
            autoRenewAccountId,
            autoRenewPeriod,
        });

        const topicInfoBytes = topicInfo.toBytes();
        const topicInfo2 = TopicInfo.fromBytes(topicInfoBytes);

        expect(topicInfo2.adminKey.toString()).to.eql(adminKey.toString());
        expect(topicInfo2.submitKey.toString()).to.eql(submitKey.toString());
        expect(topicInfo2.autoRenewAccountId.toString()).to.eql(
            autoRenewAccountId.toString(),
        );
        expect(topicInfo2.autoRenewPeriod.seconds.toInt()).to.eql(
            autoRenewPeriod.seconds.toInt(),
        );
        expect(topicInfo2.topicId.toString()).to.eql(topicId.toString());
        expect(topicInfo2.topicMemo).to.eql(topicMemo);
        expect(topicInfo2.runningHash).to.eql(runningHash);
        expect(topicInfo2.expirationTime.seconds).to.eql(
            expirationTime.seconds,
        );
        expect(topicInfo2.expirationTime.nanos).to.eql(expirationTime.nanos);
        expect(topicInfo2.sequenceNumber.toInt()).to.eql(
            sequenceNumber.toInt(),
        );
    });
});
// Filename: test/unit/TopicMessageMocking.js
import { expect } from "chai";
import Mocker from "./Mocker.js";
import * as hex from "../../src/encoding/hex.js";
import Long from "long";
import { TopicMessageQuery } from "../../src/index.js";

/**
 * @namespace com
 * @typedef {import("@hashgraph/proto").com.hedera.mirror.api.proto.IConsensusTopicResponse} com.hedera.mirror.api.proto.IConsensusTopicResponse
 */

/** @type {com.hedera.mirror.api.proto.IConsensusTopicResponse} */
const TOPIC_MESSAGE = {
    consensusTimestamp: {
        seconds: 100,
        nanos: 10,
    },
    message: hex.encode("11"),
    runningHash: hex.encode("22"),
    sequenceNumber: Long.fromNumber(3),
    runningHashVersion: Long.fromNumber(4),
    chunkInfo: null,
};

describe("TopicMessageMocking", function () {
    let client;
    let servers;
    let handle;

    afterEach(function () {
        client.close();
        servers.close();

        if (handle != null) {
            handle.unsubscribe();
        }
    });

    it("is able to receive messages", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [{ response: TOPIC_MESSAGE }],
        ]));

        let finished = false;

        handle = new TopicMessageQuery()
            .setTopicId("0.0.3")
            .setCompletionHandler(() => {
                finished = true;
            })
            .subscribe(client, () => {});

        const startTime = Date.now();

        while (!finished && Date.now() < startTime + 5000) {
            await new Promise((resolved) => setTimeout(resolved, 2000));
        }

        expect(finished).to.be.true;
    });

    it("should stop processing messages after unsubscription", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [{ response: TOPIC_MESSAGE }],
            [{ response: TOPIC_MESSAGE }],
        ]));

        let messageProcessed = false;

        handle = new TopicMessageQuery()
            .setTopicId("0.0.3")
            .subscribe(client, () => {
                messageProcessed = true;
            });

        handle.unsubscribe();

        const startTime = Date.now();

        while (!messageProcessed && Date.now() < startTime + 5000) {
            await new Promise((resolved) => setTimeout(resolved, 2000));
        }

        expect(messageProcessed).to.be.false;
    });
});
// Filename: test/unit/TopicMessageSubmitTransaction.js
import { expect } from "chai";

import {
    TopicMessageSubmitTransaction,
    AccountId,
    Timestamp,
    TransactionId,
    TopicId,
    CustomFixedFee,
    TokenId,
    CustomFeeLimit,
} from "../../src/index.js";

import * as utf8 from "../../src/encoding/utf8.js";
import * as util from "../../src/util.js";

describe("TopicMessageSubmitTransaction", function () {
    it("setMessage should throw error when passed no message", function () {
        const topicMessageSubmitTransaction =
            new TopicMessageSubmitTransaction();

        try {
            topicMessageSubmitTransaction.setMessage();
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }
    });

    it("setMessage should throw error when passed non string/Uint8Array message", function () {
        const message = { message: "this is an invalid message" };

        const topicMessageSubmitTransaction =
            new TopicMessageSubmitTransaction();

        try {
            topicMessageSubmitTransaction.setMessage(message);
        } catch (error) {
            expect(error.message).to.eql(
                util.REQUIRE_STRING_OR_UINT8ARRAY_ERROR,
            );
        }
    });

    it("setMessage should not throw error when passed valid string message", function () {
        const message = "this is a message";

        const topicMessageSubmitTransaction =
            new TopicMessageSubmitTransaction();

        topicMessageSubmitTransaction.setMessage(message);

        expect(utf8.decode(topicMessageSubmitTransaction.message)).to.eql(
            message,
        );
    });

    it("setMessage should not throw error when passed valid Uint8Array message", function () {
        const message = utf8.encode("this is a message");

        const topicMessageSubmitTransaction =
            new TopicMessageSubmitTransaction();

        topicMessageSubmitTransaction.setMessage(message);

        expect(topicMessageSubmitTransaction.message).to.eql(message);
    });

    it("setChunkSize()", function () {
        const spenderAccountId1 = new AccountId(7);
        const topicId = new TopicId(8);
        const nodeAccountId = new AccountId(10, 11, 12);
        const timestamp1 = new Timestamp(14, 15);

        let transaction = new TopicMessageSubmitTransaction()
            .setTransactionId(
                TransactionId.withValidStart(spenderAccountId1, timestamp1),
            )
            .setNodeAccountIds([nodeAccountId])
            .setTopicId(topicId)
            .setChunkSize(1)
            .setMessage("12345")
            .freeze();

        transaction._chunkInfo = { number: 1 };

        let data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            chunkInfo: { number: 1 },
            message: new Uint8Array([49]),
            topicID: topicId._toProtobuf(),
        });

        transaction._chunkInfo.number++;
        data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            chunkInfo: { number: 2 },
            message: new Uint8Array([50]),
            topicID: topicId._toProtobuf(),
        });

        transaction._chunkInfo.number++;
        data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            chunkInfo: { number: 3 },
            message: new Uint8Array([51]),
            topicID: topicId._toProtobuf(),
        });

        transaction._chunkInfo.number++;
        data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            chunkInfo: { number: 4 },
            message: new Uint8Array([52]),
            topicID: topicId._toProtobuf(),
        });

        transaction._chunkInfo.number++;
        data = transaction._makeTransactionData();

        expect(data).to.deep.equal({
            chunkInfo: { number: 5 },
            message: new Uint8Array([53]),
            topicID: topicId._toProtobuf(),
        });
    });

    describe("HIP-991: Permissionless revenue generating topics", function () {
        it("should set custom fee limits", function () {
            const customFeeLimits = [
                new CustomFeeLimit()
                    .setAccountId(new AccountId(1))
                    .setFees(
                        new CustomFixedFee()
                            .setAmount(1)
                            .setDenominatingTokenId(new TokenId(1)),
                    ),
                new CustomFeeLimit()
                    .setAccountId(new AccountId(2))
                    .setFees(
                        new CustomFixedFee()
                            .setAmount(2)
                            .setDenominatingTokenId(new TokenId(2)),
                    ),
            ];

            const topicMessageSubmitTransaction =
                new TopicMessageSubmitTransaction();

            topicMessageSubmitTransaction.setCustomFeeLimits(customFeeLimits);

            customFeeLimits.forEach((customFeeLimit, index) => {
                expect(
                    topicMessageSubmitTransaction.getCustomFeeLimits()[index],
                ).to.deep.equal(customFeeLimit);
            });
        });

        it("should add custom fee limit to a list", function () {
            const customFeeLimits = [
                new CustomFeeLimit()
                    .setAccountId(new AccountId(1))
                    .setFees(
                        new CustomFixedFee()
                            .setAmount(1)
                            .setDenominatingTokenId(new TokenId(1)),
                    ),
                new CustomFeeLimit()
                    .setAccountId(new AccountId(2))
                    .setFees(
                        new CustomFixedFee()
                            .setAmount(2)
                            .setDenominatingTokenId(new TokenId(2)),
                    ),
            ];

            const customFeeLimitToBeAdded = new CustomFeeLimit()
                .setAccountId(new AccountId(3))
                .setFees(
                    new CustomFixedFee()
                        .setAmount(3)
                        .setDenominatingTokenId(new TokenId(3)),
                );

            const expectedCustomFeeLimits = [
                ...customFeeLimits,
                customFeeLimitToBeAdded,
            ];

            const topicMessageSubmitTransaction =
                new TopicMessageSubmitTransaction();

            topicMessageSubmitTransaction.setCustomFeeLimits(customFeeLimits);

            topicMessageSubmitTransaction.addCustomFeeLimit(
                customFeeLimitToBeAdded,
            );

            expectedCustomFeeLimits.forEach((customFeeLimit, index) => {
                expect(
                    topicMessageSubmitTransaction.getCustomFeeLimits()[index],
                ).to.deep.equal(customFeeLimit);
            });
        });

        it("should add custom fee limit to an empty list", function () {
            const customFeeLimitToBeAdded = new CustomFeeLimit()
                .setAccountId(new AccountId(3))
                .setFees(
                    new CustomFixedFee()
                        .setAmount(3)
                        .setDenominatingTokenId(new TokenId(3)),
                );

            const topicMessageSubmitTransaction =
                new TopicMessageSubmitTransaction();

            topicMessageSubmitTransaction.addCustomFeeLimit(
                customFeeLimitToBeAdded,
            );

            expect(
                topicMessageSubmitTransaction.getCustomFeeLimits()[0],
            ).to.deep.equal(customFeeLimitToBeAdded);
        });
    });
});
// Filename: test/unit/TopicUpdateTransaction.js
import {
    CustomFixedFee,
    PrivateKey,
    TokenId,
    TopicUpdateTransaction,
} from "../../src/index.js";

describe("TopicUpdateTransaction", function () {
    describe("deserialization of optional parameters", function () {
        it("should deserialize with topicMemo being null", function () {
            const tx = new TopicUpdateTransaction();
            const tx2 = TopicUpdateTransaction.fromBytes(tx.toBytes());

            expect(tx.topicMemo).to.be.null;
            expect(tx2.topicMemo).to.be.null;
        });
    });

    describe("HIP-991: Permissionless revenue generating topics", function () {
        it("should set correct the fee schedule key", function () {
            const feeScheduleKey = PrivateKey.generateECDSA();
            const topicUpdateTransaction =
                new TopicUpdateTransaction().setFeeScheduleKey(feeScheduleKey);

            expect(
                topicUpdateTransaction.getFeeScheduleKey().toString(),
            ).to.eql(feeScheduleKey.toString());
        });

        it("should clear fee schedule key", function () {
            const feeScheduleKey = PrivateKey.generateECDSA();
            const topicUpdateTransaction =
                new TopicUpdateTransaction().setFeeScheduleKey(feeScheduleKey);

            topicUpdateTransaction.clearFeeScheduleKey();

            expect(topicUpdateTransaction.getFeeScheduleKey()).to.be.null;
        });

        it("should set fee exempt keys", function () {
            const feeExemptKeys = [
                PrivateKey.generateECDSA(),
                PrivateKey.generateECDSA(),
            ];

            const topicUpdateTransaction =
                new TopicUpdateTransaction().setFeeExemptKeys(feeExemptKeys);

            feeExemptKeys.forEach((feeExemptKey, index) => {
                expect(
                    topicUpdateTransaction.getFeeExemptKeys()[index].toString(),
                ).to.eql(feeExemptKey.toString());
            });
        });

        it("should add fee exempt key to empty list", function () {
            const feeExemptKeyToBeAdded = PrivateKey.generateECDSA();
            const topicUpdateTransaction =
                new TopicUpdateTransaction().addFeeExemptKey(
                    feeExemptKeyToBeAdded,
                );

            expect(feeExemptKeyToBeAdded.toString()).to.eql(
                topicUpdateTransaction.getFeeExemptKeys()[0].toString(),
            );
        });

        it("should add fee exempt key to list", function () {
            const feeExemptKey = PrivateKey.generateECDSA();
            const topicUpdateTransaction =
                new TopicUpdateTransaction().setFeeExemptKeys([feeExemptKey]);

            const feeExemptKeyToBeAdded = PrivateKey.generateECDSA();

            topicUpdateTransaction.addFeeExemptKey(feeExemptKeyToBeAdded);

            [feeExemptKey, feeExemptKeyToBeAdded].forEach(
                (feeExemptKey, index) => {
                    expect(
                        topicUpdateTransaction
                            .getFeeExemptKeys()
                            // eslint-disable-next-line no-unexpected-multiline
                            [index].toString(),
                    ).to.eql(feeExemptKey.toString());
                },
            );
        });

        it("should clear exempt key list", function () {
            const feeExemptKey = PrivateKey.generateECDSA();

            const topicUpdateTransaction =
                new TopicUpdateTransaction().setFeeExemptKeys([feeExemptKey]);

            topicUpdateTransaction.clearFeeExemptKeys();

            expect(topicUpdateTransaction.getFeeExemptKeys().length).to.eql(0);
        });

        it("should set topic custom fees", function () {
            const customFixedFees = [
                new CustomFixedFee()
                    .setAmount(1)
                    .setDenominatingTokenId(new TokenId(0)),
                new CustomFixedFee()
                    .setAmount(2)
                    .setDenominatingTokenId(new TokenId(1)),
                new CustomFixedFee()
                    .setAmount(3)
                    .setDenominatingTokenId(new TokenId(2)),
            ];

            const topicUpdateTransaction =
                new TopicUpdateTransaction().setCustomFees(customFixedFees);

            customFixedFees.forEach((customFixedFee, index) => {
                expect(
                    topicUpdateTransaction.getCustomFees()[index].amount,
                ).to.eql(customFixedFee.amount);
                expect(
                    topicUpdateTransaction
                        .getCustomFees()
                        // eslint-disable-next-line no-unexpected-multiline
                        [index].denominatingTokenId.toString(),
                ).to.eql(customFixedFee.denominatingTokenId.toString());
            });
        });

        it("should add topic custom fee to list", function () {
            const customFixedFees = [
                new CustomFixedFee()
                    .setAmount(1)
                    .setDenominatingTokenId(new TokenId(0)),
                new CustomFixedFee()
                    .setAmount(2)
                    .setDenominatingTokenId(new TokenId(1)),
                new CustomFixedFee()
                    .setAmount(3)
                    .setDenominatingTokenId(new TokenId(2)),
            ];

            const customFixedFeeToBeAdded = new CustomFixedFee()
                .setAmount(4)
                .setDenominatingTokenId(new TokenId(3));

            const expectedCustomFees = [
                ...customFixedFees,
                customFixedFeeToBeAdded,
            ];

            const topicUpdateTransaction =
                new TopicUpdateTransaction().setCustomFees(customFixedFees);

            topicUpdateTransaction.addCustomFee(customFixedFeeToBeAdded);

            expectedCustomFees.forEach((customFixedFee, index) => {
                expect(
                    topicUpdateTransaction
                        .getCustomFees()
                        // eslint-disable-next-line no-unexpected-multiline
                        [index].amount.toString(),
                ).to.eql(customFixedFee.amount.toString());
                expect(
                    topicUpdateTransaction
                        .getCustomFees()
                        // eslint-disable-next-line no-unexpected-multiline
                        [index].denominatingTokenId.toString(),
                ).to.eql(customFixedFee.denominatingTokenId.toString());
            });
        });

        it("should add topic custom fee to empty list", function () {
            const customFixedFeeToBeAdded = new CustomFixedFee()
                .setAmount(4)
                .setDenominatingTokenId(new TokenId(3));

            const topicUpdateTransaction =
                new TopicUpdateTransaction().addCustomFee(
                    customFixedFeeToBeAdded,
                );

            expect(topicUpdateTransaction.getCustomFees().length).to.eql(1);
            expect(
                topicUpdateTransaction.getCustomFees()[0].amount.toString(),
            ).to.eql(customFixedFeeToBeAdded.amount.toString());
            expect(
                topicUpdateTransaction
                    .getCustomFees()[0]
                    .denominatingTokenId.toString(),
            ).to.eql(customFixedFeeToBeAdded.denominatingTokenId.toString());
        });

        it("should clear topic fee list", function () {
            const customFixedFees = [
                new CustomFixedFee()
                    .setAmount(1)
                    .setDenominatingTokenId(new TokenId(0)),
                new CustomFixedFee()
                    .setAmount(2)
                    .setDenominatingTokenId(new TokenId(1)),
                new CustomFixedFee()
                    .setAmount(3)
                    .setDenominatingTokenId(new TokenId(2)),
            ];

            const topicUpdateTransaction =
                new TopicUpdateTransaction().setCustomFees(customFixedFees);

            topicUpdateTransaction.clearCustomFees();

            expect(topicUpdateTransaction.getCustomFees().length).to.eql(0);
        });
    });
});
// Filename: test/unit/Transaction.js
/* eslint-disable mocha/no-setup-in-describe */

import {
    AccountCreateTransaction,
    AccountId,
    FileCreateTransaction,
    Hbar,
    HbarUnit,
    PrivateKey,
    Timestamp,
    Transaction,
    TransactionId,
} from "../../src/index.js";
import * as hex from "../../src/encoding/hex.js";
import Client from "../../src/client/NodeClient.js";
import * as HieroProto from "@hashgraph/proto";
import Long from "long";
import BigNumber from "bignumber.js";
import SignatureMap from "../../src/transaction/SignatureMap.js";

describe("Transaction", function () {
    it("toBytes", async function () {
        const key = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420a58d361e61756ee809686255fda09bacb846ea8aa589c67ac39cfbcf82dd511c",
        );
        const account = AccountId.fromString("0.0.1004");
        const validStart = new Timestamp(1451, 590);
        const transactionId = new TransactionId(account, validStart);

        const hexBytes =
            "0adb012ad8010a6e0a130a0608ab0b10ce0412070800100018ec0718001206080010001803188084af5f2202087832005a440a2212206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc4830ffffffffffffffff7f38ffffffffffffffff7f40004a050880ceda0388010012660a640a206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc481a406f7b1823defed495205f67504243abd623bef1eb9dc4053b879b5e25fff382814172d0676464a6a5b7adfc7968ae8af236ac91fd751d632c0412b5f77431930d0adb012ad8010a6e0a130a0608ab0b10ce0412070800100018ec0718001206080010001804188084af5f2202087832005a440a2212206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc4830ffffffffffffffff7f38ffffffffffffffff7f40004a050880ceda0388010012660a640a206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc481a408d3fb2b8da90457cc447771361b0e27f784b70664604a5490a135595a69f2bbf2fd725a703174999d25f6f295cd58f116210dffefb94703c34fc8107be0a7908";

        const transaction = await new AccountCreateTransaction()
            .setKeyWithoutAlias(key)
            .setNodeAccountIds([new AccountId(3), new AccountId(4)])
            .setTransactionId(transactionId)
            .freeze()
            .sign(key);

        const transactionBytesHex = hex.encode(transaction.toBytes());
        expect(transactionBytesHex).to.eql(hexBytes);

        const transactionFromBytes = Transaction.fromBytes(
            transaction.toBytes(),
        );
        const transactionFromBytesToBytes = hex.encode(
            transactionFromBytes.toBytes(),
        );

        expect(transactionFromBytesToBytes).to.eql(hexBytes);
    });

    it("getTransactionHash", async function () {
        const hexHash =
            "c0a5795719f786f055d30c5881ea56165560cb6ab0615fc627d93dc7d4b6674b281dd826c4984aa868c97bd8bbf92178";

        const hexBytes =
            "0ad8012ad5010a6b0a130a0608ab0b10ce0412070800100018ec0718001206080010001803188084af5f2202087832005a410a2212206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc4830ffffffffffffffff7f38ffffffffffffffff7f40004a050880ceda0312660a640a206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc481a40adf8af54cee6bdd27d7fc40c992bb120daffad9a808aaf7900d44dae61313615b9cc692710bd1e872985ceecebcd7d75b662eb7a6a2853f53c8bac7bb9ec30020ad8012ad5010a6b0a130a0608ab0b10ce0412070800100018ec0718001206080010001804188084af5f2202087832005a410a2212206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc4830ffffffffffffffff7f38ffffffffffffffff7f40004a050880ceda0312660a640a206e0433faf04e8a674a114ed04d27bd43b0549a2ed69c9709a5a2058922c0cc481a40e9eeb92c37b44f6a1ee51ff573034cd8393066409575e758f99a13124adb897c0b354e23e949558898f7c4f0be59ddf4603f408247ccf9f003408df860d8070b";

        const transaction = Transaction.fromBytes(hex.decode(hexBytes));

        const hash = await transaction.getTransactionHash();

        expect(hexHash).to.be.equal(hex.encode(hash));
    });

    it("can decode raw protobuf transaction bytes", async function () {
        const hexBytes =
            "1acc010a640a2046fe5013b6f6fc796c3e65ec10d2a10d03c07188fc3de13d46caad6b8ec4dfb81a4045f1186be5746c9783f68cb71d6a71becd3ffb024906b855ac1fa3a2601273d41b58446e5d6a0aaf421c229885f9e70417353fab2ce6e9d8e7b162e9944e19020a640a20f102e75ff7dc3d72c9b7075bb246fcc54e714c59714814011e8f4b922d2a6f0a1a40f2e5f061349ab03fa21075020c75cf876d80498ae4bac767f35941b8e3c393b0e0a886ede328e44c1df7028ea1474722f2dcd493812d04db339480909076a10122500a180a0c08a1cc98830610c092d09e0312080800100018e4881d120608001000180418b293072202087872240a220a0f0a080800100018e4881d10ff83af5f0a0f0a080800100018eb881d108084af5f";

        const transaction = Transaction.fromBytes(hex.decode(hexBytes));

        expect(
            transaction.hbarTransfers
                .get(new AccountId(476260))
                .toTinybars()
                .toString(),
        ).to.be.equal(new Hbar(1).negated().toTinybars().toString());
        expect(
            transaction.hbarTransfers
                .get(new AccountId(476267))
                .toTinybars()
                .toString(),
        ).to.be.equal(new Hbar(1).toTinybars().toString());
    });

    it("sign", async function () {
        const key1 = PrivateKey.generateED25519();
        const key2 = PrivateKey.generateECDSA();

        const transaction = new AccountCreateTransaction()
            .setNodeAccountIds([new AccountId(6)])
            .setTransactionId(TransactionId.generate(new AccountId(7)))
            .freeze();

        await transaction.sign(key1);
        await transaction.sign(key2);

        expect(key1.publicKey.verifyTransaction(transaction)).to.be.true;
        expect(key2.publicKey.verifyTransaction(transaction)).to.be.true;

        const sigMap = transaction.getSignatures();
        expect(sigMap.size).to.be.equal(1);

        for (const [nodeAccountId, nodeSignatures] of sigMap) {
            const transactionSignatures = nodeSignatures.get(
                transaction.transactionId,
            );
            expect(nodeAccountId.toString()).equals("0.0.6");
            expect(transactionSignatures.size).to.be.equal(2);
            expect(transactionSignatures.get(key1.publicKey)).to.not.be.null;
            expect(transactionSignatures.get(key2.publicKey)).to.not.be.null;

            for (const [publicKey] of transactionSignatures) {
                expect(publicKey.verifyTransaction(transaction)).to.be.true;
            }
        }
    });

    it("sets max transaction fee", async function () {
        const nodeAccountId = new AccountId(3);
        const client = Client.forTestnet({
            scheduleNetworkUpdate: false,
        }).setDefaultMaxTransactionFee(Hbar.fromTinybars(1));

        const transaction = new FileCreateTransaction()
            .setNodeAccountIds([nodeAccountId])
            .setTransactionId(TransactionId.generate(nodeAccountId))
            .setContents("Hello world")
            .freezeWith(client);

        expect(transaction.maxTransactionFee.toTinybars().toInt()).to.be.equal(
            1,
        );
    });

    it("fromBytes fails when bodies differ", function () {
        const key1 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420a58d361e61756ee809686255fda09bacb846ea8aa589c67ac39cfbcf82dd511c",
        );
        const key2 = PrivateKey.fromStringDer(
            "302e020100300506032b657004220420a58d361e61756ee809686255fda09bacb846ea8aa589c67ac39cfbcf82dd511d",
        );

        const transactionID = TransactionId.withValidStart(
            new AccountId(9),
            new Timestamp(10, 11),
        );
        const nodeAccountID1 = new AccountId(3);
        const nodeAccountID2 = new AccountId(4);

        /** @type {proto.ITransactionBody} */
        const body1 = {
            transactionID: transactionID._toProtobuf(),
            nodeAccountID: nodeAccountID1._toProtobuf(),
            transactionFee: Long.fromNumber(1),
            transactionValidDuration: { seconds: 120 },
            cryptoCreateAccount: {
                key: key1.publicKey._toProtobufKey(),
            },
        };

        /** @type {proto.ITransactionBody} */
        const body2 = {
            transactionID: transactionID._toProtobuf(),
            nodeAccountID: nodeAccountID2._toProtobuf(),
            transactionFee: Long.fromNumber(1),
            transactionValidDuration: { seconds: 120 },
            cryptoCreateAccount: {
                key: key2.publicKey._toProtobufKey(),
            },
        };

        const bodyBytes1 =
            HieroProto.proto.TransactionBody.encode(body1).finish();
        const bodyBytes2 =
            HieroProto.proto.TransactionBody.encode(body2).finish();

        const signedTransaction1 = HieroProto.proto.SignedTransaction.encode({
            bodyBytes: bodyBytes1,
        }).finish();
        const signedTransaction2 = HieroProto.proto.SignedTransaction.encode({
            bodyBytes: bodyBytes2,
        }).finish();

        const transaction1 = { signedTransactionBytes: signedTransaction1 };
        const transaction2 = { signedTransactionBytes: signedTransaction2 };

        const list = HieroProto.proto.TransactionList.encode({
            transactionList: [transaction1, transaction2],
        }).finish();

        let err = false;

        try {
            Transaction.fromBytes(list);
        } catch (error) {
            err =
                error.toString() ===
                "Error: failed to validate transaction bodies";
        }

        if (!err) {
            throw new Error(
                "transaction successfully built from invalid bytes",
            );
        }
    });

    describe("balance must be the same before and after serialization/deserialization", function () {
        // Declare float number
        const FLOAT_NUMBER = 8.02341424;

        // Declare integer number from float number
        const INTEGER_NUMBER = Math.floor(FLOAT_NUMBER);

        // Declare diffrent number types
        const NUMBERS = {
            INTEGER: INTEGER_NUMBER,
            FLOAT: FLOAT_NUMBER,
        };
        const NUMBER_TYPES = Object.keys(NUMBERS);

        // Loop through different numbers
        NUMBER_TYPES.forEach((number_type) => {
            // Declare number
            const number = NUMBERS[number_type];
            const isNumberInteger = Number.isInteger(number);

            describe(`when ${number_type.toLowerCase()} number of ${number} is passed:`, function () {
                // Declare different types of parameter
                const PARAMETERS = {
                    STRING: `${number}`,
                    NUMBER: number,
                    LONG_NUMBER: Long.fromValue(number),
                    BIG_NUMBER: new BigNumber(number),
                    ...(isNumberInteger && {
                        HBAR: (unit) => Hbar.fromString(`${number}`, unit),
                    }),
                };
                const PARAMETERS_TYPES = Object.keys(PARAMETERS);

                // Loop through different parameter types
                PARAMETERS_TYPES.forEach((parameter_type) => {
                    // Declare parameter
                    const parameter = PARAMETERS[parameter_type];

                    // If the parameter is instance of Hbar then pass the unit
                    if (typeof parameter == "function") {
                        // Declare different units
                        const UNITS_NAMES = Object.keys(HbarUnit);
                        // Loop through different units
                        UNITS_NAMES.forEach((unit) => {
                            it(`as ${parameter_type
                                .split("_")
                                .join(" ")
                                .toLowerCase()} in ${unit}`, function () {
                                // Create transaction
                                const transaction =
                                    new AccountCreateTransaction();

                                // Set initial balance
                                transaction.setInitialBalance(
                                    parameter(HbarUnit[unit]),
                                );

                                // Serialize transaction
                                const transactionBytes = transaction.toBytes();

                                // Deserialize transaction
                                const transactionFromBytes =
                                    Transaction.fromBytes(transactionBytes);

                                // Compare balance before and after serialization/deserialization
                                expect(
                                    transaction.initialBalance.toString(
                                        HbarUnit[unit],
                                    ),
                                ).to.be.equal(
                                    transactionFromBytes.initialBalance.toString(
                                        HbarUnit[unit],
                                    ),
                                );
                            });
                        });
                    } else {
                        it(`as ${parameter_type
                            .split("_")
                            .join(" ")
                            .toLowerCase()}`, function () {
                            // Create transaction
                            const transaction = new AccountCreateTransaction();

                            // Set initial balance
                            transaction.setInitialBalance(parameter);

                            // Serialize transaction
                            const transactionBytes = transaction.toBytes();

                            // Deserialize transaction
                            const transactionFromBytes =
                                Transaction.fromBytes(transactionBytes);

                            // Compare balance before and after serialization/deserialization
                            expect(
                                transaction.initialBalance.toString(
                                    HbarUnit.Hbar,
                                ),
                            ).to.be.equal(
                                transactionFromBytes.initialBalance.toString(
                                    HbarUnit.Hbar,
                                ),
                            );
                        });
                    }
                });
            });
        });
    });

    describe("addSignature tests", function () {
        let transaction, nodeAccountIds, account, txId;

        beforeEach(function () {
            account = PrivateKey.generateED25519();
            nodeAccountIds = [new AccountId(3), new AccountId(4)];
            txId = TransactionId.generate(nodeAccountIds[0]);

            transaction = new AccountCreateTransaction()
                .setKeyWithoutAlias(account.publicKey)
                .setNodeAccountIds(nodeAccountIds)
                .setTransactionId(txId)
                .freeze();
        });

        it("should add a single signature when one transaction is present", async function () {
            const sigMap = new SignatureMap();
            const pubKey = account.publicKey;

            const signaturesArray = [];
            for (const tx of transaction._signedTransactions.list) {
                //                const sig = op.sign(txChunk.bodyBytes);
                const txBody = HieroProto.proto.TransactionBody.decode(
                    tx.bodyBytes,
                );
                const txId = TransactionId._fromProtobuf(txBody.transactionID);
                const nodeAccountId = AccountId._fromProtobuf(
                    txBody.nodeAccountID,
                );
                const sig = account.sign(tx.bodyBytes);
                sigMap.addSignature(nodeAccountId, txId, pubKey, sig);
                signaturesArray.push(sig);
            }

            transaction.addSignature(pubKey, sigMap);

            const sigPairMap = transaction
                .getSignatures()
                .getFlatSignatureList();

            expect(sigPairMap.length).to.equal(
                transaction._signedTransactions.length,
            );

            /*
             This works because the order of the signatures in the sigPairMap
             is the same as the order of the signatures in the transaction.
            */
            for (const sigPair of sigPairMap) {
                expect(sigPair.get(pubKey)).to.equal(signaturesArray.shift());
            }
        });
    });

    describe("Transaction removeSignature/removeAllSignatures methods", function () {
        let key1, key2, key3;
        let transaction, transactionId, nodeAccountId;

        beforeEach(async function () {
            const account = AccountId.fromString("0.0.1004");
            const validStart = new Timestamp(1451, 590);
            transactionId = new TransactionId(account, validStart);
            nodeAccountId = new AccountId(3);

            key1 = PrivateKey.generateED25519();
            key2 = PrivateKey.generateED25519();
            key3 = PrivateKey.generateED25519();

            transaction = new AccountCreateTransaction()
                .setInitialBalance(new Hbar(2))
                .setTransactionId(transactionId)
                .setNodeAccountIds([nodeAccountId])
                .freeze();
        });

        const signAndAddSignatures = (transaction, ...keys) => {
            for (const key of keys) {
                const sigMap = createSigmap(transaction, key);
                transaction.addSignature(key.publicKey, sigMap);
            }

            return transaction.getSignatures();
        };

        const createSigmap = (transaction, key) => {
            const sigMap = new SignatureMap();
            for (const tx of transaction._signedTransactions.list) {
                const txBody = HieroProto.proto.TransactionBody.decode(
                    tx.bodyBytes,
                );
                const txId = TransactionId._fromProtobuf(txBody.transactionID);
                const nodeAccountId = AccountId._fromProtobuf(
                    txBody.nodeAccountID,
                );
                const sig = key.sign(tx.bodyBytes);

                sigMap.addSignature(nodeAccountId, txId, key.publicKey, sig);
            }
            return sigMap;
        };

        it("should remove a specific signature", function () {
            // Sign the transaction with multiple keys
            signAndAddSignatures(transaction, key1);

            // console.log(transaction);

            //Check if the transaction internal tracking of signer public keys is correct
            expect(transaction._signerPublicKeys.size).to.equal(1);
            expect(transaction._publicKeys.length).to.equal(1);
            expect(transaction._transactionSigners.length).to.equal(1);

            // Ensure all signatures are present before removal
            const signaturesBefore = transaction
                .getSignatures()
                .getFlatSignatureList();

            expect(signaturesBefore.length).to.equal(1);

            // Remove one signature
            transaction.removeSignature(key1.publicKey);

            //Check if the transaction is frozen
            expect(transaction.isFrozen()).to.be.true;

            //Check if the transaction internal tracking of signer public keys is correct
            expect(transaction._signerPublicKeys.size).to.equal(0);
            expect(transaction._publicKeys.length).to.equal(0);
            expect(transaction._transactionSigners.length).to.equal(0);

            // Ensure the specific signature has been removed
            const signaturesAfter = transaction.getSignatures();
            expect(
                signaturesAfter
                    .get(new AccountId(3))
                    .get(transaction.transactionId).size,
            ).to.equal(0);
        });

        it("should clear all signatures", function () {
            // Sign the transaction with multiple keys
            signAndAddSignatures(transaction, key1, key2, key3);

            // Ensure all signatures are present before clearing
            const signaturesBefore = transaction.getSignatures();
            expect(
                signaturesBefore
                    .get(new AccountId(3))
                    .get(transaction.transactionId).size,
            ).to.equal(3);

            // Clear all signatures
            transaction.removeAllSignatures();

            //Check if the transaction is frozen
            expect(transaction.isFrozen()).to.be.true;

            //Check if the transaction internal tracking of signer public keys is cleared
            expect(transaction._signerPublicKeys.size).to.equal(0);
            expect(transaction._publicKeys.length).to.equal(0);
            expect(transaction._transactionSigners.length).to.equal(0);

            // Ensure all signatures have been cleared
            const signaturesAfter = transaction.getSignatures();
            expect(
                signaturesAfter
                    .get(new AccountId(3))
                    .get(transaction.transactionId).size,
            ).to.equal(0);
        });

        it("should not remove a non-existing signature", function () {
            // Sign the transaction with multiple keys
            signAndAddSignatures(transaction, key1, key2);

            // Attempt to remove a non-existing signature
            expect(() => {
                transaction.removeSignature(key3.publicKey);
            }).to.throw("The public key has not signed this transaction");

            // Ensure signatures are not affected
            const signaturesAfter = transaction
                .getSignatures()
                .get(new AccountId(3))
                .get(transaction.transactionId);
            expect(signaturesAfter.size).to.equal(2);
        });

        it("should clear and re-sign after all signatures are cleared", function () {
            // Sign the transaction with multiple keys
            signAndAddSignatures(transaction, key1, key2);

            // Ensure all signatures are present before clearing
            const signaturesBefore = transaction
                .getSignatures()
                .get(new AccountId(3))
                .get(transaction.transactionId);
            expect(signaturesBefore.size).to.equal(2);

            // Clear all signatures
            transaction.removeAllSignatures();

            // Ensure all signatures have been cleared
            const signaturesAfterClear = transaction
                .getSignatures()
                .get(new AccountId(3))
                .get(transaction.transactionId);
            expect(signaturesAfterClear.size).to.equal(0);

            // Re-sign the transaction with a different key
            const signature3 = key3.signTransaction(transaction);
            transaction.addSignature(key3.publicKey, signature3);

            // Ensure only one signature exists after re-signing
            const signaturesAfterResign = transaction.getSignatures();
            expect(signaturesAfterResign.get(new AccountId(3)).size).to.equal(
                1,
            );
        });

        it("should return the removed signature in Uint8Array format when removing a specific signature", function () {
            // Sign the transaction with multiple keys
            signAndAddSignatures(transaction, key1);

            // Remove one signature and capture the returned value
            const removedSignatures = transaction.removeSignature(
                key1.publicKey,
            );

            // Check the format of the returned value
            expect(removedSignatures).to.be.an("array");
            expect(removedSignatures.length).to.equal(1);
            expect(removedSignatures[0]).to.be.instanceOf(Uint8Array);
        });

        it("should return all removed signatures in the expected Map format when clearing all signatures", function () {
            // Sign the transaction with multiple keys
            signAndAddSignatures(transaction, key1, key2, key3);

            // Clear all signatures and capture the returned Map
            const removedSignatures = transaction.removeAllSignatures();

            // Check the format of the returned value
            expect(removedSignatures).to.be.instanceOf(Map);

            // Check if the Map contains keys using the toString() method
            const key1Exists = Array.from(removedSignatures.keys()).some(
                (key) => key.toString() === key1.publicKey.toString(),
            );
            const key2Exists = Array.from(removedSignatures.keys()).some(
                (key) => key.toString() === key2.publicKey.toString(),
            );
            const key3Exists = Array.from(removedSignatures.keys()).some(
                (key) => key.toString() === key3.publicKey.toString(),
            );

            // Assert that all keys exist
            expect(key1Exists).to.be.true;
            expect(key2Exists).to.be.true;
            expect(key3Exists).to.be.true;

            // Retrieve values using the keys and convert them to strings for comparison
            const signaturesArray1 = removedSignatures.get(
                Array.from(removedSignatures.keys()).find(
                    (key) => key.toString() === key1.publicKey.toString(),
                ),
            );

            const signaturesArray2 = removedSignatures.get(
                Array.from(removedSignatures.keys()).find(
                    (key) => key.toString() === key2.publicKey.toString(),
                ),
            );

            const signaturesArray3 = removedSignatures.get(
                Array.from(removedSignatures.keys()).find(
                    (key) => key.toString() === key3.publicKey.toString(),
                ),
            );

            // Validate that the retrieved arrays are present
            expect(signaturesArray1).to.be.an("array").that.is.not.empty;
            expect(signaturesArray2).to.be.an("array").that.is.not.empty;
            expect(signaturesArray3).to.be.an("array").that.is.not.empty;

            // Ensure the removed signatures are in the expected format
            [signaturesArray1, signaturesArray2, signaturesArray3].forEach(
                (signaturesArray) => {
                    signaturesArray.forEach((sig) => {
                        expect(sig).to.be.instanceOf(Uint8Array);
                    });
                },
            );
        });

        it("should return an empty object when no signatures are present", function () {
            expect(transaction._signerPublicKeys.size).to.equal(0);

            // Clear all signatures and capture the returned value
            const removedSignatures = transaction.removeAllSignatures();

            // Check the format of the returned value
            expect(removedSignatures).to.be.instanceOf(Map);
            expect(Object.keys(removedSignatures)).to.have.lengthOf(0);
        });

        it("should return an empty Map if transaction.sigMap is undefined", function () {
            transaction._signedTransactions.list = [1];

            const result = transaction.removeAllSignatures();
            expect(result).to.be.instanceOf(Map);
            expect(result.size).to.equal(0);
        });

        it("should return an empty Map if sigPair.pubKeyPrefix is undefined", function () {
            transaction._signedTransactions.list[0].sigMap = { sigPair: [1] };

            const result = transaction.removeAllSignatures();
            expect(result).to.be.instanceOf(Map);
            expect(result.size).to.equal(0);
        });
    });
});
// Filename: test/unit/TransactionId.js
import { expect } from "chai";

import { TransactionId, AccountId, Timestamp } from "../../src/index.js";
import Long from "long";

describe("TransactionId", function () {
    it("[to|from]Bytes()", function () {
        let transactionId = TransactionId.fromString("1.2.3@4.5/6");

        expect(
            TransactionId.fromBytes(transactionId.toBytes())._toProtobuf(),
        ).to.deep.equal({
            accountID: {
                shardNum: Long.fromNumber(1),
                realmNum: Long.fromNumber(2),
                accountNum: Long.fromNumber(3),
                alias: null,
            },
            transactionValidStart: {
                seconds: Long.fromNumber(4),
                nanos: 5,
            },
            scheduled: false,
            nonce: 6,
        });

        transactionId = TransactionId.fromString("1.2.3@4.5?scheduled/6");

        expect(
            TransactionId.fromBytes(transactionId.toBytes())._toProtobuf(),
        ).to.deep.equal({
            accountID: {
                shardNum: Long.fromNumber(1),
                realmNum: Long.fromNumber(2),
                accountNum: Long.fromNumber(3),
                alias: null,
            },
            transactionValidStart: {
                seconds: Long.fromNumber(4),
                nanos: 5,
            },
            scheduled: true,
            nonce: 6,
        });

        transactionId = TransactionId.fromString("1.2.3@4.5");

        expect(
            TransactionId.fromBytes(transactionId.toBytes())._toProtobuf(),
        ).to.deep.equal({
            accountID: {
                shardNum: Long.fromNumber(1),
                realmNum: Long.fromNumber(2),
                accountNum: Long.fromNumber(3),
                alias: null,
            },
            transactionValidStart: {
                seconds: Long.fromNumber(4),
                nanos: 5,
            },
            scheduled: false,
            nonce: null,
        });
    });

    it("should parse {shard}.{realm}.{num}@{seconds}.{nanos}", function () {
        const transactionId = TransactionId.fromString("1.2.3@4.5");

        expect(transactionId.toString()).to.be.equal("1.2.3@4.000000005");
    });

    it("should parse {num}@{seconds}.{nanos}", function () {
        const transactionId = TransactionId.fromString("3@4.5");

        expect(transactionId.toString()).to.be.equal("0.0.3@4.000000005");
    });

    it("should parse {shard}.{realm}.{num}@{seconds}.{nanos}?scheduled", function () {
        const transactionId = TransactionId.fromString("1.2.3@4.5?scheduled");

        expect(transactionId.toString()).to.be.equal(
            "1.2.3@4.000000005?scheduled",
        );
    });

    it("should parse {num}@{seconds}.{nanos}?scheduled", function () {
        const transactionId = TransactionId.fromString("3@4.5?scheduled");

        expect(transactionId.toString()).to.be.equal(
            "0.0.3@4.000000005?scheduled",
        );
    });

    it("should construct with nonce", function () {
        const accountId = AccountId.fromString("1.1.1");
        const validStart = new Timestamp(5, 4);
        const nonce = 117;
        const transactionId = new TransactionId(
            accountId,
            validStart,
            true,
            nonce,
        );

        expect(transactionId.toString().includes("/117")).to.be.true;
    });

    it("should construct with scheduled without nonce", function () {
        const accountId = AccountId.fromString("1.1.1");
        const validStart = new Timestamp(5, 4);
        let transactionId = new TransactionId(accountId, validStart, true);

        expect(transactionId.toString()).to.equal(
            "1.1.1@5.000000004?scheduled",
        );

        transactionId = new TransactionId(accountId, validStart, true, null);

        expect(transactionId.toString()).to.equal(
            "1.1.1@5.000000004?scheduled",
        );

        transactionId = new TransactionId(
            accountId,
            validStart,
            true,
            undefined,
        );

        expect(transactionId.toString()).to.equal(
            "1.1.1@5.000000004?scheduled",
        );
    });

    it("should construct with nonce without scheduled", function () {
        const accountId = AccountId.fromString("1.1.1");
        const validStart = new Timestamp(5, 4);
        const nonce = 117;
        let transactionId = new TransactionId(
            accountId,
            validStart,
            null,
            nonce,
        );

        expect(transactionId.toString()).to.equal("1.1.1@5.000000004/117");

        transactionId = new TransactionId(accountId, validStart, NaN, nonce);

        expect(transactionId.toString()).to.equal("1.1.1@5.000000004/117");

        transactionId = new TransactionId(
            accountId,
            validStart,
            undefined,
            nonce,
        );

        expect(transactionId.toString()).to.equal("1.1.1@5.000000004/117");
    });

    it("should construct without scheduled and nonce", function () {
        const accountId = AccountId.fromString("1.1.1");
        const validStart = new Timestamp(5, 4);
        let transactionId = new TransactionId(
            accountId,
            validStart,
            null,
            null,
        );

        expect(transactionId.toString()).to.equal("1.1.1@5.000000004");

        transactionId = new TransactionId(
            accountId,
            validStart,
            undefined,
            undefined,
        );

        expect(transactionId.toString()).to.equal("1.1.1@5.000000004");
    });

    it("should construct fromString", function () {
        let stringId = "1.1.1@5.4?scheduled/117";
        let transactionId = TransactionId.fromString(stringId).toString();

        expect(transactionId).to.eql("1.1.1@5.000000004?scheduled/117");
    });

    it("should construct fromString without nonce", function () {
        let stringId = "1.1.1@5.4?scheduled";
        let transactionId = TransactionId.fromString(stringId).toString();

        expect(transactionId).to.eql("1.1.1@5.000000004?scheduled");
    });

    it("should construct fromString without scheduled", function () {
        let stringId = "1.1.1@5.4/117";
        let transactionId = TransactionId.fromString(stringId).toString();

        expect(transactionId).to.eql("1.1.1@5.000000004/117");
    });

    it("should construct fromString without nonce and scheduled", function () {
        let stringId = "1.1.1@5.4";
        let transactionId = TransactionId.fromString(stringId).toString();

        expect(transactionId).to.eql("1.1.1@5.000000004");
    });

    it("should be able to update nonce with a number or date", function () {
        let stringId = "1.1.1@5.4";
        const transactionId = TransactionId.fromString(stringId);
        let nonceToSet = Number(1657293681585);
        let secondNonceToSet = new Date(1657293681585);

        try {
            transactionId.setNonce(nonceToSet);
        } catch (err) {
            throw new Error("Unable to set nonce for number: " + err);
        }

        expect(parseInt(transactionId.nonce)).equals(nonceToSet);

        try {
            transactionId.setNonce(secondNonceToSet);
        } catch (err) {
            throw new Error("Unable to set nonce for number: " + err);
        }

        expect(new Date(transactionId.nonce).getTime()).equals(
            secondNonceToSet.getTime(),
        );
    });
});
// Filename: test/unit/TransactionReceipt.js
import { expect } from "chai";

import {
    AccountId,
    ContractId,
    ExchangeRate,
    ExchangeRates,
    FileId,
    ScheduleId,
    Status,
    Timestamp,
    TokenId,
    TopicId,
    TransactionId,
    TransactionReceipt,
} from "../../src/index.js";
import Long from "long";

describe("TransactionReceipt", function () {
    it("[from|to]Bytes()", function () {
        const status = Status.Ok;
        const accountId = AccountId.fromString("0.0.1");
        const fileId = FileId.fromString("0.0.2");
        const contractId = ContractId.fromString("0.0.3");
        const topicId = TopicId.fromString("0.0.3");
        const tokenId = TokenId.fromString("0.0.4");
        const scheduleId = ScheduleId.fromString("0.0.5");
        const exchangeRate = new ExchangeRate({
            hbars: 3,
            cents: 4,
            expirationTime: new Date(5),
        });
        const nextExchangeRate = new ExchangeRate({
            hbars: 6,
            cents: 7,
            expirationTime: new Date(8),
        });
        const exchangeRateSet = new ExchangeRates({
            currentRate: exchangeRate,
            nextRate: nextExchangeRate,
        });

        const topicSequenceNumber = Long.fromNumber(9);
        const topicRunningHash = new Uint8Array([10]);
        const totalSupply = Long.fromNumber(11);
        const scheduledTransactionId = TransactionId.withValidStart(
            AccountId.fromString("0.0.12"),
            new Timestamp(13, 14),
        );
        const serials = [Long.fromNumber(15)];

        const receipt = TransactionReceipt.fromBytes(
            new TransactionReceipt({
                status,
                accountId,
                fileId,
                contractId,
                topicId,
                tokenId,
                scheduleId,
                exchangeRate,
                nextExchangeRate,
                topicSequenceNumber,
                topicRunningHash,
                totalSupply,
                scheduledTransactionId,
                serials,
                duplicates: [],
                children: [],
            }).toBytes(),
        )._toProtobuf();

        expect(receipt.receipt.status).to.deep.equal(status._code);
        expect(receipt.receipt.accountID).to.deep.equal(
            accountId._toProtobuf(),
        );
        expect(receipt.receipt.contractID).to.deep.equal(
            contractId._toProtobuf(),
        );
        expect(receipt.receipt.fileID).to.deep.equal(fileId._toProtobuf());
        expect(receipt.receipt.scheduleID).to.deep.equal(
            scheduleId._toProtobuf(),
        );
        expect(receipt.receipt.tokenID).to.deep.equal(tokenId._toProtobuf());
        expect(receipt.receipt.topicID).to.deep.equal(topicId._toProtobuf());
        expect(receipt.receipt.topicRunningHash).to.deep.equal(
            topicRunningHash,
        );
        expect(receipt.receipt.topicSequenceNumber).to.deep.equal(
            topicSequenceNumber,
        );
        expect(receipt.receipt.exchangeRate).to.deep.equal(
            exchangeRateSet._toProtobuf(),
        );
        expect(receipt.receipt.scheduledTransactionID).to.deep.equal(
            scheduledTransactionId._toProtobuf(),
        );
        expect(receipt.receipt.serialNumbers).to.deep.equal(serials);
        expect(receipt.receipt.newTotalSupply).to.deep.equal(totalSupply);
        expect(receipt.duplicateTransactionReceipts).to.deep.equal([]);
        expect(receipt.childTransactionReceipts).to.deep.equal([]);
    });

    it("toJSON()", function () {
        const status = Status.Ok;
        const accountId = AccountId.fromString("0.0.1");
        const fileId = FileId.fromString("0.0.2");
        const contractId = ContractId.fromString("0.0.3");
        const topicId = TopicId.fromString("0.0.3");
        const tokenId = TokenId.fromString("0.0.4");
        const scheduleId = ScheduleId.fromString("0.0.5");
        const exchangeRate = new ExchangeRate({
            hbars: 6,
            cents: 7,
            expirationTime: new Date(Date.parse("1973-11-25T17:31:44.000Z")),
        });
        const nextExchangeRate = new ExchangeRate({
            hbars: 2,
            cents: 1,
            expirationTime: new Date(Date.parse("1973-11-25T17:31:44.000Z")),
        });
        const topicSequenceNumber = Long.fromNumber(9);
        const topicRunningHash = new Uint8Array([10]);
        const totalSupply = Long.fromNumber(11);
        const scheduledTransactionId = TransactionId.withValidStart(
            AccountId.fromString("0.0.12"),
            new Timestamp(13, 14),
        );
        const serials = [Long.fromNumber(15)];
        const nodeId = Long.fromNumber(1234);

        const receipt = new TransactionReceipt({
            status,
            accountId,
            fileId,
            contractId,
            topicId,
            tokenId,
            scheduleId,
            exchangeRate,
            nextExchangeRate,
            topicSequenceNumber,
            topicRunningHash,
            totalSupply,
            scheduledTransactionId,
            serials,
            duplicates: [],
            children: [],
            nodeId,
        });
        const child = new TransactionReceipt({
            status,
            accountId,
            fileId,
            contractId,
            topicId,
        });
        receipt.children.push(child);
        receipt.duplicates.push(child);

        const expectedJSON = JSON.parse(
            `{"status":"OK","accountId":"0.0.1","filedId":"0.0.2","contractId":"0.0.3","topicId":"0.0.3","tokenId":"0.0.4","scheduleId":"0.0.5","exchangeRate":{"hbars":6,"cents":7,"expirationTime":"1973-11-25T17:31:44.000Z","exchangeRateInCents":1.1666666666666667},"nextExchangeRate":{"hbars":2,"cents":1,"expirationTime":"1973-11-25T17:31:44.000Z","exchangeRateInCents":0.5},"topicSequenceNumber":"9","topicRunningHash":"0a","totalSupply":"11","scheduledTransactionId":"0.0.12@13.000000014","serials":["15"],"duplicates":[{"status":"OK","accountId":"0.0.1","filedId":"0.0.2","contractId":"0.0.3","topicId":"0.0.3","tokenId":null,"scheduleId":null,"exchangeRate":null,"nextExchangeRate":null,"topicSequenceNumber":null,"topicRunningHash":null,"totalSupply":null,"scheduledTransactionId":null,"serials":[],"duplicates":[],"children":[],"nodeId":null}],"children":[{"status":"OK","accountId":"0.0.1","filedId":"0.0.2","contractId":"0.0.3","topicId":"0.0.3","tokenId":null,"scheduleId":null,"exchangeRate":null,"nextExchangeRate":null,"topicSequenceNumber":null,"topicRunningHash":null,"totalSupply":null,"scheduledTransactionId":null,"serials":[],"duplicates":[],"children":[],"nodeId":null}],"nodeId":"1234"}`,
        );

        const resultJSON = JSON.parse(JSON.stringify(receipt));
        expect(resultJSON).to.deep.equal(expectedJSON);
    });

    it("toJSON() with missing fields", function () {
        const status = Status.Ok;
        const receipt = new TransactionReceipt({
            status,
        });

        const expectedJSON = `{"status":"OK","accountId":null,"filedId":null,"contractId":null,"topicId":null,"tokenId":null,"scheduleId":null,"exchangeRate":null,"nextExchangeRate":null,"topicSequenceNumber":null,"topicRunningHash":null,"totalSupply":null,"scheduledTransactionId":null,"serials":[],"duplicates":[],"children":[],"nodeId":null}`;
        const expectedJSONParsed = JSON.parse(expectedJSON);

        const resultJSON = JSON.parse(JSON.stringify(receipt));
        expect(resultJSON).to.deep.equal(expectedJSONParsed);
    });
});
// Filename: test/unit/TransactionReceiptMocking.js
import { expect } from "chai";
import { TransactionReceiptQuery, Status } from "../../src/index.js";
import Mocker from "./Mocker.js";
import Long from "long";

const ACCOUNT_ID = {
    shardNum: Long.ZERO,
    realmNum: Long.ZERO,
    accountNum: Long.fromNumber(10),
};

const TRANSACTION_RECEIPT_QUERY_RECEIPT_NOT_FOUND_RESPONSE = {
    transactionGetReceipt: {
        header: { nodeTransactionPrecheckCode: 18 },
    },
};

const TRANSACTION_RECEIPT_QUERY_RECEIPT_INVALID_SIGNATURE_RESPONSE = {
    transactionGetReceipt: {
        header: { nodeTransactionPrecheckCode: 0 },
        receipt: {
            status: 7,
        },
    },
};

const TRANSACTION_RECEIPT_QUERY_RECEIPT_RESPONSE = {
    transactionGetReceipt: {
        header: { nodeTransactionPrecheckCode: 0 },
        receipt: {
            status: 7,
            accountId: ACCOUNT_ID,
        },
    },
};

describe("TransactionReceiptMocking", function () {
    let client;
    let servers;

    afterEach(function () {
        client.close();
        servers.close();
    });

    it("should error with max attempts", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    response:
                        TRANSACTION_RECEIPT_QUERY_RECEIPT_NOT_FOUND_RESPONSE,
                },
                {
                    response:
                        TRANSACTION_RECEIPT_QUERY_RECEIPT_NOT_FOUND_RESPONSE,
                },
            ],
        ]));

        let err = false;

        try {
            await new TransactionReceiptQuery()
                .setTransactionId("0.0.3@4.5")
                .setMaxAttempts(2)
                .execute(client);
        } catch (error) {
            err =
                error.message ===
                "max attempts of 2 was reached for request with last error being: RECEIPT_NOT_FOUND";
        }

        expect(err).to.be.true;
    });

    it("should error with transaction ID in the message instead of payment transaction ID", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    response: TRANSACTION_RECEIPT_QUERY_RECEIPT_RESPONSE,
                },
            ],
        ]));

        let err = false;

        try {
            await new TransactionReceiptQuery()
                .setTransactionId("0.0.3@4.5")
                .execute(client);
        } catch (error) {
            err =
                error.message ===
                "receipt for transaction 0.0.3@4.000000005 contained error status INVALID_SIGNATURE";
        }

        expect(err).to.be.true;
    });

    it("should not error if validate status is disabled", async function () {
        ({ client, servers } = await Mocker.withResponses([
            [
                {
                    response:
                        TRANSACTION_RECEIPT_QUERY_RECEIPT_INVALID_SIGNATURE_RESPONSE,
                },
            ],
        ]));

        const receipt = await new TransactionReceiptQuery()
            .setTransactionId("0.0.3@4.5")
            .setValidateStatus(false)
            .execute(client);

        expect(receipt.status.toString()).to.be.equal(
            Status.InvalidSignature.toString(),
        );
    });
});
// Filename: test/unit/TransactionRecord.js
import { expect } from "chai";

import {
    AssessedCustomFee,
    ScheduleId,
    EvmAddress,
    PublicKey,
    TransactionRecord,
    AccountId,
    TokenId,
} from "../../src/index.js";
import TokenTransfer from "../../src/token/TokenTransfer.js";
import TokenAssociation from "../../src/token/TokenAssociation.js";
import TokenTransferMap from "../../src/account/TokenTransferMap.js";
import TokenNFTTransferMap from "../../src/account/TokenNftTransferMap.js";
import * as hex from "../../src/encoding/hex.js";

const HEX_BYTES =
    "1a93020a3b081612070800100018de092a260a110801100c1a0b0880ae99a4ffffffffff0112110801100f1a0b08c0bd98a4ffffffffff0138004200580078001230cac44f2db045ba441f3fbc295217f2eb0f956293d28b3401578f6160e66f4e47ea87952d91c4b1cb5bda6447823b979a1a0c08f3fcb495061083d9be900322190a0c08e8fcb495061098f09cf20112070800100018850918002a0030bee8f013526c0a0f0a0608001000180510d0df820118000a0f0a0608001000186210f08dff1e18000a100a070800100018a00610def1ef0318000a100a070800100018a10610def1ef0318000a110a070800100018850910fbf8b7e10718000a110a070800100018de091080a8d6b90718008a0100aa0100";

describe("TransactionRecord", function () {
    it("[from|to]Bytes()", function () {
        const record = TransactionRecord.fromBytes(hex.decode(HEX_BYTES));
        expect(hex.encode(record.toBytes())).to.equal(HEX_BYTES);
    });

    it("toJSON()", function () {
        const record = TransactionRecord.fromBytes(hex.decode(HEX_BYTES));
        const accID = AccountId.fromString("0.0.1246");
        const tokenID = TokenId.fromString("0.0.123");

        const tokenTransferMap = new TokenTransferMap();
        tokenTransferMap.__set(tokenID, accID, 789);

        const nftTransferMap = new TokenNFTTransferMap();
        nftTransferMap.__set(tokenID, {
            sender: accID,
            recipient: accID,
            serial: 123,
            isApproved: true,
        });

        const assessedCustomFee = new AssessedCustomFee({
            tokenId: tokenID,
            feeCollectorAccountId: accID,
            amount: 789,
            payerAccountIds: [accID],
        });

        const tokenAssociation = new TokenAssociation({
            tokenId: tokenID,
            accountId: accID,
        });

        const tokenTransfer = new TokenTransfer({
            tokenId: tokenID,
            accountId: accID,
            amount: 789,
        });

        const newRecord = new TransactionRecord({
            ...record,
            transactionMemo: "test",
            tokenTransfers: tokenTransferMap,
            nftTransfers: nftTransferMap,
            parentConsensusTimestamp: record.consensusTimestamp,
            aliasKey: PublicKey.fromString(
                "302a300506032b6570032100d7366c45e4d2f1a6c1d9af054f5ef8edc0b8d3875ba5d08a7f2e81ee8876e9e8",
            ),
            ethereumHash: Uint8Array.from([1, 2, 3, 4]),
            paidStakingRewards: record.transfers,
            prngBytes: Uint8Array.from([1, 2, 3, 4]),
            prngNumber: 123,
            evmAddress: EvmAddress.fromString("0xdeadbeef"),
            scheduleRef: ScheduleId.fromString("0.0.123"),
            assessedCustomFees: [assessedCustomFee],
            automaticTokenAssociations: [tokenAssociation],
            tokenTransfersList: [tokenTransfer],
        });

        const expectedJSON = JSON.parse(
            `{"receipt":{"status":"SUCCESS","accountId":"0.0.1246","filedId":null,"contractId":null,"topicId":null,"tokenId":null,"scheduleId":null,"exchangeRate":{"hbars":1,"cents":12,"expirationTime":"1963-11-25T17:31:44.000Z","exchangeRateInCents":12},"nextExchangeRate":{"hbars":1,"cents":15,"expirationTime":"1963-11-25T13:31:44.000Z","exchangeRateInCents":15},"topicSequenceNumber":"0","topicRunningHash":"","totalSupply":"0","scheduledTransactionId":null,"serials":[],"duplicates":[],"children":[],"nodeId":"0"},"transactionHash":"cac44f2db045ba441f3fbc295217f2eb0f956293d28b3401578f6160e66f4e47ea87952d91c4b1cb5bda6447823b979a","consensusTimestamp":"2022-06-18T02:54:43.839Z","transactionId":"0.0.1157@1655520872.507983896","transactionMemo":"test","transactionFee":"41694270","transfers":[{"accountId":"0.0.5","amount":"1071080","isApproved":false},{"accountId":"0.0.98","amount":"32498552","isApproved":false},{"accountId":"0.0.800","amount":"4062319","isApproved":false},{"accountId":"0.0.801","amount":"4062319","isApproved":false},{"accountId":"0.0.1157","amount":"-1041694270","isApproved":false},{"accountId":"0.0.1246","amount":"1000000000","isApproved":false}],"tokenTransfers":{"0.0.123":{"0.0.1246":"789"}},"tokenTransfersList":[{"tokenId":"0.0.123","accountId":"0.0.1246","amount":"789"}],"scheduleRef":"0.0.123","assessedCustomFees":[{"feeCollectorAccountId":"0.0.1246","tokenId":"0.0.123","amount":"789","payerAccountIds":["0.0.1246"]}],"nftTransfers":{"0.0.123":[{"sender":"0.0.1246","recipient":"0.0.1246","serial":123,"isApproved":true}]},"automaticTokenAssociations":[{"accountId":"0.0.1246","tokenId":"0.0.123"}],"parentConsensusTimestamp":"2022-06-18T02:54:43.839Z","aliasKey":"302a300506032b6570032100d7366c45e4d2f1a6c1d9af054f5ef8edc0b8d3875ba5d08a7f2e81ee8876e9e8","duplicates":[],"children":[],"ethereumHash":"01020304","paidStakingRewards":[{"accountId":"0.0.5","amount":"1071080","isApproved":false},{"accountId":"0.0.98","amount":"32498552","isApproved":false},{"accountId":"0.0.800","amount":"4062319","isApproved":false},{"accountId":"0.0.801","amount":"4062319","isApproved":false},{"accountId":"0.0.1157","amount":"-1041694270","isApproved":false},{"accountId":"0.0.1246","amount":"1000000000","isApproved":false}],"prngBytes":"01020304","prngNumber":123,"evmAddress":"deadbeef"}`,
        );
        const actualJSON = JSON.parse(JSON.stringify(newRecord));

        expect(actualJSON).to.deep.equal(expectedJSON);
    });
});
// Filename: test/unit/TransactionResponse.js
import { expect } from "chai";

import {
    AccountId,
    TransactionId,
    TransactionResponse,
} from "../../src/index.js";

describe("TransactionResponse", function () {
    it("toJSON()", function () {
        const response = new TransactionResponse({
            nodeId: AccountId.fromString("0.0.3"),
            transactionHash: Uint8Array.of(1, 2, 3),
            transactionId: TransactionId.fromString("0.0.12@13.000000014"),
        });

        console.log(JSON.stringify(response));

        const expectedJSON = `{"nodeId":"0.0.3","transactionHash":"010203","transactionId":"0.0.12@13.000000014"}`;
        const expectedJSONParsed = JSON.parse(expectedJSON);

        const resultJSON = JSON.parse(JSON.stringify(response));
        expect(resultJSON).to.deep.equal(expectedJSONParsed);
    });
});
// Filename: test/unit/TransferTransaction.js
import { expect } from "chai";

import {
    TransferTransaction,
    HbarUnit,
    Hbar,
    TokenId,
    AccountId,
    Transaction,
    TransactionId,
    Timestamp,
    NftId,
} from "../../src/index.js";
import Long from "long";

describe("TransferTransaction", function () {
    const tokenId1 = new TokenId(1, 1, 1);
    const tokenId2 = new TokenId(2, 2, 2);
    const tokenId3 = new TokenId(3, 3, 3);
    const tokenId4 = new TokenId(4, 4, 4);
    const accountId1 = new AccountId(1, 1, 1);
    const accountId2 = new AccountId(2, 2, 2);
    const accountId3 = new AccountId(3, 3, 3);
    const accountId4 = new AccountId(4, 4, 4);
    const timestamp1 = new Timestamp(4, 4);

    it("should combine multiple same accountId tansfers into one transfer", function () {
        const expectedHbar = 3;
        const accountId = "0.0.0";

        const transfer = new TransferTransaction()
            .addHbarTransfer(accountId, 1)
            .addHbarTransfer(accountId, 1);

        transfer.addHbarTransfer(accountId, 1);
        transfer.addHbarTransfer("0.0.1", 1);

        expect(
            transfer.hbarTransfers.get(accountId).to(HbarUnit.Hbar).toNumber(),
        ).to.be.equal(new Hbar(expectedHbar).to(HbarUnit.Hbar).toNumber());
    });

    it("should use nftid case for addNftTransfer", function () {
        let transferTransaction = new TransferTransaction();

        let tokenId = new TokenId(1, 2, 3);
        let serial = Long.fromString("1234567890");

        let nftId = new NftId(tokenId, serial);
        let sender = AccountId.fromString("1.1.1");
        let recipient = AccountId.fromString("2.2.2");

        let check = {
            serial: serial,
            sender: sender,
            recipient: recipient,
            isApproved: false,
        };

        transferTransaction.addNftTransfer(nftId, sender, recipient);

        expect(
            transferTransaction.nftTransfers.values().next().value[0],
        ).to.eql(check);
        expect(transferTransaction.nftTransfers.keys().next().value).to.eql(
            tokenId,
        );
    });

    it("should use tokenId/serial case for addNftTransfer", function () {
        let transferTransaction = new TransferTransaction();

        let tokenId = new TokenId(1, 2, 3);
        let serial = Long.fromString("1234567890");

        let sender = AccountId.fromString("1.1.1");
        let recipient = AccountId.fromString("2.2.2");

        let check = {
            serial: serial,
            sender: sender,
            recipient: recipient,
            isApproved: false,
        };

        transferTransaction.addNftTransfer(tokenId, serial, sender, recipient);

        expect(
            transferTransaction.nftTransfers.values().next().value[0],
        ).to.eql(check);
        expect(transferTransaction.nftTransfers.keys().next().value).to.eql(
            tokenId,
        );
    });

    it("should parse string NftId", function () {
        let transferTransaction = new TransferTransaction();

        let tokenId = "1.2.3/555";
        let serial = Long.fromString("555");

        let sender = AccountId.fromString("1.1.1");
        let recipient = AccountId.fromString("2.2.2");

        let check = {
            serial: serial,
            sender: sender,
            recipient: recipient,
            isApproved: false,
        };

        transferTransaction.addNftTransfer(tokenId, sender, recipient);

        expect(
            transferTransaction.nftTransfers.values().next().value[0],
        ).to.eql(check);
        expect(transferTransaction.nftTransfers.keys().next().value).to.eql(
            TokenId.fromString("1.2.3"),
        );
    });

    it("should parse string TokenId", function () {
        let transferTransaction = new TransferTransaction();

        let tokenId = "1.2.3";
        let serial = Long.fromString("555");

        let sender = AccountId.fromString("1.1.1");
        let recipient = AccountId.fromString("2.2.2");

        let check = {
            serial: serial,
            sender: sender,
            recipient: recipient,
            isApproved: false,
        };

        transferTransaction.addNftTransfer(tokenId, serial, sender, recipient);

        expect(
            transferTransaction.nftTransfers.values().next().value[0],
        ).to.eql(check);
        expect(transferTransaction.nftTransfers.keys().next().value).to.eql(
            TokenId.fromString("1.2.3"),
        );
    });

    it("should save decimals", function () {
        const transferTransaction = new TransferTransaction()
            .addTokenTransferWithDecimals(tokenId2, accountId4, -1, 10)
            .addTokenTransferWithDecimals(tokenId2, accountId3, 2, 10)
            .addTokenTransferWithDecimals(tokenId1, accountId2, -3, 11)
            .addTokenTransferWithDecimals(tokenId1, accountId1, -4, 11);

        const expectedDecimals = transferTransaction.tokenIdDecimals;

        expect(expectedDecimals.size).to.equal(2);
        expect(expectedDecimals.get(tokenId1)).to.equal(11);
        expect(expectedDecimals.get(tokenId2)).to.equal(10);
    });

    it("should order transfers", function () {
        const serialNum1 = Long.fromNumber(111);
        const serialNum2 = Long.fromNumber(222);

        const transaction = new TransferTransaction()
            // Insert in reverse order to confirm they get reordered
            .addNftTransfer(
                new NftId(tokenId4, serialNum1),
                accountId2,
                accountId4,
            )
            .addNftTransfer(tokenId4, serialNum1, accountId1, accountId3)
            .addNftTransfer(tokenId4, serialNum2, accountId3, accountId1)
            .addNftTransfer(
                new NftId(tokenId3, serialNum1),
                accountId1,
                accountId2,
            )
            .addNftTransfer(
                new NftId(tokenId3, serialNum2),
                accountId2,
                accountId1,
            )
            .addTokenTransferWithDecimals(tokenId2, accountId4, -1, 10)
            .addTokenTransferWithDecimals(tokenId2, accountId3, 2, 10)
            .addTokenTransferWithDecimals(tokenId1, accountId2, -3, 11)
            .addTokenTransferWithDecimals(tokenId1, accountId1, -4, 11)
            .addHbarTransfer(accountId2, -1)
            .addHbarTransfer(accountId1, 1)
            .setHbarTransferApproval(accountId1, true)
            .setTokenTransferApproval(tokenId1, accountId1, true)
            .setNftTransferApproval(new NftId(tokenId4, serialNum1), true)
            .setTransactionId(new TransactionId(accountId3, timestamp1))
            .setNodeAccountIds([accountId4])
            .freeze();

        const transferTransaction = Transaction.fromBytes(
            transaction.toBytes(),
        );

        const data = transferTransaction._makeTransactionData();

        expect(data.transfers.accountAmounts).to.deep.equal([
            {
                accountID: {
                    shardNum: Long.fromNumber(1),
                    realmNum: Long.fromNumber(1),
                    accountNum: Long.fromNumber(1),
                    alias: null,
                },
                amount: Long.fromNumber(100000000),
                isApproval: true,
            },
            {
                accountID: {
                    shardNum: Long.fromNumber(2),
                    realmNum: Long.fromNumber(2),
                    accountNum: Long.fromNumber(2),
                    alias: null,
                },
                amount: Long.fromNumber(-100000000),
                isApproval: false,
            },
        ]);

        expect(data.tokenTransfers.length).to.be.equal(4);
        expect(data.tokenTransfers[0]).to.deep.equal({
            token: {
                shardNum: Long.fromNumber(1),
                realmNum: Long.fromNumber(1),
                tokenNum: Long.fromNumber(1),
            },
            expectedDecimals: { value: 11 },
            transfers: [
                {
                    accountID: {
                        shardNum: Long.fromNumber(1),
                        realmNum: Long.fromNumber(1),
                        accountNum: Long.fromNumber(1),
                        alias: null,
                    },
                    amount: Long.fromNumber(-4),
                    isApproval: true,
                },
                {
                    accountID: {
                        shardNum: Long.fromNumber(2),
                        realmNum: Long.fromNumber(2),
                        accountNum: Long.fromNumber(2),
                        alias: null,
                    },
                    amount: Long.fromNumber(-3),
                    isApproval: false,
                },
            ],
            nftTransfers: [],
        });
        expect(data.tokenTransfers[1]).to.deep.equal({
            token: {
                shardNum: Long.fromNumber(2),
                realmNum: Long.fromNumber(2),
                tokenNum: Long.fromNumber(2),
            },
            expectedDecimals: { value: 10 },
            transfers: [
                {
                    accountID: {
                        shardNum: Long.fromNumber(3),
                        realmNum: Long.fromNumber(3),
                        accountNum: Long.fromNumber(3),
                        alias: null,
                    },
                    amount: Long.fromNumber(2),
                    isApproval: false,
                },
                {
                    accountID: {
                        shardNum: Long.fromNumber(4),
                        realmNum: Long.fromNumber(4),
                        accountNum: Long.fromNumber(4),
                        alias: null,
                    },
                    amount: Long.fromNumber(-1),
                    isApproval: false,
                },
            ],
            nftTransfers: [],
        });
        expect(data.tokenTransfers[2]).to.deep.equal({
            token: {
                shardNum: Long.fromNumber(3),
                realmNum: Long.fromNumber(3),
                tokenNum: Long.fromNumber(3),
            },
            expectedDecimals: null,
            transfers: [],
            nftTransfers: [
                {
                    senderAccountID: {
                        shardNum: Long.fromNumber(1),
                        realmNum: Long.fromNumber(1),
                        accountNum: Long.fromNumber(1),
                        alias: null,
                    },
                    receiverAccountID: {
                        shardNum: Long.fromNumber(2),
                        realmNum: Long.fromNumber(2),
                        accountNum: Long.fromNumber(2),
                        alias: null,
                    },
                    serialNumber: serialNum1,
                    isApproval: false,
                },
                {
                    senderAccountID: {
                        shardNum: Long.fromNumber(2),
                        realmNum: Long.fromNumber(2),
                        accountNum: Long.fromNumber(2),
                        alias: null,
                    },
                    receiverAccountID: {
                        shardNum: Long.fromNumber(1),
                        realmNum: Long.fromNumber(1),
                        accountNum: Long.fromNumber(1),
                        alias: null,
                    },
                    serialNumber: serialNum2,
                    isApproval: false,
                },
            ],
        });
        expect(data.tokenTransfers[3]).to.deep.equal({
            token: {
                shardNum: Long.fromNumber(4),
                realmNum: Long.fromNumber(4),
                tokenNum: Long.fromNumber(4),
            },
            expectedDecimals: null,
            transfers: [],
            nftTransfers: [
                {
                    senderAccountID: {
                        shardNum: Long.fromNumber(1),
                        realmNum: Long.fromNumber(1),
                        accountNum: Long.fromNumber(1),
                        alias: null,
                    },
                    receiverAccountID: {
                        shardNum: Long.fromNumber(3),
                        realmNum: Long.fromNumber(3),
                        accountNum: Long.fromNumber(3),
                        alias: null,
                    },
                    serialNumber: serialNum1,
                    isApproval: true,
                },
                {
                    senderAccountID: {
                        shardNum: Long.fromNumber(3),
                        realmNum: Long.fromNumber(3),
                        accountNum: Long.fromNumber(3),
                        alias: null,
                    },
                    receiverAccountID: {
                        shardNum: Long.fromNumber(1),
                        realmNum: Long.fromNumber(1),
                        accountNum: Long.fromNumber(1),
                        alias: null,
                    },
                    serialNumber: serialNum2,
                    isApproval: false,
                },
            ],
        });
    });

    it("should return hbarTransfer list", function () {
        const accountId1 = AccountId.fromString("0.0.0");
        const accountId2 = AccountId.fromString("0.0.1");
        const amount = new Hbar(1);

        const tx = new TransferTransaction()
            .addHbarTransfer(accountId1, amount.negated())
            .addHbarTransfer(accountId2, amount);

        expect(tx.hbarTransfersList).to.deep.equal([
            {
                accountId: accountId1,
                amount: amount.negated(),
                isApproved: false,
            },
            {
                accountId: accountId2,
                amount: amount,
                isApproved: false,
            },
        ]);
    });
});
// Filename: test/unit/keccak256.js
import { keccak256 } from "../../src/cryptography/keccak.js";
import * as hex from "../../src/encoding/hex.js";

describe("keccak256", function () {
    it("should hash to the expected value", function () {
        const hash = keccak256("method");

        expect(hash).to.eql(
            "0x9c87604675c4160b0aac6ee753604a7ebe1728c804a0ac841ff8bb02e543aa3a",
        );
    });

    it("should hash to the expected value for bytes larger than 127", function () {
        const hash = keccak256(
            hex.decode("0x00112233445566778899aabbccddeeff"),
        );

        expect(hash).to.eql(
            "0x22bce46032802af0abfacf3768f7be04a34f5f01df60f44ffd52d3ca937350c0",
        );
    });

    it("should hash body bytes correctly", function () {
        const hash = keccak256(
            hex.decode(
                "0x0a0e0a0408011001120608001000180412060800100018031880c2d72f220208783200721a0a180a0a0a0608001000180410130a0a0a060800100018051014",
            ),
        );

        expect(hash).to.eql(
            "0x90c1c5bb75d76d3cfed2c136525ffbcf381b4b3909cefd11b68b26ce6f9999b6",
        );
    });
});
// Filename: test/unit/util.js
import BigNumber from "bignumber.js";
import Long from "long";
import * as util from "../../src/util.js";

describe("util", function () {
    it("soft check: isNonNull should return false if null and true if non-null", function () {
        expect(util.isNonNull("")).to.eql(true);

        expect(util.isNonNull(null)).to.eql(false);
        expect(util.isNonNull(undefined)).to.eql(false);
    });

    it("soft check: isType should return true if params are the same type else false", function () {
        expect(util.isType("", "")).to.eql(true);
        expect(util.isType(null, null)).to.eql(true);
        expect(util.isType(undefined, undefined)).to.eql(true);

        expect(util.isType(undefined, null)).to.eql(false);
        expect(util.isType(1, "1")).to.eql(false);
    });

    it("soft check: isUint8Array should return true if instanceof Uint8Array and non-null", function () {
        expect(util.isUint8Array(new Uint8Array())).to.eql(true);

        expect(util.isUint8Array("")).to.eql(false);
        expect(util.isUint8Array(null)).to.eql(false);
    });

    it("soft check: isNumber should return true if type is number and non-null", function () {
        expect(util.isNumber(new Number())).to.eql(true);
        expect(util.isNumber(1)).to.eql(true);

        expect(util.isNumber(null)).to.eql(false);
        expect(util.isNumber("1")).to.eql(false);
    });

    it("soft check: isBigNumber should return true if instanceof BigNumber and non-null", function () {
        expect(util.isBigNumber(new BigNumber())).to.eql(true);
        expect(util.isBigNumber(new BigNumber(11111))).to.eql(true);

        expect(util.isBigNumber(null)).to.eql(false);
        expect(util.isBigNumber("1")).to.eql(false);
    });

    it("soft check: isString should return true if instanceof string and non-null", function () {
        expect(util.isString("")).to.eql(true);
        expect(util.isString("")).to.eql(true);

        expect(util.isString(null)).to.eql(false);
        expect(util.isString(1)).to.eql(false);
    });

    it("soft check: isStringOrUint8Array should return true if string or Uint8Array", function () {
        expect(util.isStringOrUint8Array("")).to.eql(true);
        expect(util.isStringOrUint8Array(new Uint8Array())).to.eql(true);

        expect(util.isStringOrUint8Array(null)).to.eql(false);
        expect(util.isStringOrUint8Array(1)).to.eql(false);
    });

    it("require: requireNonNull should throw custom error if null or undefined", function () {
        try {
            util.requireNonNull(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireNonNull(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        expect(util.requireNonNull("")).to.eql("");
        expect(util.requireNonNull(1)).to.eql(1);
    });

    it("require: requireType should throw custom error if params are not same type", function () {
        try {
            util.requireType();
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            //weird case here because referencing an unset param is also undefined
            // so they are technically the same type but fail null|undefined check
            util.requireType(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireType(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_TYPE_ERROR);
        }

        try {
            util.requireType(new BigNumber(1), 1);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_TYPE_ERROR);
        }

        try {
            util.requireType("1", 1);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_TYPE_ERROR);
        }

        expect(util.requireType("", "asdf")).to.eql("");
        expect(util.requireType(1, 2)).to.eql(1);
    });

    it("require: requireBigNumber should throw custom error if param is not a BigNumber", function () {
        try {
            util.requireBigNumber(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireBigNumber(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireBigNumber(1);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_BIGNUMBER_ERROR);
        }

        try {
            util.requireBigNumber("1");
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_BIGNUMBER_ERROR);
        }

        expect(util.requireBigNumber(new BigNumber(111))).to.eql(
            new BigNumber(111),
        );
    });

    it("require: requireString should throw custom error if param is not string", function () {
        try {
            util.requireString(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireString(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireString(1);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_STRING_ERROR);
        }

        expect(util.requireString("")).to.eql("");
    });

    it("require: requireUint8Array should throw custom error if param is not Uint8Array", function () {
        try {
            util.requireUint8Array(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireUint8Array(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireUint8Array(1);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_UINT8ARRAY_ERROR);
        }

        expect(util.requireUint8Array(new Uint8Array())).to.eql(
            new Uint8Array(),
        );
    });

    it("require: requireNumber should throw custom error if param is not number", function () {
        try {
            util.requireNumber(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireNumber(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireNumber("1");
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NUMBER_ERROR);
        }

        expect(util.requireNumber(1)).to.eql(1);
    });

    it("require: requireStringOrUint8Array should throw custom error if param is not string or Uint8Array", function () {
        try {
            util.requireStringOrUint8Array(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireStringOrUint8Array(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.requireStringOrUint8Array(1);
        } catch (error) {
            expect(error.message).to.eql(
                util.REQUIRE_STRING_OR_UINT8ARRAY_ERROR,
            );
        }

        expect(util.requireStringOrUint8Array("1")).to.eql("1");
        expect(util.requireUint8Array(new Uint8Array())).to.eql(
            new Uint8Array(),
        );
    });

    it("convert: convertToBigNumber should convert string or number to BigNumber", function () {
        try {
            util.convertToBigNumber(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.convertToBigNumber(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.convertToBigNumber({});
        } catch (error) {
            expect(error.message).to.eql(
                util.FUNCTION_CONVERT_TO_BIGNUMBER_ERROR,
            );
        }

        expect(util.convertToBigNumber(1)).to.eql(BigNumber(1));
        expect(util.convertToBigNumber("1")).to.eql(BigNumber(1));
        expect(util.convertToBigNumber(BigNumber(1))).to.eql(BigNumber(1));
    });

    it("convert: convertToBigNumberArray should convert an array of strings or numbers to BigNumbers", function () {
        const bigNumberArray = [BigNumber(1), BigNumber(2), BigNumber(3)];

        try {
            util.convertToBigNumberArray(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_ARRAY_ERROR);
        }

        try {
            util.convertToBigNumberArray(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_ARRAY_ERROR);
        }

        try {
            util.convertToBigNumberArray(1);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_ARRAY_ERROR);
        }

        expect(util.convertToBigNumberArray([1, 2, 3])).to.eql(bigNumberArray);
        expect(util.convertToBigNumberArray(["1", "2", "3"])).to.eql(
            bigNumberArray,
        );
        expect(util.convertToBigNumberArray(bigNumberArray)).to.eql(
            bigNumberArray,
        );
    });

    it("convert: convertToNumber should convert string or BigNumber to number", function () {
        try {
            util.convertToNumber(null);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.convertToNumber(undefined);
        } catch (error) {
            expect(error.message).to.eql(util.REQUIRE_NON_NULL_ERROR);
        }

        try {
            util.convertToNumber({});
        } catch (error) {
            expect(error.message).to.eql(util.FUNCTION_CONVERT_TO_NUMBER_ERROR);
        }

        try {
            util.convertToNumber("asdf");
        } catch (error) {
            expect(error.message).to.eql(
                util.FUNCTION_CONVERT_TO_NUMBER_PARSE_ERROR,
            );
        }

        expect(util.convertToNumber(1)).to.eql(1);
        expect(util.convertToNumber("1")).to.eql(1);
        expect(util.convertToNumber(new BigNumber(1))).to.eql(1);
        expect(util.convertToNumber(new Long(1))).to.eql(1);
    });

    it("compare", function () {
        expect(util.compare(true, true)).to.be.true;
        expect(util.compare(true, false)).to.be.false;
        expect(util.compare("true", false)).to.be.false;
        expect(util.compare("true", "false")).to.be.false;
        expect(util.compare("true", "true")).to.be.true;
        expect(util.compare("random string", "random string")).to.be.true;
        expect(util.compare(0, 1)).to.be.false;
        expect(util.compare(1, 1)).to.be.true;
        expect(util.compare(Long.fromNumber(1), 1)).to.be.false;
        expect(util.compare(Long.fromNumber(1), Long.fromNumber(1))).to.be.true;
        expect(util.compare({}, { hello: true })).to.be.false;
        expect(util.compare({ hello: false }, { hello: true })).to.be.false;
        expect(util.compare({ hello: true }, { hello: true })).to.be.true;
        expect(util.compare({ hello: { world: false } }, { hello: true })).to.be
            .false;
        expect(util.compare({ hello: { world: false } }, { hello: {} })).to.be
            .false;
        expect(
            util.compare(
                { hello: { world: false } },
                { hello: { world: true } },
            ),
        ).to.be.false;
        expect(
            util.compare(
                { hello: { world: false } },
                { hello: { world: false } },
            ),
        ).to.be.true;
    });
});
// Filename: vite.config.js
/** @type {import('vite').UserConfig} */
export default {
    server: {
        hmr: false,
    },
    envDir: "./",
    build: {
        polyfillDynamicImport: false,
    },
    optimizeDeps: {
        force: true,
        entries: [
            "./test/unit/AccountId.js",
            "./test/unit/Hbar.js",
            "./test/unit/keccak256.js",
            "./test/unit/Transaction.js",
            "./test/unit/TransactionId.js",
            "./test/integration/AccountBalanceIntegrationTest.js",
            "./test/integration/ClientIntegrationTest.js",
            "./test/integration/TokenCreateIntegrationTest.js",
            "./test/integration/TransactionIntegrationTest.js",
            "./test/integration/TransactionResponseTest.js",
        ],
    },
    resolve: {
        alias: {
            // redirect src/ to src/browser
            // note that this is NOT needed when consuming this package as the browser field in package.json
            // will take care of this
            "../../src/index.js": "../../src/browser.js",
            "../src/index.js": "../src/browser.js",
            // TODO: extract `encoding/hex.js` etc into a variable and call a function to generate 
            // all the prefixes.
            "../../../src/encoding/hex.js": "../../../src/encoding/hex.browser.js",
            "../../src/encoding/hex.js": "../../src/encoding/hex.browser.js",
            "../src/encoding/hex.js": "../src/encoding/hex.browser.js",
            "src/encoding/hex.js": "src/encoding/hex.browser.js",
            "../encoding/hex.js": "../encoding/hex.browser.js",
            "./encoding/hex.js": "./encoding/hex.browser.js",
            "../src/encoding/utf8.js": "../src/encoding/utf8.browser.js",
            "../../src/encoding/utf8.js": "../../src/encoding/utf8.browser.js",
            "../encoding/utf8.js": "../encoding/utf8.browser.js",
            "../src/cryptography/sha384.js": "../src/cryptography/sha384.browser.js",
            "../cryptography/sha384.js": "../cryptography/sha384.browser.js",
            "./client/NodeIntegrationTestEnv.js": "./client/WebIntegrationTestEnv.js",
            "../integration/client/NodeIntegrationTestEnv.js": "../integration/client/WebIntegrationTestEnv.js",
            "../../src/client/NodeClient.js": "../../src/client/WebClient.js",
        },
    },
};
