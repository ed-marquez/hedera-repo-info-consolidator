// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/AccountAliasExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to use auto account creation (HIP-32).
 * <p>
 * You can "create" an account by generating a private key, and then deriving the public key,
 * without any need to interact with the Hedera network. The public key more or less acts as the user's
 * account ID. This public key is an account's aliasKey: a public key that aliases (or will eventually alias)
 * to a Hedera account.
 * <p>
 * An AccountId takes one of two forms: a normal AccountId with a null aliasKey member takes the form 0.0.123,
 * while an account ID with a non-null aliasKey member takes the form
 * 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
 * Note the prefix of "0.0." indicating the shard and realm. Also note that the aliasKey is stringified
 * as a hex-encoded ASN1 DER representation of the key.
 * <p>
 * An AccountId with an aliasKey can be used just like a normal AccountId for the purposes of queries and
 * transactions, however most queries and transactions involving such an AccountId won't work until Hbar has
 * been transferred to the aliasKey account.
 * <p>
 * There is no record in the Hedera network of an account associated with a given aliasKey
 * until an amount of Hbar is transferred to the account. The moment that Hbar is transferred to that aliasKey
 * AccountId is the moment that that account actually begins to exist in the Hedera ledger.
 */
class AccountAliasExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Account Alias Example (HIP-32) Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pair.
         */
        System.out.println("Generating ED25519 key pair...");
        PrivateKey privateKey = PrivateKey.generateED25519();
        PublicKey publicKey = privateKey.getPublicKey();

        /*
         * Step 2:
         * Create a couple of example Account Ids.
         *
         * Note that no queries or transactions have taken place yet.
         * This account "creation" process is entirely local.
         *
         * AccountId.fromString() can construct an AccountId with an aliasKey.
         * It expects a string of the form 0.0.123 in the case of a normal AccountId, or of the form
         * 0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777
         * in the case of an AccountId with aliasKey. Note the prefix of '0.0.' to indicate the shard and realm.
         *
         * If the shard and realm are known, you may use PublicKey.fromString().toAccountId() to construct the
         * aliasKey AccountId.
         */
        System.out.println("\"Creating\" new account...");

        // Assuming that the target shard and realm are known.
        // For now, they are virtually always 0 and 0.
        AccountId aliasAccountId = publicKey.toAccountId(0, 0);

        System.out.println("New account ID: " + aliasAccountId);
        System.out.println("Just the aliasKey: " + aliasAccountId.aliasKey);

        AccountId fromStringExample = AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777");

        AccountId fromKeyStringExample = PublicKey
                .fromString("302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777")
                .toAccountId(0, 0);

        /*
         * Step 3:
         * Transfer Hbar to the new account.
         *
         * Transfer will actually create an actual Hedera account,
         * deducting the creation fee from the amount transferred.
         */
        System.out.println("Transferring Hbar to the new account...");
        new TransferTransaction()
            .addHbarTransfer(OPERATOR_ID, Hbar.from(1).negated())
            .addHbarTransfer(aliasAccountId, Hbar.from(1))
            .execute(client)
            .getReceipt(client);

        /*
         * Step 4:
         * Query and output info about the new account.
         *
         * Note that once an account exists in the ledger, it is assigned a normal AccountId, which can be retrieved
         * via an AccountInfoQuery.
         *
         * Users may continue to refer to the account by its aliasKey AccountId, but they may also
         * now refer to it by its normal AccountId
         */
        AccountBalance newAccountBalance = new AccountBalanceQuery()
            .setAccountId(aliasAccountId)
            .execute(client);

        System.out.println("Balances of the new account: " + newAccountBalance);

        AccountInfo newAccountInfo = new AccountInfoQuery()
            .setAccountId(aliasAccountId)
            .execute(client);

        Objects.requireNonNull(newAccountInfo.accountId);

        System.out.println("Info about the new account: " + newAccountInfo);
        System.out.println("The normal account ID: " + newAccountInfo.accountId);
        System.out.println("The alias key: " + newAccountInfo.aliasKey);

        /*
         * Clean up:
         * Delete created account and close the client.
         */
        new AccountDeleteTransaction()
            .setAccountId(newAccountInfo.accountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Account Alias Example (HIP-32) Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/AccountAllowanceExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to approve and delete allowance.
 * <p>
 * Approve allowance is a transaction that allows a token owner to delegate a token spender to spend
 * a specified token amount on behalf of the token owner. This can be done for HBAR, non-fungible,
 * and fungible tokens. The owner grants the token allowance to the spender, who can then transfer tokens
 * from the owner's account to another recipient, paying for the transaction fees themselves.
 * <p>
 * On the other hand, delete allowance is a transaction that removes one or more non-fungible
 * approved allowances from an owner's account. This operation removes the allowances granted to
 * specific non-fungible token serial numbers. HBAR and fungible token allowances can be removed by
 * setting the amount to zero in CryptoApproveAllowance.
 */
class AccountAllowanceExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Account Allowance Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();

        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();

        PrivateKey charliePrivateKey = PrivateKey.generateED25519();
        PublicKey charliePublicKey = charliePrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create accounts for this example.
         */
        System.out.println("Creating Alice's, Bob's and Charlie's accounts...");

        AccountId aliceId = new AccountCreateTransaction()
            .setKey(alicePublicKey)
            .setInitialBalance(Hbar.from(5))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(aliceId);

        AccountId bobId = new AccountCreateTransaction()
            .setKey(bobPublicKey)
            .setInitialBalance(Hbar.from(5))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(bobId);

        AccountId charlieId = new AccountCreateTransaction()
            .setKey(charliePublicKey)
            .setInitialBalance(Hbar.from(5))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(charlieId);

        System.out.println("Alice's account ID: " + aliceId);
        System.out.println("Bob's account ID: " + bobId);
        System.out.println("Charlie's account ID: " + charlieId);

        System.out.println(
            "Alice's balance: " +
                new AccountBalanceQuery().setAccountId(aliceId).execute(client).hbars
        );
        System.out.println(
            "Bob's balance: " +
                new AccountBalanceQuery().setAccountId(bobId).execute(client).hbars
        );
        System.out.println(
            "Charlie's balance: " +
                new AccountBalanceQuery().setAccountId(charlieId).execute(client).hbars
        );

        /*
         * Step 3:
         * Approve an allowance of 2 Hbar with owner Alice and spender Bob.
         */
        System.out.println("Approving an allowance of 2 Hbar with owner Alice and spender Bob...");

        new AccountAllowanceApproveTransaction()
            .approveHbarAllowance(aliceId, bobId, Hbar.from(2))
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println(
            "Alice's balance: " +
                new AccountBalanceQuery().setAccountId(aliceId).execute(client).hbars
        );
        System.out.println(
            "Bob's balance: " +
                new AccountBalanceQuery().setAccountId(bobId).execute(client).hbars
        );
        System.out.println(
            "Charlie's balance: " +
                new AccountBalanceQuery().setAccountId(charlieId).execute(client).hbars
        );

        /*
         * Step 4:
         * Demonstrate allowance -- transfer 1 Hbar from Alice to Charlie, but the transaction is signed only by Bob
         * (Bob is dipping into his allowance from Alice).
         */
        System.out.println("Transferring 1 Hbar from Alice to Charlie, " +
            "but the transaction is signed only by Bob (Bob is dipping into his allowance from Alice)...");

        new TransferTransaction()
            // "addApproved*Transfer()" means that the transfer has been approved by an allowance
            .addApprovedHbarTransfer(aliceId, Hbar.from(1).negated())
            .addHbarTransfer(charlieId, Hbar.from(1))
            // The allowance spender must be pay the fee for the transaction.
            // use setTransactionId() to set the account ID that will pay the fee for the transaction.
            .setTransactionId(TransactionId.generate(bobId))
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Transfer succeeded. Bob should now have 1 Hbar left in his allowance.");

        System.out.println(
            "Alice's balance: " +
                new AccountBalanceQuery().setAccountId(aliceId).execute(client).hbars
        );
        System.out.println(
            "Bob's balance: " +
                new AccountBalanceQuery().setAccountId(bobId).execute(client).hbars
        );
        System.out.println(
            "Charlie's balance: " +
                new AccountBalanceQuery().setAccountId(charlieId).execute(client).hbars
        );

        /*
         * Step 5:
         * Demonstrate the absence of an allowance -- attempt to transfer 2 Hbar from Alice to Charlie using Bob's allowance.
         *
         * This should fail, because there is only 1 Hbar left in Bob's allowance.
         */
        try {
            System.out.println("Attempting to transfer 2 Hbar from Alice to Charlie using Bob's allowance... " +
                "(this should fail, because there is only 1 Hbar left in Bob's allowance).");

            new TransferTransaction()
                .addApprovedHbarTransfer(aliceId, Hbar.from(2).negated())
                .addHbarTransfer(charlieId, Hbar.from(2))
                .setTransactionId(TransactionId.generate(bobId))
                .freezeWith(client)
                .sign(bobPrivateKey)
                .execute(client)
                .getReceipt(client);

            throw new Exception("This transfer shouldn't have succeeded!");
        } catch (Throwable error) {
            System.out.println("This transfer failed as expected: " + error.getMessage());
        }

        /*
         * Step 6:
         * Demonstrate update of an allowance -- adjust Bob's allowance to 3 Hbar.
         */
        System.out.println("Adjusting Bob's allowance to 3 Hbar...");

        new AccountAllowanceApproveTransaction()
            .approveHbarAllowance(aliceId, bobId, Hbar.from(3))
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 7:
         * Demonstrate allowance -- transfer 2 Hbar from Alice to Charlie using Bob's allowance again.
         */
        System.out.println("Attempting to transfer 2 Hbar from Alice to Charlie using Bob's allowance again... " +
            "(this time it should succeed).");

        new TransferTransaction()
            .addApprovedHbarTransfer(aliceId, Hbar.from(2).negated())
            .addHbarTransfer(charlieId, Hbar.from(2))
            .setTransactionId(TransactionId.generate(bobId))
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Transfer succeeded.");

        System.out.println(
            "Alice's balance: " +
                new AccountBalanceQuery().setAccountId(aliceId).execute(client).hbars
        );
        System.out.println(
            "Bob's balance: " +
                new AccountBalanceQuery().setAccountId(bobId).execute(client).hbars
        );
        System.out.println(
            "Charlie's balance: " +
                new AccountBalanceQuery().setAccountId(charlieId).execute(client).hbars
        );

        /*
         * Clean up:
         * Delete allowance and created accounts.
         */
        new AccountAllowanceApproveTransaction()
            .approveHbarAllowance(aliceId, bobId, Hbar.ZERO)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(aliceId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(bobId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(charlieId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(charliePrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Account Allowance Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/AccountCreateWithHtsExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * How to use auto account creation via HTS assets (HIP-542).
 * <p>
 * This means a new alias may be given anywhere in the transaction--
 * both in the Hbar transfer list, or in an HTS token transfer list. In the latter case,
 * the assessed creation fee will include at least one auto-association slot,
 * since the new account must be associated to its originating HTS assets.
 */
class AccountCreateWithHtsExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Account Auto-Creation Via HTS Assets (HIP-542) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));
        // Set the maximum fee to be paid for transactions executed by this client.
        client.setDefaultMaxTransactionFee(Hbar.from(10));

        /*
         * Step 1:
         * Generate ECDSA keys pairs.
         */
        PublicKey operatorPublicKey = OPERATOR_KEY.getPublicKey();

        System.out.println("Generating ECDSA key pairs...");

        PrivateKey supplyPrivateKey = PrivateKey.generateECDSA();
        PublicKey supplyPublicKey = supplyPrivateKey.getPublicKey();

        PrivateKey freezePrivateKey = PrivateKey.generateECDSA();
        PublicKey freezePublicKey = freezePrivateKey.getPublicKey();

        PrivateKey wipePrivateKey = PrivateKey.generateECDSA();
        PublicKey wipePublicKey = wipePrivateKey.getPublicKey();

        /*
         * Step 2:
         * The beginning of the first example (with NFT).
         *
         * Create NFT using the Hedera Token Service.
         */
        System.out.println("The beginning of the first example (with NFT)...");

        // IPFS content identifiers for the NFT metadata.
        String[] CIDs = new String[] {
            "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
            "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
            "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
            "Qmd3kGgSrAwwSrhesYcY7K54f3qD7MDo38r7Po2dChtQx5",
            "QmWgkKz3ozgqtnvbCLeh7EaR1H8u5Sshx3ZJzxkcrT3jbw",
        };

        System.out.println("Creating NFT using the Hedera Token Service...");

        TokenCreateTransaction nftCreateTx = new TokenCreateTransaction()
            .setTokenName("HIP-542 Example Collection")
            .setTokenSymbol("HIP-542")
            .setTokenName("HIP-542 NFT")
            .setTokenSymbol("HIP542NFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setDecimals(0)
            .setInitialSupply(0)
            .setMaxSupply(CIDs.length)
            .setTreasuryAccountId(OPERATOR_ID)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(operatorPublicKey)
            .setFreezeKey(freezePublicKey)
            .setWipeKey(wipePublicKey)
            .setSupplyKey(supplyPublicKey)
            .freezeWith(client);

        // Sign the transaction with the operator key.
        TokenCreateTransaction nftCreateTxSigned = nftCreateTx.sign(OPERATOR_KEY);

        // Submit the transaction to the Hedera network.
        TransactionResponse nftCreateTxResponse = nftCreateTxSigned.execute(client);

        // Get transaction receipt information.
        TransactionReceipt nftCreateTxReceipt = nftCreateTxResponse.getReceipt(client);
        TokenId nftTokenId = nftCreateTxReceipt.tokenId;
        Objects.requireNonNull(nftTokenId);

        System.out.println("Created NFT with token ID: " + nftTokenId);

        /*
         * Step 3:
         * Mint NFTs.
         */
        System.out.println("Minting NFTs...");
        TransactionReceipt[] nftMintTxReceipts = new TransactionReceipt[CIDs.length];
        for (int i = 0; i < CIDs.length; i++) {
            byte[] nftMetadata = CIDs[i].getBytes();

            TokenMintTransaction nftMintTx = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(List.of(nftMetadata))
                .freezeWith(client);

            TokenMintTransaction nftMintTxSigned = nftMintTx.sign(supplyPrivateKey);
            TransactionResponse nftMintTxResponse = nftMintTxSigned.execute(client);

            nftMintTxReceipts[i] = nftMintTxResponse.getReceipt(client);

            System.out.println("Minted NFT (token ID: " + nftTokenId + ") with serial: " + nftMintTxReceipts[i].serials.get(0));
        }

        long exampleNftId = nftMintTxReceipts[0].serials.get(0);

        /*
         * Step 4:
         * Create an ECDSA public key alias.
         */
        PrivateKey alicePrivateKey = PrivateKey.generateECDSA();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();

        System.out.println("\"Creating\" Alice's account...");

        // Assuming that the target shard and realm are known.
        // For now they are virtually always 0 and 0.
        AccountId aliceAliasAccountId = alicePublicKey.toAccountId(0, 0);

        System.out.println("Alice's account ID: " + aliceAliasAccountId);
        System.out.println("Alice's alias key: " + aliceAliasAccountId.aliasKey);

        /*
         * Step 5:
         * Transfer the NFT to Alice's public key alias using the transfer transaction.
         */
        System.out.println("Transferring NFT to Alice's account...");

        TransferTransaction nftTransferTx = new TransferTransaction()
            .addNftTransfer(nftTokenId.nft(exampleNftId), OPERATOR_ID, aliceAliasAccountId)
            .freezeWith(client);

        // Sign the transaction with the operator key.
        TransferTransaction nftTransferTxSigned = nftTransferTx.sign(OPERATOR_KEY);

        // Submit the transaction to the Hedera network.
        TransactionResponse nftTransferTxResponse = nftTransferTxSigned.execute(client);

        // Get transaction receipt information here.
        nftTransferTxResponse.getReceipt(client);

        /*
         * Step 6:
         * Get the new account ID from the child record.
         */
        List<TokenNftInfo> nftsInfo = new TokenNftInfoQuery()
            .setNftId(nftTokenId.nft(exampleNftId))
            .execute(client);

        String nftOwnerAccountId_FromChildRecord = nftsInfo.get(0).accountId.toString();
        System.out.println("Current owner account ID: " + nftOwnerAccountId_FromChildRecord);

        /*
         * Step 7:
         * Show the normal account ID of account which owns the NFT.
         */
        String nftOwnerAccountId_FromQuery = new AccountInfoQuery()
            .setAccountId(aliceAliasAccountId)
            .execute(client)
            .accountId.toString();

        System.out.println("The \"normal\" account ID of the given alias: " + nftOwnerAccountId_FromQuery);

        /*
         * Step 8:
         * Validate that account ID value from the child record is equal to normal account ID value from the query.
         */
        if (nftOwnerAccountId_FromChildRecord.equals(nftOwnerAccountId_FromQuery)) {
            System.out.println("The NFT owner account ID matches the account ID created with the HTS! (Success)");
        } else {
            throw new Exception("The two account IDs does not match! (Error)");
        }

        /*
         * Step 9:
         * The beginning of the second example (with Fungible Token).
         * Create a fungible HTS token using the Hedera Token Service.
         */
        System.out.println("The beginning of the second example (with Fungible Token).");
        System.out.println("Creating Fungible Token using the Hedera Token Service...");

        TokenCreateTransaction ftCreateTx = new TokenCreateTransaction()
            .setTokenName("HIP-542 Fungible Token")
            .setTokenSymbol("HIP542FT")
            .setInitialSupply(10_000) // Total supply = 10000 / 10 ^ 2
            .setDecimals(2)
            .setTokenType(TokenType.FUNGIBLE_COMMON)
            .setTreasuryAccountId(OPERATOR_ID)
            .setAutoRenewAccountId(OPERATOR_ID)
            .setAdminKey(operatorPublicKey)
            .setWipeKey(wipePrivateKey)
            .freezeWith(client);

        // Sign the transaction with the operator key.
        TokenCreateTransaction ftCreateTxSigned = ftCreateTx.sign(OPERATOR_KEY);

        // Submit the transaction to the Hedera network.
        TransactionResponse ftCreateResponse = ftCreateTxSigned.execute(client);

        // Get transaction receipt information.
        TransactionReceipt ftCreateReceipt = ftCreateResponse.getReceipt(client);
        TokenId fungibleTokenId = ftCreateReceipt.tokenId;
        Objects.requireNonNull(fungibleTokenId);

        System.out.println("Created fungible token with ID: " + fungibleTokenId);

        /*
         * Step 10:
         * Create an ECDSA public key alias.
         */
        PrivateKey bobPrivateKey = PrivateKey.generateECDSA();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();

        System.out.println("\"Creating\" Bob's account...");
        // Assuming that the target shard and realm are known.
        // For now, they are virtually always 0 and 0.
        AccountId bobAliasAccountId = bobPublicKey.toAccountId(0, 0);

        System.out.println("Bob's account ID: " + bobAliasAccountId);
        System.out.println("Bob's alias key: " + bobAliasAccountId.aliasKey);

        /*
         * Step 11:
         * Transfer the Fungible Token to the Bob's public key alias using the transfer transaction.
         */
        System.out.println("Transferring Fungible Token the Bob's account...");
        TransferTransaction tokenTransferTx = new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, OPERATOR_ID, -10)
            .addTokenTransfer(fungibleTokenId, bobAliasAccountId, 10)
            .freezeWith(client);

        // Sign the transaction with the operator key.
        TransferTransaction tokenTransferTxSign = tokenTransferTx.sign(OPERATOR_KEY);

        // Submit the transaction to the Hedera network.
        TransactionResponse tokenTransferSubmit = tokenTransferTxSign.execute(client);

        // Get transaction receipt information.
        tokenTransferSubmit.getReceipt(client);

        /*
         * Step 12:
         * Get the new account ID from the child record.
         */
        String bobAccountInfo = new AccountInfoQuery()
            .setAccountId(bobAliasAccountId)
            .execute(client)
            .accountId
            .toString();

        System.out.println("The \"normal\" account ID of the given alias: " + bobAccountInfo);

        /*
         * Step 13:
         * Show the normal account ID of account which owns the NFT.
         */
        AccountBalance bobAccountBalances = new AccountBalanceQuery()
            .setAccountId(bobAliasAccountId)
            .execute(client);

        /*
         * Step 14:
         * Validate token balance of newly created account.
         */
        int bobFtBalance = bobAccountBalances.tokens.get(fungibleTokenId).intValue();
        if (bobFtBalance == 10) {
            System.out.println("New account was created using HTS TransferTransaction! (Success)");
        } else {
            throw new Exception("Creating account with HTS using public key alias failed! (Error)");
        }

        /*
         * Clean up:
         * Delete created accounts and tokens.
         */
        AccountId nftOwnerAccountId = AccountId.fromString(nftOwnerAccountId_FromQuery);

        new TokenWipeTransaction()
            .setTokenId(nftTokenId)
            .addSerial(exampleNftId)
            .setAccountId(nftOwnerAccountId)
            .freezeWith(client)
            .sign(wipePrivateKey)
            .execute(client)
            .getReceipt(client);

        AccountId bobAccountId = AccountId.fromString(bobAccountInfo);

        Map<TokenId, Long> bobsTokens = new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client)
            .tokens;

        new TokenWipeTransaction()
            .setTokenId(fungibleTokenId)
            .setAmount(bobsTokens.get(fungibleTokenId))
            .setAccountId(bobAccountId)
            .freezeWith(client)
            .sign(wipePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(nftOwnerAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(bobAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setTokenId(nftTokenId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setTokenId(fungibleTokenId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Account Auto-Creation Via HTS Assets (HIP-542) Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/AccountCreationWaysExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;

/**
 * How to create a Hedera account in different ways.
 * <p>
 * In Hedera there are 4 different account representations:
 * <ul>
 *   <li>an account can have an account ID in shard.realm.accountNumber format (0.0.10);</li>
 *   <li>an account can have a public key alias in 0.0.CIQNOWUYAGBLCCVX2VF75U6JMQDTUDXBOLZ5VJRDEWXQEGTI64DVCGQ format;</li>
 *   <li>an account can have an AccountId that is represented in 0x000000000000000000000000000000000000000a (for account ID 0.0.10) long zero format;</li>
 *   <li>an account can be represented by an Ethereum public address 0xb794f5ea0ba39494ce839613fffba74279579268.</li>
 * </ul>
 */
class AccountCreationWaysExample {

    public static void main(String[] args) {
        System.out.println("Account Creation Ways Example Start!");

        /*
         * Account ID:
         * shard.realm.number format, i.e. 0.0.10 with the corresponding 0x000000000000000000000000000000000000000a ethereum address
         */
        AccountId hederaFormat = AccountId.fromString("0.0.10");
        System.out.println("Account ID: " + hederaFormat);
        System.out.println("Account \"0.0.10\" corresponding long-zero address: " + hederaFormat.toSolidityAddress());

        /*
         * Hedera Long-Form Account ID:
         * 0.0.aliasPublicKey, i.e. 0.0.CIQNOWUYAGBLCCVX2VF75U6JMQDTUDXBOLZ5VJRDEWXQEGTI64DVCGQ
         */
        PrivateKey privateKey = PrivateKey.generateECDSA();
        PublicKey publicKey = privateKey.getPublicKey();

        // Assuming that the target shard and realm are known.
        // For now, they are virtually always 0.
        AccountId aliasAccountId = publicKey.toAccountId(0, 0);
        System.out.println("Hedera long-form account ID: " + aliasAccountId.toString());

        /*
         * Hedera Account Long-Zero address:
         * 0x000000000000000000000000000000000000000a (for accountId 0.0.10)
         */
        AccountId longZeroAddress = AccountId.fromString("0x000000000000000000000000000000000000000a");
        System.out.println("Hedera account long-zero address: " + longZeroAddress);

        /*
         * Ethereum Account Address or public-address:
         * 0xb794f5ea0ba39494ce839613fffba74279579268
         */
        AccountId evmAddress = AccountId.fromString("0xb794f5ea0ba39494ce839613fffba74279579268");
        System.out.println("Ethereum account address or public address: " + evmAddress);

        System.out.println("Account Creation Ways Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/AutoCreateAccountTransferTransactionExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to use auto account creation (HIP-583).
 * <p>
 * This HIP allows any new account on Hedera to have an ECDSA derived alias, compatible with Ethereum addresses,
 * and permits the use of this alias for all operations supported by alias today.
 * This HIP expands support in the auto-create flow for ECDSA derived addresses to be used as the alias.
 * It also adds support to CryptoCreate transactions for creation with an ECDSA derived alias.
 */
public class AutoCreateAccountTransferTransactionExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Auto Create Account Via Transfer Transaction (HIP-583) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ECSDA private key.
         */
        PrivateKey privateKey = PrivateKey.generateECDSA();

        /*
         * Step 2:
         * Extract ECDSA public key.
         */
        PublicKey publicKey = privateKey.getPublicKey();

        /*
         * Step 3:
         * Extract Ethereum public address.
         */
        EvmAddress evmAddress = publicKey.toEvmAddress();
        System.out.println("EVM address of the new account: " + evmAddress);

        /*
         * Step 4:
         * Use the TransferTransaction.
         * - populate the FromAddress with the sender Hedera account ID;
         * - populate the ToAddress with Ethereum public address.
         *
         * Note: Can transfer from public address to public address in the TransferTransaction for complete accounts.
         * Transfers from hollow accounts will not work because the hollow account does not have a public key
         * assigned to authorize transfers out of the account.
         */
        TransferTransaction transferTx = new TransferTransaction()
            .addHbarTransfer(OPERATOR_ID, Hbar.from(1).negated())
            .addHbarTransfer(AccountId.fromEvmAddress(evmAddress), Hbar.from(1))
            .freezeWith(client);

        /*
         * Step 5:
         * Sign and execute the TransferTransaction transaction using existing Hedera account
         * and key paying for the transaction fee.
         */
        System.out.println("Transferring Hbar to the the new account...");
        TransactionResponse transferTxResponse = transferTx.execute(client);

        /*
         * Step 6:
         * Get the new account ID ask for the child receipts or child records for the parent transaction ID of the TransferTransaction
         * (the AccountCreateTransaction is executed as a child transaction triggered by the TransferTransaction).
         */
        TransactionReceipt transferTxReceipt = new TransactionReceiptQuery()
            .setTransactionId(transferTxResponse.transactionId)
            .setIncludeChildren(true)
            .execute(client);

        AccountId aliceAccountId = transferTxReceipt.children.get(0).accountId;
        Objects.requireNonNull(aliceAccountId);
        System.out.println("The \"normal\" account ID of the given alias: " + aliceAccountId);

        /*
         * Step 7:
         * Get the AccountInfo and verify the account is a hollow account with the supplied public address (may need to verify with mirror node API).
         *
         * The Hedera Account that was created has a public address the user specified in the TransferTransaction ToAddress:
         *  - will not have a public key at this stage;
         *  - cannot do anything besides receive Hbar or tokens;
         *  - the alias property of the account does not have the public address;
         *  - referred to as a hollow account.
         */
        AccountInfo aliceAccountInfo_BeforeEnhancing = new AccountInfoQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        if (((KeyList) aliceAccountInfo_BeforeEnhancing.key).isEmpty()) {
            System.out.println("The newly created account is a hollow account! (Success)");
        } else {
            throw new Exception("The newly created account is not a hollow account! (Fail)");
        }

        /*
         * Step 8:
         * Create a HAPI transaction and assign the new hollow account as the transaction fee payer.
         *
         * Sign with the private key that corresponds to the public key on the hollow account
         * (to enhance the hollow account to have a public key the hollow account needs to be specified as a transaction fee payer in a HAPI transaction).
         */
        System.out.println("Creating new topic...");
        TransactionReceipt topicCreateTxReceipt = new TopicCreateTransaction()
            .setAdminKey(publicKey)
            .setTransactionId(TransactionId.generate(aliceAccountId))
            .setTopicMemo("Memo")
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Created new topic with ID: " + topicCreateTxReceipt.topicId);

        /*
         * Step 9:
         * Get the account info and return public key to show its complete account.
         */
        AccountInfo aliceAccountInfo_AfterEnhancing = new AccountInfoQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        System.out.println("The public key of the newly created and now complete account: " + aliceAccountInfo_AfterEnhancing.key);

        /*
         * Clean up:
         * Delete created account and topic.
         */
        new AccountDeleteTransaction()
            .setTransferAccountId(OPERATOR_ID)
            .setAccountId(aliceAccountId)
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        new TopicDeleteTransaction()
            .setTopicId(topicCreateTxReceipt.topicId)
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Auto Create Account Via Transfer Transaction (HIP-583) Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ChangeRemoveTokenKeys.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to change or remove existing keys from a token (HIP-540).
 * <p>
 * All entities across Hedera have opt-in administrative keys (or simply admin keys).
 * Currently, the Consensus Service and File service allow these keys to be removed
 * by an update that sets them to an empty KeyList, which is a sentinel value for immutability.
 * However the Hedera Token Service does not provide such a feature consistently.
 * We should enable existing admin keys for tokens created with the Hedera Token Service
 * to be able to sign an update transaction that changes or permanently removes any key
 * (Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata) from the token.
 */
class ChangeRemoveTokenKeys {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Change Or Remove Existing Keys From A Token (HIP-540) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey adminPrivateKey = PrivateKey.generateED25519();
        PublicKey adminPublicKey = adminPrivateKey.getPublicKey();

        PrivateKey supplyPrivateKey = PrivateKey.generateED25519();
        PublicKey supplyPublicKey = supplyPrivateKey.getPublicKey();

        PrivateKey newSupplyPrivateKey = PrivateKey.generateED25519();
        PublicKey newSupplyPublicKey = newSupplyPrivateKey.getPublicKey();

        PrivateKey wipePrivateKey = PrivateKey.generateED25519();
        PublicKey wipePublicKey = wipePrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create NFT and check its keys.
         */
        System.out.println("Creating NFT using the Hedera Token Service...");
        var nftTokenId = new TokenCreateTransaction()
            .setTokenName("HIP-540 NFT")
            .setTokenSymbol("HIP540NFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setTreasuryAccountId(OPERATOR_ID)
            .setAdminKey(adminPublicKey)
            .setWipeKey(wipePublicKey)
            .setSupplyKey(supplyPublicKey)
            .freezeWith(client)
            .sign(adminPrivateKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;
        Objects.requireNonNull(nftTokenId);

        var nftInfoBefore = new TokenInfoQuery()
            .setTokenId(nftTokenId)
            .execute(client);

        if (nftInfoBefore.adminKey != null &&
            nftInfoBefore.supplyKey != null &&
            nftInfoBefore.wipeKey != null) {
            System.out.println("Admin public key in the newly created token: " + nftInfoBefore.adminKey);
            System.out.println("Supply public key in the newly created token: " + nftInfoBefore.supplyKey);
            System.out.println("Wipe public key in the newly created token: " + nftInfoBefore.wipeKey);
        } else {
            throw new Exception("The required keys are not set correctly! (Fail)");
        }

        /*
         * Step 3:
         * Remove Wipe Key from a token (by updating it to an empty Key List) and check that its removed.
         */
        System.out.println("Removing the Wipe Key...(updating to an empty Key List).");

        // This HIP introduces ability to remove lower-privilege keys
        // (Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata) from a Token
        // using an update with the empty KeyList.
        var emptyKeyList = new KeyList();

        new TokenUpdateTransaction()
            .setTokenId(nftTokenId)
            .setWipeKey(emptyKeyList)
            // It is set by default, but we set it here explicitly for illustration.
            .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
            .freezeWith(client)
            .sign(adminPrivateKey)
            .execute(client)
            .getReceipt(client);

        var nftInfoAfterWipeKeyRemoval = new TokenInfoQuery()
            .setTokenId(nftTokenId)
            .execute(client);

        if (nftInfoAfterWipeKeyRemoval.wipeKey == null) {
            System.out.println("Token Wipe Public Key (after removal): " + nftInfoAfterWipeKeyRemoval.wipeKey);
        } else {
            throw new Exception("Token Wipe Key was not removed after removal operation! (Fail)");
        }

        /*
         * Step 4:
         * Remove Admin Key from a token (by updating it to an empty Key List) and check that its removed.
         */
        System.out.println("Removing the Admin Key...(updating to an empty Key List).");

        new TokenUpdateTransaction()
            .setTokenId(nftTokenId)
            .setAdminKey(emptyKeyList)
            .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
            .freezeWith(client)
            .sign(adminPrivateKey)
            .execute(client)
            .getReceipt(client);

        var nftInfoAfterAdminKeyRemoval = new TokenInfoQuery()
            .setTokenId(nftTokenId)
            .execute(client);

        if (nftInfoAfterAdminKeyRemoval.adminKey == null) {
            System.out.println("Token Admin Public Key (after removal): " + nftInfoAfterAdminKeyRemoval.adminKey);
        } else {
            throw new Exception("Token Admin Key was not removed after removal operation! (Fail)");
        }

        /*
         * Step 5:
         * Update Supply Key and check that its updated.
         */
        System.out.println("Updating the Supply Key...(to the new key).");

        new TokenUpdateTransaction()
            .setTokenId(nftTokenId)
            .setSupplyKey(newSupplyPublicKey)
            .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
            .freezeWith(client)
            .sign(supplyPrivateKey)
            .sign(newSupplyPrivateKey)
            .execute(client)
            .getReceipt(client);

        var nftInfoAfterSupplyKeyUpdate = new TokenInfoQuery()
            .setTokenId(nftTokenId)
            .execute(client);

        if (nftInfoAfterSupplyKeyUpdate.supplyKey.equals(newSupplyPublicKey)) {
            System.out.println("Token Supply Public Key (after update): " + nftInfoAfterSupplyKeyUpdate.supplyKey);
        } else {
            throw new Exception("Token Supply Key was not updated correctly! (Fail)");
        }

        /*
         * Step 6:
         * Remove Supply Key (update to the unusable key).
         */
        System.out.println("Removing the Supply Key...(updating to the unusable key).");

        new TokenUpdateTransaction()
            .setTokenId(nftTokenId)
            .setSupplyKey(PublicKey.unusableKey())
            .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
            .freezeWith(client)
            .sign(newSupplyPrivateKey)
            .execute(client)
            .getReceipt(client);

        var nftInfoAfterSupplyKeyRemoval = new TokenInfoQuery()
            .setTokenId(nftTokenId)
            .execute(client);

        var supplyKeyAfterRemoval = (PublicKey) nftInfoAfterSupplyKeyRemoval.supplyKey;

        if (supplyKeyAfterRemoval.equals(PublicKey.unusableKey())) {
            System.out.println("Token Supply Public Key (after removal): " + supplyKeyAfterRemoval.toStringRaw());
        } else {
            throw new Exception("Token Supply key was not removed after removal operation! (Fail)");
        }

        /*
         * Clean up:
         * Can't delete a token as it is immutable.
         */
        client.close();

        System.out.println("Change Or Remove Existing Keys From A Token (HIP-540) Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ClientHelper.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Hbar;

import java.util.HashMap;
import java.util.List;

public class ClientHelper {

    public static final String LOCAL_NETWORK_NAME = "localhost";

    private static final String LOCAL_CONSENSUS_NODE_ENDPOINT = "127.0.0.1:50211";

    private static final String LOCAL_MIRROR_NODE_GRPC_ENDPOINT = "127.0.0.1:5600";

    private static final AccountId LOCAL_CONSENSUS_NODE_ACCOUNT_ID = new AccountId(3);

    public static Client forName(String network) throws InterruptedException {
        Client client;

        if (network.equals(LOCAL_NETWORK_NAME)) {
            client = forLocalNetwork();
        } else {
            client = Client.forName(network);
        }
        return client.setDefaultMaxTransactionFee(new Hbar(50));
    }

    public static Client forLocalNetwork() throws InterruptedException {
        var network = new HashMap<String, AccountId>();
        network.put(LOCAL_CONSENSUS_NODE_ENDPOINT, LOCAL_CONSENSUS_NODE_ACCOUNT_ID);

        return Client.forNetwork(network)
            .setMirrorNetwork(List.of(LOCAL_MIRROR_NODE_GRPC_ENDPOINT));
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ConsensusPubSubChunkedExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * How to send large message to the private HCS topic and how to subscribe to the topic to receive it.
 */
class ConsensusPubSubChunkedExample {

    private static final CountDownLatch LARGE_MESSAGE_LATCH = new CountDownLatch(1);

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Consensus Service Submit Large Message And Subscribe Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Generate ED25519 key pair (Submit Key to use with the topic).
         */
        System.out.println("Generating ED25519 key pair...");
        PrivateKey submitPrivateKey = PrivateKey.generateED25519();
        PublicKey submitPublicKey = submitPrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create new HCS topic.
         */
        System.out.println("Creating new topic...");

        TopicId hederaTopicID = new TopicCreateTransaction()
            .setTopicMemo("hedera-sdk-java/ConsensusPubSubChunkedExample")
            .setAdminKey(operatorPublicKey)
            .setSubmitKey(submitPublicKey)
            .execute(client)
            .getReceipt(client)
            .topicId;
        Objects.requireNonNull(hederaTopicID);

        System.out.println("Created new topic with ID: " + hederaTopicID);

        /*
         * Step 3:
         * Wait 10 seconds (to ensure data propagated to mirror nodes).
         */
        System.out.println("Wait 5 seconds (to ensure data propagated to mirror nodes) ...");
        Thread.sleep(5_000);

        /*
         * Step 4:
         * Subscribe to messages on the topic, printing out the received message and metadata as it is published by the
         * Hedera mirror node.
         */
        System.out.println("Setting up a mirror client...");
        new TopicMessageQuery()
            .setTopicId(hederaTopicID)
            .subscribe(client, topicMessage -> {
                System.out.println("Topic message received!" +
                    " | Time: " + topicMessage.consensusTimestamp +
                    " | Sequence No.: " + topicMessage.sequenceNumber +
                    " | Size: " + topicMessage.contents.length + " bytes.");
                LARGE_MESSAGE_LATCH.countDown();
            });

        /*
         * Step 5:
         * Send large message to the topic created previously.
         */
        // Get a large file to send.
        String largeMessage = readResources("util/large_message.txt");

        // Prepare a message send transaction that requires a submit key from "somewhere else".
        Transaction<?> topicMessageSubmitTx = new TopicMessageSubmitTransaction()
            // This is value 10 by default,
            // increasing so large message will "fit".
            .setMaxChunks(15)
            .setTopicId(hederaTopicID)
            .setMessage(largeMessage)
            // Sign with the operator or "sender" of the message,
            // this is the party who will be charged the transaction fee.
            .signWithOperator(client);

        // Serialize to bytes, so we can be signed "somewhere else" by the submit key.
        byte[] transactionBytes = topicMessageSubmitTx.toBytes();

        // Now pretend we sent those bytes across the network.
        // Parse them into a transaction, so we can sign as the submit key.
        topicMessageSubmitTx = Transaction.fromBytes(transactionBytes);

        // View out the message size from the parsed transaction.
        // This can be useful to display what we are about to sign.
        long transactionMessageSize = ((TopicMessageSubmitTransaction) topicMessageSubmitTx).getMessage().size();
        System.out.println("Preparing to submit a message to the created topic (size of the message: " + transactionMessageSize + " bytes)...");

        // Sign with that Submit Key.
        topicMessageSubmitTx.sign(submitPrivateKey);

        // Now actually submit the transaction and get the receipt to ensure there were no errors.
        topicMessageSubmitTx.execute(client).getReceipt(client);

        // Wait 60 seconds to receive the message. Fail if not received.
        boolean largeMessageReceived = LARGE_MESSAGE_LATCH.await(60, TimeUnit.SECONDS);

        /*
         * Clean up:
         * Delete created topic.
         */
        new TopicDeleteTransaction()
            .setTopicId(hederaTopicID)
            .execute(client)
            .getReceipt(client);

        client.close();

        // Fail if message wasn't received.
        if (!largeMessageReceived) {
            throw new TimeoutException("Large topic message was not received! (Fail)");
        }

        System.out.println("Consensus Service Submit Large Message And Subscribe Example Complete!");
    }

    private static String readResources(String filename) {
        InputStream inputStream = ConsensusPubSubChunkedExample.class.getResourceAsStream(filename);
        StringBuilder bigContents = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(inputStream), UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                bigContents.append(line).append("\n");
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return bigContents.toString();
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ConsensusPubSubExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.charset.StandardCharsets;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * How to operate with a public HCS topic.
 * <p>
 * Subscribe to the topic and publish a number of messages to the topic (no key required).
 */
class ConsensusPubSubExample {

    private static final int TOTAL_MESSAGES = 5;

    private static final CountDownLatch MESSAGES_LATCH = new CountDownLatch(TOTAL_MESSAGES);

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Consensus Service Submit Message To The Public Topic And Subscribe Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Create new HCS topic.
         */
        System.out.println("Creating new topic...");

        TransactionResponse topicCreateTxResponse = new TopicCreateTransaction()
            .setAdminKey(operatorPublicKey)
            .execute(client);

        TransactionReceipt transactionReceipt = topicCreateTxResponse.getReceipt(client);
        TopicId hederaTopicId = Objects.requireNonNull(transactionReceipt.topicId);
        System.out.println("Created new topic with ID: " + hederaTopicId);

        /*
         * Step 2:
         * Wait 5 seconds (to ensure data propagated to mirror nodes).
         */
        System.out.println("Wait 5 seconds (to ensure data propagated to mirror nodes) ...");
        Thread.sleep(5_000);

        /*
         * Step 3:
         * Subscribe to messages on the topic, printing out the received message and metadata as it is published by the
         * Hedera mirror node.
         */
        System.out.println("Setting up a mirror client...");
        new TopicMessageQuery()
            .setTopicId(hederaTopicId)
            .subscribe(client, resp -> {
                String messageAsString = new String(resp.contents, StandardCharsets.UTF_8);
                System.out.println("Topic message received!" +
                    " | Time: " + resp.consensusTimestamp +
                    " | Content: " + messageAsString);
                MESSAGES_LATCH.countDown();
            });

        /*
         * Step 4:
         * Publish a list of messages to a topic.
         */
        for (int i = 0; i <= TOTAL_MESSAGES; i++) {
            String message = "message #" + i;

            System.out.println("Publishing message to the topic: " + message);

            new TopicMessageSubmitTransaction()
                .setTopicId(hederaTopicId)
                .setMessage(message)
                .execute(client)
                .getReceipt(client);

            Thread.sleep(2_000);
        }

        // Wait 60 seconds to receive all the messages. Fail if not received.
        boolean allMessagesReceived = MESSAGES_LATCH.await(60, TimeUnit.SECONDS);

        /*
         * Clean up:
         * Delete created topic.
         */
        new TopicDeleteTransaction()
            .setTopicId(hederaTopicId)
            .execute(client)
            .getReceipt(client);

        client.close();

        // Fail if messages weren't received.
        if (!allMessagesReceived) {
            throw new TimeoutException("Not all topic messages were received! (Fail)");
        }

        System.out.println("Consensus Service Submit Message To The Public Topic And Subscribe Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ConsensusPubSubWithSubmitKeyExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * How to operate with a private HCS topic.
 * <p>
 * Create a new HCS topic with a single ED25519 Submit Key,
 * publish a number of messages to the topic signed by the Submit Key
 * and subscribe to the topic (no key required).
 */
class ConsensusPubSubWithSubmitKeyExample {

    private static final int TOTAL_MESSAGES = 5;

    private static final CountDownLatch MESSAGES_LATCH = new CountDownLatch(TOTAL_MESSAGES);

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Consensus Service Submit Message To The Private Topic And Subscribe Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        PublicKey operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Generate ED25519 key pair (Submit Key to use with the topic).
         */
        System.out.println("Generating ED25519 key pair...");
        PrivateKey submitPrivateKey = PrivateKey.generateED25519();
        PublicKey submitPublicKey = submitPrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create new HCS topic with the key right above as the topic's Submit Key required to sign all future
         * ConsensusMessageSubmitTransactions for that topic.
         */
        System.out.println("Creating new HCS topic...");
        TransactionResponse topicCreateTxResponse = new TopicCreateTransaction()
            .setTopicMemo("HCS topic with Submit Key")
            .setAdminKey(operatorPublicKey)
            .setSubmitKey(submitPublicKey)
            .execute(client);

        TopicId hederaTopicId = Objects.requireNonNull(topicCreateTxResponse.getReceipt(client).topicId);
        System.out.println("Created topic with ID: " + hederaTopicId + " and public ED25519 submit key: " + submitPrivateKey);

        /*
         * Step 3:
         * Wait 5 seconds (to ensure data propagated to mirror nodes).
         */
        System.out.println("Wait 5 seconds (to ensure data propagated to mirror nodes) ...");
        Thread.sleep(5_000);

        /*
         * Step 4:
         * Subscribe to messages on the topic, printing out the received message and metadata as it is published by the
         * Hedera mirror node.
         */
        System.out.println("Setting up a mirror client...");
        new TopicMessageQuery()
            .setTopicId(hederaTopicId)
            .setStartTime(Instant.ofEpochSecond(0))
            .subscribe(client, (resp) -> {
                String messageAsString = new String(resp.contents, StandardCharsets.UTF_8);
                System.out.println("Topic message received!" +
                    " | Time: " + resp.consensusTimestamp +
                    " | Content: " + messageAsString);
                MESSAGES_LATCH.countDown();
            });

        /*
         * Step 5:
         * Publish a list of messages to a topic, signing each transaction with the topic's Submit Key.
         */
        Random randomGenerator = new Random();
        for (int i = 0; i <= TOTAL_MESSAGES; i++) {
            String message = "random message " + randomGenerator.nextLong();

            System.out.println("Publishing message to the topic: " + message);

            new TopicMessageSubmitTransaction()
                .setTopicId(hederaTopicId)
                .setMessage(message)
                .freezeWith(client)

                // The transaction is automatically signed by the payer.
                // Due to the topic having a submitKey requirement, additionally sign the transaction with that key.
                .sign(submitPrivateKey)

                .execute(client)
                .transactionId
                .getReceipt(client);

            Thread.sleep(2_000);
        }

        // Wait 60 seconds to receive all the messages. Fail if not received.
        boolean allMessagesReceived = MESSAGES_LATCH.await(60, TimeUnit.SECONDS);

        /*
         * Clean up:
         * Delete created topic.
         */
        new TopicDeleteTransaction()
            .setTopicId(hederaTopicId)
            .execute(client)
            .getReceipt(client);

        client.close();

        // Fail if messages weren't received.
        if (!allMessagesReceived) {
            throw new TimeoutException("Not all topic messages were received! (Fail)");
        }

        System.out.println("Consensus Service Submit Message To The Private Topic And Subscribe Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ConstructClientExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.NetworkName;
import com.hedera.hashgraph.sdk.PrivateKey;
import io.github.cdimascio.dotenv.Dotenv;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;

/**
 * How to construct and configure a client in different ways.
 * <p>
 * A client has a network and an operator.
 * <p>
 * A Hedera network is made up of nodes -- individual servers who participate
 * in the process of reaching consensus on the order and validity of transactions
 * on the network. Three networks you likely know of are previewnet, testnet, and mainnet.
 * <p>
 * For the purpose of connecting to it, each node has an IP address or URL and a port number.
 * Each node also has an AccountId used to refer to that node for several purposes,
 * including the paying of fees to that node when a client submits requests to it.
 * <p>
 * You can configure what network you want a client to use -- in other words, you can specify
 * a list of URLs and port numbers with associated account IDs, and
 * when that client is used to execute queries and transactions, the client will
 * submit requests only to nodes in that list.
 * <p>
 * A Client has an operator, which has an AccountId and a PublicKey, and which can
 * sign requests. A client's operator can also be configured.
 */
class ConstructClientExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Path to .json config file. See resources/client-config.json
     */
    @Nullable
    private static final String CONFIG_FILE = Dotenv.load().get("CONFIG_FILE");

    private static final String HEDERA_NETWORK = "testnet";

    public static void main(String[] args) throws Exception {
        System.out.println("Construct Client Example Start!");

        /*
         * Here's the simplest way to construct a client.
         * These clients' networks are filled with default lists of nodes that are baked into the SDK.
         * Their operators are not yet set, and trying to use them now will result in exceptions.
         */
        Client testnetClient = Client.forTestnet();
        Client previewnetClient = Client.forPreviewnet();
        Client mainnetClient = Client.forMainnet();

        /*
         * We can also construct a client for testnet, previewnet or mainnet depending on the value of a
         * network name string. If, for example, the input string equals "testnet", this client will be
         * configured to connect to testnet.
         */
        Client namedNetworkClient = Client.forName(HEDERA_NETWORK);

        // Let's set the operator on testnetClient.
        // (The AccountId and PrivateKey here are fake, this is just an example.)
        testnetClient.setOperator(
            AccountId.fromString("0.0.3"),
            PrivateKey.fromString("302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10")
        );

        // Let's create a client with a custom network.
        Map<String, AccountId> customNetwork = new HashMap<>();
        customNetwork.put("2.testnet.hedera.com:50211", new AccountId(5));
        customNetwork.put("3.testnet.hedera.com:50211", new AccountId(6));
        Client customClient = Client.forNetwork(customNetwork);

        /*
         * Since our customClient's network is in this case a subset of testnet, we should set the
         * network's name to testnet. If we don't do this, checksum validation won't work.
         * See ValidateChecksumExample. You can use customClient.getNetworkName()
         * to check the network name. If not set, it will return null.
         * If you attempt to validate a checksum against a client whose networkName is not set,
         * an IllegalStateException will be thrown.
         */
        customClient.setNetworkName(NetworkName.TESTNET);

        /*
         * Let's generate a client from a config.json file.
         * A config file may specify a network by name, or it may provide a custom network
         * in the form of a list of nodes.
         * The config file should specify the operator, so you can use a client constructed
         * using fromConfigFile() immediately.
         */
        if (CONFIG_FILE != null) {
            Client configClient = Client.fromConfigFile(CONFIG_FILE);
            configClient.close();
        }

        // Always close a client when you're done with it.
        testnetClient.close();
        previewnetClient.close();
        mainnetClient.close();
        namedNetworkClient.close();
        customClient.close();

        System.out.println("Construct Client Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ContractHelper.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.ContractCreateFlow;
import com.hedera.hashgraph.sdk.ContractExecuteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractFunctionResult;
import com.hedera.hashgraph.sdk.ContractId;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransactionRecord;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;


/*
ContractHelper declutters PrecompileExample.java

When we instantiate a ContractHelper, we provide it with the JSON of a compiled solidity contract
which is assumed to have functions named "step0()" through "stepN()".

Each of these step functions is assumed to take no function parameters, and to return a Hedera ResponseCode
which ought to be SUCCESS -- in other words, an int32 with value 22.
See resources/com/hedera/hashgraph/sdk/examples/contracts/precompile/HederaResponseCodes.sol

If a step takes function parameters, or if its ContractFunctionResult should be validated with a different method,
the user can specify a supplier for a particular step with setParameterSupplier(stepIndex, parametersSupplier),
and can specify an alternative validation method with setResultValidator(stepIndex, validateFunction)

The contract is created on the Hedera network in the ContractHelper constructor, and when the user is ready to
execute the step functions in the contract, they should call executeSteps(firstStepToExecute, lastStepToExecute).
 */

public class ContractHelper {
    final ContractId contractId;
    final Map<Integer, Function<ContractFunctionResult, Boolean>> stepResultValidators = new HashMap<>();
    final Map<Integer, Supplier<ContractFunctionParameters>> stepParameterSuppliers = new HashMap<>();
    final Map<Integer, Hbar> stepPayableAmounts = new HashMap<>();
    final Map<Integer, List<PrivateKey>> stepSigners = new HashMap<>();
    final Map<Integer, AccountId> stepFeePayers = new HashMap<>();
    final Map<Integer, Consumer<String>> stepLogic = new HashMap<>();

    public static String getBytecodeHex(String filename) throws IOException {
        try (Reader reader = new InputStreamReader(
            Optional.ofNullable(ContractHelper.class.getResourceAsStream(filename))
                .orElseThrow(() -> new RuntimeException("Failed to find: " + filename)),
            StandardCharsets.UTF_8)) {

            JsonObject json = new Gson().fromJson(reader, JsonObject.class);
            JsonElement bytecodeElement = Optional.ofNullable(json.has("object") ? json.get("object") : json.get("bytecode"))
                .orElseThrow(() -> new RuntimeException("No bytecode or object found in json."));

            if (bytecodeElement.isJsonObject()) {
                bytecodeElement = bytecodeElement.getAsJsonObject().get("object");
            }
            return bytecodeElement.getAsString();
        }
    }

    public ContractHelper(
        String filename,
        ContractFunctionParameters constructorParameters,
        Client client
    ) throws PrecheckStatusException, TimeoutException, ReceiptStatusException, IOException {
        contractId = Objects.requireNonNull(new ContractCreateFlow()
            .setBytecode(getBytecodeHex(filename))
            .setMaxChunks(30)
            .setGas(8_000_000)
            .setConstructorParameters(constructorParameters)
            .execute(client)
            .getReceipt(client)
            .contractId);
    }

    public ContractHelper setResultValidatorForStep(int stepIndex, Function<ContractFunctionResult, Boolean> validator) {
        stepResultValidators.put(stepIndex, validator);
        return this;
    }

    public ContractHelper setParameterSupplierForStep(int stepIndex, Supplier<ContractFunctionParameters> supplier) {
        stepParameterSuppliers.put(stepIndex, supplier);
        return this;
    }

    public ContractHelper setPayableAmountForStep(int stepIndex, Hbar amount) {
        stepPayableAmounts.put(stepIndex, amount);
        return this;
    }

    public ContractHelper addSignerForStep(int stepIndex, PrivateKey signer) {
        if (stepSigners.containsKey(stepIndex)) {
            stepSigners.get(stepIndex).add(signer);
        } else {
            List<PrivateKey> signerList = new ArrayList<>(1);
            signerList.add(signer);
            stepSigners.put(stepIndex, signerList);
        }
        return this;
    }

    public ContractHelper setFeePayerForStep(int stepIndex, AccountId feePayerAccount, PrivateKey feePayerKey) {
        stepFeePayers.put(stepIndex, feePayerAccount);
        return addSignerForStep(stepIndex, feePayerKey);
    }

    public ContractHelper setStepLogic(int stepIndex, Consumer<String> stepLogic) {
        this.stepLogic.put(stepIndex, stepLogic);
        return this;
    }

    private Function<ContractFunctionResult, Boolean> getResultValidator(int stepIndex) {
        return stepResultValidators.getOrDefault(
            stepIndex,
            // if no custom validator is given, assume that the step returns a response code which ought to be SUCCESS
            contractFunctionResult -> {
                Status responseStatus = Status.fromResponseCode(contractFunctionResult.getInt32(0));
                boolean isValid = responseStatus == Status.SUCCESS;
                if (!isValid) {
                    System.out.println("Encountered invalid response status " + responseStatus);
                }
                return isValid;
            }
        );
    }

    private Supplier<ContractFunctionParameters> getParameterSupplier(int stepIndex) {
        return stepParameterSuppliers.getOrDefault(stepIndex, () -> null);
    }

    private Hbar getPayableAmount(int stepIndex) {
        return stepPayableAmounts.get(stepIndex);
    }

    private List<PrivateKey> getSigners(int stepIndex) {
        return stepSigners.getOrDefault(stepIndex, Collections.emptyList());
    }

    public ContractHelper executeSteps(
        int firstStepToExecute,
        int lastStepToExecute,
        Client client
    ) throws Exception {
        for (int stepIndex = firstStepToExecute; stepIndex <= lastStepToExecute; stepIndex++) {
            System.out.println("Attempting to execute step " + stepIndex);
            ContractExecuteTransaction tx = new ContractExecuteTransaction()
                .setContractId(contractId)
                .setGas(10_000_000);

            Hbar payableAmount = getPayableAmount(stepIndex);
            if (payableAmount != null) {
                tx.setPayableAmount(payableAmount);
            }

            String functionName = "step" + stepIndex;
            ContractFunctionParameters parameters = getParameterSupplier(stepIndex).get();
            if (parameters != null) {
                tx.setFunction(functionName, parameters);
            } else {
                tx.setFunction(functionName);
            }

            AccountId feePayerAccountId = stepFeePayers.get(stepIndex);
            if (feePayerAccountId != null) {
                tx.setTransactionId(TransactionId.generate(feePayerAccountId));
            }

            tx.freezeWith(client);
            for (PrivateKey signer : getSigners(stepIndex)) {
                tx.sign(signer);
            }

            TransactionRecord record = tx
                .execute(client)
                .setValidateStatus(false)
                .getRecord(client);

            try {
                if (record.receipt.status != Status.SUCCESS) {
                    throw new Exception("transaction receipt yielded unsuccessful response code " + record.receipt.status);
                }

                ContractFunctionResult functionResult = Objects.requireNonNull(record.contractFunctionResult);
                System.out.println("gas used: " + functionResult.gasUsed);

                var currentStepLogic = stepLogic.get(stepIndex);
                if (currentStepLogic != null) {
                    currentStepLogic.accept(functionResult.getAddress(1));
                }

                if (getResultValidator(stepIndex).apply(functionResult)) {
                    System.out.println("step " + stepIndex + " completed, and returned valid result. (TransactionId \"" + record.transactionId + "\")");
                } else {
                    throw new Exception("returned invalid result");
                }
            } catch (Throwable error) {
                throw new Exception("Error occurred in step " + stepIndex + ": " + error.getMessage() + "\n" + "Transaction record: " + record);
            }

            // otherwise will meet local-node throttle
            Thread.sleep(500L);
        }
        return this;
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ContractNoncesExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.List;
import java.util.Objects;

/**
 * How to check contract nonces and validate HIP-729 behaviour.
 * <p>
 * HIP-729: Contract Accounts Nonce Externalization.
 * A deployed contract A should have a nonce value that reflects the number
 * of other contracts that were created since As creation.
 * <p>
 * To validate this behaviour, we deploy contract, which deploys another contract in its constructor.
 */
class ContractNoncesExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Contract Nonces (HIP-729) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        PublicKey operatorPublicKey = OPERATOR_KEY.getPublicKey();

        System.out.println("Creating new contract...");

        /*
         * Step 1:
         * Create a file with smart contract bytecode.
         */
        String contractBytecodeHex = ContractHelper.getBytecodeHex("contracts/parent_deploys_child/parent_deploys_child.json");
        TransactionResponse bytecodeFileCreateTxResponse = new FileCreateTransaction()
            .setKeys(operatorPublicKey)
            .setContents(contractBytecodeHex)
            .setMaxTransactionFee(Hbar.from(2))
            .execute(client);

        TransactionReceipt bytecodeFileCreateTxReceipt = bytecodeFileCreateTxResponse.getReceipt(client);
        FileId bytecodeFileId = bytecodeFileCreateTxReceipt.fileId;
        Objects.requireNonNull(bytecodeFileId);

        /*
         * Step 2:
         * Create a smart contract.
         */
        TransactionResponse contractCreateTxResponse = new ContractCreateTransaction()
            .setAdminKey(operatorPublicKey)
            .setGas(100_000)
            .setBytecodeFileId(bytecodeFileId)
            .setContractMemo("HIP-729 Contract")
            .execute(client);

        TransactionReceipt contractCreateTxReceipt = contractCreateTxResponse.getReceipt(client);
        ContractId contractId = contractCreateTxReceipt.contractId;
        Objects.requireNonNull(contractId);

        System.out.println("Created new contract with ID: " + contractId);

        /*
         * Step 3:
         * Get a record from a contract create transaction to check contracts nonces.
         * We expect to see `nonce=2` as we deploy a contract that creates another contract in its constructor.
         */
        List<ContractNonceInfo> contractNonces = contractCreateTxResponse.
            getRecord(client)
            .contractFunctionResult
            .contractNonces;

        System.out.println("Contract nonces: " + contractNonces);

        /*
         * Clean up:
         * Delete created contract.
         */
        new ContractDeleteTransaction()
            .setContractId(contractId)
            .setTransferAccountId(contractCreateTxReceipt.transactionId.accountId)
            .setMaxTransactionFee(Hbar.from(1))
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Contract Nonces (HIP-729) Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateAccountExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to create a Hedera account.
 */
class CreateAccountExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Create Account Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 private and public key pair for the account.
         */
        PrivateKey privateKey = PrivateKey.generateED25519();
        PublicKey publicKey = privateKey.getPublicKey();
        System.out.println("Future account private key: " + privateKey);
        System.out.println("Future account public key: " + publicKey);

        /*
         * Step 2:
         * Create a new account.
         */
        System.out.println("Creating new account...");
        TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
            // The only required property here is `key`.
            .setKey(publicKey)
            .setInitialBalance(Hbar.from(1))
            .execute(client);

        // This will wait for the receipt to become available.
        TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);
        AccountId newAccountId = accountCreateTxReceipt.accountId;
        Objects.requireNonNull(newAccountId);
        System.out.println("Created account with ID: " + newAccountId);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setTransferAccountId(OPERATOR_ID)
            .setAccountId(newAccountId)
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Create Account Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateAccountThresholdKeyExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * How to create a Hedera account with threshold key.
 */
class CreateAccountThresholdKeyExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Create Account With Threshold Key Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate three new Ed25519 private, public key pairs.
         *
         * You do not need the private keys to create the Threshold Key List,
         * you only need the public keys, and if you're doing things correctly,
         * you probably shouldn't have these private keys.
         */
        PrivateKey[] privateKeys = new PrivateKey[3];
        PublicKey[] publicKeys = new PublicKey[3];
        for (int i = 0; i < 3; i++) {
            PrivateKey key = PrivateKey.generateED25519();
            privateKeys[i] = key;
            publicKeys[i] = key.getPublicKey();
        }

        System.out.println("Generating public keys...");
        for (Key publicKey : publicKeys) {
            System.out.println("Generated public key: " + publicKey);
        }

        /*
         * Step 2:
         * Create a Key List.
         *
         * Require 2 of the 3 keys we generated to sign on anything modifying this account.
         */
        KeyList thresholdKey = KeyList.withThreshold(2);
        Collections.addAll(thresholdKey, publicKeys);

        /*
         * Step 2:
         * Create a new account setting a Key List from a previous step as an account's key.
         */
        System.out.println("Creating new account...");
        TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
            .setKey(thresholdKey)
            .setInitialBalance(Hbar.from(1))
            .execute(client);

        TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);
        AccountId newAccountId = Objects.requireNonNull(accountCreateTxReceipt.accountId);
        Objects.requireNonNull(newAccountId);
        System.out.println("Created account with ID: " + newAccountId);

        /*
         * Step 2:
         * Create a transfer transaction from a newly created account to demonstrate the signing process (threshold).
         */
        System.out.println("Transferring 1 Hbar from a newly created account...");
        TransactionResponse transferTxResponse = new TransferTransaction()
            .addHbarTransfer(newAccountId, Hbar.from(1).negated())
            .addHbarTransfer(new AccountId(3), Hbar.from(1))
            // To manually sign, you must explicitly build the Transaction.
            .freezeWith(client)
            // We sign with 2 of the 3 keys.
            .sign(privateKeys[0])
            .sign(privateKeys[1])
            .execute(client);

        // (Important!) Wait for the transfer to reach the consensus.
        transferTxResponse.getReceipt(client);

        Hbar accountBalanceAfterTransfer = new AccountBalanceQuery()
            .setAccountId(newAccountId)
            .execute(client)
            .hbars;

        System.out.println("New account's Hbar balance after transfer: " + accountBalanceAfterTransfer);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setTransferAccountId(OPERATOR_ID)
            .setAccountId(newAccountId)
            .freezeWith(client)
            .sign(privateKeys[0])
            .sign(privateKeys[1])
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Create Account With Threshold Key Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateAccountWithAliasExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to create a Hedera account with alias.
 *
 */
class CreateAccountWithAliasExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Create Account With Alias Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Generate ECSDA private key.
         */
        PrivateKey privateKey = PrivateKey.generateECDSA();

        /*
         * Step 2:
         * Extract ECDSA public key.
         */
        PublicKey publicKey = privateKey.getPublicKey();

        /*
         * Step 3:
         * Extract Ethereum public address.
         */
        EvmAddress evmAddress = publicKey.toEvmAddress();
        System.out.println("EVM address of the new account: " + evmAddress);

        /*
         * Step 4:
         * Create new account.
         *
         * Set the EVM address field to the Ethereum public address.
         */
        AccountCreateTransaction accountCreateTx = new AccountCreateTransaction()
            .setInitialBalance(Hbar.from(1))
            .setKey(operatorPublicKey)
            .setAlias(evmAddress)
            .freezeWith(client);

        /*
         * Step 5:
         * Sign the AccountCreateTransaction transaction using an existing Hedera account and key paying for the transaction fee.
         */
        accountCreateTx.sign(privateKey);
        TransactionResponse accountCreateTxResponse = accountCreateTx.execute(client);

        AccountId newAccountId = new TransactionReceiptQuery()
            .setTransactionId(accountCreateTxResponse.transactionId)
            .execute(client)
            .accountId;
        Objects.requireNonNull(newAccountId);
        System.out.println("Created account with ID: " + newAccountId);

         /*
         * Step 6:
         * Get the AccountInfo and show that the account has contractAccountId.
         */
        AccountInfo newAccountInfo = new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        if (newAccountInfo.contractAccountId != null) {
            System.out.println("The newly account has alias: " + newAccountInfo.contractAccountId);
        } else {
            throw new Exception("The newly account doesn't have alias! (Fail)");
        }

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(newAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Create Account With Alias Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateFileExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to create a file.
 */
class CreateFileExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Create File Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Submit the file create transaction.
         */
        // The file is required to be a byte array,
        // you can easily use the bytes of a file instead.
        String fileContents = "Hedera hashgraph is great!";

        System.out.println("Creating new file...");
        TransactionResponse fileCreateTxResponse = new FileCreateTransaction()
            // Use the same key as the operator to "own" this file.
            .setKeys(operatorPublicKey)
            .setContents(fileContents)
            // The default max fee of 1 Hbar is not enough to create a file (starts around ~1.1 Hbar).
            .setMaxTransactionFee(Hbar.from(2))
            .execute(client);
        
        TransactionReceipt fileCreateTxReceipt = fileCreateTxResponse.getReceipt(client);
        FileId newFileId = fileCreateTxReceipt.fileId;
        Objects.requireNonNull(newFileId);
        System.out.println("Created new file with ID: " + newFileId);

        /*
         * Clean up:
         * Delete created file.
         */
        new FileDeleteTransaction()
            .setFileId(newFileId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Create File Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateSimpleContractExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.charset.StandardCharsets;
import java.util.Objects;

/**
 * How to create a simple stateless smart contract and call its function.
 */
class CreateSimpleContractExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Create Simple Contract Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Create a file with smart contract bytecode.
         */
        System.out.println("Creating new bytecode file...");
        String contractBytecodeHex = ContractHelper.getBytecodeHex("contracts/hello_world/hello_world.json");

        TransactionResponse fileCreateTxResponse = new FileCreateTransaction()
            // Use the same key as the operator to "own" this file.
            .setKeys(operatorPublicKey)
            .setContents(contractBytecodeHex.getBytes(StandardCharsets.UTF_8))
            .setMaxTransactionFee(Hbar.from(2))
            .execute(client);

        TransactionReceipt fileCreateTxReceipt = fileCreateTxResponse.getReceipt(client);
        FileId newFileId = Objects.requireNonNull(fileCreateTxReceipt.fileId);
        Objects.requireNonNull(newFileId);
        System.out.println("Created new bytecode file with ID: " + newFileId);

        /*
         * Step 2:
         * Create a smart contract.
         */
        System.out.println("Creating new contract...");
        TransactionResponse contractCreateTxResponse = new ContractCreateTransaction()
            .setGas(100_000)
            .setBytecodeFileId(newFileId)
            // Set an admin key, so we can delete the contract later.
            .setAdminKey(operatorPublicKey)
            .setMaxTransactionFee(Hbar.from(16))
            .execute(client);

        TransactionReceipt contractCreateTxReceipt = contractCreateTxResponse.getReceipt(client);
        ContractId newContractId = Objects.requireNonNull(contractCreateTxReceipt.contractId);
        Objects.requireNonNull(newContractId);
        System.out.println("Created new contract with ID: " + newContractId);

        /*
         * Step 3:
         * Call smart contract function.
         */
        System.out.println("Calling contract function \"greet\"...");
        ContractFunctionResult contractCallResult = new ContractCallQuery()
            .setGas(100_000)
            .setContractId(newContractId)
            .setFunction("greet")
            .setMaxQueryPayment(Hbar.from(1))
            .execute(client);

        if (contractCallResult.errorMessage != null) {
            throw new Exception("Error calling contract function \"greet\": " + contractCallResult.errorMessage);
        }

        String contractCallResultString = contractCallResult.getString(0);
        System.out.println("Contract call result (\"greet\" function returned): " + contractCallResultString);

        /*
         * Clean up:
         * Delete created contract.
         */
        new ContractDeleteTransaction()
            .setContractId(newContractId)
            .setTransferAccountId(contractCreateTxResponse.transactionId.accountId)
            .setMaxTransactionFee(Hbar.from(1))
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Create Simple Contract Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateStatefulContractExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to create a stateful smart contract and call its function.
 */
class CreateStatefulContractExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Create Stateful Contract Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));
        // Default max fee for all transactions executed by this client.
        client.setDefaultMaxTransactionFee(Hbar.from(100));
        client.setDefaultMaxQueryPayment(Hbar.from(10));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Create a file with smart contract bytecode.
         */
        System.out.println("Creating new bytecode file...");
        String contractBytecodeHex = ContractHelper.getBytecodeHex("contracts/stateful/stateful.json");

        TransactionResponse fileCreateTxResponse = new FileCreateTransaction()
            // Use the same key as the operator to "own" this file.
            .setKeys(operatorPublicKey)
            .setContents(contractBytecodeHex)
            .execute(client);

        TransactionReceipt fileCreateTxReceipt = fileCreateTxResponse.getReceipt(client);
        FileId newFileId = Objects.requireNonNull(fileCreateTxReceipt.fileId);
        Objects.requireNonNull(newFileId);
        System.out.println("Created new bytecode file with ID: " + newFileId);

        /*
         * Step 2:
         * Create a smart contract.
         */
        TransactionResponse contractCreateTxResponse = new ContractCreateTransaction()
            // Set an Admin Key, so we can delete the contract later.
            .setGas(150_000)
            .setBytecodeFileId(newFileId)
            .setAdminKey(operatorPublicKey)
            .setConstructorParameters(
                new ContractFunctionParameters()
                    .addString("Hello from Hedera!"))
            .execute(client);

        TransactionReceipt contractCreateTxReceipt = contractCreateTxResponse.getReceipt(client);
        ContractId newContractId = Objects.requireNonNull(contractCreateTxReceipt.contractId);
        Objects.requireNonNull(newContractId);
        System.out.println("Created new contract with ID: " + newContractId);

        /*
         * Step 3:
         * Call smart contract function.
         */
        System.out.println("Calling contract function \"get_message\"...");
        ContractFunctionResult contractCallResult_BeforeSetMessage = new ContractCallQuery()
            .setContractId(newContractId)
            .setGas(100_000)
            .setFunction("get_message")
            .setMaxQueryPayment(Hbar.from(1))
            .execute(client);

        if (contractCallResult_BeforeSetMessage.errorMessage != null) {
            throw new Exception("Error calling contract function \"get_message\": " + contractCallResult_BeforeSetMessage.errorMessage);
        }

        String contractCallResult_BeforeSetMessage_String = contractCallResult_BeforeSetMessage.getString(0);
        System.out.println("Contract call result (\"get_message\" function returned): " + contractCallResult_BeforeSetMessage_String);

        System.out.println("Calling contract function \"set_message\"...");
        TransactionResponse contractExecuteTxResponse = new ContractExecuteTransaction()
            .setContractId(newContractId)
            .setGas(100_000)
            .setFunction("set_message", new ContractFunctionParameters()
                .addString("Hello from hedera again!"))
            .execute(client);

        // If this doesn't throw then we know the contract executed successfully.
        contractExecuteTxResponse.getReceipt(client);

        /*
         * Step 3:
         * Call smart contract function.
         */
        System.out.println("Calling contract function \"get_message\"...");
        ContractFunctionResult contractCallResult_AfterSetMessage = new ContractCallQuery()
            .setGas(100_000)
            .setContractId(newContractId)
            .setFunction("get_message")
            .setMaxQueryPayment(Hbar.from(1))
            .execute(client);

        if (contractCallResult_AfterSetMessage.errorMessage != null) {
            throw new Exception("Error calling contract function \"get_message\": " + contractCallResult_AfterSetMessage.errorMessage);
        }

        String contractCallResult_AfterSetMessage_String = contractCallResult_AfterSetMessage.getString(0);
        System.out.println("Contract call result (\"get_message\" function returned): " + contractCallResult_AfterSetMessage_String);

        /*
         * Clean up:
         * Delete created contract.
         */
        new ContractDeleteTransaction()
            .setContractId(newContractId)
            .setTransferAccountId(contractCreateTxResponse.transactionId.accountId)
            .setMaxTransactionFee(Hbar.from(1))
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Create Stateful Contract Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CreateTopicExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to create a public HCS topic and submit a message to it.
 */
class CreateTopicExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Consensus Service Submit Message To The Public Topic Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Create new HCS topic.
         */
        System.out.println("Creating new topic...");

        TransactionResponse topicCreateTxResponse = new TopicCreateTransaction()
            .setAdminKey(operatorPublicKey)
            .execute(client);

        TransactionReceipt topicCreateTxReceipt = topicCreateTxResponse.getReceipt(client);
        TopicId topicId = topicCreateTxReceipt.topicId;
        Objects.requireNonNull(topicId);
        System.out.println("Created new topic with ID: " + topicId);

        /*
         * Step 2:
         * Submit message to the topic created in previous step.
         */
        System.out.println("Publishing message to the topic...");
        TransactionResponse topicMessageSubmitTxResponse = new TopicMessageSubmitTransaction()
            .setTopicId(topicCreateTxReceipt.topicId)
            .setMessage("Hello World")
            .execute(client);

        TransactionReceipt topicMessageSubmitTxReceipt = topicMessageSubmitTxResponse.getReceipt(client);
        System.out.println("Topic sequence number: " + topicMessageSubmitTxReceipt.topicSequenceNumber);

        /*
         * Clean up:
         * Delete created topic.
         */
        new TopicDeleteTransaction()
            .setTopicId(topicCreateTxReceipt.topicId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Consensus Service Submit Message To The Public Topic Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/CustomFeesExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * How to set and receive custom fees.
 */
class CustomFeesExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Custom Fees Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Create three accounts: Alice, Bob, and Charlie.
         *
         * Alice will be the treasury for our example token.
         * Fees only apply in transactions not involving the treasury, so we need two other accounts.
         */
        System.out.println("Creating Alice's, Bob's and Charlie's accounts...");

        Hbar initialAccountBalance = Hbar.from(1);
        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();
        AccountId aliceAccountId = new AccountCreateTransaction()
            .setInitialBalance(initialAccountBalance)
            .setKey(alicePublicKey)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(aliceAccountId);

        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();
        AccountId bobAccountId = new AccountCreateTransaction()
            .setInitialBalance(initialAccountBalance)
            .setKey(bobPublicKey)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(bobAccountId);

        PrivateKey charliePrivateKey = PrivateKey.generateED25519();
        PublicKey charliePublicKey = charliePrivateKey.getPublicKey();
        AccountId charlieAccountId = new AccountCreateTransaction()
            .setInitialBalance(initialAccountBalance)
            .setKey(charliePublicKey)
            .freezeWith(client)
            .sign(charliePrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(charlieAccountId);

        System.out.println("Alice's account ID: " + aliceAccountId);
        System.out.println("Bob's account ID: " + bobAccountId);
        System.out.println("Charlie's account ID: " + charlieAccountId);

        /*
         * Step 2:
         * Create a custom fee list of 1 fixed fee.
         *
         * A custom fee list can be a list of up to 10 custom fees,
         * where each fee is a fixed fee or a fractional fee.
         * This fixed fee will mean that every time Bob transfers any number of tokens to Charlie,
         * Alice will collect 1 Hbar from each account involved in the transaction who is SENDING
         * the Token (in this case, Bob).
         *
         * In this example the fee is in Hbar, but you can charge a fixed fee in a token if you'd like.
         * E.g., you can make it so that each time an account transfers Foo tokens,
         * they must pay a fee in Bar tokens to the fee collecting account.
         * To charge a fixed fee in tokens, instead of calling setHbarAmount(), call
         * setDenominatingTokenId(tokenForFee) and setAmount(tokenFeeAmount).
         */
        CustomFixedFee customHbarFee = new CustomFixedFee()
            .setHbarAmount(Hbar.from(1))
            .setFeeCollectorAccountId(aliceAccountId);
        List<CustomFee> hbarFeeList = Collections.singletonList(customHbarFee);

        /*
         * Step 3:
         * Create a fungible token.
         *
         * Setting the feeScheduleKey to Alice's key will enable Alice to change the custom
         * fees list on this token later using the TokenFeeScheduleUpdateTransaction.
         * We will create an initial supply of 100 of these tokens.
         */
        System.out.println("Creating new Fungible Token using the Hedera Token Service...");

        TokenId fungibleTokenId = new TokenCreateTransaction()
            .setTokenName("Custom Fees Example Fungible Token")
            .setTokenSymbol("CFEFT")
            .setAdminKey(alicePublicKey)
            .setSupplyKey(alicePublicKey)
            .setFeeScheduleKey(alicePublicKey)
            .setWipeKey(alicePublicKey)
            .setTreasuryAccountId(aliceAccountId)
            .setCustomFees(hbarFeeList)
            .setInitialSupply(100)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;

        Objects.requireNonNull(fungibleTokenId);

        TokenInfo fungibleTokenInfo = new TokenInfoQuery()
            .setTokenId(fungibleTokenId)
            .execute(client);

        System.out.println("Created new fungible token with ID: " + fungibleTokenId + " and custom fees: "
            + fungibleTokenInfo.customFees);

        /*
         * Step 4:
         * Associate the token with Bob and Charlie before they can transfer and receive it.
         */
        System.out.println("Associate created fungible token with Bob's and Charlie's accounts...");

        new TokenAssociateTransaction()
            .setAccountId(bobAccountId)
            .setTokenIds(Collections.singletonList(fungibleTokenId))
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        new TokenAssociateTransaction()
            .setAccountId(charlieAccountId)
            .setTokenIds(Collections.singletonList(fungibleTokenId))
            .freezeWith(client)
            .sign(charliePrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 5:
         * Transfer all 100 tokens to Bob.
         */
        System.out.println("Transferring all 100 tokens from Alice to Bob...");

        new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, bobAccountId, 100)
            .addTokenTransfer(fungibleTokenId, aliceAccountId, -100)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 6:
         * Check Alice's Hbar balance.
         */
        Hbar aliceAccountBalanceHbars_BeforeCollectingFees = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .hbars;

        if (aliceAccountBalanceHbars_BeforeCollectingFees.equals(initialAccountBalance)) {
            System.out.println("Alice's Hbar balance before: " + aliceAccountBalanceHbars_BeforeCollectingFees);
        } else {
            throw new Exception("Alice's account initial balance was not set correctly! (Fail)");
        }

        /*
         * Step 7:
         * Transfer 20 tokens from Bob to Charlie.
         */
        System.out.println("Transferring 20 tokens from Bob to Charlie...");

        TransactionRecord transferTxRecord = new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, bobAccountId, -20)
            .addTokenTransfer(fungibleTokenId, charlieAccountId, 20)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getRecord(client);

        /*
         * Step 8:
         * Check Alice's Hbar balance.
         *
         * It should increase, because of the fee taken from the transfer in the previous step.
         */
        Hbar aliceAccountBalanceHbars_AfterCollectingFees = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .hbars;

        if (aliceAccountBalanceHbars_AfterCollectingFees.equals(Hbar.from(2))) {
            System.out.println("Alice's Hbar balance after Bob transferred 20 tokens to Charlie: "
                + aliceAccountBalanceHbars_AfterCollectingFees);
        } else {
            throw new Exception("Custom fee was not set correctly! (Fail)");
        }

        System.out.println("Assessed fees: " + transferTxRecord.assessedCustomFees);

        /*
         * Step 9:
         * Use the TokenUpdateFeeScheduleTransaction with Alice's key to change the custom fees on our token.
         *
         * TokenUpdateFeeScheduleTransaction will replace the list of fees that apply to the token with
         * an entirely new list. Let's charge a 10% fractional fee. This means that when Bob attempts to transfer
         * 20 tokens to Charlie, 10% of the tokens he attempts to transfer (2 in this case) will be transferred to
         * Alice instead.
         *
         * Fractional fees default to FeeAssessmentMethod.INCLUSIVE, which is the behavior described above.
         * If you set the assessment method to EXCLUSIVE, then when Bob attempts to transfer 20 tokens to Charlie,
         * Charlie will receive all 20 tokens, and Bob will be charged an additional 10% fee which
         * will be transferred to Alice.
         */
        CustomFractionalFee customFractionalFee = new CustomFractionalFee()
            .setNumerator(1)
            .setDenominator(10)
            .setMin(1)
            .setMax(10)
            // .setAssessmentMethod(FeeAssessmentMethod.EXCLUSIVE)
            .setFeeCollectorAccountId(aliceAccountId);
        List<CustomFee> fractionalFeeList = Collections.singletonList(customFractionalFee);

        System.out.println("Updating the custom fees for a fungible token...");

        new TokenFeeScheduleUpdateTransaction()
            .setTokenId(fungibleTokenId)
            .setCustomFees(fractionalFeeList)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        TokenInfo tokenInfo2 = new TokenInfoQuery()
            .setTokenId(fungibleTokenId)
            .execute(client);

        System.out.println("Updated custom fees: " + tokenInfo2.customFees);

        /*
         * Step 10:
         * Check Alice's token balance.
         */
        Map<TokenId, Long> aliceAccountBalanceTokens_BeforeCollectingFees = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .tokens;
        if (aliceAccountBalanceTokens_BeforeCollectingFees.get(fungibleTokenId) == 0) {
            System.out.println("Alice's token balance before Bob transfers 20 tokens to Charlie: "
                + aliceAccountBalanceTokens_BeforeCollectingFees.get(fungibleTokenId));
        } else {
            throw new Exception("Alice's account initial token balance is not zero! (Fail)");
        }

        /*
         * Step 11:
         * Transfer 20 tokens from Bob to Charlie.
         */
        System.out.println("Transferring 20 tokens from Bob to Charlie...");

        TransactionRecord transferTxRecord_2 = new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, bobAccountId, -20)
            .addTokenTransfer(fungibleTokenId, charlieAccountId, 20)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getRecord(client);

        /*
         * Step 12:
         * Check Alice's token balance. It should increase, because of the fee taken from the
         * transfer in the previous step.
         */
        Map<TokenId, Long> aliceAccountBalanceTokens_AfterCollectingFees = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .tokens;

        if (aliceAccountBalanceTokens_AfterCollectingFees.get(fungibleTokenId) == 2) {
            System.out.println("Alice's token balance after Bob transfers 20 tokens to Charlie: "
                + aliceAccountBalanceTokens_AfterCollectingFees.get(fungibleTokenId));
        } else {
            throw new Exception("Custom fractional fee was not set correctly! (Fail)");
        }

        System.out.println("Token transfers: " + transferTxRecord_2.tokenTransfers);
        System.out.println("Assessed fees: " + transferTxRecord_2.assessedCustomFees);

        /*
         * Clean up:
         * Delete created accounts and tokens.
         */

        // Move token to operator account.
        new TokenAssociateTransaction()
            .setAccountId(client.getOperatorAccountId())
            .setTokenIds(Collections.singletonList(fungibleTokenId))
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        new TokenUpdateTransaction()
            .setTokenId(fungibleTokenId)
            .setAdminKey(OPERATOR_KEY)
            .setSupplyKey(OPERATOR_KEY)
            .setFeeScheduleKey(OPERATOR_KEY)
            .setWipeKey(OPERATOR_KEY)
            .setTreasuryAccountId(client.getOperatorAccountId())
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        // Wipe token on created accounts.
        Map<TokenId, Long> charlieTokensBeforeWipe = new AccountBalanceQuery()
            .setAccountId(charlieAccountId)
            .execute(client)
            .tokens;

        new TokenWipeTransaction()
            .setTokenId(fungibleTokenId)
            .setAmount(charlieTokensBeforeWipe.get(fungibleTokenId))
            .setAccountId(charlieAccountId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        Map<TokenId, Long> bobsTokens = new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client)
            .tokens;

        new TokenWipeTransaction()
            .setTokenId(fungibleTokenId)
            .setAmount(bobsTokens.get(fungibleTokenId))
            .setAccountId(bobAccountId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        Map<TokenId, Long> aliceTokensBeforeWipe = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .tokens;

        new TokenWipeTransaction()
            .setTokenId(fungibleTokenId)
            .setAmount(aliceTokensBeforeWipe.get(fungibleTokenId))
            .setAccountId(aliceAccountId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        // Delete created accounts.
        new AccountDeleteTransaction()
            .setAccountId(charlieAccountId)
            .setTransferAccountId(client.getOperatorAccountId())
            .freezeWith(client)
            .sign(charliePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(bobAccountId)
            .setTransferAccountId(client.getOperatorAccountId())
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(aliceAccountId)
            .setTransferAccountId(client.getOperatorAccountId())
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        // Delete created token.
        new TokenDeleteTransaction()
            .setTokenId(fungibleTokenId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Custom Fees Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/DynamicAddressBookExample.java
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Endpoint;
import com.hedera.hashgraph.sdk.NodeCreateTransaction;
import com.hedera.hashgraph.sdk.NodeDeleteTransaction;
import com.hedera.hashgraph.sdk.NodeUpdateTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import io.github.cdimascio.dotenv.Dotenv;
import java.util.Collections;
import java.util.Objects;
import java.util.concurrent.TimeoutException;

/**
 * hip-869
 */
public class DynamicAddressBookExample {
    // see `.env.sample` in the repository root for how to specify these values
    // or set environment variables with the same names
    private static final AccountId OPERATOR_ID = AccountId.fromString(
        Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(
        Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));
    // HEDERA_NETWORK defaults to testnet if not specified in dotenv
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    public static void main(String[] args)
        throws TimeoutException, PrecheckStatusException, ReceiptStatusException, InterruptedException {
        Client client = ClientHelper.forName(HEDERA_NETWORK);

        // Defaults the operator account ID and key such that all generated transactions will be paid for
        // by this account and be signed by this key
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);

        AccountId accountId = AccountId.fromString("0.0.1999");
        String description = "Hedera cryptocurrency";
        String newDescription = "Hedera cryptocurrency - updated";

        // Set up IPv4 address
        Endpoint gossipEndpoint = new Endpoint();
        gossipEndpoint
            .setAddress(new byte[] {0x00, 0x01, 0x02, 0x03});

        // Set up service endpoint
        Endpoint serviceEndpoint = new Endpoint();
        serviceEndpoint
            .setAddress(new byte[] {0x00, 0x01, 0x02, 0x03});

        // Generate admin key
        PrivateKey adminKey = PrivateKey.generateED25519();

        // Create node create transaction
        NodeCreateTransaction nodeCreateTransaction = new NodeCreateTransaction()
            .setAccountId(accountId)
            .setDescription(description)
            .setGossipCaCertificate("gossipCaCertificate".getBytes())
            .setServiceEndpoints(Collections.singletonList(serviceEndpoint))
            .setGossipEndpoints(Collections.singletonList(gossipEndpoint))
            .setAdminKey(adminKey.getPublicKey());

        try {
            nodeCreateTransaction.execute(client).getReceipt(client);
        } catch (Exception e){
            System.out.println(e);
        }

        var nodeUpdateTransaction = new NodeUpdateTransaction()
            .setNodeId(123)
            .setAccountId(accountId)
            .setDescription(newDescription)
            .setGossipCaCertificate("gossipCaCertificate".getBytes())
            .setServiceEndpoints(Collections.singletonList(serviceEndpoint))
            .setGossipEndpoints(Collections.singletonList(gossipEndpoint))
            .setAdminKey(adminKey.getPublicKey());

        try {
            nodeUpdateTransaction.execute(client).getReceipt(client);
        } catch (Exception e){
            System.out.println(e);
        }

        var nodeDeleteTransaction = new NodeDeleteTransaction()
            .setNodeId(123);

        try {
            nodeDeleteTransaction.execute(client).getReceipt(client);
        } catch (Exception e){
            System.out.println(e);
        }
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ExampleTemplate.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * This is a template for examples.
 * <p>
 * Simple title, like "How to do X".
 * <p>
 * General description of the example should be here (class-level comment).
 */
// Class access modifier should be default (simplicity and accessibility).
class ExampleTemplate {

    // UTIL VARIABLES BELOW
    private static final int TOTAL_MESSAGES = 5; // Example.

    // CONFIG VARIABLES BELOW

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    // No constructor (for simplicity)

    // There should be only main method for simplicity
    // throws only Exception for simplicity
    public static void main(String[] args) throws Exception {
        System.out.println("Example Start!");

        /*
         * Step 0:
         * Create and configure SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        // Steps with comments, for example:

        /*
         * Step 1:
         * Create an ECSDA private key.
         */
        PrivateKey privateKey = PrivateKey.generateECDSA();

        /*
         * Step 2:
         * Extract the ECDSA public key.
         */
        PublicKey publicKey = privateKey.getPublicKey();

        /*
         * Clean up:
         */
        client.close();

        System.out.println("Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ExemptCustomFeesExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * How to exempt token creators all of their tokens fee collectors from a custom fee (HIP-573).
 */
class ExemptCustomFeesExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Exempt Custom Fees Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Create three accounts: Alice, Bob, and Charlie.
         */
        System.out.println("Creating new accounts...");
        Hbar initialBalance = Hbar.from(1);
        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();
        AccountId aliceAccountId = new AccountCreateTransaction()
            .setInitialBalance(initialBalance)
            .setKey(alicePublicKey)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(aliceAccountId);

        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();
        AccountId bobAccountId = new AccountCreateTransaction()
            .setInitialBalance(initialBalance)
            .setKey(bobPublicKey)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(bobAccountId);

        PrivateKey charilePrivateKey = PrivateKey.generateED25519();
        PublicKey charilePublicKey = charilePrivateKey.getPublicKey();
        AccountId charlieAccountId = new AccountCreateTransaction()
            .setInitialBalance(initialBalance)
            .setKey(charilePublicKey)
            .freezeWith(client)
            .sign(charilePrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(charlieAccountId);

        /*
         * Step 2:
         * Create a fungible token that has three fractional fees:
         * - aliceFee sends 1/100 of the transferred value to Alice's account;
         * - bobFee sends 2/100 of the transferred value to Bob's account;
         * - charlieFee sends 3/100 of the transferred value to Charlie's account.
         */
        CustomFractionalFee aliceFee = new CustomFractionalFee()
            .setFeeCollectorAccountId(aliceAccountId)
            .setNumerator(1)
            .setDenominator(100)
            .setAllCollectorsAreExempt(true);

        CustomFractionalFee bobFee = new CustomFractionalFee()
            .setFeeCollectorAccountId(bobAccountId)
            .setNumerator(2)
            .setDenominator(100)
            .setAllCollectorsAreExempt(true);

        CustomFractionalFee charlieFee = new CustomFractionalFee()
            .setFeeCollectorAccountId(charlieAccountId)
            .setNumerator(3)
            .setDenominator(100)
            .setAllCollectorsAreExempt(true);

        System.out.println("Creating new Fungible Token using the Hedera Token Service...");
        TokenId fungibleTokenId = new TokenCreateTransaction()
            .setTokenName("HIP-573 Fungible Token")
            .setTokenSymbol("HIP573FT")
            .setTokenType(TokenType.FUNGIBLE_COMMON)
            .setTreasuryAccountId(OPERATOR_ID)
            .setAutoRenewAccountId(OPERATOR_ID)
            .setAdminKey(operatorPublicKey)
            .setFreezeKey(operatorPublicKey)
            .setWipeKey(operatorPublicKey)
            .setInitialSupply(100_000_000)
            .setDecimals(2)
            .setCustomFees(List.of(aliceFee, bobFee, charlieFee))
            .freezeWith(client)
            .sign(alicePrivateKey)
            .sign(bobPrivateKey)
            .sign(charilePrivateKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;
        Objects.requireNonNull(fungibleTokenId);
        System.out.println("Created new fungible token with ID: " + fungibleTokenId);

        /*
         * Step 3:
         * Transfer tokens:
         * - 10_000 units of the Fungible Token from the operator's to Bob's account;
         * - 10_000 units of the Fungible Token from Bob's to Alice's account.
         */
        System.out.println("Transferring 10_000 units of the Fungible Token from the operator's to Bob's account...");
        new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, OPERATOR_ID, -10_000)
            .addTokenTransfer(fungibleTokenId, bobAccountId, 10_000)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client);

        System.out.println("Transferring 10_000 units of the Fungible Token from Bob's to Alice's account...");
        TransactionResponse transferTxResponse = new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, bobAccountId, -10_000)
            .addTokenTransfer(fungibleTokenId, aliceAccountId, 10_000)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client);

        /*
         * Step 4:
         * Get the transaction fee for that transfer transaction.
         */
        Hbar transactionFee = transferTxResponse
            .getRecord(client)
            .transactionFee;

        System.out.println("Transaction fee for the transfer above: " + transactionFee);

        /*
         * Step 5:
         * Show that the fee collector accounts in the custom fee list
         * of the token that was created was not charged a custom fee in the transfer.
         */
        Long aliceAccountBalanceAfter = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .tokens.get(fungibleTokenId);

        Long bobAccountBalanceAfter = new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client)
            .tokens.get(fungibleTokenId);

        Long charlieAccountBalanceAfter = new AccountBalanceQuery()
            .setAccountId(charlieAccountId)
            .execute(client)
            .tokens.get(fungibleTokenId);

        System.out.println("Alice's balance after transferring the fungible token: " + aliceAccountBalanceAfter);
        System.out.println("Bob's account balance after transferring the fungible token: " + bobAccountBalanceAfter);
        System.out.println("Charlie's account balance after transferring the fungible token: " + charlieAccountBalanceAfter);

        /*
         * Clean up:
         * Delete created accounts and token.
         */
        Map<TokenId, Long> alicesTokens = new AccountBalanceQuery()
            .setAccountId(aliceAccountId)
            .execute(client)
            .tokens;

        new TokenWipeTransaction()
            .setTokenId(fungibleTokenId)
            .setAmount(alicesTokens.get(fungibleTokenId))
            .setAccountId(aliceAccountId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(aliceAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(bobAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(charlieAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(charilePrivateKey)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setTokenId(fungibleTokenId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Exempt Custom Fees Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/FileAppendChunkedExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * How to append to already created file.
 */
class FileAppendChunkedExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Big File Append Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Submit the file create transaction.
         */
        // The file is required to be a byte array,
        // you can easily use the bytes of a file instead.
        String fileContents = "Hedera hashgraph is great!";

        System.out.println("Creating new file...");
        TransactionResponse fileCreateTxResponse = new FileCreateTransaction()
            // Use the same key as the operator to "own" this file.
            .setKeys(operatorPublicKey)
            .setContents(fileContents)
            // The default max fee of 1 Hbar is not enough to create a file (starts around ~1.1 Hbar).
            .setMaxTransactionFee(Hbar.from(2))
            .execute(client);

        TransactionReceipt fileCreateTxReceipt = fileCreateTxResponse.getReceipt(client);
        FileId newFileId = fileCreateTxReceipt.fileId;
        Objects.requireNonNull(newFileId);
        System.out.println("Created new file with ID: " + newFileId);

        /*
         * Step 2:
         * Query file info to check its size after creation.
         */
        FileInfo fileInfoAfterCreate = new FileInfoQuery()
            .setFileId(newFileId)
            .execute(client);

        System.out.println("Created file size after create (according to `FileInfoQuery`): " + fileInfoAfterCreate.size + " bytes.");

        /*
         * Step 3:
         * Create new file contents that will be appended to a file.
         */
        StringBuilder contents = new StringBuilder();
        for (int i = 0; i <= 4096 * 9; i++) {
            contents.append("1");
        }

        /*
         * Step 4:
         * Append new file contents to a file.
         */
        System.out.println("Appending new contents to the created file...");
        new FileAppendTransaction()
            .setNodeAccountIds(Collections.singletonList(fileCreateTxResponse.nodeId))
            .setFileId(newFileId)
            .setContents(contents.toString())
            .setMaxChunks(40)
            .setMaxTransactionFee(Hbar.from(100))
            .freezeWith(client)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 5:
         * Query file info to check its size after append.
         */
        FileInfo fileInfoAfterAppend = new FileInfoQuery()
            .setFileId(newFileId)
            .execute(client);

        if (fileInfoAfterCreate.size < fileInfoAfterAppend.size) {
            System.out.println("File size after append (according to `FileInfoQuery`): " + fileInfoAfterAppend.size + " bytes.");
        } else {
            throw new Exception("File append was unsuccessful! (Fail)");
        }

        /*
         * Clean up:
         * Delete created file.
         */
        new FileDeleteTransaction()
            .setFileId(newFileId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Big File Append Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GenerateKeyExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;

/**
 * How to generate ED25519 key pair.
 */
class GenerateKeyExample {

    public static void main(String[] args) {
        System.out.println("Generate ED25519 Private And Public Key Pair Example Start!");

        System.out.println("Generating the ED25519 private key...");
        PrivateKey privateKey = PrivateKey.generateED25519();
        System.out.println("Private Key: " + privateKey);

        System.out.println("Deriving a public key from the above private key");
        PublicKey publicKey = privateKey.getPublicKey();
        System.out.println("Public key: " + publicKey);

        System.out.println("Generate ED25519 Private And Public Key Pair Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GenerateKeyWithMnemonicExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.Mnemonic;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;

/**
 * How to generate ED25519 key with mnemonic phrase.
 */
class GenerateKeyWithMnemonicExample {

    public static void main(String[] args) {
        System.out.println("Generate ED25519 Key With Mnemonic Phrase Example Start!");

        System.out.println("Generating random 24-word mnemonic from the BIP-39 standard English word list...");
        Mnemonic mnemonic24 = Mnemonic.generate24();
        System.out.println("Generated 24-word mnemonic: " + mnemonic24);

        System.out.println("Recovering an ED25519 private key from the 24-word mnemonic phrase above...");
        PrivateKey privateKey24 = mnemonic24.toStandardEd25519PrivateKey("", 0);
        System.out.println("Recovered ED25519 private key: " + privateKey24);

        System.out.println("Deriving a public key from the above private key...");
        PublicKey publicKey24 = privateKey24.getPublicKey();
        System.out.println("Public key: " + publicKey24);

        System.out.println("---");

        System.out.println("Generating random 12-word mnemonic from the BIP-39 standard English word list...");
        Mnemonic mnemonic12 = Mnemonic.generate12();
        System.out.println("Generated 12-word mnemonic: " + mnemonic12);

        System.out.println("Recovering an ED25519 private key from the 12-word mnemonic phrase above...");
        PrivateKey privateKey12 = mnemonic12.toStandardEd25519PrivateKey("", 0);
        System.out.println("Recovered ED25519 private key: " + privateKey12);

        System.out.println("Deriving a public key from the above private key...");
        PublicKey publicKey12 = privateKey12.getPublicKey();
        System.out.println("Public key: " + publicKey12);

        System.out.println("Generate ED25519 Key With Mnemonic Phrase Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GetAccountBalanceExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to get balance of a Hedera account.
 */
class GetAccountBalanceExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Get Account Balance Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         *
         * Because AccountBalanceQuery is a free query, we can make it without setting an operator on the client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Execute AccountBalanceQuery and output operator's account balance.
         */
        Hbar operatorsBalance = new AccountBalanceQuery()
            .setAccountId(OPERATOR_ID)
            .execute(client)
            .hbars;

        System.out.println("Operator's Hbar account balance: " + operatorsBalance);

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Get Account Balance Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GetAccountInfoExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to get information about Hedera account.
 */
class GetAccountInfoExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Get Account Info Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Execute AccountBalanceQuery and output operator's account info.
         */
        AccountInfo operatorsAccountInfo = new AccountInfoQuery()
            .setAccountId(OPERATOR_ID)
            .setMaxQueryPayment(Hbar.from(1))
            .execute(client);

        System.out.println("Operator's account public key: " + operatorsAccountInfo.key);
        System.out.println("Operator's account require receiver signature: " + operatorsAccountInfo.isReceiverSignatureRequired);
        System.out.println("Operator's account expiration time: " + operatorsAccountInfo.expirationTime);

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Get Account Info Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GetAddressBookExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AddressBookQuery;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.FileId;
import com.hedera.hashgraph.sdk.NodeAddressBook;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.util.Objects;

/**
 * How to get the network address book and then inspect node public keys, etc.
 */
class GetAddressBookExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Get Address Book Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Fetch the address book.
         * Note: from Feb 25 2022 you can now fetch the address book for free from a mirror node with AddressBookQuery.
         */
        System.out.println("Getting address book for " + HEDERA_NETWORK + "...");

        NodeAddressBook addressBook = new AddressBookQuery()
            .setFileId(FileId.ADDRESS_BOOK)
            .execute(client);

        Objects.requireNonNull(addressBook);
        System.out.println("Address book for " + HEDERA_NETWORK + ": " + addressBook);

        /*
         * Clean up:
         */
        Files.deleteIfExists(FileSystems.getDefault().getPath("address-book.proto.bin"));
        client.close();

        System.out.println("Get Address Book Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GetExchangeRatesExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to get exchange rates info from the Hedera network.
 */
class GetExchangeRatesExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Get Exchange Rates Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Get contents of the file '0.0.112'. It is a system file, where exchange rate is stored.
         */
        System.out.println("Getting contents of the file `0.0.112`...");
        ByteString fileContentsByteString = new FileContentsQuery()
            .setFileId(FileId.fromString("0.0.112"))
            .execute(client);
        Objects.requireNonNull(fileContentsByteString);

        /*
         * Step 2:
         * Parse file contents to an ExchangeRates object.
         */
        byte[] fileContents = fileContentsByteString.toByteArray();
        ExchangeRates exchangeRateSet = ExchangeRates.fromBytes(fileContents);

        /*
         * Step 3:
         * Print the info.
         */
        System.out.println("Current numerator: " + exchangeRateSet.currentRate.cents);
        System.out.println("Current denominator: " + exchangeRateSet.currentRate.hbars);
        System.out.println("Current expiration time: " + exchangeRateSet.currentRate.expirationTime.toString());
        System.out.println("Current Exchange Rate: " + exchangeRateSet.currentRate.exchangeRateInCents);
        System.out.println("Next numerator: " + exchangeRateSet.nextRate.cents);
        System.out.println("Next denominator: " + exchangeRateSet.nextRate.hbars);
        System.out.println("Next expiration time: " + exchangeRateSet.nextRate.expirationTime.toString());
        System.out.println("Next Exchange Rate: " + exchangeRateSet.nextRate.exchangeRateInCents);

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Get Exchange Rates Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/GetFileContentsExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.charset.StandardCharsets;
import java.util.Objects;

/**
 * How to get file contents.
 *
 */
class GetFileContentsExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Get File Contents Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Submit the file create transaction.
         */
        // Content to be stored in the file.
        byte[] fileContents = "Hedera is great!".getBytes(StandardCharsets.UTF_8);

        // Create the new file and set its properties.
        System.out.println("Creating new file...");
        TransactionResponse fileCreateTxResponse = new FileCreateTransaction()
            // The public key of the owner of the file.
            .setKeys(operatorPublicKey)
            // Contents of the file.
            .setContents(fileContents)
            .setMaxTransactionFee(Hbar.from(2))
            .execute(client);

        FileId newFileId = Objects.requireNonNull(fileCreateTxResponse.getReceipt(client).fileId);
        Objects.requireNonNull(newFileId);
        System.out.println("Created new file with ID: " + newFileId);

        /*
         * Step 2:
         * Get file contents and print them.
         */
        ByteString contents = new FileContentsQuery()
            .setFileId(newFileId)
            .execute(client);

        Objects.requireNonNull(contents);
        // Prints query results to console.
        System.out.println("File contents: " + contents.toStringUtf8());

        /*
         * Clean up:
         * Delete created file.
         */
        new FileDeleteTransaction()
            .setFileId(newFileId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Get File Contents Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/LoggerFunctionalitiesExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How SDK Logger works.
 *
 */
public class LoggerFunctionalitiesExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    public static void main(String[] args) throws Exception {
        System.out.println("Logger Functionalities Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);

        /*
         * Step 1:
         * Instantiate debug- and info-level loggers.
         */
        var debugLogger = new Logger(LogLevel.DEBUG);
        var infoLogger = new Logger(LogLevel.INFO);

        /*
         * Step 2:
         * Attach debug logger to the SDK Client.
         */
        client.setLogger(debugLogger);

        /*
         * Step 3:
         * Generate ED25519 private and public keys.
         */
        var privateKey = PrivateKey.generateED25519();
        var publicKey = privateKey.getPublicKey();

        /*
         * Step 4:
         * "Create" account.
         */
        System.out.println("\"Creating\" new account...");
        var aliasAccountId = publicKey.toAccountId(0, 0);
        var operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 4:
         * Transfer 10 tinybars from operator's account to newly created account to init it on Hedera network.
         */
        System.out.println("Transferring Hbar to the the new account...");
        new TransferTransaction()
            .addHbarTransfer(OPERATOR_ID, Hbar.from(1).negated())
            .addHbarTransfer(aliasAccountId, Hbar.from(1))
            .setTransactionMemo("")
            .execute(client);

        /*
         * Step 5:
         * Create a topic with attached info logger.
         */
        System.out.println("Creating new topic...(with attached info logger).");
        TopicId hederaTopicId = new TopicCreateTransaction()
            .setLogger(infoLogger)
            .setTopicMemo("Hedera topic")
            .setAdminKey(operatorPublicKey)
            .execute(client)
            .getReceipt(client)
            .topicId;
        Objects.requireNonNull(hederaTopicId);

        /*
         * Step 6:
         * Set the level of the infoLogger from info to error.
         */
        infoLogger.setLevel(LogLevel.ERROR);

        /*
         * Step 7:
         * Create a topic with attached info logger.
         *
         * This should not display any logs because currently there are no warn logs predefined in the SDK.
         */
        System.out.println("Creating new topic...(with attached info logger).");
        var logisticsTopicId = new TopicCreateTransaction()
            .setLogger(infoLogger)
            .setTopicMemo("Logistics topic")
            .setAdminKey(operatorPublicKey)
            .execute(client)
            .getReceipt(client)
            .topicId;
        Objects.requireNonNull(logisticsTopicId);

        /*
         * Step 8:
         * Silence the debugLogger - no logs should be shown.
         *
         * This can also be achieved by calling .setLevel(LogLevel.Silent).
         */
        debugLogger.setSilent(true);

        /*
         * Step 9:
         * Create a topic with attached debug logger.
         * This should not display any logs because logger was silenced.
         */
        System.out.println("Creating new topic...(with attached debug logger).");
        var supplyChainTopicId = new TopicCreateTransaction()
            .setLogger(debugLogger)
            .setTopicMemo("Supply chain topic")
            .setAdminKey(operatorPublicKey)
            .execute(client)
            .getReceipt(client)
            .topicId;
        Objects.requireNonNull(supplyChainTopicId);

        /*
         * Step 10:
         * Unsilence the debugLogger - applies back the old log level before silencing.
         */
        debugLogger.setSilent(false);

        /*
         * Step 11:
         * Create a topic with attached debug logger.
         *
         * Should produce logs.
         */
        System.out.println("Creating new topic...(with attached debug logger).");
        var chatTopicId = new TopicCreateTransaction()
            .setLogger(debugLogger)
            .setTopicMemo("Chat topic")
            .setAdminKey(operatorPublicKey)
            .execute(client)
            .getReceipt(client)
            .topicId;
        Objects.requireNonNull(chatTopicId);

        /*
         * Clean up:
         * Delete created topics.
         */
        new TopicDeleteTransaction()
            .setTopicId(hederaTopicId)
            .execute(client)
            .getReceipt(client);

        new TopicDeleteTransaction()
            .setTopicId(logisticsTopicId)
            .execute(client)
            .getReceipt(client);

        new TopicDeleteTransaction()
            .setTopicId(supplyChainTopicId)
            .execute(client)
            .getReceipt(client);

        new TopicDeleteTransaction()
            .setTopicId(chatTopicId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Logger Functionalities Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/MultiAppTransferExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to transfer Hbar to an account with the receiver signature enabled.
 */
class MultiAppTransferExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("MultiApp Transfer Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        // The exchange should possess this key, we're only generating it for demonstration purposes.
        PrivateKey exchangePrivateKey = PrivateKey.generateED25519();
        PublicKey exchangePublicKey = exchangePrivateKey.getPublicKey();

        // This is the only key we should actually possess.
        PrivateKey userPrivateKey = PrivateKey.generateED25519();
        PublicKey userPublicKey = userPrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create exchange and receiver accounts.
         */
        System.out.println("Creating exchange and receiver accounts...");
        // The exchange creates an account for the user to transfer funds to.
        AccountId exchangeAccountId = new AccountCreateTransaction()
            // The exchange only accepts transfers that it validates through a side channel (e.g. REST API).
            .setReceiverSignatureRequired(true)
            .setKey(exchangePublicKey)
            // The owner key has to sign this transaction when setReceiverSignatureRequired is true.
            .freezeWith(client)
            .sign(exchangePrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(exchangeAccountId);

        // For the purpose of this example we create an account for the user with a balance of 5 Hbar.
        AccountId userAccountId = new AccountCreateTransaction()
            .setInitialBalance(Hbar.from(2))
            .setKey(userPublicKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(userAccountId);

        Hbar senderBalanceBefore = new AccountBalanceQuery()
            .setAccountId(userAccountId)
            .execute(client)
            .hbars;

        Hbar exchangeBalanceBefore = new AccountBalanceQuery()
            .setAccountId(exchangeAccountId)
            .execute(client)
            .hbars;

        System.out.println("User account (" + userAccountId + ") balance: " + senderBalanceBefore);
        System.out.println("Exchange account (" + exchangeAccountId + ") balance: " + exchangeBalanceBefore);

        /*
         * Step 3:
         * Make a transfer from the user account to the exchange account, this requires signing by both parties.
         */
        TransferTransaction transferTx = new TransferTransaction()
            .addHbarTransfer(userAccountId, Hbar.from(1).negated())
            .addHbarTransfer(exchangeAccountId, Hbar.from(1))
            // The exchange-provided memo required to validate the transaction.
            .setTransactionMemo("https://some-exchange.com/user1/account1")
            // NOTE: to manually sign, you must freeze the Transaction first
            .freezeWith(client)
            .sign(userPrivateKey);

        // The exchange must sign the transaction in order for it to be accepted by the network
        // (assume this is some REST call to the exchange API server).
        byte[] signedTransferTxBytes = Transaction.fromBytes(transferTx.toBytes()).sign(exchangePrivateKey).toBytes();

        // Parse the transaction bytes returned from the exchange.
        Transaction<?> signedTransferTx = Transaction.fromBytes(signedTransferTxBytes);

        // Get the amount we are about to transfer (we built this with +2, -2).
        Hbar transferAmount = ((TransferTransaction) signedTransferTx).getHbarTransfers().values().toArray(new Hbar[0])[0];

        System.out.println("Transferring " + transferAmount + " from the user account to the exchange account...");

        // We now execute the signed transaction and wait for it to be accepted.
        TransactionResponse transactionTxResponse = signedTransferTx.execute(client);

        // (Important!) Wait for consensus by querying for the receipt.
        transactionTxResponse.getReceipt(client);

        /*
         * Step 4:
         * Query user and exchange account balance to validate the transfer was successfully complete.
         */
        Hbar senderBalanceAfter = new AccountBalanceQuery()
            .setAccountId(userAccountId)
            .execute(client)
            .hbars;

        Hbar exchangeBalanceAfter = new AccountBalanceQuery()
            .setAccountId(exchangeAccountId)
            .execute(client)
            .hbars;

        System.out.println("User account (" + userAccountId + ") balance: " + senderBalanceAfter);
        System.out.println("Exchange account (" + exchangeAccountId + ") balance: " + exchangeBalanceAfter);

        /*
         * Clean up:
         * Delete created accounts.
         */
        new AccountDeleteTransaction()
            .setAccountId(exchangeAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(exchangePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(userAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(userPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("MultiApp Transfer Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/MultiSigOfflineExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Arrays;
import java.util.Collections;
import java.util.Objects;

/**
 * How to sign a transaction with multi-sig account.
 */
class MultiSigOfflineExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Multi Sig Offline Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 private and public keys for accounts...");

        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        System.out.println("Alice's ED25519 Private Key: " + alicePrivateKey);

        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();
        System.out.println("Alice's ED25519 Public Key: " + alicePublicKey);

        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        System.out.println("Bob's ED25519 Private Key: " + bobPrivateKey);

        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();
        System.out.println("Bob's ED25519 Public Key: " + bobPublicKey);

        /*
         * Step 2:
         * Create a Multi-sig account.
         */
        System.out.println("Creating new Key List..");
        KeyList keylist = new KeyList();
        keylist.add(alicePublicKey);
        keylist.add(bobPublicKey);
        System.out.println("Created Key List: " + keylist);

        System.out.println("Creating a new account...");
        TransactionResponse createAccountTxResponse = new AccountCreateTransaction()
            .setInitialBalance(Hbar.from(2))
            .setKey(keylist)
            .execute(client);

        TransactionReceipt createAccountTxReceipt = createAccountTxResponse.getReceipt(client);
        var newAccountId = createAccountTxReceipt.accountId;
        Objects.requireNonNull(newAccountId);
        System.out.println("Created new account with ID: " + newAccountId);

        /*
         * Step 2:
         * Create a transfer from new account to the account with ID '0.0.3'.
         */
        System.out.println("Transferring 1 Hbar from new account to the account with ID `0.0.3`...");
        TransferTransaction transferTx = new TransferTransaction()
            .setNodeAccountIds(Collections.singletonList(new AccountId(3)))
            .addHbarTransfer(Objects.requireNonNull(createAccountTxReceipt.accountId), Hbar.from(1).negated())
            .addHbarTransfer(new AccountId(3), Hbar.from(1))
            .freezeWith(client);

        /*
         * Step 3:
         * Convert transaction to bytes to send to signatories.
         */
        System.out.println("Converting transaction to bytes to send to signatories...");
        byte[] transactionBytes = transferTx.toBytes();
        Transaction<?> transactionToExecute = Transaction.fromBytes(transactionBytes);

        /*
         * Step 4:
         * Ask users to sign and return signature.
         */
        byte[] alicesSignature = alicePrivateKey.signTransaction(Transaction.fromBytes(transactionBytes));
        System.out.println("Alice signed the transaction. Signature: " + Arrays.toString(alicesSignature));
        byte[] bobsSignature = bobPrivateKey.signTransaction(Transaction.fromBytes(transactionBytes));
        System.out.println("Bob signed the transaction. Signature: " + Arrays.toString(bobsSignature));

        /*
         * Step 5:
         * Recreate the transaction from bytes.
         */
        System.out.println("Adding users' signatures to the transaction...");
        transactionToExecute.signWithOperator(client);
        transactionToExecute.addSignature(alicePrivateKey.getPublicKey(), alicesSignature);
        transactionToExecute.addSignature(bobPrivateKey.getPublicKey(), bobsSignature);

        /*
         * Step 6:
         * Execute recreated transaction.
         */
        System.out.println("Executing transfer transaction...");
        TransactionResponse transferTxResponse = transactionToExecute.execute(client);
        createAccountTxReceipt = transferTxResponse.getReceipt(client);
        System.out.println("Transfer transaction was complete with status: " + createAccountTxReceipt.status);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(newAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Multi Sig Offline Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/NftAddRemoveAllowancesExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * How to grant another account the right to transfer hbar, fungible and non-fungible tokens from your account (HIP-336).
 */
class NftAddRemoveAllowancesExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Nft Add Remove Allowances (HIP-336) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        PublicKey operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * The beginning of the first example (approve/delete allowances for single serial numbers).
         * Create NFT using the Hedera Token Service.
         */
        System.out.println("The beginning of the first example (approve/delete allowances for single serial numbers).");

        String[] CIDs = {
            "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
            "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
            "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        };

        System.out.println("Creating NFT using the Hedera Token Service...");
        TransactionReceipt nftCreateTxReceipt = new TokenCreateTransaction()
            .setTokenName("HIP-336 NFT1")
            .setTokenSymbol("HIP336NFT1")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setDecimals(0)
            .setInitialSupply(0)
            .setMaxSupply(CIDs.length)
            .setTreasuryAccountId(OPERATOR_ID)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(operatorPublicKey)
            .setSupplyKey(operatorPublicKey)
            .setWipeKey(operatorPublicKey)
            .freezeWith(client)
            .execute(client)
            .getReceipt(client);

        TokenId nftTokenId = nftCreateTxReceipt.tokenId;
        Objects.requireNonNull(nftTokenId);
        System.out.println("Created NFT with token ID: " + nftTokenId);

        /*
         * Step 2:
         * Mint NFTs.
         */
        System.out.println("Minting NFTs...");
        List<TransactionReceipt> nftMintTxReceipts = new ArrayList<>();
        for (int i = 0; i < CIDs.length; i++) {
            nftMintTxReceipts.add(new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(List.of(CIDs[i].getBytes(StandardCharsets.UTF_8)))
                .freezeWith(client)
                .execute(client)
                .getReceipt(client));

            System.out.println("Minted NFT (token ID: " + nftTokenId + ") with serial: " + nftMintTxReceipts.get(i).serials.get(0));
        }

        /*
         * Step 3:
         * Create spender and receiver accounts.
         */
        System.out.println("Creating spender and receiver accounts...");
        PrivateKey spenderPrivateKey = PrivateKey.generateECDSA();
        PublicKey spenderPublicKey = spenderPrivateKey.getPublicKey();
        AccountId spenderAccountId = new AccountCreateTransaction()
            .setKey(spenderPublicKey)
            .setInitialBalance(Hbar.from(2))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(spenderAccountId);
        System.out.println("Created spender account with ID: " + spenderAccountId);

        PrivateKey receiverPrivateKey = PrivateKey.generateECDSA();
        PublicKey receiverPublicKey = receiverPrivateKey.getPublicKey();
        AccountId receiverAccountId = new AccountCreateTransaction()
            .setKey(receiverPublicKey)
            .setInitialBalance(Hbar.from(2))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(receiverAccountId);
        System.out.println("Created receiver account with ID: " + receiverAccountId);

        /*
         * Step 4:
         * Associate spender and receiver accounts with the NFT.
         */
        System.out.println("Associating spender and receiver accounts with the NFT...");
        TransactionReceipt spenderAssociateReceipt = new TokenAssociateTransaction()
            .setAccountId(spenderAccountId)
            .setTokenIds(List.of(nftTokenId))
            .freezeWith(client)
            .sign(spenderPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("Spender association transaction was complete with status: " + spenderAssociateReceipt.status);

        TransactionReceipt receiverAssociateReceipt = new TokenAssociateTransaction()
            .setAccountId(receiverAccountId)
            .setTokenIds(List.of(nftTokenId))
            .freezeWith(client)
            .sign(receiverPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("Receiver association transaction was complete with status: " + receiverAssociateReceipt.status);

        /*
         * Step 5:
         * Approve NFT (serial '1' and '2') allowance for spender account.
         */
        NftId nft1 = new NftId(nftTokenId, 1);
        NftId nft2 = new NftId(nftTokenId, 2);

        System.out.println("Approving spender account allowance for NFT (serials #1 and #2)...");
        TransactionReceipt approveReceipt = new AccountAllowanceApproveTransaction()
            .approveTokenNftAllowance(nft1, OPERATOR_ID, spenderAccountId)
            .approveTokenNftAllowance(nft2, OPERATOR_ID, spenderAccountId)
            .execute(client)
            .getReceipt(client);
        System.out.println("Approve spender allowance transaction was complete with status: " + approveReceipt.status);

        /*
         * Step 6:
         * Send NFT with serial #1 from operator's to receiver account.
         * This transaction should be executed on behalf of the spender and should end up with SUCCESS.
         */
        // Generate TransactionId from spender's account id in order,
        // for the transaction to be executed on behalf of the spender.
        TransactionId onBehalfOfTransactionId = TransactionId.generate(spenderAccountId);

        System.out.println("Transferring NFT (serial #1) on behalf of the spender...");
        TransactionReceipt approvedSendReceipt = new TransferTransaction()
            .addApprovedNftTransfer(nft1, OPERATOR_ID, receiverAccountId)
            .setTransactionId(onBehalfOfTransactionId)
            .freezeWith(client)
            .sign(spenderPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("Transfer transaction was complete with status: " + approvedSendReceipt.status);

        /*
         * Step 7:
         * Remove all NFT token allowances (for serial #2).
         */
        System.out.println("Removing all NFT token allowances (for serial #2)...");
        TransactionReceipt deleteAllowanceReceipt = new AccountAllowanceDeleteTransaction()
            .deleteAllTokenNftAllowances(nft2, OPERATOR_ID)
            .execute(client)
            .getReceipt(client);
        System.out.println("Remove allowance transaction was complete with status: " + deleteAllowanceReceipt.status);

        /*
         * Step 8:
         * Send NFT with serial #2 from operator's to receiver account.
         * Spender does not have an allowance to send serial #2, should end up with SPENDER_DOES_NOT_HAVE_ALLOWANCE.
         */
        TransactionId onBehalfOfTransactionId2 = TransactionId.generate(spenderAccountId);

        try {
            System.out.println("Transferring NFT (serial #2) on behalf of the spender...");
            new TransferTransaction()
                .addApprovedNftTransfer(nft2, OPERATOR_ID, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId2)
                .freezeWith(client)
                .sign(spenderPrivateKey)
                .execute(client)
                .getReceipt(client);
        } catch (Exception e) {
            System.out.println("Transferring NFT (serial #2) was failed (as expected): " + e.getMessage());
        }

        System.out.println("---");

        /*
         * Step 9:
         * The beginning of the second example (approve/delete allowances for ALL serial numbers at once).
         * Create a fungible HTS token using the Hedera Token Service.
         */
        System.out.println("The beginning of the second example (approve/delete allowances for ALL serial numbers at once).");

        String[] CIDs2 = {
            "QmNPCiNA3Dsu3K5FxDPMG5Q3fZRwVTg14EXA92uqEeSRXn",
            "QmZ4dgAgt8owvnULxnKxNe8YqpavtVCXmc1Lt2XajFpJs9",
            "QmPzY5GxevjyfMUF5vEAjtyRoigzWp47MiKAtLBduLMC1T",
        };

        System.out.println("Creating NFT using the Hedera Token Service...");
        TransactionReceipt nftCreateReceipt2 = new TokenCreateTransaction()
            .setTokenName("HIP336NFT2")
            .setTokenSymbol("HIP336NFT2")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setDecimals(0)
            .setInitialSupply(0)
            .setMaxSupply(CIDs2.length)
            .setTreasuryAccountId(OPERATOR_ID)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(operatorPublicKey)
            .setSupplyKey(operatorPublicKey)
            .setWipeKey(operatorPublicKey)
            .freezeWith(client)
            .execute(client)
            .getReceipt(client);

        TokenId nftTokenId2 = nftCreateReceipt2.tokenId;
        Objects.requireNonNull(nftCreateReceipt2);
        System.out.println("Created NFT with token ID: " + nftTokenId2);

        /*
         * Step 10:
         * Mint NFTs.
         */
        System.out.println("Minting NFTs...");
        List<TransactionReceipt> nftCollection2 = new ArrayList<>();
        for (int i = 0; i < CIDs2.length; i++) {
            nftCollection2.add(new TokenMintTransaction()
                .setTokenId(nftTokenId2)
                .setMetadata(List.of(CIDs2[i].getBytes(StandardCharsets.UTF_8)))
                .freezeWith(client)
                .execute(client)
                .getReceipt(client));

            System.out.println("Minted NFT (token ID: " + nftTokenId2 + ") with serial: " + nftCollection2.get(i).serials.get(0));
        }

        /*
         * Step 11:
         * Create spender and receiver accounts.
         */
        System.out.println("Creating spender and receiver accounts...");
        PrivateKey delegatingSpenderPrivateKey = PrivateKey.generateECDSA();
        PublicKey delegatingSpenderPublicKey2 = delegatingSpenderPrivateKey.getPublicKey();
        AccountId delegatingSpenderAccountId = new AccountCreateTransaction()
            .setKey(delegatingSpenderPublicKey2)
            .setInitialBalance(Hbar.from(2))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(delegatingSpenderAccountId);
        System.out.println("Created spender account with ID: " + delegatingSpenderAccountId);

        PrivateKey receiverPrivateKey2 = PrivateKey.generateECDSA();
        PublicKey receiverPublicKey2 = receiverPrivateKey2.getPublicKey();
        AccountId receiverAccountId2 = new AccountCreateTransaction()
            .setKey(receiverPublicKey2)
            .setInitialBalance(Hbar.from(2))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(receiverAccountId2);
        System.out.println("Created receiver account with ID: " + receiverAccountId2);

        /*
         * Step 12:
         * Associate spender and receiver accounts with the NFT.
         */
        System.out.println("Associating spender and receiver accounts with the NFT...");
        TransactionReceipt spenderAssociateReceipt2 = new TokenAssociateTransaction()
            .setAccountId(delegatingSpenderAccountId)
            .setTokenIds(List.of(nftTokenId2))
            .freezeWith(client)
            .sign(delegatingSpenderPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("Spender association transaction was complete with status: " + spenderAssociateReceipt2.status);

        TransactionReceipt receiverAssociateReceipt2 = new TokenAssociateTransaction()
            .setAccountId(receiverAccountId2)
            .setTokenIds(List.of(nftTokenId2))
            .freezeWith(client)
            .sign(receiverPrivateKey2)
            .execute(client)
            .getReceipt(client);
        System.out.println("Receiver association transaction was complete with status: " + receiverAssociateReceipt2.status);

        /*
         * Step 13:
         * Approve NFT (all serials) allowance for spender account.
         */
        NftId example2Nft1 = new NftId(nftTokenId2, 1);
        NftId example2Nft2 = new NftId(nftTokenId2, 2);
        NftId example2Nft3 = new NftId(nftTokenId2, 3);

        System.out.println("Approving spender account allowance for NFT (all serials)...");
        TransactionReceipt approveReceipt2 = new AccountAllowanceApproveTransaction()
            .approveTokenNftAllowanceAllSerials(nftTokenId2, OPERATOR_ID, delegatingSpenderAccountId)
            .execute(client)
            .getReceipt(client);
        System.out.println("Approve spender allowance transaction was complete with status: " + approveReceipt2.status);

        /*
         * Step 14:
         * Create delegate spender account.
         */
        System.out.println("Creating delegate spender account...");
        PrivateKey spenderPrivateKey2 = PrivateKey.generateECDSA();
        PublicKey spenderPublicKey2 = spenderPrivateKey2.getPublicKey();
        AccountId spenderAccountId2 = new AccountCreateTransaction()
            .setKey(spenderPublicKey2)
            .setInitialBalance(Hbar.from(2))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(spenderAccountId2);
        System.out.println("Created delegate spender account with ID: : " + spenderAccountId2);

        /*
         * Step 15:
         * Give delegatingSpender allowance for NFT with serial #3 on behalf of spender account which has approveForAll rights.
         */
        System.out.println("Approving delegate spender account allowance for NFT (serial #3) on behalf of spender account which has `approveForAll` rights...");
        TransactionReceipt approveDelegateAllowanceReceipt = new AccountAllowanceApproveTransaction()
            .approveTokenNftAllowance(example2Nft3, OPERATOR_ID, spenderAccountId2, delegatingSpenderAccountId)
            .freezeWith(client)
            .sign(delegatingSpenderPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("Approve delegated spender allowance for serial 3 - status: " + approveDelegateAllowanceReceipt.status);

        /*
         * Step 16:
         * Send NFT with serial #3 from operator's to receiver account.
         * This transaction should be executed on behalf of the spenderAccountId2,
         * which has an allowance to send serial #3, and should end up with SUCCESS.
         */
        // Generate TransactionId from spender's account id in order,
        // for the transaction to be executed on behalf of the spender.
        TransactionId delegatedOnBehalfOfTxId = TransactionId.generate(spenderAccountId2);

        TransactionReceipt delegatedSendTx = new TransferTransaction()
            .addApprovedNftTransfer(example2Nft3, OPERATOR_ID, receiverAccountId2)
            .setTransactionId(delegatedOnBehalfOfTxId)
            .freezeWith(client)
            .sign(spenderPrivateKey2)
            .execute(client)
            .getReceipt(client);
        System.out.println("Transfer serial 3 on behalf of the delegated spender status:" + delegatedSendTx.status);

        /*
         * Step 17:
         * Send NFT with serial #1 from operator's to receiver account.
         * This transaction should be executed on behalf of the delegatingSpender,
         * which has an allowance to send serial #1, and should end up with SUCCESS.
         */
        // Generate TransactionId from spender's account id in order,
        // for the transaction to be executed on behalf of the spender.
        TransactionId onBehalfOfTransactionId3 = TransactionId.generate(delegatingSpenderAccountId);

        TransactionReceipt approvedSendReceipt3 = new TransferTransaction()
            .addApprovedNftTransfer(example2Nft1, OPERATOR_ID, receiverAccountId2)
            .setTransactionId(onBehalfOfTransactionId3)
            .freezeWith(client)
            .sign(delegatingSpenderPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("Transfer serial 1 on behalf of the spender status:" + approvedSendReceipt3.status);

        /*
         * Step 18:
         * Remove delegatingSpender allowance for all of NFT serials.
         */
        TransactionReceipt deleteAllowanceReceipt2 = new AccountAllowanceApproveTransaction()
            .deleteTokenNftAllowanceAllSerials(nftTokenId2, OPERATOR_ID, delegatingSpenderAccountId)
            .execute(client)
            .getReceipt(client);
        System.out.println("Remove spender's allowance for serial 2 - status: " + deleteAllowanceReceipt2.status);

        /*
         * Step 19:
         * Send NFT with serial #2 from operator's to receiver account.
         * Spender does not have an allowance to send serial #2, should end up with SPENDER_DOES_NOT_HAVE_ALLOWANCE.
         */
        // Generate TransactionId from spender's account id in order,
        // for the transaction to be executed on behalf of the spender.
        TransactionId onBehalfOfTransactionId4 = TransactionId.generate(delegatingSpenderAccountId);

        try {
            new TransferTransaction()
                .addApprovedNftTransfer(example2Nft2, OPERATOR_ID, receiverAccountId2)
                .setTransactionId(onBehalfOfTransactionId4)
                .freezeWith(client)
                .sign(delegatingSpenderPrivateKey)
                .execute(client)
                .getReceipt(client);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        /*
         * Clean up:
         * Delete created accounts and tokens.
         */
        new TokenWipeTransaction()
            .setTokenId(nftTokenId)
            .addSerial(1)
            .setAccountId(receiverAccountId)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        new TokenWipeTransaction()
            .setTokenId(nftTokenId2)
            .addSerial(1)
            .addSerial(3)
            .setAccountId(receiverAccountId2)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(spenderAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(spenderPrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(receiverAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(receiverPrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(delegatingSpenderAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(delegatingSpenderPrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(receiverAccountId2)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(receiverPrivateKey2)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setTokenId(nftTokenId)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setTokenId(nftTokenId2)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Nft Add Remove Allowances (HIP-336) Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/PrngExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to generate random number.
 */
class PrngExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Prng Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Execute PrngTransaction and retrieve the result (random number) from the transaction record.
         */
        System.out.println("Executing Prng Transaction (range: 100)...");
        TransactionResponse transactionResponse = new PrngTransaction()
            // The only required property here is `key`.
            .setRange(100)
            .execute(client);

        // This will wait for the receipt to become available.
        TransactionRecord record = transactionResponse.getRecord(client);
        System.out.println("Prng transaction response (random number): " + record.prngNumber);

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Prng Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ScheduleExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.time.Instant;
import java.util.Objects;

/**
 * How to schedule a transaction.
 */
class ScheduleExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Schedule Transaction Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs for accounts.
         */
        System.out.println("Generating ED25519 key pairs for accounts...");
        PrivateKey privateKey1 = PrivateKey.generateED25519();
        PublicKey publicKey1 = privateKey1.getPublicKey();
        PrivateKey privateKey2 = PrivateKey.generateED25519();
        PublicKey publicKey2 = privateKey2.getPublicKey();

        /*
         * Step 1:
         * Create new account.
         */
        System.out.println("Creating new account...");
        AccountId accountId = new AccountCreateTransaction()
            .setKey(KeyList.of(publicKey1, publicKey2))
            .setInitialBalance(Hbar.from(1))
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(accountId);
        System.out.println("Created new account with ID: " + accountId);

        /*
         * Step 2:
         * Schedule a transfer transaction.
         */
        System.out.println("Scheduling token transfer...");
        TransactionResponse transferTxResponse = new TransferTransaction()
            .addHbarTransfer(accountId, Hbar.from(1).negated())
            .addHbarTransfer(client.getOperatorAccountId(), Hbar.from(1))
            .schedule()
            // Set expiration time to be now + 24 hours
            .setExpirationTime(Instant.now().plusSeconds(24 * 60 * 60))
            // Set wait for expiry to true
            .setWaitForExpiry(true)
            .execute(client);

        System.out.println("Scheduled transaction ID: " + transferTxResponse.transactionId);

        ScheduleId scheduleId = Objects.requireNonNull(transferTxResponse.getReceipt(client).scheduleId);
        System.out.println("Schedule ID for the transaction above: " + scheduleId);

        TransactionRecord record = transferTxResponse.getRecord(client);
        System.out.println("Scheduled transaction record: " + record);

        /*
         * Step 3:
         * Sign the schedule transaction with the first key.
         */
        System.out.println("Appending private key #1 signature to a schedule transaction...");
        var scheduleSignTxReceiptFirstSignature = new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(privateKey1)
            .execute(client)
            .getReceipt(client);

        System.out.println("A transaction that appends signature to a schedule transaction (private key #1) " +
            "was complete with status: " + scheduleSignTxReceiptFirstSignature.status);

        /*
         * Step 4:
         * Query the state of a schedule transaction.
         */
        ScheduleInfo scheduleInfo = new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);

        System.out.println("Schedule info: " + scheduleInfo);

        /*
         * Step 5:
         * Sign the schedule transaction with the second key.
         */
        System.out.println("Appending private key #2 signature to a schedule transaction...");
        var scheduleSignTxReceiptSecondSignature = new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(privateKey2)
            .execute(client)
            .getReceipt(client);

        System.out.println("A transaction that appends signature to a schedule transaction (private key #2) " +
            "was complete with status: " + scheduleSignTxReceiptSecondSignature.status);

        TransactionId transactionId = transferTxResponse.transactionId;
        String validMirrorTransactionId = transactionId.accountId.toString() + "-" + transactionId.validStart.getEpochSecond() + "-" + transactionId.validStart.getNano();
        String mirrorNodeUrl = "https://" + HEDERA_NETWORK + ".mirrornode.hedera.com/api/v1/transactions/" + validMirrorTransactionId;
        System.out.println("The following link should query the mirror node for the scheduled transaction: " + mirrorNodeUrl);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(accountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey1)
            .sign(privateKey2)
            .execute(client);

        client.close();

        System.out.println("Schedule Transaction Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ScheduleIdenticalTransactionExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * How to schedule identical transactions.
 */
class ScheduleIdenticalTransactionExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Schedule Identical Transaction Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Create key pairs, clients and accounts.
         */
        PrivateKey[] privateKeys = new PrivateKey[3];
        PublicKey[] publicKeys = new PublicKey[3];
        Client[] clients = new Client[3];
        AccountId[] accounts = new AccountId[3];

        ScheduleId scheduleId = null;

        for (int i = 0; i < 3 ; i++) {
            System.out.println("Generating ED25519 key pair...");

            PrivateKey newPrivateKey = PrivateKey.generateED25519();
            PublicKey newPublicKey = newPrivateKey.getPublicKey();

            privateKeys[i] = newPrivateKey;
            publicKeys[i] = newPublicKey;

            System.out.println("Key pair #" + (i + 1) +" | Private key: " + privateKeys[i]);
            System.out.println("Key pair #" + (i + 1) +" | Public key: " + publicKeys[i]);

            System.out.println("Creating new account...");
            TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
                .setKey(newPublicKey)
                .setInitialBalance(Hbar.from(1))
                .execute(client);

            // Make sure the transaction succeeded.
            TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);

            Client newClient = ClientHelper.forName(HEDERA_NETWORK);
            newClient.setOperator(Objects.requireNonNull(accountCreateTxReceipt.accountId), newPrivateKey);
            clients[i] = newClient;
            accounts[i] = accountCreateTxReceipt.accountId;

            System.out.println("Created new account with ID: " + accounts[i]);
            System.out.println("---");
        }

        /*
         * Step 2:
         * Create a threshold key with a threshold of 2 and length of 3 requires
         * (at least 2 of 3 keys to sign anything modifying the account).
         */
        System.out.println("Creating a Key List..." +
            "(with threshold, it will require 2 of 3 keys we generated to sign on anything modifying this account).");
        KeyList thresholdKey = KeyList.withThreshold(2);
        Collections.addAll(thresholdKey, publicKeys);
        System.out.println("Created a Key List: " + thresholdKey);

        /*
         * Step 3:
         * Create a new account with the Key List from previous step.
         */
        // We are using all of these keys, so the scheduled transaction doesn't automatically go through.
        // It works perfectly fine with just one key.
        System.out.println("Creating new account...(with the above Key List as an account key).");
        TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
            // The key that must sign each transfer out of the account. If receiverSigRequired is true, then
            // it must also sign any transfer into the account.
            .setKey(thresholdKey)
            .setInitialBalance(Hbar.from(10))
            .execute(client);

        // Make sure the transaction succeeded.
        TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);

        AccountId thresholdAccount = accountCreateTxReceipt.accountId;
        Objects.requireNonNull(thresholdAccount);
        System.out.println("Created new account with ID: " + thresholdAccount);

        System.out.println("\n---\n");

        /*
         * Step 4:
         * Each loopClient creates an identical transaction, sending 1 Hbar to each of the created accounts,
         * sent from the threshold Account.
         */
        for (Client loopClient : clients) {
            AccountId operatorId = loopClient.getOperatorAccountId();

            System.out.println("Creating transfer transaction...");
            TransferTransaction transferTx = new TransferTransaction();
            for (AccountId account : accounts) {
                transferTx.addHbarTransfer(account, Hbar.from(1));
            }
            transferTx.addHbarTransfer(Objects.requireNonNull(thresholdAccount), Hbar.from(3).negated());

            System.out.println("Scheduling created transfer transaction...");
            ScheduleCreateTransaction scheduledTx = new ScheduleCreateTransaction()
                .setScheduledTransaction(transferTx);

            scheduledTx.setPayerAccountId(thresholdAccount);

            TransactionResponse scheduledTxResponse = scheduledTx.execute(loopClient);

            System.out.println("Executing scheduled transaction...");
            TransactionReceipt loopReceipt = new TransactionReceiptQuery()
                .setTransactionId(scheduledTxResponse.transactionId)
                .setNodeAccountIds(Collections.singletonList(scheduledTxResponse.nodeId))
                .execute(loopClient);

            System.out.println("Operator (ID: " + operatorId + ") | Schedule ID: " + loopReceipt.scheduleId);

            // Save the schedule ID, so that it can be asserted for each loopClient submission.
            if (scheduleId == null) {
                scheduleId = loopReceipt.scheduleId;
            }

            if (!scheduleId.equals(Objects.requireNonNull(loopReceipt.scheduleId))) {
                throw new Exception("Invalid generated schedule ID! Expected " + scheduleId + ", got " + loopReceipt.scheduleId);
            }

            // If the status return by the receipt is related to already created, execute a schedule sign transaction.
            if (loopReceipt.status == Status.IDENTICAL_SCHEDULE_ALREADY_CREATED) {
                System.out.println("Appending signature to a schedule transaction...");
                TransactionResponse scheduleSignTxResponse = new ScheduleSignTransaction()
                    .setScheduleId(scheduleId)
                    .setNodeAccountIds(Collections.singletonList(accountCreateTxResponse.nodeId))
                    .setScheduleId(loopReceipt.scheduleId)
                    .execute(loopClient);

                TransactionReceipt scheduleSignTxReceipt = new TransactionReceiptQuery()
                    .setTransactionId(scheduleSignTxResponse.transactionId)
                    .execute(client);

                System.out.println("A transaction that appends signature to a schedule transaction " +
                    "was complete with status: " + scheduleSignTxReceipt.status);

                if (scheduleSignTxReceipt.status != Status.SUCCESS && scheduleSignTxReceipt.status != Status.SCHEDULE_ALREADY_EXECUTED) {
                    throw new Exception("Bad status while getting receipt of schedule sign with operator " + operatorId + ": " + scheduleSignTxReceipt.status);
                }
            }
            System.out.println("---");
        }

        System.out.println("\n---\n");

        /*
         * Step 5:
         * Query the state of a schedule transaction.
         */
        ScheduleInfo scheduleInfo = new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        System.out.println("Scheduled transaction info: " + scheduleInfo);

        /*
         * Clean up:
         * Delete created accounts and close created clients.
         */
        AccountDeleteTransaction accountDeleteTx = new AccountDeleteTransaction()
            .setAccountId(thresholdAccount)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client);

        for (int i = 0; i < 3; i++) {
            accountDeleteTx.sign(privateKeys[i]);
            new AccountDeleteTransaction()
                .setAccountId(accounts[i])
                .setTransferAccountId(OPERATOR_ID)
                .freezeWith(client)
                .sign(privateKeys[i])
                .execute(client)
                .getReceipt(client);
        }

        accountDeleteTx
            .execute(client)
            .getReceipt(client);

        client.close();

        for (Client loopClient : clients) {
            loopClient.close();
        }

        System.out.println("Schedule Identical Transaction Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ScheduleMultiSigTransactionExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Map;
import java.util.Objects;

/**
 * How to schedule a transaction with a multi-sig account.
 */
class ScheduleMultiSigTransactionExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Scheduled Transaction Multi-Sig Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        PublicKey operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Generate three ED25519 private keys.
         */
        System.out.println("Generating ED25519 private keys...");
        PrivateKey privateKey1 = PrivateKey.generateED25519();
        PublicKey publicKey1 = privateKey1.getPublicKey();
        PrivateKey privateKey2 = PrivateKey.generateED25519();
        PublicKey publicKey2 = privateKey2.getPublicKey();
        PrivateKey privateKey3 = PrivateKey.generateED25519();
        PublicKey publicKey3 = privateKey3.getPublicKey();

        /*
         * Step 2:
         * Create a Key List from keys generated in previous step.
         *
         * This key will be used as the new account's key.
         * The reason we want to use a `KeyList` is to simulate a multi-party system where
         * multiple keys are required to sign.
         */
        System.out.println("Creating a Key List...");
        KeyList keyList = new KeyList();
        keyList.add(publicKey1);
        keyList.add(publicKey2);
        keyList.add(publicKey3);
        System.out.println("Created a Key List: " + keyList);

        /*
         * Step 3:
         * Create a new account with a Key List created in a previous step.
         */
        System.out.println("Creating new account...");
        TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
            .setNodeAccountIds(Collections.singletonList(new AccountId(3)))
            // The only required property here is key.
            .setKey(keyList)
            .setInitialBalance(Hbar.from(2))
            .execute(client);

        // This will wait for the receipt to become available.
        TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);
        AccountId accountId = Objects.requireNonNull(accountCreateTxReceipt.accountId);
        System.out.println("Created new account with ID: " + accountId);

        /*
         * Step 4:
         * Create a new scheduled transaction for transferring Hbars.
         */
        // Generate a TransactionId. This id is used to query the inner scheduled transaction
        // after we expect it to have been executed.
        TransactionId transactionId = TransactionId.generate(OPERATOR_ID);

        System.out.println("Generated `TransactionId` for a scheduled transaction: " + transactionId);

        // Create a transfer transaction with 2/3 signatures.
        System.out.println("Creating a token transfer transaction...");
        TransferTransaction transferTx = new TransferTransaction()
            .addHbarTransfer(accountId, Hbar.from(1).negated())
            .addHbarTransfer(OPERATOR_ID, Hbar.from(1));

        // Schedule the transaction.
        System.out.println("Scheduling the token transfer transaction...");
        ScheduleCreateTransaction scheduled = transferTx.schedule()
            .setPayerAccountId(OPERATOR_ID)
            .setAdminKey(operatorPublicKey)
            .freezeWith(client)
            .sign(privateKey2);

        accountCreateTxReceipt = scheduled.execute(client).getReceipt(client);
        // Get the schedule ID from the receipt.
        ScheduleId scheduleId = Objects.requireNonNull(accountCreateTxReceipt.scheduleId);
        System.out.println("Schedule ID: " + scheduleId);

        /*
         * Step 5:
         * Get the schedule info to see if signatories is populated with 2/3 signatures.
         */
        ScheduleInfo scheduleInfo_BeforeLastSignature = new ScheduleInfoQuery()
            .setNodeAccountIds(Collections.singletonList(accountCreateTxResponse.nodeId))
            .setScheduleId(scheduleId)
            .execute(client);

        System.out.println("Schedule info: " + scheduleInfo_BeforeLastSignature);

        transferTx = (TransferTransaction) scheduleInfo_BeforeLastSignature.getScheduledTransaction();
        Map<AccountId, Hbar> transfers = transferTx.getHbarTransfers();

        // Make sure the transfer transaction is what we expect.
        if (transfers.size() != 2) {
            throw new Exception("More transfers than expected! (Fail)");
        }

        if (!transfers.get(accountId).equals(Hbar.from(1).negated())) {
            throw new Exception("Transfer for " + accountId + " is not what is expected " + transfers.get(accountId));
        }

        if (!transfers.get(OPERATOR_ID).equals(Hbar.from(1))) {
            throw new Exception("Transfer for " + OPERATOR_ID + " is not what is expected " + transfers.get(OPERATOR_ID));
        }

        System.out.println("Sending schedule sign transaction...");

        /*
         * Step 6:
         * Send this last signature to Hedera.
         *
         * This last signature should mean the transaction executes since all 3 signatures have been provided.
         */
        System.out.println("Appending private key #3 signature to a schedule transaction..." +
            "(This last signature should mean the transaction executes since all 3 signatures have been provided)");
        TransactionReceipt scheduleSignTxReceipt = new ScheduleSignTransaction()
            .setNodeAccountIds(Collections.singletonList(accountCreateTxResponse.nodeId))
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(privateKey3)
            .execute(client)
            .getReceipt(client);

        System.out.println("A transaction that appends signature to a schedule transaction (private key #3) " +
            "was complete with status: " + scheduleSignTxReceipt.status);

        /*
         * Step 7:
         * Query the schedule info again.
         */
        ScheduleInfo scheduleInfo_AfterAllSigned = new ScheduleInfoQuery()
            .setNodeAccountIds(Collections.singletonList(accountCreateTxResponse.nodeId))
            .setScheduleId(scheduleId)
            .execute(client);

        System.out.println("Schedule info: " + scheduleInfo_AfterAllSigned);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(accountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey1)
            .sign(privateKey2)
            .sign(privateKey3)
            .execute(client);

        client.close();

        System.out.println("Scheduled Transaction Multi-Sig Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ScheduledTransactionMultiSigThresholdExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * How to schedule a transaction with a multi-sig account with a threshold.
 */
class ScheduledTransactionMultiSigThresholdExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Scheduled Transaction Multi-Sig With Threshold Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate four ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey[] privateKeys = new PrivateKey[4];
        PublicKey[] publicKeys = new PublicKey[4];
        for (int i = 0; i < 4; i++) {
            PrivateKey key = PrivateKey.generateED25519();
            privateKeys[i] = key;
            publicKeys[i] = key.getPublicKey();
            System.out.println("Key pair #" + (i + 1) +" | Private key: " + privateKeys[i]);
            System.out.println("Key pair #" + (i + 1) +" | Public key: " + publicKeys[i]);
        }

        /*
         * Step 2:
         * Create a Key List with threshold
         * (require 3 of 4 keys we generated to sign on anything modifying this account).
         */
        System.out.println("Creating a Key List..." +
            "(with threshold, it will require 3 of 4 keys we generated to sign on anything modifying this account).");
        KeyList thresholdKey = KeyList.withThreshold(3);
        Collections.addAll(thresholdKey, publicKeys);
        System.out.println("Created a Key List: " + thresholdKey);

        /*
         * Step 3:
         * Create a new account with a Key List from previous step.
         */
        System.out.println("Creating new account...(with the above Key List as an account key).");
        TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
            .setKey(thresholdKey)
            .setInitialBalance(Hbar.from(1))
            .setAccountMemo("3-of-4 multi-sig account")
            .execute(client);

        // This will wait for the receipt to become available.
        TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);
        AccountId multiSigAccountId = Objects.requireNonNull(accountCreateTxReceipt.accountId);
        Objects.requireNonNull(multiSigAccountId);
        System.out.println("Created new account with ID: " + multiSigAccountId);

        /*
         * Step 4:
         * Check the balance of the newly created account.
         */
        AccountBalance accountBalance = new AccountBalanceQuery()
            .setAccountId(multiSigAccountId)
            .execute(client);

        System.out.println("Balance of a newly created account with ID " + multiSigAccountId + ": " + accountBalance.hbars.toTinybars() + " tinybar.");

        /*
         * Step 5:
         * Schedule crypto transfer from multi-sig account to operator account.
         */
        System.out.println("Scheduling crypto transfer from multi-sig account to operator account...");
        TransactionResponse transferTxScheduled = new TransferTransaction()
            .addHbarTransfer(multiSigAccountId, Hbar.from(1).negated())
            .addHbarTransfer(Objects.requireNonNull(client.getOperatorAccountId()), Hbar.from(1))
            .schedule()
            .freezeWith(client)
            // Add first signature.
            .sign(privateKeys[0])
            .execute(client);

        TransactionReceipt transferTxScheduledReceipt = transferTxScheduled.getReceipt(client);
        System.out.println("Schedule status: " + transferTxScheduledReceipt.status);
        ScheduleId scheduleId = Objects.requireNonNull(transferTxScheduledReceipt.scheduleId);
        System.out.println("Schedule ID: " + scheduleId);
        TransactionId scheduledTxId = Objects.requireNonNull(transferTxScheduledReceipt.scheduledTransactionId);
        System.out.println("Scheduled transaction ID: " + scheduledTxId);

        // Add second signature.
        TransactionResponse scheduleSignTxResponseSecondSignature = new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(privateKeys[1])
            .execute(client);

        TransactionReceipt scheduleSignTxReceiptSecondSignature = scheduleSignTxResponseSecondSignature.getReceipt(client);
        System.out.println("A transaction that appends signature to a schedule transaction (private key #2) " +
            "was complete with status: " + scheduleSignTxReceiptSecondSignature.status);

        // Add third signature.
        TransactionResponse scheduleSignTxResponseThirdSignature = new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(privateKeys[2])
            .execute(client);

        TransactionReceipt scheduleSignTxReceiptThirdSignature = scheduleSignTxResponseThirdSignature.getReceipt(client);
        System.out.println("A transaction that appends signature to a schedule transaction (private key #3) " +
            "was complete with status: " + scheduleSignTxReceiptThirdSignature.status);

        /*
         * Step 6:
         * Query schedule.
         */
        ScheduleInfo scheduleInfo = new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        System.out.println("Schedule info: " + scheduleInfo);

        /*
         * Step 7:
         * Query triggered scheduled transaction.
         */
        TransactionRecord recordScheduledTx = new TransactionRecordQuery()
            .setTransactionId(scheduledTxId)
            .execute(client);
        System.out.println("Triggered scheduled transaction info: " + recordScheduledTx);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(multiSigAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKeys[0])
            .sign(privateKeys[1])
            .sign(privateKeys[2])
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Scheduled Transaction Multi-Sig With Threshold Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ScheduledTransferExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to schedule a transfer transaction.
 * <p>
 * A scheduled transaction is a transaction that has been proposed by an account,
 * but which requires more signatures before it will actually execute on the Hedera network.
 * <p>
 * For example, if Alice wants to transfer an amount of Hbar to Bob, and Bob has
 * `receiverSignatureRequired` set to true, then that transaction must be signed by
 * both Alice and Bob before the transaction will be executed.
 * <p>
 * To solve this problem, Alice can propose the transaction by creating a scheduled
 * transaction on the Hedera network which, if executed, would transfer Hbar from
 * Alice to Bob. That scheduled transaction will have a `ScheduleId` by which we can
 * refer to that scheduled transaction. Alice can communicate the `ScheduleId` to Bob, and
 * then Bob can use a `ScheduleSignTransaction` to sign that scheduled transaction.
 * <p>
 * Bob has a 30-minute window in which to sign the scheduled transaction, starting at the
 * moment that Alice creates the scheduled transaction.  If a scheduled transaction
 * is not signed by all the necessary signatories within the 30-minute window,
 * that scheduled transaction will expire, and will not be executed.
 * <p>
 * Once a scheduled transaction has all the signatures necessary to execute, it will
 * be executed on the Hedera network automatically. If you create a scheduled transaction
 * on the Hedera network, but that transaction only requires your signature in order to
 * execute and no one else's, that scheduled transaction will be automatically
 * executed immediately.
 */
class ScheduledTransferExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Scheduled Transfer Transaction Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        System.out.println("In this example Alice's account ID would be equal to the Operator's account ID: "
            + client.getOperatorAccountId());

        /*
         * Step 1:
         * Generate ED25519 key pair.
         */
        System.out.println("Generating ED25519 key pair for Bob's account...");
        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create Bob's account with receiver signature property enabled.
         */
        System.out.println("Create Bob's account...(with receiver signature property enabled).");
        AccountId bobAccountId = new AccountCreateTransaction()
            .setReceiverSignatureRequired(true)
            .setKey(bobPublicKey)
            .setInitialBalance(Hbar.from(1))
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(bobAccountId);
        System.out.println("Created Bob's account with ID: " + bobAccountId);

        /*
         * Step 3:
         * Check Bob's initial balance.
         */
        AccountBalance bobsInitialBalance = new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client);
        System.out.println("Bob's initial account balance: " + bobsInitialBalance);

        /*
         * Step 4:
         * Create a transfer transaction which we will schedule.
         */
        TransferTransaction transferTx = new TransferTransaction()
            .addHbarTransfer(client.getOperatorAccountId(), Hbar.from(1).negated())
            .addHbarTransfer(bobAccountId, Hbar.from(1));
        System.out.println("Scheduling token transfer: " + transferTx);

        /*
         * Step 5:
         * Create a scheduled transaction from a transfer transaction.
         *
         * The payerAccountId is the account that will be charged the fee
         * for executing the scheduled transaction if/when it is executed.
         * That fee is separate from the fee that we will pay to execute the
         * ScheduleCreateTransaction itself.
         *
         * To clarify: Alice pays a fee to execute the ScheduleCreateTransaction,
         * which creates the scheduled transaction on the Hedera network.
         * She specifies when creating the scheduled transaction that Bob will pay
         * the fee for the scheduled transaction when it is executed.
         *
         * If payerAccountId is not specified, the account who creates the scheduled transaction
         * will be charged for executing the scheduled transaction.
         */
        ScheduleId scheduleId = new ScheduleCreateTransaction()
            .setScheduledTransaction(transferTx)
            .setPayerAccountId(bobAccountId)
            .execute(client)
            .getReceipt(client)
            .scheduleId;
        Objects.requireNonNull(scheduleId);
        System.out.println("Schedule ID for the transaction above: " + scheduleId);

        /*
         * Step 6:
         * Check Bob's balance -- it should be unchanged, because the transfer has been scheduled,
         * but it hasn't been executed yet as it requires Bob's signature.
         */
        AccountBalance bobsBalanceAfterSchedule = new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client);
        System.out.println("Bob's balance after scheduling the transfer (should be unchanged): " + bobsBalanceAfterSchedule);

        /*
         * Step 7:
         * Query the state of a schedule transaction.
         *
         * Once Alice has communicated the scheduleId to Bob, Bob can query for information about the
         * scheduled transaction.
         */
        ScheduleInfo scheduledTransactionInfo = new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        System.out.println("Scheduled transaction info: " + scheduledTransactionInfo);

        // getScheduledTransaction() will return an SDK Transaction object identical to the transaction
        // that was scheduled, which Bob can then inspect like a normal transaction.
        Transaction<?> scheduledTransaction = scheduledTransactionInfo.getScheduledTransaction();

        // We happen to know that this transaction is (or certainly ought to be) a TransferTransaction.
        if (scheduledTransaction instanceof TransferTransaction) {
            TransferTransaction scheduledTransfer = (TransferTransaction) scheduledTransaction;
            System.out.println("The scheduled transfer transaction from Bob's POV: " + scheduledTransfer);
        } else {
            throw new Exception("The scheduled transaction was not a transfer transaction! (Fail)");
        }

        /*
         * Step 8:
         * Appends Bob's signature to a schedule transaction, i.e. Bob signs the scheduled transaction.
         */
        System.out.println("Appending Bob's signature to a schedule transaction...");
        var scheduleSignTxReceipt = new ScheduleSignTransaction()
            .setScheduleId(scheduleId)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);
        System.out.println("A transaction that appends Bob's signature to a schedule transfer transaction " +
            "was complete with status: " + scheduleSignTxReceipt.status);

        /*
         * Step 9:
         * Check Bob's account balance after signing the scheduled transaction.
         */
        AccountBalance balanceAfterSigning = new AccountBalanceQuery()
            .setAccountId(bobAccountId)
            .execute(client);
        System.out.println("Bob's balance after signing the scheduled transaction: " + balanceAfterSigning);

        /*
         * Step 10:
         * Query the state of a schedule transaction.
         */
        ScheduleInfo postTransactionInfo = new ScheduleInfoQuery()
            .setScheduleId(scheduleId)
            .execute(client);
        System.out.println("Scheduled transaction info (`executedAt` should no longer be `null`): " + postTransactionInfo);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setTransferAccountId(client.getOperatorAccountId())
            .setAccountId(bobAccountId)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Scheduled Transfer Transaction Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/SignTransactionExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * How to sign a transaction with a multi-sig account.
 */
class SignTransactionExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Sign Transaction Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey privateKey1 = PrivateKey.generateED25519();
        PublicKey publicKey1 = privateKey1.getPublicKey();
        PrivateKey privateKey2 = PrivateKey.generateED25519();
        PublicKey publicKey2 = privateKey2.getPublicKey();

        /*
         * Step 2:
         * Create a Key List from keys generated in previous step.
         */
        System.out.println("Creating a Key List...");
        KeyList keylist = new KeyList();
        keylist.add(publicKey1);
        keylist.add(publicKey2);
        System.out.println("Created a Key List: " + keylist);

        /*
         * Step 3:
         * Create a new account with a Key List created in a previous step.
         */
        System.out.println("Creating new account...");
        TransactionResponse createAccountTxResponse = new AccountCreateTransaction()
            .setInitialBalance(Hbar.from(2))
            .setKey(keylist)
            .execute(client);

        TransactionReceipt createAccountTxReceipt = createAccountTxResponse.getReceipt(client);
        var accountId = createAccountTxReceipt.accountId;
        Objects.requireNonNull(accountId);
        System.out.println("Created new account with ID: " + accountId);

        /*
         * Step 4:
         * Create a transfer transaction and freeze it with a client.
         */
        System.out.println("Creating a transfer transaction...");
        TransferTransaction transferTx = new TransferTransaction()
            .setNodeAccountIds(Collections.singletonList(new AccountId(3)))
            .addHbarTransfer(Objects.requireNonNull(createAccountTxReceipt.accountId), Hbar.from(1).negated())
            .addHbarTransfer(new AccountId(3), Hbar.from(1))
            .freezeWith(client);

        /*
         * Step 5:
         * Sign the transfer transaction with all respective keys (from a Key List).
         */
        System.out.println("Signing the transfer transaction...");
        transferTx.signWithOperator(client);
        privateKey1.signTransaction(transferTx);
        privateKey2.signTransaction(transferTx);

        /*
         * Step 6:
         * Execute the transfer transaction and output its status.
         */
        System.out.println("Executing the transfer transaction...");
        TransactionResponse transferTxResponse = transferTx.execute(client);
        TransactionReceipt transferTxReceipt = transferTxResponse.getReceipt(client);
        System.out.println("The transfer transaction was complete with status: " + transferTxReceipt.status);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(accountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey1)
            .sign(privateKey2)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Sign Transaction Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/SolidityPrecompileExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Arrays;
import java.util.Objects;
import java.util.function.Consumer;

/*
This example just instantiates the solidity contract
defined in resources/com/hedera/hashgraph/sdk/examples/contracts/precompile/PrecompileExample.sol, which has been
compiled into resources/com/hedera/hashgraph/sdk/examples/contracts/precompile/PrecompileExample.json.

You should go look at that PrecompileExample.sol file, because that's where the meat of this example is.

This example uses the ContractHelper class (defined in ./ContractHelper.java) to declutter things.

When this example spits out a raw response code,
you can look it up here: https://github.com/hashgraph/hedera-protobufs/blob/main/services/response_code.proto
 */

public class SolidityPrecompileExample {

    // see `.env.sample` in the repository root for how to specify these values
    // or set environment variables with the same names
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));
    // HEDERA_NETWORK defaults to testnet if not specified in dotenv
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    private SolidityPrecompileExample() {
    }

    public static void main(String[] args) throws Exception {
        Client client = ClientHelper.forName(HEDERA_NETWORK);

        // Defaults the operator account ID and key such that all generated transactions will be paid for
        // by this account and be signed by this key
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);

        // We need a new account for the contract to interact with in some of its steps
        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();
        AccountId aliceAccountId = Objects.requireNonNull(new AccountCreateTransaction()
            .setKey(alicePublicKey)
            .setInitialBalance(Hbar.fromTinybars(1000))
            .execute(client)
            .getReceipt(client)
            .accountId
        );

        // Instantiate ContractHelper
        ContractHelper contractHelper = new ContractHelper(
            "contracts/precompile/PrecompileExample.json",
            new ContractFunctionParameters()
                .addAddress(OPERATOR_ID.toSolidityAddress())
                .addAddress(aliceAccountId.toSolidityAddress()),
            client
        );

        // Update the signer to have contractId KeyList (this is by security requirement)
        new AccountUpdateTransaction()
            .setAccountId(OPERATOR_ID)
            .setKey(KeyList.of(OPERATOR_KEY.getPublicKey(), contractHelper.contractId).setThreshold(1))
            .execute(client)
            .getReceipt(client);

        // Update the Alice account to have contractId KeyList (this is by security requirement)
        new AccountUpdateTransaction()
            .setAccountId(aliceAccountId)
            .setKey(KeyList.of(alicePublicKey, contractHelper.contractId).setThreshold(1))
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        Consumer<String> additionalLogic = tokenAddress -> {
            try {
                var tokenUpdateTransactionReceipt = new TokenUpdateTransaction()
                    .setTokenId(TokenId.fromSolidityAddress(tokenAddress))
                    .setAdminKey(KeyList.of(OPERATOR_KEY.getPublicKey(), contractHelper.contractId).setThreshold(1))
                    .setSupplyKey(KeyList.of(OPERATOR_KEY.getPublicKey(), contractHelper.contractId).setThreshold(1))
                    .freezeWith(client)
                    .sign(alicePrivateKey)
                    .execute(client)
                    .getReceipt(client);

                System.out.println("Status of Token Update Transaction: " + tokenUpdateTransactionReceipt.status);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };

        // Configure steps in ContractHelper
        contractHelper
            .setResultValidatorForStep(0, contractFunctionResult -> {
                System.out.println("getPseudoRandomSeed() returned " + Arrays.toString(contractFunctionResult.getBytes32(0)));
                return true;
            }).setPayableAmountForStep(1, Hbar.from(20))
            // step 3 associates Alice with the token, which requires Alice's signature
            .addSignerForStep(3, alicePrivateKey)
            .addSignerForStep(5, alicePrivateKey)
            .setParameterSupplierForStep(11, () -> {
                return new ContractFunctionParameters()
                    // when contracts work with a public key, they handle the raw bytes of the public key
                    .addBytes(alicePublicKey.toBytesRaw());
            }).setPayableAmountForStep(11, Hbar.from(40))
            // Because we're setting the adminKey for the created NFT token to Alice's key,
            // Alice must sign the ContractExecuteTransaction.
            .addSignerForStep(11, alicePrivateKey)
            .setStepLogic(11, additionalLogic)
            // and Alice must sign for minting because her key is the supply key.
            .addSignerForStep(12, alicePrivateKey)
            .setParameterSupplierForStep(12, () -> {
                return new ContractFunctionParameters()
                    // add three metadatas
                    .addBytesArray(new byte[][]{new byte[]{0x01b}, new byte[]{0x02b}, new byte[]{0x03b}});
            }) // and alice must sign to become associated with the token.
            .addSignerForStep(13, alicePrivateKey)
            // Alice must sign to burn the token because her key is the supply key
            .addSignerForStep(16, alicePrivateKey);

        // step 0 tests pseudo random number generator (PRNG)
        // step 1 creates a fungible token
        // step 2 mints it
        // step 3 associates Alice with it
        // step 4 transfers it to Alice.
        // step 5 approves an allowance of the fungible token with operator as the owner and Alice as the spender [NOT WORKING]
        // steps 6 - 10 test misc functions on the fungible token (see PrecompileExample.sol for details).
        // step 11 creates an NFT token with a custom fee, and with the admin and supply set to Alice's key
        // step 12 mints some NFTs
        // step 13 associates Alice with the NFT token
        // step 14 transfers some NFTs to Alice
        // step 15 approves an NFT allowance with operator as the owner and Alice as the spender [NOT WORKING]
        // step 16 burn some NFTs

        contractHelper.executeSteps(/* from step */ 0, /* to step */ 16, client);

        System.out.println("All steps completed with valid results.");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/StakingExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to stake to some account.
 *
 */
class StakingExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Staking Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pair.
         */
        System.out.println("Generating ED25519 key pair...");
        PrivateKey privateKey = PrivateKey.generateED25519();
        PublicKey publicKey = privateKey.getPublicKey();

        /*
         * Step 2:
         * Create an account and stake to an account ID.
         *
         * In this case we're staking to account ID 3 which happens to be
         * the account ID of node 0, we're only doing this as an example.
         * If you really want to stake to node 0, you should use setStakedNodeId() instead.
         */
        System.out.println("Creating new account with staked account ID...");
        AccountId stakedAccountId = AccountId.fromString("0.0.3");
        AccountId newAccountId = new AccountCreateTransaction()
            .setKey(publicKey)
            .setInitialBalance(Hbar.from(1))
            .setStakedAccountId(stakedAccountId)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(newAccountId);
        System.out.println("Created new account with ID: " + newAccountId);

        // Show the required key used to sign the account update transaction to
        // stake the accounts Hbar i.e. the fee payer key and key to authorize
        // changes to the account should be different.
        System.out.println("Key required to update staking information: " + publicKey);
        System.out.println("Fee payer or operator key: " + client.getOperatorPublicKey());

        /*
         * Step 3:
         * Query the account info, it should show the staked account ID to be 0.0.3.
         */
        AccountInfo info = new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        if (info.stakingInfo.stakedAccountId.equals(stakedAccountId)) {
            System.out.println("New account staking info: " + info.stakingInfo);
        } else {
            throw new Exception("Staked account ID was not set correctly! (Fail)");
        }

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(newAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Staking Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/StakingWithUpdateExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to stake to some account and then unstake.
 */
class StakingWithUpdateExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Staking With Update Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate an ED25519 key pair.
         */
        System.out.println("Generating ED25519 key pair...");
        PrivateKey privateKey = PrivateKey.generateED25519();
        PublicKey publicKey = privateKey.getPublicKey();

        /*
         * Step 2:
         * Create an account and stake to an account ID.
         *
         * In this case we're staking to account ID 3 which happens to be
         * the account ID of node 0, we're only doing this as an example.
         * If you really want to stake to node 0, you should use setStakedNodeId() instead.
         */
        System.out.println("Creating new account with staked account ID...");
        AccountId stakedAccountId = AccountId.fromString("0.0.3");
        AccountId newAccountId = new AccountCreateTransaction()
            .setKey(publicKey)
            .setInitialBalance(Hbar.from(1))
            .setStakedAccountId(stakedAccountId)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(newAccountId);
        System.out.println("Created new account with ID: " + newAccountId);

        // Show the required key used to sign the account update transaction to
        // stake the accounts Hbar i.e. the fee payer key and key to authorize
        // changes to the account should be different.
        System.out.println("Key required to update staking information: " + publicKey);
        System.out.println("Fee payer or operator key: " + client.getOperatorPublicKey());

        /*
         * Step 3:
         * Query the account info, it should show the staked account ID to be 0.0.3.
         */
        AccountInfo accountInfo = new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        if (accountInfo.stakingInfo.stakedAccountId.equals(stakedAccountId)) {
            System.out.println("New account staking info: " + accountInfo.stakingInfo);
        } else {
            throw new Exception("Staked account ID was not set correctly! (Fail)");
        }

        /*
         * Step 4:
         * Use the AccountUpdateTransaction to unstake the account's Hbar.
         *
         * If this succeeds then we should no longer have a staked account ID.
         */
        System.out.println("Updating the new account...(unstake Hbar).");
        new AccountUpdateTransaction()
            .setAccountId(newAccountId)
            .clearStakedAccountId()
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 5:
         * Query the account info, it should show the staked account ID to be null.
         */
        accountInfo = new AccountInfoQuery()
            .setAccountId(newAccountId)
            .execute(client);

        if (accountInfo.stakingInfo.stakedAccountId == null) {
            System.out.println("New account staking info: " + accountInfo.stakingInfo);
        } else {
            throw new Exception("Staked account ID was not set correctly! (Fail)");
        }

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(newAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Staking With Update Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TokenAirdropExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TokenAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenCancelAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenClaimAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenRejectTransaction;
import com.hedera.hashgraph.sdk.TokenSupplyType;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class TokenAirdropExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID. Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(
        Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(
        Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file. Network can be: localhost, testnet,
     * previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file. Log levels can be: TRACE, DEBUG, INFO, WARN,
     * ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL, for example via VM
     * options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Example Start!");

        /*
         * Step 0:
         * Create and configure SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Create 4 accounts
         */
        var privateKey1 = PrivateKey.generateECDSA();
        var alice = new AccountCreateTransaction()
            .setKey(privateKey1)
            .setInitialBalance(new Hbar(10))
            .setMaxAutomaticTokenAssociations(-1)
            .execute(client)
            .getReceipt(client)
            .accountId;

        var privateKey2 = PrivateKey.generateECDSA();
        var bob = new AccountCreateTransaction()
            .setKey(privateKey2)
            .setMaxAutomaticTokenAssociations(1)
            .execute(client)
            .getReceipt(client)
            .accountId;

        var privateKey3 = PrivateKey.generateECDSA();
        var carol = new AccountCreateTransaction()
            .setKey(privateKey3)
            .setMaxAutomaticTokenAssociations(0)
            .execute(client)
            .getReceipt(client)
            .accountId;

        var treasuryKey = PrivateKey.generateECDSA();
        var treasuryAccount = new AccountCreateTransaction()
            .setKey(treasuryKey)
            .setInitialBalance(new Hbar(10))
            .execute(client)
            .getReceipt(client)
            .accountId;

        /*
         * Step 2:
         * Create FT and NFT and mint
         */
        var tokenID = new TokenCreateTransaction()
            .setTokenName("Fungible Token")
            .setTokenSymbol("TFT")
            .setTokenMemo("Example memo")
            .setDecimals(3)
            .setInitialSupply(100)
            .setMaxSupply(100)
            .setTreasuryAccountId(treasuryAccount)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(client.getOperatorPublicKey())
            .setFreezeKey(client.getOperatorPublicKey())
            .setSupplyKey(client.getOperatorPublicKey())
            .setMetadataKey(client.getOperatorPublicKey())
            .setPauseKey(client.getOperatorPublicKey())
            .freezeWith(client)
            .sign(treasuryKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;

        var nftID = new TokenCreateTransaction()
            .setTokenName("Test NFT")
            .setTokenSymbol("TNFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setTreasuryAccountId(treasuryAccount)
            .setSupplyType(TokenSupplyType.FINITE)
            .setMaxSupply(10)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(client.getOperatorPublicKey())
            .setFreezeKey(client.getOperatorPublicKey())
            .setSupplyKey(client.getOperatorPublicKey())
            .setMetadataKey(client.getOperatorPublicKey())
            .setPauseKey(client.getOperatorPublicKey())
            .freezeWith(client)
            .sign(treasuryKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;

        new TokenMintTransaction()
            .setTokenId(nftID)
            .setMetadata(generateNftMetadata((byte) 3))
            .execute(client)
            .getReceipt(client);


        /*
         * Step 3:
         * Airdrop fungible tokens to all 3 accounts
         */
        System.out.println("Airdropping fts");
        var txnRecord = new TokenAirdropTransaction()
            .addTokenTransfer(tokenID, alice, 10)
            .addTokenTransfer(tokenID, treasuryAccount, -10)
            .addTokenTransfer(tokenID, bob, 10)
            .addTokenTransfer(tokenID, treasuryAccount, -10)
            .addTokenTransfer(tokenID, carol, 10)
            .addTokenTransfer(tokenID, treasuryAccount, -10)
            .freezeWith(client)
            .sign(treasuryKey)
            .execute(client)
            .getRecord(client);

        /*
         * Step 4:
         * Get the transaction record and see one pending airdrop (for carol)
         */
        System.out.println("Pending airdrops length: " + txnRecord.pendingAirdropRecords.size());
        System.out.println("Pending airdrops: " + txnRecord.pendingAirdropRecords.get(0));

        /*
         * Step 5:
         * Query to verify alice and bob received the airdrops and carol did not
         */
        var aliceBalance = new AccountBalanceQuery()
            .setAccountId(alice)
            .execute(client);
        var bobBalance = new AccountBalanceQuery()
            .setAccountId(bob)
            .execute(client);
        var carolBalance = new AccountBalanceQuery()
            .setAccountId(carol)
            .execute(client);

        System.out.println("Alice ft balance after airdrop: " + aliceBalance.tokens.get(tokenID));
        System.out.println("Bob ft balance after airdrop: " + bobBalance.tokens.get(tokenID));
        System.out.println("Carol ft balance after airdrop: " + carolBalance.tokens.get(tokenID));

        /*
         * Step 6:
         * Claim the airdrop for carol
         */
        System.out.println("Claiming ft with carol");
        new TokenClaimAirdropTransaction()
            .addPendingAirdrop(txnRecord.pendingAirdropRecords.get(0).getPendingAirdropId())
            .freezeWith(client)
            .sign(privateKey3)
            .execute(client)
            .getReceipt(client);

        carolBalance = new AccountBalanceQuery()
            .setAccountId(carol)
            .execute(client);
        System.out.println("Carol ft balance after claim: " + carolBalance.tokens.get(tokenID));

        /*
         * Step 7:
         * Airdrop the NFTs to all three accounts
         */
        System.out.println("Airdropping nfts");
        txnRecord = new TokenAirdropTransaction()
            .addNftTransfer(nftID.nft(1), treasuryAccount, alice)
            .addNftTransfer(nftID.nft(2), treasuryAccount, bob)
            .addNftTransfer(nftID.nft(3), treasuryAccount, carol)
            .freezeWith(client)
            .sign(treasuryKey)
            .execute(client)
            .getRecord(client);

        /*
         * Step 8:
         * Get the transaction record and verify two pending airdrops (for bob & carol)
         */
        System.out.println("Pending airdrops length: " + txnRecord.pendingAirdropRecords.size());
        System.out.println("Pending airdrops for Bob: " + txnRecord.pendingAirdropRecords.get(0));
        System.out.println("Pending airdrops for Carol: " + txnRecord.pendingAirdropRecords.get(1));

        /*
         * Step 9:
         * Query to verify alice received the airdrop and bob and carol did not
         */
        aliceBalance = new AccountBalanceQuery()
            .setAccountId(alice)
            .execute(client);
        bobBalance = new AccountBalanceQuery()
            .setAccountId(bob)
            .execute(client);
        carolBalance = new AccountBalanceQuery()
            .setAccountId(carol)
            .execute(client);

        System.out.println("Alice nft balance after airdrop: " + aliceBalance.tokens.get(nftID));
        System.out.println("Bob nft balance after airdrop: " + bobBalance.tokens.get(nftID));
        System.out.println("Carol nft balance after airdrop: " + carolBalance.tokens.get(nftID));

        /*
         * Step 10:
         * Claim the airdrop for bob
         */
        System.out.println("Claiming nft with Bob");
        new TokenClaimAirdropTransaction()
            .addPendingAirdrop(txnRecord.pendingAirdropRecords.get(0).getPendingAirdropId())
            .freezeWith(client)
            .sign(privateKey2)
            .execute(client)
            .getReceipt(client);

        bobBalance = new AccountBalanceQuery()
            .setAccountId(bob)
            .execute(client);
        System.out.println("Bob nft balance after claim: " + bobBalance.tokens.get(nftID));

        /*
         * Step 11:
         * Cancel the airdrop for carol
         */
        System.out.println("Canceling nft for Carol");
        new TokenCancelAirdropTransaction()
            .addPendingAirdrop(txnRecord.pendingAirdropRecords.get(1).getPendingAirdropId())
            .freezeWith(client)
            .sign(treasuryKey)
            .execute(client)
            .getReceipt(client);

        carolBalance = new AccountBalanceQuery()
            .setAccountId(carol)
            .execute(client);
        System.out.println("Carol nft balance after cancel: " + carolBalance.tokens.get(nftID));

        /*
         * Step 12:
         * Reject the NFT for bob
         */
        System.out.println("Rejecting nft with Bob");
        new TokenRejectTransaction()
            .setOwnerId(bob)
            .addNftId(nftID.nft(2))
            .freezeWith(client)
            .sign(privateKey2)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 13:
         * Query to verify bob no longer has the NFT
         */
        bobBalance = new AccountBalanceQuery()
            .setAccountId(bob)
            .execute(client);
        System.out.println("Bob nft balance after reject: " + bobBalance.tokens.get(nftID));

        /*
         * Step 13:
         * Query to verify the NFT was returned to the Treasury
         */
        var treasuryBalance = new AccountBalanceQuery()
            .setAccountId(treasuryAccount)
            .execute(client);
        System.out.println("Treasury nft balance after reject: " + treasuryBalance.tokens.get(nftID));

        /*
         * Step 14:
         * Reject the fungible tokens for Carol
         */
        System.out.println("Rejecting ft with Carol");
        new TokenRejectTransaction()
            .setOwnerId(carol)
            .addTokenId(tokenID)
            .freezeWith(client)
            .sign(privateKey3)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 14:
         * Query to verify carol no longer has the fungible tokens
         */
        carolBalance = new AccountBalanceQuery()
            .setAccountId(carol)
            .execute(client);
        System.out.println("Carol ft balance after reject: " + carolBalance.tokens.get(tokenID));

        /*
         * Step 15:
         * Query to verify Treasury received the rejected fungible tokens
         */
        treasuryBalance = new AccountBalanceQuery()
            .setAccountId(treasuryAccount)
            .execute(client);
        System.out.println("Treasury ft balance after reject: " + treasuryBalance.tokens.get(tokenID));

        /*
         * Clean up:
         */
        client.close();

        System.out.println("Example Complete!");
    }

    private static List<byte[]> generateNftMetadata(byte metadataCount) {
        List<byte[]> metadatas = new ArrayList<>();

        for (byte i = 0; i < metadataCount; i++) {
            byte[] md = {i};
            metadatas.add(md);
        }

        return metadatas;
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TokenMetadataExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Arrays;
import java.util.Objects;

/**
 * How to set and update token's metadata.
 * <p>
 * HIP-646: Fungible Token Metadata Field.
 * Addition of the metadata field to Fungible Tokens (FT),
 * taking after the Non-Fungible Token (NFT) metadata field which was added in HIP-17.
 * <p>
 * HIP-765: NFT Collection Token Metadata Field
 * Addition of the metadata field to Non-Fungible Token Class,
 * taking after the individual Non-Fungible Token (NFT) metadata field, which was added in HIP-17.
 */
public class TokenMetadataExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Token Metadata (HIP-646 and HIP-765) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        PrivateKey adminPrivateKey = PrivateKey.generateED25519();
        PublicKey adminPublicKey = adminPrivateKey.getPublicKey();

        PrivateKey metadataPrivateKey = PrivateKey.generateED25519();
        PublicKey metadataPublicKey = metadataPrivateKey.getPublicKey();

        /*
         * Step 2:
         * The beginning of the first example (mutable token's metadata).
         *
         * Create a mutable fungible token with a metadata, but without a Metadata Key.
         */
        System.out.println("The beginning of the first example (mutable token's metadata).");
        byte[] initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};

        System.out.println("Creating mutable Fungible Token using the Hedera Token Service...");
        var mutableFungibleTokenId = new TokenCreateTransaction()
            .setTokenName("HIP-646 Mutable FT")
            .setTokenSymbol("HIP646MFT")
            .setTokenMetadata(initialTokenMetadata)
            // The same flow can be executed with a TokenType.NON_FUNGIBLE_UNIQUE (i.e. HIP-765).
            .setTokenType(TokenType.FUNGIBLE_COMMON)
            .setTreasuryAccountId(OPERATOR_ID)
            .setDecimals(3)
            .setInitialSupply(1_000_000)
            .setAdminKey(adminPublicKey)
            .freezeWith(client)
            .sign(adminPrivateKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;
        Objects.requireNonNull(mutableFungibleTokenId);
        System.out.println("Created mutable Fungible Token with ID: " + mutableFungibleTokenId);

        /*
         * Step 3:
         * Query and output mutable Fungible Token info after its creation.
         */
        var mutableFungibleTokenInfo_AfterCreation = new TokenInfoQuery()
            .setTokenId(mutableFungibleTokenId)
            .execute(client);

        // Check that metadata was set correctly.
        if (Arrays.equals(mutableFungibleTokenInfo_AfterCreation.metadata, initialTokenMetadata)) {
            System.out.println("Mutable Fungible Token metadata after creation: "
                + Arrays.toString(mutableFungibleTokenInfo_AfterCreation.metadata));
        } else {
            throw new Exception("Mutable Fungible Token metadata was not set correctly! (Fail)");
        }

        /*
         * Step 4:
         * Update mutable Fungible Token metadata.
         */
        byte[] updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};
        System.out.println("Updating mutable Fungible Token metadata...");
        new TokenUpdateTransaction()
            .setTokenId(mutableFungibleTokenId)
            .setTokenMetadata(updatedTokenMetadata)
            .freezeWith(client)
            .sign(adminPrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 5:
         * Query and output mutable Fungible Token info after its metadata was updated.
         */
        var mutableFungibleTokenInfo_AfterMetadataUpdate = new TokenInfoQuery()
            .setTokenId(mutableFungibleTokenId)
            .execute(client);

        // Check that metadata was updated correctly.
        if (Arrays.equals(mutableFungibleTokenInfo_AfterMetadataUpdate.metadata, updatedTokenMetadata)) {
            System.out.println("Mutable Fungible Token metadata after update: "
                + Arrays.toString(mutableFungibleTokenInfo_AfterMetadataUpdate.metadata));
        } else {
            throw new Exception("Mutable Fungible Token metadata was not updated correctly! (Fail)");
        }

        /*
         * Step 6:
         * The beginning of the second example (immutable token's metadata).
         *
         * Create an immutable Fungible Token with a metadata key and a metadata.
         */
        System.out.println("The beginning of the second example (immutable token's metadata).");

        System.out.println("Creating immutable Fungible Token using the Hedera Token Service...");
        var immutableFungibleTokenId = new TokenCreateTransaction()
            .setTokenName("HIP-646 Immutable FT")
            .setTokenSymbol("HIP646IMMFT")
            .setTokenMetadata(initialTokenMetadata)
            // The same flow can be executed with a TokenType.NON_FUNGIBLE_UNIQUE (i.e. HIP-765).
            .setTokenType(TokenType.FUNGIBLE_COMMON)
            .setTreasuryAccountId(OPERATOR_ID)
            .setMetadataKey(metadataPublicKey)
            .setDecimals(3)
            .setInitialSupply(1_000_000)
            .execute(client)
            .getReceipt(client)
            .tokenId;
        Objects.requireNonNull(immutableFungibleTokenId);
        System.out.println("Created an immutable Fungible Token with ID: " + immutableFungibleTokenId);

        /*
         * Step 7:
         * Query and output immutable Fungible Token info after its creation.
         */
        var immutableFungibleTokenTokenInfo_AfterCreation = new TokenInfoQuery()
            .setTokenId(immutableFungibleTokenId)
            .execute(client);

        // Check that metadata was set correctly.
        if (Arrays.equals(immutableFungibleTokenTokenInfo_AfterCreation.metadata, initialTokenMetadata)) {
            System.out.println("Immutable Fungible Token metadata after creation: "
                + Arrays.toString(immutableFungibleTokenTokenInfo_AfterCreation.metadata));
        } else {
            throw new Exception("Immutable Fungible Token metadata was not set correctly! (Fail)");
        }

        /*
         * Step 8:
         * Update immutable Fungible Token metadata.
         */
        System.out.println("Updating immutable Fungible Token metadata...");
        new TokenUpdateTransaction()
            .setTokenId(immutableFungibleTokenId)
            .setTokenMetadata(updatedTokenMetadata)
            .freezeWith(client)
            .sign(metadataPrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 5:
         * Query and output immutable Fungible Token info after its metadata was updated.
         */
        var immutableFungibleTokenInfo_AfterMetadataUpdate = new TokenInfoQuery()
            .setTokenId(immutableFungibleTokenId)
            .execute(client);

        // Check that metadata was updated correctly.
        if (Arrays.equals(immutableFungibleTokenInfo_AfterMetadataUpdate.metadata, updatedTokenMetadata)) {
            System.out.println("Immutable Fungible Token metadata after update: "
                + Arrays.toString(immutableFungibleTokenInfo_AfterMetadataUpdate.metadata));
        } else {
            throw new Exception("Immutable Fungible Token metadata was not updated correctly! (Fail)");
        }

        /*
         * Clean up:
         * Delete created mutable token.
         */
        new TokenDeleteTransaction()
            .setTokenId(mutableFungibleTokenId)
            .freezeWith(client)
            .sign(adminPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Token Metadata (HIP-646 and HIP-765) Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TokenRejectExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * How to reject a token (part of HIP-904).
 */
class TokenRejectExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Token Reject (HIP-904) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey treasuryAccountPrivateKey = PrivateKey.generateED25519();
        PublicKey treasuryAccountPublicKey = treasuryAccountPrivateKey.getPublicKey();
        PrivateKey receiverAccountPrivateKey = PrivateKey.generateED25519();
        PublicKey receiverAccountPublicKey = receiverAccountPrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create accounts for this example.
         */
        System.out.println("Creating treasury and receiver accounts...");
        // Create a treasury account.
        var treasuryAccountId = new AccountCreateTransaction()
            .setKey(treasuryAccountPublicKey)
            .setMaxAutomaticTokenAssociations(100)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(treasuryAccountId);

        // Create a receiver account with unlimited max auto associations (-1).
        var receiverAccountId = new AccountCreateTransaction()
            .setKey(receiverAccountPublicKey)
            .setMaxAutomaticTokenAssociations(-1)
            .freezeWith(client)
            .sign(receiverAccountPrivateKey)
            .execute(client)
            .getReceipt(client)
            .accountId;
        Objects.requireNonNull(receiverAccountId);

        /*
         * Step 3:
         * Create tokens for this example.
         */
        System.out.println("Creating FT and NFT...");
        // Create a Fungible Token.
        final int FUNGIBLE_TOKEN_SUPPLY = 1_000_000;
        TokenId fungibleTokenId = new TokenCreateTransaction()
            .setTokenName("HIP-904 FT")
            .setTokenSymbol("HIP904FT")
            .setDecimals(0)
            .setInitialSupply(FUNGIBLE_TOKEN_SUPPLY)
            .setMaxSupply(FUNGIBLE_TOKEN_SUPPLY)
            .setTreasuryAccountId(treasuryAccountId)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(treasuryAccountPublicKey)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;
        Objects.requireNonNull(fungibleTokenId);

        // Create NFT.
        TokenId nftId = new TokenCreateTransaction()
            .setTokenName("HIP-904 NFT")
            .setTokenSymbol("HIP904NFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setTreasuryAccountId(treasuryAccountId)
            .setSupplyType(TokenSupplyType.FINITE)
            .setMaxSupply(3)
            .setAdminKey(treasuryAccountPublicKey)
            .setSupplyKey(treasuryAccountPublicKey)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client)
            .tokenId;
        Objects.requireNonNull(nftId);

        /*
         * Step 4:
         * Mint three NFTs.
         */
        System.out.println("Minting three NFTs...");
        var tokenMintTxReceipt = new TokenMintTransaction()
            .setTokenId(nftId)
            .setMetadata(generateNftMetadata((byte) 3))
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client);
        var nftSerials = tokenMintTxReceipt.serials;

        /*
         * Step 5:
         * Transfer tokens to the receiver.
         */
        System.out.println("Transferring tokens to the receiver...");
        new TransferTransaction()
            .addTokenTransfer(fungibleTokenId, treasuryAccountId, -1_000)
            .addTokenTransfer(fungibleTokenId, receiverAccountId, 1_000)
            .addNftTransfer(nftId.nft(nftSerials.get(0)), treasuryAccountId, receiverAccountId)
            .addNftTransfer(nftId.nft(nftSerials.get(1)), treasuryAccountId, receiverAccountId)
            .addNftTransfer(nftId.nft(nftSerials.get(2)), treasuryAccountId, receiverAccountId)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 6:
         * Check receiver account balance.
         */
        var receiverAccountBalance = new AccountBalanceQuery()
            .setAccountId(receiverAccountId)
            .execute(client);

        if (receiverAccountBalance.tokens.get(fungibleTokenId) == 1_000) {
            System.out.println("Receiver account has: " + receiverAccountBalance.tokens.get(fungibleTokenId) + " example fungible tokens.");
        } else {
            throw new Exception("Failed to transfer Fungible Token to the receiver account!");
        }

        if (receiverAccountBalance.tokens.get(nftId) == 3) {
            System.out.println("Receiver account has: " + receiverAccountBalance.tokens.get(nftId) + " example NFTs.");
        } else {
            throw new Exception("Failed to transfer NFT to the receiver account!");
        }

        /*
         * Step 7:
         * Reject the fungible token.
         */
        System.out.println("Receiver rejects example fungible tokens...");
        new TokenRejectTransaction()
            .setOwnerId(receiverAccountId)
            .addTokenId(fungibleTokenId)
            .freezeWith(client)
            .sign(receiverAccountPrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 8:
         * Execute the token reject flow -- reject NFTs.
         */
        System.out.println("Receiver rejects example NFTs...");
        new TokenRejectFlow()
            .setOwnerId(receiverAccountId)
            .setNftIds(List.of(
                nftId.nft(nftSerials.get(0)),
                nftId.nft(nftSerials.get(1)),
                nftId.nft(nftSerials.get(2))
            ))
            .freezeWith(client)
            .sign(receiverAccountPrivateKey)
            .execute(client)
            .getReceipt(client);

        /*
         * Step 9:
         * Check receiver account balance after token reject.
         */
        var receiverAccountBalance_AfterTokenReject = new AccountBalanceQuery()
            .setAccountId(receiverAccountId)
            .execute(client);

        if (receiverAccountBalance_AfterTokenReject.tokens.get(fungibleTokenId) == 0) {
            System.out.println("Receiver account has (after rejecting tokens): "
                + receiverAccountBalance_AfterTokenReject.tokens.get(fungibleTokenId) + " example fungible tokens.");
        } else {
            throw new Exception("Failed to reject Fungible Token!");
        }

        if (receiverAccountBalance_AfterTokenReject.tokens.get(nftId) == null) {
            System.out.println("Receiver account has (after rejecting tokens): "
                + receiverAccountBalance_AfterTokenReject.tokens.get(nftId) + " example NFTs.");
        } else {
            throw new Exception("Failed to reject NFT!");
        }

        /*
         * Step 10:
         * Check treasury account balance after token reject.
         */
        var treasuryAccountBalance = new AccountBalanceQuery()
            .setAccountId(treasuryAccountId)
            .execute(client);

        if (treasuryAccountBalance.tokens.get(fungibleTokenId) == FUNGIBLE_TOKEN_SUPPLY) {
            System.out.println("Treasury account has: " + treasuryAccountBalance.tokens.get(fungibleTokenId)
                + " example fungible tokens.");
        } else {
            throw new Exception("Failed to transfer Fungible Token to the treasury account during token rejection!");
        }

        if (treasuryAccountBalance.tokens.get(nftId) == 3) {
            System.out.println("Receiver account has: " + receiverAccountBalance.tokens.get(nftId)
                + " example NFTs.");
        } else {
            throw new Exception("Failed to transfer NFT to the treasury account during token rejection!");
        }

        /*
         * Clean up:
         * Delete created accounts and tokens.
         */
        new AccountDeleteTransaction()
            .setAccountId(treasuryAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client);

        new AccountDeleteTransaction()
            .setAccountId(receiverAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(receiverAccountPrivateKey)
            .execute(client);

        new TokenDeleteTransaction()
            .setTokenId(fungibleTokenId)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setTokenId(nftId)
            .freezeWith(client)
            .sign(treasuryAccountPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Token Reject (HIP-904) Example Complete!");
    }

    private static List<byte[]> generateNftMetadata(byte metadataCount) {
        List<byte[]> metadatas = new ArrayList<>();

        for (byte i = 0; i < metadataCount; i++) {
            byte[] md = {i};
            metadatas.add(md);
        }

        return metadatas;
    }

}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TopicWithAdminKeyExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Arrays;
import java.util.Collections;
import java.util.Objects;

/**
 * How to create and manage HCS topic using a threshold key as the adminKey and going through a key rotation to a new
 * set of keys.
 * <p>
 * Create a new HCS topic with a 2-of-3 threshold key for the Admin Key and
 * update the HCS topic to a 3-of-4 threshold key for the adminKey.
 */
class TopicWithAdminKeyExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Topic With Admin (Threshold) Key Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Generate the initial key pairs that are part of the Admin Key's Threshold Key.
         *
         * Three ED25519 keys part of a 2-of-3 threshold key.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey[] initialAdminPrivateKeys = new PrivateKey[3];
        PublicKey[] initialAdminPublicKeys = new PublicKey[3];
        Arrays.setAll(initialAdminPrivateKeys, i -> PrivateKey.generate());
        Arrays.setAll(initialAdminPublicKeys, i -> initialAdminPrivateKeys[i].getPublicKey());

        /*
         * Step 2:
         * Create the Threshold Key.
         */
        System.out.println("Creating a Key List (threshold key)...");
        KeyList thresholdKey = KeyList.withThreshold(2);
        Collections.addAll(thresholdKey, initialAdminPublicKeys);
        System.out.println("Created a Key List: " + thresholdKey);

        /*
         * Step 3:
         * Create the topic create transaction with Threshold Key.
         */
        System.out.println("Creating topic create transaction...");
        Transaction<?> topicCreateTx = new TopicCreateTransaction()
            .setTopicMemo("demo topic")
            .setAdminKey(thresholdKey)
            .freezeWith(client);

        /*
         * Step 4:
         * Sign the topic create transaction with 2 of 3 keys that are part of the Admin Key Threshold Key.
         */
        Arrays.stream(initialAdminPrivateKeys, 0, 2).forEach(k -> {
            System.out.println("Signing topic create transaction with key " + k);
            topicCreateTx.sign(k);
        });

        /*
         * Step 5:
         * Execute the topic create transaction.
         */
        TransactionResponse topicCreateTxResponse = topicCreateTx.execute(client);
        TopicId hederaTopicId = topicCreateTxResponse.getReceipt(client).topicId;
        Objects.requireNonNull(hederaTopicId);
        System.out.println("Created new topic (" + hederaTopicId + ") with 2-of-3 threshold key as admin key.");

        /*
         * Step 6:
         * Generate the new key pairs that are part of the Admin Key's Threshold Key.
         *
         * Four ED25519 keys part of a 3-of-4 threshold key.
         */
        System.out.println("Generating new ED25519 key pairs...");
        PrivateKey[] newAdminKeys = new PrivateKey[4];
        PublicKey[] newAdminPublicKeys = new PublicKey[4];
        Arrays.setAll(newAdminKeys, i -> PrivateKey.generate());
        Arrays.setAll(newAdminPublicKeys, i -> newAdminKeys[i].getPublicKey());

        /*
         * Step 7:
         * Create the new threshold key.
         */
        System.out.println("Creating new Key List (threshold key)...");
        KeyList newThresholdKey = KeyList.withThreshold(3);
        Collections.addAll(newThresholdKey, newAdminPublicKeys);
        System.out.println("Created new Key List: " + thresholdKey);

        /*
         * Step 8:
         * Create the topic update transaction with the new threshold key.
         */
        System.out.println("Creating topic update transaction...");
        Transaction<?> topicUpdateTx = new TopicUpdateTransaction()
            .setTopicId(hederaTopicId)
            .setTopicMemo("This topic will be updated")
            .setAdminKey(newThresholdKey)
            .freezeWith(client);

        /*
         * Step 9:
         * Sign the topic update transaction with the initial Admin Key.
         *
         * 2 of the 3 keys already part of the topic's Admin Key.
         */
        Arrays.stream(initialAdminPrivateKeys, 0, 2).forEach(k -> {
            System.out.println("Signing topic update transaction with initial admin key " + k);
            topicUpdateTx.sign(k);
        });

        /*
         * Step 9:
         * Sign the topic update transaction with the new Admin Key.
         * 3 of 4 keys already part of the topic's Admin Key.
         */
        Arrays.stream(newAdminKeys, 0, 3).forEach(k -> {
            System.out.println("Signing topic update transaction with new admin key " + k);
            topicUpdateTx.sign(k);
        });

        /*
         * Step 10:
         * Execute the topic update transaction.
         */
        TransactionResponse topicUpdateTxResponse = topicUpdateTx.execute(client);

        // Retrieve results post-consensus.
        topicUpdateTxResponse.getReceipt(client);
        System.out.println("Updated topic (" + hederaTopicId + ") with 3-of-4 threshold key as admin key.");

        /*
         * Step 11:
         * Query the topic info and output it.
         */
        TopicInfo hederaTopicInfo = new TopicInfoQuery()
            .setTopicId(hederaTopicId)
            .execute(client);
        System.out.println("Topic info: " + hederaTopicInfo);

        /*
         * Clean up:
         * Delete created topic.
         */
        var topicDeleteTransaction = new TopicDeleteTransaction()
            .setTopicId(hederaTopicId)
            .freezeWith(client);

        Arrays.stream(newAdminKeys, 0, 3).forEach(k -> {
            topicDeleteTransaction.sign(k);
        });

        topicDeleteTransaction.execute(client).getReceipt(client);

        client.close();

        System.out.println("Topic With Admin (Threshold) Key Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TransactionSerializationExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to serialize incomplete transaction, deserialize it, complete and execute (HIP-745).
 */
class TransactionSerializationExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Transaction Serialization (HIP-745) Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Check Hbar balance of sender and recipient.
         */
        AccountId recipientId = AccountId.fromString("0.0.3");
        Hbar senderBalanceBefore = new AccountBalanceQuery()
            .setAccountId(OPERATOR_ID)
            .execute(client)
            .hbars;

        Hbar recipientBalanceBefore = new AccountBalanceQuery()
            .setAccountId(recipientId)
            .execute(client)
            .hbars;

        System.out.println("Sender (" + OPERATOR_ID + ") balance before transfer: " + senderBalanceBefore);
        System.out.println("Recipient (" + recipientId + ") balance before transfer: " + recipientBalanceBefore);

        /*
         * Step 2:
         * Create the transfer transaction with adding only Hbar transfer which credits the operator.
         */
        System.out.println("Creating the transfer transaction...");
        Hbar transferAmount = Hbar.from(1);
        var transferTx = new TransferTransaction()
            // addSender and addRecipient can be called as many times as you want as long as the total sum from
            // both sides is equivalent.
            .addHbarTransfer(OPERATOR_ID, transferAmount.negated());

        /*
         * Step 3:
         * Serialize the transfer transaction.
         */
        System.out.println("Serializing the transfer transaction...");
        var transactionBytes = transferTx.toBytes();

        /*
         * Step 4:
         * Deserialize the transfer transaction.
         */
        System.out.println("Deserializing the transfer transaction...");
        TransferTransaction transferTxDeserialized = (TransferTransaction) Transaction.fromBytes(transactionBytes);

        /*
         * Step 5:
         * Complete the transfer transaction-- add Hbar transfer which debits Hbar to the recipient.
         * And execute the transfer transaction.
         */
        System.out.println("Completing and executing the transfer transaction...");
        var transferTxResponse = transferTxDeserialized
            .addHbarTransfer(recipientId, transferAmount)
            .setTransactionMemo("HIP-745 example")
            .execute(client);

        System.out.println("Transaction info: " + transferTxResponse);
        TransactionRecord transferTxRecord = transferTxResponse.getRecord(client);
        System.out.println("Transferred " + transferAmount);
        System.out.println("Transfer memo: " + transferTxRecord.transactionMemo);

        /*
         * Step 6:
         * Check Hbar balance of the sender and recipient after transfer transaction was executed.
         */
        Hbar senderBalanceAfter = new AccountBalanceQuery()
            .setAccountId(OPERATOR_ID)
            .execute(client)
            .hbars;

        Hbar receiptBalanceAfter = new AccountBalanceQuery()
            .setAccountId(recipientId)
            .execute(client)
            .hbars;

        System.out.println("Sender (" + OPERATOR_ID + ") balance after transfer: " + senderBalanceAfter);
        System.out.println("Recipient (" + recipientId + ") balance after transfer: " + receiptBalanceAfter);

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Example complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TransferCryptoExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to transfer Hbar between accounts.
 */
class TransferCryptoExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Transfer Crypto Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        AccountId recipientId = AccountId.fromString("0.0.3");

        /*
         * Step 1:
         * Check Hbar balance of sender and recipient.
         */
        Hbar senderBalanceBefore = new AccountBalanceQuery()
            .setAccountId(OPERATOR_ID)
            .execute(client)
            .hbars;

        Hbar recipientBalanceBefore = new AccountBalanceQuery()
            .setAccountId(recipientId)
            .execute(client)
            .hbars;

        System.out.println("Sender (" + OPERATOR_ID + ") balance before transfer: " + senderBalanceBefore);
        System.out.println("Recipient (" + recipientId + ") balance before transfer: " + recipientBalanceBefore);

        /*
         * Step 2:
         * Execute the transfer transaction to send Hbars from operator to the recipient.
         */
        System.out.println("Executing the transfer transaction...");
        Hbar transferAmount = Hbar.from(1);
        TransactionResponse transferTxResponse = new TransferTransaction()
            // addSender and addRecipient can be called as many times as you want as long as the total sum from
            // both sides is equivalent.
            .addHbarTransfer(OPERATOR_ID, transferAmount.negated())
            .addHbarTransfer(recipientId, transferAmount)
            .setTransactionMemo("Transfer example")
            .execute(client);

        System.out.println("Transaction info: " + transferTxResponse);
        TransactionRecord record = transferTxResponse.getRecord(client);
        System.out.println("Transferred " + transferAmount);
        System.out.println("Transfer memo: " + record.transactionMemo);

        /*
         * Step 6:
         * Check Hbar balance of the sender and recipient after transfer transaction was executed.
         */
        Hbar senderBalanceAfter = new AccountBalanceQuery()
            .setAccountId(OPERATOR_ID)
            .execute(client)
            .hbars;

        Hbar receiptBalanceAfter = new AccountBalanceQuery()
            .setAccountId(recipientId)
            .execute(client)
            .hbars;

        System.out.println("Sender (" + OPERATOR_ID + ") balance after transfer: " + senderBalanceAfter);
        System.out.println("Recipient (" + recipientId + ") balance after transfer: " + receiptBalanceAfter);

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Example complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TransferTokensExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * How to transfer tokens between accounts.
 */
class TransferTokensExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Transfer Tokens Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        PublicKey operatorPublicKey = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs for accounts...");
        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();
        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create two new accounts.
         */
        System.out.println("Creating accounts...");
        Hbar initialBalance = Hbar.from(1);
        TransactionResponse aliceAccountCreateTxResponse = new AccountCreateTransaction()
            // The only required property here is key.
            .setKey(alicePublicKey)
            .setInitialBalance(initialBalance)
            .execute(client);

        // This will wait for the receipt to become available.
        TransactionReceipt aliceAccountCreateTxReceipt = aliceAccountCreateTxResponse.getReceipt(client);
        AccountId aliceAccountId = Objects.requireNonNull(aliceAccountCreateTxReceipt.accountId);
        Objects.requireNonNull(aliceAccountId);
        System.out.println("Created Alice's account with ID: " + aliceAccountId);

        TransactionResponse bobAccountCreateTxResponse = new AccountCreateTransaction()
            // The only required property here is key.
            .setKey(bobPublicKey)
            .setInitialBalance(initialBalance)
            .execute(client);

        // This will wait for the receipt to become available.
        TransactionReceipt bobAccountCreateTxReceipt = bobAccountCreateTxResponse.getReceipt(client);
        AccountId bobAccountId = Objects.requireNonNull(bobAccountCreateTxReceipt.accountId);
        Objects.requireNonNull(bobAccountId);
        System.out.println("Created Bob's account with ID: " + bobAccountId);

        /*
         * Step 3:
         * Create a Fungible Token.
         */
        System.out.println("Creating Fungible Token...");
        TransactionResponse tokenCreateTxResponse = new TokenCreateTransaction()
            .setNodeAccountIds(Collections.singletonList(bobAccountCreateTxResponse.nodeId))
            .setTokenName("Example Fungible Token for Transfer demo")
            .setTokenSymbol("EFT")
            .setDecimals(3)
            .setInitialSupply(1_000_000)
            .setTreasuryAccountId(OPERATOR_ID)
            .setAdminKey(operatorPublicKey)
            .setFreezeKey(operatorPublicKey)
            .setWipeKey(operatorPublicKey)
            .setKycKey(operatorPublicKey)
            .setSupplyKey(operatorPublicKey)
            .setFreezeDefault(false)
            .execute(client);

        TokenId tokenId = Objects.requireNonNull(tokenCreateTxResponse.getReceipt(client).tokenId);
        Objects.requireNonNull(tokenId);
        System.out.println("Created Fungible Token with ID: " + tokenId);

        /*
         * Step 4:
         * Associate the token with created accounts.
         */
        System.out.println("Associating the token with created accounts...");
        new TokenAssociateTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .setAccountId(aliceAccountId)
            .setTokenIds(Collections.singletonList(tokenId))
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Associated account " + aliceAccountId + " with token " + tokenId);

        new TokenAssociateTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .setAccountId(bobAccountId)
            .setTokenIds(Collections.singletonList(tokenId))
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Associated account " + bobAccountId + " with token " + tokenId);

        /*
         * Step 5:
         * Grant token KYC for created accounts.
         */
        System.out.println("Granting token KYC for created accounts...");
        new TokenGrantKycTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .setAccountId(aliceAccountId)
            .setTokenId(tokenId)
            .execute(client)
            .getReceipt(client);

        System.out.println("Granted KYC for account " + aliceAccountId + " on token " + tokenId);

        new TokenGrantKycTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .setAccountId(bobAccountId)
            .setTokenId(tokenId)
            .execute(client)
            .getReceipt(client);

        System.out.println("Granted KYC for account " + bobAccountId + " on token " + tokenId);

        /*
         * Step 6:
         * Transfer tokens from the operator (treasury) to Alice's account.
         */
        System.out.println("Transferring tokens from operator's (treasury) account to the `accountId1`...");
        new TransferTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .addTokenTransfer(tokenId, OPERATOR_ID, -10)
            .addTokenTransfer(tokenId, aliceAccountId, 10)
            .execute(client)
            .getReceipt(client);

        System.out.println("Sent 10 tokens from account " + OPERATOR_ID + " to account " + aliceAccountId + " on token " + tokenId);

        /*
         * Step 6:
         * Transfer 10 tokens from the Alice to Bob.
         */
        System.out.println("Transferring tokens from the `accountId1` to the `accountId2`...");
        new TransferTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .addTokenTransfer(tokenId, aliceAccountId, -10)
            .addTokenTransfer(tokenId, bobAccountId, 10)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Sent 10 tokens from account " + aliceAccountId + " to account " + bobAccountId + " on token " + tokenId);

        /*
         * Step 6:
         * Transfer 10 tokens from Bob to Alice.
         */
        System.out.println("Transferring tokens from the `accountId2` to the `accountId1`...");
        new TransferTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .addTokenTransfer(tokenId, bobAccountId, -10)
            .addTokenTransfer(tokenId, aliceAccountId, 10)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        System.out.println("Sent 10 tokens from account " + bobAccountId + " to account " + aliceAccountId + " on token " + tokenId);

        /*
         * Clean up:
         * Delete created accounts and tokens.
         */
        new TokenWipeTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .setTokenId(tokenId)
            .setAccountId(aliceAccountId)
            .setAmount(10)
            .execute(client)
            .getReceipt(client);

        new TokenDeleteTransaction()
            .setNodeAccountIds(Collections.singletonList(tokenCreateTxResponse.nodeId))
            .setTokenId(tokenId)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(aliceAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(bobAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(OPERATOR_KEY)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Example complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/TransferUsingEvmAddressExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to transfer Hbar or tokens to a Hedera account using their public-address (HIP-583).
 */
class TransferUsingEvmAddressExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Transfer Using Evm Address Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Create an ECSDA private key.
         */
        PrivateKey alicePrivateKey = PrivateKey.generateECDSA();

        /*
         * Step 2:
         * Extract the ECDSA public key.
         */
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();

        /*
         * Step 3:
         * Extract the Ethereum public address.
         */
        EvmAddress aliceEvmAddress = alicePublicKey.toEvmAddress();
        System.out.println("EVM address of Alice's account: " + aliceEvmAddress);

        /*
         * Step 4:
         * Transfer tokens using the TransferTransaction to the Ethereum Account Address.
         * - the from field should be a complete account that has a public address;
         * - the to field should be to a public address (to create a new account).
         */
        System.out.println("Transferring Hbar to Alice's account...");
        TransferTransaction transferTx = new TransferTransaction()
            .addHbarTransfer(OPERATOR_ID, Hbar.from(1).negated())
            .addHbarTransfer(aliceEvmAddress, Hbar.from(1))
            .freezeWith(client);

        TransferTransaction transferTxSigned = transferTx.sign(OPERATOR_KEY);
        TransactionResponse transferTxResponse = transferTxSigned.execute(client);

        /*
         * Step 5:
         * Get the child receipt or child record to return the Hedera Account ID for the new account that was created.
         */
        TransactionReceipt transferTxReceipt = new TransactionReceiptQuery()
            .setTransactionId(transferTxResponse.transactionId)
            .setIncludeChildren(true)
            .execute(client);

        AccountId aliceAccountId = transferTxReceipt.children.get(0).accountId;
        Objects.requireNonNull(aliceAccountId);
        System.out.println("The \"normal\" account ID of the given alias: " + aliceAccountId);

        /*
         * Step 6:
         * Get the AccountInfo on the new account and show it is a hollow account by not having a public key.
         */
        AccountInfo aliceAccountInfo_BeforeEnhancing = new AccountInfoQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        System.out.println("Alice's account info: " + aliceAccountInfo_BeforeEnhancing);

        /*
         * Step 7:
         * Use the hollow account as a transaction fee payer in a HAPI transaction.
         */
        System.out.println("Setting new account as client's operator...");
        client.setOperator(aliceAccountId, alicePrivateKey);
        PrivateKey bobPrivateKey = PrivateKey.generateED25519();
        PublicKey bobPublicKey = bobPrivateKey.getPublicKey();

        System.out.println("Creating Bob's account...");
        AccountCreateTransaction accountCreateTx = new AccountCreateTransaction()
            .setKey(bobPublicKey)
            .freezeWith(client);

        /*
         * Step 8:
         * Sign the transaction with ECDSA private key.
         */
        AccountCreateTransaction accountCreateTxSigned = accountCreateTx.sign(alicePrivateKey);
        TransactionResponse accountCreateTxResponse = accountCreateTxSigned.execute(client);
        TransactionReceipt accountCreateTxReceipt = accountCreateTxResponse.getReceipt(client);
        var bobAccountId = accountCreateTxReceipt.accountId;
        Objects.requireNonNull(bobAccountId);
        System.out.println("Created Bob's account with ID: " + bobAccountId);

        /*
         * Step 9:
         * Get the AccountInfo of the account and show the account is now a complete account
         * by returning the public key on the account.
         */
        AccountInfo aliceAccountInfo_AfterEnhancing = new AccountInfoQuery()
            .setAccountId(aliceAccountId)
            .execute(client);

        System.out.println("The public key of the newly created (and now complete) account: " + aliceAccountInfo_AfterEnhancing.key);

        /*
         * Clean up:
         * Delete created accounts.
         */
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);

        new AccountDeleteTransaction()
            .setAccountId(aliceAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        new AccountDeleteTransaction()
            .setAccountId(bobAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(bobPrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Transfer Using Evm Address Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/UpdateAccountPublicKeyExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Objects;

/**
 * How to update account's key.
 */
class UpdateAccountPublicKeyExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Update Account Public Key Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        client.setDefaultMaxTransactionFee(Hbar.from(10));

        /*
         * Step 1:
         * Generate ED25519 key pairs.
         */
        System.out.println("Generating ED25519 key pairs...");
        PrivateKey privateKey1 = PrivateKey.generateED25519();
        PublicKey publicKey1 = privateKey1.getPublicKey();
        PrivateKey privateKey2 = PrivateKey.generateED25519();
        PublicKey publicKey2 = privateKey2.getPublicKey();

        /*
         * Step 2:
         * Create a new account.
         */
        System.out.println("Creating new account...");
        TransactionResponse accountCreateTxResponse = new AccountCreateTransaction()
            .setKey(publicKey1)
            .setInitialBalance(Hbar.from(1))
            .execute(client);

        AccountId accountId = Objects.requireNonNull(accountCreateTxResponse.getReceipt(client).accountId);
        Objects.requireNonNull(accountId);
        System.out.println("Created new account with ID: " + accountId + " and public key: " + publicKey1);

        /*
         * Step 2:
         * Update account's key.
         */
        System.out.println("Updating public key of new account...(Setting key: " + publicKey2 + ").");
        TransactionResponse accountUpdateTxResponse = new AccountUpdateTransaction()
            .setAccountId(accountId)
            .setKey(publicKey2)
            .freezeWith(client)
            // Sign with the previous key and the new key.
            .sign(privateKey1)
            .sign(privateKey2)
            // Execute will implicitly sign with the operator.
            .execute(client);

        // (Important!) Wait for the transaction to complete by querying the receipt.
        accountUpdateTxResponse.getReceipt(client);

        /*
         * Step 3:
         * Get account info to confirm the key was changed.
         */
        AccountInfo accountInfo = new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(client);

        System.out.println("New account public key: " + accountInfo.key);

        /*
         * Clean up:
         * Delete created account.
         */
        new AccountDeleteTransaction()
            .setAccountId(accountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(privateKey2)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Update Account Public Key Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/UpdateNftsMetadataExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * How to update NFTs' metadata (HIP-657).
 */
class UpdateNftsMetadataExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Update Nfts Metadata Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        PublicKey operatorKeyPublic = OPERATOR_KEY.getPublicKey();

        /*
         * Step 1:
         * Generate ED25519 key pair (Metadata Key).
         */
        System.out.println("Generating ED25519 key pair...(metadata key).");
        PrivateKey metadataPrivateKey = PrivateKey.generateED25519();
        PublicKey metadataPublicKey = metadataPrivateKey.getPublicKey();

        /*
         * Step 2:
         * The beginning of the first example (mutable token's metadata).
         *
         * Create a non-fungible token (NFT) with the metadata key field set.
         */
        System.out.println("The beginning of the first example (mutable token's metadata).");
        byte[] initialMetadata = new byte[]{1};
        System.out.println("Creating mutable NFT with the metadata key field set...");
        var mutableNftCreateTx = new TokenCreateTransaction()
            .setTokenName("HIP-657 Mutable NFT")
            .setTokenSymbol("HIP657MNFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setTreasuryAccountId(OPERATOR_ID)
            .setAdminKey(operatorKeyPublic)
            .setSupplyKey(operatorKeyPublic)
            .setMetadataKey(metadataPublicKey)
            .freezeWith(client);

        var mutableNftCreateTxResponse = mutableNftCreateTx.sign(OPERATOR_KEY).execute(client);
        var mutableNftCreateTxReceipt = mutableNftCreateTxResponse.getReceipt(client);
        // Get the token ID of the token that was created.
        var mutableNftId = mutableNftCreateTxReceipt.tokenId;
        Objects.requireNonNull(mutableNftId);
        System.out.println("Created mutable NFT with token ID: " + mutableNftId);

        /*
         * Step 3:
         * Query for the mutable token information stored in consensus node state to see that the Metadata Key is set.
         */
        var mutableNftInfo = new TokenInfoQuery()
            .setTokenId(mutableNftId)
            .execute(client);

        System.out.println("Mutable NFT metadata key: " + mutableNftInfo.metadataKey);

        /*
         * Step 4:
         * Mint the first NFT and set the initial metadata for the NFT.
         */
        System.out.println("Minting NFTs...");
        var mutableNftMintTx = new TokenMintTransaction()
            .setMetadata(List.of(initialMetadata))
            .setTokenId(mutableNftId);

        mutableNftMintTx.getMetadata().forEach(metadata -> {
            System.out.println("Setting metadata: " + Arrays.toString(metadata));
        });

        var mutableNftMintTxResponse = mutableNftMintTx.execute(client);

        // Get receipt for mint token transaction.
        var mutableNftMintTxReceipt = mutableNftMintTxResponse.getReceipt(client);
        System.out.println("Mint transaction was complete with status: " + mutableNftMintTxReceipt.status);

        var mutableNftSerials = mutableNftMintTxReceipt.serials;

        // Check that metadata on the NFT was set correctly.
        getMetadataList(client, mutableNftId, mutableNftSerials).forEach(metadata -> {
            System.out.println("Metadata after mint: " + Arrays.toString(metadata));
        });

        /*
         * Step 5:
         * Create an account to send the NFT to.
         */
        System.out.println("Creating Alice's account...");
        var aliceAccountCreateTx = new AccountCreateTransaction()
            .setKey(operatorKeyPublic)
            // If the account does not have any automatic token association,
            // slots open ONLY then associate the NFT to the account.
            .setMaxAutomaticTokenAssociations(10)
            .execute(client);

        var aliceAccountId = aliceAccountCreateTx.getReceipt(client).accountId;
        Objects.requireNonNull(aliceAccountId);
        System.out.println("Created Alice's account with ID: " + aliceAccountId);

        /*
         * Step 6:
         * Transfer the NFT to the new account.
         */
        System.out.println("Transferring the NFT to Alice's account...");
        new TransferTransaction()
            .addNftTransfer(mutableNftId.nft(mutableNftSerials.get(0)), OPERATOR_ID, aliceAccountId)
            .execute(client);

        /*
         * Step 7:
         * Update NFTs' metadata.
         */
        byte[] updatedMetadata = new byte[]{1, 2};
        System.out.println("Updating NFTs' metadata...");
        var tokenUpdateNftsTx = new TokenUpdateNftsTransaction()
            .setTokenId(mutableNftId)
            .setSerials(mutableNftSerials)
            .setMetadata(updatedMetadata)
            .freezeWith(client);

        System.out.println("Updated NFTs' metadata: " + Arrays.toString(tokenUpdateNftsTx.getMetadata()));
        var tokenUpdateNftsTxResponse = tokenUpdateNftsTx.sign(metadataPrivateKey).execute(client);

        // Get receipt for update NFTs metadata transaction.
        var tokenUpdateNftsTxReceipt = tokenUpdateNftsTxResponse.getReceipt(client);
        System.out.println("Token update nfts metadata transaction was complete with status: " + tokenUpdateNftsTxReceipt.status);

        // Check that metadata for the NFT was updated correctly.
        getMetadataList(client, mutableNftId, mutableNftSerials).forEach(metadata -> {
            System.out.println("NFTs' metadata after update: " + Arrays.toString(metadata));
        });

        /*
         * Step 8:
         * The beginning of the second example (immutable token's metadata).
         *
         * Create a non-fungible token (NFT) with the metadata key field set.
         */
        System.out.println("The beginning of the second example (immutable token's metadata).");
        System.out.println("Creating immutable NFT with the metadata key field set...");
        var immutableNftCreateTx = new TokenCreateTransaction()
            .setTokenName("HIP-657 Immutable NFT")
            .setTokenSymbol("HIP657IMMNFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setTreasuryAccountId(OPERATOR_ID)
            .setSupplyKey(operatorKeyPublic)
            .setMetadataKey(metadataPublicKey)
            .freezeWith(client);

        var immutableNftCreateTxResponse = immutableNftCreateTx.sign(OPERATOR_KEY).execute(client);
        var immutableNftCreateTxReceipt = immutableNftCreateTxResponse.getReceipt(client);
        // Get the token ID of the token that was created.
        var immutableNftId = immutableNftCreateTxReceipt.tokenId;
        Objects.requireNonNull(immutableNftId);
        System.out.println("Created immutable NFT with token ID: " + immutableNftId);

        /*
         * Step 9:
         * Query for the mutable token information stored in consensus node state to see that the metadata key is set.
         */
        var immutableNftInfo = new TokenInfoQuery()
            .setTokenId(immutableNftId)
            .execute(client);

        System.out.println("Immutable NFT metadata key: " + immutableNftInfo.metadataKey);

        /*
         * Step 10:
         * Mint the first NFT and set the initial metadata for the NFT.
         */
        System.out.println("Minting NFTs...");
        var immutableNftMintTx = new TokenMintTransaction()
            .setMetadata(List.of(initialMetadata))
            .setTokenId(immutableNftId);

        immutableNftMintTx.getMetadata().forEach(metadata -> {
            System.out.println("Setting metadata: " + Arrays.toString(metadata));
        });

        var immutableNftMintTxResponse = immutableNftMintTx.execute(client);

        // Get receipt for mint token transaction.
        var immutableNftMintTxReceipt = immutableNftMintTxResponse.getReceipt(client);
        System.out.println("Mint transaction was complete with status: " + immutableNftMintTxReceipt.status);

        var immutableNftSerials = immutableNftMintTxReceipt.serials;
        // Check that metadata on the NFT was set correctly.
        getMetadataList(client, immutableNftId, immutableNftSerials).forEach(metadata -> {
            System.out.println("Metadata after mint: " + Arrays.toString(metadata));
        });

        /*
         * Step 11:
         * Create an account to send the NFT to.
         */
        System.out.println("Creating Bob's account...");
        var bobAccountCreateTx = new AccountCreateTransaction()
            .setKey(operatorKeyPublic)
            // If the account does not have any automatic token association,
            // slots open ONLY then associate the NFT to the account.
            .setMaxAutomaticTokenAssociations(10)
            .execute(client);

        var bobAccountId = bobAccountCreateTx.getReceipt(client).accountId;
        Objects.requireNonNull(bobAccountId);
        System.out.println("Created Bob's account with ID: " + bobAccountId);

        /*
         * Step 12:
         * Transfer the NFT to the new account.
         */
        System.out.println("Transferring the NFT to Bob's account...");
        new TransferTransaction()
            .addNftTransfer(immutableNftId.nft(immutableNftSerials.get(0)), OPERATOR_ID, bobAccountId)
            .execute(client);

        /*
         * Step 13:
         * Update NFTs' metadata.
         */
        System.out.println("Updating NFTs' metadata...");
        var immutableNftUpdateNftsTx = new TokenUpdateNftsTransaction()
            .setTokenId(immutableNftId)
            .setSerials(immutableNftSerials)
            .setMetadata(updatedMetadata)
            .freezeWith(client);

        System.out.println("Updated NFTs' metadata: " + Arrays.toString(immutableNftUpdateNftsTx.getMetadata()));
        var immutableNftUpdateNftsTxResponse = immutableNftUpdateNftsTx.sign(metadataPrivateKey).execute(client);

        // Get receipt for update NFTs metadata transaction.
        var immutableNftUpdateNftsTxReceipt = immutableNftUpdateNftsTxResponse.getReceipt(client);
        System.out.println("Token update nfts metadata transaction was complete with status: " + immutableNftUpdateNftsTxReceipt.status);

        // Check that metadata for the NFT was updated correctly.
        getMetadataList(client, immutableNftId, immutableNftSerials).forEach(metadata -> {
            System.out.println("NFTs' metadata after update: " + Arrays.toString(metadata));
        });

        /*
         * Clean up:
         * Delete created mutable token.
         */
        new TokenDeleteTransaction()
            .setTokenId(mutableNftId)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Update Nfts Metadata Example Complete!");
    }

    private static List<byte[]> getMetadataList(Client client, TokenId tokenId, List<Long> nftSerials) {
        return nftSerials.stream()
            .map(serial -> new NftId(tokenId, serial))
            .flatMap(nftId -> {
                try {
                    return new TokenNftInfoQuery()
                        .setNftId(nftId)
                        .execute(client).stream();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            })
            .map(tokenNftInfo -> tokenNftInfo.metadata)
            .toList();
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ValidateChecksumExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.nio.charset.Charset;
import java.util.Objects;
import java.util.Scanner;

/**
 * How to validate account ID checksum.
 * <p>
 * Entity IDs, such as TokenId and AccountId, can be constructed from strings.
 * For example, the AccountId.fromString(inputString) static method will attempt to parse
 * the input string and construct the expected AccountId object, and will throw an
 * IllegalArgumentException if the string is incorrectly formatted.
 * <p>
 * From here on, we'll talk about methods on accountId, but equivalent methods exist
 * on every entity ID type.
 * <p>
 * fromString() expects the input to look something like this: "1.2.3-asdfg".
 * Here, 1 is the shard, 2 is the realm, 3 is the number, and "asdfg" is the checksum.
 * <p>
 * The checksum can be used to ensure that an entity ID was inputted correctly.
 * For example, if the string being parsed is from a config file, or from user input,
 * it could contain typos.
 * <p>
 * You can use accountId.getChecksum() to get the checksum of an accountId object that was constructed
 * using fromString(). This will be the checksum from the input string. fromString() will merely
 * parse the string and create an AccountId object with the expected shard, realm, num, and checksum
 * values. fromString() will NOT verify that the AccountId maps to a valid account on the Hedera
 * network, and it will not verify the checksum.
 * <p>
 * To verify a checksum, call accountId.validateChecksum(client). If the checksum
 * is invalid, validateChecksum() will throw a BadEntityIdException, otherwise it will return normally.
 * <p>
 * The validity of a checksum depends on which network the client is connected to (e.g. mainnet or
 * testnet or previewnet).  For example, a checksum that is valid for a particular shard/realm/num
 * on mainnet will be INVALID for the same shard/realm/num on testnet.
 * <p>
 * As far as fromString() is concerned, the checksum is optional.
 * If you use fromString() to generate an AccountId from a string that does not include a checksum,
 * such as "1.2.3", fromString() will work, but a call to the getChecksum() method on the resulting
 * AccountId object will return null.
 * <p>
 * Generally speaking, AccountId objects can come from three places:
 * 1) AccountId.fromString(inString)
 * 2) new AccountId(shard, realm, num)
 * 3) From the result of a query.
 * <p>
 * In the first case, the AccountId object will have a checksum (getChecksum() will not return null) if
 * the input string included a checksum, and it will not have a checksum if the string did not
 * include a checksum.
 * <p>
 * In the second and third cases, the AccountId object will not have a checksum.
 * <p>
 * If you call accountId.validateChecksum(client) and accountId has no checksum to validate,
 * validateChecksum() will silently pass, and will not throw an exception.
 * <p>
 * accountId.toString() will stringify the account ID with no checksum,
 * accountId.toStringWithChecksum(client) will stringify the account ID with the correct checksum
 * for that shard/realm/num on the client's network.
 */
class ValidateChecksumExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Validate Checksum Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        /*
         * Step 1:
         * Read an input and validate the checksum (manual).
         */
        System.out.println("An example of manual checksum validation:");

        Scanner inputScanner = new Scanner(System.in, Charset.defaultCharset().name());

        while (true) {
            try {
                System.out.print("Enter an account ID with checksum: ");
                String inputString = inputScanner.nextLine();

                // Throws IllegalArgumentException if incorrectly formatted.
                AccountId accountId = AccountId.fromString(inputString);

                System.out.println("The account ID with no checksum is: " + accountId.toString());
                System.out.println("The account ID with the correct checksum is: " + accountId.toStringWithChecksum(client));

                if (accountId.getChecksum() == null) {
                    System.out.println("You must enter a checksum.");
                    continue;
                }
                System.out.println("The checksum entered was: " + accountId.getChecksum());

                // Throws BadEntityIdException if checksum is incorrect.
                accountId.validateChecksum(client);

                AccountBalance accountBalance = new AccountBalanceQuery()
                    .setAccountId(accountId)
                    .execute(client);

                System.out.println("Account Balance: " + accountBalance);

                // Exit the loop.
                break;
            } catch (IllegalArgumentException exc) {
                System.out.println(exc.getMessage());
            } catch (BadEntityIdException exc) {
                System.out.println(exc.getMessage());
                System.out.println(
                    "You entered " + exc.shard + "." + exc.realm + "." + exc.num + "-" + exc.presentChecksum +
                        ", the expected checksum was " + exc.expectedChecksum
                );
            }
        }

        /*
         * Step 2:
         * Read an input and validate the checksum (auto).
         *
         * It is also possible to perform automatic checksum validation.
         *
         * Automatic checksum validation is disabled by default, but it can be enabled with
         * client.setAutoValidateChecksums(true). You can check whether automatic checksum
         * validation is enabled with client.isAutoValidateChecksumsEnabled().
         *
         * When this feature is enabled, the execute() method of a transaction or query
         * will automatically check the validity of checksums on any IDs in the
         * transaction or query.  It will throw an IllegalArgumentException if an
         * invalid checksum is encountered.
         */
        System.out.println("An example of automatic checksum validation:");

        client.setAutoValidateChecksums(true);

        while (true) {
            try {
                System.out.print("Enter an account ID with checksum: ");

                AccountId accountId = AccountId.fromString(inputScanner.nextLine());

                if (accountId.getChecksum() == null) {
                    System.out.println("You must enter a checksum.");
                    continue;
                }

                AccountBalance accountBalance = new AccountBalanceQuery()
                    .setAccountId(accountId)
                    .execute(client);

                System.out.println("Account Balance: " + accountBalance);

                // Exit the loop.
                break;

            } catch (IllegalArgumentException exc) {
                System.out.println(exc.getMessage());
            }
        }

        /*
         * Clean up:
         */
        client.close();
        System.out.println("Validate Checksum Example Complete!");
    }
}
// Filename: examples/src/main/java/com/hedera/hashgraph/sdk/examples/ZeroTokenOperationsExample.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.examples;

import com.hedera.hashgraph.sdk.*;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.github.cdimascio.dotenv.Dotenv;

import java.util.Collections;
import java.util.Objects;

/**
 * Steps 1-5 are executed through ContractHelper and calling HIP564Example Contract.
 * Step 6 is executed through the SDK
 */
class ZeroTokenOperationsExample {

    /*
     * See .env.sample in the examples folder root for how to specify values below
     * or set environment variables with the same names.
     */

    /**
     * Operator's account ID.
     * Used to sign and pay for operations on Hedera.
     */
    private static final AccountId OPERATOR_ID = AccountId.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_ID")));

    /**
     * Operator's private key.
     */
    private static final PrivateKey OPERATOR_KEY = PrivateKey.fromString(Objects.requireNonNull(Dotenv.load().get("OPERATOR_KEY")));

    /**
     * HEDERA_NETWORK defaults to testnet if not specified in dotenv file.
     * Network can be: localhost, testnet, previewnet or mainnet.
     */
    private static final String HEDERA_NETWORK = Dotenv.load().get("HEDERA_NETWORK", "testnet");

    /**
     * SDK_LOG_LEVEL defaults to SILENT if not specified in dotenv file.
     * Log levels can be: TRACE, DEBUG, INFO, WARN, ERROR, SILENT.
     * <p>
     * Important pre-requisite: set simple logger log level to same level as the SDK_LOG_LEVEL,
     * for example via VM options: -Dorg.slf4j.simpleLogger.log.com.hedera.hashgraph=trace
     */
    private static final String SDK_LOG_LEVEL = Dotenv.load().get("SDK_LOG_LEVEL", "SILENT");

    public static void main(String[] args) throws Exception {
        System.out.println("Zero Token Operations Example Start!");

        /*
         * Step 0:
         * Create and configure the SDK Client.
         */
        Client client = ClientHelper.forName(HEDERA_NETWORK);
        // All generated transactions will be paid by this account and signed by this key.
        client.setOperator(OPERATOR_ID, OPERATOR_KEY);
        // Attach logger to the SDK Client.
        client.setLogger(new Logger(LogLevel.valueOf(SDK_LOG_LEVEL)));

        client.setDefaultMaxTransactionFee(Hbar.from(10));

        /*
         * Step 1:
         * Generate an ED25519 key pair.
         */
        System.out.println("Generating ED25519 key pair...");
        PrivateKey alicePrivateKey = PrivateKey.generateED25519();
        PublicKey alicePublicKey = alicePrivateKey.getPublicKey();

        /*
         * Step 2:
         * Create a new account for the contract to interact with in some of its steps.
         */
        System.out.println("Creating Alice account...");
        AccountCreateTransaction accountCreateTx = new AccountCreateTransaction()
            .setKey(alicePublicKey)
            .setInitialBalance(Hbar.from(1))
            .freezeWith(client);

        accountCreateTx = accountCreateTx.signWithOperator(client);
        TransactionResponse accountCreateTxResponse = accountCreateTx.execute(client);
        AccountId aliceAccountId = accountCreateTxResponse.getReceipt(client).accountId;
        Objects.requireNonNull(aliceAccountId);
        System.out.println("Created Alice's account with ID: " + aliceAccountId);

        /*
         * Step 3:
         * Instantiate ContractHelper.
         */
        System.out.println("Instantiating `ContractHelper`...");
        ContractHelper contractHelper = new ContractHelper(
            "contracts/precompile/ZeroTokenOperations.json",
            new ContractFunctionParameters()
                .addAddress(OPERATOR_ID.toSolidityAddress())
                .addAddress(aliceAccountId.toSolidityAddress()),
            client
        );

        /*
         * Step 4:
         * Configure steps in ContractHelper.
         */
        System.out.println("Configuring steps in `ContractHelper`...");
        contractHelper
            .setPayableAmountForStep(0, Hbar.from(20))
            .addSignerForStep(1, alicePrivateKey);

         /*
         * Step 5:
         * Execute steps in ContractHelper.
         * - step 0 creates a fungible token;
         * - step 1 Associate with account;
         * - step 2 transfer the token by passing a zero value;
         * - step 3 mint the token by passing a zero value;
         * - step 4 burn the token by passing a zero value;
         * - step 5 wipe the token by passing a zero value.
        */
        System.out.println("Executing steps in `ContractHelper`.");
        // Update the signer to have contractId KeyList (this is by security requirement)
        new AccountUpdateTransaction()
            .setAccountId(OPERATOR_ID)
            .setKey(KeyList.of(OPERATOR_KEY.getPublicKey(), contractHelper.contractId).setThreshold(1))
            .execute(client)
            .getReceipt(client);

        // Update the Alice account to have contractId KeyList (this is by security requirement)
        new AccountUpdateTransaction()
            .setAccountId(aliceAccountId)
            .setKey(KeyList.of(alicePublicKey, contractHelper.contractId).setThreshold(1))
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        // Configure steps in ContractHelper
        contractHelper
            .setPayableAmountForStep(0, Hbar.from(40))
            .addSignerForStep(1, alicePrivateKey);

        // step 0 creates a fungible token
        // step 1 Associate with account
        // step 2 transfer the token by passing a zero value
        // step 3 mint the token by passing a zero value
        // step 4 burn the token by passing a zero value
        // step 5 wipe the token by passing a zero value
        contractHelper.executeSteps(/* from step */ 0, /* to step */ 5, client);

        /*
         * Step 6:
         * Create and execute a transfer transaction with a zero value.
         */
        System.out.println("Creating a Fungible Token...");
        TokenCreateTransaction tokenCreateTx = new TokenCreateTransaction()
            .setTokenName("Zero Token Ops Fungible Token")
            .setTokenSymbol("ZTOFT")
            .setTreasuryAccountId(OPERATOR_ID)
            // Total supply = 10000 / 10 ^ 2.
            .setInitialSupply(10_000)
            .setDecimals(2)
            .setAutoRenewAccountId(OPERATOR_ID)
            .freezeWith(client);

        tokenCreateTx = tokenCreateTx.signWithOperator(client);
        TransactionResponse tokenCreateTxResponse = tokenCreateTx.execute(client);

        TokenId fungibleTokenId = tokenCreateTxResponse.getReceipt(client).tokenId;
        Objects.requireNonNull(fungibleTokenId);
        System.out.println("Created Fungible Token with ID: " + fungibleTokenId);

        // Associate Token with Account.
        // Accounts on hedera have to opt in to receive any types of token that aren't Hbar.
        System.out.println("Associate Token with Alice's account...");
        TokenAssociateTransaction tokenAssociateTx = new TokenAssociateTransaction()
            .setAccountId(aliceAccountId)
            .setTokenIds(Collections.singletonList(fungibleTokenId))
            .freezeWith(client);

        TokenAssociateTransaction tokenAssociateTxSigned = tokenAssociateTx.sign(alicePrivateKey);
        TransactionResponse tokenAssociateTxResponse = tokenAssociateTxSigned.execute(client);
        TransactionReceipt tokenAssociateTxReceipt = tokenAssociateTxResponse.getReceipt(client);
        System.out.println("Alice association transaction was complete with status: " + tokenAssociateTxReceipt.status);

        // Transfer token.
        System.out.println("Transferring zero tokens from operator's account to Alice's account...");
        TransferTransaction transferTx = new TransferTransaction()
            // Deduct 0 tokens.
            .addTokenTransfer(fungibleTokenId, OPERATOR_ID, 0)
            // Increase balance by 0.
            .addTokenTransfer(fungibleTokenId, aliceAccountId, 0)
            .freezeWith(client);

        TransferTransaction transferTxSigned = transferTx.signWithOperator(client);
        TransactionResponse transferTxResponse = transferTxSigned.execute(client);

        // Verify the transaction reached consensus.
        TransactionRecord transferTxRecord = transferTxResponse.getRecord(client);

        System.out.println(
            "step 6 completed, and returned valid result. TransactionId: " + transferTxRecord.transactionId);

        System.out.println("All steps completed with valid results.");

        /*
         * Clean up:
         * Delete created account and contract.
         */
        new AccountDeleteTransaction()
            .setAccountId(aliceAccountId)
            .setTransferAccountId(OPERATOR_ID)
            .freezeWith(client)
            .sign(alicePrivateKey)
            .execute(client)
            .getReceipt(client);

        client.close();

        System.out.println("Zero Token Operations Example Complete!");
    }
}
// Filename: examples/src/main/java/module-info.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

module com.hedera.hashgraph.examples {
    requires com.hedera.hashgraph.sdk;
    // requires com.hedera.hashgraph.sdk.full;

    requires com.google.gson;
    requires java.dotenv;

    requires static java.annotation;
    requires com.google.protobuf;
}
// Filename: sdk-full/src/main/java/module-info.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

module com.hedera.hashgraph.sdk.full {
    requires transitive com.google.protobuf;

    requires com.google.common;
    requires com.google.gson;
    requires headlong;
    requires io.grpc.inprocess;
    requires io.grpc.protobuf;
    requires io.grpc.stub;
    requires io.grpc;
    requires java.net.http;
    requires org.bouncycastle.pkix;
    requires org.bouncycastle.provider;
    requires org.slf4j;

    requires static com.github.spotbugs.annotations;
    requires static com.google.errorprone.annotations;
    requires static java.annotation;

    exports com.hedera.hashgraph.sdk;
    exports com.hedera.hashgraph.sdk.logger;
    exports com.hedera.hashgraph.sdk.proto;

    opens com.hedera.hashgraph.sdk;
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AbstractTokenTransferTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

abstract class AbstractTokenTransferTransaction<T extends AbstractTokenTransferTransaction<T>> extends Transaction<T> {

    protected final ArrayList<TokenTransfer> tokenTransfers = new ArrayList<>();
    protected final ArrayList<TokenNftTransfer> nftTransfers = new ArrayList<>();

    protected AbstractTokenTransferTransaction() {}

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    AbstractTokenTransferTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    AbstractTokenTransferTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
    }


    /**
     * Extract the list of token id decimals.
     *
     * @return the list of token id decimals
     */
    public Map<TokenId, Integer> getTokenIdDecimals() {
        Map<TokenId, Integer> decimalsMap = new HashMap<>();

        for (var transfer : tokenTransfers) {
            decimalsMap.put(transfer.tokenId, transfer.expectedDecimals);
        }

        return decimalsMap;
    }

    /**
     * Extract the list of token transfer records.
     *
     * @return the list of token transfer records
     */
    public Map<TokenId, Map<AccountId, Long>> getTokenTransfers() {
        Map<TokenId, Map<AccountId, Long>> transfers = new HashMap<>();

        for (var transfer : tokenTransfers) {
            var current = transfers.get(transfer.tokenId) != null
                ? transfers.get(transfer.tokenId) : new HashMap<AccountId, Long>();
            current.put(transfer.accountId, transfer.amount);
            transfers.put(transfer.tokenId, current);
        }

        return transfers;
    }

    private T doAddTokenTransfer(TokenId tokenId, AccountId accountId, long value,
        boolean isApproved) {
        requireNotFrozen();

        for (var transfer : tokenTransfers) {
            if (transfer.tokenId.equals(tokenId) && transfer.accountId.equals(accountId)
                && transfer.isApproved == isApproved) {
                transfer.amount = transfer.amount + value;
                // noinspection unchecked
                return (T) this;
            }
        }

        tokenTransfers.add(new TokenTransfer(tokenId, accountId, value, isApproved));
        // noinspection unchecked
        return (T) this;
    }

    /**
     * Add a non-approved token transfer to the transaction.
     *
     * @param tokenId   the token id
     * @param accountId the account id
     * @param value     the value
     * @return the updated transaction
     */
    public T addTokenTransfer(TokenId tokenId, AccountId accountId, long value) {
        return doAddTokenTransfer(tokenId, accountId, value, false);
    }

    /**
     * Add an approved token transfer to the transaction.
     *
     * @param tokenId   the token id
     * @param accountId the account id
     * @param value     the value
     * @return the updated transaction
     */
    public T addApprovedTokenTransfer(TokenId tokenId, AccountId accountId, long value) {
        return doAddTokenTransfer(tokenId, accountId, value, true);
    }

    private T doAddTokenTransferWithDecimals(
        TokenId tokenId,
        AccountId accountId,
        long value,
        int decimals,
        boolean isApproved
    ) {
        requireNotFrozen();

        var found = false;

        for (var transfer : tokenTransfers) {
            if (transfer.tokenId.equals(tokenId)) {
                if (transfer.expectedDecimals != null && transfer.expectedDecimals != decimals) {
                    throw new IllegalArgumentException(
                        "expected decimals for a token in a token transfer cannot be changed after being set");
                }

                transfer.expectedDecimals = decimals;

                if (transfer.accountId.equals(accountId) && transfer.isApproved == isApproved) {
                    transfer.amount = transfer.amount + value;
                    found = true;
                }

            }
        }

        if (found) {
            // noinspection unchecked
            return (T) this;
        }
        tokenTransfers.add(new TokenTransfer(tokenId, accountId, value, decimals, isApproved));

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Add a non-approved token transfer with decimals.
     *
     * @param tokenId   the token id
     * @param accountId the account id
     * @param value     the value
     * @param decimals  the decimals
     * @return the updated transaction
     */
    public T addTokenTransferWithDecimals(
        TokenId tokenId,
        AccountId accountId,
        long value,
        int decimals
    ) {
        return doAddTokenTransferWithDecimals(tokenId, accountId, value, decimals, false);
    }

    /**
     * Add an approved token transfer with decimals.
     *
     * @param tokenId   the token id
     * @param accountId the account id
     * @param value     the value
     * @param decimals  the decimals
     * @return the updated transaction
     */
    public T addApprovedTokenTransferWithDecimals(
        TokenId tokenId,
        AccountId accountId,
        long value,
        int decimals
    ) {
        return doAddTokenTransferWithDecimals(tokenId, accountId, value, decimals, true);
    }

    /**
     * @param tokenId    the token id
     * @param accountId  the account id
     * @param isApproved whether the transfer is approved
     * @return {@code this}
     * @deprecated - Use {@link #addApprovedTokenTransfer(TokenId, AccountId, long)} instead
     */
    @Deprecated
    public T setTokenTransferApproval(TokenId tokenId, AccountId accountId, boolean isApproved) {
        requireNotFrozen();

        for (var transfer : tokenTransfers) {
            if (transfer.tokenId.equals(tokenId) && transfer.accountId.equals(accountId)) {
                transfer.isApproved = isApproved;
                // noinspection unchecked
                return (T) this;
            }
        }

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Extract the of token nft transfers.
     *
     * @return list of token nft transfers
     */
    public Map<TokenId, List<TokenNftTransfer>> getTokenNftTransfers() {
        Map<TokenId, List<TokenNftTransfer>> transfers = new HashMap<>();

        for (var transfer : nftTransfers) {
            var current = transfers.get(transfer.tokenId) != null
                ? transfers.get(transfer.tokenId) : new ArrayList<TokenNftTransfer>();
            current.add(transfer);
            transfers.put(transfer.tokenId, current);
        }

        return transfers;
    }

    private T doAddNftTransfer(NftId nftId, AccountId sender, AccountId receiver,
        boolean isApproved) {
        requireNotFrozen();
        nftTransfers.add(new TokenNftTransfer(nftId.tokenId, sender, receiver, nftId.serial, isApproved));
        return (T) this;
    }

    /**
     * Add a non-approved nft transfer.
     *
     * @param nftId    the nft's id
     * @param sender   the sender account id
     * @param receiver the receiver account id
     * @return the updated transaction
     */
    public T addNftTransfer(NftId nftId, AccountId sender, AccountId receiver) {
        return doAddNftTransfer(nftId, sender, receiver, false);
    }

    /**
     * Add an approved nft transfer.
     *
     * @param nftId    the nft's id
     * @param sender   the sender account id
     * @param receiver the receiver account id
     * @return the updated transaction
     */
    public T addApprovedNftTransfer(NftId nftId, AccountId sender, AccountId receiver) {
        return doAddNftTransfer(nftId, sender, receiver, true);
    }

    /**
     * @param nftId      the NFT id
     * @param isApproved whether the transfer is approved
     * @return {@code this}
     * @deprecated - Use {@link #addApprovedNftTransfer(NftId, AccountId, AccountId)} instead
     */
    @Deprecated
    public T setNftTransferApproval(NftId nftId, boolean isApproved) {
        requireNotFrozen();

        for (var transfer : nftTransfers) {
            if (transfer.tokenId.equals(nftId.tokenId) && transfer.serial == nftId.serial) {
                transfer.isApproved = isApproved;
                // noinspection unchecked
                return (T) this;
            }
        }

        // noinspection unchecked
        return (T) this;
    }

    protected ArrayList<com.hedera.hashgraph.sdk.TokenTransferList> sortTransfersAndBuild() {
        var transferLists = new ArrayList<com.hedera.hashgraph.sdk.TokenTransferList>();

        this.tokenTransfers.sort(Comparator.comparing((TokenTransfer a) -> a.tokenId).thenComparing(a -> a.accountId)
            .thenComparing(a -> a.isApproved));
        this.nftTransfers.sort(Comparator.comparing((TokenNftTransfer a) -> a.tokenId).thenComparing(a -> a.sender)
            .thenComparing(a -> a.receiver).thenComparing(a -> a.serial));

        var i = 0;
        var j = 0;

        // Effectively merge sort
        while (i < this.tokenTransfers.size() || j < this.nftTransfers.size()) {
            if (i < this.tokenTransfers.size() && j < this.nftTransfers.size()) {
                var iTokenId = this.tokenTransfers.get(i).tokenId;
                var jTokenId = this.nftTransfers.get(j).tokenId;
                var last = !transferLists.isEmpty() ? transferLists.get(transferLists.size() - 1) : null;
                var lastTokenId = last != null ? last.tokenId : null;

                if (last != null && iTokenId.compareTo(lastTokenId) == 0) {
                    last.transfers.add(this.tokenTransfers.get(i++));
                    continue;
                }

                if (last != null && jTokenId.compareTo(lastTokenId) == 0) {
                    last.nftTransfers.add(this.nftTransfers.get(j++));
                    continue;
                }

                var result = iTokenId.compareTo(jTokenId);

                if (result == 0) {
                    transferLists.add(new com.hedera.hashgraph.sdk.TokenTransferList(iTokenId,
                        this.tokenTransfers.get(i).expectedDecimals, this.tokenTransfers.get(i++),
                        this.nftTransfers.get(j++)));
                } else if (result < 0) {
                    transferLists.add(new com.hedera.hashgraph.sdk.TokenTransferList(iTokenId,
                        this.tokenTransfers.get(i).expectedDecimals, this.tokenTransfers.get(i++), null));
                } else {
                    transferLists.add(new com.hedera.hashgraph.sdk.TokenTransferList(jTokenId, null, null,
                        this.nftTransfers.get(j++)));
                }
            } else if (i < this.tokenTransfers.size()) {
                var iTokenId = this.tokenTransfers.get(i).tokenId;
                var last = !transferLists.isEmpty() ? transferLists.get(transferLists.size() - 1) : null;
                var lastTokenId = last != null ? last.tokenId : null;

                if (last != null && iTokenId.compareTo(lastTokenId) == 0) {
                    last.transfers.add(this.tokenTransfers.get(i++));
                    continue;
                }

                transferLists.add(new com.hedera.hashgraph.sdk.TokenTransferList(iTokenId,
                    this.tokenTransfers.get(i).expectedDecimals, this.tokenTransfers.get(i++), null));
            } else {
                var jTokenId = this.nftTransfers.get(j).tokenId;
                var last = !transferLists.isEmpty() ? transferLists.get(transferLists.size() - 1) : null;
                var lastTokenId = last != null ? last.tokenId : null;

                if (last != null && jTokenId.compareTo(lastTokenId) == 0) {
                    last.nftTransfers.add(this.nftTransfers.get(j++));
                    continue;
                }

                transferLists.add(
                    new com.hedera.hashgraph.sdk.TokenTransferList(jTokenId, null, null, this.nftTransfers.get(j++)));
            }
        }
        return transferLists;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        for (var transfer : nftTransfers) {
            transfer.tokenId.validateChecksum(client);
            transfer.sender.validateChecksum(client);
            transfer.receiver.validateChecksum(client);
        }

        for (var transfer : tokenTransfers) {
            transfer.tokenId.validateChecksum(client);
            transfer.accountId.validateChecksum(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountAllowanceAdjustTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * @deprecated with no replacement
 */

@Deprecated
public class AccountAllowanceAdjustTransaction extends Transaction<AccountAllowanceAdjustTransaction> {
    private final List<HbarAllowance> hbarAllowances = new ArrayList<>();
    private final List<TokenAllowance> tokenAllowances =  new ArrayList<>();
    private final List<TokenNftAllowance> nftAllowances = new ArrayList<>();
    // key is "{ownerId}:{spenderId}".  OwnerId may be "FEE_PAYER"
    private final Map<String, Map<TokenId, Integer>> nftMap = new HashMap<>();

    /**
     * Constructor.
     */
    public AccountAllowanceAdjustTransaction() {
    }

    AccountAllowanceAdjustTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs
    ) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    AccountAllowanceAdjustTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    private void initFromTransactionBody() {
        throw new UnsupportedOperationException("Cannot construct AccountAllowanceAdjustTransaction from bytes");
    }

    private AccountAllowanceAdjustTransaction adjustHbarAllowance(
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        Hbar amount
    ) {
        requireNotFrozen();
        hbarAllowances.add(new HbarAllowance(ownerAccountId, Objects.requireNonNull(spenderAccountId), amount));
        return this;
    }

    /**
     * @deprecated - Use {@link #grantHbarAllowance(AccountId, AccountId, Hbar)} or
     * {@link #revokeHbarAllowance(AccountId, AccountId, Hbar)} instead
     *
     * @param spenderAccountId          the spender account id
     * @param amount                    the amount of hbar
     * @return                          an account allowance adjust transaction
     */
    @Deprecated
    public AccountAllowanceAdjustTransaction addHbarAllowance(AccountId spenderAccountId, Hbar amount) {
        return adjustHbarAllowance(null, spenderAccountId, Objects.requireNonNull(amount));
    }

    /**
     *  Grants Hbar allowance.
     *
     * @param ownerAccountId    the owner's account id
     * @param spenderAccountId  the spender's account id
     * @param amount            the amount of Hbar
     * @return {@code this}
     */
    public AccountAllowanceAdjustTransaction grantHbarAllowance(
        AccountId ownerAccountId,
        AccountId spenderAccountId,
        Hbar amount
    ) {
        Objects.requireNonNull(amount);
        if (amount.compareTo(Hbar.ZERO) < 0) {
            throw new IllegalArgumentException("amount passed to grantHbarAllowance must be positive");
        }
        return adjustHbarAllowance(Objects.requireNonNull(ownerAccountId), spenderAccountId, amount);
    }

    /**
     * Revokes Hbar allowance
     *
     * @param ownerAccountId    the owner's account id
     * @param spenderAccountId  the spender's account id
     * @param amount            the amount of Hbar
     * @return {@code this}
     */
    public AccountAllowanceAdjustTransaction revokeHbarAllowance(
        AccountId ownerAccountId,
        AccountId spenderAccountId,
        Hbar amount
    ) {
        Objects.requireNonNull(amount);
        if (amount.compareTo(Hbar.ZERO) < 0) {
            throw new IllegalArgumentException("amount passed to revokeHbarAllowance must be positive");
        }
        return adjustHbarAllowance(Objects.requireNonNull(ownerAccountId), spenderAccountId, amount.negated());
    }

    /**
     * Get the Hbar allowances
     *
     * @return the Hbar allowances
     */
    public List<HbarAllowance> getHbarAllowances() {
        return new ArrayList<>(hbarAllowances);
    }

    private AccountAllowanceAdjustTransaction adjustTokenAllowance(
        TokenId tokenId,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        long amount
    ) {
        requireNotFrozen();
        tokenAllowances.add(new TokenAllowance(
            Objects.requireNonNull(tokenId),
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            amount
        ));
        return this;
    }

    /**
     * @deprecated - Use {@link #grantTokenAllowance(TokenId, AccountId, AccountId, long)} or
     * {@link #revokeTokenAllowance(TokenId, AccountId, AccountId, long)} instead
     *
     * @param tokenId                   the token's id
     * @param spenderAccountId          the spender's account id
     * @param amount                    the amount of hbar
     * @return                          an account allowance adjust transaction
     */
    @Deprecated
    public AccountAllowanceAdjustTransaction addTokenAllowance(TokenId tokenId, AccountId spenderAccountId, long amount) {
        return adjustTokenAllowance(tokenId, null, spenderAccountId, amount);
    }

    /**
     * Grants token allowance.
     *
     * @param tokenId           the token's id
     * @param ownerAccountId    the owner's id
     * @param spenderAccountId  the spender's id
     * @param amount            the amount of tokens
     * @return {@code this}
     */
    public AccountAllowanceAdjustTransaction grantTokenAllowance(
        TokenId tokenId,
        AccountId ownerAccountId,
        AccountId spenderAccountId,
        @Nonnegative long amount
    ) {
        return adjustTokenAllowance(tokenId, Objects.requireNonNull(ownerAccountId), spenderAccountId, amount);
    }

    /**
     * Revokes token allowance.
     *
     * @param tokenId           the token's id
     * @param ownerAccountId    the owner's id
     * @param spenderAccountId  the spender's id
     * @param amount            the amount of tokens
     * @return {@code this}
     */
    public AccountAllowanceAdjustTransaction revokeTokenAllowance(
        TokenId tokenId,
        AccountId ownerAccountId,
        AccountId spenderAccountId,
        @Nonnegative long amount
    ) {
        return adjustTokenAllowance(tokenId, Objects.requireNonNull(ownerAccountId), spenderAccountId, -amount);
    }

    /**
     * Get the token allowances
     *
     * @return the token allowances
     */
    public List<TokenAllowance> getTokenAllowances() {
        return new ArrayList<>(tokenAllowances);
    }

    private static String ownerToString(@Nullable AccountId ownerAccountId) {
        return ownerAccountId != null ? ownerAccountId.toString() : "FEE_PAYER";
    }

    private List<Long> getNftSerials(@Nullable AccountId ownerAccountId, AccountId spenderAccountId, TokenId tokenId) {
        var key = ownerToString(ownerAccountId) + ":" + spenderAccountId;
        if (nftMap.containsKey(key)) {
            var innerMap = nftMap.get(key);
            if (innerMap.containsKey(tokenId)) {
                return Objects.requireNonNull(nftAllowances.get(innerMap.get(tokenId)).serialNumbers);
            } else {
                return newNftSerials(ownerAccountId, spenderAccountId, tokenId, innerMap);
            }
        } else {
            Map<TokenId, Integer> innerMap = new HashMap<>();
            nftMap.put(key, innerMap);
            return newNftSerials(ownerAccountId, spenderAccountId, tokenId, innerMap);
        }
    }

    private List<Long> newNftSerials(
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        TokenId tokenId,
        Map<TokenId, Integer> innerMap
    ) {
        innerMap.put(tokenId, nftAllowances.size());
        TokenNftAllowance newAllowance = new TokenNftAllowance(tokenId, ownerAccountId, spenderAccountId, null, new ArrayList<>(), null);
        nftAllowances.add(newAllowance);
        return newAllowance.serialNumbers;
    }

    private AccountAllowanceAdjustTransaction adjustNftAllowance(
        TokenId tokenId,
        long serial,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        requireNotFrozen();
        getNftSerials(ownerAccountId, Objects.requireNonNull(spenderAccountId), tokenId).add(serial);
        return this;
    }

    private AccountAllowanceAdjustTransaction adjustNftAllowanceAllSerials(
        TokenId tokenId,
        boolean allSerials,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        requireNotFrozen();
        nftAllowances.add(new TokenNftAllowance(
            Objects.requireNonNull(tokenId),
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            null,
            Collections.emptyList(),
            allSerials
        ));
        return this;
    }

    /**
     * @deprecated - Use {@link #grantTokenNftAllowance(NftId, AccountId, AccountId)} or
     * {@link #revokeTokenNftAllowance(NftId, AccountId, AccountId)} instead
     *
     * @param nftId                 the NFT's id
     * @param spenderAccountId      the spender's account id
     * @return                      an account allowance adjust transaction
     */
    @Deprecated
    public AccountAllowanceAdjustTransaction addTokenNftAllowance(NftId nftId, AccountId spenderAccountId) {
        Objects.requireNonNull(nftId);
        return adjustNftAllowance(nftId.tokenId, nftId.serial, null, spenderAccountId);
    }

    /**
     * @deprecated - Use {@link #grantTokenNftAllowanceAllSerials(TokenId, AccountId, AccountId)} or
     * {@link #revokeTokenNftAllowanceAllSerials(TokenId, AccountId, AccountId)} instead
     * @param tokenId               the token's id
     * @param spenderAccountId      the spender's account id
     * @return                      an account allowance adjust transaction
     */
    @Deprecated
    public AccountAllowanceAdjustTransaction addAllTokenNftAllowance(TokenId tokenId, AccountId spenderAccountId) {
        return adjustNftAllowanceAllSerials(tokenId, true, null, spenderAccountId);
    }

    /**
     * Grants NFT allowance.
     *
     * @param nftId             the NFT's id
     * @param ownerAccountId    the owner's id
     * @param spenderAccountId  the spender's id
     * @return {@code this}
     */
    public AccountAllowanceAdjustTransaction grantTokenNftAllowance(
        NftId nftId,
        AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        Objects.requireNonNull(nftId);
        Objects.requireNonNull(ownerAccountId);
        return adjustNftAllowance(nftId.tokenId, nftId.serial, ownerAccountId, spenderAccountId);
    }

    /**
     * Grants allowance for all NFT serials of a token
     *
     * @param tokenId               the token's id
     * @param ownerAccountId        the owner's account id
     * @param spenderAccountId      the spender's account id
     * @return                      an account allowance adjust transaction
     */
    public AccountAllowanceAdjustTransaction grantTokenNftAllowanceAllSerials(
        TokenId tokenId,
        AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        Objects.requireNonNull(ownerAccountId);
        return adjustNftAllowanceAllSerials(tokenId, true, ownerAccountId, spenderAccountId);
    }

    /**
     * @deprecated with no replacement
     * @param nftId                 the NFT's id
     * @param ownerAccountId        the owner's account id
     * @param spenderAccountId      the spender's account id
     * @return                      an account allowance adjust transaction
     */
    @Deprecated
    public AccountAllowanceAdjustTransaction revokeTokenNftAllowance(
        NftId nftId,
        AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        Objects.requireNonNull(nftId);
        Objects.requireNonNull(ownerAccountId);
        return adjustNftAllowance(nftId.tokenId, -nftId.serial, ownerAccountId, spenderAccountId);
    }

    /**
     * Revokes allowance for all NFT serials of a token
     *
     * @param tokenId               the token's id
     * @param ownerAccountId        the owner's account id
     * @param spenderAccountId      the spender's account id
     * @return                      an account allowance adjust transaction
     */
    public AccountAllowanceAdjustTransaction revokeTokenNftAllowanceAllSerials(
        TokenId tokenId,
        AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        Objects.requireNonNull(ownerAccountId);
        return adjustNftAllowanceAllSerials(tokenId, false, ownerAccountId, spenderAccountId);
    }

    /**
     * Get the NFT allowances
     *
     * @return a copy of {@link #nftAllowances}
     */
    public List<TokenNftAllowance> getTokenNftAllowances() {
        List<TokenNftAllowance> retval = new ArrayList<>(nftAllowances.size());
        for (var allowance : nftAllowances) {
            retval.add(TokenNftAllowance.copyFrom(allowance));
        }
        return retval;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        throw new UnsupportedOperationException("Cannot get method descriptor for AccountAllowanceAdjustTransaction");
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        // do nothing
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("Cannot schedule AccountAllowanceAdjustTransaction");
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        for (var allowance : hbarAllowances) {
            allowance.validateChecksums(client);
        }
        for (var allowance : tokenAllowances) {
            allowance.validateChecksums(client);
        }
        for (var allowance : nftAllowances) {
            allowance.validateChecksums(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountAllowanceApproveTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoApproveAllowanceTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * This transaction type is for approving account allowance.
 */
public class AccountAllowanceApproveTransaction extends Transaction<AccountAllowanceApproveTransaction> {
    private final List<HbarAllowance> hbarAllowances = new ArrayList<>();
    private final List<TokenAllowance> tokenAllowances =  new ArrayList<>();
    private final List<TokenNftAllowance> nftAllowances = new ArrayList<>();
    // key is "{ownerId}:{spenderId}".  OwnerId may be "FEE_PAYER"
    // <ownerId:spenderId, <tokenId, index>>
    private final Map<String, Map<TokenId, Integer>> nftMap = new HashMap<>();

    /**
     * Constructor.
     */
    public AccountAllowanceApproveTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs                                   Compound list of transaction id's list of (AccountId, Transaction) records
     */
    AccountAllowanceApproveTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs
    ) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody                    protobuf TransactionBody
     */
    AccountAllowanceApproveTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    private void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoApproveAllowance();
        for (var allowanceProto : body.getCryptoAllowancesList()) {
            hbarAllowances.add(HbarAllowance.fromProtobuf(allowanceProto));
        }
        for (var allowanceProto : body.getTokenAllowancesList()) {
            tokenAllowances.add(TokenAllowance.fromProtobuf(allowanceProto));
        }
        for (var allowanceProto : body.getNftAllowancesList()) {
            if (allowanceProto.hasApprovedForAll() && allowanceProto.getApprovedForAll().getValue()) {
                nftAllowances.add(TokenNftAllowance.fromProtobuf(allowanceProto));
            } else {
                getNftSerials(
                    allowanceProto.hasOwner() ? AccountId.fromProtobuf(allowanceProto.getOwner()) : null,
                    AccountId.fromProtobuf(allowanceProto.getSpender()),
                    allowanceProto.hasDelegatingSpender() ? AccountId.fromProtobuf(allowanceProto.getDelegatingSpender()) : null,
                    TokenId.fromProtobuf(allowanceProto.getTokenId())
                ).addAll(allowanceProto.getSerialNumbersList());
            }
        }
    }

    /**
     * @deprecated - Use {@link #approveHbarAllowance(AccountId, AccountId, Hbar)} instead
     *
     * @param spenderAccountId          the spender account id
     * @param amount                    the amount of hbar
     * @return                          an account allowance approve transaction
     */
    @Deprecated
    public AccountAllowanceApproveTransaction addHbarAllowance(AccountId spenderAccountId, Hbar amount) {
        return approveHbarAllowance(null, spenderAccountId, amount);
    }

    /**
     * Approves the Hbar allowance.
     *
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @param amount                    amount of hbar add
     * @return {@code this}
     */
    public AccountAllowanceApproveTransaction approveHbarAllowance(
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        Hbar amount
    ) {
        requireNotFrozen();
        Objects.requireNonNull(amount);
        if (amount.compareTo(Hbar.ZERO) < 0) {
            throw new IllegalArgumentException("amount passed to approveHbarAllowance must be positive");
        }
        hbarAllowances.add(new HbarAllowance(ownerAccountId, Objects.requireNonNull(spenderAccountId), amount));
        return this;
    }

    /**
     * @deprecated - Use {@link #getHbarApprovals()} instead
     *
     * @return                          list of hbar allowance records
     */
    @Deprecated
    public List<HbarAllowance> getHbarAllowances() {
        return getHbarApprovals();
    }

    /**
     * Extract the list of hbar allowances.
     *
     * @return                          array list of hbar allowances
     */
    public List<HbarAllowance> getHbarApprovals() {
        return new ArrayList<>(hbarAllowances);
    }

    /**
     * @deprecated - Use {@link #approveTokenAllowance(TokenId, AccountId, AccountId, long)} instead
     *
     * @param tokenId                   the token id
     * @param spenderAccountId          the spenders account id
     * @param amount                    the hbar amount
     * @return                          an account allowance approve transaction
     */
    @Deprecated
    public AccountAllowanceApproveTransaction addTokenAllowance(
        TokenId tokenId,
        AccountId spenderAccountId,
        long amount
    ) {
        return approveTokenAllowance(tokenId, null, spenderAccountId, amount);
    }

    /**
     * Approves the Token allowance.
     *
     * @param tokenId                   the token's id
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @param amount                    amount of tokens
     * @return {@code this}
     */
    public AccountAllowanceApproveTransaction approveTokenAllowance(
        TokenId tokenId,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        long amount
    ) {
        requireNotFrozen();
        if (amount < 0) {
            throw new IllegalArgumentException("amount given to approveTokenAllowance must be positive");
        }
        tokenAllowances.add(new TokenAllowance(
            Objects.requireNonNull(tokenId),
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            amount
        ));
        return this;
    }

    /**
     * @deprecated - Use {@link #getTokenApprovals()} instead
     *
     * @return                          a list of token allowances
     */
    @Deprecated
    public List<TokenAllowance> getTokenAllowances() {
        return getTokenApprovals();
    }

    /**
     * Extract a list of token allowance approvals.
     *
     * @return                          array list of token approvals.
     */
    public List<TokenAllowance> getTokenApprovals() {
        return new ArrayList<>(tokenAllowances);
    }

    /**
     * Extract the owner as a string.
     *
     * @param ownerAccountId            owner's account id
     * @return                          a string representation of the account id
     *                                  or FEE_PAYER
     */
    private static String ownerToString(@Nullable AccountId ownerAccountId) {
        return ownerAccountId != null ? ownerAccountId.toString() : "FEE_PAYER";
    }

    /**
     * Return a list of NFT serial numbers.
     *
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @param delegatingSpender         delegating spender's account id
     * @param tokenId                   the token's id
     * @return list of NFT serial numbers
     */
    private List<Long> getNftSerials(@Nullable AccountId ownerAccountId, AccountId spenderAccountId, @Nullable AccountId delegatingSpender, TokenId tokenId) {
        var key = ownerToString(ownerAccountId) + ":" + spenderAccountId;
        if (nftMap.containsKey(key)) {
            var innerMap = nftMap.get(key);
            if (innerMap.containsKey(tokenId)) {
                return Objects.requireNonNull(nftAllowances.get(innerMap.get(tokenId)).serialNumbers);
            } else {
                return newNftSerials(ownerAccountId, spenderAccountId, delegatingSpender, tokenId, innerMap);
            }
        } else {
            Map<TokenId, Integer> innerMap = new HashMap<>();
            nftMap.put(key, innerMap);
            return newNftSerials(ownerAccountId, spenderAccountId, delegatingSpender, tokenId, innerMap);
        }
    }

    /**
     * Add NFT serials.
     *
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @param delegatingSpender         delegating spender's account id
     * @param tokenId                   the token's id
     * @param innerMap                  list of token id's and serial number records
     * @return list of NFT serial numbers
     */
    private List<Long> newNftSerials(
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        @Nullable AccountId delegatingSpender,
        TokenId tokenId,
        Map<TokenId, Integer> innerMap
    ) {
        innerMap.put(tokenId, nftAllowances.size());
        TokenNftAllowance newAllowance = new TokenNftAllowance(
            tokenId,
            ownerAccountId,
            spenderAccountId,
            delegatingSpender,
            new ArrayList<>(),
            null
        );
        nftAllowances.add(newAllowance);
        return newAllowance.serialNumbers;
    }

    /**
     * @deprecated - Use {@link #approveTokenNftAllowance(NftId, AccountId, AccountId, AccountId)} instead
     *
     * @param nftId                     the nft id
     * @param spenderAccountId          the spender's account id
     * @return {@code this}
     */
    @Deprecated
    public AccountAllowanceApproveTransaction addTokenNftAllowance(NftId nftId, AccountId spenderAccountId) {
        requireNotFrozen();
        getNftSerials(null, spenderAccountId, null, nftId.tokenId).add(nftId.serial);
        return this;
    }

    /**
     * @deprecated - Use {@link #approveTokenNftAllowanceAllSerials(TokenId, AccountId, AccountId)} instead
     *
     * @param tokenId                   the token id
     * @param spenderAccountId          the spender's account id
     * @return {@code this}
     */
    @Deprecated
    public AccountAllowanceApproveTransaction addAllTokenNftAllowance(TokenId tokenId, AccountId spenderAccountId) {
        requireNotFrozen();
        nftAllowances.add(new TokenNftAllowance(
            tokenId,
            null,
            spenderAccountId,
            null,
            Collections.emptyList(),
            true
        ));
        return this;
    }

    /**
     * Approve the NFT allowance.
     *
     * @param nftId                     nft's id
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @param delegatingSpender         delegating spender's account id
     * @return {@code this}
     */
    public AccountAllowanceApproveTransaction approveTokenNftAllowance(
        NftId nftId,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId,
        @Nullable AccountId delegatingSpender
    ) {
        requireNotFrozen();
        Objects.requireNonNull(nftId);
        getNftSerials(
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            delegatingSpender,
            nftId.tokenId
        ).add(nftId.serial);
        return this;
    }

    /**
     * Approve the NFT allowance.
     *
     * @param nftId                     nft's id
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @return {@code this}
     */
    public AccountAllowanceApproveTransaction approveTokenNftAllowance(
        NftId nftId,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        requireNotFrozen();
        Objects.requireNonNull(nftId);
        getNftSerials(
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            null,
            nftId.tokenId
        ).add(nftId.serial);
        return this;
    }

    /**
     * Approve the token nft allowance on all serials.
     *
     * @param tokenId                   the token's id
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @return {@code this}
     */
    public AccountAllowanceApproveTransaction approveTokenNftAllowanceAllSerials(
        TokenId tokenId,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        requireNotFrozen();
        nftAllowances.add(new TokenNftAllowance(
            Objects.requireNonNull(tokenId),
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            null,
            Collections.emptyList(),
            true
        ));
        return this;
    }

    /**
     * Delete the token nft allowance on all serials.
     *
     * @param tokenId                   the token's id
     * @param ownerAccountId            owner's account id
     * @param spenderAccountId          spender's account id
     * @return {@code this}
     */
    public AccountAllowanceApproveTransaction deleteTokenNftAllowanceAllSerials(
        TokenId tokenId,
        @Nullable AccountId ownerAccountId,
        AccountId spenderAccountId
    ) {
        requireNotFrozen();
        nftAllowances.add(new TokenNftAllowance(
            Objects.requireNonNull(tokenId),
            ownerAccountId,
            Objects.requireNonNull(spenderAccountId),
            null,
            Collections.emptyList(),
            false
        ));
        return this;
    }

    /**
     * @deprecated - Use {@link #getTokenNftApprovals()} instead
     *
     * @return {@code this}
     */
    @Deprecated
    public List<TokenNftAllowance> getTokenNftAllowances() {
        return getTokenNftApprovals();
    }

    /**
     * Returns the list of token nft allowances.
     *
     * @return  list of token nft allowances.
     */
    public List<TokenNftAllowance> getTokenNftApprovals() {
        List<TokenNftAllowance> retval = new ArrayList<>(nftAllowances.size());
        for (var allowance : nftAllowances) {
            retval.add(TokenNftAllowance.copyFrom(allowance));
        }
        return retval;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getApproveAllowancesMethod();
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.CryptoApproveAllowanceTransactionBody builder }
     */
    CryptoApproveAllowanceTransactionBody.Builder build() {
        var builder = CryptoApproveAllowanceTransactionBody.newBuilder();

        for (var allowance : hbarAllowances) {
            builder.addCryptoAllowances(allowance.toProtobuf());
        }
        for (var allowance : tokenAllowances) {
            builder.addTokenAllowances(allowance.toProtobuf());
        }
        for (var allowance : nftAllowances) {
            builder.addNftAllowances(allowance.toProtobuf());
        }
        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoApproveAllowance(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setCryptoApproveAllowance(build());
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        for (var allowance : hbarAllowances) {
            allowance.validateChecksums(client);
        }
        for (var allowance : tokenAllowances) {
            allowance.validateChecksums(client);
        }
        for (var allowance : nftAllowances) {
            allowance.validateChecksums(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountAllowanceDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoDeleteAllowanceTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * This transaction type is for deleting an account allowance.
 */
public class AccountAllowanceDeleteTransaction extends com.hedera.hashgraph.sdk.Transaction<AccountAllowanceDeleteTransaction> {
    private final List<HbarAllowance> hbarAllowances = new ArrayList<>();
    private final List<TokenAllowance> tokenAllowances = new ArrayList<>();
    private final List<TokenNftAllowance> nftAllowances = new ArrayList<>();
    // <ownerId, <tokenId, index>>
    private final Map<AccountId, Map<TokenId, Integer>> nftMap = new HashMap<>();

    /**
     * Constructor.
     */
    public AccountAllowanceDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs                       Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException   when there is an issue with the protobuf
     */
    AccountAllowanceDeleteTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs
    ) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody                    protobuf TransactionBody
     */
    AccountAllowanceDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    private void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoDeleteAllowance();
        for (var allowanceProto : body.getNftAllowancesList()) {
            getNftSerials(
                AccountId.fromProtobuf(allowanceProto.getOwner()),
                TokenId.fromProtobuf(allowanceProto.getTokenId())
            ).addAll(allowanceProto.getSerialNumbersList());
        }
    }

    /**
     * @deprecated with no replacement
     *
     * @param ownerAccountId            the owner's account id
     * @return {@code this}
     */
    @Deprecated
    public AccountAllowanceDeleteTransaction deleteAllHbarAllowances(AccountId ownerAccountId) {
        requireNotFrozen();
        hbarAllowances.add(new HbarAllowance(Objects.requireNonNull(ownerAccountId), null, null));
        return this;
    }

    /**
     * @deprecated with no replacement
     *
     * @return                          a list of hbar allowance records
     */
    @Deprecated
    public List<HbarAllowance> getHbarAllowanceDeletions() {
        return new ArrayList<>(hbarAllowances);
    }

    /**
     * @deprecated with no replacement
     *
     * @param tokenId                   the token id
     * @param ownerAccountId            the owner's account id
     * @return {@code this}
     */
    @Deprecated
    public AccountAllowanceDeleteTransaction deleteAllTokenAllowances(TokenId tokenId, AccountId ownerAccountId) {
        requireNotFrozen();
        tokenAllowances.add(new TokenAllowance(
            Objects.requireNonNull(tokenId),
            Objects.requireNonNull(ownerAccountId),
            null,
            0
        ));
        return this;
    }

    /**
     * @deprecated with no replacement
     *
     * @return                          a list of token allowance records
     */
    @Deprecated
    public List<TokenAllowance> getTokenAllowanceDeletions() {
        return new ArrayList<>(tokenAllowances);
    }

    /**
     * Remove all nft token allowances.
     *
     * @param nftId                     nft's id
     * @param ownerAccountId            owner's account id
     * @return                          {@code this}
     */
    public AccountAllowanceDeleteTransaction deleteAllTokenNftAllowances(NftId nftId, AccountId ownerAccountId) {
        requireNotFrozen();
        Objects.requireNonNull(nftId);
        getNftSerials(Objects.requireNonNull(ownerAccountId), nftId.tokenId).add(nftId.serial);
        return this;
    }

    /**
     * Return list of nft tokens to be deleted.
     *
     * @return                          list of token nft allowances
     */
    public List<TokenNftAllowance> getTokenNftAllowanceDeletions() {
        List<TokenNftAllowance> retval = new ArrayList<>(nftAllowances.size());
        for (var allowance : nftAllowances) {
            retval.add(TokenNftAllowance.copyFrom(allowance));
        }
        return retval;
    }

    /**
     * Return list of nft serial numbers.
     *
     * @param ownerAccountId            owner's account id
     * @param tokenId                   the token's id
     * @return                          list of nft serial numbers
     */
    private List<Long> getNftSerials(@Nullable AccountId ownerAccountId, TokenId tokenId) {
        var key = ownerAccountId;
        if (nftMap.containsKey(key)) {
            var innerMap = nftMap.get(key);
            if (innerMap.containsKey(tokenId)) {
                return Objects.requireNonNull(nftAllowances.get(innerMap.get(tokenId)).serialNumbers);
            } else {
                return newNftSerials(ownerAccountId, tokenId, innerMap);
            }
        } else {
            Map<TokenId, Integer> innerMap = new HashMap<>();
            nftMap.put(key, innerMap);
            return newNftSerials(ownerAccountId, tokenId, innerMap);
        }
    }

    /**
     * Return serial numbers of new nft's.
     *
     * @param ownerAccountId            owner's account id
     * @param tokenId                   the token's id
     * @param innerMap                  list of token id's and serial number records
     * @return                          list of nft serial numbers
     */
    private List<Long> newNftSerials(
        @Nullable AccountId ownerAccountId,
        TokenId tokenId,
        Map<TokenId, Integer> innerMap
    ) {
        innerMap.put(tokenId, nftAllowances.size());
        TokenNftAllowance newAllowance = new TokenNftAllowance(
            tokenId,
            ownerAccountId,
            null,
            null,
            new ArrayList<>(),
            null
        );
        nftAllowances.add(newAllowance);
        return newAllowance.serialNumbers;
    }

    @Override
    MethodDescriptor<Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getDeleteAllowancesMethod();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link CryptoDeleteAllowanceTransactionBody}
     */
    CryptoDeleteAllowanceTransactionBody.Builder build() {
        var builder = CryptoDeleteAllowanceTransactionBody.newBuilder();
        for (var allowance : nftAllowances) {
            builder.addNftAllowances(allowance.toRemoveProtobuf());
        }
        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoDeleteAllowance(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setCryptoDeleteAllowance(build());
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        for (var allowance : nftAllowances) {
            allowance.validateChecksums(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountBalance.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoGetAccountBalanceResponse;
import com.hedera.hashgraph.sdk.proto.TokenBalance;

import javax.annotation.Nonnegative;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * This class represents the account balance object
 */
public class AccountBalance {
    /**
     * The Hbar balance of the account
     */
    @Nonnegative
    public final Hbar hbars;

    /**
     * @deprecated - Use `tokens` instead
     */
    @Deprecated
    @Nonnegative
    public final Map<TokenId, Long> token = new HashMap<>();

    public final Map<TokenId, Long> tokens;

    @Nonnegative
    public final Map<TokenId, Integer> tokenDecimals;

    AccountBalance(Hbar hbars, Map<TokenId, Long> token, Map<TokenId, Integer> decimal) {
        this.hbars = hbars;
        this.tokens = token;
        this.tokenDecimals = decimal;
    }

    /**
     * Convert the protobuf object to an account balance object.
     *
     * @param protobuf                  protobuf response object
     * @return                          the converted account balance object
     */
    static AccountBalance fromProtobuf(CryptoGetAccountBalanceResponse protobuf) {
        var balanceList = protobuf.getTokenBalancesList();
        Map<TokenId, Long> map = new HashMap<>();
        Map<TokenId, Integer> decimalMap = new HashMap<>();
        for (int i = 0; i < protobuf.getTokenBalancesCount(); i++) {
            map.put(TokenId.fromProtobuf(balanceList.get(i).getTokenId()), balanceList.get(i).getBalance());
            decimalMap.put(TokenId.fromProtobuf(balanceList.get(i).getTokenId()), balanceList.get(i).getDecimals());
        }

        return new AccountBalance(Hbar.fromTinybars(protobuf.getBalance()), map, decimalMap);
    }

    /**
     * Convert a byte array to an account balance object.
     *
     * @param data                      the byte array
     * @return                          the converted account balance object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static AccountBalance fromBytes(byte[] data) throws InvalidProtocolBufferException {
        return fromProtobuf(CryptoGetAccountBalanceResponse.parseFrom(data));
    }

    /**
     * Convert an account balance object into a protobuf.
     *
     * @return                          the protobuf object
     */
    CryptoGetAccountBalanceResponse toProtobuf() {
        var protobuf = CryptoGetAccountBalanceResponse.newBuilder()
            .setBalance(hbars.toTinybars());

        for (var entry : tokens.entrySet()) {
            protobuf.addTokenBalances(TokenBalance.newBuilder()
                .setTokenId(entry.getKey().toProtobuf())
                .setBalance(entry.getValue())
                .setDecimals(Objects.requireNonNull(tokenDecimals.get(entry.getKey())))
            );
        }

        return protobuf.build();
    }

    /**
     * Convert the account balance object to a byte array.
     *
     * @return                          the converted account balance object
     */
    public ByteString toBytes() {
        return toProtobuf().toByteString();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("hbars", hbars)
            .add("tokens", tokens)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountBalanceQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoGetAccountBalanceQuery;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Get the balance of a Hedera crypto-currency account. This returns only the balance, so it is a
 * smaller and faster reply than {@link AccountInfoQuery}.
 *
 * <p>This query is free.
 */
public final class AccountBalanceQuery extends Query<AccountBalance, AccountBalanceQuery> {
    @Nullable
    private AccountId accountId = null;
    @Nullable
    private ContractId contractId = null;

    /**
     * Constructor.
     */
    public AccountBalanceQuery() {
    }

    /**
     * Return the account's id.
     *
     * @return {@code accountId}
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * The account ID for which the balance is being requested.
     * <p>
     * This is mutually exclusive with {@link #setContractId(ContractId)}.
     *
     * @param accountId The AccountId to set
     * @return {@code this}
     */
    public AccountBalanceQuery setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * The contract ID for which the balance is being requested.
     * <p>
     * This is mutually exclusive with {@link #setAccountId(AccountId)}.
     *
     * @param contractId The ContractId to set
     * @return {@code this}
     */
    public AccountBalanceQuery setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        this.contractId = contractId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }

        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    boolean isPaymentRequired() {
        return false;
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = CryptoGetAccountBalanceQuery.newBuilder();
        if (accountId != null) {
            builder.setAccountID(accountId.toProtobuf());
        }

        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }

        queryBuilder.setCryptogetAccountBalance(builder.setHeader(header));
    }

    @Override
    AccountBalance mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return AccountBalance.fromProtobuf(response.getCryptogetAccountBalance());
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getCryptogetAccountBalance().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getCryptogetAccountBalance().getHeader();
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getCryptoGetBalanceMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Create a new Hedera account.
 */
public final class AccountCreateTransaction extends Transaction<AccountCreateTransaction> {
    @Nullable
    private AccountId proxyAccountId = null;
    @Nullable
    private Key key = null;
    private String accountMemo = "";
    private Hbar initialBalance = new Hbar(0);
    private boolean receiverSigRequired = false;
    private Duration autoRenewPeriod = DEFAULT_AUTO_RENEW_PERIOD;
    private int maxAutomaticTokenAssociations = 0;

    @Nullable
    private AccountId stakedAccountId = null;

    @Nullable
    private Long stakedNodeId = null;

    private boolean declineStakingReward = false;

    @Nullable
    private EvmAddress alias = null;

    /**
     * Constructor.
     */
    public AccountCreateTransaction() {
        defaultMaxTransactionFee = Hbar.from(5);
    }

    /**
     * Constructor.
     *
     * @param txs                                   Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    AccountCreateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody                    protobuf TransactionBody
     */
    AccountCreateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the key.
     *
     * @return                          the creating account's key
     */
    @Nullable
    public Key getKey() {
        return key;
    }

    /**
     * Set the key for this account.
     *
     * <p>The key that must sign each transfer out of the account. If receiverSignatureRequired is
     * true, then it must also sign any transfer into the account.
     *
     * @param key the key for this account.
     * @return {@code this}
     */
    public AccountCreateTransaction setKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        this.key = key;
        return this;
    }

    /**
     * Extract the amount in hbar.
     *
     * @return                          the initial balance for the new account
     */
    public Hbar getInitialBalance() {
        return initialBalance;
    }

    /**
     * Set the initial amount to transfer into this account.
     *
     * @param initialBalance the initial balance.
     * @return {@code this}
     */
    public AccountCreateTransaction setInitialBalance(Hbar initialBalance) {
        Objects.requireNonNull(initialBalance);
        requireNotFrozen();
        this.initialBalance = initialBalance;
        return this;
    }

    /**
     * Is the receiver required to sign?
     *
     * @return                          is the receiver required to sign
     */
    public boolean getReceiverSignatureRequired() {
        return receiverSigRequired;
    }

    /**
     * Set to true to require this account to sign any transfer of hbars to this account.
     *
     * <p>All transfers of hbars from this account must always be signed. This property only affects
     * transfers to this account.
     *
     * @param receiveSignatureRequired true to require a signature when receiving hbars.
     * @return {@code this}
     */
    public AccountCreateTransaction setReceiverSignatureRequired(boolean receiveSignatureRequired) {
        requireNotFrozen();
        receiverSigRequired = receiveSignatureRequired;
        return this;
    }

    /**
     * @deprecated with no replacement
     *
     * Extract the proxy account id.
     *
     * @return                          the proxy account id
     */
    @Nullable
    @Deprecated
    public AccountId getProxyAccountId() {
        return proxyAccountId;
    }

    /**
     * @deprecated with no replacement
     *
     * Set the ID of the account to which this account is proxy staked.
     *
     * @param proxyAccountId the proxy account ID.
     * @return {@code this}
     */
    @Deprecated
    public AccountCreateTransaction setProxyAccountId(AccountId proxyAccountId) {
        requireNotFrozen();
        Objects.requireNonNull(proxyAccountId);
        this.proxyAccountId = proxyAccountId;
        return this;
    }

    /**
     * Extract the duration for the auto renew period.
     *
     * @return                          the duration for auto-renew
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Set the auto renew period for this account.
     *
     * <p>A Hedera account is charged to extend its expiration date every renew period. If it
     * doesn't have enough balance, it extends as long as possible. If the balance is zero when it
     * expires, then the account is deleted.
     *
     * <p>This is defaulted to 3 months by the SDK.
     *
     * @param autoRenewPeriod the auto renew period for this account.
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public AccountCreateTransaction setAutoRenewPeriod(Duration autoRenewPeriod) {
        requireNotFrozen();
        Objects.requireNonNull(autoRenewPeriod);
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * Extract the maximum automatic token associations.
     *
     * @return                          the max automatic token associations
     */
    public int getMaxAutomaticTokenAssociations() {
        return maxAutomaticTokenAssociations;
    }

    /**
     * Grant an amount of tokens.
     *
     * @param amount                    the amount of tokens
     * @return                          {@code this}
     */
    public AccountCreateTransaction setMaxAutomaticTokenAssociations(int amount) {
        requireNotFrozen();
        maxAutomaticTokenAssociations = amount;
        return this;
    }

    /**
     * Extract the account memo.
     *
     * @return                          the account memo
     */
    public String getAccountMemo() {
        return accountMemo;
    }

    /**
     * Assign a memo to the account.
     *
     * @param memo                      the memo
     * @return                          {@code this}
     */
    public AccountCreateTransaction setAccountMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        accountMemo = memo;
        return this;
    }

    /**
     * ID of the account to which this account will stake
     *
     * @return ID of the account to which this account will stake.
     */
    @Nullable
    public AccountId getStakedAccountId() {
        return stakedAccountId;
    }

    /**
     * Set the account to which this account will stake
     *
     * @param stakedAccountId ID of the account to which this account will stake.
     * @return {@code this}
     */
    public AccountCreateTransaction setStakedAccountId(@Nullable AccountId stakedAccountId) {
        requireNotFrozen();
        this.stakedAccountId = stakedAccountId;
        this.stakedNodeId = null;
        return this;
    }

    /**
     * The node to which this account will stake
     *
     * @return ID of the node this account will be staked to.
     */
    @Nullable
    public Long getStakedNodeId() {
        return stakedNodeId;
    }

    /**
     * Set the node to which this account will stake
     *
     * @param stakedNodeId ID of the node this account will be staked to.
     * @return {@code this}
     */
    public AccountCreateTransaction setStakedNodeId(@Nullable Long stakedNodeId) {
        requireNotFrozen();
        this.stakedNodeId = stakedNodeId;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * If true, the account declines receiving a staking reward. The default value is false.
     *
     * @return If true, the account declines receiving a staking reward. The default value is false.
     */
    public boolean getDeclineStakingReward() {
        return declineStakingReward;
    }

    /**
     * If true, the account declines receiving a staking reward. The default value is false.
     *
     * @param declineStakingReward - If true, the account declines receiving a staking reward. The default value is false.
     * @return {@code this}
     */
    public AccountCreateTransaction setDeclineStakingReward(boolean declineStakingReward) {
        requireNotFrozen();
        this.declineStakingReward = declineStakingReward;
        return this;
    }

    /**
     * The bytes to be used as the account's alias.
     * <p>
     * The bytes must be formatted as the calcluated last 20 bytes of the
     * keccak-256 of the ECDSA primitive key.
     * <p>
     * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
     * delegatable_contract_id, are not supported.
     * <p>
     * At most only one account can ever have a given alias on the network.
     */
    @Nullable
    public EvmAddress getAlias() {
        return alias;
    }

    /**
     * The bytes to be used as the account's alias.
     * <p>
     * The bytes must be formatted as the calcluated last 20 bytes of the
     * keccak-256 of the ECDSA primitive key.
     * <p>
     * All other types of keys, including but not limited to ED25519, ThresholdKey, KeyList, ContractID, and
     * delegatable_contract_id, are not supported.
     * <p>
     * At most only one account can ever have a given alias on the network.
     *
     * @param alias The ethereum account 20-byte EVM address
     * @return {@code this}
     */
    public AccountCreateTransaction setAlias(EvmAddress alias) {
        requireNotFrozen();
        this.alias = alias;
        return this;
    }

    /**
     * The ethereum account 20-byte EVM address to be used as the account's alias. This EVM address may be either
     * the encoded form of the shard.realm.num or the keccak-256 hash of a ECDSA_SECP256K1 primitive key.
     * <p>
     * A given alias can map to at most one account on the network at a time. This uniqueness will be enforced
     * relative to aliases currently on the network at alias assignment.
     * <p>
     * If a transaction creates an account using an alias, any further crypto transfers to that alias will
     * simply be deposited in that account, without creating anything, and with no creation fee being charged.
     *
     * @param aliasEvmAddress The ethereum account 20-byte EVM address
     * @return {@code this}
     * @throws IllegalArgumentException when evmAddress is invalid
     */
    public AccountCreateTransaction setAlias(String aliasEvmAddress) {
        if ((aliasEvmAddress.startsWith("0x") && aliasEvmAddress.length() == 42) || aliasEvmAddress.length() == 40) {
            EvmAddress address = EvmAddress.fromString(aliasEvmAddress);
            return this.setAlias(address);
        } else {
            throw new IllegalArgumentException("evmAddress must be an a valid EVM address with \"0x\" prefix");
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.CryptoCreateTransactionBody}
     */
    CryptoCreateTransactionBody.Builder build() {
        var builder = CryptoCreateTransactionBody.newBuilder()
            .setInitialBalance(initialBalance.toTinybars())
            .setReceiverSigRequired(receiverSigRequired)
            .setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod))
            .setMemo(accountMemo)
            .setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations)
            .setDeclineReward(declineStakingReward);

        if (proxyAccountId != null) {
            builder.setProxyAccountID(proxyAccountId.toProtobuf());
        }

        if (key != null) {
            builder.setKey(key.toProtobufKey());
        }

        if (alias != null) {
            builder.setAlias(ByteString.copyFrom(alias.toBytes()));
        }

        if (stakedAccountId != null) {
            builder.setStakedAccountId(stakedAccountId.toProtobuf());
        } else if (stakedNodeId != null) {
            builder.setStakedNodeId(stakedNodeId);
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (proxyAccountId != null) {
            proxyAccountId.validateChecksum(client);
        }

        if (stakedAccountId != null) {
            stakedAccountId.validateChecksum(client);
        }
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoCreateAccount();

        if (body.hasProxyAccountID()) {
            proxyAccountId = AccountId.fromProtobuf(body.getProxyAccountID());
        }
        if (body.hasKey()) {
            key = Key.fromProtobufKey(body.getKey());
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        initialBalance = Hbar.fromTinybars(body.getInitialBalance());
        accountMemo = body.getMemo();
        receiverSigRequired = body.getReceiverSigRequired();
        maxAutomaticTokenAssociations = body.getMaxAutomaticTokenAssociations();
        declineStakingReward = body.getDeclineReward();

        if (body.hasStakedAccountId()) {
            stakedAccountId = AccountId.fromProtobuf(body.getStakedAccountId());
        }

        if (body.hasStakedNodeId()) {
            stakedNodeId = body.getStakedNodeId();
        }

        alias = EvmAddress.fromAliasBytes(body.getAlias());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getCreateAccountMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoCreateAccount(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setCryptoCreateAccount(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Marks an account as deleted, moving all its current hbars to another account.
 * <p>
 * It will remain in the ledger, marked as deleted, until it expires.
 * Transfers into it a deleted account fail. But a deleted account can still have its
 * expiration extended in the normal way.
 */
public final class AccountDeleteTransaction extends Transaction<AccountDeleteTransaction> {
    @Nullable
    private AccountId accountId = null;
    @Nullable
    private AccountId transferAccountId = null;

    /**
     * Constructor.
     */
    public AccountDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs                                   Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    AccountDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody                    protobuf TransactionBody
     */
    AccountDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Sets the account ID which should be deleted.
     *
     * @param deleteAccountId The AccountId to be set
     * @return {@code this}
     */
    public AccountDeleteTransaction setAccountId(AccountId deleteAccountId) {
        Objects.requireNonNull(deleteAccountId);
        requireNotFrozen();
        this.accountId = deleteAccountId;
        return this;
    }

    /**
     * Extract the receiving account id.
     *
     * @return                          the account id that receives the hbar
     */
    @Nullable
    public AccountId getTransferAccountId() {
        return transferAccountId;
    }

    /**
     * Sets the account ID which will receive all remaining hbars.
     *
     * @param transferAccountId The AccountId to be set
     * @return {@code this}
     */
    public AccountDeleteTransaction setTransferAccountId(AccountId transferAccountId) {
        requireNotFrozen();
        Objects.requireNonNull(transferAccountId);
        this.transferAccountId = transferAccountId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }

        if (transferAccountId != null) {
            transferAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getCryptoDeleteMethod();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link CryptoDeleteTransactionBody}
     */
    CryptoDeleteTransactionBody.Builder build() {
        var builder = CryptoDeleteTransactionBody.newBuilder();

        if (accountId != null) {
            builder.setDeleteAccountID(accountId.toProtobuf());
        }

        if (transferAccountId != null) {
            builder.setTransferAccountID(transferAccountId.toProtobuf());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoDelete();
        if (body.hasDeleteAccountID()) {
            accountId = AccountId.fromProtobuf(body.getDeleteAccountID());
        }

        if (body.hasTransferAccountID()) {
            transferAccountId = AccountId.fromProtobuf(body.getTransferAccountID());
        }
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoDelete(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setCryptoDelete(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AccountID;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.regex.Pattern;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.Hex;

/**
 * The ID for a cryptocurrency account on Hedera.
 */
public final class AccountId implements Comparable<AccountId> {
    private static final Pattern ALIAS_ID_REGEX = Pattern.compile("(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.((?:[0-9a-fA-F][0-9a-fA-F])+)$");

    /**
     * The shard number
     */
    @Nonnegative
    public final long shard;

    /**
     * The realm number
     */
    @Nonnegative
    public final long realm;

    /**
     * The id number
     */
    @Nonnegative
    public final long num;

    /**
     * The public key bytes to be used as the account's alias
     */
    @Nullable
    public final PublicKey aliasKey;

    /**
     * The ethereum account 20-byte EVM address to be used initially in place of the public key bytes
     */
    @Nullable
    public final EvmAddress evmAddress;

    @Nullable
    private final String checksum;

    /**
     * Assign the num part of the account id.
     *
     * @param num                       the num part of the account id
     */
    public AccountId(@Nonnegative long num) {
        this(0, 0, num);
    }

    /**
     * Assign all parts of the account id.
     *
     * @param shard                     the shard part of the account id
     * @param realm                     the realm part of the account id
     * @param num                       the num part of the account id
     */
    @SuppressWarnings("InconsistentOverloads")
    public AccountId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num) {
        this(shard, realm, num, null);
    }

    /**
     * Assign all parts of the account id.
     *
     * @param shard                     the shard part of the account id
     * @param realm                     the realm part of the account id
     * @param num                       the num part of the account id
     */
    @SuppressWarnings("InconsistentOverloads")
    AccountId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num, @Nullable String checksum) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
        this.aliasKey = null;
        this.evmAddress = null;
    }

    /**
     * Assign all parts of the account id.
     *
     * @param shard                     the shard part of the account id
     * @param realm                     the realm part of the account id
     * @param num                       the num part of the account id
     */
    @SuppressWarnings("InconsistentOverloads")
    AccountId(
        @Nonnegative long shard,
        @Nonnegative long realm,
        @Nonnegative long num,
        @Nullable String checksum,
        @Nullable PublicKey aliasKey,
        @Nullable EvmAddress evmAddress
    ) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
        this.aliasKey = aliasKey;
        this.evmAddress = evmAddress;
    }

    /**
     * Retrieve the account id from a string.
     *
     * @param id                        a string representing a valid account id
     * @return                          the account id object
     * @throws IllegalArgumentException when the account id and checksum are invalid
     */
    public static AccountId fromString(String id) {
        if ((id.startsWith("0x") && id.length() == 42) || id.length() == 40)
            return fromEvmAddress(id);

        try {
            return EntityIdHelper.fromString(id, AccountId::new);
        } catch (IllegalArgumentException error) {
            var match = ALIAS_ID_REGEX.matcher(id);
            if (!match.find()) {
                throw new IllegalArgumentException(
                    "Invalid Account ID \"" + id + "\": format should look like 0.0.123 or 0.0.123-vfmkw or 0.0.1337BEEF (where 1337BEEF is a hex-encoded, DER-format public key)"
                );
            } else {
                byte[] aliasBytes = Hex.decode(match.group(3));
                boolean isEvmAddress = aliasBytes.length == 20;
                return new AccountId(
                    Long.parseLong(match.group(1)),
                    Long.parseLong(match.group(2)),
                    0,
                    null,
                    isEvmAddress ? null : PublicKey.fromBytesDER(aliasBytes),
                    isEvmAddress ? EvmAddress.fromBytes(aliasBytes) : null
                );
            }
        }
    }

    /**
     * Retrieve the account id from an EVM address.
     *
     * @param evmAddress                a string representing the EVM address
     * @return                          the account id object
     */
    public static AccountId fromEvmAddress(String evmAddress) {
        return fromEvmAddress(evmAddress, 0, 0);
    }

    /**
     * Retrieve the account id from an EVM address.
     *
     * @param evmAddress                a string representing the EVM address
     * @param shard                     the shard part of the account id
     * @param realm                     the shard realm of the account id
     * @return                          the account id object
     */
    public static AccountId fromEvmAddress(String evmAddress, @Nonnegative long shard, @Nonnegative long realm) {
        return fromEvmAddress(EvmAddress.fromString(evmAddress), shard, realm);
    }

    /**
     * Retrieve the account id from an EVM address.
     *
     * @param evmAddress                an EvmAddress instance
     * @return                          the account id object
     */
    public static AccountId fromEvmAddress(EvmAddress evmAddress) {
        return fromEvmAddress(evmAddress, 0, 0);
    }

    /**
     * Retrieve the account id from an EVM address.
     *
     * @param evmAddress                an EvmAddress instance
     * @param shard                     the shard part of the account id
     * @param realm                     the shard realm of the account id
     * @return                          the account id object
     */
    public static AccountId fromEvmAddress(EvmAddress evmAddress, @Nonnegative long shard, @Nonnegative long realm) {
        return new AccountId(
            shard,
            realm,
            0,
            null,
            null,
            evmAddress
        );
    }

    /**
     * Retrieve the account id from a solidity address.
     *
     * @param address                   a string representing the address
     * @return                          the account id object
     */
    public static AccountId fromSolidityAddress(String address) {
        if (EntityIdHelper.isLongZeroAddress(EntityIdHelper.decodeSolidityAddress(address))) {
            return EntityIdHelper.fromSolidityAddress(address, AccountId::new);
        } else {
            return fromEvmAddress(address);
        }
    }

    /**
     * Retrieve the account id from a protobuf.
     *
     * @param accountId                 the protobuf
     * @return                          the account id object
     */
    static AccountId fromProtobuf(AccountID accountId) {
        PublicKey aliasKey = null;
        EvmAddress evmAddress = null;

        if (accountId.hasAlias()) {
            if (accountId.getAlias().size() == 20) {
                evmAddress = EvmAddress.fromAliasBytes(accountId.getAlias());
            } else {
               aliasKey = PublicKey.fromAliasBytes(accountId.getAlias());
            }
        }
        Objects.requireNonNull(accountId);
        return new AccountId(
            accountId.getShardNum(),
            accountId.getRealmNum(),
            accountId.getAccountNum(),
            null,
            aliasKey,
            evmAddress
        );
    }

    /**
     * Retrieve the account id from a protobuf byte array.
     *
     * @param bytes                     a byte array representation of the protobuf
     * @return                          the account id object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static AccountId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(AccountID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the solidity address.
     *
     * @return                          the solidity address as a string
     */
    public String toSolidityAddress() {
        return EntityIdHelper.toSolidityAddress(shard, realm, num);
    }

    /**
     * Extract the account id protobuf.
     *
     * @return                          the account id builder
     */
    AccountID toProtobuf() {
        var accountIdBuilder = AccountID.newBuilder()
            .setShardNum(shard)
            .setRealmNum(realm);
        if (aliasKey != null) {
            accountIdBuilder.setAlias(aliasKey.toProtobufKey().toByteString());
        } else if (evmAddress != null) {
            accountIdBuilder.setAlias(ByteString.copyFrom(evmAddress.toBytes()));
        }else {
            accountIdBuilder.setAccountNum(num);
        }
        return accountIdBuilder.build();
    }

    /**
     * Gets the actual `num` field of the `AccountId` from the Mirror Node.
     * Should be used after generating `AccountId.fromEvmAddress()` because it sets the `num` field to `0`
     * automatically since there is no connection between the `num` and the `evmAddress`
     * Sync version
     *
     * @param client
     * @return populated AccountId instance
     */
    public AccountId populateAccountNum(Client client) throws InterruptedException, ExecutionException {
        return populateAccountNumAsync(client).get();
    }

    /**
     * Gets the actual `num` field of the `AccountId` from the Mirror Node.
     * Should be used after generating `AccountId.fromEvmAddress()` because it sets the `num` field to `0`
     * automatically since there is no connection between the `num` and the `evmAddress`
     * Async version
     *
     * @deprecated Use 'populateAccountNum' instead due to its nearly identical operation.
     * @param client
     * @return populated AccountId instance
     */
    @Deprecated
    public CompletableFuture<AccountId> populateAccountNumAsync(Client client) {
        return EntityIdHelper.getAccountNumFromMirrorNodeAsync(client, evmAddress.toString())
            .thenApply(accountNumFromMirrorNode ->
                new AccountId(
                    this.shard,
                    this.realm,
                    accountNumFromMirrorNode,
                    this.checksum,
                    this.aliasKey,
                    this.evmAddress));
    }

    /**
     * Populates `evmAddress` field of the `AccountId` extracted from the Mirror Node.
     * Sync version
     *
     * @param client
     * @return populated AccountId instance
     */
    public AccountId populateAccountEvmAddress(Client client) throws ExecutionException, InterruptedException {
        return populateAccountEvmAddressAsync(client).get();
    }

    /**
     * Populates `evmAddress` field of the `AccountId` extracted from the Mirror Node.
     * Async version
     *
     * @deprecated Use 'populateAccountEvmAddress' instead due to its nearly identical operation.
     * @param client
     * @return populated AccountId instance
     */
    @Deprecated
    public CompletableFuture<AccountId> populateAccountEvmAddressAsync(Client client) {
        return EntityIdHelper.getEvmAddressFromMirrorNodeAsync(client, num)
            .thenApply(evmAddressFromMirrorNode ->
                new AccountId(
                    this.shard,
                    this.realm,
                    this.num,
                    this.checksum,
                    this.aliasKey,
                    evmAddressFromMirrorNode));
    }

    /**
     * @param client to validate against
     * @throws BadEntityIdException if entity ID is formatted poorly
     * @deprecated Use {@link #validateChecksum(Client)} instead.
     */
    @Deprecated
    public void validate(Client client) throws BadEntityIdException {
        validateChecksum(client);
    }

    /**
     * Verify that the client has a valid checksum.
     *
     * @param client                    the client to verify
     * @throws BadEntityIdException     when the account id and checksum are invalid
     */
    public void validateChecksum(Client client) throws BadEntityIdException {
        if (aliasKey == null && evmAddress == null) {
            EntityIdHelper.validate(shard, realm, num, client, checksum);
        }
    }

    /**
     * Extract the checksum.
     *
     * @return                          the checksum
     */
    @Nullable
    public String getChecksum() {
        return checksum;
    }

    /**
     * Extract a byte array representation.
     *
     * @return                          a byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        if (aliasKey != null) {
            return "" + shard + "." + realm + "." + aliasKey.toStringDER();
        } else if (evmAddress != null) {
            return "" + shard + "." + realm + "." + evmAddress.toString();
        } else {
            return EntityIdHelper.toString(shard, realm, num);
        }
    }

    /**
     * Extract a string representation with the checksum.
     *
     * @param client                    the client
     * @return                          the account id with checksum
     */
    public String toStringWithChecksum(Client client) {
        if (aliasKey != null || evmAddress != null) {
            throw new IllegalStateException("toStringWithChecksum cannot be applied to AccountId with aliasKey or evmAddress");
        } else {
            return EntityIdHelper.toStringWithChecksum(shard, realm, num, client, checksum);
        }
    }

    @Override
    public int hashCode() {
        byte[] aliasBytes = null;

        if (aliasKey != null) {
            aliasBytes = aliasKey.toBytes();
        } else if (evmAddress != null) {
            aliasBytes = evmAddress.toBytes();
        }

        return Objects.hash(
            shard, realm, num, Arrays.hashCode(aliasBytes)
        );
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof AccountId)) {
            return false;
        }

        AccountId otherId = (AccountId) o;
        if ((aliasKey == null) != (otherId.aliasKey == null)) {
            return false;
        }
        if ((evmAddress == null) != (otherId.evmAddress == null)) {
            return false;
        }
        return shard == otherId.shard && realm == otherId.realm && num == otherId.num &&
            (aliasKey == null || aliasKey.equals(otherId.aliasKey)) &&
            (evmAddress == null || evmAddress.equals(otherId.evmAddress));
    }

    @Override
    public int compareTo(AccountId o) {
        Objects.requireNonNull(o);
        int shardComparison = Long.compare(shard, o.shard);
        if (shardComparison != 0) {
            return shardComparison;
        }
        int realmComparison = Long.compare(realm, o.realm);
        if (realmComparison != 0) {
            return realmComparison;
        }
        int numComparison = Long.compare(num, o.num);
        if (numComparison != 0) {
            return numComparison;
        }
        if ((aliasKey == null) != (o.aliasKey == null)) {
            return aliasKey != null ? 1 : -1;
        }
        if (aliasKey != null) {
            return aliasKey.toStringDER().compareTo(o.aliasKey.toStringDER());
        }
        if ((evmAddress == null) != (o.evmAddress == null)) {
            return evmAddress != null ? 1 : -1;
        }
        if (evmAddress == null) {
            return 0;
        }
        return evmAddress.toString().compareTo(o.evmAddress.toString());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static java.util.stream.Collectors.toList;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoGetInfoResponse;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Current information about an account, including the balance.
 */
public final class AccountInfo {
    /**
     * The account ID for which this information applies.
     */
    public final AccountId accountId;

    /**
     * The Contract Account ID comprising both the contract instance and the cryptocurrency account owned by the
     * contract instance, in the format used by Solidity.
     */
    public final String contractAccountId;

    /**
     * If true, then this account has been deleted, it will disappear when it expires, and all transactions for it will
     * fail except the transaction to extend its expiration date.
     */
    public final boolean isDeleted;

    /**
     * The Account ID of the account to which this is proxy staked. If proxyAccountID is null, or is an invalid account,
     * or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the
     * network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it
     * is not currently running a node, then it will behave as if proxyAccountID was null.
     */
    @Nullable
    public final AccountId proxyAccountId;

    /**
     * The total proxy staked to this account.
     */
    public final Hbar proxyReceived;

    /**
     * The key for the account, which must sign in order to transfer out, or to modify the account in any way other than
     * extending its expiration date.
     */
    public final Key key;

    /**
     * The current balance of account.
     */
    public final Hbar balance;

    /**
     * The threshold amount for which an account record is created (and this account charged for them) for any
     * send/withdraw transaction.
     */
    public final Hbar sendRecordThreshold;

    /**
     * The threshold amount for which an account record is created (and this account charged for them) for any
     * transaction above this amount.
     */
    public final Hbar receiveRecordThreshold;

    /**
     * If true, no transaction can transfer to this account unless signed by this account's key.
     */
    public final boolean isReceiverSignatureRequired;

    /**
     * The time at which this account is set to expire.
     */
    public final Instant expirationTime;

    /**
     * The duration for expiration time will extend every this many seconds. If there are insufficient funds, then it
     * extends as long as possible. If it is empty when it expires, then it is deleted.
     */
    public final Duration autoRenewPeriod;

    /**
     * All the livehashes attached to the account (each of which is a hash along with the keys that authorized it and
     * can delete it)
     */
    public final List<LiveHash> liveHashes;

    public final Map<TokenId, TokenRelationship> tokenRelationships;

    /**
     * The memo associated with the account
     */
    public final String accountMemo;

    /**
     * The number of NFTs owned by this account
     */
    public final long ownedNfts;

    /**
     * The maximum number of tokens that an Account can be implicitly associated with.
     */
    public final int maxAutomaticTokenAssociations;

    /**
     * The public key which aliases to this account.
     */
    @Nullable
    public final PublicKey aliasKey;

    /**
     * The ledger ID the response was returned from; please see <a
     * href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the
     * network-specific IDs.
     */
    public final LedgerId ledgerId;

    /**
     * The ethereum transaction nonce associated with this account.
     */
    public final long ethereumNonce;

    /**
     * List of Hbar allowances
     */
    @Deprecated
    public final List<HbarAllowance> hbarAllowances;

    /**
     * List of token allowances
     */
    @Deprecated
    public final List<TokenAllowance> tokenAllowances;

    /**
     * List of NFT allowances
     */
    @Deprecated
    public final List<TokenNftAllowance> tokenNftAllowances;

    /**
     * Staking metadata for this account.
     */
    @Nullable
    public final StakingInfo stakingInfo;

    /**
     * Constructor.
     *
     * @param accountId                     the account id
     * @param contractAccountId             the contracts account id
     * @param isDeleted                     is it deleted
     * @param proxyAccountId                the proxy account's id
     * @param proxyReceived                 amount of proxy received
     * @param key                           signing key
     * @param balance                       account balance
     * @param sendRecordThreshold           @depreciated no replacement
     * @param receiveRecordThreshold        @depreciated no replacement
     * @param receiverSignatureRequired     is the receiver's signature required
     * @param expirationTime                the expiration time
     * @param autoRenewPeriod               the auto renew period
     * @param liveHashes                    the live hashes
     * @param tokenRelationships            list of token id and token relationship records
     * @param accountMemo                   the account memo
     * @param ownedNfts                     number of nft's
     * @param maxAutomaticTokenAssociations max number of token associations
     * @param aliasKey                      public alias key
     * @param ledgerId                      the ledger id
     */
    private AccountInfo(
        AccountId accountId,
        String contractAccountId,
        boolean isDeleted,
        @Nullable AccountId proxyAccountId,
        long proxyReceived,
        Key key,
        long balance,
        long sendRecordThreshold,
        long receiveRecordThreshold,
        boolean receiverSignatureRequired,
        Instant expirationTime,
        Duration autoRenewPeriod,
        List<LiveHash> liveHashes,
        Map<TokenId, TokenRelationship> tokenRelationships,
        String accountMemo,
        long ownedNfts,
        int maxAutomaticTokenAssociations,
        @Nullable PublicKey aliasKey,
        LedgerId ledgerId,
        long ethereumNonce,
        @Nullable StakingInfo stakingInfo
    ) {
        this.accountId = accountId;
        this.contractAccountId = contractAccountId;
        this.isDeleted = isDeleted;
        this.proxyAccountId = proxyAccountId;
        this.proxyReceived = Hbar.fromTinybars(proxyReceived);
        this.key = key;
        this.balance = Hbar.fromTinybars(balance);
        this.sendRecordThreshold = Hbar.fromTinybars(sendRecordThreshold);
        this.receiveRecordThreshold = Hbar.fromTinybars(receiveRecordThreshold);
        this.isReceiverSignatureRequired = receiverSignatureRequired;
        this.expirationTime = expirationTime;
        this.autoRenewPeriod = autoRenewPeriod;
        this.liveHashes = liveHashes;
        this.tokenRelationships = Collections.unmodifiableMap(tokenRelationships);
        this.accountMemo = accountMemo;
        this.ownedNfts = ownedNfts;
        this.maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;
        this.aliasKey = aliasKey;
        this.ledgerId = ledgerId;
        this.ethereumNonce = ethereumNonce;
        this.hbarAllowances = Collections.emptyList();
        this.tokenAllowances = Collections.emptyList();
        this.tokenNftAllowances = Collections.emptyList();
        this.stakingInfo = stakingInfo;
    }

    /**
     * Retrieve the account info from a protobuf.
     *
     * @param accountInfo the account info protobuf
     * @return the account info object
     */
    static AccountInfo fromProtobuf(CryptoGetInfoResponse.AccountInfo accountInfo) {
        var accountId = AccountId.fromProtobuf(accountInfo.getAccountID());

        var proxyAccountId = accountInfo.getProxyAccountID().getAccountNum() > 0
            ? AccountId.fromProtobuf(accountInfo.getProxyAccountID())
            : null;

        var liveHashes = Arrays.stream(accountInfo.getLiveHashesList().toArray())
            .map((liveHash) -> LiveHash.fromProtobuf((com.hedera.hashgraph.sdk.proto.LiveHash) liveHash))
            .collect(toList());

        Map<TokenId, TokenRelationship> relationships = new HashMap<>();

        for (com.hedera.hashgraph.sdk.proto.TokenRelationship relationship : accountInfo.getTokenRelationshipsList()) {
            TokenId tokenId = TokenId.fromProtobuf(relationship.getTokenId());
            relationships.put(tokenId, TokenRelationship.fromProtobuf(relationship));
        }

        @Nullable
        var aliasKey = PublicKey.fromAliasBytes(accountInfo.getAlias());

        return new AccountInfo(
            accountId,
            accountInfo.getContractAccountID(),
            accountInfo.getDeleted(),
            proxyAccountId,
            accountInfo.getProxyReceived(),
            Key.fromProtobufKey(accountInfo.getKey()),
            accountInfo.getBalance(),
            accountInfo.getGenerateSendRecordThreshold(),
            accountInfo.getGenerateReceiveRecordThreshold(),
            accountInfo.getReceiverSigRequired(),
            InstantConverter.fromProtobuf(accountInfo.getExpirationTime()),
            DurationConverter.fromProtobuf(accountInfo.getAutoRenewPeriod()),
            liveHashes,
            relationships,
            accountInfo.getMemo(),
            accountInfo.getOwnedNfts(),
            accountInfo.getMaxAutomaticTokenAssociations(),
            aliasKey,
            LedgerId.fromByteString(accountInfo.getLedgerId()),
            accountInfo.getEthereumNonce(),
            accountInfo.hasStakingInfo() ? StakingInfo.fromProtobuf(accountInfo.getStakingInfo()) : null
        );
    }

    /**
     * Retrieve the account info from a protobuf byte array.
     *
     * @param bytes a byte array representing the protobuf
     * @return the account info object
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    public static AccountInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(CryptoGetInfoResponse.AccountInfo.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Convert an account info object into a protobuf.
     *
     * @return the protobuf object
     */
    CryptoGetInfoResponse.AccountInfo toProtobuf() {
        var hashes = Arrays.stream(liveHashes.toArray())
            .map((liveHash) -> ((LiveHash) liveHash).toProtobuf())
            .collect(toList());

        var accountInfoBuilder = CryptoGetInfoResponse.AccountInfo.newBuilder()
            .setAccountID(accountId.toProtobuf())
            .setDeleted(isDeleted)
            .setProxyReceived(proxyReceived.toTinybars())
            .setKey(key.toProtobufKey())
            .setBalance(balance.toTinybars())
            .setGenerateSendRecordThreshold(sendRecordThreshold.toTinybars())
            .setGenerateReceiveRecordThreshold(receiveRecordThreshold.toTinybars())
            .setReceiverSigRequired(isReceiverSignatureRequired)
            .setExpirationTime(InstantConverter.toProtobuf(expirationTime))
            .setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod))
            .addAllLiveHashes(hashes)
            .setMemo(accountMemo)
            .setOwnedNfts(ownedNfts)
            .setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations)
            .setLedgerId(ledgerId.toByteString())
            .setEthereumNonce(ethereumNonce);

        if (contractAccountId != null) {
            accountInfoBuilder.setContractAccountID(contractAccountId);
        }

        if (proxyAccountId != null) {
            accountInfoBuilder.setProxyAccountID(proxyAccountId.toProtobuf());
        }

        if (aliasKey != null) {
            accountInfoBuilder.setAlias(aliasKey.toProtobufKey().toByteString());
        }

        if (stakingInfo != null) {
            accountInfoBuilder.setStakingInfo(stakingInfo.toProtobuf());
        }

        return accountInfoBuilder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("accountId", accountId)
            .add("contractAccountId", contractAccountId)
            .add("deleted", isDeleted)
            .add("proxyAccountId", proxyAccountId)
            .add("proxyReceived", proxyReceived)
            .add("key", key)
            .add("balance", balance)
            .add("sendRecordThreshold", sendRecordThreshold)
            .add("receiveRecordThreshold", receiveRecordThreshold)
            .add("receiverSignatureRequired", isReceiverSignatureRequired)
            .add("expirationTime", expirationTime)
            .add("autoRenewPeriod", autoRenewPeriod)
            .add("liveHashes", liveHashes)
            .add("tokenRelationships", tokenRelationships)
            .add("accountMemo", accountMemo)
            .add("ownedNfts", ownedNfts)
            .add("maxAutomaticTokenAssociations", maxAutomaticTokenAssociations)
            .add("aliasKey", aliasKey)
            .add("ledgerId", ledgerId)
            .add("ethereumNonce", ethereumNonce)
            .add("stakingInfo", stakingInfo)
            .toString();
    }

    /**
     * Extract a byte array representation.
     *
     * @return a byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountInfoFlow.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;

/**
 * Account Info Flow object.
 */
public class AccountInfoFlow {

    private static PublicKey getAccountPublicKey(
        Client client,
        AccountId accountId
    ) throws PrecheckStatusException, TimeoutException {
        return requirePublicKey(accountId, new AccountInfoQuery().setAccountId(accountId).execute(client).key);
    }

    private static CompletableFuture<PublicKey> getAccountPublicKeyAsync(Client client, AccountId accountId) {
        return new AccountInfoQuery().setAccountId(accountId).executeAsync(client).thenApply(accountInfo -> {
            return requirePublicKey(accountId, accountInfo.key);
        });
    }

    private static PublicKey requirePublicKey(AccountId accountId, Key key) {
        if (key instanceof PublicKey k) {
            return k;
        }
        throw new UnsupportedOperationException("Account " + accountId + " has a KeyList key, which is not supported");
    }

    /**
     * Is the signature valid.
     *
     * @param client    the client
     * @param accountId the account id
     * @param message   the message
     * @param signature the signature
     * @return is the signature valid
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public static boolean verifySignature(
        Client client,
        AccountId accountId,
        byte[] message,
        byte[] signature
    ) throws PrecheckStatusException, TimeoutException {
        return getAccountPublicKey(client, accountId).verify(message, signature);
    }

    /**
     * Is the transaction signature valid.
     *
     * @param client      the client
     * @param accountId   the account id
     * @param transaction the signed transaction
     * @return is the transaction signature valid
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public static boolean verifyTransactionSignature(
        Client client,
        AccountId accountId,
        Transaction<?> transaction
    ) throws PrecheckStatusException, TimeoutException {
        return getAccountPublicKey(client, accountId).verifyTransaction(transaction);
    }

    /**
     * Asynchronously determine if the signature is valid.
     *
     * @param client    the client
     * @param accountId the account id
     * @param message   the message
     * @param signature the signature
     * @return is the signature valid
     */
    public static CompletableFuture<Boolean> verifySignatureAsync(
        Client client,
        AccountId accountId,
        byte[] message,
        byte[] signature
    ) {
        return getAccountPublicKeyAsync(client, accountId).thenApply(pubKey -> pubKey.verify(message, signature));
    }

    /**
     * Asynchronously determine if the signature is valid.
     *
     * @param client      the client
     * @param accountId   the account id
     * @param transaction the signed transaction
     * @return is the signature valid
     */
    public static CompletableFuture<Boolean> verifyTransactionSignatureAsync(
        Client client,
        AccountId accountId,
        Transaction<?> transaction
    ) {
        return getAccountPublicKeyAsync(client, accountId).thenApply(pubKey -> pubKey.verifyTransaction(transaction));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoGetInfoQuery;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Get all the information about an account, including the balance.
 * This does not get the list of account records.
 */
public final class AccountInfoQuery extends Query<AccountInfo, AccountInfoQuery> {

    @Nullable
    private AccountId accountId = null;

    /**
     * Constructor.
     */
    public AccountInfoQuery() {
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Sets the account ID for which information is requested.
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public AccountInfoQuery setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        this.accountId = accountId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = CryptoGetInfoQuery.newBuilder();

        if (accountId != null) {
            builder.setAccountID(accountId.toProtobuf());
        }

        queryBuilder.setCryptoGetInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getCryptoGetInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getCryptoGetInfo().getHeader();
    }

    @Override
    AccountInfo mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return AccountInfo.fromProtobuf(response.getCryptoGetInfo().getAccountInfo());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getGetAccountInfoMethod();
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `ACCOUNT_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountRecordsQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoGetAccountRecordsQuery;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Get all the records for an account for any transfers into it and out of it,
 * that were above the threshold, during the last 25 hours.
 */
public final class AccountRecordsQuery extends Query<List<TransactionRecord>, AccountRecordsQuery> {
    @Nullable
    private AccountId accountId = null;

    /**
     * Constructor.
     */
    public AccountRecordsQuery() {
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Sets the account ID for which the records should be retrieved.
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public AccountRecordsQuery setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        this.accountId = accountId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = CryptoGetAccountRecordsQuery.newBuilder();

        if (accountId != null) {
            builder.setAccountID(accountId.toProtobuf());
        }

        queryBuilder.setCryptoGetAccountRecords(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getCryptoGetAccountRecords().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getCryptoGetAccountRecords().getHeader();
    }

    @Override
    List<TransactionRecord> mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        var rawTransactionRecords = response.getCryptoGetAccountRecords().getRecordsList();
        var transactionRecords = new ArrayList<TransactionRecord>(rawTransactionRecords.size());

        for (var record : rawTransactionRecords) {
            transactionRecords.add(TransactionRecord.fromProtobuf(record));
        }

        return transactionRecords;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getGetAccountRecordsMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountStakersQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoGetStakersQuery;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Get all the accounts that are proxy staking to this account.
 * For each of them, give the amount currently staked.
 * <p>
 * This is not yet implemented, but will be in a future version of the API.
 */
public final class AccountStakersQuery extends Query<List<ProxyStaker>, AccountStakersQuery> {
    @Nullable
    private AccountId accountId = null;

    /**
     * Constructor.
     */
    public AccountStakersQuery() {
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Sets the Account ID for which the records should be retrieved.
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public AccountStakersQuery setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        this.accountId = accountId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = CryptoGetStakersQuery.newBuilder();

        if (accountId != null) {
            builder.setAccountID(accountId.toProtobuf());
        }

        queryBuilder.setCryptoGetProxyStakers(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getCryptoGetProxyStakers().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getCryptoGetProxyStakers().getHeader();
    }

    @Override
    List<ProxyStaker> mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        var rawStakers = response.getCryptoGetProxyStakers().getStakers();
        var stakers = new ArrayList<ProxyStaker>(rawStakers.getProxyStakerCount());

        for (var i = 0; i < rawStakers.getProxyStakerCount(); ++i) {
            stakers.add(ProxyStaker.fromProtobuf(rawStakers.getProxyStaker(i)));
        }

        return stakers;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getGetStakersByAccountIDMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AccountUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.BoolValue;
import com.google.protobuf.Int32Value;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.CryptoUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Change properties for the given account.
 * <p>
 * Any null field is ignored (left unchanged).
 * <p>
 * This transaction must be signed by the existing key for this account.
 * <p>
 * If the transaction is changing the key field, then the transaction must be signed by
 * both the old key (from before the change) and the new key. The old key must sign for security.
 * The new key must sign as a safeguard to avoid accidentally
 * changing to an invalid key, and then having no way to recover.
 * <p>
 * When extending the expiration date, the cost is affected by the size
 * of the list of attached claims, and of the keys
 * associated with the claims and the account.
 */
public final class AccountUpdateTransaction extends Transaction<AccountUpdateTransaction> {
    @Nullable
    private AccountId accountId = null;
    @Nullable
    private AccountId proxyAccountId = null;
    @Nullable
    private Key key = null;
    @Nullable
    private Instant expirationTime = null;
    @Nullable
    private Duration autoRenewPeriod = null;
    @Nullable
    private Boolean receiverSigRequired = null;
    @Nullable
    private String accountMemo = null;
    @Nullable
    private Integer maxAutomaticTokenAssociations = null;
    @Nullable
    private Key aliasKey;

    @Nullable
    private AccountId stakedAccountId = null;

    @Nullable
    private Long stakedNodeId = null;

    @Nullable
    private Boolean declineStakingReward = null;

    /**
     * Constructor.
     */
    public AccountUpdateTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs                       Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    AccountUpdateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody                    protobuf TransactionBody
     */
    AccountUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Sets the account ID which is being updated in this transaction.
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public AccountUpdateTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the key.
     *
     * @return                          the key
     */
    @Nullable
    public Key getKey() {
        return key;
    }

    /**
     * Sets the new key.
     *
     * @param key The Key to be set
     * @return {@code this}
     */
    public AccountUpdateTransaction setKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        this.key = key;
        return this;
    }

    /**
     * @deprecated with no replacement
     * @return the alias key
     */
    @Deprecated
    @Nullable
    public Key getAliasKey() {
        return aliasKey;
    }

    /**
     * @deprecated with no replacement
     *
     * Sets the new key.
     *
     * @param aliasKey The Key to be set
     * @return {@code this}
     */
    @Deprecated
    public AccountUpdateTransaction setAliasKey(Key aliasKey) {
        Objects.requireNonNull(aliasKey);
        requireNotFrozen();
        this.aliasKey = aliasKey;
        return this;
    }

    /**
     * Extract the proxy account id.
     *
     * @return                          the proxy account id
     */
    @Nullable
    public AccountId getProxyAccountId() {
        return proxyAccountId;
    }

    /**
     * Sets the ID of the account to which this account is proxy staked.
     * <p>
     * If proxyAccountID is null, or is an invalid account, or is an account
     * that isn't a node, then this account is automatically proxy staked to
     * a node chosen by the network, but without earning payments.
     * <p>
     * If the proxyAccountID account refuses to accept proxy staking, or
     * if it is not currently running a node, then it
     * will behave as if proxyAccountID was null.
     *
     * @param proxyAccountId The AccountId to be set
     * @return {@code this}
     */
    public AccountUpdateTransaction setProxyAccountId(AccountId proxyAccountId) {
        Objects.requireNonNull(proxyAccountId);
        requireNotFrozen();
        this.proxyAccountId = proxyAccountId;
        return this;
    }

    /**
     * Extract the expiration time.
     *
     * @return                          the expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Sets the new expiration time to extend to (ignored if equal to or
     * before the current one).
     *
     * @param expirationTime The Instant to be set as the expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public AccountUpdateTransaction setExpirationTime(Instant expirationTime) {
        Objects.requireNonNull(expirationTime);
        requireNotFrozen();
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Sets the duration in which it will automatically extend the expiration period.
     * <p>
     * If it doesn't have enough balance, it extends as long as possible.
     * If it is empty when it expires, then it is deleted.
     *
     * @param autoRenewPeriod The Duration to be set for auto renewal
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public AccountUpdateTransaction setAutoRenewPeriod(Duration autoRenewPeriod) {
        Objects.requireNonNull(autoRenewPeriod);
        requireNotFrozen();
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * Is the receiver required to sign?
     *
     * @return                          is the receiver required to sign
     */
    @Nullable
    public Boolean getReceiverSignatureRequired() {
        return receiverSigRequired;
    }

    /**
     * Sets whether this account's key must sign any transaction
     * depositing into this account (in addition to all withdrawals).
     *
     * @param receiverSignatureRequired The bool to be set
     * @return {@code this}
     */
    public AccountUpdateTransaction setReceiverSignatureRequired(boolean receiverSignatureRequired) {
        requireNotFrozen();
        receiverSigRequired = receiverSignatureRequired;
        return this;
    }

    /**
     * Extract the maximum automatic token associations.
     *
     * @return                          the max automatic token associations
     */
    @Nullable
    public Integer getMaxAutomaticTokenAssociations() {
        return maxAutomaticTokenAssociations;
    }

    /**
     * Grant an amount of tokens.
     *
     * @param amount                    the amount of tokens
     * @return                          {@code this}
     */
    public AccountUpdateTransaction setMaxAutomaticTokenAssociations(int amount) {
        requireNotFrozen();
        maxAutomaticTokenAssociations = amount;
        return this;
    }

    /**
     * Extract the account memo.
     *
     * @return                          the account memo
     */
    @Nullable
    public String getAccountMemo() {
        return accountMemo;
    }

    /**
     * Assign a memo to the account.
     *
     * @param memo                      the memo
     * @return                          {@code this}
     */
    public AccountUpdateTransaction setAccountMemo(String memo) {
        requireNotFrozen();
        Objects.requireNonNull(memo);
        accountMemo = memo;
        return this;
    }

    /**
     * Erase the memo field.
     *
     * @return {@code this}
     */
    public AccountUpdateTransaction clearMemo() {
        requireNotFrozen();
        accountMemo = "";
        return this;
    }

    /**
     * ID of the account to which this account will stake
     *
     * @return ID of the account to which this account will stake.
     */
    @Nullable
    public AccountId getStakedAccountId() {
        return stakedAccountId;
    }

    /**
     * Set the account to which this account will stake
     *
     * @param stakedAccountId ID of the account to which this account will stake.
     * @return {@code this}
     */
    public AccountUpdateTransaction setStakedAccountId(@Nullable AccountId stakedAccountId) {
        requireNotFrozen();
        this.stakedAccountId = stakedAccountId;
        this.stakedNodeId = null;
        return this;
    }

    /**
     * Clear the staked account ID
     *
     * @return {@code this}
     */
    public AccountUpdateTransaction clearStakedAccountId() {
        requireNotFrozen();
        this.stakedAccountId = new AccountId(0);
        this.stakedNodeId = null;
        return this;
    }

    /**
     * The node to which this account will stake
     *
     * @return ID of the node this account will be staked to.
     */
    @Nullable
    public Long getStakedNodeId() {
        return stakedNodeId;
    }

    /**
     * Set the node to which this account will stake
     *
     * @param stakedNodeId ID of the node this account will be staked to.
     * @return {@code this}
     */
    public AccountUpdateTransaction setStakedNodeId(@Nullable Long stakedNodeId) {
        requireNotFrozen();
        this.stakedNodeId = stakedNodeId;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * Clear the staked node
     *
     * @return {@code this}
     */
    public AccountUpdateTransaction clearStakedNodeId() {
        requireNotFrozen();
        this.stakedNodeId = -1L;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * If true, the account declines receiving a staking reward. The default value is false.
     *
     * @return If true, the account declines receiving a staking reward. The default value is false.
     */
    @Nullable
    public Boolean getDeclineStakingReward() {
        return declineStakingReward;
    }

    /**
     * If true, the account declines receiving a staking reward. The default value is false.
     *
     * @param declineStakingReward - If true, the account declines receiving a staking reward. The default value is false.
     * @return {@code this}
     */
    public AccountUpdateTransaction setDeclineStakingReward(boolean declineStakingReward) {
        requireNotFrozen();
        this.declineStakingReward = declineStakingReward;
        return this;
    }

    /**
     * Clear decline staking reward
     *
     * @return {@code this}
     */
    public AccountUpdateTransaction clearDeclineStakingReward() {
        requireNotFrozen();
        this.declineStakingReward = null;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
        if (proxyAccountId != null) {
            proxyAccountId.validateChecksum(client);
        }

        if (stakedAccountId != null) {
            stakedAccountId.validateChecksum(client);
        }
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoUpdateAccount();

        if (body.hasAccountIDToUpdate()) {
            accountId = AccountId.fromProtobuf(body.getAccountIDToUpdate());
        }
        if (body.hasProxyAccountID()) {
            proxyAccountId = AccountId.fromProtobuf(body.getProxyAccountID());
        }
        if (body.hasKey()) {
            key = Key.fromProtobufKey(body.getKey());
        }
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        if (body.hasReceiverSigRequiredWrapper()) {
            receiverSigRequired = body.getReceiverSigRequiredWrapper().getValue();
        }
        if (body.hasMemo()) {
            accountMemo = body.getMemo().getValue();
        }
        if (body.hasMaxAutomaticTokenAssociations()) {
            maxAutomaticTokenAssociations = body.getMaxAutomaticTokenAssociations().getValue();
        }

        if (body.hasDeclineReward()) {
            declineStakingReward = body.getDeclineReward().getValue();
        }

        if (body.hasStakedAccountId()) {
            stakedAccountId = AccountId.fromProtobuf(body.getStakedAccountId());
        }

        if (body.hasStakedNodeId()) {
            stakedNodeId = body.getStakedNodeId();
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getUpdateAccountMethod();
    }

    /**
     * Create the builder.
     *
     * @return                          the transaction builder
     */
    CryptoUpdateTransactionBody.Builder build() {
        var builder = CryptoUpdateTransactionBody.newBuilder();
        if (accountId != null) {
            builder.setAccountIDToUpdate(accountId.toProtobuf());
        }
        if (proxyAccountId != null) {
            builder.setProxyAccountID(proxyAccountId.toProtobuf());
        }
        if (key != null) {
            builder.setKey(key.toProtobufKey());
        }
        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        if (receiverSigRequired != null) {
            builder.setReceiverSigRequiredWrapper(BoolValue.of(receiverSigRequired));
        }
        if (accountMemo != null) {
            builder.setMemo(StringValue.of(accountMemo));
        }
        if (maxAutomaticTokenAssociations != null) {
            builder.setMaxAutomaticTokenAssociations(Int32Value.of(maxAutomaticTokenAssociations));
        }

        if (stakedAccountId != null) {
            builder.setStakedAccountId(stakedAccountId.toProtobuf());
        } else if (stakedNodeId != null) {
            builder.setStakedNodeId(stakedNodeId);
        }

        if (declineStakingReward != null) {
            builder.setDeclineReward(BoolValue.newBuilder().setValue(declineStakingReward).build());
        }

        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoUpdateAccount(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setCryptoUpdateAccount(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AddressBookQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.mirror.NetworkServiceGrpc;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.CallOptions;
import io.grpc.ClientCall;
import io.grpc.Deadline;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.ClientCalls;
import io.grpc.stub.StreamObserver;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Query the mirror node for the address book.
 */
public class AddressBookQuery {
    private static final Logger LOGGER = LoggerFactory.getLogger(AddressBookQuery.class);

    @Nullable
    private FileId fileId = null;
    @Nullable
    private Integer limit = null;
    private int maxAttempts = 10;
    private Duration maxBackoff = Duration.ofSeconds(8L);

    /**
     * Constructor.
     */
    public AddressBookQuery() {
    }

    private static boolean shouldRetry(Throwable throwable) {
        if (throwable instanceof StatusRuntimeException statusRuntimeException) {
            var code = statusRuntimeException.getStatus().getCode();
            var description = statusRuntimeException.getStatus().getDescription();

            return (code == io.grpc.Status.Code.UNAVAILABLE) ||
                (code == io.grpc.Status.Code.RESOURCE_EXHAUSTED) ||
                (code == Status.Code.INTERNAL && description != null && Executable.RST_STREAM.matcher(description)
                    .matches());
        }

        return false;
    }

    /**
     * Extract the file id.
     *
     * @return the file id that was assigned
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * Assign the file id of address book to retrieve.
     *
     * @param fileId the file id of the address book
     * @return {@code this}
     */
    public AddressBookQuery setFileId(FileId fileId) {
        this.fileId = fileId;
        return this;
    }

    /**
     * Extract the limit number.
     *
     * @return the limit number that was assigned
     */
    @Nullable
    public Integer getLimit() {
        return limit;
    }

    /**
     * Assign the number of node addresses to retrieve or all nodes set to 0.
     *
     * @param limit number of node addresses to get
     * @return {@code this}
     */
    public AddressBookQuery setLimit(@Nullable @Nonnegative Integer limit) {
        this.limit = limit;
        return this;
    }

    /**
     * Extract the maximum number of attempts.
     *
     * @return the maximum number of attempts
     */
    public int getMaxAttempts() {
        return maxAttempts;
    }

    /**
     * Assign the maximum number of attempts.
     *
     * @param maxAttempts the maximum number of attempts
     * @return {@code this}
     */
    public AddressBookQuery setMaxAttempts(@Nonnegative int maxAttempts) {
        this.maxAttempts = maxAttempts;
        return this;
    }

    /**
     * Assign the maximum backoff duration.
     *
     * @param maxBackoff the maximum backoff duration
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public AddressBookQuery setMaxBackoff(Duration maxBackoff) {
        Objects.requireNonNull(maxBackoff);
        if (maxBackoff.toMillis() < 500L) {
            throw new IllegalArgumentException("maxBackoff must be at least 500 ms");
        }
        this.maxBackoff = maxBackoff;
        return this;
    }

    /**
     * Execute the query with preset timeout.
     *
     * @param client the client object
     * @return the node address book
     */
    public NodeAddressBook execute(Client client) {
        return execute(client, client.getRequestTimeout());
    }

    /**
     * Execute the query with user supplied timeout.
     *
     * @param client  the client object
     * @param timeout the user supplied timeout
     * @return the node address book
     */
    public NodeAddressBook execute(Client client, Duration timeout) {
        var deadline = Deadline.after(timeout.toMillis(), TimeUnit.MILLISECONDS);
        for (int attempt = 1; true; attempt++) {
            try {
                var addressProtoIter = ClientCalls.blockingServerStreamingCall(
                    buildCall(client, deadline),
                    buildQuery()
                );
                List<NodeAddress> addresses = new ArrayList<>();
                while (addressProtoIter.hasNext()) {
                    addresses.add(NodeAddress.fromProtobuf(addressProtoIter.next()));
                }
                return new NodeAddressBook().setNodeAddresses(addresses);
            } catch (Throwable error) {
                if (!shouldRetry(error) || attempt >= maxAttempts) {
                    LOGGER.error("Error attempting to get address book at FileId {}", fileId, error);
                    throw error;
                }
                warnAndDelay(attempt, error);
            }
        }
    }

    /**
     * Execute the query with preset timeout asynchronously.
     *
     * @param client the client object
     * @return the node address book
     */
    public CompletableFuture<NodeAddressBook> executeAsync(Client client) {
        return executeAsync(client, client.getRequestTimeout());
    }

    /**
     * Execute the query with user supplied timeout.
     *
     * @param client  the client object
     * @param timeout the user supplied timeout
     * @return the node address book
     */
    public CompletableFuture<NodeAddressBook> executeAsync(Client client, Duration timeout) {
        var deadline = Deadline.after(timeout.toMillis(), TimeUnit.MILLISECONDS);
        CompletableFuture<NodeAddressBook> returnFuture = new CompletableFuture<>();
        executeAsync(client, deadline, returnFuture, 1);
        return returnFuture;
    }

    /**
     * Execute the query.
     *
     * @param client       the client object
     * @param deadline     the user supplied timeout
     * @param returnFuture returned promise callback
     * @param attempt      maximum number of attempts
     */
    void executeAsync(Client client, Deadline deadline, CompletableFuture<NodeAddressBook> returnFuture, int attempt) {
        List<NodeAddress> addresses = new ArrayList<>();
        ClientCalls.asyncServerStreamingCall(
            buildCall(client, deadline),
            buildQuery(),
            new StreamObserver<com.hedera.hashgraph.sdk.proto.NodeAddress>() {
                @Override
                public void onNext(com.hedera.hashgraph.sdk.proto.NodeAddress addressProto) {
                    addresses.add(NodeAddress.fromProtobuf(addressProto));
                }

                @Override
                public void onError(Throwable error) {
                    if (attempt >= maxAttempts || !shouldRetry(error)) {
                        LOGGER.error("Error attempting to get address book at FileId {}", fileId, error);
                        returnFuture.completeExceptionally(error);
                        return;
                    }
                    warnAndDelay(attempt, error);
                    addresses.clear();
                    executeAsync(client, deadline, returnFuture, attempt + 1);
                }

                @Override
                public void onCompleted() {
                    returnFuture.complete(new NodeAddressBook().setNodeAddresses(addresses));
                }
            });
    }

    /**
     * Build the address book query.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery buildQuery }
     */
    com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery buildQuery() {
        var builder = com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder();
        if (fileId != null) {
            builder.setFileId(fileId.toProtobuf());
        }
        if (limit != null) {
            builder.setLimit(limit);
        }
        return builder.build();
    }

    private ClientCall<com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery, com.hedera.hashgraph.sdk.proto.NodeAddress>
    buildCall(Client client, Deadline deadline) {
        try {
            return client.mirrorNetwork.getNextMirrorNode().getChannel().newCall(
                NetworkServiceGrpc.getGetNodesMethod(),
                CallOptions.DEFAULT.withDeadline(deadline)
            );
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    private void warnAndDelay(int attempt, Throwable error) {
        var delay = Math.min(500 * (long) Math.pow(2, attempt), maxBackoff.toMillis());
        LOGGER.warn(
            "Error fetching address book at FileId {} during attempt #{}. Waiting {} ms before next attempt: {}",
            fileId, attempt, delay, error.getMessage());

        try {
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/AssessedCustomFee.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

/**
 * A custom transfer fee that was assessed during the handling of a CryptoTransfer.
 */
public class AssessedCustomFee {
    /**
     * The number of units assessed for the fee
     */
    public final long amount;

    /**
     * The denomination of the fee; taken as hbar if left unset
     */
    @Nullable
    public final TokenId tokenId;

    /**
     * The account to receive the assessed fee
     */
    @Nullable
    public final AccountId feeCollectorAccountId;

    /**
     * The account(s) whose final balances would have been higher in the absence of this assessed fee
     */
    public final List<AccountId> payerAccountIdList;

    AssessedCustomFee(
        long amount,
        @Nullable TokenId tokenId,
        @Nullable AccountId feeCollectorAccountId,
        List<AccountId> payerAccountIdList
    ) {
        this.amount = amount;
        this.tokenId = tokenId;
        this.feeCollectorAccountId = feeCollectorAccountId;
        this.payerAccountIdList = payerAccountIdList;
    }

    /**
     * Convert the protobuf object to an assessed custom fee object.
     *
     * @param assessedCustomFee         protobuf response object
     * @return                          the converted assessed custom fee object
     */
    static AssessedCustomFee fromProtobuf(com.hedera.hashgraph.sdk.proto.AssessedCustomFee assessedCustomFee) {
        var payerList = new ArrayList<AccountId>(assessedCustomFee.getEffectivePayerAccountIdCount());
        for (var payerId : assessedCustomFee.getEffectivePayerAccountIdList()) {
            payerList.add(AccountId.fromProtobuf(payerId));
        }
        return new AssessedCustomFee(
            assessedCustomFee.getAmount(),
            assessedCustomFee.hasTokenId() ? TokenId.fromProtobuf(assessedCustomFee.getTokenId()) : null,
            assessedCustomFee.hasFeeCollectorAccountId() ? AccountId.fromProtobuf(assessedCustomFee.getFeeCollectorAccountId()) : null,
            payerList
        );
    }

    /**
     * Convert a byte array into an assessed custom fee object.
     *
     * @param bytes                     the byte array
     * @return                          the converted assessed custom fee object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static AssessedCustomFee fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.AssessedCustomFee.parseFrom(bytes).toBuilder().build());
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("amount", amount)
            .add("tokenId", tokenId)
            .add("feeCollectorAccountId", feeCollectorAccountId)
            .add("payerAccountIdList", payerAccountIdList)
            .toString();
    }

    /**
     * Create the protobuf representation.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.AssessedCustomFee}
     */
    com.hedera.hashgraph.sdk.proto.AssessedCustomFee toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.AssessedCustomFee.newBuilder().setAmount(amount);
        if (tokenId != null) {
            builder.setTokenId(tokenId.toProtobuf());
        }
        if (feeCollectorAccountId != null) {
            builder.setFeeCollectorAccountId(feeCollectorAccountId.toProtobuf());
        }
        for (var payerId : payerAccountIdList) {
            builder.addEffectivePayerAccountId(payerId.toProtobuf());
        }
        return builder.build();
    }

    /**
     * Create a byte array representation.
     *
     * @return                          the converted assessed custom fees
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BadEntityIdException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Custom exception thrown by the entity helper validate method when the account id and checksum are invalid.
 */
public class BadEntityIdException extends Exception {
    /**
     * the shard portion of the account id
     */
    public final long shard;
    /**
     * the realm portion of the account id
     */
    public final long realm;
    /**
     * the num portion of the account id
     */
    public final long num;
    /**
     * the user supplied checksum
     */
    public final String presentChecksum;
    /**
     * the calculated checksum
     */
    public final String expectedChecksum;

    /**
     * Constructor.
     *
     * @param shard                     the shard portion of the account id
     * @param realm                     the realm portion of the account id
     * @param num                       the num portion of the account id
     * @param presentChecksum           the user supplied checksum
     * @param expectedChecksum          the calculated checksum
     */
    BadEntityIdException(long shard, long realm, long num, String presentChecksum, String expectedChecksum) {
        super(String.format("Entity ID %d.%d.%d-%s was incorrect.", shard, realm, num, presentChecksum));
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.presentChecksum = presentChecksum;
        this.expectedChecksum = expectedChecksum;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BadKeyException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Signals that a key could not be realized from the given input.
 * <p>
 * This exception can be raised by any of the {@code from} methods
 * on {@link PrivateKey} or {@link PublicKey}.
 */
public final class BadKeyException extends IllegalArgumentException {
    /**
     * @param message                   the message
     */
    BadKeyException(String message) {
        super(message);
    }

    /**
     * @param cause                     the cause
     */
    BadKeyException(Throwable cause) {
        super(cause);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BadMnemonicException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;
import java.util.List;

/**
 * Custom exception for when there are issues with the mnemonic.
 */
public class BadMnemonicException extends Exception {
    /**
     * The mnemonic that failed validation.
     */
    public final Mnemonic mnemonic;

    /**
     * The reason for which the mnemonic failed validation.
     */
    public final BadMnemonicReason reason;

    /**
     * If not null, these are the indices in the mnemonic that were not found in the
     * BIP-39 standard English word list.
     * <p>
     * If {@code reason == BadMnemonicReason.UnknownWords} then this will be not null.
     */
    @Nullable
    public final List<Integer> unknownWordIndices;

    /**
     * Constructor.
     *
     * @param mnemonic                  the mnemonic
     * @param reason                    the reason
     * @param unknownWordIndices        the indices
     */
    BadMnemonicException(Mnemonic mnemonic, BadMnemonicReason reason, List<Integer> unknownWordIndices) {
        this.mnemonic = mnemonic;
        this.reason = reason;
        this.unknownWordIndices = unknownWordIndices;
    }

    /**
     * Constructor.
     *
     * @param mnemonic                  the mnemonic
     * @param reason                    the reason
     */
    BadMnemonicException(Mnemonic mnemonic, BadMnemonicReason reason) {
        this.mnemonic = mnemonic;
        this.reason = reason;
        this.unknownWordIndices = null;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BadMnemonicReason.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Possible reason why a {@link Mnemonic} failed validation.
 */
public enum BadMnemonicReason {
    /**
     * The mnemonic did not contain exactly 24 words.
     */
    BadLength,

    /**
     * The mnemonic contained words which were not found in the BIP-39 standard English word list.
     * <p>
     * {@link BadMnemonicException#unknownWordIndices} will be set with the list of word indices
     * in {@link Mnemonic#words} which were not found in the standard word list.
     *
     * @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">BIP-39
     * English word list</a>.
     */
    UnknownWords,

    /**
     * The checksum encoded in the mnemonic did not match the checksum we just calculated for
     * that mnemonic.
     * <p>
     * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
     * after being calculated from it, before being encoded into words. This status is returned if
     * {@link Mnemonic#validate()} calculated a different checksum for the mnemonic than that which
     * was encoded into it.
     * <p>
     * This could happen if two or more of the words were entered out of the original order or
     * replaced with another from the standard word list (as this is only returned if all the words
     * exist in the word list).
     */
    ChecksumMismatch,
    /**
     * The given mnemonic doesn't contain 22 words required to be a legacy mnemonic, or the words are
     * not in the legacy list.
     */
    NotLegacy
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BaseNetwork.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.annotations.VisibleForTesting;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Abstracts away most of the similar functionality between {@link Network} and {@link MirrorNetwork}
 *
 * @param <BaseNetworkT> - The network that is extending this class. This is used for builder pattern setter methods.
 * @param <KeyT> - The identifying type for the network.
 * @param <BaseNodeT> - The specific node type for this network.
 */
abstract class BaseNetwork<
    BaseNetworkT extends BaseNetwork<BaseNetworkT, KeyT, BaseNodeT>,
    KeyT,
    BaseNodeT extends BaseNode<BaseNodeT, KeyT>> {
    protected static final Integer DEFAULT_MAX_NODE_ATTEMPTS = -1;
    protected static final Random random = new Random();

    protected final ExecutorService executor;

    /**
     * Map of node identifiers to nodes. Used to quickly fetch node for identifier.
     */
    protected Map<KeyT, List<BaseNodeT>> network = new ConcurrentHashMap<>();

    /**
     * The list of all nodes.
     */
    protected List<BaseNodeT> nodes = new ArrayList<>();

    /**
     * The list of currently healthy nodes.
     */
    protected List<BaseNodeT> healthyNodes = new ArrayList<>();

    /**
     * The current minimum backoff for the nodes in the network. This backoff is used when nodes return a bad
     * gRPC status.
     */
    protected Duration minNodeBackoff = Client.DEFAULT_MIN_NODE_BACKOFF;

    /**
     * The current maximum backoff for the nodes in the network. This backoff is used when nodes return a bad
     * gRPC status.
     */
    protected Duration maxNodeBackoff = Client.DEFAULT_MAX_NODE_BACKOFF;

    /**
     * Timeout for closing either a single node when setting a new network, or closing the entire network.
     */
    protected Duration closeTimeout = Client.DEFAULT_CLOSE_TIMEOUT;

    /**
     * Limit for how many times we retry a node which has returned a bad gRPC status
     */
    protected int maxNodeAttempts = DEFAULT_MAX_NODE_ATTEMPTS;

    /**
     * Is the network using transport security
     */
    protected boolean transportSecurity;

    /**
     * The min time to wait before attempting to readmit nodes.
     */
    protected Duration minNodeReadmitTime = Client.DEFAULT_MIN_NODE_BACKOFF;

    /**
     * The max time to wait for readmitting nodes.
     */
    protected Duration maxNodeReadmitTime = Client.DEFAULT_MAX_NODE_BACKOFF;

    /**
     * The instant that readmission will happen after.
     */
    protected Instant earliestReadmitTime;

    /**
     * The name of the network. This corresponds to ledger ID in entity ID checksum calculations
     */
    @Nullable
    private LedgerId ledgerId;

    @VisibleForTesting
    @SuppressFBWarnings(
        value = "URF_UNREAD_FIELD",
        justification = "this field is used for testing"
    )
    boolean hasShutDownNow = false;

    protected BaseNetwork(ExecutorService executor) {
        this.executor = executor;
        earliestReadmitTime = Instant.now().plus(minNodeReadmitTime);
    }

    /**
     * Extract the ledger id.
     *
     * @return                          the ledger id
     */
    @Nullable
    synchronized LedgerId getLedgerId() {
        return ledgerId;
    }

    /**
     * Set the new LedgerId for this network. LedgerIds are used for TLS certificate checking and entity ID
     * checksum validation.
     *
     * @param ledgerId                  the ledger id
     * @return {@code this}
     */
    synchronized BaseNetworkT setLedgerId(@Nullable LedgerId ledgerId) {
        this.ledgerId = ledgerId;

        // noinspection unchecked
        return (BaseNetworkT) this;
    }

    /**
     * Extract the node attempts.
     *
     * @return                          maximum node attempts
     */
    synchronized int getMaxNodeAttempts() {
        return maxNodeAttempts;
    }

    /**
     * Set the max number of times a node can return a bad gRPC status before we remove it from the list.
     *
     * @param maxNodeAttempts           the max node attempts
     * @return {@code this}
     */
    synchronized BaseNetworkT setMaxNodeAttempts(int maxNodeAttempts) {
        this.maxNodeAttempts = maxNodeAttempts;

        // noinspection unchecked
        return (BaseNetworkT) this;
    }

    /**
     * Extract the minimum node backoff time.
     *
     * @return                          the minimum node backoff time
     */
    synchronized Duration getMinNodeBackoff() {
        return minNodeBackoff;
    }

    /**
     * Set the minimum backoff a node should use when receiving a bad gRPC status.
     *
     * @param minNodeBackoff            the min node backoff
     * @return {@code this}
     */
    synchronized BaseNetworkT setMinNodeBackoff(Duration minNodeBackoff) {
        this.minNodeBackoff = minNodeBackoff;

        for (var node : nodes) {
            node.setMinBackoff(minNodeBackoff);
        }

        // noinspection unchecked
        return (BaseNetworkT) this;
    }

    /**
     * Extract the maximum node backoff time.
     *
     * @return                          the maximum node backoff time
     */
    synchronized Duration getMaxNodeBackoff() {
        return maxNodeBackoff;
    }

    /**
     * Set the maximum backoff a node should use when receiving a bad gRPC status.
     *
     * @param maxNodeBackoff            the max node backoff
     * @return {@code this}
     */
    synchronized BaseNetworkT setMaxNodeBackoff(Duration maxNodeBackoff) {
        this.maxNodeBackoff = maxNodeBackoff;

        for (var node : nodes) {
            node.setMaxBackoff(maxNodeBackoff);
        }

        // noinspection unchecked
        return (BaseNetworkT) this;
    }

    /**
     * Extract the minimum node readmit time.
     *
     * @return                          the minimum node readmit time
     */
    synchronized public Duration getMinNodeReadmitTime() {
        return minNodeReadmitTime;
    }

    /**
     * Assign the minimum node readmit time.
     *
     * @param minNodeReadmitTime        the minimum node readmit time
     */
    synchronized public void setMinNodeReadmitTime(Duration minNodeReadmitTime) {
        this.minNodeReadmitTime = minNodeReadmitTime;

        for (var node : nodes) {
            node.readmitTime = Instant.now();
        }
    }

    /**
     * Extract the maximum node readmit time.
     *
     * @return                          the maximum node readmit time
     */
    public Duration getMaxNodeReadmitTime() {
        return maxNodeReadmitTime;
    }

    /**
     * Assign the maximum node readmit time.
     *
     * @param maxNodeReadmitTime        the maximum node readmit time
     */
    public void setMaxNodeReadmitTime(Duration maxNodeReadmitTime) {
        this.maxNodeReadmitTime = maxNodeReadmitTime;
    }

    /**
     * Is transport Security enabled?
     *
     * @return                          using transport security
     */
    boolean isTransportSecurity() {
        return transportSecurity;
    }

    /**
     * Extract the close timeout.
     *
     * @return                          the close timeout
     */
    synchronized Duration getCloseTimeout() {
        return closeTimeout;
    }

    /**
     * Assign the close timeout.
     *
     * @param closeTimeout              the close timeout
     * @return {@code this}
     */
    synchronized BaseNetworkT setCloseTimeout(Duration closeTimeout) {
        this.closeTimeout = closeTimeout;

        // noinspection unchecked
        return (BaseNetworkT) this;
    }

    protected abstract BaseNodeT createNodeFromNetworkEntry(Map.Entry<String, KeyT> entry);

    /**
     * Returns a list of index in descending order to remove from the current node list.
     *
     * Descending order is important here because {@link BaseNetwork#setNetwork(Map<String, KeyT>)} uses a for-each loop.
     *
     * @param network - the new network
     * @return - list of indexes in descending order
     */
    protected List<Integer> getNodesToRemove(Map<String, KeyT> network) {
        var nodes = new ArrayList<Integer>(this.nodes.size());

        for (int i = this.nodes.size() - 1; i >= 0; i--) {
            var node = this.nodes.get(i);

            if (!nodeIsInGivenNetwork(node, network)) {
                nodes.add(i);
            }
        }

        return nodes;
    }

    private boolean nodeIsInGivenNetwork(BaseNodeT node, Map<String,KeyT> network) {
        for (var entry : network.entrySet()) {
            if (
                node.getKey().equals(entry.getValue()) &&
                node.address.equals(BaseNodeAddress.fromString(entry.getKey()))
            ) {
                return true;
            }
        }
        return false;
    }

    /**
     * Intelligently overwrites the current network.
     *
     * Shutdown and remove any node from the current network if the new network doesn't contain it. This includes
     * checking both the URL and {@link AccountId} when the network is a {@link Network}.
     *
     * Add any nodes from the new network that don't already exist in the network.
     *
     * @param network - The new network
     * @return - {@code this}
     * @throws TimeoutException - when shutting down nodes
     * @throws InterruptedException - when acquiring the lock
     */
    synchronized BaseNetworkT setNetwork(Map<String, KeyT> network) throws TimeoutException, InterruptedException {
        var newNodes = new ArrayList<BaseNodeT>();
        var newHealthyNodes = new ArrayList<BaseNodeT>();
        var newNetwork = new HashMap<KeyT, List<BaseNodeT>>();
        var newNodeKeys = new HashSet<KeyT>();
        var newNodeAddresses = new HashSet<String>();

        // getNodesToRemove() should always return the list in reverse order
        for (var index : getNodesToRemove(network)) {
            var stopAt = Instant.now().getEpochSecond() + closeTimeout.getSeconds();
            var remainingTime = stopAt - Instant.now().getEpochSecond();
            var node = nodes.get(index);

            // Exit early if we have no time remaining
            if (remainingTime <= 0) {
                throw new TimeoutException("Failed to properly shutdown all channels");
            }

            removeNodeFromNetwork(node);
            node.close(Duration.ofSeconds(remainingTime));
            this.nodes.remove(index.intValue());
        }

        for (var node : this.nodes) {
            newNodes.add(node);
            newNodeKeys.add(node.getKey());
            newNodeAddresses.add(node.address.toString());
        }

        for (var entry : network.entrySet()) {
            var node = createNodeFromNetworkEntry(entry);

            if (newNodeKeys.contains(node.getKey()) && newNodeAddresses.contains(node.getAddress().toString())) {
                continue;
            }

            newNodes.add(node);
        }

        for (var node : newNodes) {
            if (newNetwork.containsKey(node.getKey())) {
                newNetwork.get(node.getKey()).add(node);
            } else {
                var list = new ArrayList<BaseNodeT>();
                list.add(node);
                newNetwork.put(node.getKey(), list);
            }

            newHealthyNodes.add(node);
        }

        // Atomically set all the variables
        nodes = newNodes;
        this.network = newNetwork;
        healthyNodes = newHealthyNodes;

        // noinspection unchecked
        return (BaseNetworkT) this;
    }

    synchronized void increaseBackoff(BaseNodeT node) {
        node.increaseBackoff();
        healthyNodes.remove(node);
    }

    synchronized void decreaseBackoff(BaseNodeT node) {
        node.decreaseBackoff();
    }

    private void removeNodeFromNetwork(BaseNodeT node) {
        var nodesForKey = this.network.get(node.getKey());
        nodesForKey.remove(node);
        if (nodesForKey.isEmpty()) {
            this.network.remove(node.getKey());
        }
    }

    private boolean addressIsInNodeList(String addressString, List<BaseNodeT> nodes) {
        var address = BaseNodeAddress.fromString(addressString);
        for (var node : nodes) {
            if (node.address.equals(address)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Remove any nodes from the network when they've exceeded the {@link BaseNetwork#maxNodeAttempts} limit
     *
     * @throws InterruptedException - when shutting down nodes
     */
    protected void removeDeadNodes() throws InterruptedException {
        if (maxNodeAttempts > 0) {
            for (int i = nodes.size() - 1; i >= 0; i--) {
                var node = Objects.requireNonNull(nodes.get(i));

                if (node.getBadGrpcStatusCount() >= maxNodeAttempts) {
                    node.close(closeTimeout);
                    removeNodeFromNetwork(node);
                    nodes.remove(i);
                }
            }
        }
    }

    /**
     * Readmits nodes from the `nodes` list into the `healthyNodes` list when the time is passed the
     * {@code earliestReadmitTime}. While readmitting nodes the `earliestReadmitTime` will be updated to
     * a new value. This value is either the value of the node with the smallest readmission time from now,
     * or `minNodeReadmitTime` or `maxNodeReadmitTime`.
     */
    synchronized void readmitNodes() {
        var now = Instant.now();

        if (now.toEpochMilli() > earliestReadmitTime.toEpochMilli()) {
            var nextEarliestReadmitTime = now.plus(maxNodeReadmitTime);

            for (var node : this.nodes) {
                if (node.readmitTime.isAfter(now) && node.readmitTime.isBefore(nextEarliestReadmitTime)) {
                    nextEarliestReadmitTime = node.readmitTime;
                }
            }


            this.earliestReadmitTime = nextEarliestReadmitTime;
            if (this.earliestReadmitTime.isBefore(now.plus(minNodeReadmitTime))) {
                this.earliestReadmitTime = now.plus(minNodeReadmitTime);
            }

            outer: for (var i = 0; i < this.nodes.size(); i++) {
                // Check if `healthyNodes` already contains this node
                for (var j = 0; j < this.healthyNodes.size(); j++) {
                    if (this.nodes.get(i) == this.healthyNodes.get(j)) {
                        continue outer;
                    }
                }

                // If `healthyNodes` doesn't contain the node, check the `readmitTime` on the node
                if (this.nodes.get(i).readmitTime.isBefore(now)) {
                    this.healthyNodes.add(this.nodes.get(i));
                }
            }

        }
    }

    /**
     * Get a random healthy node.
     *
     * @return                          the node
     */
    synchronized BaseNodeT getRandomNode() {
        // Attempt to readmit nodes each time a node is fetched.
        // Note: Readmitting nodes will only happen periodically so calling it each time should not harm
        // performance.
        readmitNodes();

        if (healthyNodes.isEmpty()) {
            throw new IllegalStateException("No healthy node was found");
        }

        return healthyNodes.get(random.nextInt(healthyNodes.size()));
    }

    /**
     * Get all node proxies by key
     *
     * @param key                       the desired key
     * @return                          the list of node proxies
     */
    synchronized List<BaseNodeT> getNodeProxies(KeyT key) {
        // Attempt to readmit nodes each time a node is fetched.
        // Note: Readmitting nodes will only happen periodically so calling it each time should not harm
        // performance.
        readmitNodes();

        return network.get(key);
    }

    /**
     * Returns `count` number of the most healthy nodes. Healthy-ness is determined by sort order; leftmost being most
     * healthy. This will also remove any nodes which have hit or exceeded {@link BaseNetwork#maxNodeAttempts}.
     *
     * Returns a list of nodes where each node has a unique key.
     *
     * @param count                     number of nodes to return
     * @return                          List of nodes to use
     * @throws InterruptedException     when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    protected synchronized List<BaseNodeT> getNumberOfMostHealthyNodes(int count) throws InterruptedException {
        readmitNodes();
        removeDeadNodes();

        var returnNodes = new HashMap<KeyT, BaseNodeT>(count);

        for (var i = 0; i < count; i++ ) {
            var node = getRandomNode();

            if (!returnNodes.containsKey(node.getKey())) {
                returnNodes.put(node.getKey(), node);
            }
        }

        var returnList = new ArrayList<BaseNodeT>();
        returnList.addAll(returnNodes.values());
        return returnList;
    }


    synchronized void beginClose() {
        for (var node : nodes) {
            if (node.channel != null) {
                node.channel = node.channel.shutdown();
            }
        }
    }

    // returns null if successful, or Throwable if error occurred
    @Nullable
    synchronized Throwable awaitClose(Instant deadline, @Nullable Throwable previousError) {
        try {
            if (previousError != null) {
                throw previousError;
            }

            for (var node : nodes) {
                if (node.channel != null) {
                    var timeoutMillis = Duration.between(Instant.now(), deadline).toMillis();
                    if (timeoutMillis <= 0 || !node.channel.awaitTermination(timeoutMillis, TimeUnit.MILLISECONDS)) {
                        throw new TimeoutException("Failed to properly shutdown all channels");
                    } else {
                        node.channel = null;
                    }
                }
            }

            return null;
        } catch (Throwable error) {
            for (var node : nodes) {
                if (node.channel != null) {
                    node.channel.shutdownNow();
                }
            }
            hasShutDownNow = true;

            return error;
        } finally {
            nodes.clear();
            network.clear();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BaseNode.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import io.grpc.ChannelCredentials;
import io.grpc.ConnectivityState;
import io.grpc.Grpc;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.TlsChannelCredentials;
import io.grpc.inprocess.InProcessChannelBuilder;

import java.lang.module.ModuleDescriptor;
import java.time.Duration;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

/**
 * Internal utility class.
 *
 * @param <N>                           the n type
 * @param <KeyT>                        the key t type
 */
abstract class BaseNode<N extends BaseNode<N, KeyT>, KeyT> {
    private static final int GET_STATE_INTERVAL_MILLIS = 50;
    private static final int GET_STATE_TIMEOUT_MILLIS = 10000;
    private static final int GET_STATE_MAX_ATTEMPTS = GET_STATE_TIMEOUT_MILLIS / GET_STATE_INTERVAL_MILLIS;
    private boolean hasConnected = false;

    protected final ExecutorService executor;

    /**
     * Address of this node
     */
    protected final BaseNodeAddress address;

    /**
     * Timestamp of when this node will be considered healthy again
     */
    protected Instant readmitTime;

    /**
     * The current backoff duration. Uses exponential backoff so think 1s, 2s, 4s, 8s, etc until maxBackoff is hit
     */
    protected Duration currentBackoff;

    /**
     * Minimum backoff used by node when receiving a bad gRPC status
     */
    protected Duration minBackoff;

    /**
     * Maximum backoff used by node when receiving a bad gRPC status
     */
    protected Duration maxBackoff;

    /**
     * Number of times this node has received a bad gRPC status
     */
    protected long badGrpcStatusCount;

    @Nullable
    protected ManagedChannel channel = null;

    /**
     * Constructor.
     *
     * @param address                   the node address
     * @param executor                  the client
     */
    protected BaseNode(BaseNodeAddress address, ExecutorService executor) {
        this.executor = executor;
        this.address = address;
        this.currentBackoff = Client.DEFAULT_MIN_NODE_BACKOFF;
        this.minBackoff = Client.DEFAULT_MIN_NODE_BACKOFF;
        this.maxBackoff = Client.DEFAULT_MAX_NODE_BACKOFF;
        this.readmitTime = Instant.EPOCH;
    }

    /**
     * Constructor.
     *
     * @param node                      the node object
     * @param address                   the address to assign
     */
    protected BaseNode(N node, BaseNodeAddress address) {
        this.address = address;

        this.executor = node.executor;
        this.minBackoff = node.minBackoff;
        this.maxBackoff = node.maxBackoff;
        this.readmitTime = node.readmitTime;
        this.currentBackoff = node.currentBackoff;
        this.badGrpcStatusCount = node.badGrpcStatusCount;
    }

    /**
     * Return the local host ip address
     *
     * @return                          the authority address
     */
    protected String getAuthority() {
        return "127.0.0.1";
    }

    /**
     * Extract the key list
     *
     * @return                          the key list
     */
    abstract KeyT getKey();

    /**
     * Get the address of this node
     *
     * @return                          the address for the node
     */
    BaseNodeAddress getAddress() {
        return address;
    }

    /**
     * Get the minimum backoff time
     *
     * @return                          the minimum backoff time
     */
    synchronized Duration getMinBackoff() {
        return minBackoff;
    }

    /**
     * Set the minimum backoff tim
     *
     * @param minBackoff                the minimum backoff time
     * @return {@code this}
     */
    synchronized N setMinBackoff(Duration minBackoff) {
        if (currentBackoff == this.minBackoff) {
            currentBackoff = minBackoff;
        }
        this.minBackoff = minBackoff;

        // noinspection unchecked
        return (N) this;
    }

    /**
     * Get the maximum backoff time
     *
     * @return                          the maximum backoff time
     */
    Duration getMaxBackoff() {
        return maxBackoff;
    }

    /**
     * Set the maximum backoff time
     *
     * @param maxBackoff                the max backoff time
     * @return {@code this}
     */
    N setMaxBackoff(Duration maxBackoff) {
        this.maxBackoff = maxBackoff;

        // noinspection unchecked
        return (N) this;
    }

    /**
     * Get the number of times this node has received a bad gRPC status
     *
     * @return                          the count of bad grpc status
     */
    long getBadGrpcStatusCount() {
        return badGrpcStatusCount;
    }

    /**
     * Extract the unhealthy backoff time remaining.
     *
     * @return                          the unhealthy backoff time remaining
     */
    long unhealthyBackoffRemaining() {
        return Math.max(0, readmitTime.toEpochMilli() - System.currentTimeMillis());
    }

    /**
     * Determines if this is node is healthy.
     * Healthy means the node has either not received any bad gRPC statuses, or if it has received bad gRPC status then
     * the node backed off for a period of time.
     *
     * @return                          is the node healthy
     */
    boolean isHealthy() {
        return readmitTime.toEpochMilli() < Instant.now().toEpochMilli();
    }

    /**
     * Used when a node has received a bad gRPC status
     */
    synchronized void increaseBackoff() {
        this.badGrpcStatusCount++;
        this.readmitTime = Instant.now().plus(this.currentBackoff);
        this.currentBackoff = currentBackoff.multipliedBy(2);
        this.currentBackoff = currentBackoff.compareTo(maxBackoff) < 0 ? currentBackoff : maxBackoff;
    }

    /**
     * Used when a node has not received a bad gRPC status.
     * This means on each request that doesn't get a bad gRPC status the current backoff will be lowered. The point of
     * this is to allow a node which has been performing poorly (receiving several bad gRPC status) to become used again
     * once it stops receiving bad gRPC statuses.
     */
    synchronized void decreaseBackoff() {
        this.currentBackoff = currentBackoff.dividedBy(2);
        this.currentBackoff = currentBackoff.compareTo(minBackoff) > 0 ? currentBackoff : minBackoff;
    }

    /**
     * Get the amount of time the node has to wait until it's healthy again
     *
     * @return                          remaining back off time
     */
    long getRemainingTimeForBackoff() {
        return readmitTime.toEpochMilli() - System.currentTimeMillis();
    }

    /**
     * Create TLS credentials when transport security is enabled
     *
     * @return                          the channel credentials
     */
    ChannelCredentials getChannelCredentials() {
        return TlsChannelCredentials.create();
    }

    /**
     * Get the gRPC channel for this node
     *
     * @return                          the channel
     */
    synchronized ManagedChannel getChannel() {
        if (channel != null) {
            return channel;
        }

        ManagedChannelBuilder<?> channelBuilder;

        if (address.isInProcess()) {
            channelBuilder = InProcessChannelBuilder.forName(Objects.requireNonNull(address.getName()));
        } else if (address.isTransportSecurity()) {
            channelBuilder = Grpc.newChannelBuilder(address.toString(), getChannelCredentials());

            String authority = getAuthority();
            if (authority != null) {
                channelBuilder = channelBuilder.overrideAuthority(authority);
            }
        } else {
            channelBuilder = ManagedChannelBuilder.forTarget(address.toString()).usePlaintext();
        }

        channel = channelBuilder
            .keepAliveTimeout(10, TimeUnit.SECONDS)
            .keepAliveWithoutCalls(true)
            .disableRetry()
            .userAgent(getUserAgent())
            .executor(executor)
            .build();

        return channel;
    }

    /**
     * Did we fail to connect?
     *
     * @return                          did we fail to connect
     */
    boolean channelFailedToConnect() {
        return channelFailedToConnect(Instant.MAX);
    }

    boolean channelFailedToConnect(Instant timeoutTime) {
        if (hasConnected) {
            return false;
        }
        hasConnected = (getChannel().getState(true) == ConnectivityState.READY);
        try {
            for (@Var int i = 0; i < GET_STATE_MAX_ATTEMPTS && !hasConnected; i++) {
                Duration currentTimeout = Duration.between(Instant.now(), timeoutTime);
                if (currentTimeout.isNegative() || currentTimeout.isZero()) {
                    return false;
                }
                TimeUnit.MILLISECONDS.sleep(GET_STATE_INTERVAL_MILLIS);
                hasConnected = (getChannel().getState(true) == ConnectivityState.READY);
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return !hasConnected;
    }


    private CompletableFuture<Boolean> channelFailedToConnectAsync(int i, ConnectivityState state) {
        hasConnected = (state == ConnectivityState.READY);
        if (i >= GET_STATE_MAX_ATTEMPTS || hasConnected) {
            return CompletableFuture.completedFuture(!hasConnected);
        }
        return Delayer.delayFor(GET_STATE_INTERVAL_MILLIS, executor).thenCompose(ignored -> {
            return channelFailedToConnectAsync(i + 1, getChannel().getState(true));
        });
    }

    /**
     * Asynchronously determine if the channel failed to connect.
     *
     * @return                          did we fail to connect
     */
    CompletableFuture<Boolean> channelFailedToConnectAsync() {
        if (hasConnected) {
            return CompletableFuture.completedFuture(false);
        }
        return channelFailedToConnectAsync(0, getChannel().getState(true));
    }

    /**
     * Close the current nodes channel
     *
     * @param timeout                   the timeout value
     * @throws InterruptedException     thrown when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    synchronized void close(Duration timeout) throws InterruptedException {
        if (channel != null) {
            channel.shutdown();
            channel.awaitTermination(timeout.getSeconds(), TimeUnit.SECONDS);
            channel = null;
        }
    }

    /**
     * Extract the user agent string.
     *
     * @return                          the user agent string
     */
    private String getUserAgent() {
        var theModule = getClass().getModule();
        var thePackage = getClass().getPackage();
        String implementationVersion;
        if (theModule.getName() == null) {
            // running on classpath
            implementationVersion =
                thePackage != null ? thePackage.getImplementationVersion() : null;
        } else {
            // running on module path
            implementationVersion =
                theModule.getDescriptor().version().map(ModuleDescriptor.Version::toString).orElse(null);
        }
        return "hedera-sdk-java/" + ((implementationVersion != null) ? ("v" + implementationVersion) : "DEV");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/BaseNodeAddress.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;
import java.util.Objects;
import java.util.regex.Pattern;

/**
 * Internal utility class.
 */
class BaseNodeAddress {
    private static final Pattern HOST_AND_PORT = Pattern.compile("^(\\S+):(\\d+)$");
    private static final Pattern IN_PROCESS = Pattern.compile("^in-process:(\\S+)$");
    static final int PORT_MIRROR_TLS = 443;
    static final int PORT_NODE_PLAIN = 50211;
    static final int PORT_NODE_TLS = 50212;

    // If address is `in-process:.*` this will contain the right side of the `:`
    @Nullable
    private final String name;

    @Nullable
    private final String address;
    private final int port;
    private final boolean secure;

    /**
     * Constructor.
     *
     * @param name                      the name part
     * @param address                   the address part
     * @param port                      the port part
     */
    public BaseNodeAddress(@Nullable String name, @Nullable String address, int port) {
        this(name, address, port, false);
    }

    /**
     * Constructor.
     *
     * @param name                      the name part
     * @param address                   the address part
     * @param port                      the port part
     * @param secure                    secure transport
     */
    public BaseNodeAddress(@Nullable String name, @Nullable String address, int port, boolean secure) {
        this.name = name;
        this.address = address;
        this.port = port;
        this.secure = secure;
    }

    /**
     * Create a managed node address fom a string.
     *
     * @param string                    the string representation
     * @return                          the new managed node address
     */
    public static BaseNodeAddress fromString(String string) {
        var hostAndPortMatcher = HOST_AND_PORT.matcher(string);
        var inProcessMatcher = IN_PROCESS.matcher(string);

        if (hostAndPortMatcher.matches() && hostAndPortMatcher.groupCount() == 2) {
            var address = hostAndPortMatcher.group(1);
            var port = hostAndPortMatcher.group(2);

            return new BaseNodeAddress(null, address, Integer.parseInt(port));
        } else if (inProcessMatcher.matches() && inProcessMatcher.groupCount() == 1) {
            return new BaseNodeAddress(inProcessMatcher.group(1), null, 0);
        } else {
            throw new IllegalStateException("failed to parse node address");
        }
    }

    /**
     * Extract the name.
     *
     * @return                          the name
     */
    public String getName() {
        return name;
    }

    /**
     * Extract the address.
     *
     * @return                          the address
     */
    public String getAddress() {
        return address;
    }

    /**
     * Extract the port.
     *
     * @return                          the port
     */
    public int getPort() {
        return port;
    }

    /**
     * Are we in process?
     *
     * @return                          are we in process
     */
    public boolean isInProcess() {
        return name != null;
    }

    /**
     * Are we secure?
     *
     * @return                          are we secure
     */
    public boolean isTransportSecurity() {
        return port == PORT_NODE_TLS || port == PORT_MIRROR_TLS || secure;
    }

    /**
     * Create a new insecure managed node.
     *
     * @return                          the insecure managed node address
     */
    public BaseNodeAddress toInsecure() {
        var newPort = (this.port == PORT_NODE_TLS) ? PORT_NODE_PLAIN : this.port;
        return new BaseNodeAddress(name, address, newPort, false);
    }

    /**
     * Create a new managed node.
     *
     * @return                          the secure managed node address
     */
    public BaseNodeAddress toSecure() {
        var newPort = (this.port == PORT_NODE_PLAIN) ? PORT_NODE_TLS : this.port;
        return new BaseNodeAddress(name, address, newPort, true);
    }

    @Override
    public String toString() {
        if (name != null) {
            return name;
        }

        return address + ":" + port;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BaseNodeAddress that = (BaseNodeAddress) o;
        return Objects.equals(getName(), that.getName()) && Objects.equals(getAddress(), that.getAddress()) && port == that.port;
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName(), getAddress(), getPort());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ChunkedTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SignatureMap;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import javax.annotation.Nullable;

/**
 * A common base for file and topic message transactions.
 */
abstract class ChunkedTransaction<T extends ChunkedTransaction<T>> extends Transaction<T> {
    private int chunkSize = 1024;

    /**
     * The transaction data
     */
    protected ByteString data = ByteString.EMPTY;

    /**
     * Maximum number of chunks this message will get broken up into when
     * it's frozen.
     */
    private int maxChunks = 20;

    /**
     * Constructor.
     *
     * @param txs                       Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ChunkedTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
    }

    /**
     * Constructor.
     *
     * @param txBody                    protobuf TransactionBody
     */
    ChunkedTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
    }

    /**
     * Constructor.
     */
    ChunkedTransaction() {
        super();
    }

    /**
     * Extract the data.
     *
     * @return                          the data
     */
    ByteString getData() {
        return data;
    }

    /**
     * Assign the data via a byte array.
     *
     * @param data                      the byte array
     * @return {@code this}
     */
    T setData(byte[] data) {
        requireNotFrozen();
        this.data = ByteString.copyFrom(data);

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Assign the data via a byte string.
     *
     * @param data                      the byte string
     * @return {@code this}
     */
    T setData(ByteString data) {
        requireNotFrozen();
        this.data = data;

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Assign the data via a string.
     *
     * @param text                      the byte array
     * @return {@code this}
     */
    T setData(String text) {
        requireNotFrozen();
        this.data = ByteString.copyFromUtf8(text);

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Retrieve the maximum number of chunks.
     *
     * @return                          the number of chunks
     */
    public int getMaxChunks() {
        return maxChunks;
    }

    /**
     * Assign the max number of chunks.
     *
     * @param maxChunks                 the number of chunks
     * @return {@code this}
     */
    public T setMaxChunks(int maxChunks) {
        requireNotFrozen();
        this.maxChunks = maxChunks;

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Retrieve the chunk size.
     *
     * @return                          the chunk size
     */
    public int getChunkSize() {
        return chunkSize;
    }

    /**
     * Assign the chunk size.
     *
     * @param chunkSize                 the chunk size
     * @return {@code this}
     */
    public T setChunkSize(int chunkSize) {
        requireNotFrozen();
        this.chunkSize = chunkSize;

        // noinspection unchecked
        return (T) this;
    }

    @Override
    public byte[] getTransactionHash() {
        if (outerTransactions.size() > nodeAccountIds.size()) {
            throw new IllegalStateException("a single transaction hash can not be calculated for a chunked transaction, try calling `getAllTransactionHashesPerNode`");
        }

        return super.getTransactionHash();
    }

    @Override
    public Map<AccountId, byte[]> getTransactionHashPerNode() {
        if (outerTransactions.size() > nodeAccountIds.size()) {
            throw new IllegalStateException("a single transaction hash can not be calculated for a chunked transaction, try calling `getAllTransactionHashesPerNode`");
        }

        return super.getTransactionHashPerNode();
    }

    /**
     * Extract the list of transaction hashes.
     *
     * @return                          the list of transaction hashes
     */
    public final List<Map<AccountId, byte[]>> getAllTransactionHashesPerNode() {
        if (!this.isFrozen()) {
            throw new IllegalStateException("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`");
        }

        transactionIds.setLocked(true);
        nodeAccountIds.setLocked(true);

        buildAllTransactions();

        var txCount = transactionIds.size();
        var nodeCount = nodeAccountIds.size();
        var transactionHashes = new ArrayList<Map<AccountId, byte[]>>(txCount);

        for (var txIndex = 0; txIndex < txCount; ++txIndex) {
            var hashes = new HashMap<AccountId, byte[]>();
            var offset = txIndex * nodeCount;

            for (var nodeIndex = 0; nodeIndex < nodeCount; ++nodeIndex) {
                hashes.put(
                    nodeAccountIds.get(nodeIndex),
                    hash(outerTransactions.get(offset + nodeIndex).getSignedTransactionBytes().toByteArray()));
            }

            transactionHashes.add(hashes);
        }

        return transactionHashes;
    }

    @Override
    public T addSignature(PublicKey publicKey, byte[] signature) {
        if (data.size() > chunkSize) {
            throw new IllegalStateException("Cannot manually add signature to chunked transaction with length greater than " + chunkSize);
        }
        return super.addSignature(publicKey, signature);
    }

    @Override
    public Map<AccountId, Map<PublicKey, byte[]>> getSignatures() {
        if (data.size() > chunkSize) {
            throw new IllegalStateException("Cannot call getSignatures() on a chunked transaction with length greater than " + chunkSize);
        }
        return super.getSignatures();
    }

    /**
     * Extract the list of all signers.
     *
     * @return                          the list of all signatures
     */
    public List<Map<AccountId, Map<PublicKey, byte[]>>> getAllSignatures() {
        if (publicKeys.isEmpty()) {
            return new ArrayList<>();
        }

        buildAllTransactions();

        var txCount = transactionIds.size();
        var nodeCount = nodeAccountIds.size();

        var retval = new ArrayList<Map<AccountId, Map<PublicKey, byte[]>>>(txCount);

        for (int i = 0; i < txCount; i++) {
            retval.add(getSignaturesAtOffset(i * nodeCount));
        }

        return retval;
    }

    private void freezeAndSign(Client client) {
        if (!isFrozen()) {
            freezeWith(client);
        }

        var operatorId = client.getOperatorAccountId();

        if (operatorId != null && operatorId.equals(Objects.requireNonNull(getTransactionIdInternal().accountId))) {
            // on execute, sign each transaction with the operator, if present
            // and we are signing a transaction that used the default transaction ID
            signWithOperator(client);
        }
    }

    @Override
    public TransactionResponse execute(Client client, Duration timeoutPerChunk) throws TimeoutException, PrecheckStatusException {
        return executeAll(client, timeoutPerChunk).get(0);
    }

    /**
     * Execute this transaction or query
     *
     * @param client The client with which this will be executed.
     * @return Result of execution for each chunk
     * @throws TimeoutException         when the transaction times out
     * @throws PrecheckStatusException  when the precheck fails
     */
    public List<TransactionResponse> executeAll(Client client) throws PrecheckStatusException, TimeoutException {
        return executeAll(client, client.getRequestTimeout());
    }

    /**
     * Execute this transaction or query
     *
     * @param client The client with which this will be executed.
     * @param timeoutPerChunk The timeout after which the execution attempt will be cancelled.
     * @return Result of execution for each chunk
     * @throws TimeoutException         when the transaction times out
     * @throws PrecheckStatusException  when the precheck fails
     */
    public List<TransactionResponse> executeAll(Client client, Duration timeoutPerChunk) throws PrecheckStatusException, TimeoutException {
        freezeAndSign(client);

        var responses = new ArrayList<TransactionResponse>(transactionIds.size());

        for (var i = 0; i < transactionIds.size(); i++) {
            var response = super.execute(client, timeoutPerChunk);

            if (shouldGetReceipt()) {
                new TransactionReceiptQuery()
                    .setNodeAccountIds(Collections.singletonList(response.nodeId))
                    .setTransactionId(response.transactionId)
                    .execute(client, timeoutPerChunk);
            }

            responses.add(response);
        }

        return responses;
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client The client with which this will be executed.
     * @return Future result of execution for each chunk
     */
    public CompletableFuture<List<TransactionResponse>> executeAllAsync(Client client) {
        return executeAllAsync(client, client.getRequestTimeout());
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client The client with which this will be executed.
     * @param timeoutPerChunk The timeout after which the execution attempt will be cancelled.
     * @return Future result of execution for each chunk
     */
    public CompletableFuture<List<TransactionResponse>> executeAllAsync(Client client, Duration timeoutPerChunk) {
        freezeAndSign(client);

        @Var
        CompletableFuture<List<com.hedera.hashgraph.sdk.TransactionResponse>> future =
            CompletableFuture.supplyAsync(() -> new ArrayList<>(transactionIds.size()));

        for (var i = 0; i < transactionIds.size(); i++) {
            future = future.thenCompose(list -> {
                var responseFuture = super.executeAsync(client, timeoutPerChunk);

                Function<TransactionResponse, ? extends CompletionStage<TransactionResponse>> receiptFuture =
                    (TransactionResponse response) -> response.getReceiptAsync(client, timeoutPerChunk)
                        .thenApply(receipt -> response);

                Function<TransactionResponse, List<TransactionResponse>> addToList =
                    (response) -> {
                        list.add(response);
                        return list;
                    };

                if (shouldGetReceipt()) {
                    return responseFuture.thenCompose(receiptFuture).thenApply(addToList);
                } else {
                    return responseFuture.thenApply(addToList);
                }
            });
        }

        return future;
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client The client with which this will be executed.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAllAsync(Client client, BiConsumer<List<TransactionResponse>, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAllAsync(client), callback);
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAllAsync(Client client, Duration timeout, BiConsumer<List<TransactionResponse>, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAllAsync(client, timeout), callback);
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client The client with which this will be executed.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAllAsync(Client client, Consumer<List<TransactionResponse>> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAllAsync(client), onSuccess, onFailure);
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAllAsync(Client client, Duration timeout, Consumer<List<TransactionResponse>> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAllAsync(client, timeout), onSuccess, onFailure);
    }

    @Override
    public CompletableFuture<com.hedera.hashgraph.sdk.TransactionResponse> executeAsync(Client client, Duration timeoutPerChunk) {
        return executeAllAsync(client, timeoutPerChunk).thenApply(responses -> responses.get(0));
    }

    @Override
    public ScheduleCreateTransaction schedule() {
        requireNotFrozen();
        if (!nodeAccountIds.isEmpty()) {
            throw new IllegalStateException(
                "The underlying transaction for a scheduled transaction cannot have node account IDs set"
            );
        }
        if (data.size() > chunkSize) {
            throw new IllegalStateException("Cannot schedule a chunked transaction with length greater than " + chunkSize);
        }

        var bodyBuilder = spawnBodyBuilder(null);

        onFreeze(bodyBuilder);

        onFreezeChunk(
            bodyBuilder,
            null,
            0,
            data.size(),
            1,
            1
        );

        return doSchedule(bodyBuilder);
    }

    @Override
    int getRequiredChunks() {
        @Var var requiredChunks = (this.data.size() + (chunkSize - 1)) / chunkSize;

        if (requiredChunks == 0) {
            requiredChunks = 1;
        }

        if (requiredChunks > maxChunks) {
            throw new IllegalArgumentException(
                "message of " + this.data.size() + " bytes requires " + requiredChunks
                    + " chunks but the maximum allowed chunks is " + maxChunks + ", try using setMaxChunks");
        }
        return requiredChunks;
    }

    @Override
    void wipeTransactionLists(int requiredChunks) {
        sigPairLists = new ArrayList<>(requiredChunks * nodeAccountIds.size());
        outerTransactions = new ArrayList<>(requiredChunks * nodeAccountIds.size());
        innerSignedTransactions = new ArrayList<>(requiredChunks * nodeAccountIds.size());

        for (int i = 0; i < requiredChunks; i++) {
            if (!transactionIds.isEmpty()) {
                var startIndex = i * chunkSize;
                @Var var endIndex = startIndex + chunkSize;

                if (endIndex > this.data.size()) {
                    endIndex = this.data.size();
                }

                onFreezeChunk(
                    Objects.requireNonNull(frozenBodyBuilder).setTransactionID(transactionIds.get(i).toProtobuf()),
                    transactionIds.get(0).toProtobuf(),
                    startIndex,
                    endIndex,
                    i,
                    requiredChunks
                );
            }

            // For each node we add a transaction with that node
            for (var nodeId : nodeAccountIds) {
                sigPairLists.add(SignatureMap.newBuilder());
                innerSignedTransactions.add(SignedTransaction.newBuilder()
                    .setBodyBytes(
                        frozenBodyBuilder
                            .setNodeAccountID(nodeId.toProtobuf())
                            .build()
                            .toByteString()
                    )
                );
                outerTransactions.add(null);
            }
        }
    }

    /**
     * A common base for file and topic message transactions.
     */
    abstract void onFreezeChunk(TransactionBody.Builder body, @Nullable TransactionID initialTransactionId, int startIndex, int endIndex, int chunk, int total);

    /**
     * Should the receipt be retrieved?
     *
     * @return                          by default do not get a receipt
     */
    boolean shouldGetReceipt() {
        return false;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Client.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import javax.annotation.Nullable;

/**
 * Managed client for use on the Hedera Hashgraph network.
 */
public final class Client implements AutoCloseable {
    static final int DEFAULT_MAX_ATTEMPTS = 10;
    static final Duration DEFAULT_MAX_BACKOFF = Duration.ofSeconds(8L);
    static final Duration DEFAULT_MIN_BACKOFF = Duration.ofMillis(250L);
    static final Duration DEFAULT_MAX_NODE_BACKOFF = Duration.ofHours(1L);
    static final Duration DEFAULT_MIN_NODE_BACKOFF = Duration.ofSeconds(8L);
    static final Duration DEFAULT_CLOSE_TIMEOUT = Duration.ofSeconds(30L);
    static final Duration DEFAULT_REQUEST_TIMEOUT = Duration.ofMinutes(2L);
    static final Duration DEFAULT_GRPC_DEADLINE = Duration.ofSeconds(10L);
    static final Duration DEFAULT_NETWORK_UPDATE_PERIOD = Duration.ofHours(24);
    // Initial delay of 10 seconds before we update the network for the first time,
    // so that this doesn't happen in unit tests.
    static final Duration NETWORK_UPDATE_INITIAL_DELAY = Duration.ofSeconds(10);
    private static final Hbar DEFAULT_MAX_QUERY_PAYMENT = new Hbar(1);
    private static final String MAINNET = "mainnet";
    private static final String TESTNET = "testnet";
    private static final String PREVIEWNET = "previewnet";
    final ExecutorService executor;
    private final AtomicReference<Duration> grpcDeadline = new AtomicReference(DEFAULT_GRPC_DEADLINE);
    private final Set<SubscriptionHandle> subscriptions = ConcurrentHashMap.newKeySet();
    @Nullable
    Hbar defaultMaxTransactionFee = null;
    Hbar defaultMaxQueryPayment = DEFAULT_MAX_QUERY_PAYMENT;
    Network network;
    MirrorNetwork mirrorNetwork;
    @Nullable
    private Operator operator;
    private Duration requestTimeout = DEFAULT_REQUEST_TIMEOUT;
    private Duration closeTimeout = DEFAULT_CLOSE_TIMEOUT;
    private int maxAttempts = DEFAULT_MAX_ATTEMPTS;
    private volatile Duration maxBackoff = DEFAULT_MAX_BACKOFF;
    private volatile Duration minBackoff = DEFAULT_MIN_BACKOFF;
    private boolean autoValidateChecksums = false;
    private boolean defaultRegenerateTransactionId = true;
    // If networkUpdatePeriod is null, any network updates in progress will not complete
    @Nullable
    private Duration networkUpdatePeriod;
    @Nullable
    private CompletableFuture<Void> networkUpdateFuture;
    private Logger logger = new Logger(LogLevel.SILENT);

    /**
     * Constructor.
     *
     * @param executor      the executor
     * @param network       the network
     * @param mirrorNetwork the mirror network
     */
    @VisibleForTesting
    Client(
        ExecutorService executor,
        Network network,
        MirrorNetwork mirrorNetwork,
        @Nullable Duration networkUpdateInitialDelay,
        @Nullable Duration networkUpdatePeriod
    ) {
        this.executor = executor;
        this.network = network;
        this.mirrorNetwork = mirrorNetwork;
        this.networkUpdatePeriod = networkUpdatePeriod;
        scheduleNetworkUpdate(networkUpdateInitialDelay);
    }

    /**
     * Extract the executor.
     *
     * @return the executor service
     */
    static ExecutorService createExecutor() {
        var threadFactory = new ThreadFactoryBuilder()
            .setNameFormat("hedera-sdk-%d")
            .setDaemon(true)
            .build();

        int nThreads = Runtime.getRuntime().availableProcessors();
        return new ThreadPoolExecutor(nThreads, nThreads,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(),
            threadFactory, new ThreadPoolExecutor.CallerRunsPolicy());
    }

    /**
     *
     * Construct a client given a set of nodes.
     * It is the responsibility of the caller to ensure that all nodes in the map are part of the
     * same Hedera network. Failure to do so will result in undefined behavior.
     * The client will load balance all requests to Hedera using a simple round-robin scheme to
     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be tried.
     *
     * @param networkMap the map of node IDs to node addresses that make up the network.
     * @param executor runs the grpc requests asynchronously. Note that calling `close()` method on one of the
     *                 clients will close the executor for all the other clients sharing this executor
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forNetwork(Map<String, AccountId> networkMap, ExecutorService executor) {
        var network = Network.forNetwork(executor, networkMap);
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, new ArrayList<>());

        return new Client(executor, network, mirrorNetwork, null, null);
    }


    /**
     * Construct a client given a set of nodes.
     *
     * <p>It is the responsibility of the caller to ensure that all nodes in the map are part of the
     * same Hedera network. Failure to do so will result in undefined behavior.
     *
     * <p>The client will load balance all requests to Hedera using a simple round-robin scheme to
     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be tried.
     *
     * @param networkMap the map of node IDs to node addresses that make up the network.
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forNetwork(Map<String, AccountId> networkMap) {
        var executor = createExecutor();
        return forNetwork(networkMap, executor);
    }

    /**
     * Set up the client for the selected network.
     *
     * @param name the selected network
     * @return the configured client
     */
    public static Client forName(String name) {
        return switch (name) {
            case MAINNET -> Client.forMainnet();
            case TESTNET -> Client.forTestnet();
            case PREVIEWNET -> Client.forPreviewnet();
            default -> throw new IllegalArgumentException("Name must be one-of `mainnet`, `testnet`, or `previewnet`");
        };
    }

    /**
     * Construct a Hedera client pre-configured for <a
     * href="https://docs.hedera.com/guides/mainnet/address-book#mainnet-address-book">Mainnet access</a>.
     *
     * @param executor runs the grpc requests asynchronously. Note that calling `close()` method on one of the
     *                 clients will close the executor for all the other clients sharing this executor
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forMainnet(ExecutorService executor) {
        var network = Network.forMainnet(executor);
        var mirrorNetwork = MirrorNetwork.forMainnet(executor);

        return new Client(executor, network, mirrorNetwork, NETWORK_UPDATE_INITIAL_DELAY,
            DEFAULT_NETWORK_UPDATE_PERIOD);
    }

    /**
     * Construct a Hedera client pre-configured for <a href="https://docs.hedera.com/guides/testnet/nodes">Testnet
     * access</a>.
     *
     * @param executor runs the grpc requests asynchronously. Note that calling `close()` method on one of the
     *                 clients will close the executor for all the other clients sharing this executor
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forTestnet(ExecutorService executor) {
        var network = Network.forTestnet(executor);
        var mirrorNetwork = MirrorNetwork.forTestnet(executor);

        return new Client(executor, network, mirrorNetwork, NETWORK_UPDATE_INITIAL_DELAY,
            DEFAULT_NETWORK_UPDATE_PERIOD);
    }

    /**
     * Construct a Hedera client pre-configured for <a
     * href="https://docs.hedera.com/guides/testnet/testnet-nodes#previewnet-node-public-keys">Preview Testnet
     * nodes</a>.
     *
     * @param executor runs the grpc requests asynchronously. Note that calling `close()` method on one of the
     *                 clients will close the executor for all the other clients sharing this executor
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forPreviewnet(ExecutorService executor) {
        var network = Network.forPreviewnet(executor);
        var mirrorNetwork = MirrorNetwork.forPreviewnet(executor);

        return new Client(executor, network, mirrorNetwork, NETWORK_UPDATE_INITIAL_DELAY,
            DEFAULT_NETWORK_UPDATE_PERIOD);
    }


    /**
     * Construct a Hedera client pre-configured for <a
     * href="https://docs.hedera.com/guides/mainnet/address-book#mainnet-address-book">Mainnet access</a>.
     *
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forMainnet() {
        var executor = createExecutor();
        return forMainnet(executor);
    }

    /**
     * Construct a Hedera client pre-configured for <a href="https://docs.hedera.com/guides/testnet/nodes">Testnet
     * access</a>.
     *
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forTestnet() {
        var executor = createExecutor();
        return forTestnet(executor);
    }

    /**
     * Construct a Hedera client pre-configured for <a
     * href="https://docs.hedera.com/guides/testnet/testnet-nodes#previewnet-node-public-keys">Preview Testnet
     * nodes</a>.
     *
     * @return {@link com.hedera.hashgraph.sdk.Client}
     */
    public static Client forPreviewnet() {
        var executor = createExecutor();
        return forPreviewnet(executor);
    }

    /**
     * Configure a client based off the given JSON string.
     *
     * @param json The json string containing the client configuration
     * @return {@link com.hedera.hashgraph.sdk.Client}
     * @throws Exception if the config is incorrect
     */
    public static Client fromConfig(String json) throws Exception {
        return fromConfig(new StringReader(json));
    }

    /**
     * Configure a client based off the given JSON reader.
     *
     * @param json The Reader containing the client configuration
     * @return {@link com.hedera.hashgraph.sdk.Client}
     * @throws Exception if the config is incorrect
     */
    public static Client fromConfig(Reader json) throws Exception {
        Config config = new Gson().fromJson(json, Config.class);
        Client client;

        if (config.network == null) {
            throw new Exception("Network is not set in provided json object");
        } else if (config.network.isJsonObject()) {
            var networks = config.network.getAsJsonObject();
            Map<String, AccountId> nodes = new HashMap<>(networks.size());
            for (Map.Entry<String, JsonElement> entry : networks.entrySet()) {
                nodes.put(entry.getValue().toString().replace("\"", ""),
                    AccountId.fromString(entry.getKey().replace("\"", "")));
            }
            client = Client.forNetwork(nodes);
            if (config.networkName != null) {
                var networkNameString = config.networkName.getAsString();
                try {
                    client.setNetworkName(NetworkName.fromString(networkNameString));
                } catch (Exception ignored) {
                    throw new IllegalArgumentException("networkName in config was \"" + networkNameString
                        + "\", expected either \"mainnet\", \"testnet\" or \"previewnet\"");
                }
            }
        } else {
            String networks = config.network.getAsString();
            client = switch (networks) {
                case MAINNET -> Client.forMainnet();
                case TESTNET -> Client.forTestnet();
                case PREVIEWNET -> Client.forPreviewnet();
                default -> throw new JsonParseException("Illegal argument for network.");
            };
        }

        if (config.operator != null) {
            AccountId operatorAccount = AccountId.fromString(config.operator.accountId);
            PrivateKey privateKey = PrivateKey.fromString(config.operator.privateKey);

            client.setOperator(operatorAccount, privateKey);
        }

        //already set in previous set network if?
        if (config.mirrorNetwork != null) {
            if (config.mirrorNetwork.isJsonArray()) {
                var mirrors = config.mirrorNetwork.getAsJsonArray();
                List<String> listMirrors = new ArrayList<>(mirrors.size());
                for (var i = 0; i < mirrors.size(); i++) {
                    listMirrors.add(mirrors.get(i).getAsString().replace("\"", ""));
                }
                client.setMirrorNetwork(listMirrors);
            } else {
                String mirror = config.mirrorNetwork.getAsString();
                switch (mirror) {
                    case MAINNET -> client.mirrorNetwork = MirrorNetwork.forMainnet(client.executor);
                    case TESTNET -> client.mirrorNetwork = MirrorNetwork.forTestnet(client.executor);
                    case PREVIEWNET -> client.mirrorNetwork = MirrorNetwork.forPreviewnet(client.executor);
                    default -> throw new JsonParseException("Illegal argument for mirrorNetwork.");
                }
            }
        }

        return client;
    }

    /**
     * Configure a client based on a JSON file at the given path.
     *
     * @param fileName The string containing the file path
     * @return {@link com.hedera.hashgraph.sdk.Client}
     * @throws IOException if IO operations fail
     */
    public static Client fromConfigFile(String fileName) throws Exception {
        return fromConfigFile(new File(fileName));
    }

    /**
     * Configure a client based on a JSON file.
     *
     * @param file The file containing the client configuration
     * @return {@link com.hedera.hashgraph.sdk.Client}
     * @throws IOException if IO operations fail
     */
    public static Client fromConfigFile(File file) throws Exception {
        return fromConfig(Files.newBufferedReader(file.toPath(), StandardCharsets.UTF_8));
    }

    /**
     * Extract the mirror network node list.
     *
     * @return the list of mirror nodes
     */
    synchronized public List<String> getMirrorNetwork() {
        return mirrorNetwork.getNetwork();
    }

    /**
     * Set the mirror network nodes.
     *
     * @param network list of network nodes
     * @return {@code this}
     * @throws InterruptedException when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    public synchronized Client setMirrorNetwork(List<String> network) throws InterruptedException {
        try {
            this.mirrorNetwork.setNetwork(network);
        } catch (TimeoutException e) {
            throw new RuntimeException(e);
        }

        return this;
    }

    private synchronized void scheduleNetworkUpdate(@Nullable Duration delay) {
        if (delay == null) {
            networkUpdateFuture = null;
            return;
        }
        networkUpdateFuture = Delayer.delayFor(delay.toMillis(), executor);
        networkUpdateFuture.thenRun(() -> {
            // Checking networkUpdatePeriod != null must be synchronized, so I've put it in a synchronized method.
            requireNetworkUpdatePeriodNotNull(() -> {
                new AddressBookQuery().setFileId(FileId.ADDRESS_BOOK).executeAsync(this)
                    .thenCompose(addressBook -> requireNetworkUpdatePeriodNotNull(() -> {
                        try {
                            this.setNetworkFromAddressBook(addressBook);
                        } catch (Throwable error) {
                            return CompletableFuture.failedFuture(error);
                        }
                        return CompletableFuture.completedFuture(null);
                    })).exceptionally(error -> {
                        logger.warn("Failed to update address book via mirror node query ", error);
                        return null;
                    });
                scheduleNetworkUpdate(networkUpdatePeriod);
                return null;
            });
        });
    }

    private synchronized CompletionStage<?> requireNetworkUpdatePeriodNotNull(Supplier<CompletionStage<?>> task) {
        return networkUpdatePeriod != null ? task.get() : CompletableFuture.completedFuture(null);
    }

    private void cancelScheduledNetworkUpdate() {
        if (networkUpdateFuture != null) {
            networkUpdateFuture.cancel(true);
        }
    }

    private void cancelAllSubscriptions() {
        subscriptions.forEach(SubscriptionHandle::unsubscribe);
    }

    void trackSubscription(SubscriptionHandle subscriptionHandle) {
        subscriptions.add(subscriptionHandle);
    }

    void untrackSubscription(SubscriptionHandle subscriptionHandle) {
        subscriptions.remove(subscriptionHandle);
    }

    /**
     * Replace all nodes in this Client with the nodes in the Address Book
     * and update the address book if necessary.
     *
     * @param addressBook A list of nodes and their metadata
     * @param updateAddressBook whether to update the address book of the network
     * @return {@code this}
     */
    public synchronized Client setNetworkFromAddressBook(NodeAddressBook addressBook, boolean updateAddressBook)
        throws InterruptedException, TimeoutException {
        network.setNetwork(Network.addressBookToNetwork(addressBook.nodeAddresses));
        if (updateAddressBook) {
            network.setAddressBook(addressBook);
        }
        return this;
    }

    /**
     * Replace all nodes in this Client with the nodes in the Address Book
     *
     * @param addressBook A list of nodes and their metadata
     * @return {@code this}
     * @throws InterruptedException when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     * @throws TimeoutException     when shutting down nodes
     */
    public synchronized Client setNetworkFromAddressBook(NodeAddressBook addressBook)
        throws InterruptedException, TimeoutException {
        return setNetworkFromAddressBook(addressBook, false);
    }

    /**
     * Extract the network.
     *
     * @return the client's network
     */
    synchronized public Map<String, AccountId> getNetwork() {
        return network.getNetwork();
    }

    /**
     * Replace all nodes in this Client with a new set of nodes (e.g. for an Address Book update).
     *
     * @param network a map of node account ID to node URL.
     * @return {@code this} for fluent API usage.
     * @throws TimeoutException     when shutting down nodes
     * @throws InterruptedException when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    public synchronized Client setNetwork(Map<String, AccountId> network)
        throws InterruptedException, TimeoutException {
        this.network.setNetwork(network);
        return this;
    }

    /**
     * Set if transport security should be used to connect to mirror nodes.
     * <br>
     * If transport security is enabled all connections to mirror nodes will use TLS.
     *
     * @param transportSecurity - enable or disable transport security for mirror nodes
     * @return {@code this} for fluent API usage.
     * @deprecated Mirror nodes can only be accessed using TLS
     */
    @Deprecated
    public Client setMirrorTransportSecurity(boolean transportSecurity) {
        return this;
    }

    /**
     * Is tls enabled for consensus nodes.
     *
     * @return is tls enabled
     */
    public boolean isTransportSecurity() {
        return network.isTransportSecurity();
    }

    /**
     * Set if transport security should be used to connect to consensus nodes.
     * <br>
     * If transport security is enabled all connections to consensus nodes will use TLS, and the server's certificate
     * hash will be compared to the hash stored in the {@link NodeAddressBook} for the given network.
     * <br>
     * *Note*: If transport security is enabled, but {@link Client#isVerifyCertificates()} is disabled then server
     * certificates will not be verified.
     *
     * @param transportSecurity enable or disable transport security for consensus nodes
     * @return {@code this} for fluent API usage.
     * @throws InterruptedException when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    public Client setTransportSecurity(boolean transportSecurity) throws InterruptedException {
        network.setTransportSecurity(transportSecurity);
        return this;
    }

    /**
     * Is tls enabled for mirror nodes.
     *
     * @return is tls enabled
     */
    public boolean mirrorIsTransportSecurity() {
        return mirrorNetwork.isTransportSecurity();
    }

    /**
     * Is certificate verification enabled.
     *
     * @return is certificate verification enabled
     */
    public boolean isVerifyCertificates() {
        return network.isVerifyCertificates();
    }

    /**
     * Set if server certificates should be verified against an existing address book
     *
     * @param verifyCertificates - enable or disable certificate verification
     * @return {@code this}
     */
    public Client setVerifyCertificates(boolean verifyCertificates) {
        network.setVerifyCertificates(verifyCertificates);
        return this;
    }

    /**
     * Send a ping to the given node.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @throws TimeoutException        when the transaction times out
     * @throws PrecheckStatusException when the precheck fails
     */
    public Void ping(AccountId nodeAccountId) throws PrecheckStatusException, TimeoutException {
        return ping(nodeAccountId, getRequestTimeout());
    }

    /**
     * Send a ping to the given node.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @param timeout       The timeout after which the execution attempt will be cancelled.
     * @throws TimeoutException        when the transaction times out
     * @throws PrecheckStatusException when the precheck fails
     */
    public Void ping(AccountId nodeAccountId, Duration timeout) throws PrecheckStatusException, TimeoutException {
        new AccountBalanceQuery()
            .setAccountId(nodeAccountId)
            .setNodeAccountIds(Collections.singletonList(nodeAccountId))
            .execute(this, timeout);

        return null;
    }

    /**
     * Send a ping to the given node asynchronously.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @return an empty future that throws exception if there was an error
     */
    public CompletableFuture<Void> pingAsync(AccountId nodeAccountId) {
        return pingAsync(nodeAccountId, getRequestTimeout());
    }

    /**
     * Send a ping to the given node asynchronously.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @param timeout       The timeout after which the execution attempt will be cancelled.
     * @return an empty future that throws exception if there was an error
     */
    public CompletableFuture<Void> pingAsync(AccountId nodeAccountId, Duration timeout) {
        var result = new CompletableFuture<Void>();
        new AccountBalanceQuery()
            .setAccountId(nodeAccountId)
            .setNodeAccountIds(Collections.singletonList(nodeAccountId))
            .executeAsync(this, timeout)
            .whenComplete((balance, error) -> {
                if (error == null) {
                    result.complete(null);
                } else {
                    result.completeExceptionally(error);
                }
            });
        return result;
    }

    /**
     * Send a ping to the given node asynchronously.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @param callback      a BiConsumer which handles the result or error.
     */
    public void pingAsync(AccountId nodeAccountId, BiConsumer<Void, Throwable> callback) {
        ConsumerHelper.biConsumer(pingAsync(nodeAccountId), callback);
    }

    /**
     * Send a ping to the given node asynchronously.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @param timeout       The timeout after which the execution attempt will be cancelled.
     * @param callback      a BiConsumer which handles the result or error.
     */
    public void pingAsync(AccountId nodeAccountId, Duration timeout, BiConsumer<Void, Throwable> callback) {
        ConsumerHelper.biConsumer(pingAsync(nodeAccountId, timeout), callback);
    }

    /**
     * Send a ping to the given node asynchronously.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @param onSuccess     a Consumer which consumes the result on success.
     * @param onFailure     a Consumer which consumes the error on failure.
     */
    public void pingAsync(AccountId nodeAccountId, Consumer<Void> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(pingAsync(nodeAccountId), onSuccess, onFailure);
    }

    /**
     * Send a ping to the given node asynchronously.
     *
     * @param nodeAccountId Account ID of the node to ping
     * @param timeout       The timeout after which the execution attempt will be cancelled.
     * @param onSuccess     a Consumer which consumes the result on success.
     * @param onFailure     a Consumer which consumes the error on failure.
     */
    public void pingAsync(AccountId nodeAccountId, Duration timeout, Consumer<Void> onSuccess,
        Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(pingAsync(nodeAccountId, timeout), onSuccess, onFailure);
    }

    /**
     * Sends pings to all nodes in the client's network. Combines well with setMaxAttempts(1) to remove all dead nodes
     * from the network.
     *
     * @throws TimeoutException        when the transaction times out
     * @throws PrecheckStatusException when the precheck fails
     */
    public synchronized Void pingAll() throws PrecheckStatusException, TimeoutException {
        return pingAll(getRequestTimeout());
    }

    /**
     * Sends pings to all nodes in the client's network. Combines well with setMaxAttempts(1) to remove all dead nodes
     * from the network.
     *
     * @param timeoutPerPing The timeout after which each execution attempt will be cancelled.
     * @throws TimeoutException        when the transaction times out
     * @throws PrecheckStatusException when the precheck fails
     */
    public synchronized Void pingAll(Duration timeoutPerPing) throws PrecheckStatusException, TimeoutException {
        for (var nodeAccountId : network.getNetwork().values()) {
            ping(nodeAccountId, timeoutPerPing);
        }

        return null;
    }

    /**
     * Sends pings to all nodes in the client's network asynchronously. Combines well with setMaxAttempts(1) to remove
     * all dead nodes from the network.
     *
     * @return an empty future that throws exception if there was an error
     */
    public synchronized CompletableFuture<Void> pingAllAsync() {
        return pingAllAsync(getRequestTimeout());
    }

    /**
     * Sends pings to all nodes in the client's network asynchronously. Combines well with setMaxAttempts(1) to remove
     * all dead nodes from the network.
     *
     * @param timeoutPerPing The timeout after which each execution attempt will be cancelled.
     * @return an empty future that throws exception if there was an error
     */
    public synchronized CompletableFuture<Void> pingAllAsync(Duration timeoutPerPing) {
        var network = this.network.getNetwork();
        var list = new ArrayList<CompletableFuture<Void>>(network.size());

        for (var nodeAccountId : network.values()) {
            list.add(pingAsync(nodeAccountId, timeoutPerPing));
        }

        return CompletableFuture.allOf(list.toArray(new CompletableFuture<?>[0])).thenApply((v) -> null);
    }

    /**
     * Sends pings to all nodes in the client's network asynchronously. Combines well with setMaxAttempts(1) to remove
     * all dead nodes from the network.
     *
     * @param callback a BiConsumer which handles the result or error.
     */
    public void pingAllAsync(BiConsumer<Void, Throwable> callback) {
        ConsumerHelper.biConsumer(pingAllAsync(), callback);
    }

    /**
     * Sends pings to all nodes in the client's network asynchronously. Combines well with setMaxAttempts(1) to remove
     * all dead nodes from the network.
     *
     * @param timeoutPerPing The timeout after which each execution attempt will be cancelled.
     * @param callback       a BiConsumer which handles the result or error.
     */
    public void pingAllAsync(Duration timeoutPerPing, BiConsumer<Void, Throwable> callback) {
        ConsumerHelper.biConsumer(pingAllAsync(timeoutPerPing), callback);
    }

    /**
     * Sends pings to all nodes in the client's network asynchronously. Combines well with setMaxAttempts(1) to remove
     * all dead nodes from the network.
     *
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void pingAllAsync(Consumer<Void> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(pingAllAsync(), onSuccess, onFailure);
    }

    /**
     * Sends pings to all nodes in the client's network asynchronously. Combines well with setMaxAttempts(1) to remove
     * all dead nodes from the network.
     *
     * @param timeoutPerPing The timeout after which each execution attempt will be cancelled.
     * @param onSuccess      a Consumer which consumes the result on success.
     * @param onFailure      a Consumer which consumes the error on failure.
     */
    public void pingAllAsync(Duration timeoutPerPing, Consumer<Void> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(pingAllAsync(timeoutPerPing), onSuccess, onFailure);
    }

    /**
     * Set the account that will, by default, be paying for transactions and queries built with this client.
     * <p>
     * The operator account ID is used to generate the default transaction ID for all transactions executed with this
     * client.
     * <p>
     * The operator private key is used to sign all transactions executed by this client.
     *
     * @param accountId  The AccountId of the operator
     * @param privateKey The PrivateKey of the operator
     * @return {@code this}
     */
    public synchronized Client setOperator(AccountId accountId, PrivateKey privateKey) {
        return setOperatorWith(accountId, privateKey.getPublicKey(), privateKey::sign);
    }

    /**
     * Sets the account that will, by default, by paying for transactions and queries built with this client.
     * <p>
     * The operator account ID is used to generate a default transaction ID for all transactions executed with this
     * client.
     * <p>
     * The `transactionSigner` is invoked to sign all transactions executed by this client.
     *
     * @param accountId         The AccountId of the operator
     * @param publicKey         The PrivateKey of the operator
     * @param transactionSigner The signer for the operator
     * @return {@code this}
     */
    public synchronized Client setOperatorWith(AccountId accountId, PublicKey publicKey,
        UnaryOperator<byte[]> transactionSigner) {
        if (getNetworkName() != null) {
            try {
                accountId.validateChecksum(this);
            } catch (BadEntityIdException exc) {
                throw new IllegalArgumentException(
                    "Tried to set the client operator account ID to an account ID with an invalid checksum: "
                        + exc.getMessage()
                );
            }
        }

        this.operator = new Operator(accountId, publicKey, transactionSigner);
        return this;
    }

    /**
     * Current name of the network; corresponds to ledger ID in entity ID checksum calculations.
     *
     * @return the network name
     * @deprecated use {@link #getLedgerId()} instead
     */
    @Nullable
    @Deprecated
    public synchronized NetworkName getNetworkName() {
        var ledgerId = network.getLedgerId();
        return ledgerId == null ? null : ledgerId.toNetworkName();
    }

    /**
     * Set the network name to a particular value. Useful when constructing a network which is a subset of an existing
     * known network.
     *
     * @param networkName the desired network
     * @return {@code this}
     * @deprecated use {@link #setLedgerId(LedgerId)} instead
     */
    @Deprecated
    public synchronized Client setNetworkName(@Nullable NetworkName networkName) {
        this.network.setLedgerId(networkName == null ? null : LedgerId.fromNetworkName(networkName));
        return this;
    }

    /**
     * Current LedgerId of the network; corresponds to ledger ID in entity ID checksum calculations.
     *
     * @return the ledger id
     */
    @Nullable
    public synchronized LedgerId getLedgerId() {
        return network.getLedgerId();
    }

    /**
     * Set the LedgerId to a particular value. Useful when constructing a network which is a subset of an existing known
     * network.
     *
     * @param ledgerId the desired ledger id
     * @return {@code this}
     */
    public synchronized Client setLedgerId(@Nullable LedgerId ledgerId) {
        this.network.setLedgerId(ledgerId);
        return this;
    }

    /**
     * Max number of attempts a request executed with this client will do.
     *
     * @return the maximus attempts
     */
    public synchronized int getMaxAttempts() {
        return maxAttempts;
    }

    /**
     * Set the max number of attempts a request executed with this client will do.
     *
     * @param maxAttempts the desired max attempts
     * @return {@code this}
     */
    public synchronized Client setMaxAttempts(int maxAttempts) {
        if (maxAttempts <= 0) {
            throw new IllegalArgumentException("maxAttempts must be greater than zero");
        }
        this.maxAttempts = maxAttempts;
        return this;
    }

    /**
     * The maximum amount of time to wait between retries
     *
     * @return maxBackoff
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getMaxBackoff() {
        return maxBackoff;
    }

    /**
     * The maximum amount of time to wait between retries. Every retry attempt will increase the wait time exponentially
     * until it reaches this time.
     *
     * @param maxBackoff The maximum amount of time to wait between retries
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public Client setMaxBackoff(Duration maxBackoff) {
        if (maxBackoff == null || maxBackoff.toNanos() < 0) {
            throw new IllegalArgumentException("maxBackoff must be a positive duration");
        } else if (maxBackoff.compareTo(minBackoff) < 0) {
            throw new IllegalArgumentException("maxBackoff must be greater than or equal to minBackoff");
        }
        this.maxBackoff = maxBackoff;
        return this;
    }

    /**
     * The minimum amount of time to wait between retries
     *
     * @return minBackoff
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getMinBackoff() {
        return minBackoff;
    }

    /**
     * The minimum amount of time to wait between retries. When retrying, the delay will start at this time and increase
     * exponentially until it reaches the maxBackoff.
     *
     * @param minBackoff The minimum amount of time to wait between retries
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public Client setMinBackoff(Duration minBackoff) {
        if (minBackoff == null || minBackoff.toNanos() < 0) {
            throw new IllegalArgumentException("minBackoff must be a positive duration");
        } else if (minBackoff.compareTo(maxBackoff) > 0) {
            throw new IllegalArgumentException("minBackoff must be less than or equal to maxBackoff");
        }
        this.minBackoff = minBackoff;
        return this;
    }

    /**
     * Max number of times any node in the network can receive a bad gRPC status before being removed from the network.
     *
     * @return the maximum node attempts
     */
    public synchronized int getMaxNodeAttempts() {
        return network.getMaxNodeAttempts();
    }

    /**
     * Set the max number of times any node in the network can receive a bad gRPC status before being removed from the
     * network.
     *
     * @param maxNodeAttempts the desired minimum attempts
     * @return {@code this}
     */
    public synchronized Client setMaxNodeAttempts(int maxNodeAttempts) {
        this.network.setMaxNodeAttempts(maxNodeAttempts);
        return this;
    }

    /**
     * The minimum backoff time for any node in the network.
     *
     * @return the wait time
     * @deprecated - Use {@link Client#getNodeMaxBackoff()} instead
     */
    @Deprecated
    public synchronized Duration getNodeWaitTime() {
        return getNodeMinBackoff();
    }

    /**
     * Set the minimum backoff time for any node in the network.
     *
     * @param nodeWaitTime the wait time
     * @return the updated client
     * @deprecated - Use {@link Client#setNodeMinBackoff(Duration)} ()} instead
     */
    @Deprecated
    public synchronized Client setNodeWaitTime(Duration nodeWaitTime) {
        return setNodeMinBackoff(nodeWaitTime);
    }

    /**
     * The minimum backoff time for any node in the network.
     *
     * @return the minimum backoff time
     */
    public synchronized Duration getNodeMinBackoff() {
        return network.getMinNodeBackoff();
    }

    /**
     * Set the minimum backoff time for any node in the network.
     *
     * @param minBackoff the desired minimum backoff time
     * @return {@code this}
     */
    public synchronized Client setNodeMinBackoff(Duration minBackoff) {
        network.setMinNodeBackoff(minBackoff);
        return this;
    }

    /**
     * The maximum backoff time for any node in the network.
     *
     * @return the maximum node backoff time
     */
    public synchronized Duration getNodeMaxBackoff() {
        return network.getMaxNodeBackoff();
    }

    /**
     * Set the maximum backoff time for any node in the network.
     *
     * @param maxBackoff the desired max backoff time
     * @return {@code this}
     */
    public synchronized Client setNodeMaxBackoff(Duration maxBackoff) {
        network.setMaxNodeBackoff(maxBackoff);
        return this;
    }

    /**
     * Extract the minimum node readmit time.
     *
     * @return the minimum node readmit time
     */
    public Duration getMinNodeReadmitTime() {
        return network.getMinNodeReadmitTime();
    }

    /**
     * Assign the minimum node readmit time.
     *
     * @param minNodeReadmitTime the requested duration
     * @return {@code this}
     */
    public Client setMinNodeReadmitTime(Duration minNodeReadmitTime) {
        network.setMinNodeReadmitTime(minNodeReadmitTime);
        return this;
    }

    /**
     * Extract the node readmit time.
     *
     * @return the maximum node readmit time
     */
    public Duration getMaxNodeReadmitTime() {
        return network.getMaxNodeReadmitTime();
    }

    /**
     * Assign the maximum node readmit time.
     *
     * @param maxNodeReadmitTime the maximum node readmit time
     * @return {@code this}
     */
    public Client setMaxNodeReadmitTime(Duration maxNodeReadmitTime) {
        network.setMaxNodeReadmitTime(maxNodeReadmitTime);
        return this;
    }

    /**
     * Set the max amount of nodes that will be chosen per request. By default, the request will use 1/3rd the network
     * nodes per request.
     *
     * @param maxNodesPerTransaction the desired number of nodes
     * @return {@code this}
     */
    public synchronized Client setMaxNodesPerTransaction(int maxNodesPerTransaction) {
        this.network.setMaxNodesPerRequest(maxNodesPerTransaction);
        return this;
    }

    /**
     * Enable or disable automatic entity ID checksum validation.
     *
     * @param value the desired value
     * @return {@code this}
     */
    public synchronized Client setAutoValidateChecksums(boolean value) {
        autoValidateChecksums = value;
        return this;
    }

    /**
     * Is automatic entity ID checksum validation enabled.
     *
     * @return is validation enabled
     */
    public synchronized boolean isAutoValidateChecksumsEnabled() {
        return autoValidateChecksums;
    }

    /**
     * Get the ID of the operator. Useful when the client was constructed from file.
     *
     * @return {AccountId}
     */
    @Nullable
    public synchronized AccountId getOperatorAccountId() {
        if (operator == null) {
            return null;
        }

        return operator.accountId;
    }

    /**
     * Get the key of the operator. Useful when the client was constructed from file.
     *
     * @return {PublicKey}
     */
    @Nullable
    public synchronized PublicKey getOperatorPublicKey() {
        if (operator == null) {
            return null;
        }

        return operator.publicKey;
    }

    /**
     * The default maximum fee used for transactions.
     *
     * @return the max transaction fee
     */
    @Nullable
    public synchronized Hbar getDefaultMaxTransactionFee() {
        return defaultMaxTransactionFee;
    }

    /**
     * Set the maximum fee to be paid for transactions executed by this client.
     * <p>
     * Because transaction fees are always maximums, this will simply add a call to
     * {@link Transaction#setMaxTransactionFee(Hbar)} on every new transaction. The actual fee assessed for a given
     * transaction may be less than this value, but never greater.
     *
     * @param defaultMaxTransactionFee The Hbar to be set
     * @return {@code this}
     */
    public synchronized Client setDefaultMaxTransactionFee(Hbar defaultMaxTransactionFee) {
        Objects.requireNonNull(defaultMaxTransactionFee);
        if (defaultMaxTransactionFee.toTinybars() < 0) {
            throw new IllegalArgumentException("maxTransactionFee must be non-negative");
        }

        this.defaultMaxTransactionFee = defaultMaxTransactionFee;
        return this;
    }

    /**
     * Set the maximum fee to be paid for transactions executed by this client.
     * <p>
     * Because transaction fees are always maximums, this will simply add a call to
     * {@link Transaction#setMaxTransactionFee(Hbar)} on every new transaction. The actual fee assessed for a given
     * transaction may be less than this value, but never greater.
     *
     * @param maxTransactionFee The Hbar to be set
     * @return {@code this}
     * @deprecated Use {@link #setDefaultMaxTransactionFee(Hbar)} instead.
     */
    @Deprecated
    public synchronized Client setMaxTransactionFee(Hbar maxTransactionFee) {
        return setDefaultMaxTransactionFee(maxTransactionFee);
    }

    /**
     * Extract the maximum query payment.
     *
     * @return the default maximum query payment
     */
    public synchronized Hbar getDefaultMaxQueryPayment() {
        return defaultMaxQueryPayment;
    }

    /**
     * Set the maximum default payment allowable for queries.
     * <p>
     * When a query is executed without an explicit {@link Query#setQueryPayment(Hbar)} call, the client will first
     * request the cost of the given query from the node it will be submitted to and attach a payment for that amount
     * from the operator account on the client.
     * <p>
     * If the returned value is greater than this value, a {@link MaxQueryPaymentExceededException} will be thrown from
     * {@link Query#execute(Client)} or returned in the second callback of
     * {@link Query#executeAsync(Client, Consumer, Consumer)}.
     * <p>
     * Set to 0 to disable automatic implicit payments.
     *
     * @param defaultMaxQueryPayment The Hbar to be set
     * @return {@code this}
     */
    public synchronized Client setDefaultMaxQueryPayment(Hbar defaultMaxQueryPayment) {
        Objects.requireNonNull(defaultMaxQueryPayment);
        if (defaultMaxQueryPayment.toTinybars() < 0) {
            throw new IllegalArgumentException("defaultMaxQueryPayment must be non-negative");
        }

        this.defaultMaxQueryPayment = defaultMaxQueryPayment;
        return this;
    }

    /**
     * @param maxQueryPayment The Hbar to be set
     * @return {@code this}
     * @deprecated Use {@link #setDefaultMaxQueryPayment(Hbar)} instead.
     */
    @Deprecated
    public synchronized Client setMaxQueryPayment(Hbar maxQueryPayment) {
        return setDefaultMaxQueryPayment(maxQueryPayment);
    }

    /**
     * Should the transaction id be regenerated?
     *
     * @return the default regenerate transaction id
     */
    public synchronized boolean getDefaultRegenerateTransactionId() {
        return defaultRegenerateTransactionId;
    }

    /**
     * Assign the default regenerate transaction id.
     *
     * @param regenerateTransactionId should there be a regenerated transaction id
     * @return {@code this}
     */
    public synchronized Client setDefaultRegenerateTransactionId(boolean regenerateTransactionId) {
        this.defaultRegenerateTransactionId = regenerateTransactionId;
        return this;
    }

    /**
     * Maximum amount of time a request can run
     *
     * @return the timeout value
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public synchronized Duration getRequestTimeout() {
        return requestTimeout;
    }

    /**
     * Set the maximum amount of time a request can run. Used only in async variants of methods.
     *
     * @param requestTimeout the timeout value
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public synchronized Client setRequestTimeout(Duration requestTimeout) {
        this.requestTimeout = Objects.requireNonNull(requestTimeout);
        return this;
    }

    /**
     * Maximum amount of time closing a network can take.
     *
     * @return the timeout value
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getCloseTimeout() {
        return closeTimeout;
    }

    /**
     * Set the maximum amount of time closing a network can take.
     *
     * @param closeTimeout the timeout value
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public Client setCloseTimeout(Duration closeTimeout) {
        this.closeTimeout = Objects.requireNonNull(closeTimeout);
        network.setCloseTimeout(closeTimeout);
        mirrorNetwork.setCloseTimeout(closeTimeout);
        return this;
    }

    /**
     * Maximum amount of time a gRPC request can run
     *
     * @return the gRPC deadline value
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getGrpcDeadline() {
        return grpcDeadline.get();
    }

    /**
     * Set the maximum amount of time a gRPC request can run.
     *
     * @param grpcDeadline the gRPC deadline value
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public Client setGrpcDeadline(Duration grpcDeadline) {
        this.grpcDeadline.set(Objects.requireNonNull(grpcDeadline));
        return this;
    }

    /**
     * Extract the operator.
     *
     * @return the operator
     */
    @Nullable
    synchronized Operator getOperator() {
        return this.operator;
    }

    /**
     * Get the period for updating the Address Book
     *
     * @return the networkUpdatePeriod
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    @Nullable
    public synchronized Duration getNetworkUpdatePeriod() {
        return this.networkUpdatePeriod;
    }

    /**
     * Set the period for updating the Address Book
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 31
     * because it uses features introduced in API level 31 (Android 12).</p>*
     *
     * @param networkUpdatePeriod the period for updating the Address Book
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public synchronized Client setNetworkUpdatePeriod(Duration networkUpdatePeriod) {
        cancelScheduledNetworkUpdate();
        this.networkUpdatePeriod = networkUpdatePeriod;
        scheduleNetworkUpdate(networkUpdatePeriod);
        return this;
    }

    public Logger getLogger() {
        return this.logger;
    }

    public Client setLogger(Logger logger) {
        this.logger = logger;
        return this;
    }

    /**
     * Initiates an orderly shutdown of all channels (to the Hedera network) in which preexisting transactions or
     * queries continue but more would be immediately cancelled.
     *
     * <p>After this method returns, this client can be re-used. Channels will be re-established as
     * needed.
     *
     * @throws TimeoutException if the mirror network doesn't close in time
     */
    @Override
    public synchronized void close() throws TimeoutException {
        close(closeTimeout);
    }

    /**
     * Initiates an orderly shutdown of all channels (to the Hedera network),
     * without closing the ExecutorService {@link #executor}
     *
     * @throws TimeoutException if the network doesn't close in time
     */
    public synchronized void closeChannels() throws TimeoutException {
        var closeDeadline = Instant.now().plus(closeTimeout);

        networkUpdatePeriod = null;
        cancelScheduledNetworkUpdate();
        cancelAllSubscriptions();

        network.beginClose();
        mirrorNetwork.beginClose();

        var networkError = network.awaitClose(closeDeadline, null);
        var mirrorNetworkError = mirrorNetwork.awaitClose(closeDeadline, networkError);

        if (mirrorNetworkError != null) {
            if (mirrorNetworkError instanceof TimeoutException ex) {
                throw ex;
            } else {
                throw new RuntimeException(mirrorNetworkError);
            }
        }
    }

    /**
     * Initiates an orderly shutdown of all channels (to the Hedera network) in which preexisting transactions or
     * queries continue but more would be immediately cancelled.
     *
     * <p>After this method returns, this client can be re-used. Channels will be re-established as
     * needed.
     *
     * @param timeout The Duration to be set
     * @throws TimeoutException if the mirror network doesn't close in time
     */
    public synchronized void close(Duration timeout) throws TimeoutException {
        var closeDeadline = Instant.now().plus(timeout);

        networkUpdatePeriod = null;
        cancelScheduledNetworkUpdate();
        cancelAllSubscriptions();

        network.beginClose();
        mirrorNetwork.beginClose();

        var networkError = network.awaitClose(closeDeadline, null);
        var mirrorNetworkError = mirrorNetwork.awaitClose(closeDeadline, networkError);

        // https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html
        try {
            executor.shutdown();
            if (!executor.awaitTermination(timeout.getSeconds() / 2, TimeUnit.SECONDS)) {
                executor.shutdownNow();
                if (!executor.awaitTermination(timeout.getSeconds() / 2, TimeUnit.SECONDS)) {
                    logger.warn("Pool did not terminate");
                }
            }
        } catch (InterruptedException ex) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }

        if (mirrorNetworkError != null) {
            if (mirrorNetworkError instanceof TimeoutException ex) {
                throw ex;
            } else {
                throw new RuntimeException(mirrorNetworkError);
            }
        }
    }

    static class Operator {
        final AccountId accountId;
        final PublicKey publicKey;
        final UnaryOperator<byte[]> transactionSigner;

        Operator(AccountId accountId, PublicKey publicKey, UnaryOperator<byte[]> transactionSigner) {
            this.accountId = accountId;
            this.publicKey = publicKey;
            this.transactionSigner = transactionSigner;
        }
    }

    private static class Config {
        @Nullable
        private JsonElement network;

        @Nullable
        private JsonElement networkName;

        @Nullable
        private ConfigOperator operator;

        @Nullable
        private JsonElement mirrorNetwork;

        private static class ConfigOperator {
            @Nullable
            private String accountId;

            @Nullable
            private String privateKey;
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ConsumerHelper.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.concurrent.CompletableFuture;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

class ConsumerHelper {
    static <T> void biConsumer(CompletableFuture<T> future, BiConsumer<T, Throwable> consumer) {
        future.whenComplete(consumer);
    }

    static <T> void twoConsumers(CompletableFuture<T> future, Consumer<T> onSuccess, Consumer<Throwable> onFailure) {
        future.whenComplete((output, error) -> {
            if (error != null) {
                onFailure.accept(error);
            } else {
                onSuccess.accept(output);
            }
        });
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractByteCodeQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ContractGetBytecodeQuery;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Get the bytecode for a smart contract instance.
 */
public final class ContractByteCodeQuery extends Query<ByteString, ContractByteCodeQuery> {
    @Nullable
    private ContractId contractId = null;

    /**
     * Constructor.
     */
    public ContractByteCodeQuery() {
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract ID for which information is requested.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public ContractByteCodeQuery setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        this.contractId = contractId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = ContractGetBytecodeQuery.newBuilder();
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }

        queryBuilder.setContractGetBytecode(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getContractGetBytecodeResponse().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getContractGetBytecode().getHeader();
    }

    @Override
    ByteString mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return response.getContractGetBytecodeResponse().getBytecode();
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return SmartContractServiceGrpc.getContractGetBytecodeMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractCallQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ContractCallLocalQuery;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import io.grpc.MethodDescriptor;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Call a function of the given smart contract instance, giving it functionParameters as its inputs.
 * It will consume the entire given amount of gas.
 * <p>
 * This is performed locally on the particular node that the client is communicating with.
 * It cannot change the state of the contract instance (and so, cannot spend
 * anything from the instance's cryptocurrency account).
 * <p>
 * It will not have a consensus timestamp. It cannot generate a record or a receipt.
 * The response will contain the output returned by the function call.
 * This is useful for calling getter functions, which purely read the state and don't change it.
 * It is faster and cheaper than a normal call, because it is purely local to a single  node.
 */
public final class ContractCallQuery extends Query<ContractFunctionResult, ContractCallQuery> {
    @Nullable
    private ContractId contractId = null;
    private long gas = 0;
    private byte[] functionParameters = {};
    private long maxResultSize = 0;
    @Nullable
    private AccountId senderAccountId = null;

    /**
     * Constructor.
     */
    public ContractCallQuery() {
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract instance to call, in the format used in transactions.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public ContractCallQuery setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        this.contractId = contractId;
        return this;
    }

    /**
     * Extract the gas.
     *
     * @return                          the gas
     */
    public long getGas() {
        return gas;
    }

    /**
     * Sets the amount of gas to use for the call.
     * <p>
     * All of the gas offered will be charged for.
     *
     * @param gas The long to be set as gas
     * @return {@code this}
     */
    public ContractCallQuery setGas(long gas) {
        this.gas = gas;
        return this;
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // network bug: ContractCallLocal cost estimate is too low
        return super.getCostAsync(client).thenApply(cost -> Hbar.fromTinybars((long) (cost.toTinybars() * 1.1)));
    }

    /**
     * Extract the function parameters.
     *
     * @return                          the byte string representation
     */
    public ByteString getFunctionParameters() {
        return ByteString.copyFrom(functionParameters);
    }

    /**
     * Sets the function parameters as their raw bytes.
     * <p>
     * Use this instead of {@link #setFunction(String, ContractFunctionParameters)} if you have already
     * pre-encoded a solidity function call.
     *
     * @param functionParameters The function parameters to be set
     * @return {@code this}
     */
    public ContractCallQuery setFunctionParameters(byte[] functionParameters) {
        this.functionParameters = Arrays.copyOf(functionParameters, functionParameters.length);
        return this;
    }

    /**
     * Sets the function name to call.
     * <p>
     * The function will be called with no parameters. Use {@link #setFunction(String, ContractFunctionParameters)}
     * to call a function with parameters.
     *
     * @param name The function name to be set
     * @return {@code this}
     */
    public ContractCallQuery setFunction(String name) {
        return setFunction(name, new ContractFunctionParameters());
    }

    /**
     * Sets the function to call, and the parameters to pass to the function.
     *
     * @param name   The function name to be set
     * @param params The parameters to pass
     * @return {@code this}
     */
    public ContractCallQuery setFunction(String name, ContractFunctionParameters params) {
        Objects.requireNonNull(params);
        setFunctionParameters(params.toBytes(name).toByteArray());
        return this;
    }

    /**
     * Get the max number of bytes that the result might include
     *
     * @deprecated with no replacement
     * @return the max number of byes
     */
    @Deprecated
    public long getMaxResultSize() {
        return maxResultSize;
    }

    /**
     * @deprecated with no replacement
     * <br>
     * Sets the max number of bytes that the result might include.
     * The run will fail if it had returned more than this number of bytes.
     *
     * @param size The long to be set as size
     * @return {@code this}
     */
    @Deprecated
    public ContractCallQuery setMaxResultSize(long size) {
        maxResultSize = size;
        return this;
    }

    /**
     * Get the sender account ID
     * @return the account that is the "sender"
     */
    @Nullable
    public AccountId getSenderAccountId() {
        return senderAccountId;
    }

    /**
     * Sets the account that is the "sender." If not present it is the accountId from the transactionId.
     * Typically a different value than specified in the transactionId requires a valid signature
     * over either the hedera transaction or foreign transaction data.
     *
     * @param senderAccountId the account that is the "sender"
     * @return {@code this}
     */

    public ContractCallQuery setSenderAccountId(AccountId senderAccountId) {
        Objects.requireNonNull(senderAccountId);
        this.senderAccountId = senderAccountId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = ContractCallLocalQuery.newBuilder();
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }
        builder.setGas(gas);
        builder.setFunctionParameters(ByteString.copyFrom(functionParameters));
        if (senderAccountId != null) {
            builder.setSenderId(senderAccountId.toProtobuf());
        }

        queryBuilder.setContractCallLocal(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getContractCallLocal().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getContractCallLocal().getHeader();
    }

    @Override
    ContractFunctionResult mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return new ContractFunctionResult(response.getContractCallLocal().getFunctionResult());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return SmartContractServiceGrpc.getContractCallLocalMethodMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractCreateFlow.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.Hex;

/**
 * Start a new smart contract instance. After the instance is created, the ContractID for it is in the receipt.
 * <p>
 * The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew itself for another
 * autoRenewPeriod seconds by charging its associated cryptocurrency account (which it creates here). If it has
 * insufficient cryptocurrency to extend that long, it will extend as long as it can. If its balance is zero, the
 * instance will be deleted.
 * <p>
 * A smart contract instance normally enforces rules, so "the code is law". For example, an ERC-20 contract prevents a
 * transfer from being undone without a signature by the recipient of the transfer. This is always enforced if the
 * contract instance was created with the adminKeys being null. But for some uses, it might be desirable to create
 * something like an ERC-20 contract that has a specific group of trusted individuals who can act as a "supreme court"
 * with the ability to override the normal operation, when a sufficient number of them agree to do so. If adminKeys is
 * not null, then they can sign a transaction that can change the state of the smart contract in arbitrary ways, such as
 * to reverse a transaction that violates some standard of behavior that is not covered by the code itself. The admin
 * keys can also be used to change the autoRenewPeriod, and change the adminKeys field itself. The API currently does
 * not implement this ability. But it does allow the adminKeys field to be set and queried, and will in the future
 * implement such admin abilities for any instance that has a non-null adminKeys.
 * <p>
 * If this constructor stores information, it is charged gas to store it. There is a fee in hbars to maintain that
 * storage until the expiration time, and that fee is added as part of the transaction fee.
 * <p>
 * An entity (account, file, or smart contract instance) must be created in a particular realm. If the realmID is left
 * null, then a new realm will be created with the given admin key. If a new realm has a null adminKey, then anyone can
 * create/modify/delete entities in that realm. But if an admin key is given, then any transaction to
 * create/modify/delete an entity in that realm must be signed by that key, though anyone can still call functions on
 * smart contract instances that exist in that realm. A realm ceases to exist when everything within it has expired and
 * no longer exists.
 * <p>
 * The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0, with a
 * null key. Future versions of the API will support multiple realms and multiple shards.
 * <p>
 * The optional memo field can contain a string whose length is up to 100 bytes. That is the size after Unicode NFD then
 * UTF-8 conversion. This field can be used to describe the smart contract. It could also be used for other purposes.
 * One recommended purpose is to hold a hexadecimal string that is the SHA-384 hash of a PDF file containing a
 * human-readable legal contract. Then, if the admin keys are the public keys of human arbitrators, they can use that
 * legal document to guide their decisions during a binding arbitration tribunal, convened to consider any changes to
 * the smart contract in the future. The memo field can only be changed using the admin keys. If there are no admin
 * keys, then it cannot be changed after the smart contract is created.
 */

// Re-use the WithExecute interface that was generated for Executable
public class ContractCreateFlow {
    static final int FILE_CREATE_MAX_BYTES = 2048;

    private String bytecode = "";
    @Nullable
    private Integer maxChunks = null;
    @Nullable
    private Key adminKey = null;
    private long gas = 0;
    private Hbar initialBalance = Hbar.ZERO;
    @Nullable
    private AccountId proxyAccountId = null;
    private int maxAutomaticTokenAssociations = 0;
    @Nullable
    private Duration autoRenewPeriod = null;
    @Nullable
    private AccountId autoRenewAccountId = null;
    private byte[] constructorParameters = {};
    @Nullable
    private String contractMemo = null;
    @Nullable
    private List<AccountId> nodeAccountIds = null;
    private String createBytecode = "";
    private String appendBytecode = "";

    @Nullable
    private AccountId stakedAccountId = null;

    @Nullable
    private Long stakedNodeId = null;

    private boolean declineStakingReward = false;

    @Nullable
    private Client freezeWithClient = null;

    @Nullable
    private PrivateKey signPrivateKey = null;

    @Nullable
    private PublicKey signPublicKey = null;

    @Nullable
    private UnaryOperator<byte[]> transactionSigner = null;

    /**
     * Constructor
     */
    public ContractCreateFlow() {
    }

    /**
     * Extract the hex-encoded bytecode of the contract.
     *
     * @return the hex-encoded bytecode of the contract.
     */
    public String getBytecode() {
        return bytecode;
    }

    /**
     * Sets the bytecode of the contract in hex.
     *
     * @param bytecode the string to assign
     * @return {@code this}
     */
    public ContractCreateFlow setBytecode(String bytecode) {
        Objects.requireNonNull(bytecode);
        this.bytecode = bytecode;
        return this;
    }

    /**
     * Sets the bytecode of the contract in raw bytes.
     *
     * @param bytecode the byte array
     * @return {@code this}
     */
    public ContractCreateFlow setBytecode(byte[] bytecode) {
        Objects.requireNonNull(bytecode);
        this.bytecode = Hex.toHexString(bytecode);
        return this;
    }

    /**
     * Sets the bytecode of the contract in raw bytes.
     *
     * @param bytecode the byte string
     * @return the contract in raw bytes
     */
    public ContractCreateFlow setBytecode(ByteString bytecode) {
        Objects.requireNonNull(bytecode);
        return setBytecode(bytecode.toByteArray());
    }

    /**
     * Get the maximum number of chunks
     *
     * @return the maxChunks
     */
    @Nullable
    public Integer getMaxChunks() {
        return maxChunks;
    }

    /**
     * Set the maximal number of chunks
     *
     * @param maxChunks the maximum number of chunks
     * @return {@code this}
     */
    public ContractCreateFlow setMaxChunks(int maxChunks) {
        this.maxChunks = maxChunks;
        return this;
    }

    /**
     * Extract the admin key.
     *
     * @return the admin key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Sets the state of the instance and its fields can be modified arbitrarily if this key signs a transaction to
     * modify it. If this is null, then such modifications are not possible, and there is no administrator that can
     * override the normal operation of this smart contract instance. Note that if it is created with no admin keys,
     * then there is no administrator to authorize changing the admin keys, so there can never be any admin keys for
     * that instance.
     *
     * @param adminKey The Key to be set
     * @return {@code this}
     */
    public ContractCreateFlow setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Extract the gas.
     *
     * @return the gas
     */
    public long getGas() {
        return gas;
    }

    /**
     * Sets the gas to run the constructor.
     *
     * @param gas The long to be set as gas
     * @return {@code this}
     */
    public ContractCreateFlow setGas(long gas) {
        this.gas = gas;
        return this;
    }

    /**
     * Extract the initial balance in hbar.
     *
     * @return the initial balance in hbar
     */
    public Hbar getInitialBalance() {
        return initialBalance;
    }

    /**
     * Sets the initial number of hbars to put into the cryptocurrency account associated with and owned by the smart
     * contract.
     *
     * @param initialBalance The Hbar to be set as the initial balance
     * @return {@code this}
     */
    public ContractCreateFlow setInitialBalance(Hbar initialBalance) {
        Objects.requireNonNull(initialBalance);
        this.initialBalance = initialBalance;
        return this;
    }

    /**
     * @return the proxy account id
     * @deprecated with no replacement
     * <p>
     * Extract the proxy account id.
     */
    @Nullable
    @Deprecated
    public AccountId getProxyAccountId() {
        return proxyAccountId;
    }

    /**
     * @param proxyAccountId The AccountId to be set
     * @return {@code this}
     * @deprecated with no replacement
     * <p>
     * Sets the ID of the account to which this account is proxy staked.
     * <p>
     * If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is
     * automatically proxy staked to a node chosen by the network, but without earning payments.
     * <p>
     * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it
     * will behave as if  proxyAccountID was null.
     */
    @Deprecated
    public ContractCreateFlow setProxyAccountId(AccountId proxyAccountId) {
        Objects.requireNonNull(proxyAccountId);
        this.proxyAccountId = proxyAccountId;
        return this;
    }

    /**
     * The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0 and up to a maximum
     * value of 1000.
     *
     * @return The maxAutomaticTokenAssociations.
     */
    public int getMaxAutomaticTokenAssociations() {
        return maxAutomaticTokenAssociations;
    }

    /**
     * The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0 and up to a maximum
     * value of 1000.
     *
     * @param maxAutomaticTokenAssociations The maxAutomaticTokenAssociations to set
     * @return {@code this}
     */
    public ContractCreateFlow setMaxAutomaticTokenAssociations(int maxAutomaticTokenAssociations) {
        this.maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Sets the period that the instance will charge its account every this many seconds to renew.
     *
     * @param autoRenewPeriod The Duration to be set for auto renewal
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public ContractCreateFlow setAutoRenewPeriod(Duration autoRenewPeriod) {
        Objects.requireNonNull(autoRenewPeriod);
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * Get the account ID which will be charged for renewing this account
     *
     * @return the auto-renewal account id
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * Set the account ID which will be charged for renewing this account
     *
     * @param autoRenewAccountId the autoRenewAccountId to set
     * @return {@code this}
     */
    public ContractCreateFlow setAutoRenewAccountId(AccountId autoRenewAccountId) {
        Objects.requireNonNull(autoRenewAccountId);
        this.autoRenewAccountId = autoRenewAccountId;
        return this;
    }

    /**
     * Extract the byte string representation.
     *
     * @return the byte string representation
     */
    public ByteString getConstructorParameters() {
        return ByteString.copyFrom(constructorParameters);
    }

    /**
     * Sets the constructor parameters as their raw bytes.
     * <p>
     * Use this instead of {@link #setConstructorParameters(ContractFunctionParameters)} if you have already pre-encoded
     * a solidity function call.
     *
     * @param constructorParameters The constructor parameters
     * @return {@code this}
     */
    public ContractCreateFlow setConstructorParameters(byte[] constructorParameters) {
        this.constructorParameters = Arrays.copyOf(constructorParameters, constructorParameters.length);
        return this;
    }

    /**
     * Sets the parameters to pass to the constructor.
     *
     * @param constructorParameters The contructor parameters
     * @return {@code this}
     */
    public ContractCreateFlow setConstructorParameters(ContractFunctionParameters constructorParameters) {
        Objects.requireNonNull(constructorParameters);
        return setConstructorParameters(constructorParameters.toBytes(null).toByteArray());
    }

    /**
     * Extract the contract memo.
     *
     * @return the contract memo
     */
    public String getContractMemo() {
        return contractMemo;
    }

    /**
     * Sets the memo to be associated with this contract.
     *
     * @param memo The String to be set as the memo
     * @return {@code this}
     */
    public ContractCreateFlow setContractMemo(String memo) {
        Objects.requireNonNull(memo);
        contractMemo = memo;
        return this;
    }

    /**
     * ID of the account to which this contract will stake
     *
     * @return ID of the account to which this contract will stake.
     */
    @Nullable
    public AccountId getStakedAccountId() {
        return stakedAccountId;
    }

    /**
     * Set the account to which this contract will stake
     *
     * @param stakedAccountId ID of the account to which this contract will stake.
     * @return {@code this}
     */
    public ContractCreateFlow setStakedAccountId(@Nullable AccountId stakedAccountId) {
        this.stakedAccountId = stakedAccountId;
        this.stakedNodeId = null;
        return this;
    }

    /**
     * The node to which this contract will stake
     *
     * @return ID of the node this contract will be staked to.
     */
    @Nullable
    public Long getStakedNodeId() {
        return stakedNodeId;
    }

    /**
     * Set the node to which this contract will stake
     *
     * @param stakedNodeId ID of the node this contract will be staked to.
     * @return {@code this}
     */
    public ContractCreateFlow setStakedNodeId(@Nullable Long stakedNodeId) {
        this.stakedNodeId = stakedNodeId;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     *
     * @return If true, the contract declines receiving a staking reward. The default value is false.
     */
    public boolean getDeclineStakingReward() {
        return declineStakingReward;
    }

    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     *
     * @param declineStakingReward - If true, the contract declines receiving a staking reward. The default value is
     *                             false.
     * @return {@code this}
     */
    public ContractCreateFlow setDeclineStakingReward(boolean declineStakingReward) {
        this.declineStakingReward = declineStakingReward;
        return this;
    }

    /**
     * Extract the list of node account id's.
     *
     * @return the list of node account id's
     */
    @Nullable
    public List<AccountId> getNodeAccountIds() {
        return nodeAccountIds != null ? Collections.unmodifiableList(nodeAccountIds) : null;
    }

    /**
     * Set the account IDs of the nodes that this transaction will be submitted to.
     * <p>
     * Providing an explicit node account ID interferes with client-side load balancing of the network. By default, the
     * SDK will pre-generate a transaction for 1/3 of the nodes on the network. If a node is down, busy, or otherwise
     * reports a fatal error, the SDK will try again with a different node.
     *
     * @param nodeAccountIds The list of node AccountIds to be set
     * @return {@code this}
     */
    public ContractCreateFlow setNodeAccountIds(List<AccountId> nodeAccountIds) {
        Objects.requireNonNull(nodeAccountIds);
        this.nodeAccountIds = new ArrayList(nodeAccountIds);
        return this;
    }

    /**
     * Set the client that this transaction will be frozen with.
     *
     * @param client the client with the transaction to execute
     * @return {@code this}
     */
    public ContractCreateFlow freezeWith(Client client) {
        this.freezeWithClient = client;
        return this;
    }

    /**
     * Set the private key that this transaction will be signed with.
     *
     * @param privateKey the private key used for signing
     * @return {@code this}
     */
    public ContractCreateFlow sign(PrivateKey privateKey) {
        this.signPrivateKey = privateKey;
        this.signPublicKey = null;
        this.transactionSigner = null;
        return this;
    }

    /**
     * Set the public key and key list that this transaction will be signed with.
     *
     * @param publicKey         the public key
     * @param transactionSigner the key list
     * @return {@code this}
     */
    public ContractCreateFlow signWith(PublicKey publicKey, UnaryOperator<byte[]> transactionSigner) {
        this.signPublicKey = publicKey;
        this.transactionSigner = transactionSigner;
        this.signPrivateKey = null;
        return this;
    }

    /**
     * Set the operator that this transaction will be signed with.
     *
     * @param client the client with the transaction to execute
     * @return {@code this}
     */
    public ContractCreateFlow signWithOperator(Client client) {
        var operator = Objects.requireNonNull(client.getOperator());
        this.signPublicKey = operator.publicKey;
        this.transactionSigner = operator.transactionSigner;
        this.signPrivateKey = null;
        return this;
    }

    private void splitBytecode() {
        if (bytecode.length() > FILE_CREATE_MAX_BYTES) {
            createBytecode = bytecode.substring(0, FILE_CREATE_MAX_BYTES);
            appendBytecode = bytecode.substring(FILE_CREATE_MAX_BYTES);
        } else {
            createBytecode = bytecode;
            appendBytecode = "";
        }
    }

    private FileCreateTransaction createFileCreateTransaction(Client client) {
        var fileCreateTx = new FileCreateTransaction()
            .setKeys(Objects.requireNonNull(client.getOperatorPublicKey()))
            .setContents(createBytecode);
        if (nodeAccountIds != null) {
            fileCreateTx.setNodeAccountIds(nodeAccountIds);
        }
        return fileCreateTx;
    }

    private FileAppendTransaction createFileAppendTransaction(FileId fileId) {
        var fileAppendTx = new FileAppendTransaction()
            .setFileId(fileId)
            .setContents(appendBytecode);
        if (maxChunks != null) {
            fileAppendTx.setMaxChunks(maxChunks);
        }
        if (nodeAccountIds != null) {
            fileAppendTx.setNodeAccountIds(nodeAccountIds);
        }
        return fileAppendTx;
    }

    private ContractCreateTransaction createContractCreateTransaction(FileId fileId) {
        var contractCreateTx = new ContractCreateTransaction()
            .setBytecodeFileId(fileId)
            .setConstructorParameters(constructorParameters)
            .setGas(gas)
            .setInitialBalance(initialBalance)
            .setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations)
            .setDeclineStakingReward(declineStakingReward);
        if (adminKey != null) {
            contractCreateTx.setAdminKey(adminKey);
        }
        if (proxyAccountId != null) {
            contractCreateTx.setProxyAccountId(proxyAccountId);
        }
        if (autoRenewPeriod != null) {
            contractCreateTx.setAutoRenewPeriod(autoRenewPeriod);
        }
        if (autoRenewAccountId != null) {
            contractCreateTx.setAutoRenewAccountId(autoRenewAccountId);
        }
        if (contractMemo != null) {
            contractCreateTx.setContractMemo(contractMemo);
        }
        if (nodeAccountIds != null) {
            contractCreateTx.setNodeAccountIds(nodeAccountIds);
        }
        if (stakedAccountId != null) {
            contractCreateTx.setStakedAccountId(stakedAccountId);
        } else if (stakedNodeId != null) {
            contractCreateTx.setStakedNodeId(stakedNodeId);
        }
        if (freezeWithClient != null) {
            contractCreateTx.freezeWith(freezeWithClient);
        }
        if (signPrivateKey != null) {
            contractCreateTx.sign(signPrivateKey);
        } else if (signPublicKey != null && transactionSigner != null) {
            contractCreateTx.signWith(signPublicKey, transactionSigner);
        }
        return contractCreateTx;
    }

    /**
     * Create a new transaction receipt query.
     *
     * @param response the transaction response
     * @return the receipt query
     */
    TransactionReceiptQuery createTransactionReceiptQuery(TransactionResponse response) {
        return new TransactionReceiptQuery()
            .setNodeAccountIds(Collections.singletonList(response.nodeId))
            .setTransactionId(response.transactionId);
    }

    /**
     * Execute the transactions in the flow with the passed in client.
     *
     * @param client the client with the transaction to execute
     * @return the response
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public TransactionResponse execute(Client client) throws PrecheckStatusException, TimeoutException {
        return execute(client, client.getRequestTimeout());
    }

    /**
     * Execute the transactions in the flow with the passed in client.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @return the response
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public TransactionResponse execute(Client client, Duration timeoutPerTransaction)
        throws PrecheckStatusException, TimeoutException {
        try {
            splitBytecode();
            var fileId = createFileCreateTransaction(client)
                .execute(client, timeoutPerTransaction)
                .getReceipt(client, timeoutPerTransaction)
                .fileId;
            Objects.requireNonNull(fileId);
            if (!appendBytecode.isEmpty()) {
                createFileAppendTransaction(fileId)
                    .execute(client, timeoutPerTransaction);
            }
            var response = createContractCreateTransaction(fileId).execute(client, timeoutPerTransaction);
            response.getReceipt(client, timeoutPerTransaction);
            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(client, timeoutPerTransaction);
            return response;
        } catch (ReceiptStatusException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client the client with the transaction to execute
     * @return the response
     */
    public CompletableFuture<TransactionResponse> executeAsync(Client client) {
        return executeAsync(client, client.getRequestTimeout());
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @return the response
     */
    public CompletableFuture<TransactionResponse> executeAsync(Client client, Duration timeoutPerTransaction) {
        splitBytecode();
        return createFileCreateTransaction(client).executeAsync(client, timeoutPerTransaction)
            .thenCompose(fileCreateResponse -> createTransactionReceiptQuery(fileCreateResponse)
                .executeAsync(client, timeoutPerTransaction)
                .thenApply(receipt -> receipt.fileId)).thenCompose(fileId -> {
                CompletableFuture<Void> appendFuture =
                    appendBytecode.isEmpty() ? CompletableFuture.completedFuture(null) :
                        createFileAppendTransaction(fileId).executeAsync(client, timeoutPerTransaction)
                            .thenApply(ignored -> null);
                return appendFuture.thenCompose(
                    ignored -> createContractCreateTransaction(fileId).executeAsync(client, timeoutPerTransaction)
                        .thenApply(contractCreateResponse -> {
                            createTransactionReceiptQuery(contractCreateResponse).executeAsync(client,
                                timeoutPerTransaction).thenRun(() -> {
                                new FileDeleteTransaction()
                                    .setFileId(fileId)
                                    .executeAsync(client, timeoutPerTransaction);
                            });
                            return contractCreateResponse;
                        }));
            });
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client   the client with the transaction to execute
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, BiConsumer<TransactionResponse, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client), callback);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @param callback              a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, Duration timeoutPerTransaction,
        BiConsumer<TransactionResponse, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client, timeoutPerTransaction), callback);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client    the client with the transaction to execute
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Consumer<TransactionResponse> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client), onSuccess, onFailure);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @param onSuccess             a Consumer which consumes the result on success.
     * @param onFailure             a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Duration timeoutPerTransaction, Consumer<TransactionResponse> onSuccess,
        Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client, timeoutPerTransaction), onSuccess, onFailure);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import org.bouncycastle.util.Arrays;
import java.time.Duration;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Start a new smart contract instance.
 * After the instance is created,
 * the ContractID for it is in the receipt.
 * <p>
 * The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew itself for another
 * autoRenewPeriod seconds by charging its associated cryptocurrency account (which it creates here).
 * If it has insufficient cryptocurrency to extend that long, it will extend as long as it can.
 * If its balance is zero, the instance will be deleted.
 * <p>
 * A smart contract instance normally enforces rules, so "the code is law". For example, an
 * ERC-20 contract prevents a transfer from being undone without a signature by the recipient of the transfer.
 * This is always enforced if the contract instance was created with the adminKeys being null.
 * But for some uses, it might be desirable to create something like an ERC-20 contract that has a
 * specific group of trusted individuals who can act as a "supreme court" with the ability to override the normal
 * operation, when a sufficient number of them agree to do so. If adminKeys is not null, then they can
 * sign a transaction that can change the state of the smart contract in arbitrary ways, such as to reverse
 * a transaction that violates some standard of behavior that is not covered by the code itself.
 * The admin keys can also be used to change the autoRenewPeriod, and change the adminKeys field itself.
 * The API currently does not implement this ability. But it does allow the adminKeys field to be set and
 * queried, and will in the future implement such admin abilities for any instance that has a non-null adminKeys.
 * <p>
 * If this constructor stores information, it is charged gas to store it. There is a fee in hbars to
 * maintain that storage until the expiration time, and that fee is added as part of the transaction fee.
 * <p>
 * An entity (account, file, or smart contract instance) must be created in a particular realm.
 * If the realmID is left null, then a new realm will be created with the given admin key. If a new realm has
 * a null adminKey, then anyone can create/modify/delete entities in that realm. But if an admin key is given,
 * then any transaction to create/modify/delete an entity in that realm must be signed by that key,
 * though anyone can still call functions on smart contract instances that exist in that realm.
 * A realm ceases to exist when everything within it has expired and no longer exists.
 * <p>
 * The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0,
 * with a null key. Future versions of the API will support multiple realms and multiple shards.
 * <p>
 * The optional memo field can contain a string whose length is up to 100 bytes. That is the size after Unicode
 * NFD then UTF-8 conversion. This field can be used to describe the smart contract. It could also be used for
 * other purposes. One recommended purpose is to hold a hexadecimal string that is the SHA-384 hash of a
 * PDF file containing a human-readable legal contract. Then, if the admin keys are the
 * public keys of human arbitrators, they can use that legal document to guide their decisions during a binding
 * arbitration tribunal, convened to consider any changes to the smart contract in the future. The memo field can only
 * be changed using the admin keys. If there are no admin keys, then it cannot be
 * changed after the smart contract is created.
 */
public final class ContractCreateTransaction extends Transaction<ContractCreateTransaction> {

    @Nullable
    private FileId bytecodeFileId = null;
    @Nullable
    private byte[] bytecode = null;

    /**
     * @deprecated with no replacement
     */
    @Nullable
    @Deprecated
    private AccountId proxyAccountId = null;

    @Nullable
    private Key adminKey = null;
    private long gas = 0;
    private Hbar initialBalance = new Hbar(0);
    private int maxAutomaticTokenAssociations = 0;
    @Nullable
    private Duration autoRenewPeriod = null;
    private byte[] constructorParameters = {};
    private String contractMemo = "";

    @Nullable
    private AccountId stakedAccountId = null;

    @Nullable
    private Long stakedNodeId = null;

    private boolean declineStakingReward = false;

    @Nullable
    private AccountId autoRenewAccountId = null;

    /**
     * Constructor.
     */
    public ContractCreateTransaction() {
        setAutoRenewPeriod(DEFAULT_AUTO_RENEW_PERIOD);
        defaultMaxTransactionFee = new Hbar(20);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ContractCreateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    ContractCreateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id as a byte code
     */
    @Nullable
    public FileId getBytecodeFileId() {
        return bytecodeFileId;
    }

    /**
     * Sets the file containing the smart contract byte code.
     * <p>
     * A copy will be made and held by the contract instance, and have the same expiration time as
     * the instance.
     * <p>
     * The file must be the ASCII hexadecimal representation of the smart contract bytecode.
     *
     * @param bytecodeFileId The FileId to be set
     * @return {@code this}
     */
    public ContractCreateTransaction setBytecodeFileId(FileId bytecodeFileId) {
        Objects.requireNonNull(bytecodeFileId);
        requireNotFrozen();
        this.bytecode = null;
        this.bytecodeFileId = bytecodeFileId;
        return this;
    }

    /**
     * Extract the bytecode.
     *
     * @return                          the bytecode
     */
    @Nullable
    public byte[] getBytecode() {
        return bytecode != null ? Arrays.copyOf(bytecode, bytecode.length) : null;
    }

    /**
     * Sets the smart contract byte code.
     * <br>
     * The bytes of the smart contract initcode. This is only useful if the smart contract init
     * is less than the hedera transaction limit. In those cases fileID must be used.
     *
     * @param bytecode The bytecode
     * @return {@code this}
     */

    public ContractCreateTransaction setBytecode(byte[] bytecode) {
        Objects.requireNonNull(bytecode);
        requireNotFrozen();
        this.bytecodeFileId = null;
        this.bytecode = Arrays.copyOf(bytecode, bytecode.length);
        return this;
    }

    /**
     * Get the admin key
     *
     * @return the adminKey
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Sets the state of the instance and its fields can be modified arbitrarily if this key signs a transaction
     * to modify it. If this is null, then such modifications are not possible, and there is no administrator
     * that can override the normal operation of this smart contract instance. Note that if it is created with no
     * admin keys, then there is no administrator to authorize changing the admin keys, so
     * there can never be any admin keys for that instance.
     *
     * @param adminKey The Key to be set
     * @return {@code this}
     */
    public ContractCreateTransaction setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        requireNotFrozen();
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Extract the gas.
     *
     * @return                          the gas amount that was set
     */
    public long getGas() {
        return gas;
    }

    /**
     * Sets the gas to run the constructor.
     *
     * @param gas The long to be set as gas
     * @return {@code this}
     */
    public ContractCreateTransaction setGas(long gas) {
        requireNotFrozen();
        this.gas = gas;
        return this;
    }

    /**
     * Extract the initial balance.
     *
     * @return                          the initial balance in hbar
     */
    public Hbar getInitialBalance() {
        return initialBalance;
    }

    /**
     * Sets the initial number of hbars to put into the cryptocurrency account
     * associated with and owned by the smart contract.
     *
     * @param initialBalance The Hbar to be set as the initial balance
     * @return {@code this}
     */
    public ContractCreateTransaction setInitialBalance(Hbar initialBalance) {
        Objects.requireNonNull(initialBalance);
        requireNotFrozen();
        this.initialBalance = initialBalance;
        return this;
    }

    /**
     * @deprecated with no replacement
     *
     * Extract the proxy account id.
     *
     * @return                          the proxy account id
     */
    @Deprecated
    @Nullable
    public AccountId getProxyAccountId() {
        return proxyAccountId;
    }

    /**
     * @deprecated with no replacement
     *
     * Sets the ID of the account to which this account is proxy staked.
     * <p>
     * If proxyAccountID is null, or is an invalid account, or is an account that isn't a node,
     * then this account is automatically proxy staked to a node chosen by the network, but without earning payments.
     * <p>
     * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node,
     * then it will behave as if  proxyAccountID was null.
     *
     * @param proxyAccountId The AccountId to be set
     * @return {@code this}
     */
    @Deprecated
    public ContractCreateTransaction setProxyAccountId(AccountId proxyAccountId) {
        Objects.requireNonNull(proxyAccountId);
        requireNotFrozen();
        this.proxyAccountId = proxyAccountId;
        return this;
    }

    /**
     * Get the maximum number of tokens that this contract can be
     * automatically associated with (i.e., receive air-drops from).
     *
     * @return the maxAutomaticTokenAssociations
     */
    public int getMaxAutomaticTokenAssociations() {
        return maxAutomaticTokenAssociations;
    }

    /**
     * Sets the new maximum number of tokens that this contract can be
     * automatically associated with (i.e., receive air-drops from).
     *
     * @param maxAutomaticTokenAssociations The maximum automatic token associations
     * @return  {@code this}
     */
    public ContractCreateTransaction setMaxAutomaticTokenAssociations(int maxAutomaticTokenAssociations) {
        requireNotFrozen();
        this.maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Sets the period that the instance will charge its account every this many seconds to renew.
     *
     * @param autoRenewPeriod The Duration to be set for auto renewal
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public ContractCreateTransaction setAutoRenewPeriod(Duration autoRenewPeriod) {
        Objects.requireNonNull(autoRenewPeriod);
        requireNotFrozen();
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * Extract the constructor parameters.
     *
     * @return                          the byte string representation
     */
    public ByteString getConstructorParameters() {
        return ByteString.copyFrom(constructorParameters);
    }

    /**
     * Sets the constructor parameters as their raw bytes.
     * <p>
     * Use this instead of {@link #setConstructorParameters(ContractFunctionParameters)} if you have already
     * pre-encoded a solidity function call.
     *
     * @param constructorParameters The constructor parameters
     * @return {@code this}
     */
    public ContractCreateTransaction setConstructorParameters(byte[] constructorParameters) {
        requireNotFrozen();
        this.constructorParameters = Arrays.copyOf(constructorParameters, constructorParameters.length);
        return this;
    }

    /**
     * Sets the parameters to pass to the constructor.
     *
     * @param constructorParameters The contructor parameters
     * @return {@code this}
     */
    public ContractCreateTransaction setConstructorParameters(ContractFunctionParameters constructorParameters) {
        Objects.requireNonNull(constructorParameters);
        return setConstructorParameters(constructorParameters.toBytes(null).toByteArray());
    }

    /**
     * Extract the contract memo.
     *
     * @return                          the contract's memo
     */
    public String getContractMemo() {
        return contractMemo;
    }

    /**
     * Sets the memo to be associated with this contract.
     *
     * @param memo The String to be set as the memo
     * @return {@code this}
     */
    public ContractCreateTransaction setContractMemo(String memo) {
        requireNotFrozen();
        Objects.requireNonNull(memo);
        contractMemo = memo;
        return this;
    }

    /**
     * ID of the account to which this contract will stake
     *
     * @return ID of the account to which this contract will stake.
     */
    @Nullable
    public AccountId getStakedAccountId() {
        return stakedAccountId;
    }

    /**
     * Set the account to which this contract will stake
     *
     * @param stakedAccountId ID of the account to which this contract will stake.
     * @return {@code this}
     */
    public ContractCreateTransaction setStakedAccountId(@Nullable AccountId stakedAccountId) {
        requireNotFrozen();
        this.stakedAccountId = stakedAccountId;
        this.stakedNodeId = null;
        return this;
    }

    /**
     * The node to which this contract will stake
     *
     * @return ID of the node this contract will be staked to.
     */
    @Nullable
    public Long getStakedNodeId() {
        return stakedNodeId;
    }

    /**
     * Set the node to which this contract will stake
     *
     * @param stakedNodeId ID of the node this contract will be staked to.
     * @return {@code this}
     */
    public ContractCreateTransaction setStakedNodeId(@Nullable Long stakedNodeId) {
        requireNotFrozen();
        this.stakedNodeId = stakedNodeId;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     *
     * @return If true, the contract declines receiving a staking reward. The default value is false.
     */
    public boolean getDeclineStakingReward() {
        return declineStakingReward;
    }

    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     *
     * @param declineStakingReward - If true, the contract declines receiving a staking reward. The default value is false.
     * @return {@code this}
     */
    public ContractCreateTransaction setDeclineStakingReward(boolean declineStakingReward) {
        requireNotFrozen();
        this.declineStakingReward = declineStakingReward;
        return this;
    }

    /**
     * Get the auto renew accountId.
     *
     * @return                          the auto renew accountId
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * An account to charge for auto-renewal of this contract. If not set, or set to an
     * account with zero hbar balance, the contract's own hbar balance will be used to
     * cover auto-renewal fees.
     *
     * @param autoRenewAccountId The AccountId to be set for auto renewal
     * @return {@code this}
     */
    public ContractCreateTransaction setAutoRenewAccountId(AccountId autoRenewAccountId) {
        Objects.requireNonNull(autoRenewAccountId);
        requireNotFrozen();
        this.autoRenewAccountId = autoRenewAccountId;
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link ContractCreateTransactionBody}
     */
    ContractCreateTransactionBody.Builder build() {
        var builder = ContractCreateTransactionBody.newBuilder();
        if (bytecodeFileId != null) {
            builder.setFileID(bytecodeFileId.toProtobuf());
        }
        if (bytecode != null) {
            builder.setInitcode(ByteString.copyFrom(bytecode));
        }
        if (proxyAccountId != null) {
            builder.setProxyAccountID(proxyAccountId.toProtobuf());
        }
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        builder.setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations);
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        builder.setGas(gas);
        builder.setInitialBalance(initialBalance.toTinybars());
        builder.setConstructorParameters(ByteString.copyFrom(constructorParameters));
        builder.setMemo(contractMemo);
        builder.setDeclineReward(declineStakingReward);

        if (stakedAccountId != null) {
            builder.setStakedAccountId(stakedAccountId.toProtobuf());
        } else if (stakedNodeId != null) {
            builder.setStakedNodeId(stakedNodeId);
        }

        if (autoRenewAccountId != null) {
            builder.setAutoRenewAccountId(autoRenewAccountId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (bytecodeFileId != null) {
            bytecodeFileId.validateChecksum(client);
        }

        if (proxyAccountId != null) {
            proxyAccountId.validateChecksum(client);
        }

        if (stakedAccountId != null) {
            stakedAccountId.validateChecksum(client);
        }

        if (autoRenewAccountId != null) {
            autoRenewAccountId.validateChecksum(client);
        }
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getContractCreateInstance();

        if (body.hasFileID()) {
            bytecodeFileId = FileId.fromProtobuf(body.getFileID());
        }
        if (body.hasInitcode()) {
            bytecode = body.getInitcode().toByteArray();
        }
        if (body.hasProxyAccountID()) {
            proxyAccountId = AccountId.fromProtobuf(body.getProxyAccountID());
        }
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        maxAutomaticTokenAssociations = body.getMaxAutomaticTokenAssociations();
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        gas = body.getGas();
        initialBalance = Hbar.fromTinybars(body.getInitialBalance());
        constructorParameters = body.getConstructorParameters().toByteArray();
        contractMemo = body.getMemo();
        declineStakingReward = body.getDeclineReward();

        if (body.hasStakedAccountId()) {
            stakedAccountId = AccountId.fromProtobuf(body.getStakedAccountId());
        }

        if (body.hasStakedNodeId()) {
            stakedNodeId = body.getStakedNodeId();
        }

        if (body.hasAutoRenewAccountId()) {
            autoRenewAccountId = AccountId.fromProtobuf(body.getAutoRenewAccountId());
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return SmartContractServiceGrpc.getCreateContractMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setContractCreateInstance(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setContractCreateInstance(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Marks a contract as deleted, moving all its current hbars to another account.
 */
public final class ContractDeleteTransaction extends Transaction<ContractDeleteTransaction> {

    @Nullable
    private ContractId contractId = null;
    @Nullable
    private ContractId transferContractId = null;
    @Nullable
    private AccountId transferAccountId = null;

    /**
     * Constructor.
     */
    public ContractDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ContractDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    ContractDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract ID which should be deleted.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public ContractDeleteTransaction setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        requireNotFrozen();
        this.contractId = contractId;
        return this;
    }

    /**
     * Extract the transfer account id.
     *
     * @return                          the account id that will receive the remaining hbars
     */
    @Nullable
    public AccountId getTransferAccountId() {
        return transferAccountId;
    }

    /**
     * Sets the account ID which will receive all remaining hbars.
     * <p>
     * This is mutually exclusive with {@link #setTransferContractId(ContractId)}.
     *
     * @param transferAccountId The AccountId to be set
     * @return {@code this}
     */
    public ContractDeleteTransaction setTransferAccountId(AccountId transferAccountId) {
        Objects.requireNonNull(transferAccountId);
        requireNotFrozen();
        this.transferAccountId = transferAccountId;
        return this;
    }

    /**
     * Extract the transfer contract id.
     *
     * @return                          the contract id that will receive the remaining hbars
     */
    @Nullable
    public ContractId getTransferContractId() {
        return transferContractId;
    }

    /**
     * Sets the contract ID which will receive all remaining hbars.
     * <p>
     * This is mutually exclusive with {@link #setTransferAccountId(AccountId)}.
     *
     * @param transferContractId The ContractId to be set
     * @return {@code this}
     */
    public ContractDeleteTransaction setTransferContractId(ContractId transferContractId) {
        Objects.requireNonNull(transferContractId);
        requireNotFrozen();
        this.transferContractId = transferContractId;
        return this;
    }

    /**
     * Validates tha the contract id, transfer contract id and the transfer account id are valid.
     *
     * @param client                    the configured client
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (contractId != null) {
            contractId.validateChecksum(client);
        }

        if (transferContractId != null) {
            transferContractId.validateChecksum(client);
        }

        if (transferAccountId != null) {
            transferAccountId.validateChecksum(client);
        }
    }


    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return SmartContractServiceGrpc.getDeleteContractMethod();
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getContractDeleteInstance();
        if (body.hasContractID()) {
            contractId = ContractId.fromProtobuf(body.getContractID());
        }
        if (body.hasTransferContractID()) {
            transferContractId = ContractId.fromProtobuf(body.getTransferContractID());
        }
        if (body.hasTransferAccountID()) {
            transferAccountId = AccountId.fromProtobuf(body.getTransferAccountID());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link ContractDeleteTransactionBody}
     */
    ContractDeleteTransactionBody.Builder build() {
        var builder = ContractDeleteTransactionBody.newBuilder();
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }

        if (transferAccountId != null) {
            builder.setTransferAccountID(transferAccountId.toProtobuf());
        }

        if (transferContractId != null) {
            builder.setTransferContractID(transferContractId.toProtobuf());
        }

        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setContractDeleteInstance(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setContractDeleteInstance(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractExecuteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractCallTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Call a function of the given smart contract instance, giving it parameters as its inputs.
 * <p>
 * It can use the given amount of gas, and any unspent gas will be refunded to the paying account.
 * <p>
 * If this function stores information, it is charged gas to store it.
 * There is a fee in hbars to maintain that storage until the expiration time, and that fee is
 * added as part of the transaction fee.
 */
public final class ContractExecuteTransaction extends Transaction<ContractExecuteTransaction> {

    @Nullable
    private ContractId contractId = null;
    private long gas = 0;
    private Hbar payableAmount = new Hbar(0);
    private byte[] functionParameters = {};

    /**
     * Constructor.
     */
    public ContractExecuteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ContractExecuteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    ContractExecuteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract instance to call.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public ContractExecuteTransaction setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        requireNotFrozen();
        this.contractId = contractId;
        return this;
    }

    /**
     * Extract the gas.
     *
     * @return                          the gas
     */
    public long getGas() {
        return gas;
    }

    /**
     * Sets the maximum amount of gas to use for the call.
     *
     * @param gas The long to be set as gas
     * @return {@code this}
     */
    public ContractExecuteTransaction setGas(long gas) {
        requireNotFrozen();
        this.gas = gas;
        return this;
    }

    /**
     * Extract the payable amount.
     *
     * @return                          the payable amount in hbar
     */
    public Hbar getPayableAmount() {
        return payableAmount;
    }

    /**
     * Sets the number of hbars sent with this function call.
     *
     * @param amount The Hbar to be set
     * @return {@code this}
     */
    public ContractExecuteTransaction setPayableAmount(Hbar amount) {
        Objects.requireNonNull(amount);
        requireNotFrozen();
        payableAmount = amount;
        return this;
    }

    /**
     * Extract the function parameters.
     *
     * @return                          the function parameters
     */
    public ByteString getFunctionParameters() {
        return ByteString.copyFrom(functionParameters);
    }

    /**
     * Sets the function parameters as their raw bytes.
     * <p>
     * Use this instead of {@link #setFunction(String, ContractFunctionParameters)} if you have already
     * pre-encoded a solidity function call.
     *
     * @param functionParameters The function parameters to be set
     * @return {@code this}
     */
    public ContractExecuteTransaction setFunctionParameters(ByteString functionParameters) {
        Objects.requireNonNull(functionParameters);
        requireNotFrozen();
        this.functionParameters = functionParameters.toByteArray();
        return this;
    }

    /**
     * Sets the function name to call.
     * <p>
     * The function will be called with no parameters. Use {@link #setFunction(String, ContractFunctionParameters)}
     * to call a function with parameters.
     *
     * @param name The String to be set as the function name
     * @return {@code this}
     */
    public ContractExecuteTransaction setFunction(String name) {
        return setFunction(name, new ContractFunctionParameters());
    }

    /**
     * Sets the function to call, and the parameters to pass to the function.
     *
     * @param name   The String to be set as the function name
     * @param params The function parameters to be set
     * @return {@code this}
     */
    public ContractExecuteTransaction setFunction(String name, ContractFunctionParameters params) {
        Objects.requireNonNull(params);
        return setFunctionParameters(params.toBytes(name));
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getContractCall();
        if (body.hasContractID()) {
            contractId = ContractId.fromProtobuf(body.getContractID());
        }
        gas = body.getGas();
        payableAmount = Hbar.fromTinybars(body.getAmount());
        functionParameters = body.getFunctionParameters().toByteArray();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link ContractCallTransactionBody}
     */
    ContractCallTransactionBody.Builder build() {
        var builder = ContractCallTransactionBody.newBuilder();
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }
        builder.setGas(gas);
        builder.setAmount(payableAmount.toTinybars());
        builder.setFunctionParameters(ByteString.copyFrom(functionParameters));

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return SmartContractServiceGrpc.getContractCallMethodMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setContractCall(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setContractCall(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractFunctionParameters.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.DecoderException;
import org.bouncycastle.util.encoders.Hex;

// an implementation of function selector and parameter encoding as specified here:
// https://solidity.readthedocs.io/en/v0.5.7/abi-spec.html#

/**
 * Builder for encoding parameters for a Solidity contract constructor/function call.
 * <p>
 * If you require a type which is not supported here, please let us know on
 * <a href="https://github.com/hashgraph/hedera-sdk-java/issues/298">this Github issue</a>.
 */
public final class ContractFunctionParameters {
    /**
     * The length of a Solidity address in bytes.
     */
    public static final int ADDRESS_LEN = EntityIdHelper.SOLIDITY_ADDRESS_LEN;

    /**
     * The length of a hexadecimal-encoded Solidity address, in ASCII characters (bytes).
     */
    public static final int ADDRESS_LEN_HEX = EntityIdHelper.SOLIDITY_ADDRESS_LEN_HEX;

    /**
     * Function selector length in bytes
     */
    public static final int SELECTOR_LEN = 4;

    /**
     * Function selector length in hex characters
     */
    public static final int SELECTOR_LEN_HEX = 8;

    // padding that we can substring without new allocations
    private static final ByteString padding = ByteString.copyFrom(new byte[31]);
    private static final ByteString negativePadding;

    static {
        byte[] fill = new byte[31];
        Arrays.fill(fill, (byte) 0xFF);
        negativePadding = ByteString.copyFrom(fill);
    }

    private final ArrayList<Argument> args = new ArrayList<>();

    private static ByteString encodeString(String string) {
        ByteString strBytes = ByteString.copyFromUtf8(string);
        // prepend the size of the string in UTF-8 bytes
        return int256(strBytes.size(), 32)
            .concat(rightPad32(strBytes));
    }

    private static ByteString encodeBytes(byte[] bytes) {
        return int256(bytes.length, 32)
            .concat(rightPad32(ByteString.copyFrom(bytes)));
    }

    private static ByteString encodeBytes32(byte[] bytes) {
        if (bytes.length > 32) {
            throw new IllegalArgumentException("byte32 encoding forbids byte array length greater than 32");
        }

        return rightPad32(ByteString.copyFrom(bytes));
    }

    private static ByteString encodeBool(boolean bool) {
        return int256(bool ? 1 : 0, 8);
    }

    private static ByteString encodeArray(Stream<ByteString> elements) {
        List<ByteString> list = elements.collect(Collectors.toList());

        return int256(list.size(), 32)
            .concat(ByteString.copyFrom(list));
    }

    private static ByteString encodeDynArr(List<ByteString> elements) {
        int offsetsLen = elements.size();

        // [len, offset[0], offset[1], ... offset[len - 1]]
        ArrayList<ByteString> head = new ArrayList<>(offsetsLen + 1);

        head.add(uint256(elements.size(), 32));

        // points to start of dynamic segment, *not* including the length of the array
        @Var long currOffset = offsetsLen * 32L;

        for (ByteString elem : elements) {
            head.add(uint256(currOffset, 64));
            currOffset += elem.size();
        }

        return ByteString.copyFrom(head).concat(ByteString.copyFrom(elements));
    }

    static ByteString int256(long val, int bitWidth) {
        return int256(val, bitWidth, true);
    }

    static ByteString int256(long val, @Var int bitWidth, boolean signed) {
        // don't try to get wider than a `long` as it should just be filled with padding
        bitWidth = Math.min(bitWidth, 64);
        ByteString.Output output = ByteString.newOutput(bitWidth / 8);

        try {
            // write bytes in big-endian order
            for (int i = bitWidth - 8; i >= 0; i -= 8) {
                // widening conversion sign-extends so we don't have to do anything special when
                // truncating a previously widened value
                byte u8 = (byte) (val >> i);
                output.write(u8);
            }

            // byte padding will sign-extend appropriately
            return leftPad32(output.toByteString(), signed && val < 0);
        } finally {
            try {
                output.close();
            } catch (Throwable ignored) {
                // do nothing
            }
        }
    }

    static byte[] getTruncatedBytes(BigInteger bigInt, int bitWidth) {
        byte[] bytes = bigInt.toByteArray();
        int expectedBytes = bitWidth / 8;
        return bytes.length <= expectedBytes ?
            bytes :
            Arrays.copyOfRange(bytes, bytes.length - expectedBytes, bytes.length);
    }

    static ByteString int256(BigInteger bigInt, int bitWidth) {
        return leftPad32(getTruncatedBytes(bigInt, bitWidth), bigInt.signum() < 0);
    }

    static ByteString uint256(long val, int bitWidth) {
        return int256(val, bitWidth, false);
    }

    static ByteString uint256(BigInteger bigInt, int bitWidth) {
        if (bigInt.signum() < 0) {
            throw new IllegalArgumentException("negative BigInteger passed to unsigned function");
        }
        return leftPad32(getTruncatedBytes(bigInt, bitWidth), false);
    }

    static ByteString leftPad32(ByteString input) {
        return leftPad32(input, false);
    }

    // Solidity contracts require all parameters to be padded to 32 byte multiples but specifies
    // different requirements for padding for strings/byte arrays vs integers
    static ByteString leftPad32(ByteString input, boolean negative) {
        int rem = 32 - input.size() % 32;
        return rem == 32
            ? input
            : (negative ? negativePadding : padding).substring(0, rem)
                .concat(input);
    }

    static ByteString leftPad32(byte[] input, boolean negative) {
        return leftPad32(ByteString.copyFrom(input), negative);
    }

    static ByteString rightPad32(ByteString input) {
        int rem = 32 - input.size() % 32;
        return rem == 32 ? input : input.concat(padding.substring(0, rem));
    }

    private static byte[] decodeAddress(@Var String address) {
        address = address.startsWith("0x") ? address.substring(2) : address;

        if (address.length() != ADDRESS_LEN_HEX) {
            throw new IllegalArgumentException(
                "Solidity addresses must be 40 hex chars");
        }

        try {
            return Hex.decode(address);
        } catch (DecoderException e) {
            throw new IllegalArgumentException("failed to decode Solidity address as hex", e);
        }
    }

    /**
     * Add a parameter of type {@code string}.
     * <p>
     * For Solidity addresses, use {@link #addAddress(String)}.
     *
     * @param param The String to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addString(String param) {
        args.add(new Argument("string", encodeString(param), true));

        return this;
    }

    /**
     * Add a parameter of type {@code string[]}.
     *
     * @param strings The array of Strings to be added
     * @return {@code this}
     * @throws NullPointerException if any value in `strings` is null
     */
    public ContractFunctionParameters addStringArray(String[] strings) {
        List<ByteString> byteStrings = Arrays.stream(strings)
            .map(ContractFunctionParameters::encodeString)
            .collect(Collectors.toList());

        ByteString argBytes = encodeDynArr(byteStrings);

        args.add(new Argument("string[]", argBytes, true));

        return this;
    }

    /**
     * Add a parameter of type {@code bytes}, a byte-string.
     *
     * @param param The byte-string to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addBytes(byte[] param) {
        args.add(new Argument("bytes", encodeBytes(param), true));

        return this;
    }

    /**
     * Add a parameter of type {@code bytes[]}, an array of byte-strings.
     *
     * @param param The array of byte-strings to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addBytesArray(byte[][] param) {
        List<ByteString> byteArrays = Arrays.stream(param)
            .map(ContractFunctionParameters::encodeBytes)
            .collect(Collectors.toList());

        args.add(new Argument("bytes[]", encodeDynArr(byteArrays), true));

        return this;
    }

    /**
     * Add a parameter of type {@code bytes32}, a 32-byte byte-string.
     * <p>
     * If applicable, the array will be right-padded with zero bytes to a length of 32 bytes.
     *
     * @param param The byte-string to be added
     * @return {@code this}
     * @throws IllegalArgumentException if the length of the byte array is greater than 32.
     */
    public ContractFunctionParameters addBytes32(byte[] param) {
        args.add(new Argument("bytes32", encodeBytes32(param), false));

        return this;
    }

    /**
     * Add a parameter of type {@code bytes32[]}, an array of 32-byte byte-strings.
     * <p>
     * Each byte array will be right-padded with zero bytes to a length of 32 bytes.
     *
     * @param param The array of byte-strings to be added
     * @return {@code this}
     * @throws IllegalArgumentException if the length of any byte array is greater than 32.
     */
    public ContractFunctionParameters addBytes32Array(byte[][] param) {
        // array of fixed-size elements
        Stream<ByteString> byteArrays = Arrays.stream(param)
            .map(ContractFunctionParameters::encodeBytes32);

        args.add(new Argument("bytes32[]", encodeArray(byteArrays), true));

        return this;
    }

    /**
     * Add a boolean parameter
     *
     * @param bool The bool to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addBool(boolean bool) {
        // boolean encodes to `uint8` of values [0, 1]
        args.add(new Argument("bool", encodeBool(bool), false));
        return this;
    }

    /**
     * Add a boolean array parameter
     *
     * @param param The array of booleans to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addBoolArray(boolean[] param) {
        Boolean[] boolWrapperArray = new Boolean[param.length];
        for (int i = 0; i < param.length; i++) {
            boolWrapperArray[i] = param[i];
        }

        Stream<ByteString> bools = Arrays.stream(boolWrapperArray)
            .map(ContractFunctionParameters::encodeBool);

        args.add(new Argument("bool[]", encodeArray(bools), true));

        return this;
    }

    /**
     * Add an 8-bit integer.
     * <p>
     * The implementation is wasteful as we must pad to 32-bytes to store 1 byte.
     *
     * @param value The value to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt8(byte value) {
        args.add(new Argument("int8", int256(value, 8), false));

        return this;
    }

    /**
     * Add a 16-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt16(int value) {
        args.add(new Argument("int16", int256(value, 16), false));

        return this;
    }

    /**
     * Add a 24-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt24(int value) {
        args.add(new Argument("int24", int256(value, 24), false));

        return this;
    }

    /**
     * Add a 32-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt32(int value) {
        args.add(new Argument("int32", int256(value, 32), false));

        return this;
    }

    /**
     * Add a 40-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt40(long value) {
        args.add(new Argument("int40", int256(value, 40), false));

        return this;
    }

    /**
     * Add a 48-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt48(long value) {
        args.add(new Argument("int48", int256(value, 48), false));

        return this;
    }

    /**
     * Add a 56-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt56(long value) {
        args.add(new Argument("int56", int256(value, 56), false));

        return this;
    }

    /**
     * Add a 64-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt64(long value) {
        args.add(new Argument("int64", int256(value, 64), false));

        return this;
    }

    /**
     * Add a 72-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt72(BigInteger value) {
        args.add(new Argument("int72", int256(value, 72), false));

        return this;
    }

    /**
     * Add a 80-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt80(BigInteger value) {
        args.add(new Argument("int80", int256(value, 80), false));

        return this;
    }

    /**
     * Add a 88-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt88(BigInteger value) {
        args.add(new Argument("int88", int256(value, 88), false));

        return this;
    }

    /**
     * Add a 96-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt96(BigInteger value) {
        args.add(new Argument("int96", int256(value, 96), false));

        return this;
    }

    /**
     * Add a 104-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt104(BigInteger value) {
        args.add(new Argument("int104", int256(value, 104), false));

        return this;
    }

    /**
     * Add a 112-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt112(BigInteger value) {
        args.add(new Argument("int112", int256(value, 112), false));

        return this;
    }

    /**
     * Add a 120-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt120(BigInteger value) {
        args.add(new Argument("int120", int256(value, 120), false));

        return this;
    }

    /**
     * Add a 128-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt128(BigInteger value) {
        args.add(new Argument("int128", int256(value, 128), false));

        return this;
    }

    /**
     * Add a 136-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt136(BigInteger value) {
        args.add(new Argument("int136", int256(value, 136), false));

        return this;
    }

    /**
     * Add a 144-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt144(BigInteger value) {
        args.add(new Argument("int144", int256(value, 144), false));

        return this;
    }

    /**
     * Add a 152-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt152(BigInteger value) {
        args.add(new Argument("int152", int256(value, 152), false));

        return this;
    }

    /**
     * Add a 160-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt160(BigInteger value) {
        args.add(new Argument("int160", int256(value, 160), false));

        return this;
    }

    /**
     * Add a 168-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt168(BigInteger value) {
        args.add(new Argument("int168", int256(value, 168), false));

        return this;
    }

    /**
     * Add a 176-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt176(BigInteger value) {
        args.add(new Argument("int176", int256(value, 176), false));

        return this;
    }

    /**
     * Add a 184-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt184(BigInteger value) {
        args.add(new Argument("int184", int256(value, 184), false));

        return this;
    }

    /**
     * Add a 192-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt192(BigInteger value) {
        args.add(new Argument("int192", int256(value, 192), false));

        return this;
    }

    /**
     * Add a 200-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt200(BigInteger value) {
        args.add(new Argument("int200", int256(value, 200), false));

        return this;
    }

    /**
     * Add a 208-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt208(BigInteger value) {
        args.add(new Argument("int208", int256(value, 208), false));

        return this;
    }

    /**
     * Add a 216-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt216(BigInteger value) {
        args.add(new Argument("int216", int256(value, 216), false));

        return this;
    }

    /**
     * Add a 224-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt224(BigInteger value) {
        args.add(new Argument("int224", int256(value, 224), false));

        return this;
    }

    /**
     * Add a 232-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt232(BigInteger value) {
        args.add(new Argument("int232", int256(value, 232), false));

        return this;
    }

    /**
     * Add a 240-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt240(BigInteger value) {
        args.add(new Argument("int240", int256(value, 240), false));

        return this;
    }

    /**
     * Add a 248-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt248(BigInteger value) {
        args.add(new Argument("int248", int256(value, 248), false));

        return this;
    }

    /**
     * Add a 256-bit integer.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt256(BigInteger value) {
        args.add(new Argument("int256", int256(value, 256), false));

        return this;
    }

    /**
     * Add a dynamic array of 8-bit integers.
     * <p>
     * The implementation is wasteful as we must pad to 32-bytes to store 1 byte.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt8Array(byte[] intArray) {
        IntStream intStream = IntStream.range(0, intArray.length).map(idx -> intArray[idx]);

        @Var ByteString arrayBytes = ByteString.copyFrom(
            intStream.mapToObj(i -> int256(i, 8))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int8[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 16-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt16Array(int[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 16))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int16[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 24-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt24Array(int[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 24))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int24[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 32-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt32Array(int[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 32))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int32[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 40-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt40Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 40))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int40[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 48-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt48Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 48))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int48[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 56-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt56Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 56))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int56[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 64-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt64Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> int256(i, 64))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int64[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 72-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt72Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 72))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int72[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 80-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt80Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 80))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int80[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 88-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt88Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 88))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int88[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 96-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt96Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 96))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int96[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 104-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt104Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 104))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int104[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 112-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt112Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 112))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int112[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 120-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt120Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 120))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int120[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 128-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt128Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 128))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int128[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 136-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt136Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 136))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int136[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 144-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt144Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 144))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int144[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 152-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt152Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 152))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int152[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 160-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt160Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 160))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int160[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 168-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt168Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 168))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int168[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 176-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt176Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 176))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int176[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 184-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt184Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 184))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int184[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 192-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt192Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 192))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int192[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 200-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt200Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 200))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int200[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 208-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt208Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 208))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int208[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 216-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt216Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 216))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int216[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 224-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt224Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 224))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int224[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 232-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt232Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 232))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int232[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 240-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt240Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 240))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int240[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 248-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt248Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 248))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int248[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 256-bit integers.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addInt256Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> int256(i, 256))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("int256[]", arrayBytes, true));

        return this;
    }

    /**
     * Add an unsigned 8-bit integer.
     * <p>
     * The implementation is wasteful as we must pad to 32-bytes to store 1 byte.
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint8(byte value) {
        args.add(new Argument("uint8", uint256(value, 8), false));

        return this;
    }

    /**
     * Add a 16-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint16(int value) {
        args.add(new Argument("uint16", uint256(value, 16), false));

        return this;
    }

    /**
     * Add a 24-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint24(int value) {
        args.add(new Argument("uint24", uint256(value, 24), false));

        return this;
    }

    /**
     * Add a 32-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint32(int value) {
        args.add(new Argument("uint32", uint256(value, 32), false));

        return this;
    }

    /**
     * Add a 40-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint40(long value) {
        args.add(new Argument("uint40", uint256(value, 40), false));

        return this;
    }

    /**
     * Add a 48-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint48(long value) {
        args.add(new Argument("uint48", uint256(value, 48), false));

        return this;
    }

    /**
     * Add a 56-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint56(long value) {
        args.add(new Argument("uint56", uint256(value, 56), false));

        return this;
    }

    /**
     * Add a 64-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint64(long value) {
        args.add(new Argument("uint64", uint256(value, 64), false));

        return this;
    }

    /**
     * Add a 72-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint72(BigInteger value) {
        args.add(new Argument("uint72", uint256(value, 72), false));

        return this;
    }

    /**
     * Add a 80-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint80(BigInteger value) {
        args.add(new Argument("uint80", uint256(value, 80), false));

        return this;
    }

    /**
     * Add a 88-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint88(BigInteger value) {
        args.add(new Argument("uint88", uint256(value, 88), false));

        return this;
    }

    /**
     * Add a 96-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint96(BigInteger value) {
        args.add(new Argument("uint96", uint256(value, 96), false));

        return this;
    }

    /**
     * Add a 104-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint104(BigInteger value) {
        args.add(new Argument("uint104", uint256(value, 104), false));

        return this;
    }

    /**
     * Add a 112-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint112(BigInteger value) {
        args.add(new Argument("uint112", uint256(value, 112), false));

        return this;
    }

    /**
     * Add a 120-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint120(BigInteger value) {
        args.add(new Argument("uint120", uint256(value, 120), false));

        return this;
    }

    /**
     * Add a 128-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint128(BigInteger value) {
        args.add(new Argument("uint128", uint256(value, 128), false));

        return this;
    }

    /**
     * Add a 136-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint136(BigInteger value) {
        args.add(new Argument("uint136", uint256(value, 136), false));

        return this;
    }

    /**
     * Add a 144-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint144(BigInteger value) {
        args.add(new Argument("uint144", uint256(value, 144), false));

        return this;
    }

    /**
     * Add a 152-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint152(BigInteger value) {
        args.add(new Argument("uint152", uint256(value, 152), false));

        return this;
    }

    /**
     * Add a 160-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint160(BigInteger value) {
        args.add(new Argument("uint160", uint256(value, 160), false));

        return this;
    }

    /**
     * Add a 168-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint168(BigInteger value) {
        args.add(new Argument("uint168", uint256(value, 168), false));

        return this;
    }

    /**
     * Add a 176-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint176(BigInteger value) {
        args.add(new Argument("uint176", uint256(value, 176), false));

        return this;
    }

    /**
     * Add a 184-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint184(BigInteger value) {
        args.add(new Argument("uint184", uint256(value, 184), false));

        return this;
    }

    /**
     * Add a 192-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint192(BigInteger value) {
        args.add(new Argument("uint192", uint256(value, 192), false));

        return this;
    }

    /**
     * Add a 200-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint200(BigInteger value) {
        args.add(new Argument("uint200", uint256(value, 200), false));

        return this;
    }

    /**
     * Add a 208-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint208(BigInteger value) {
        args.add(new Argument("uint208", uint256(value, 208), false));

        return this;
    }

    /**
     * Add a 216-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint216(BigInteger value) {
        args.add(new Argument("uint216", uint256(value, 216), false));

        return this;
    }

    /**
     * Add a 224-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint224(BigInteger value) {
        args.add(new Argument("uint224", uint256(value, 224), false));

        return this;
    }

    /**
     * Add a 232-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint232(BigInteger value) {
        args.add(new Argument("uint232", uint256(value, 232), false));

        return this;
    }

    /**
     * Add a 240-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint240(BigInteger value) {
        args.add(new Argument("uint240", uint256(value, 240), false));

        return this;
    }

    /**
     * Add a 248-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint248(BigInteger value) {
        args.add(new Argument("uint248", uint256(value, 248), false));

        return this;
    }

    /**
     * Add a 256-bit unsigned integer.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param value The integer to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint256(BigInteger value) {
        args.add(new Argument("uint256", uint256(value, 256), false));

        return this;
    }

    /**
     * Add a dynamic array of unsigned 8-bit integers.
     * <p>
     * The implementation is wasteful as we must pad to 32-bytes to store 1 byte.
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint8Array(byte[] intArray) {
        IntStream intStream = IntStream.range(0, intArray.length).map(idx -> intArray[idx]);

        @Var ByteString arrayBytes = ByteString.copyFrom(
            intStream.mapToObj(i -> uint256(i, 8))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint8[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 16-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint16Array(int[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 16))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint16[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 24-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint24Array(int[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 24))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint24[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 32-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint32Array(int[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 32))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint32[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 40-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint40Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 40))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint40[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 48-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint48Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 48))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint48[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 56-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint56Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 56))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint56[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 64-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     */
    public ContractFunctionParameters addUint64Array(long[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).mapToObj(i -> uint256(i, 64))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint64[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 72-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint72Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 72))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint72[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 80-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint80Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 80))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint80[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 88-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint88Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 88))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint88[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 96-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint96Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 96))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint96[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 104-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint104Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 104))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint104[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 112-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint112Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 112))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint112[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 120-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint120Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 120))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint120[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 128-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint128Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 128))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint128[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 136-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint136Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 136))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint136[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 144-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint144Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 144))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint144[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 152-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint152Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 152))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint152[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 160-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint160Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 160))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint160[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 168-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint168Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 168))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint168[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 176-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint176Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 176))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint176[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 184-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint184Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 184))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint184[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 192-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint192Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 192))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint192[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 200-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint200Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 200))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint200[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 208-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint208Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 208))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint208[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 216-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint216Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 216))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint216[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 224-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint224Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 224))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint224[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 232-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint232Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 232))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint232[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 240-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint240Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 240))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint240[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 248-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint248Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 248))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint248[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a dynamic array of 256-bit unsigned integers.
     * <p>
     * The value will be treated as unsigned during encoding (it will be zero-padded instead of sign-extended to 32
     * bytes).
     *
     * @param intArray The array of integers to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code bigInt.signum() < 0}.
     */
    public ContractFunctionParameters addUint256Array(BigInteger[] intArray) {
        @Var ByteString arrayBytes = ByteString.copyFrom(
            Arrays.stream(intArray).map(i -> uint256(i, 256))
                .collect(Collectors.toList()));

        arrayBytes = uint256(intArray.length, 32).concat(arrayBytes);

        args.add(new Argument("uint256[]", arrayBytes, true));

        return this;
    }

    /**
     * Add a {@value ADDRESS_LEN_HEX}-character hex-encoded Solidity address parameter with the type {@code address}.
     * <p>
     * Note: adding a {@code address payable} or {@code contract} parameter must also use this function as the ABI does
     * not support those types directly.
     *
     * @param address The address to be added
     * @return {@code this}
     * @throws IllegalArgumentException if the address is not exactly {@value ADDRESS_LEN_HEX} characters long or fails
     *                                  to decode as hexadecimal.
     */
    public ContractFunctionParameters addAddress(String address) {
        byte[] addressBytes = decodeAddress(address);

        args.add(new Argument("address", leftPad32(ByteString.copyFrom(addressBytes)), false));

        return this;
    }

    /**
     * Add an array of {@value ADDRESS_LEN_HEX}-character hex-encoded Solidity addresses as a {@code address[]} param.
     *
     * @param addresses The array of addresses to be added
     * @return {@code this}
     * @throws IllegalArgumentException if any value is not exactly {@value ADDRESS_LEN_HEX} characters long or fails to
     *                                  decode as hexadecimal.
     * @throws NullPointerException     if any value in the array is null.
     */
    public ContractFunctionParameters addAddressArray(String[] addresses) {
        ByteString addressArray = encodeArray(
            Arrays.stream(addresses).map(a -> {
                byte[] address = decodeAddress(a);
                return leftPad32(ByteString.copyFrom(address));
            }));

        args.add(new Argument("address[]", addressArray, true));

        return this;
    }

    /**
     * Add a Solidity function reference as a {@value ADDRESS_LEN}-byte contract address and a
     * {@value SELECTOR_LEN}-byte function selector.
     *
     * @param address  a hex-encoded {@value ADDRESS_LEN_HEX}-character Solidity address.
     * @param selector a
     * @return {@code this}
     * @throws IllegalArgumentException if {@code address} is not {@value ADDRESS_LEN_HEX} characters or
     *                                  {@code selector} is not {@value SELECTOR_LEN} bytes.
     */
    public ContractFunctionParameters addFunction(String address, byte[] selector) {
        return addFunction(decodeAddress(address), selector);
    }

    /**
     * Add a Solidity function reference as a {@value ADDRESS_LEN}-byte contract address and a constructed
     * {@link ContractFunctionSelector}. The {@link ContractFunctionSelector} may not be modified after this call.
     *
     * @param address  The address used in the function to be added
     * @param selector The selector used in the function to be added
     * @return {@code this}
     * @throws IllegalArgumentException if {@code address} is not {@value ADDRESS_LEN_HEX} characters.
     */
    public ContractFunctionParameters addFunction(String address, ContractFunctionSelector selector) {
        // allow the `FunctionSelector` to be reused multiple times
        return addFunction(decodeAddress(address), selector.finish());
    }

    private ContractFunctionParameters addFunction(byte[] address, byte[] selector) {
        if (selector.length != SELECTOR_LEN) {
            throw new IllegalArgumentException("function selectors must be 4 bytes or 8 hex chars");
        }

        var output = ByteString.newOutput(ADDRESS_LEN + SELECTOR_LEN);
        try {
            output.write(address, 0, address.length);
            output.write(selector, 0, selector.length);

            // function reference encodes as `bytes24`
            args.add(new Argument("function", rightPad32(output.toByteString()), false));

            return this;
        } finally {
            try {
                output.close();
            } catch (Throwable ignored) {
                // do nothing
            }
        }
    }

    /**
     * Get the encoding of the currently added parameters as a {@link ByteString}.
     * <p>
     * You may continue to add parameters and call this again.
     *
     * @return the Solidity encoding of the call parameters in the order they were added.
     */
    ByteString toBytes(@Nullable String funcName) {
        // offset for dynamic-length data, immediately after value arguments
        @Var var dynamicOffset = args.size() * 32;

        var paramsBytes = new ArrayList<ByteString>(args.size() + 1);

        var dynamicArgs = new ArrayList<ByteString>();

        ContractFunctionSelector functionSelector = funcName != null
            ? new ContractFunctionSelector(funcName) : null;

        // iterate the arguments and determine whether they are dynamic or not
        for (Argument arg : args) {
            if (functionSelector != null) {
                functionSelector.addParamType(arg.type);
            }

            if (arg.isDynamic) {
                // dynamic arguments supply their offset in value position and append their data at
                // that offset
                paramsBytes.add(int256(dynamicOffset, 256));
                dynamicArgs.add(arg.value);
                dynamicOffset += arg.value.size();
            } else {
                // value arguments are dropped in the current arg position
                paramsBytes.add(arg.value);
            }
        }

        if (functionSelector != null) {
            paramsBytes.add(0, ByteString.copyFrom(functionSelector.finish()));
        }

        paramsBytes.addAll(dynamicArgs);

        return ByteString.copyFrom(paramsBytes);
    }

    private final static class Argument {
        private final String type;

        private final ByteString value;

        private final boolean isDynamic;

        private Argument(String type, ByteString value, boolean isDynamic) {
            this.type = type;
            if (!isDynamic && value.size() != 32) {
                throw new IllegalArgumentException("value argument that was not 32 bytes");
            }

            this.value = value;
            this.isDynamic = isDynamic;
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractFunctionResult.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.esaulpaugh.headlong.abi.Tuple;
import com.esaulpaugh.headlong.abi.TupleType;
import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.Int64Value;
import com.hedera.hashgraph.sdk.proto.ContractFunctionResultOrBuilder;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.Hex;

/**
 * Result of invoking a contract via {@link ContractCallQuery}, or {@link ContractExecuteTransaction}, or the result of
 * a contract constructor being called by {@link ContractCreateTransaction}.
 * <p>
 * If you require a type which is not supported here, please let us know on
 * <a href="https://github.com/hashgraph/hedera-sdk-java/issues/298">this Github issue</a>.
 */
public final class ContractFunctionResult {
    private static final ByteString errorPrefix = ByteString.copyFrom(new byte[]{8, -61, 121, -96});

    /**
     * The ID of the contract that was invoked.
     */
    public final ContractId contractId;

    /**
     * The contract's 20-byte EVM address
     */
    @Nullable
    public final ContractId evmAddress;

    /**
     * message in case there was an error during smart contract execution
     */
    @Nullable
    public final String errorMessage;

    /**
     * bloom filter for record
     */
    public final ByteString bloom;

    /**
     * units of gas used to execute contract
     */
    public final long gasUsed;

    /**
     * the log info for events returned by the function
     */
    public final List<ContractLogInfo> logs;

    /**
     * The created ids will now _also_ be externalized through internal transaction records, where each record has its
     * alias field populated with the new contract's EVM address. (This is needed for contracts created with CREATE2,
     * since there is no longer a simple relationship between the new contract's 0.0.X id and its Solidity address.)
     */
    @Deprecated
    public final List<ContractId> createdContractIds;

    /**
     * @deprecated - Use mirror node for contract traceability instead
     */
    @Deprecated
    public final List<ContractStateChange> stateChanges;

    /**
     * The amount of gas available for the call, aka the gasLimit
     */
    public final long gas;

    /**
     * Number of tinybars sent (the function must be payable if this is nonzero).
     */
    public final Hbar hbarAmount;

    /**
     * The parameters passed into the contract call.
     * <br>
     * This field should only be populated when the paired TransactionBody in the record stream is not a
     * ContractCreateTransactionBody or a ContractCallTransactionBody.
     */
    public final byte[] contractFunctionParametersBytes;
    /**
     * The account that is the "sender." If not present it is the accountId from the transactionId.
     */
    @Nullable
    public final AccountId senderAccountId;
    /**
     * A list of updated contract account nonces containing the new nonce value for each contract account. This is
     * always empty in a ContractCallLocalResponse#ContractFunctionResult message, since no internal creations can
     * happen in a static EVM call.
     */
    public final List<ContractNonceInfo> contractNonces;
    /**
     * If not null this field specifies what the value of the signer account nonce is post transaction execution.
     * For transactions that don't update the signer nonce (like HAPI ContractCall and ContractCreate transactions) this field should be null.
     */
    public final long signerNonce;

    private final ByteString rawResult;

    /**
     * Constructor.
     *
     * @param inner the protobuf
     */
    ContractFunctionResult(ContractFunctionResultOrBuilder inner) {
        contractId = ContractId.fromProtobuf(inner.getContractID());

        evmAddress = inner.hasEvmAddress() ?
            new ContractId(contractId.shard, contractId.realm, inner.getEvmAddress().getValue().toByteArray()) : null;

        String errMsg = inner.getErrorMessage();
        errorMessage = !errMsg.isEmpty() ? errMsg : null;

        ByteString callResult = inner.getContractCallResult();

        // if an exception was thrown, the call result is encoded like the params
        // for a function `Error(string)`
        // https://solidity.readthedocs.io/en/v0.6.2/control-structures.html#revert
        if (errorMessage != null && callResult.startsWith(errorPrefix)) {
            // trim off the function selector bytes
            rawResult = callResult.substring(4);
        } else {
            rawResult = callResult;
        }

        bloom = inner.getBloom();

        gasUsed = inner.getGasUsed();

        logs = inner.getLogInfoList().stream().map(ContractLogInfo::fromProtobuf).collect(Collectors.toList());

        createdContractIds = inner.getCreatedContractIDsList().stream().map(ContractId::fromProtobuf).collect(Collectors.toList());

        stateChanges = new ArrayList<ContractStateChange>();
        // for (var stateChangeProto : inner.getStateChangesList()) {
        //     stateChanges.add(ContractStateChange.fromProtobuf(stateChangeProto));
        // }

        gas = inner.getGas();

        hbarAmount = Hbar.fromTinybars(inner.getAmount());

        contractFunctionParametersBytes = inner.getFunctionParameters().toByteArray();

        senderAccountId = inner.hasSenderId() ? AccountId.fromProtobuf(inner.getSenderId()) : null;

        contractNonces = inner.getContractNoncesList().stream().map(ContractNonceInfo::fromProtobuf).collect(Collectors.toList());

        signerNonce = inner.getSignerNonce().getValue();
    }

    /**
     * Get the whole raw function result.
     *
     * @return byte[]
     */
    public byte[] asBytes() {
        return rawResult.toByteArray();
    }

    /**
     * Get the nth returned value as a string
     *
     * @param valIndex The index of the string to be retrieved
     * @return String
     */
    public String getString(int valIndex) {
        return getDynamicBytes(valIndex).toStringUtf8();
    }

    /**
     * Get the nth returned value as a list of strings
     *
     * @param index The index of the list of strings to be retrieved
     * @return A List of Strings
     */
    public List<String> getStringArray(int index) {
        var offset = getInt32(index);
        var count = getIntValueAt(offset);
        var strings = new ArrayList<String>();

        for (int i = 0; i < count; i++) {
            var strOffset = getIntValueAt(offset + 32 + (i * 32));
            var len = getIntValueAt(offset + strOffset + 32);
            var str = getByteString(offset + strOffset + 32 + 32, offset + strOffset + 32 + 32 + len).toStringUtf8();
            strings.add(str);
        }

        return strings;
    }

    /**
     * Get the nth value in the result as a dynamic byte array.
     *
     * @param valIndex The index of the array of bytes to be retrieved
     * @return byte[]
     */
    public byte[] getBytes(int valIndex) {
        return getDynamicBytes(valIndex).toByteArray();
    }

    /**
     * Get the nth fixed-width 32-byte value in the result.
     * <p>
     * This is the native word size for the Solidity ABI.
     *
     * @param valIndex The index of the array of bytes to be retrieved
     * @return byte[]
     */
    public byte[] getBytes32(int valIndex) {
        return getByteString(valIndex * 32, (valIndex + 1) * 32).toByteArray();
    }

    private ByteString getDynamicBytes(int valIndex) {
        int offset = getInt32(valIndex);
        int len = getIntValueAt(offset);
        return getByteString(offset + 32, offset + 32 + len);
    }

    /**
     * Get the nth value as a boolean.
     *
     * @param valIndex The index of the boolean to be retrieved
     * @return boolean
     */
    public boolean getBool(int valIndex) {
        return getInt8(valIndex) != 0;
    }

    /**
     * Get the nth returned value as an 8-bit integer.
     * <p>
     * If the actual value is wider it will be truncated to the last byte (similar to Java's integer narrowing
     * semantics).
     * <p>
     * If you are developing a contract and intending to return more than one of these values from a Solidity function,
     * consider using the {@code bytes32} Solidity type instead as that will be a more compact representation which will
     * save on gas. (Each individual {@code int8} value is padded to 32 bytes in the ABI.)
     *
     * @param valIndex The index of the value to be retrieved
     * @return byte
     */
    public byte getInt8(int valIndex) {
        return getByteBuffer(valIndex * 32 + 31).get();
    }

    /**
     * Get the nth returned value as a 32-bit integer.
     * <p>
     * If the actual value is wider it will be truncated to the last 4 bytes (similar to Java's integer narrowing
     * semantics).
     *
     * @param valIndex The index of the value to be retrieved
     * @return int
     */
    public int getInt32(int valIndex) {
        // int will be the last 4 bytes in the "value"
        return getIntValueAt(valIndex * 32);
    }

    /**
     * Get the nth returned value as a 64-bit integer.
     * <p>
     * If the actual value is wider it will be truncated to the last 8 bytes (similar to Java's integer narrowing
     * semantics).
     *
     * @param valIndex The index of the value to be retrieved
     * @return long
     */
    public long getInt64(int valIndex) {
        return getByteBuffer(valIndex * 32 + 24).getLong();
    }

    /**
     * Get the nth returned value as a 256-bit integer.
     * <p>
     * This type can represent the full width of Solidity integers.
     *
     * @param valIndex The index of the value to be retrieved
     * @return BigInteger
     */
    public BigInteger getInt256(int valIndex) {
        return new BigInteger(getBytes32(valIndex));
    }

    /**
     * Get the nth returned value as a 8-bit unsigned integer.
     * <p>
     * If the actual value is wider it will be truncated to the last byte (similar to Java's integer narrowing
     * semantics).
     * <p>
     * Because Java does not have native unsigned integers, this is semantically identical to {@link #getInt8(int)}. To
     * treat the value as unsigned in the range {@code [0, 255]}, use {@link Byte#toUnsignedInt(byte)} to widen to
     * {@code int} without sign-extension.
     * <p>
     * If you are developing a contract and intending to return more than one of these values from a Solidity function,
     * consider using the {@code bytes32} Solidity type instead as that will be a more compact representation which will
     * save on gas. (Each individual {@code uint8} value is padded to 32 bytes in the ABI.)
     *
     * @param valIndex The index of the value to be retrieved
     * @return byte
     */
    public byte getUint8(int valIndex) {
        return getInt8(valIndex);
    }

    /**
     * Get the nth returned value as a 32-bit unsigned integer.
     * <p>
     * If the actual value is wider it will be truncated to the last 4 bytes (similar to Java's integer narrowing
     * semantics).
     * <p>
     * Because Java does not have native unsigned integers, this is semantically identical to {@link #getInt32(int)}.
     * The {@link Integer} class has static methods for treating an {@code int} as unsigned where the difference between
     * signed and unsigned actually matters (comparison, division, printing and widening to {@code long}).
     *
     * @param valIndex The index of the value to be retrieved
     * @return int
     */
    public int getUint32(int valIndex) {
        return getInt32(valIndex);
    }

    /**
     * Get the nth returned value as a 64-bit integer.
     * <p>
     * If the actual value is wider it will be truncated to the last 8 bytes (similar to Java's integer narrowing
     * semantics).
     * <p>
     * Because Java does not have native unsigned integers, this is semantically identical to {@link #getInt64(int)}.
     * The {@link Long} class has static methods for treating a {@code long} as unsigned where the difference between
     * signed and unsigned actually matters (comparison, division and printing).
     *
     * @param valIndex The index of the value to be retrieved
     * @return long
     */
    public long getUint64(int valIndex) {
        return getInt64(valIndex);
    }

    /**
     * Get the nth returned value as a 256-bit unsigned integer.
     * <p>
     * The value will be padded with a leading zero-byte so that {@link BigInteger#BigInteger(byte[])} treats the value
     * as positive regardless of whether the most significant bit is set or not.
     * <p>
     * This type can represent the full width of Solidity integers.
     *
     * @param valIndex The index of the value to be retrieved
     * @return BigInteger
     */
    public BigInteger getUint256(int valIndex) {
        // prepend a zero byte so that `BigInteger` finds a zero sign bit and treats it as positive
        // `ByteString -> byte[]` requires copying anyway so we can amortize these two operations
        byte[] bytes = new byte[33];
        getByteString(valIndex * 32, (valIndex + 1) * 32).copyTo(bytes, 1);

        // there's a constructor that takes a signum but we would need to scan the array
        // to check that it's nonzero; this constructor does that work for us but requires
        // prepending a sign bit
        return new BigInteger(bytes);
    }

    /**
     * Get the nth returned value as a Solidity address.
     *
     * @param valIndex The index of the value to be retrieved
     * @return String
     */
    public String getAddress(int valIndex) {
        int offset = valIndex * 32;
        // address is a uint160
        return Hex.toHexString(getByteString(offset + 12, offset + 32).toByteArray());
    }

    private int getIntValueAt(int valueOffset) {
        return getByteBuffer(valueOffset + 28).getInt();
    }

    private ByteBuffer getByteBuffer(int offset) {
        // **NB** `.asReadOnlyByteBuffer()` on a substring returns a `ByteBuffer` with the
        // offset set as `position()`, so be sure to advance the buffer relative to that
        ByteBuffer byteBuffer = rawResult.asReadOnlyByteBuffer();
        byteBuffer.position(byteBuffer.position() + offset);

        return byteBuffer;
    }

    private ByteString getByteString(int startIndex, int endIndex) {
        return rawResult.substring(startIndex, endIndex);
    }

    /**
     * Create the protobuf representation.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.ContractFunctionResult}
     */
    com.hedera.hashgraph.sdk.proto.ContractFunctionResult toProtobuf() {
        var contractFunctionResult = com.hedera.hashgraph.sdk.proto.ContractFunctionResult.newBuilder()
            .setContractID(contractId.toProtobuf())
            .setContractCallResult(rawResult)
            .setBloom(bloom)
            .setGasUsed(gasUsed)
            .setSignerNonce(Int64Value.of(this.signerNonce));

        if (evmAddress != null) {
            contractFunctionResult.setEvmAddress(BytesValue.newBuilder()
                .setValue(ByteString.copyFrom(Objects.requireNonNull(evmAddress.evmAddress)))
                .build()
            );
        }

        if (errorMessage != null) {
            contractFunctionResult.setErrorMessage(errorMessage);
        }

        for (ContractLogInfo log : logs) {
            contractFunctionResult.addLogInfo(log.toProtobuf());
        }

        for (var contractId : createdContractIds) {
            contractFunctionResult.addCreatedContractIDs(contractId.toProtobuf());
        }

        if (senderAccountId != null) {
            contractFunctionResult.setSenderId(senderAccountId.toProtobuf());
        }

        // for (var stateChange : stateChanges) {
        //     contractFunctionResult.addStateChanges(stateChange.toProtobuf());
        // }

        for (var contractNonce : contractNonces) {
            contractFunctionResult.addContractNonces(contractNonce.toProtobuf());
        }

        return contractFunctionResult.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("contractId", contractId)
            .add("evmAddress", evmAddress)
            .add("errorMessage", errorMessage)
            .add("bloom", Hex.toHexString(bloom.toByteArray()))
            .add("gasUsed", gasUsed)
            .add("logs", logs)
            .add("createdContractIds", createdContractIds)
            .add("stateChanges", stateChanges)
            .add("gas", gas)
            .add("hbarAmount", hbarAmount)
            .add("contractFunctionparametersBytes", Hex.toHexString(contractFunctionParametersBytes))
            .add("rawResult", Hex.toHexString(rawResult.toByteArray()))
            .add("senderAccountId", senderAccountId)
            .add("contractNonces", contractNonces)
            .add("signerNonce", signerNonce)
            .toString();
    }

    public Tuple getResult(String types) {
        TupleType<Tuple> tupleType = TupleType.parse(types);
        return tupleType.decode(rawResult.toByteArray());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractFunctionSelector.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.bouncycastle.jcajce.provider.digest.Keccak;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.Objects;

import static java.nio.charset.StandardCharsets.US_ASCII;

/**
 * Builder class for Solidity function selectors.
 */
public final class ContractFunctionSelector {
    @Nullable
    private Keccak.Digest256 digest;

    private boolean needsComma = false;

    @Nullable
    private byte[] finished = null;

    /**
     * Start building a selector for a function with a given name.
     *
     * @param funcName The name of the function
     */
    public ContractFunctionSelector(String funcName) {
        digest = new Keccak.Digest256();
        digest.update(funcName.getBytes(US_ASCII));
        digest.update((byte) '(');
    }

    /**
     * Add a string parameter.
     *
     * @return                          string
     */
    public ContractFunctionSelector addString() {
        return addParamType("string");
    }

    /**
     * Add a string array parameter.
     *
     * @return                          array string
     */
    public ContractFunctionSelector addStringArray() {
        return addParamType("string[]");
    }

    /**
     * Add a bytes parameter.
     *
     * @return                          bytes
     */
    public ContractFunctionSelector addBytes() {
        return addParamType("bytes");
    }

    /**
     * Add a bytes array parameter.
     *
     * @return                          bytes array
     */
    public ContractFunctionSelector addBytesArray() {
        return addParamType("bytes[]");
    }

    /**
     * Add a bytes 32 parameter.
     *
     * @return                          bytes 32
     */
    public ContractFunctionSelector addBytes32() {
        return addParamType("bytes32");
    }

    /**
     * Add a bytes 32 array parameter.
     *
     * @return                          bytes 32 array
     */
    public ContractFunctionSelector addBytes32Array() {
        return addParamType("bytes32[]");
    }

    /**
     * Add a bool parameter.
     *
     * @return                          bool
     */
    public ContractFunctionSelector addBool() {
        return addParamType("bool");
    }

    /**
     * Add an int 8 parameter.
     *
     * @return                          int 8
     */
    public ContractFunctionSelector addInt8() {
        return addParamType("int8");
    }

    /**
     * Add an int 32 parameter.
     *
     * @return                          int 32
     */
    public ContractFunctionSelector addInt32() {
        return addParamType("int32");
    }

    /**
     * Add an int 64 parameter.
     *
     * @return                          int 64
     */
    public ContractFunctionSelector addInt64() {
        return addParamType("int64");
    }

    /**
     * Add an int 256 parameter.
     *
     * @return                          int 256
     */
    public ContractFunctionSelector addInt256() {
        return addParamType("int256");
    }

    /**
     * Add an int 8 array parameter.
     *
     * @return                          int 8 array
     */
    public ContractFunctionSelector addInt8Array() {
        return addParamType("int8[]");
    }

    /**
     * Add an int 32 array parameter.
     *
     * @return                          int 32 array
     */
    public ContractFunctionSelector addInt32Array() {
        return addParamType("int32[]");
    }

    /**
     * Add an int 64 array parameter.
     *
     * @return                          int 64 array
     */
    public ContractFunctionSelector addInt64Array() {
        return addParamType("int64[]");
    }

    /**
     * Add an int 256 array parameter.
     *
     * @return                          int 256 array
     */
    public ContractFunctionSelector addInt256Array() {
        return addParamType("int256[]");
    }

    /**
     * Add an unsigned int 8 parameter.
     *
     * @return                          unsigned int 8
     */
    public ContractFunctionSelector addUint8() {
        return addParamType("uint8");
    }

    /**
     * Add an unsigned int 32 parameter.
     *
     * @return                          unsigned int 32
     */
    public ContractFunctionSelector addUint32() {
        return addParamType("uint32");
    }

    /**
     * Add an unsigned int 64 parameter.
     *
     * @return                          unsigned int 64
     */
    public ContractFunctionSelector addUint64() {
        return addParamType("uint64");
    }

    /**
     * Add an unsigned int 256 parameter.
     *
     * @return                          unsigned int 256
     */
    public ContractFunctionSelector addUint256() {
        return addParamType("uint256");
    }

    /**
     * Add an unsigned int 8 array parameter.
     *
     * @return                          unsigned int 8 array
     */
    public ContractFunctionSelector addUint8Array() {
        return addParamType("uint8[]");
    }

    /**
     * Add an unsigned int 32 array parameter.
     *
     * @return                          unsigned int 32 array
     */
    public ContractFunctionSelector addUint32Array() {
        return addParamType("uint32[]");
    }

    /**
     * Add an unsigned int 64 array parameter.
     *
     * @return                          unsigned int 64 array
     */
    public ContractFunctionSelector addUint64Array() {
        return addParamType("uint64[]");
    }

    /**
     * Add an unsigned int 256 array parameter.
     *
     * @return                          unsigned int 256 array
     */
    public ContractFunctionSelector addUint256Array() {
        return addParamType("uint256[]");
    }

    /**
     * Add an address parameter.
     *
     * @return                          address
     */
    public ContractFunctionSelector addAddress() {
        return addParamType("address");
    }

    /**
     * Add an address array parameter.
     *
     * @return                          address array
     */
    public ContractFunctionSelector addAddressArray() {
        return addParamType("address[]");
    }

    /**
     * Add a function parameter.
     *
     * @return                          function.
     */
    public ContractFunctionSelector addFunction() {
        return addParamType("function");
    }

    /**
     * Add a Solidity type name to this selector;
     * {@see https://solidity.readthedocs.io/en/v0.5.9/types.html}
     *
     * @param typeName the name of the Solidity type for a parameter.
     * @return {@code this}
     * @throws IllegalStateException if {@link #finish()} has already been called.
     */
    @SuppressWarnings({"NullableDereference"})
    ContractFunctionSelector addParamType(String typeName) {
        if (finished != null) {
            throw new IllegalStateException("FunctionSelector already finished");
        }

        Objects.requireNonNull(digest);

        if (needsComma) {
            digest.update((byte) ',');
        }

        digest.update(typeName.getBytes(US_ASCII));
        needsComma = true;

        return this;
    }

    /**
     * Complete the function selector after all parameters have been added and get the selector
     * bytes.
     * <p>
     * No more parameters may be added after this method call.
     * <p>
     * However, this can be called multiple times; it will always return the same result.
     *
     * @return the computed selector bytes.
     */
    @SuppressWarnings({"NullableDereference"})
    byte[] finish() {
        if (finished == null) {
            Objects.requireNonNull(digest);
            digest.update((byte) ')');
            finished = Arrays.copyOf(digest.digest(), 4);
            // release digest state
            digest = null;
        }

        return finished;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractID;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.regex.Pattern;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.Hex;

/**
 * The ID for a smart contract instance on Hedera.
 */
public class ContractId extends Key implements Comparable<ContractId> {
    static final Pattern EVM_ADDRESS_REGEX = Pattern.compile("(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.([a-fA-F0-9]{40}$)");
    /**
     * The shard number
     */
    @Nonnegative
    public final long shard;

    /**
     * The realm number
     */
    @Nonnegative
    public final long realm;

    /**
     * The id number
     */
    @Nonnegative
    public final long num;

    @Nullable
    private final String checksum;

    /**
     * The 20-byte EVM address of the contract to call.
     */
    @Nullable
    public final byte[] evmAddress;

    /**
     * Assign the num part of the contract id.
     *
     * @param num                       the num part of the account id
     */
    public ContractId(@Nonnegative long num) {
        this(0, 0, num);
    }

    /**
     * Assign all parts of the contract id.
     *
     * @param shard                     the shard part of the contract id
     * @param realm                     the realm part of the contract id
     * @param num                       the num part of the contract id
     */
    @SuppressWarnings("InconsistentOverloads")
    public ContractId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num) {
        this(shard, realm, num, null);
    }

    /**
     * Assign all parts of the contract id.
     *
     * @param shard                     the shard part of the contract id
     * @param realm                     the realm part of the contract id
     * @param num                       the num part of the contract id
     */
    @SuppressWarnings("InconsistentOverloads")
    ContractId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num, @Nullable String checksum) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
        this.evmAddress = null;
    }

    ContractId(@Nonnegative long shard, @Nonnegative long realm, byte[] evmAddress) {
        this.shard = shard;
        this.realm = realm;
        this.evmAddress = evmAddress;
        this.num = 0;
        this.checksum = null;
    }

    /**
     * Parse contract id from a string.
     *
     * @param id                        the string containing a contract id
     * @return                          the contract id object
     */
    public static ContractId fromString(String id) {
        var match = EVM_ADDRESS_REGEX.matcher(id);
        if (match.find()) {
            return new ContractId(
                Long.parseLong(match.group(1)),
                Long.parseLong(match.group(2)),
                Hex.decode(match.group(3))
            );
        } else {
            return EntityIdHelper.fromString(id, ContractId::new);
        }
    }

    /**
     * Parse contract id from a solidity address string.
     *
     * @param address                   the address string
     * @return                          the contract id object
     */
    public static ContractId fromSolidityAddress(String address) {
        if (EntityIdHelper.isLongZeroAddress(EntityIdHelper.decodeSolidityAddress(address))) {
            return EntityIdHelper.fromSolidityAddress(address, ContractId::new);
        } else {
            return fromEvmAddress(0, 0, address);
        }
    }

    /**
     * Parse contract id from an ethereum address.
     *
     * @param shard                     the desired shard
     * @param realm                     the desired realm
     * @param evmAddress                the evm address
     * @return                          the contract id object
     */
    public static ContractId fromEvmAddress(@Nonnegative long shard, @Nonnegative long realm, String evmAddress) {
        return new ContractId(
            shard,
            realm,
            Hex.decode(evmAddress.startsWith("0x") ? evmAddress.substring(2) : evmAddress)
        );
    }

    /**
     * Extract a contract id from a protobuf.
     *
     * @param contractId                the protobuf containing a contract id
     * @return                          the contract id object
     */
    static ContractId fromProtobuf(ContractID contractId) {
        Objects.requireNonNull(contractId);
        if (contractId.hasEvmAddress()) {
            return new ContractId(
                contractId.getShardNum(),
                contractId.getRealmNum(),
                contractId.getEvmAddress().toByteArray()
            );
        } else {
            return new ContractId(contractId.getShardNum(), contractId.getRealmNum(), contractId.getContractNum());
        }
    }

    /**
     * Convert a byte array to an account balance object.
     *
     * @param bytes                     the byte array
     * @return                          the converted contract id object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static ContractId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(ContractID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the representation of solidity address.
     *
     * @return                          string representation of solidity address
     */
    public String toSolidityAddress() {
        if (evmAddress != null) {
            return Hex.toHexString(evmAddress);
        } else {
            return EntityIdHelper.toSolidityAddress(shard, realm, num);
        }
    }

    /**
     * Convert contract id to protobuf.
     *
     * @return                          the protobuf object
     */
    ContractID toProtobuf() {
        var builder = ContractID.newBuilder()
            .setShardNum(shard)
            .setRealmNum(realm);
        if (evmAddress != null) {
            builder.setEvmAddress(ByteString.copyFrom(evmAddress));
        } else {
            builder.setContractNum(num);
        }
        return builder.build();
    }

    /**
     *  Gets the actual `num` field of the `ContractId` from the Mirror Node.
     * Should be used after generating `ContractId.fromEvmAddress()` because it sets the `num` field to `0`
     * automatically since there is no connection between the `num` and the `evmAddress`
     * Sync version
     *
     * @param client
     * @return populated ContractId instance
     */
    public ContractId populateContractNum(Client client) throws InterruptedException, ExecutionException {
        return populateContractNumAsync(client).get();
    }

    /**
     * Gets the actual `num` field of the `ContractId` from the Mirror Node.
     * Should be used after generating `ContractId.fromEvmAddress()` because it sets the `num` field to `0`
     * automatically since there is no connection between the `num` and the `evmAddress`
     * Async version
     *
     * @deprecated Use 'populateContractNum' instead due to its nearly identical operation.
     * @param client
     * @return populated ContractId instance
     */
    @Deprecated
    public CompletableFuture<ContractId> populateContractNumAsync(Client client) {
        EvmAddress address = new EvmAddress(this.evmAddress);

        return EntityIdHelper.getContractNumFromMirrorNodeAsync(client, address.toString())
            .thenApply(contractNumFromMirrorNode ->
                new ContractId(this.shard, this.realm, contractNumFromMirrorNode, checksum));
    }

    /**
     * @param client to validate against
     * @throws BadEntityIdException if entity ID is formatted poorly
     * @deprecated Use {@link #validateChecksum(Client)} instead.
     */
    @Deprecated
    public void validate(Client client) throws BadEntityIdException {
        validateChecksum(client);
    }

    /**
     * Verify the checksum.
     *
     * @param client                    to validate against
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    public void validateChecksum(Client client) throws BadEntityIdException {
        EntityIdHelper.validate(shard, realm, num, client, checksum);
    }

    /**
     * Extract the checksum.
     *
     * @return                          the checksum
     */
    @Nullable
    public String getChecksum() {
        return checksum;
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        return com.hedera.hashgraph.sdk.proto.Key.newBuilder()
            .setContractID(toProtobuf())
            .build();
    }

    @Override
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        if (evmAddress != null) {
            return "" + shard + "." + realm + "." + Hex.toHexString(evmAddress);
        } else {
            return EntityIdHelper.toString(shard, realm, num);
        }
    }

    /**
     * Create a string representation that includes the checksum.
     *
     * @param client                    the client
     * @return                          the string representation with the checksum
     */
    public String toStringWithChecksum(Client client) {
        if (evmAddress != null) {
            throw new IllegalStateException("toStringWithChecksum cannot be applied to ContractId with evmAddress");
        } else {
            return EntityIdHelper.toStringWithChecksum(shard, realm, num, client, checksum);
        }
    }

    @Override
    public int hashCode() {
        return Objects.hash(shard, realm, num, Arrays.hashCode(evmAddress));
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof ContractId)) {
            return false;
        }

        ContractId otherId = (ContractId) o;
        return shard == otherId.shard && realm == otherId.realm && num == otherId.num && evmAddressMatches(otherId);
    }

    private boolean evmAddressMatches(ContractId otherId) {
        if ((evmAddress == null) != (otherId.evmAddress == null)) {
            return false;
        }
        if (evmAddress != null) {
            return Arrays.equals(evmAddress, otherId.evmAddress);
        }
        // both are null
        return true;
    }

    @Override
    public int compareTo(ContractId o) {
        Objects.requireNonNull(o);
        int shardComparison = Long.compare(shard, o.shard);
        if (shardComparison != 0) {
            return shardComparison;
        }
        int realmComparison = Long.compare(realm, o.realm);
        if (realmComparison != 0) {
            return realmComparison;
        }
        int numComparison = Long.compare(num, o.num);
        if (numComparison != 0) {
            return numComparison;
        }
        return evmAddressCompare(o);
    }

    private int evmAddressCompare(ContractId o) {
        int nullCompare = (evmAddress == null ? 0 : 1) - (o.evmAddress == null ? 0 : 1);
        if (nullCompare != 0) {
            return nullCompare;
        }
        if (evmAddress != null) {
            return Hex.toHexString(evmAddress).compareTo(Hex.toHexString(o.evmAddress));
        }
        // both are null
        return 0;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractGetInfoResponse;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;

/**
 * Current information on the smart contract instance, including its balance.
 */
public final class ContractInfo {
    /**
     * ID of the contract instance, in the format used in transactions.
     */
    public final ContractId contractId;

    /**
     * ID of the cryptocurrency account owned by the contract instance,
     * in the format used in transactions.
     */
    public final AccountId accountId;

    /**
     * ID of both the contract instance and the cryptocurrency account owned by the contract
     * instance, in the format used by Solidity.
     */
    public final String contractAccountId;

    /**
     * The state of the instance and its fields can be modified arbitrarily if this key signs a
     * transaction to modify it. If this is null, then such modifications are not possible,
     * and there is no administrator that can override the normal operation of this smart
     * contract instance. Note that if it is created with no admin keys, then there is no
     * administrator to authorize changing the admin keys, so there can never be any admin keys
     * for that instance.
     */
    @Nullable
    public final Key adminKey;

    /**
     * The current time at which this contract instance (and its account) is set to expire.
     */
    public final Instant expirationTime;

    /**
     * The expiration time will extend every this many seconds. If there are insufficient funds,
     * then it extends as long as possible. If the account is empty when it expires,
     * then it is deleted.
     */
    public final Duration autoRenewPeriod;

    /**
     * ID of the an account to charge for auto-renewal of this contract. If not set, or set to
     * an account with zero hbar balance, the contract's own hbar balance will be used to cover
     * auto-renewal fees.
     */
    @Nullable
    public final AccountId autoRenewAccountId;

    /**
     * Number of bytes of storage being used by this instance (which affects the cost to
     * extend the expiration time).
     */
    public final long storage;

    /**
     * The memo associated with the contract (max 100 bytes).
     */
    public final String contractMemo;

    /**
     * The current balance of the contract.
     */
    public final Hbar balance;

    /**
     * Whether the contract has been deleted
     */
    public final boolean isDeleted;

    /**
     * The tokens associated to the contract
     */
    public final Map<TokenId, TokenRelationship> tokenRelationships;

    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    public final LedgerId ledgerId;

    /**
     * Staking metadata for this account.
     */
    @Nullable
    public final StakingInfo stakingInfo;

    /**
     *  Constructor.
     *
     * @param contractId                the contract id
     * @param accountId                 the account id
     * @param contractAccountId         the account id of the owner
     * @param adminKey                  the key that can modify the contract
     * @param expirationTime            the time that contract will expire
     * @param autoRenewPeriod           seconds before contract is renewed (funds must be available)
     * @param autoRenewAccountId        account ID which will be charged for renewing this account
     * @param storage                   number of bytes used by this contract
     * @param contractMemo              the memo field 100 bytes
     * @param balance                   current balance
     * @param isDeleted                 does it still exist
     * @param tokenRelationships        list of compound token id and relationship records
     * @param ledgerId                  the ledger id
     */
    private ContractInfo(
        ContractId contractId,
        AccountId accountId,
        String contractAccountId,
        @Nullable Key adminKey,
        Instant expirationTime,
        Duration autoRenewPeriod,
        @Nullable AccountId autoRenewAccountId,
        long storage,
        String contractMemo,
        Hbar balance,
        boolean isDeleted,
        Map<TokenId, TokenRelationship> tokenRelationships,
        LedgerId ledgerId,
        @Nullable StakingInfo stakingInfo
    ) {
        this.contractId = contractId;
        this.accountId = accountId;
        this.contractAccountId = contractAccountId;
        this.adminKey = adminKey;
        this.expirationTime = expirationTime;
        this.autoRenewPeriod = autoRenewPeriod;
        this.autoRenewAccountId = autoRenewAccountId;
        this.storage = storage;
        this.contractMemo = contractMemo;
        this.balance = balance;
        this.isDeleted = isDeleted;
        this.tokenRelationships = tokenRelationships;
        this.ledgerId = ledgerId;
        this.stakingInfo = stakingInfo;
    }

    /**
     * Extract the contract from the protobuf.
     *
     * @param contractInfo              the protobuf
     * @return                          the contract object
     */
    static ContractInfo fromProtobuf(ContractGetInfoResponse.ContractInfo contractInfo) {
        var adminKey = contractInfo.hasAdminKey()
            ? Key.fromProtobufKey(contractInfo.getAdminKey())
            : null;

        var tokenRelationships = new HashMap<TokenId, TokenRelationship>(contractInfo.getTokenRelationshipsCount());

        for (var relationship : contractInfo.getTokenRelationshipsList()) {
            tokenRelationships.put(
                TokenId.fromProtobuf(relationship.getTokenId()),
                TokenRelationship.fromProtobuf(relationship)
            );
        }

        return new ContractInfo(
            ContractId.fromProtobuf(contractInfo.getContractID()),
            AccountId.fromProtobuf(contractInfo.getAccountID()),
            contractInfo.getContractAccountID(),
            adminKey,
            InstantConverter.fromProtobuf(contractInfo.getExpirationTime()),
            DurationConverter.fromProtobuf(contractInfo.getAutoRenewPeriod()),
            contractInfo.hasAutoRenewAccountId() ? AccountId.fromProtobuf(contractInfo.getAutoRenewAccountId()) : null,
            contractInfo.getStorage(),
            contractInfo.getMemo(),
            Hbar.fromTinybars(contractInfo.getBalance()),
            contractInfo.getDeleted(),
            tokenRelationships,
            LedgerId.fromByteString(contractInfo.getLedgerId()),
            contractInfo.hasStakingInfo() ? StakingInfo.fromProtobuf(contractInfo.getStakingInfo()) : null
        );
    }

    /**
     * Extract the contract from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the extracted contract
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static ContractInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(ContractGetInfoResponse.ContractInfo.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Build the protobuf.
     *
     * @return                          the protobuf representation
     */
    ContractGetInfoResponse.ContractInfo toProtobuf() {
        var contractInfoBuilder = ContractGetInfoResponse.ContractInfo.newBuilder()
            .setContractID(contractId.toProtobuf())
            .setAccountID(accountId.toProtobuf())
            .setContractAccountID(contractAccountId)
            .setExpirationTime(InstantConverter.toProtobuf(expirationTime))
            .setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod))
            .setStorage(storage)
            .setMemo(contractMemo)
            .setBalance(balance.toTinybars())
            .setLedgerId(ledgerId.toByteString());

        if (adminKey != null) {
            contractInfoBuilder.setAdminKey(adminKey.toProtobufKey());
        }

        if (stakingInfo != null) {
            contractInfoBuilder.setStakingInfo(stakingInfo.toProtobuf());
        }

        if (autoRenewAccountId != null) {
            contractInfoBuilder.setAutoRenewAccountId(autoRenewAccountId.toProtobuf());
        }

        return contractInfoBuilder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("contractId", contractId)
            .add("accountId", accountId)
            .add("contractAccountId", contractAccountId)
            .add("adminKey", adminKey)
            .add("expirationTime", expirationTime)
            .add("autoRenewPeriod", autoRenewPeriod)
            .add("autoRenewAccountId", autoRenewAccountId)
            .add("storage", storage)
            .add("contractMemo", contractMemo)
            .add("balance", balance)
            .add("isDeleted", isDeleted)
            .add("tokenRelationships", tokenRelationships)
            .add("ledgerId", ledgerId)
            .add("stakingInfo", stakingInfo)
            .toString();
    }

    /**
     * Create a byte array representation.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ContractGetInfoQuery;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import io.grpc.MethodDescriptor;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Get information about a smart contract instance.
 * <p>
 * This includes the account that it uses, the file containing its bytecode,
 * and the time when it will expire.
 */
public final class ContractInfoQuery extends Query<ContractInfo, ContractInfoQuery> {
    @Nullable
    private ContractId contractId = null;

    /**
     * Constructor.
     */
    public ContractInfoQuery() {
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract ID for which information is requested.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public ContractInfoQuery setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        this.contractId = contractId;
        return this;
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `CONTRACT_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = ContractGetInfoQuery.newBuilder();
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }

        queryBuilder.setContractGetInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getContractGetInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getContractGetInfo().getHeader();
    }

    @Override
    ContractInfo mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return ContractInfo.fromProtobuf(response.getContractGetInfo().getContractInfo());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return SmartContractServiceGrpc.getGetContractInfoMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractLogInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractLoginfo;
import org.bouncycastle.util.encoders.Hex;

import java.util.ArrayList;
import java.util.List;

/**
 * The log information for an event returned by a smart contract function call.
 * One function call may return several such events.
 */
public final class ContractLogInfo {
    /**
     * Address of a contract that emitted the event.
     */
    public final ContractId contractId;

    /**
     * Bloom filter for a particular log.
     */
    public final ByteString bloom;

    /**
     * Topics of a particular event.
     */
    public final List<ByteString> topics;

    /**
     * The event data.
     */
    public final ByteString data;

    /**
     * Constructor.
     *
     * @param contractId                the contract id
     * @param bloom                     the bloom filter
     * @param topics                    list of topics
     * @param data                      the event data
     */
    private ContractLogInfo(ContractId contractId, ByteString bloom, List<ByteString> topics, ByteString data) {
        this.contractId = contractId;
        this.bloom = bloom;
        this.topics = topics;
        this.data = data;
    }

    /**
     * Convert to a protobuf.
     *
     * @param logInfo                   the log info object
     * @return                          the protobuf
     */
    static ContractLogInfo fromProtobuf(com.hedera.hashgraph.sdk.proto.ContractLoginfo logInfo) {
        return new ContractLogInfo(
            ContractId.fromProtobuf(logInfo.getContractID()),
            logInfo.getBloom(),
            logInfo.getTopicList(),
            logInfo.getData()
        );
    }

    /**
     * Create the contract log info from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the contract log info object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static ContractLogInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(ContractLoginfo.parseFrom(bytes));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.ContractLoginfo toProtobuf() {
        var contractLogInfo = com.hedera.hashgraph.sdk.proto.ContractLoginfo.newBuilder()
            .setContractID(contractId.toProtobuf())
            .setBloom(bloom);

        for (ByteString topic : topics) {
            contractLogInfo.addTopic(topic);
        }

        return contractLogInfo.build();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        var stringHelper = MoreObjects.toStringHelper(this)
            .add("contractId", contractId)
            .add("bloom", Hex.toHexString(bloom.toByteArray()));

        var topicList = new ArrayList<>();

        for (var topic : topics) {
            topicList.add(Hex.toHexString(topic.toByteArray()));
        }

        return stringHelper
            .add("topics", topicList)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractNonceInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

import java.util.Objects;

/**
 * Info about a contract account's nonce value.
 * A nonce of a contract is only incremented when that contract creates another contract.
 */
public final class ContractNonceInfo {
    /**
     * Id of the contract
     */
    public final ContractId contractId;

    /**
     * The current value of the contract account's nonce property
     */
    public final Long nonce;

    public ContractNonceInfo(
        ContractId contractId,
        Long nonce
    ) {
        this.contractId = contractId;
        this.nonce = nonce;
    }

    /**
     * Extract the contractNonce from the protobuf.
     *
     * @param contractNonceInfo the protobuf
     * @return the contract object
     */
    static ContractNonceInfo fromProtobuf(com.hedera.hashgraph.sdk.proto.ContractNonceInfo contractNonceInfo) {
        return new ContractNonceInfo(
            ContractId.fromProtobuf(contractNonceInfo.getContractId()),
            contractNonceInfo.getNonce()
        );
    }

    /**
     * Extract the contractNonce from a byte array.
     *
     * @param bytes the byte array
     * @return the extracted contract
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    public static ContractNonceInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.ContractNonceInfo.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Build the protobuf.
     *
     * @return the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.ContractNonceInfo toProtobuf() {
        return com.hedera.hashgraph.sdk.proto.ContractNonceInfo.newBuilder()
            .setContractId(contractId.toProtobuf())
            .setNonce(nonce)
            .build();
    }

    @Override
    public int hashCode() {
        return Objects.hash(contractId, nonce);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof ContractNonceInfo otherInfo)) {
            return false;
        }

        return contractId.equals(otherInfo.contractId) && nonce.equals(otherInfo.nonce);
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("contractId", contractId)
            .add("nonce", nonce)
            .toString();
    }

    /**
     * Create a byte array representation.
     *
     * @return the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractStateChange.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;

import java.util.ArrayList;
import java.util.List;

/**
 * @deprecated - User mirror nodes for contract traceability instead
 *
 * The storage changes to a smart contract's storage as a side effect of the function call.
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/smart-contracts/contractcalllocal#contractstatechange">Hedera Documentation</a>
 */
@Deprecated
public class ContractStateChange {
    /**
     * The contract to which the storage changes apply to
     */
    public final ContractId contractId;

    /**
     * The list of storage changes
     */
    public final List<StorageChange> storageChanges;

    /**
     * Constructor.
     *
     * @param contractId                the contract id
     * @param storageChanges            the list of storage change objects
     */
    ContractStateChange(ContractId contractId, List<StorageChange> storageChanges) {
        this.contractId = contractId;
        this.storageChanges = storageChanges;
    }

    // /**
    //  * Create contract stage change object from protobuf.
    //  *
    //  * @param stateChangeProto          the protobuf
    //  * @return                          the contract stage change object
    //  */
    // static ContractStateChange fromProtobuf(com.hedera.hashgraph.sdk.proto.ContractStateChange stateChangeProto) {
    //     List<StorageChange> storageChanges = new ArrayList<>(stateChangeProto.getStorageChangesCount());
    //     for (var storageChangeProto : stateChangeProto.getStorageChangesList()) {
    //         storageChanges.add(StorageChange.fromProtobuf(storageChangeProto));
    //     }
    //     return new ContractStateChange(ContractId.fromProtobuf(stateChangeProto.getContractID()), storageChanges);
    // }
    //
    // /**
    //  * Create contract stage change object from byte array.
    //  *
    //  * @param bytes                     the byte array
    //  * @return                          the contract stage change object
    //  * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
    //  */
    // public static ContractStateChange fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
    //     return fromProtobuf(com.hedera.hashgraph.sdk.proto.ContractStateChange.parseFrom(bytes));
    // }
    //
    // /**
    //  * Create the protobuf.
    //  *
    //  * @return                          the protobuf representation
    //  */
    // com.hedera.hashgraph.sdk.proto.ContractStateChange toProtobuf() {
    //     var builder = com.hedera.hashgraph.sdk.proto.ContractStateChange.newBuilder()
    //         .setContractID(contractId.toProtobuf());
    //     for (var storageChange : storageChanges) {
    //         builder.addStorageChanges(storageChange.toProtobuf());
    //     }
    //     return builder.build();
    // }
    //
    // /**
    //  * Create the byte array.
    //  *
    //  * @return                          the byte array representation
    //  */
    // public byte[] toBytes() {
    //     return toProtobuf().toByteArray();
    // }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ContractUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.BoolValue;
import com.google.protobuf.Int32Value;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.ContractUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Modify a smart contract instance to have the given parameter values.
 * <p>
 * Any null field is ignored (left unchanged).
 * <p>
 * If only the contractInstanceExpirationTime is being modified, then no signature is
 * needed on this transaction other than for the account paying for the transaction itself.
 * <p>
 * But if any of the other fields are being modified, then it must be signed by the adminKey.
 * <p>
 * The use of adminKey is not currently supported in this API, but in the future will
 * be implemented to allow these fields to be modified, and also to make modifications
 * to the state of the instance.
 * <p>
 * If the contract is created with no admin key, then none of the fields can be
 * changed that need an admin signature, and therefore no admin key can ever be added.
 * So if there is no admin key, then things like the bytecode are immutable.
 * But if there is an admin key, then they can be changed. For example, the
 * admin key might be a threshold key, which requires 3 of 5 binding arbitration judges to
 * agree before the bytecode can be changed. This can be used to add flexibility to the management
 * of smart contract behavior. But this is optional. If the smart contract is created
 * without an admin key, then such a key can never be added, and its bytecode will be immutable.
 */
public final class ContractUpdateTransaction extends Transaction<ContractUpdateTransaction> {
    @Nullable
    private ContractId contractId = null;
    @Nullable
    private AccountId proxyAccountId = null;
    @Nullable
    private FileId bytecodeFileId = null;
    @Nullable
    private Instant expirationTime = null;
    @Nullable
    private Key adminKey = null;
    @Nullable
    private Integer maxAutomaticTokenAssociations = null;
    @Nullable
    private Duration autoRenewPeriod = null;
    @Nullable
    private String contractMemo = null;

    @Nullable
    private AccountId stakedAccountId = null;

    @Nullable
    private Long stakedNodeId = null;

    @Nullable
    private Boolean declineStakingReward = null;

    @Nullable
    private AccountId autoRenewAccountId = null;

    /**
     * Contract.
     */
    public ContractUpdateTransaction() {
    }

    /**
     * Contract.
     *
     * @param txs                       Compound list of transaction id's list of (AccountId, Transaction) record
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ContractUpdateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }
    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    ContractUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the Contract ID instance to update.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public ContractUpdateTransaction setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        requireNotFrozen();
        this.contractId = contractId;
        return this;
    }

    /**
     * Extract the contract expiration time.
     *
     * @return                          the contract expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Sets the expiration of the instance and its account to this time (
     * no effect if it already is this time or later).
     *
     * @param expirationTime The Instant to be set for expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public ContractUpdateTransaction setExpirationTime(Instant expirationTime) {
        Objects.requireNonNull(expirationTime);
        requireNotFrozen();
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Extract the administrator key.
     *
     * @return                          the administrator key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Sets a new admin key for this contract.
     *
     * @param adminKey The Key to be set
     * @return {@code this}
     */
    public ContractUpdateTransaction setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        requireNotFrozen();
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Extract the proxy account id.
     *
     * @return                          the proxy account id
     */
    @Nullable
    public AccountId getProxyAccountId() {
        return proxyAccountId;
    }

    /**
     * Sets the ID of the account to which this account is proxy staked.
     * <p>
     * If proxyAccountID is null, or is an invalid account, or is an account
     * that isn't a node, then this account is automatically proxy staked to a
     * node chosen by the network, but without earning payments.
     * <p>
     * If the proxyAccountID account refuses to accept proxy staking, or if it is
     * not currently running a node, then it will behave as if proxyAccountID was null.
     *
     * @param proxyAccountId The AccountId to be set
     * @return {@code this}
     */
    public ContractUpdateTransaction setProxyAccountId(AccountId proxyAccountId) {
        Objects.requireNonNull(proxyAccountId);
        requireNotFrozen();
        this.proxyAccountId = proxyAccountId;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    public Integer getMaxAutomaticTokenAssociations() {
        return maxAutomaticTokenAssociations;
    }

    /**
     * Sets the new maximum number of tokens that this contract can be
     * automatically associated with (i.e., receive air-drops from).
     *
     * @param maxAutomaticTokenAssociations The maximum automatic token associations
     * @return  {@code this}
     */

    public ContractUpdateTransaction setMaxAutomaticTokenAssociations(int maxAutomaticTokenAssociations) {
        requireNotFrozen();
        this.maxAutomaticTokenAssociations = maxAutomaticTokenAssociations;
        return this;
    }

    /**
     * Extract the duration for the auto renew period.
     *
     * @return                          the duration for auto-renew
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Sets the auto renew period for this contract.
     *
     * @param autoRenewPeriod The Duration to be set for auto renewal
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public ContractUpdateTransaction setAutoRenewPeriod(Duration autoRenewPeriod) {
        Objects.requireNonNull(autoRenewPeriod);
        requireNotFrozen();
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * @deprecated with no replacement
     * @return the bytecodeFileId
     */
    @Nullable
    @Deprecated
    public FileId getBytecodeFileId() {
        return bytecodeFileId;
    }

    /**
     * @deprecated with no replacement
     *
     * Sets the file ID of file containing the smart contract byte code.
     * <p>
     * A copy will be made and held by the contract instance, and have the same expiration
     * time as the instance.
     *
     * @param bytecodeFileId The FileId to be set
     * @return {@code this}
     */
    @Deprecated
    public ContractUpdateTransaction setBytecodeFileId(FileId bytecodeFileId) {
        Objects.requireNonNull(bytecodeFileId);
        requireNotFrozen();
        this.bytecodeFileId = bytecodeFileId;
        return this;
    }

    /**
     * Extract the contents of the memo.
     *
     * @return                          the contents of the memo
     */
    @Nullable
    public String getContractMemo() {
        return contractMemo;
    }

    /**
     * Sets the memo associated with the contract (max: 100 bytes).
     *
     * @param memo The memo to be set
     * @return {@code this}
     */
    public ContractUpdateTransaction setContractMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        contractMemo = memo;
        return this;
    }

    /**
     * Remove the memo contents.
     *
     * @return {@code this}
     */
    public ContractUpdateTransaction clearMemo() {
        requireNotFrozen();
        contractMemo = "";
        return this;
    }

    /**
     * ID of the account to which this contract will stake
     *
     * @return ID of the account to which this contract will stake.
     */
    @Nullable
    public AccountId getStakedAccountId() {
        return stakedAccountId;
    }

    /**
     * Set the account to which this contract will stake
     *
     * @param stakedAccountId ID of the account to which this contract will stake.
     * @return {@code this}
     */
    public ContractUpdateTransaction setStakedAccountId(@Nullable AccountId stakedAccountId) {
        requireNotFrozen();
        this.stakedAccountId = stakedAccountId;
        this.stakedNodeId = null;
        return this;
    }

    /**
     * Clear the staked account ID
     *
     * @return {@code this}
     */
    public ContractUpdateTransaction clearStakedAccountId() {
        requireNotFrozen();
        this.stakedAccountId = new AccountId(0);
        this.stakedNodeId = null;
        return this;
    }

    /**
     * The node to which this contract will stake
     *
     * @return ID of the node this contract will be staked to.
     */
    @Nullable
    public Long getStakedNodeId() {
        return stakedNodeId;
    }

    /**
     * Set the node to which this contract will stake
     *
     * @param stakedNodeId ID of the node this contract will be staked to.
     * @return {@code this}
     */
    public ContractUpdateTransaction setStakedNodeId(@Nullable Long stakedNodeId) {
        requireNotFrozen();
        this.stakedNodeId = stakedNodeId;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * clear the staked node account ID
     *
     * @return {@code this}
     */
    public ContractUpdateTransaction clearStakedNodeId() {
        requireNotFrozen();
        this.stakedNodeId = -1L;
        this.stakedAccountId = null;
        return this;
    }

    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     *
     * @return If true, the contract declines receiving a staking reward. The default value is false.
     */
    @Nullable
    public Boolean getDeclineStakingReward() {
        return declineStakingReward;
    }

    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     *
     * @param declineStakingReward - If true, the contract declines receiving a staking reward. The default value is false.
     * @return {@code this}
     */
    public ContractUpdateTransaction setDeclineStakingReward(boolean declineStakingReward) {
        requireNotFrozen();
        this.declineStakingReward = declineStakingReward;
        return this;
    }

    /**
     * Clear decline staking reward
     *
     * @return {@code this}
     */
    public ContractUpdateTransaction clearDeclineStakingReward() {
        requireNotFrozen();
        this.declineStakingReward = null;
        return this;
    }

    /**
     * Get the auto renew accountId.
     *
     * @return                          the auto renew accountId
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * An account to charge for auto-renewal of this contract. If not set, or set to an
     * account with zero hbar balance, the contract's own hbar balance will be used to
     * cover auto-renewal fees.
     *
     * @param autoRenewAccountId The AccountId to be set for auto renewal
     * @return {@code this}
     */
    public ContractUpdateTransaction setAutoRenewAccountId(AccountId autoRenewAccountId) {
        Objects.requireNonNull(autoRenewAccountId);
        requireNotFrozen();
        this.autoRenewAccountId = autoRenewAccountId;
        return this;
    }

    /**
     * Clears the auto-renew account ID
     *
     * @return {@code this}
     */
    public ContractUpdateTransaction clearAutoRenewAccountId() {
        this.autoRenewAccountId = new AccountId(0);
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getContractUpdateInstance();
        if (body.hasContractID()) {
            contractId = ContractId.fromProtobuf(body.getContractID());
        }
        if (body.hasProxyAccountID()) {
            proxyAccountId = AccountId.fromProtobuf(body.getProxyAccountID());
        }
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        if (body.hasMaxAutomaticTokenAssociations()) {
            maxAutomaticTokenAssociations = body.getMaxAutomaticTokenAssociations().getValue();
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        if (body.hasMemoWrapper()) {
            contractMemo = body.getMemoWrapper().getValue();
        }

        if (body.hasDeclineReward()) {
            declineStakingReward = body.getDeclineReward().getValue();
        }

        if (body.hasStakedAccountId()) {
            stakedAccountId = AccountId.fromProtobuf(body.getStakedAccountId());
        }

        if (body.hasStakedNodeId()) {
            stakedNodeId = body.getStakedNodeId();
        }

        if (body.hasAutoRenewAccountId()) {
            autoRenewAccountId = AccountId.fromProtobuf(body.getAutoRenewAccountId());
        }
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.ContractUpdateTransactionBody builder }
     */
    ContractUpdateTransactionBody.Builder build() {
        var builder = ContractUpdateTransactionBody.newBuilder();
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }
        if (proxyAccountId != null) {
            builder.setProxyAccountID(proxyAccountId.toProtobuf());
        }
        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        if (maxAutomaticTokenAssociations != null) {
            builder.setMaxAutomaticTokenAssociations(Int32Value.of(maxAutomaticTokenAssociations));
        }
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        if (contractMemo != null) {
            builder.setMemoWrapper(StringValue.of(contractMemo));
        }

        if (stakedAccountId != null) {
            builder.setStakedAccountId(stakedAccountId.toProtobuf());
        }

        if (stakedNodeId != null) {
            builder.setStakedNodeId(stakedNodeId);
        }

        if (declineStakingReward != null) {
            builder.setDeclineReward(BoolValue.newBuilder().setValue(declineStakingReward).build());
        }

        if (autoRenewAccountId != null) {
            builder.setAutoRenewAccountId(autoRenewAccountId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (contractId != null) {
            contractId.validateChecksum(client);
        }

        if (proxyAccountId != null) {
            proxyAccountId.validateChecksum(client);
        }

        if (stakedAccountId != null) {
            stakedAccountId.validateChecksum(client);
        }

        if (autoRenewAccountId != null) {
            autoRenewAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return SmartContractServiceGrpc.getUpdateContractMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setContractUpdateInstance(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setContractUpdateInstance(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Crypto.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.bouncycastle.asn1.sec.SECNamedCurves;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.asn1.x9.X9IntegerConverter;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA384Digest;
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;
import org.bouncycastle.crypto.macs.HMac;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.jcajce.provider.digest.Keccak;
import org.bouncycastle.math.ec.ECAlgorithms;
import org.bouncycastle.math.ec.ECPoint;

import javax.annotation.Nullable;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * Utility class used internally by the sdk.
 */
final class Crypto {
    static final int IV_LEN = 16;
    static final int ITERATIONS = 262144;
    static final int SALT_LEN = 32;
    static final int DK_LEN = 32;

    // OpenSSL doesn't like longer derived keys
    static final int CBC_DK_LEN = 16;

    static final X9ECParameters ECDSA_SECP256K1_CURVE = SECNamedCurves.getByName("secp256k1");
    static final ECDomainParameters ECDSA_SECP256K1_DOMAIN = new ECDomainParameters(
        ECDSA_SECP256K1_CURVE.getCurve(),
        ECDSA_SECP256K1_CURVE.getG(),
        ECDSA_SECP256K1_CURVE.getN(),
        ECDSA_SECP256K1_CURVE.getH());

    /**
     * Constructor.
     */
    private Crypto() {
    }

    /**
     * Derive a sha 256 key.
     *
     * @param passphrase                the password will be converted into bytes
     * @param salt                      the salt to be mixed in
     * @param iterations                the iterations for mixing
     * @param dkLenBytes                the key length in bytes
     * @return                          the key parameter object
     */
    static KeyParameter deriveKeySha256(String passphrase, byte[] salt, int iterations, int dkLenBytes) {
        PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator(new SHA256Digest());
        gen.init(passphrase.getBytes(StandardCharsets.UTF_8), salt, iterations);

        return (KeyParameter) gen.generateDerivedParameters(dkLenBytes * 8);
    }

    /**
     * Initialize an advanced encryption standard counter mode cipher.
     *
     * @param cipherKey                 the cipher key
     * @param iv                        the initialization vector byte array
     * @param forDecrypt                is this for decryption
     * @return                          the aes ctr cipher
     */
    static Cipher initAesCtr128(KeyParameter cipherKey, byte[] iv, boolean forDecrypt) {
        Cipher aesCipher;

        try {
            aesCipher = Cipher.getInstance("AES/CTR/NOPADDING");
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            throw new Error("platform does not support AES-CTR ciphers", e);
        }

        return initAesCipher(aesCipher, cipherKey, iv, forDecrypt);
    }

    /**
     * Initialize an advanced encryption standard cipher block chaining mode
     * cipher for encryption.
     *
     * @param cipherKey                 the cipher key
     * @param iv                        the initialization vector byte array
     * @return                          the aes cbc cipher
     */
    static Cipher initAesCbc128Encrypt(KeyParameter cipherKey, byte[] iv) {
        Cipher aesCipher;

        try {
            aesCipher = Cipher.getInstance("AES/CBC/NoPadding");
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            throw new Error("platform does not support AES-CBC ciphers", e);
        }

        return initAesCipher(aesCipher, cipherKey, iv, false);
    }

    /**
     * Initialize an advanced encryption standard cipher block chaining mode
     * cipher for decryption.
     *
     * @param cipherKey                 the cipher key
     * @param parameters                the algorithm parameters
     * @return                          the aes cbc cipher
     */
    static Cipher initAesCbc128Decrypt(KeyParameter cipherKey, AlgorithmParameters parameters) {
        Cipher aesCipher;

        try {
            aesCipher = Cipher.getInstance("AES/CBC/NoPadding");
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            throw new Error("platform does not support AES-CBC ciphers", e);
        }

        try {
            aesCipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(cipherKey.getKey(), 0, 16, "AES"), parameters);
        } catch (InvalidKeyException e) {
            throw new Error("platform does not support AES-128 ciphers", e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new Error(e);
        }

        return aesCipher;
    }

    /**
     * Create a new aes cipher.
     *
     * @param aesCipher                 the aes cipher
     * @param cipherKey                 the cipher key
     * @param iv                        the initialization vector byte array
     * @param forDecrypt                is this for decryption True or encryption False
     * @return                          the new aes cipher
     */
    private static Cipher initAesCipher(Cipher aesCipher, KeyParameter cipherKey, byte[] iv, boolean forDecrypt) {
        int mode = forDecrypt ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE;

        try {
            aesCipher.init(mode, new SecretKeySpec(cipherKey.getKey(), 0, 16, "AES"),
                new IvParameterSpec(iv));
        } catch (InvalidKeyException e) {
            throw new Error("platform does not support AES-128 ciphers", e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new Error(e);
        }

        return aesCipher;
    }

    /**
     * Encrypt a byte array with the aes ctr cipher.
     *
     * @param cipherKey                 the cipher key
     * @param iv                        the initialization vector
     * @param input                     the byte array to encrypt
     * @return                          the encrypted byte array
     */
    static byte[] encryptAesCtr128(KeyParameter cipherKey, byte[] iv, byte[] input) {
        Cipher aesCipher = initAesCtr128(cipherKey, iv, false);
        return runCipher(aesCipher, input);
    }

    /**
     * Decrypt a byte array with the aes ctr cipher.
     *
     * @param cipherKey                 the cipher key
     * @param iv                        the initialization vector
     * @param input                     the byte array to decrypt
     * @return                          the decrypted byte array
     */
    static byte[] decryptAesCtr128(KeyParameter cipherKey, byte[] iv, byte[] input) {
        Cipher aesCipher = initAesCtr128(cipherKey, iv, true);
        return runCipher(aesCipher, input);
    }

    /**
     * Run the cipher on the given input.
     *
     * @param cipher                    the cipher
     * @param input                     the byte array
     * @return                          the output of running the cipher
     */
    static byte[] runCipher(Cipher cipher, byte[] input) {
        byte[] output = new byte[cipher.getOutputSize(input.length)];

        try {
            cipher.doFinal(input, 0, input.length, output);
        } catch (ShortBufferException | IllegalBlockSizeException | BadPaddingException e) {
            throw new Error(e);
        }

        return output;
    }

    /**
     * Calculate a hash message authentication code using the secure hash
     * algorithm variant 384.
     *
     * @param cipherKey                 the cipher key
     * @param iv                        the initialization vector
     * @param input                     the byte array
     * @return                          the hmac using sha 384
     */
    static byte[] calcHmacSha384(KeyParameter cipherKey, @Nullable byte[] iv, byte[] input) {
        HMac hmacSha384 = new HMac(new SHA384Digest());
        byte[] output = new byte[hmacSha384.getMacSize()];

        hmacSha384.init(new KeyParameter(cipherKey.getKey(), 16, 16));
        if (iv != null) {
            hmacSha384.update(iv, 0, iv.length);
        }
        hmacSha384.update(input, 0, input.length);
        hmacSha384.doFinal(output, 0);

        return output;
    }

    /**
     * Calculate a keccak 256-bit hash.
     *
     * @param message                   the message to be hashed
     * @return                          the hash
     */
    static byte[] calcKeccak256(byte[] message) {
        var digest = new Keccak.Digest256();
        digest.update(message);
        return digest.digest();
    }

    /**
     * Generate some randomness.
     *
     * @param len                       the number of bytes requested
     * @return                          the byte array of randomness
     */
    static byte[] randomBytes(int len) {
        byte[] out = new byte[len];
        ThreadLocalSecureRandom.current().nextBytes(out);

        return out;
    }

    /**
     * Given the r and s components of a signature and the hash value of the message, recover and return the public key
     * according to the algorithm in <a href="https://www.secg.org/sec1-v2.pdf">SEC1v2 section 4.1.6.</a>
     * <p>
     * Calculations and explanations in this method were taken and adapted from
     * <a href="https://github.com/apache/incubator-tuweni/blob/0852e0b01ad126b47edae51b26e808cb73e294b1/crypto/src/main/java/org/apache/tuweni/crypto/SECP256K1.java#L199-L215">incubator-tuweni lib</a>
     *
     * @param recId Which possible key to recover.
     * @param r The R component of the signature.
     * @param s The S component of the signature.
     * @param messageHash Hash of the data that was signed.
     * @return A ECKey containing only the public part, or {@code null} if recovery wasn't possible.
     */
    static byte[] recoverPublicKeyECDSAFromSignature(int recId, BigInteger r, BigInteger s, byte[] messageHash) {
        if (!(recId == 0 || recId == 1)) {
            throw new IllegalArgumentException("Recovery Id must be 0 or 1 for secp256k1.");
        }
        if (r.signum() < 0 || s.signum() < 0) {
            throw new IllegalArgumentException("'r' and 's' shouldn't be negative.");
        }
        // 1.1 - 1.3 calculate point R
        ECPoint R = decompressKey(r, (recId & 1) == 1);
        // 1.4 nR should be a point at infinity
        if (R == null || !R.multiply(ECDSA_SECP256K1_DOMAIN.getN()).isInfinity()) {
            return null;
        }
        // 1.5 Compute e from M using Steps 2 and 3 of ECDSA signature verification.
        BigInteger e = new BigInteger(1, messageHash);

        // 1.6.1 Compute a candidate public key as:
        //   Q = mi(r) * (sR - eG)
        // Where mi(x) is the modular multiplicative inverse. We transform this into the following:
        //   Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
        // Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n).
        // In the above equation ** is point multiplication and + is point addition (the EC group
        // operator).
        //
        // We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive
        // inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
        BigInteger eInv = BigInteger.ZERO.subtract(e).mod(ECDSA_SECP256K1_DOMAIN.getN());
        BigInteger rInv = r.modInverse(ECDSA_SECP256K1_DOMAIN.getN());
        BigInteger srInv = rInv.multiply(s).mod(ECDSA_SECP256K1_DOMAIN.getN());
        BigInteger eInvrInv = rInv.multiply(eInv).mod(ECDSA_SECP256K1_DOMAIN.getN());
        ECPoint q = ECAlgorithms.sumOfTwoMultiplies(ECDSA_SECP256K1_DOMAIN.getG(), eInvrInv, R, srInv);

        if (q.isInfinity()) {
            return null;
        }

        return q.getEncoded(true);
    }

    private static ECPoint decompressKey(BigInteger xBN, boolean yBit) {
        var X_9_INTEGER_CONVERTER = new X9IntegerConverter();
        byte[] compEnc = X_9_INTEGER_CONVERTER.integerToBytes(
            xBN, 1 + X_9_INTEGER_CONVERTER.getByteLength(ECDSA_SECP256K1_DOMAIN.getCurve()));
        compEnc[0] = (byte) (yBit ? 0x03 : 0x02);
        try {
            return ECDSA_SECP256K1_DOMAIN.getCurve().decodePoint(compEnc);
        } catch (IllegalArgumentException e) {
            // the key was invalid
            return null;
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/CustomFee.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Base class for custom fees.
 */
abstract public class CustomFee {
    /**
     * The account to receive the custom fee
     */
    @Nullable
    protected AccountId feeCollectorAccountId = null;

    /**
     * If true, exempts all the token's fee collection accounts from this fee
     */
    protected boolean allCollectorsAreExempt = false;

    /**
     * Constructor.
     */
    CustomFee() {
    }

    /**
     * Convert the protobuf object to a custom fee object.
     *
     * @param customFee                 protobuf response object
     * @return                          the converted custom fee object
     */
    static CustomFee fromProtobufInner(com.hedera.hashgraph.sdk.proto.CustomFee customFee) {
        switch (customFee.getFeeCase()) {
            case FIXED_FEE:
                return CustomFixedFee.fromProtobuf(customFee.getFixedFee());

            case FRACTIONAL_FEE:
                return CustomFractionalFee.fromProtobuf(customFee.getFractionalFee());

            case ROYALTY_FEE:
                return CustomRoyaltyFee.fromProtobuf(customFee.getRoyaltyFee());

            default:
                throw new IllegalStateException("CustomFee#fromProtobuf: unhandled fee case: " + customFee.getFeeCase());
        }
    }

    static CustomFee fromProtobuf(com.hedera.hashgraph.sdk.proto.CustomFee customFee) {
        var outFee = fromProtobufInner(customFee);
        if (customFee.hasFeeCollectorAccountId()) {
            outFee.feeCollectorAccountId = AccountId.fromProtobuf(customFee.getFeeCollectorAccountId());
        }
        outFee.allCollectorsAreExempt = customFee.getAllCollectorsAreExempt();

        return outFee;
    }

    /**
     * Convert byte array to a custom fee object.
     *
     * @param bytes                     the byte array
     * @return                          the converted custom fee object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static CustomFee fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.CustomFee.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create a new copy of a custom fee list.
     *
     * @param customFees                existing custom fee list
     * @return                          new custom fee list
     */
    public static List<CustomFee> deepCloneList(List<CustomFee> customFees) {
        var returnCustomFees = new ArrayList<CustomFee>(customFees.size());
        for (var fee : customFees) {
            returnCustomFees.add(fee.deepClone());
        }
        return returnCustomFees;
    }

    /**
     * Extract the fee collector account id.
     *
     * @return                          the fee collector account id
     */
    @Nullable
    public AccountId getFeeCollectorAccountId() {
        return feeCollectorAccountId;
    }

    /**
     *
     * @return whether all fee collectors are exempt from fees
     */
    public boolean getAllCollectorsAreExempt() {
        return allCollectorsAreExempt;
    }

    /**
     * Create a deep clone.
     *
     * @return                          the correct cloned fee type
     */
    abstract CustomFee deepClone();

    /**
     * Verify the validity of the client object.
     *
     * @param client                    the configured client
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    void validateChecksums(Client client) throws BadEntityIdException {
        if (feeCollectorAccountId != null) {
            feeCollectorAccountId.validateChecksum(client);
        }
    }

    /**
     * Finalize the builder into the protobuf.
     *
     * @param customFeeBuilder              the builder object
     * @return                              the protobuf
     */
    protected com.hedera.hashgraph.sdk.proto.CustomFee finishToProtobuf(com.hedera.hashgraph.sdk.proto.CustomFee.Builder customFeeBuilder) {
        if (feeCollectorAccountId != null) {
            customFeeBuilder.setFeeCollectorAccountId(feeCollectorAccountId.toProtobuf());
        }
        customFeeBuilder.setAllCollectorsAreExempt(allCollectorsAreExempt);
        return customFeeBuilder.build();
    }

    /**
     * Create the protobuf.
     *
     * @return                              the protobuf for the custom fee object
     */
    abstract com.hedera.hashgraph.sdk.proto.CustomFee toProtobuf();

    /**
     * Create the byte array.
     *
     * @return                              the byte array representing the protobuf
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    /**
     * Serializes the class to ToStringHelper
     *
     * @return the {@link com.google.common.base.MoreObjects.ToStringHelper}
     */
    protected MoreObjects.ToStringHelper toStringHelper() {
        return MoreObjects.toStringHelper(this)
            .add("feeCollectorAccountId", feeCollectorAccountId)
            .add("allCollectorsAreExempt", allCollectorsAreExempt);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/CustomFeeBase.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.Objects;

abstract class CustomFeeBase <F extends CustomFeeBase<F>> extends CustomFee {

    /**
     * Assign the fee collector account id.
     *
     * @param feeCollectorAccountId     the account id of the fee collector
     * @return {@code this}
     */
    public F setFeeCollectorAccountId(AccountId feeCollectorAccountId) {
        this.feeCollectorAccountId = Objects.requireNonNull(feeCollectorAccountId);
        // noinspection unchecked
        return (F) this;
    }

    /**
     * If true, exempts all the token's fee collection accounts from this fee.
     * (The token's treasury and the above fee_collector_account_id will always
     * be exempt. Please see <a href="https://hips.hedera.com/hip/hip-573">HIP-573</a>
     * for details.)
     *
     * @param allCollectorsAreExempt whether all fee collectors are exempt from fees
     * @return {@code this}
     */
    public F setAllCollectorsAreExempt(boolean allCollectorsAreExempt) {
        this.allCollectorsAreExempt = allCollectorsAreExempt;
        // noinspection unchecked
        return (F) this;
    }

    abstract F deepCloneSubclass();

    /**
     * Finishes the deep clone by setting the fields of the {@link CustomFeeBase} class
     *
     * @param source    the source object
     * @return the cloned object
     */
    protected F finishDeepClone(CustomFeeBase<F> source) {
        feeCollectorAccountId = source.feeCollectorAccountId;
        allCollectorsAreExempt = source.getAllCollectorsAreExempt();

        // noinspection unchecked
        return (F) this;
    }

    @Override
    CustomFee deepClone() {
        return deepCloneSubclass();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/CustomFixedFee.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.hedera.hashgraph.sdk.proto.FixedFee;

import javax.annotation.Nullable;

/**
 * Custom fixed fee utility class.
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/custom-token-fees#fixed-fee">Hedera Documentation</a>
 */
public class CustomFixedFee extends CustomFeeBase<CustomFixedFee> {
    private long amount = 0;
    /**
     * The shard, realm, number of the tokens.
     */
    @Nullable
    private TokenId denominatingTokenId = null;

    /**
     * Constructor.
     */
    public CustomFixedFee() {
    }

    /**
     * Create a custom fixed fee from a fixed fee protobuf.
     *
     * @param fixedFee                  the fixed fee protobuf
     * @return                          the new custom fixed fee object
     */
    static CustomFixedFee fromProtobuf(FixedFee fixedFee) {
        var returnFee = new CustomFixedFee()
            .setAmount(fixedFee.getAmount());
        if (fixedFee.hasDenominatingTokenId()) {
            returnFee.setDenominatingTokenId(TokenId.fromProtobuf(fixedFee.getDenominatingTokenId()));
        }
        return returnFee;
    }

    @Override
    CustomFixedFee deepCloneSubclass() {
        return new CustomFixedFee()
            .setAmount(amount)
            .setDenominatingTokenId(denominatingTokenId)
            .finishDeepClone(this);
    }

    /**
     * Extract the amount.
     *
     * @return                          the amount of the fee in tiny bar
     */
    public long getAmount() {
        return amount;
    }

    /**
     * Assign the fee amount in tiny bar.
     *
     * @param amount                    the amount of the fee in tiny bar
     * @return {@code this}
     */
    public CustomFixedFee setAmount(long amount) {
        this.amount = amount;
        return this;
    }

    /**
     * Extract the fee amount.
     *
     * @return                          the fee amount in hbar
     */
    public Hbar getHbarAmount() {
        return Hbar.fromTinybars(amount);
    }

    /**
     * Assign the fee amount in hbar.
     *
     * @param amount                    the fee amount in hbar
     * @return {@code this}
     */
    public CustomFixedFee setHbarAmount(Hbar amount) {
        denominatingTokenId = null;
        this.amount = amount.toTinybars();
        return this;
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id object
     */
    @Nullable
    public TokenId getDenominatingTokenId() {
        return denominatingTokenId;
    }

    /**
     * Assign the desired token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public CustomFixedFee setDenominatingTokenId(@Nullable TokenId tokenId) {
        denominatingTokenId = tokenId;
        return this;
    }

    /**
     * Assign the default token 0.0.0.
     *
     * @return {@code this}
     */
    public CustomFixedFee setDenominatingTokenToSameToken() {
        denominatingTokenId = new TokenId(0, 0, 0);
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        super.validateChecksums(client);
        if (denominatingTokenId != null) {
            denominatingTokenId.validateChecksum(client);
        }
    }

    @Override
    public String toString() {
        return toStringHelper()
            .add("amount", getAmount())
            .add("demoninatingTokenId", getDenominatingTokenId())
            .toString();
    }

    /**
     * Convert to a protobuf.
     *
     * @return                          the protobuf converted object
     */
    FixedFee toFixedFeeProtobuf() {
        var fixedFeeBuilder = FixedFee.newBuilder()
            .setAmount(getAmount());
        if (getDenominatingTokenId() != null) {
            fixedFeeBuilder.setDenominatingTokenId(getDenominatingTokenId().toProtobuf());
        }
        return fixedFeeBuilder.build();
    }

    @Override
    com.hedera.hashgraph.sdk.proto.CustomFee toProtobuf() {
        var customFeeBuilder = com.hedera.hashgraph.sdk.proto.CustomFee.newBuilder()
            .setFixedFee(toFixedFeeProtobuf());
        return finishToProtobuf(customFeeBuilder);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/CustomFractionalFee.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Fraction;
import com.hedera.hashgraph.sdk.proto.FractionalFee;

import java.util.Objects;

/**
 * Custom fractional fee utility class.
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/custom-token-fees#fractional-fee">Hedera Documentation</a>
 */
public class CustomFractionalFee extends CustomFeeBase<CustomFractionalFee> {
    private long numerator = 0;
    private long denominator = 1;
    private long min = 0;
    private long max = 0;
    private FeeAssessmentMethod assessmentMethod = FeeAssessmentMethod.INCLUSIVE;

    /**
     * Constructor.
     */
    public CustomFractionalFee() {
    }

    /**
     * Create a custom fractional fee from a fee protobuf.
     *
     * @param fractionalFee the fractional fee protobuf
     * @return the new custom fractional fee object
     */
    static CustomFractionalFee fromProtobuf(FractionalFee fractionalFee) {
        var fraction = fractionalFee.getFractionalAmount();
        return new CustomFractionalFee()
            .setNumerator(fraction.getNumerator())
            .setDenominator(fraction.getDenominator())
            .setMin(fractionalFee.getMinimumAmount())
            .setMax(fractionalFee.getMaximumAmount())
            .setAssessmentMethod(FeeAssessmentMethod.valueOf(fractionalFee.getNetOfTransfers()));
    }

    @Override
    CustomFractionalFee deepCloneSubclass() {
        return new CustomFractionalFee()
            .setNumerator(numerator)
            .setDenominator(denominator)
            .setMin(min)
            .setMax(max)
            .setAssessmentMethod(assessmentMethod)
            .finishDeepClone(this);
    }

    /**
     * Extract the numerator.
     *
     * @return the numerator
     */
    public long getNumerator() {
        return numerator;
    }

    /**
     * Assign the numerator.
     *
     * @param numerator the numerator
     * @return {@code this}
     */
    public CustomFractionalFee setNumerator(long numerator) {
        this.numerator = numerator;
        return this;
    }

    /**
     * Extract the denominator.
     *
     * @return the denominator
     */
    public long getDenominator() {
        return denominator;
    }

    /**
     * Assign the denominator can not be zero (0).
     *
     * @param denominator the denominator
     * @return {@code this}
     */
    public CustomFractionalFee setDenominator(long denominator) {
        this.denominator = denominator;
        return this;
    }

    /**
     * Extract the minimum fee amount.
     *
     * @return the minimum fee amount
     */
    public long getMin() {
        return min;
    }

    /**
     * Assign the minimum fee amount.
     *
     * @param min the fee amount
     * @return {@code this}
     */
    public CustomFractionalFee setMin(long min) {
        this.min = min;
        return this;
    }

    /**
     * Extract the fee amount.
     *
     * @return the fee amount
     */
    public long getMax() {
        return max;
    }

    /**
     * Assign the maximum fee amount.
     *
     * @param max the fee amount
     * @return {@code this}
     */
    public CustomFractionalFee setMax(long max) {
        this.max = max;
        return this;
    }

    /**
     * Extract the assessment method inclusive / exclusive.
     *
     * @return the assessment method inclusive / exclusive
     */
    public FeeAssessmentMethod getAssessmentMethod() {
        return assessmentMethod;
    }

    /**
     * Assign the assessment method inclusive / exclusive.
     * <p>
     * If the assessment method field is set, the token's custom fee is charged
     * to the sending account and the receiving account receives the full token
     * transfer amount. If this field is set to false, the receiver pays for
     * the token custom fees and gets the remaining token balance.
     * INCLUSIVE(false)
     * EXCLUSIVE(true)
     * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/custom-token-fees#fractional-fee">Hedera Documentation</a>
     *
     * @param assessmentMethod inclusive / exclusive
     * @return {@code this}
     */
    public CustomFractionalFee setAssessmentMethod(FeeAssessmentMethod assessmentMethod) {
        Objects.requireNonNull(assessmentMethod);
        this.assessmentMethod = assessmentMethod;
        return this;
    }

    @Override
    public String toString() {
        return toStringHelper()
            .add("numerator", getNumerator())
            .add("denominator", getDenominator())
            .add("min", getMin())
            .add("max", getMax())
            .add("assessmentMethod", getAssessmentMethod())
            .toString();
    }

    /**
     * Convert the fractional fee object to a protobuf.
     *
     * @return the protobuf object
     */
    FractionalFee toFractionalFeeProtobuf() {
        return FractionalFee.newBuilder()
            .setMinimumAmount(getMin())
            .setMaximumAmount(getMax())
            .setFractionalAmount(
                Fraction.newBuilder()
                    .setNumerator(getNumerator())
                    .setDenominator(getDenominator())
            )
            .setNetOfTransfers(assessmentMethod.code)
            .build();
    }

    @Override
    com.hedera.hashgraph.sdk.proto.CustomFee toProtobuf() {
        var customFeeBuilder = com.hedera.hashgraph.sdk.proto.CustomFee.newBuilder()
            .setFractionalFee(toFractionalFeeProtobuf());
        return finishToProtobuf(customFeeBuilder);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/CustomRoyaltyFee.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.hedera.hashgraph.sdk.proto.Fraction;
import com.hedera.hashgraph.sdk.proto.RoyaltyFee;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Custom royalty fee utility class.
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/custom-token-fees#royalty-fee">Hedera Documentation</a>
 */
public class CustomRoyaltyFee extends CustomFeeBase<CustomRoyaltyFee> {
    private long numerator = 0;
    private long denominator = 1;
    @Nullable
    private CustomFixedFee fallbackFee = null;

    /**
     * Constructor.
     */
    public CustomRoyaltyFee() {
    }

    /**
     * Create a custom royalty fee from a royalty fee protobuf.
     *
     * @param royaltyFee                the royalty fee protobuf
     * @return                          the new royalty fee object
     */
    static CustomRoyaltyFee fromProtobuf(RoyaltyFee royaltyFee) {
        var fraction = royaltyFee.getExchangeValueFraction();
        var returnFee = new CustomRoyaltyFee()
            .setNumerator(fraction.getNumerator())
            .setDenominator(fraction.getDenominator());
        if (royaltyFee.hasFallbackFee()) {
            returnFee.fallbackFee = CustomFixedFee.fromProtobuf(royaltyFee.getFallbackFee());
        }
        return returnFee;
    }

    @Override
    CustomRoyaltyFee deepCloneSubclass() {
        var returnFee = new CustomRoyaltyFee();
        returnFee.numerator = numerator;
        returnFee.denominator = denominator;
        returnFee.fallbackFee = fallbackFee != null ? fallbackFee.deepCloneSubclass() : null;
        returnFee.feeCollectorAccountId = feeCollectorAccountId;
        returnFee.allCollectorsAreExempt = allCollectorsAreExempt;
        return returnFee;

    }

    /**
     * Extract the numerator.
     *
     * @return                          the numerator
     */
    public long getNumerator() {
        return numerator;
    }

    /**
     * Assign the numerator.
     *
     * @param numerator                 the numerator
     * @return {@code this}
     */
    public CustomRoyaltyFee setNumerator(long numerator) {
        this.numerator = numerator;
        return this;
    }

    /**
     * Extract the denominator.
     *
     * @return                          the denominator
     */
    public long getDenominator() {
        return denominator;
    }

    /**
     * Assign the denominator can not be zero (0).
     *
     * @param denominator               the denominator
     * @return {@code this}
     */
    public CustomRoyaltyFee setDenominator(long denominator) {
        this.denominator = denominator;
        return this;
    }

    /**
     * The fallback fee is a fixed fee that is charged to the NFT receiver
     * when there is no fungible value exchanged with the sender of the NFT.
     *
     * @param fallbackFee               the fallback fee amount
     * @return {@code this}
     */
    public CustomRoyaltyFee setFallbackFee(CustomFixedFee fallbackFee) {
        Objects.requireNonNull(fallbackFee);
        this.fallbackFee = fallbackFee.deepCloneSubclass();
        return this;
    }

    /**
     * Get the fallback fixed fee.
     *
     * @return the fallback fixed fee
     */
    @Nullable
    public CustomFixedFee getFallbackFee() {
        return fallbackFee != null ? fallbackFee.deepCloneSubclass() : null;
    }

    /**
     * Convert the royalty fee object to a protobuf.
     *
     * @return                          the protobuf object
     */
    RoyaltyFee toRoyaltyFeeProtobuf() {
        var royaltyFeeBuilder = RoyaltyFee.newBuilder()
            .setExchangeValueFraction(
                Fraction.newBuilder()
                    .setNumerator(numerator)
                    .setDenominator(denominator)
            );
        if (fallbackFee != null) {
            royaltyFeeBuilder.setFallbackFee(fallbackFee.toFixedFeeProtobuf());
        }
        return royaltyFeeBuilder.build();
    }

    @Override
    com.hedera.hashgraph.sdk.proto.CustomFee toProtobuf() {
        var customFeeBuilder = com.hedera.hashgraph.sdk.proto.CustomFee.newBuilder()
            .setRoyaltyFee(toRoyaltyFeeProtobuf());
        return finishToProtobuf(customFeeBuilder);
    }

    @Override
    public String toString() {
        return toStringHelper()
            .add("numerator", numerator)
            .add("denominator", denominator)
            .add("fallbackFee", fallbackFee)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Delayer.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Utility class used internally by the sdk.
 */
final class Delayer {
    private static final Logger logger = LoggerFactory.getLogger(Delayer.class);

    private static final ScheduledExecutorService SCHEDULER = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r);
        t.setDaemon(true);
        return t;
    });

    private static final Duration MIN_DELAY = Duration.ofMillis(500);

    /**
     * Constructor.
     */
    private Delayer() {
    }

    /**
     * Set the delay backoff attempts.
     *
     * @param attempt                   the attempts
     * @param executor                  the executor
     * @return                          the updated future
     */
    static CompletableFuture<Void> delayBackOff(int attempt, Executor executor) {
        var interval = MIN_DELAY.multipliedBy(ThreadLocalRandom.current().nextLong(1L << attempt));

        return delayFor(interval.toMillis(), executor);
    }

    /**
     * Set the delay backoff milliseconds.
     *
     * @param milliseconds              the milliseconds
     * @param executor                  the executor
     * @return                          the updated future
     */
    static CompletableFuture<Void> delayFor(long milliseconds, Executor executor) {
        logger.trace("waiting for {} seconds before trying again", (double) milliseconds / 1000.0);

        return CompletableFuture.runAsync(
            () -> {
            },
            delayedExecutor(milliseconds, TimeUnit.MILLISECONDS, executor));
    }

    private static Executor delayedExecutor(long delay, TimeUnit unit, Executor executor) {
        return r -> SCHEDULER.schedule(() -> executor.execute(r), delay, unit);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/DelegateContractId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractID;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * The ID for a smart contract instance on Hedera.
 */
public final class DelegateContractId extends ContractId {
    /**
     * Constructor.
     *
     * @param num                       the num portion of the contract id
     */
    public DelegateContractId(long num) {
        super(num);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard portion of the contract id
     * @param realm                     the realm portion of the contract id
     * @param num                       the num portion of the contract id
     */
    public DelegateContractId(long shard, long realm, long num) {
        super(shard, realm, num);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard portion of the contract id
     * @param realm                     the realm portion of the contract id
     * @param num                       the num portion of the contract id
     * @param checksum                  the optional checksum
     */
    DelegateContractId(long shard, long realm, long num, @Nullable String checksum) {
        super(shard, realm, num, checksum);
    }

    /**
     * Create a delegate contract id from a string.
     *
     * @param id                        the contract id
     * @return                          the delegate contract id object
     */
    public static DelegateContractId fromString(String id) {
        return EntityIdHelper.fromString(id, DelegateContractId::new);
    }

    /**
     * Create a delegate contract id from a string.
     *
     * @param address                   the contract id solidity address
     * @return                          the delegate contract id object
     */
    public static DelegateContractId fromSolidityAddress(String address) {
        return EntityIdHelper.fromSolidityAddress(address, DelegateContractId::new);
    }

    /**
     * Create a delegate contract id from a string.
     *
     * @param contractId                the contract id protobuf
     * @return                          the delegate contract id object
     */
    static DelegateContractId fromProtobuf(ContractID contractId) {
        Objects.requireNonNull(contractId);
        return new DelegateContractId(contractId.getShardNum(), contractId.getRealmNum(), contractId.getContractNum());
    }

    /**
     * Create a delegate contract id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the delegate contract id object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static DelegateContractId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(ContractID.parseFrom(bytes).toBuilder().build());
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        return com.hedera.hashgraph.sdk.proto.Key.newBuilder()
            .setDelegatableContractId(toProtobuf())
            .build();
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (o instanceof DelegateContractId) {
            DelegateContractId otherId = (DelegateContractId) o;
            return shard == otherId.shard && realm == otherId.realm && num == otherId.num;
        } else if (o instanceof ContractId) {
            ContractId otherId = (ContractId) o;
            return shard == otherId.shard && realm == otherId.realm && num == otherId.num;
        } else {
            return false;
        }

    }
}

// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/DurationConverter.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.time.Duration;

/**
 * Utility class used internally by the sdk.
 */
final class DurationConverter {
    private DurationConverter() {
    }

    /**
     * Create a duration object from a protobuf.
     *
     * @param duration                  the duration protobuf
     * @return                          the duration object
     */
    static Duration fromProtobuf(com.hedera.hashgraph.sdk.proto.Duration duration) {
        return Duration.ofSeconds(duration.getSeconds());
    }

    /**
     * Convert the duration object into a protobuf.
     *
     * @param duration                  the duration object
     * @return                          the protobuf
     */
    static com.hedera.hashgraph.sdk.proto.Duration toProtobuf(Duration duration) {
        return com.hedera.hashgraph.sdk.proto.Duration.newBuilder()
            .setSeconds(duration.getSeconds())
            .build();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Endpoint.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ServiceEndpoint;

import java.util.Arrays;
import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Utility class used internally by the sdk.
 */
public class Endpoint implements Cloneable {

    @Nullable
    byte[] address = null;

    int port;

    String domainName = "";

    /**
     * Constructor.
     */
    public Endpoint() {
    }

    /**
     * Create an endpoint object from a service endpoint protobuf.
     *
     * @param serviceEndpoint           the service endpoint protobuf
     * @return                          the endpoint object
     */
    static Endpoint fromProtobuf(ServiceEndpoint serviceEndpoint) {
        @Var var port = (int) (serviceEndpoint.getPort() & 0x00000000ffffffffL);

        if (port == 0 || port == 50111) {
            port = 50211;
        }

        return new Endpoint()
            .setAddress(serviceEndpoint.getIpAddressV4().toByteArray())
            .setPort(port)
            .setDomainName(serviceEndpoint.getDomainName());
    }

    /**
     * Extract the ipv4 address.
     *
     * @return                          the ipv4 address
     */
    @Nullable
    public byte[] getAddress() {
        return address;
    }

    /**
     * Assign the ipv4 address.
     *
     * @param address                   the desired ipv4 address
     * @return {@code this}
     */
    public Endpoint setAddress(byte[] address) {
        this.address = address;
        return this;
    }

    /**
     * Extract the port number.
     *
     * @return                          the port number
     */
    public int getPort() {
        return port;
    }

    /**
     * Assign the desired port number.
     *
     * @param port                      the desired port number
     * @return {@code this}
     */
    public Endpoint setPort(int port) {
        this.port = port;
        return this;
    }

    /**
     * Extract the domain name.
     *
     * @return                          the domain name
     */
    public String getDomainName() {
        return domainName;
    }

    /**
     * Assign the desired domain name.
     *
     * @param domainName                      the desired domain name
     * @return {@code this}
     */
    public Endpoint setDomainName(String domainName) {
        this.domainName = domainName;
        return this;
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    ServiceEndpoint toProtobuf() {
        var builder = ServiceEndpoint.newBuilder();

        if (address != null) {
            builder.setIpAddressV4(ByteString.copyFrom(address));
        }

        builder.setDomainName(domainName);

        return builder.setPort(port).build();
    }

    @Override
    public String toString() {
        if (this.domainName != null && !this.domainName.isEmpty()) {
            return domainName + ":" + port;
        } else {
            return ((int) address[0] & 0x000000FF) + "." + ((int) address[1] & 0x000000FF) + "." +
            ((int) address[2] & 0x000000FF) + "." + ((int) address[3] & 0x000000FF) +
                ":" + port;
        }
    }

    @Override
    public Endpoint clone() {
        try {
            Endpoint clone = (Endpoint) super.clone();
            clone.address = address != null ? address.clone() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EntityIdHelper.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.ByteBuffer;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.DecoderException;
import org.bouncycastle.util.encoders.Hex;

/**
 * Utility class used internally by the sdk.
 */
class EntityIdHelper {
    /**
     * The length of a Solidity address in bytes.
     */
    static final int SOLIDITY_ADDRESS_LEN = 20;

    /**
     * The length of a hexadecimal-encoded Solidity address, in ASCII characters (bytes).
     */
    static final int SOLIDITY_ADDRESS_LEN_HEX = SOLIDITY_ADDRESS_LEN * 2;

    private static final Pattern ENTITY_ID_REGEX = Pattern.compile(
        "(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-([a-z]{5}))?$");

    static final Duration MIRROR_NODE_CONNECTION_TIMEOUT = Duration.ofSeconds(30);

    /**
     * Constructor.
     */
    private EntityIdHelper() {
    }

    /**
     * Generate an R object from a string.
     *
     * @param idString                  the id string
     * @param constructObjectWithIdNums the R object generator
     * @param <R>
     * @return the R type object
     */
    static <R> R fromString(String idString, WithIdNums<R> constructObjectWithIdNums) {
        var match = ENTITY_ID_REGEX.matcher(idString);
        if (!match.find()) {
            throw new IllegalArgumentException(
                "Invalid ID \"" + idString + "\": format should look like 0.0.123 or 0.0.123-vfmkw"
            );
        }
        return constructObjectWithIdNums.apply(
            Long.parseLong(match.group(1)),
            Long.parseLong(match.group(2)),
            Long.parseLong(match.group(3)),
            match.group(4));
    }

    /**
     * Generate an R object from a solidity address.
     *
     * @param address     the string representation
     * @param withAddress the R object generator
     * @param <R>
     * @return the R type object
     */
    static <R> R fromSolidityAddress(String address, WithIdNums<R> withAddress) {
        return fromSolidityAddress(decodeSolidityAddress(address), withAddress);
    }

    private static <R> R fromSolidityAddress(byte[] address, WithIdNums<R> withAddress) {
        if (address.length != SOLIDITY_ADDRESS_LEN) {
            throw new IllegalArgumentException(
                "Solidity addresses must be 20 bytes or 40 hex chars");
        }

        var buf = ByteBuffer.wrap(address);
        return withAddress.apply(buf.getInt(), buf.getLong(), buf.getLong(), null);
    }

    /**
     * Decode the solidity address from a string.
     *
     * @param address the string representation
     * @return the decoded address
     */
    public static byte[] decodeSolidityAddress(@Var String address) {
        address = address.startsWith("0x") ? address.substring(2) : address;

        if (address.length() != SOLIDITY_ADDRESS_LEN_HEX) {
            throw new IllegalArgumentException(
                "Solidity addresses must be 20 bytes or 40 hex chars");
        }

        try {
            return Hex.decode(address);
        } catch (DecoderException e) {
            throw new IllegalArgumentException("failed to decode Solidity address as hex", e);
        }
    }

    /**
     * Generate a solidity address.
     *
     * @param shard the shard part
     * @param realm the realm part
     * @param num   the num part
     * @return the solidity address
     */
    static String toSolidityAddress(long shard, long realm, long num) {
        if (Long.highestOneBit(shard) > 32) {
            throw new IllegalStateException("shard out of 32-bit range " + shard);
        }

        return Hex.toHexString(
            ByteBuffer.allocate(20)
                .putInt((int) shard)
                .putLong(realm)
                .putLong(num)
                .array());
    }

    /**
     * Generate a checksum.
     *
     * @param ledgerId the ledger id
     * @param addr     the address
     * @return the checksum
     */
    static String checksum(LedgerId ledgerId, String addr) {
        StringBuilder answer = new StringBuilder();
        List<Integer> d = new ArrayList<>(); // Digits with 10 for ".", so if addr == "0.0.123" then d == [0, 10, 0, 10, 1, 2, 3]
        @Var
        long s0 = 0; // Sum of even positions (mod 11)
        @Var
        long s1 = 0; // Sum of odd positions (mod 11)
        @Var
        long s = 0; // Weighted sum of all positions (mod p3)
        @Var
        long sh = 0; // Hash of the ledger ID
        @SuppressWarnings("UnusedVariable")
        @Var
        long c = 0; // The checksum, as a single number
        long p3 = 26 * 26 * 26; // 3 digits in base 26
        long p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26
        long asciiA = Character.codePointAt("a", 0); // 97
        long m = 1_000_003; //min prime greater than a million. Used for the final permutation.
        long w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.

        List<Byte> h = new ArrayList<>(ledgerId.toBytes().length + 6);
        for (byte b : ledgerId.toBytes()) {
            h.add(b);
        }
        for (int i = 0; i < 6; i++) {
            h.add((byte) 0);
        }
        for (var i = 0; i < addr.length(); i++) {
            d.add(addr.charAt(i) == '.' ? 10 : Integer.parseInt(String.valueOf(addr.charAt(i)), 10));
        }
        for (var i = 0; i < d.size(); i++) {
            s = (w * s + d.get(i)) % p3;
            if (i % 2 == 0) {
                s0 = (s0 + d.get(i)) % 11;
            } else {
                s1 = (s1 + d.get(i)) % 11;
            }
        }
        for (byte b : h) {
            // byte is signed in java, have to fake it to make bytes act like they're unsigned
            sh = (w * sh + (b < 0 ? 256 + b : b)) % p5;
        }
        c = ((((addr.length() % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;
        c = (c * m) % p5;

        for (var i = 0; i < 5; i++) {
            answer.append((char) (asciiA + (c % 26)));
            c /= 26;
        }

        return answer.reverse().toString();
    }

    /**
     * Validate the configured client.
     *
     * @param shard    the shard part
     * @param realm    the realm part
     * @param num      the num part
     * @param client   the configured client
     * @param checksum the checksum
     * @throws BadEntityIdException
     */
    static void validate(long shard, long realm, long num, Client client, @Nullable String checksum)
        throws BadEntityIdException {
        if (client.getNetworkName() == null) {
            throw new IllegalStateException(
                "Can't validate checksum without knowing which network the ID is for.  Ensure client's network name is set.");
        }
        if (checksum != null) {
            String expectedChecksum = EntityIdHelper.checksum(
                client.getLedgerId(),
                EntityIdHelper.toString(shard, realm, num)
            );
            if (!checksum.equals(expectedChecksum)) {
                throw new BadEntityIdException(shard, realm, num, checksum, expectedChecksum);
            }
        }
    }

    /**
     * Generate a string representation.
     *
     * @param shard the shard part
     * @param realm the realm part
     * @param num   the num part
     * @return the string representation
     */
    static String toString(long shard, long realm, long num) {
        return "" + shard + "." + realm + "." + num;
    }

    /**
     * Generate a string representation with a checksum.
     *
     * @param shard    the shard part
     * @param realm    the realm part
     * @param num      the num part
     * @param client   the configured client
     * @param checksum the checksum
     * @return the string representation with checksum
     */
    static String toStringWithChecksum(long shard, long realm, long num, Client client, @Nullable String checksum) {
        if (client.getLedgerId() != null) {
            return "" + shard + "." + realm + "." + num + "-" + checksum(client.getLedgerId(),
                EntityIdHelper.toString(shard, realm, num));
        } else {
            throw new IllegalStateException(
                "Can't derive checksum for ID without knowing which network the ID is for.  Ensure client's ledgerId is set.");
        }
    }

    /**
     * Takes an address as `byte[]` and returns whether this is a long-zero address
     * @param address
     * @return
     */
    public static boolean isLongZeroAddress(byte[] address) {
        for (int i = 0; i < 12; i++) {
            if (address[i] != 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Get AccountId num from mirror node using evm address.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 33
     * because it uses features introduced in API level 33 (Android 13).</p>*
     *
     * @param client
     * @param evmAddress
     * @return
     * @throws IOException
     * @throws InterruptedException
     */
    public static CompletableFuture<Long> getAccountNumFromMirrorNodeAsync(Client client, String evmAddress) {
        String apiEndpoint = "/accounts/" + evmAddress;
        return performQueryToMirrorNodeAsync(client, apiEndpoint)
            .thenApply(response ->
                parseNumFromMirrorNodeResponse(response, "account"));
    }

    /**
     * Get EvmAddress from mirror node using account num.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 33
     * because it uses features introduced in API level 33 (Android 13).</p>*
     *
     * @param client
     * @param num
     * @return
     * @throws IOException
     * @throws InterruptedException
     */
    public static CompletableFuture<EvmAddress> getEvmAddressFromMirrorNodeAsync(Client client, long num) {
        String apiEndpoint = "/accounts/" + num;
        return performQueryToMirrorNodeAsync(client, apiEndpoint)
            .thenApply(response ->
                EvmAddress.fromString(parseEvmAddressFromMirrorNodeResponse(response, "evm_address")));
    }

    /**
     * Get ContractId num from mirror node using evm address.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 33
     * because it uses features introduced in API level 33 (Android 13).</p>*
     *
     * @param client
     * @param evmAddress
     * @return
     * @throws IOException
     * @throws InterruptedException
     */
    public static CompletableFuture<Long> getContractNumFromMirrorNodeAsync(Client client, String evmAddress) {
        String apiEndpoint = "/contracts/" + evmAddress;

        CompletableFuture<String> responseFuture = performQueryToMirrorNodeAsync(client, apiEndpoint);

        return responseFuture.thenApply(response ->
            parseNumFromMirrorNodeResponse(response, "contract_id"));
    }

    private static CompletableFuture<String> performQueryToMirrorNodeAsync(Client client, String apiEndpoint) {
        Optional<String> mirrorUrl = client.getMirrorNetwork().stream()
            .map(url -> url.substring(0, url.indexOf(":")))
            .findFirst();

        if (mirrorUrl.isEmpty()) {
            return CompletableFuture.failedFuture(new IllegalArgumentException("Mirror URL not found"));
        }

        String apiUrl = "https://" + mirrorUrl.get() + "/api/v1" + apiEndpoint;

        if (client.getLedgerId() == null) {
            apiUrl = "http://" + mirrorUrl.get() + ":5551/api/v1" + apiEndpoint;
        }

        HttpClient httpClient = HttpClient.newHttpClient();
        HttpRequest httpRequest = HttpRequest.newBuilder()
            .timeout(MIRROR_NODE_CONNECTION_TIMEOUT)
            .uri(URI.create(apiUrl))
            .build();

        return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
            .thenApply(HttpResponse::body);
    }

    private static long parseNumFromMirrorNodeResponse(String responseBody, String memberName) {
        JsonParser jsonParser = new JsonParser();
        JsonObject jsonObject = jsonParser.parse(responseBody).getAsJsonObject();

        String num = jsonObject.get(memberName).getAsString();

        return Long.parseLong(num.substring(num.lastIndexOf(".") + 1));
    }

    private static String parseEvmAddressFromMirrorNodeResponse(String responseBody, String memberName) {
        JsonParser jsonParser = new JsonParser();
        JsonObject jsonObject = jsonParser.parse(responseBody).getAsJsonObject();

        String evmAddress = jsonObject.get(memberName).getAsString();

        return evmAddress.substring(evmAddress.lastIndexOf(".") + 1);
    }

    @FunctionalInterface
    interface WithIdNums<R> {
        R apply(long shard, long realm, long num, @Nullable String checksum);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EthereumFlow.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.time.Duration;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;

/**
 * Execute an Ethereum transaction on Hedera
 */
public class EthereumFlow {
    /**
     * 5KiB in Bytes
     * Indicates when we should splice out the call data from an ethereum transaction data
     */
    static int MAX_ETHEREUM_DATA_SIZE = 5120;
    @Nullable
    private EthereumTransactionData ethereumData;

    @Nullable
    private FileId callDataFileId;

    @Nullable
    private Hbar maxGasAllowance;


    /**
     * Constructor
     */
    public EthereumFlow() {
    }

    private static FileId createFile(byte[] callData, Client client, Duration timeoutPerTransaction) throws PrecheckStatusException, TimeoutException {
        try {
            var transaction = new FileCreateTransaction()
                .setContents(Arrays.copyOfRange(callData, 0, Math.min(FileAppendTransaction.DEFAULT_CHUNK_SIZE, callData.length)))
                .execute(client, timeoutPerTransaction);
            var fileId = transaction.getReceipt(client, timeoutPerTransaction).fileId;

            if (callData.length > FileAppendTransaction.DEFAULT_CHUNK_SIZE) {
                new FileAppendTransaction()
                    .setFileId(fileId)
                    .setContents(Arrays.copyOfRange(callData, FileAppendTransaction.DEFAULT_CHUNK_SIZE, callData.length))
                    .execute(client, timeoutPerTransaction);
            }
            return fileId;
        } catch (ReceiptStatusException e) {
            throw new RuntimeException(e);
        }

    }

    private static CompletableFuture<FileId> createFileAsync(byte[] callData, Client client, Duration timeoutPerTransaction) {
        return new FileCreateTransaction()
            .setContents(Arrays.copyOfRange(callData, 0, Math.min(FileAppendTransaction.DEFAULT_CHUNK_SIZE, callData.length)))
            .executeAsync(client, timeoutPerTransaction)
            .thenCompose((response) -> response.getReceiptAsync(client, timeoutPerTransaction))
            .thenCompose((receipt) -> {
                if (callData.length > FileAppendTransaction.DEFAULT_CHUNK_SIZE) {
                    return new FileAppendTransaction()
                        .setFileId(receipt.fileId)
                        .setContents(Arrays.copyOfRange(callData, FileAppendTransaction.DEFAULT_CHUNK_SIZE, callData.length))
                        .executeAsync(client, timeoutPerTransaction)
                        .thenApply((r) -> receipt.fileId);
                } else {
                    return CompletableFuture.completedFuture(receipt.fileId);
                }
            });
    }

    /**
     * Gets the data of the Ethereum transaction
     *
     * @return the data of the Ethereum transaction
     */
    @Nullable
    public EthereumTransactionData getEthereumData() {
        return ethereumData;
    }

    /**
     * Sets the raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
     * unless the callDataFileId is set.
     *
     * @param ethereumData raw ethereum transaction bytes
     * @return {@code this}
     */
    public EthereumFlow setEthereumData(byte[] ethereumData) {
        this.ethereumData = EthereumTransactionData.fromBytes(ethereumData);
        return this;
    }

    /**
     * Gets the maximum amount that the payer of the hedera transaction
     * is willing to pay to complete the transaction.
     *
     * @return the max gas allowance
     */
    @Nullable
    public Hbar getMaxGasAllowance() {
        return maxGasAllowance;
    }

    /**
     * Sets the maximum amount that the payer of the hedera transaction
     * is willing to pay to complete the transaction.
     * <br>
     * Ordinarily the account with the ECDSA alias corresponding to the public
     * key that is extracted from the ethereum_data signature is responsible for
     * fees that result from the execution of the transaction. If that amount of
     * authorized fees is not sufficient then the payer of the transaction can be
     * charged, up to but not exceeding this amount. If the ethereum_data
     * transaction authorized an amount that was insufficient then the payer will
     * only be charged the amount needed to make up the difference. If the gas
     * price in the transaction was set to zero then the payer will be assessed
     * the entire fee.
     *
     * @param maxGasAllowance the maximum gas allowance
     * @return {@code this}
     */
    public EthereumFlow setMaxGasAllowance(Hbar maxGasAllowance) {
        this.maxGasAllowance = maxGasAllowance;
        return this;
    }

    /**
     * Execute the transactions in the flow with the passed in client.
     *
     * @param client the client with the transaction to execute
     * @return the response
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public TransactionResponse execute(Client client) throws PrecheckStatusException, TimeoutException {
        return execute(client, client.getRequestTimeout());
    }

    /**
     * Execute the transactions in the flow with the passed in client.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @return the response
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public TransactionResponse execute(Client client, Duration timeoutPerTransaction) throws PrecheckStatusException, TimeoutException {
        if (ethereumData == null) {
            throw new IllegalStateException("Cannot execute a ethereum flow when ethereum data was not provided");
        }

        var ethereumTransaction = new EthereumTransaction();
        var ethereumDataBytes = ethereumData.toBytes();

        if (maxGasAllowance != null) {
            ethereumTransaction.setMaxGasAllowanceHbar(maxGasAllowance);
        }

        if (ethereumDataBytes.length <= MAX_ETHEREUM_DATA_SIZE) {
            ethereumTransaction.setEthereumData(ethereumDataBytes);
        } else {
            var callDataFileId = createFile(ethereumData.callData, client, timeoutPerTransaction);
            ethereumData.callData = new byte[]{};
            ethereumTransaction.setEthereumData(ethereumData.toBytes()).setCallDataFileId(callDataFileId);
        }

        return ethereumTransaction.execute(client, timeoutPerTransaction);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 31
     * because it uses features introduced in API level 31 (Android 12).</p>*
     *
     * @param client the client with the transaction to execute
     * @return the response
     */
    public CompletableFuture<TransactionResponse> executeAsync(Client client) {
        return executeAsync(client, client.getRequestTimeout());
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 31
     * because it uses features introduced in API level 31 (Android 12).</p>*
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @return the response
     */
    public CompletableFuture<TransactionResponse> executeAsync(Client client, Duration timeoutPerTransaction) {
        if (ethereumData == null) {
            return CompletableFuture.failedFuture(new IllegalStateException("Cannot execute a ethereum flow when ethereum data was not provided"));
        }

        var ethereumTransaction = new EthereumTransaction();
        var ethereumDataBytes = ethereumData.toBytes();

        if (maxGasAllowance != null) {
            ethereumTransaction.setMaxGasAllowanceHbar(maxGasAllowance);
        }

        if (ethereumDataBytes.length <= MAX_ETHEREUM_DATA_SIZE) {
            return ethereumTransaction.setEthereumData(ethereumDataBytes).executeAsync(client);
        } else {
            return createFileAsync(ethereumData.callData, client, timeoutPerTransaction)
                .thenCompose((callDataFileId) -> {
                    ethereumData.callData = new byte[]{};
                    return ethereumTransaction
                        .setEthereumData(ethereumData.toBytes())
                        .setCallDataFileId(callDataFileId)
                        .executeAsync(client, timeoutPerTransaction);
                });
        }
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client   the client with the transaction to execute
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, BiConsumer<TransactionResponse, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client), callback);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @param callback              a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, Duration timeoutPerTransaction, BiConsumer<TransactionResponse, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client, timeoutPerTransaction), callback);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client    the client with the transaction to execute
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Consumer<TransactionResponse> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client), onSuccess, onFailure);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @param onSuccess             a Consumer which consumes the result on success.
     * @param onFailure             a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Duration timeoutPerTransaction, Consumer<TransactionResponse> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client, timeoutPerTransaction), onSuccess, onFailure);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EthereumTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.EthereumTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Execute an Ethereum transaction on Hedera
 */
public class EthereumTransaction extends Transaction<EthereumTransaction> {
    private byte[] ethereumData = new byte[0];
    private FileId callDataFileId = null;
    private Hbar maxGasAllowanceHbar = Hbar.ZERO;

    /**
     * Constructor
     */
    public EthereumTransaction() {
    }

    EthereumTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    EthereumTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Gets the raw Ethereum transaction
     *
     * @return the raw Ethereum transaction
     */
    public byte[] getEthereumData() {
        return Arrays.copyOf(ethereumData, ethereumData.length);
    }

    /**
     * Sets the raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
     * unless the callDataFileId is set.
     *
     * @param ethereumData raw ethereum transaction bytes
     * @return {@code this}
     */

    public EthereumTransaction setEthereumData(byte[] ethereumData) {
        Objects.requireNonNull(ethereumData);
        requireNotFrozen();
        this.ethereumData = Arrays.copyOf(ethereumData, ethereumData.length);
        return this;
    }

    /**
     * Gets the FileId of the call data
     *
     * @return the FileId of the call data
     */
    @Nullable
    public FileId getCallDataFileId() {
        return callDataFileId;
    }

    /**
     * For large transactions (for example contract create) this should be used to
     * set the FileId of an HFS file containing the callData
     * of the ethereumData. The data in the ethereumData will be re-written with
     * the callData element as a zero length string with the original contents in
     * the referenced file at time of execution. The ethereumData will need to be
     * "rehydrated" with the callData for signature validation to pass.
     *
     * @param fileId File ID of an HFS file containing the callData
     * @return {@code this}
     */

    public EthereumTransaction setCallDataFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        requireNotFrozen();
        callDataFileId = fileId;
        return this;
    }

    /**
     * Gets the maximum amount that the payer of the hedera transaction
     * is willing to pay to complete the transaction.
     *
     * @return the max gas allowance
     */
    public Hbar getMaxGasAllowanceHbar() {
        return maxGasAllowanceHbar;
    }

    /**
     * Sets the maximum amount that the payer of the hedera transaction
     * is willing to pay to complete the transaction.
     * <br>
     * Ordinarily the account with the ECDSA alias corresponding to the public
     * key that is extracted from the ethereum_data signature is responsible for
     * fees that result from the execution of the transaction. If that amount of
     * authorized fees is not sufficient then the payer of the transaction can be
     * charged, up to but not exceeding this amount. If the ethereum_data
     * transaction authorized an amount that was insufficient then the payer will
     * only be charged the amount needed to make up the difference. If the gas
     * price in the transaction was set to zero then the payer will be assessed
     * the entire fee.
     *
     * @param maxGasAllowanceHbar the maximum gas allowance
     * @return {@code this}
     */
    public EthereumTransaction setMaxGasAllowanceHbar(Hbar maxGasAllowanceHbar) {
        Objects.requireNonNull(maxGasAllowanceHbar);
        requireNotFrozen();
        this.maxGasAllowanceHbar = maxGasAllowanceHbar;
        return this;
    }

    private void initFromTransactionBody() {
        var body = sourceTransactionBody.getEthereumTransaction();

        ethereumData = body.getEthereumData().toByteArray();
        if (body.hasCallData()) {
            callDataFileId = FileId.fromProtobuf(body.getCallData());
        }
        maxGasAllowanceHbar = Hbar.fromTinybars(body.getMaxGasAllowance());
    }

    private EthereumTransactionBody.Builder build() {
        var builder = EthereumTransactionBody.newBuilder()
            .setEthereumData(ByteString.copyFrom(ethereumData))
            .setMaxGasAllowance(maxGasAllowanceHbar.toTinybars());
        if (callDataFileId != null) {
            builder.setCallData(callDataFileId.toProtobuf());
        }
        return builder;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return SmartContractServiceGrpc.getCallEthereumMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setEthereumTransaction(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("Cannot schedule EthereumTransaction");
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (callDataFileId != null) {
            callDataFileId.validateChecksum(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EthereumTransactionData.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.esaulpaugh.headlong.rlp.RLPDecoder;

/**
 * This class represents the data of an Ethereum transaction.
 * <p>
 * It may be of subclass {@link EthereumTransactionDataLegacy} or of subclass {@link EthereumTransactionDataEip1559}
 */
public abstract class EthereumTransactionData {
    /**
     * The raw call data.
     */
    public byte[] callData;

    EthereumTransactionData(byte[] callData) {
        this.callData = callData;
    }

    static EthereumTransactionData fromBytes(byte[] bytes) {
        var decoder = RLPDecoder.RLP_STRICT.sequenceIterator(bytes);
        var rlpItem = decoder.next();
        if (rlpItem.isList()) {
            return EthereumTransactionDataLegacy.fromBytes(bytes);
        } else {
            return EthereumTransactionDataEip1559.fromBytes(bytes);
        }
    }

    /**
     * Serialize the ethereum transaction data into bytes using RLP
     *
     * @return the serialized transaction as a byte array
     */
    public abstract byte[] toBytes();

    /**
     * Serialize the ethereum transaction data into a string
     *
     * @return the serialized transaction as a string
     */
    public abstract String toString();
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EthereumTransactionDataEip1559.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.esaulpaugh.headlong.rlp.RLPDecoder;
import com.esaulpaugh.headlong.rlp.RLPEncoder;
import com.esaulpaugh.headlong.rlp.RLPItem;
import com.esaulpaugh.headlong.util.Integers;
import com.google.common.base.MoreObjects;
import java.util.ArrayList;
import java.util.List;
import org.bouncycastle.util.encoders.Hex;

/**
 * The ethereum transaction data, in the format defined in <a
 * href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md">EIP-1559</a>
 */
public class EthereumTransactionDataEip1559 extends EthereumTransactionData {

    /**
     * ID of the chain
     */
    public byte[] chainId;

    /**
     * Transaction's nonce
     */
    public byte[] nonce;

    /**
     * An 'optional' additional fee in Ethereum that is paid directly to miners in order to incentivize them to include
     * your transaction in a block. Not used in Hedera
     */
    public byte[] maxPriorityGas;

    /**
     * The maximum amount, in tinybars, that the payer of the hedera transaction is willing to pay to complete the
     * transaction
     */
    public byte[] maxGas;

    /**
     * The amount of gas available for the transaction
     */
    public byte[] gasLimit;

    /**
     * The receiver of the transaction
     */
    public byte[] to;

    /**
     * The transaction value
     */
    public byte[] value;

    /**
     * specifies an array of addresses and storage keys that the transaction plans to access
     */
    public byte[] accessList;

    /**
     * recovery parameter used to ease the signature verification
     */
    public byte[] recoveryId;

    /**
     * The R value of the signature
     */
    public byte[] r;

    /**
     * The S value of the signature
     */
    public byte[] s;

    EthereumTransactionDataEip1559(
        byte[] chainId,
        byte[] nonce,
        byte[] maxPriorityGas,
        byte[] maxGas,
        byte[] gasLimit,
        byte[] to,
        byte[] value,
        byte[] callData,
        byte[] accessList,
        byte[] recoveryId,
        byte[] r,
        byte[] s
    ) {
        super(callData);

        this.chainId = chainId;
        this.nonce = nonce;
        this.maxPriorityGas = maxPriorityGas;
        this.maxGas = maxGas;
        this.gasLimit = gasLimit;
        this.to = to;
        this.value = value;
        this.accessList = accessList;
        this.recoveryId = recoveryId;
        this.r = r;
        this.s = s;
    }

    /**
     * Convert a byte array to an ethereum transaction data.
     *
     * @param bytes the byte array
     * @return the ethereum transaction data
     */
    public static EthereumTransactionDataEip1559 fromBytes(byte[] bytes) {
        var decoder = RLPDecoder.RLP_STRICT.sequenceIterator(bytes);
        var rlpItem = decoder.next();

        // typed transaction?
        byte typeByte = rlpItem.asByte();
        if (typeByte != 2) {
            throw new IllegalArgumentException("rlp type byte " + typeByte + "is not supported");
        }
        rlpItem = decoder.next();
        if (!rlpItem.isList()) {
            throw new IllegalArgumentException("expected RLP element list");
        }
        List<RLPItem> rlpList = rlpItem.asRLPList().elements();
        if (rlpList.size() != 12) {
            throw new IllegalArgumentException("expected 12 RLP encoded elements, found " + rlpList.size());
        }

        return new EthereumTransactionDataEip1559(
            rlpList.get(0).data(),
            rlpList.get(1).data(),
            rlpList.get(2).data(),
            rlpList.get(3).data(),
            rlpList.get(4).data(),
            rlpList.get(5).data(),
            rlpList.get(6).data(),
            rlpList.get(7).data(),
            rlpList.get(8).data(),
            rlpList.get(9).data(),
            rlpList.get(10).data(),
            rlpList.get(11).data()
        );
    }

    public byte[] toBytes() {
        return RLPEncoder.sequence(Integers.toBytes(0x02), List.of(
            chainId, nonce, maxPriorityGas, maxGas, gasLimit, to,
            value, callData, new ArrayList<String>(), recoveryId, r, s
        ));
    }

    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("chainId", Hex.toHexString(chainId))
            .add("nonce", Hex.toHexString(nonce))
            .add("maxPriorityGas", Hex.toHexString(maxPriorityGas))
            .add("maxGas", Hex.toHexString(maxGas))
            .add("gasLimit", Hex.toHexString(gasLimit))
            .add("to", Hex.toHexString(to))
            .add("value", Hex.toHexString(value))
            .add("accessList", Hex.toHexString(accessList))
            .add("recoveryId", Hex.toHexString(recoveryId))
            .add("r", Hex.toHexString(r))
            .add("s", Hex.toHexString(s))
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EthereumTransactionDataLegacy.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.esaulpaugh.headlong.rlp.RLPDecoder;
import com.esaulpaugh.headlong.rlp.RLPEncoder;
import com.esaulpaugh.headlong.rlp.RLPItem;
import com.google.common.base.MoreObjects;
import org.bouncycastle.util.encoders.Hex;

import java.math.BigInteger;
import java.util.List;

/**
 * The ethereum transaction data, in the legacy format
 */
public class EthereumTransactionDataLegacy extends EthereumTransactionData {

    /**
     * ID of the chain
     */
    public byte[] chainId = new byte[]{};

    /**
     * Transaction's nonce
     */
    public byte[] nonce;

    /**
     * The price for 1 gas
     */
    public byte[] gasPrice;

    /**
     * The amount of gas available for the transaction
     */
    public byte[] gasLimit;

    /**
     * The receiver of the transaction
     */
    public byte[] to;

    /**
     * The transaction value
     */
    public byte[] value;

    /**
     * The V value of the signature
     */
    public byte[] v;

    /**
     * recovery parameter used to ease the signature verification
     */
    public int recoveryId;

    /**
     * The R value of the signature
     */
    public byte[] r;

    /**
     * The S value of the signature
     */
    public byte[] s;

    EthereumTransactionDataLegacy(
        byte[] nonce,
        byte[] gasPrice,
        byte[] gasLimit,
        byte[] to,
        byte[] value,
        byte[] callData,
        byte[] v,
        byte[] r,
        byte[] s
    ) {
        super(callData);

        this.nonce = nonce;
        this.gasPrice = gasPrice;
        this.gasLimit = gasLimit;
        this.to = to;
        this.value = value;
        this.v = v;
        this.r = r;
        this.s = s;

        var vBI = new BigInteger(1, this.v);
        this.recoveryId = vBI.testBit(0) ? 0 : 1;

        if (vBI.compareTo(BigInteger.valueOf(34)) > 0) {
            this.chainId = vBI.subtract(BigInteger.valueOf(35)).shiftRight(1).toByteArray();
        }
    }

    /**
     * Convert a byte array to an ethereum transaction data.
     *
     * @param bytes                     the byte array
     * @return                          the ethereum transaction data
     */
    public static EthereumTransactionDataLegacy fromBytes(byte[] bytes) {
        var decoder = RLPDecoder.RLP_STRICT.sequenceIterator(bytes);
        var rlpItem = decoder.next();

        List<RLPItem> rlpList = rlpItem.asRLPList().elements();
        if (rlpList.size() != 9) {
            throw new IllegalArgumentException("expected 9 RLP encoded elements, found " + rlpList.size());
        }

        return new EthereumTransactionDataLegacy(
            rlpList.get(0).data(),
            rlpList.get(1).asBytes(),
            rlpList.get(2).data(),
            rlpList.get(3).data(),
            rlpList.get(4).data(),
            rlpList.get(5).data(),
            rlpList.get(6).asBytes(),
            rlpList.get(7).data(),
            rlpList.get(8).data()
        );
    }

    public byte[] toBytes() {
        return RLPEncoder.list(nonce, gasPrice, gasLimit, to, value, callData, v, r, s);
    }

    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("chainId", Hex.toHexString(this.chainId))
            .add("nonce", Hex.toHexString(this.nonce))
            .add("gasPrice", Hex.toHexString(this.gasPrice))
            .add("gasLimit", Hex.toHexString(this.gasLimit))
            .add("to", Hex.toHexString(this.to))
            .add("value", Hex.toHexString(this.value))
            .add("recoveryId", this.recoveryId)
            .add("v", Hex.toHexString(this.v))
            .add("r", Hex.toHexString(this.r))
            .add("s", Hex.toHexString(this.s))
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/EvmAddress.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AccountID;
import org.bouncycastle.util.encoders.Hex;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.Objects;
import java.util.regex.Pattern;

/**
 * The ID for a cryptocurrency account on Hedera.
 */
public final class EvmAddress extends Key {
    private final byte[] bytes;

    /**
     * Constructor
     *
     * @param bytes the byte array representation of the address
     */
    public EvmAddress(byte[] bytes) {
        this.bytes = Arrays.copyOf(bytes, bytes.length);
    }

    /**
     * Convert a string to an ethereum address.
     *
     * @param text                      the string
     * @return                          the ethereum address
     */
    public static EvmAddress fromString(String text) {
        String address = text.startsWith("0x") ? text.substring(2) : text;
        if (address.length() == 40) {
            return new EvmAddress(Hex.decode(address));
        }
        return null;
    }

    @Nullable
    static EvmAddress fromAliasBytes(ByteString aliasBytes) {
        if (!aliasBytes.isEmpty() && aliasBytes.size() == 20) {
            return new EvmAddress(aliasBytes.toByteArray());
        }
        return null;
    }

    /**
     * Convert a byte array to an ethereum address.
     *
     * @param bytes                     the byte array
     * @return                          the ethereum address
     */
    public static EvmAddress fromBytes(byte[] bytes) {
        return new EvmAddress(bytes);
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        throw new UnsupportedOperationException("toProtobufKey() not implemented for EvmAddress");
    }

    public byte[] toBytes() {
        return Arrays.copyOf(bytes, bytes.length);
    }

    @Override
    public String toString() {
        return Hex.toHexString(bytes);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(bytes);
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof EvmAddress)) {
            return false;
        }

        EvmAddress other = (EvmAddress) o;
        return Arrays.equals(bytes, other.bytes);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ExchangeRate.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import java.time.Instant;

/**
 * Denotes a conversion between Hbars and cents (USD).
 */
public final class ExchangeRate {
    /**
     * Denotes Hbar equivalent to cents (USD)
     */
    public final int hbars;

    /**
     * Denotes cents (USD) equivalent to Hbar
     */
    public final int cents;

    /**
     * Expiration time of this exchange rate
     */
    public final Instant expirationTime;

    /**
     * Calculated exchange rate
     */
    public final double exchangeRateInCents;

    ExchangeRate(int hbars, int cents, Instant expirationTime) {
        this.hbars = hbars;
        this.cents = cents;
        this.expirationTime = expirationTime;
        this.exchangeRateInCents = (double) cents / (double) hbars;
    }

    /**
     * Create an Exchange Rate from a protobuf.
     *
     * @param pb                        the protobuf
     * @return                          the new exchange rate
     */
    static ExchangeRate fromProtobuf(com.hedera.hashgraph.sdk.proto.ExchangeRate pb) {
        return new ExchangeRate(
            pb.getHbarEquiv(),
            pb.getCentEquiv(),
            InstantConverter.fromProtobuf(pb.getExpirationTime())
        );
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("hbars", hbars)
            .add("cents", cents)
            .add("expirationTime", expirationTime)
            .add("exchangeRateInCents", exchangeRateInCents)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ExchangeRates.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

/**
 * Contains a set of Exchange Rates (current and next).
 */
public final class ExchangeRates {
    /**
     * Current Exchange Rate
     */
    public final ExchangeRate currentRate;

    /**
     * Next Exchange Rate
     */
    public final ExchangeRate nextRate;

    private ExchangeRates(ExchangeRate currentRate, ExchangeRate nextRate) {
        this.currentRate = currentRate;
        this.nextRate = nextRate;
    }

    /**
     * Create an Exchange Rates from a protobuf.
     *
     * @param pb                        the protobuf
     * @return                          the new exchange rates
     */
    static ExchangeRates fromProtobuf(com.hedera.hashgraph.sdk.proto.ExchangeRateSet pb) {
        return new ExchangeRates(
            ExchangeRate.fromProtobuf(pb.getCurrentRate()),
            ExchangeRate.fromProtobuf(pb.getNextRate())
        );
    }

    /**
     * Create an Exchange Rates from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new exchange rates
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static ExchangeRates fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.ExchangeRateSet.parseFrom(bytes).toBuilder().build());
    }


    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("currentRate", currentRate.toString())
            .add("nextRate", nextRate.toString())
            .toString();
    }

}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Executable.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static com.hedera.hashgraph.sdk.FutureConverter.toCompletableFuture;

import com.google.common.annotations.VisibleForTesting;
import com.google.protobuf.MessageLite;
import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import io.grpc.CallOptions;
import io.grpc.ClientCall;
import io.grpc.MethodDescriptor;
import io.grpc.Status.Code;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.ClientCalls;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.Hex;

/**
 * Abstract base utility class.
 *
 * @param <SdkRequestT>   the sdk request
 * @param <ProtoRequestT> the proto request
 * @param <ResponseT>     the response
 * @param <O>             the O type
 */
abstract class Executable<SdkRequestT, ProtoRequestT extends MessageLite, ResponseT extends MessageLite, O> {
    @SuppressWarnings("java:S2245")
    protected static final Random random = new Random();
    static final Pattern RST_STREAM = Pattern
        .compile(".*\\brst[^0-9a-zA-Z]stream\\b.*", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    /**
     * The maximum times execution will be attempted
     */
    @Nullable
    protected Integer maxAttempts = null;

    /**
     * The maximum amount of time to wait between retries
     */
    @Nullable
    protected Duration maxBackoff = null;

    /**
     * The minimum amount of time to wait between retries
     */
    @Nullable
    protected Duration minBackoff = null;

    /**
     * List of account IDs for nodes with which execution will be attempted.
     */
    protected LockableList<AccountId> nodeAccountIds = new LockableList<>();

    /**
     * List of healthy and unhealthy nodes with which execution will be attempted.
     */
    protected LockableList<Node> nodes = new LockableList<>();

    /**
     * Indicates if the request has been attempted to be sent to all nodes
     */
    protected boolean attemptedAllNodes = false;
    /**
     * The timeout for each execution attempt
     */
    protected Duration grpcDeadline;
    protected Logger logger;
    private java.util.function.Function<ProtoRequestT, ProtoRequestT> requestListener;
    // Lambda responsible for executing synchronous gRPC requests. Pluggable for unit testing.
    @VisibleForTesting
    Function<GrpcRequest, ResponseT> blockingUnaryCall =
        (grpcRequest) -> ClientCalls.blockingUnaryCall(grpcRequest.createCall(), grpcRequest.getRequest());
    private java.util.function.Function<ResponseT, ResponseT> responseListener;

    Executable() {
        requestListener = request -> {
            if (logger.isEnabledForLevel(LogLevel.TRACE)) {
                logger.trace("Sent protobuf {}", Hex.toHexString(request.toByteArray()));
            }
            return request;
        };
        responseListener = response -> {
            if (logger.isEnabledForLevel(LogLevel.TRACE)) {
                logger.trace("Received protobuf {}", Hex.toHexString(response.toByteArray()));
            }
            return response;
        };
    }

    /**
     * When execution is attempted, a single attempt will time out when this deadline is reached. (The SDK may
     * subsequently retry the execution.)
     *
     * @return The timeout for each execution attempt
     */
    public final Duration grpcDeadline() {
        return grpcDeadline;
    }

    /**
     * When execution is attempted, a single attempt will timeout when this deadline is reached. (The SDK may
     * subsequently retry the execution.)
     *
     * @param grpcDeadline The timeout for each execution attempt
     * @return {@code this}
     */
    public final SdkRequestT setGrpcDeadline(Duration grpcDeadline) {
        this.grpcDeadline = Objects.requireNonNull(grpcDeadline);

        // noinspection unchecked
        return (SdkRequestT) this;
    }

    /**
     * The maximum amount of time to wait between retries
     *
     * @return maxBackoff
     */
    public final Duration getMaxBackoff() {
        return maxBackoff != null ? maxBackoff : Client.DEFAULT_MAX_BACKOFF;
    }

    /**
     * The maximum amount of time to wait between retries. Every retry attempt will increase the wait time exponentially
     * until it reaches this time.
     *
     * @param maxBackoff The maximum amount of time to wait between retries
     * @return {@code this}
     */
    public final SdkRequestT setMaxBackoff(Duration maxBackoff) {
        if (maxBackoff == null || maxBackoff.toNanos() < 0) {
            throw new IllegalArgumentException("maxBackoff must be a positive duration");
        } else if (maxBackoff.compareTo(getMinBackoff()) < 0) {
            throw new IllegalArgumentException("maxBackoff must be greater than or equal to minBackoff");
        }
        this.maxBackoff = maxBackoff;
        // noinspection unchecked
        return (SdkRequestT) this;
    }

    /**
     * The minimum amount of time to wait between retries
     *
     * @return minBackoff
     */
    public final Duration getMinBackoff() {
        return minBackoff != null ? minBackoff : Client.DEFAULT_MIN_BACKOFF;
    }

    /**
     * The minimum amount of time to wait between retries. When retrying, the delay will start at this time and increase
     * exponentially until it reaches the maxBackoff.
     *
     * @param minBackoff The minimum amount of time to wait between retries
     * @return {@code this}
     */
    public final SdkRequestT setMinBackoff(Duration minBackoff) {
        if (minBackoff == null || minBackoff.toNanos() < 0) {
            throw new IllegalArgumentException("minBackoff must be a positive duration");
        } else if (minBackoff.compareTo(getMaxBackoff()) > 0) {
            throw new IllegalArgumentException("minBackoff must be less than or equal to maxBackoff");
        }
        this.minBackoff = minBackoff;
        // noinspection unchecked
        return (SdkRequestT) this;
    }

    /**
     * @return Number of errors before execution will fail.
     * @deprecated Use {@link #getMaxAttempts()} instead.
     */
    @java.lang.Deprecated
    public final int getMaxRetry() {
        return getMaxAttempts();
    }

    /**
     * @param count Number of errors before execution will fail
     * @return {@code this}
     * @deprecated Use {@link #setMaxAttempts(int)} instead.
     */
    @java.lang.Deprecated
    public final SdkRequestT setMaxRetry(int count) {
        return setMaxAttempts(count);
    }

    /**
     * Get the maximum times execution will be attempted.
     *
     * @return Number of errors before execution will fail.
     */
    public final int getMaxAttempts() {
        return maxAttempts != null ? maxAttempts : Client.DEFAULT_MAX_ATTEMPTS;
    }

    /**
     * Set the maximum times execution will be attempted.
     *
     * @param maxAttempts Execution will fail after this many errors.
     * @return {@code this}
     */
    public final SdkRequestT setMaxAttempts(int maxAttempts) {
        if (maxAttempts <= 0) {
            throw new IllegalArgumentException("maxAttempts must be greater than zero");
        }
        this.maxAttempts = maxAttempts;
        // noinspection unchecked
        return (SdkRequestT) this;
    }

    /**
     * Get the list of account IDs for nodes with which execution will be attempted.
     *
     * @return the list of account IDs
     */
    @Nullable
    public final List<AccountId> getNodeAccountIds() {
        if (!nodeAccountIds.isEmpty()) {
            return new ArrayList<>(nodeAccountIds.getList());
        }

        return null;
    }

    /**
     * Set the account IDs of the nodes that this transaction will be submitted to.
     * <p>
     * Providing an explicit node account ID interferes with client-side load balancing of the network. By default, the
     * SDK will pre-generate a transaction for 1/3 of the nodes on the network. If a node is down, busy, or otherwise
     * reports a fatal error, the SDK will try again with a different node.
     *
     * @param nodeAccountIds The list of node AccountIds to be set
     * @return {@code this}
     */
    public SdkRequestT setNodeAccountIds(List<AccountId> nodeAccountIds) {
        this.nodeAccountIds.setList(nodeAccountIds).setLocked(true);

        // noinspection unchecked
        return (SdkRequestT) this;
    }

    /**
     * Set a callback that will be called right before the request is sent. As input, the callback will receive the
     * protobuf of the request, and the callback should return the request protobuf.  This means the callback has an
     * opportunity to read, copy, or modify the request that will be sent.
     *
     * @param requestListener The callback to use
     * @return {@code this}
     */
    public final SdkRequestT setRequestListener(UnaryOperator<ProtoRequestT> requestListener) {
        this.requestListener = Objects.requireNonNull(requestListener);
        return (SdkRequestT) this;
    }

    /**
     * Set a callback that will be called right before the response is returned. As input, the callback will receive the
     * protobuf of the response, and the callback should return the response protobuf.  This means the callback has an
     * opportunity to read, copy, or modify the response that will be read.
     *
     * @param responseListener The callback to use
     * @return {@code this}
     */
    public final SdkRequestT setResponseListener(UnaryOperator<ResponseT> responseListener) {
        this.responseListener = Objects.requireNonNull(responseListener);
        return (SdkRequestT) this;
    }

    /**
     * Set the logger
     *
     * @param logger the new logger
     * @return {@code this}
     */
    public SdkRequestT setLogger(Logger logger) {
        this.logger = logger;
        return (SdkRequestT) this;
    }

    void checkNodeAccountIds() {
        if (nodeAccountIds.isEmpty()) {
            throw new IllegalStateException("Request node account IDs were not set before executing");
        }
    }

    abstract void onExecute(Client client) throws TimeoutException, PrecheckStatusException;

    abstract CompletableFuture<Void> onExecuteAsync(Client client);

    void mergeFromClient(Client client) {
        if (maxAttempts == null) {
            maxAttempts = client.getMaxAttempts();
        }

        if (maxBackoff == null) {
            maxBackoff = client.getMaxBackoff();
        }

        if (minBackoff == null) {
            minBackoff = client.getMinBackoff();
        }

        if (grpcDeadline == null) {
            grpcDeadline = client.getGrpcDeadline();
        }
    }

    private void delay(long delay) {
        if (delay <= 0) {
            return;
        }
        try {
            if (delay > 0) {
                if (logger.isEnabledForLevel(LogLevel.DEBUG)) {
                    logger.debug("Sleeping for: " + delay + " | Thread name: " + Thread.currentThread().getName());
                }
                Thread.sleep(delay);
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Execute this transaction or query
     *
     * @param client The client with which this will be executed.
     * @return Result of execution
     * @throws TimeoutException        when the transaction times out
     * @throws PrecheckStatusException when the precheck fails
     */
    public O execute(Client client) throws TimeoutException, PrecheckStatusException {
        return execute(client, client.getRequestTimeout());
    }

    /**
     * Execute this transaction or query with a timeout
     *
     * @param client  The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return Result of execution
     * @throws TimeoutException        when the transaction times out
     * @throws PrecheckStatusException when the precheck fails
     */
    public O execute(Client client, Duration timeout) throws TimeoutException, PrecheckStatusException {
        Throwable lastException = null;

        // If the logger on the request is not set, use the logger in client
        // (if set, otherwise do not use logger)
        if (this.logger == null) {
            this.logger = client.getLogger();
        }

        mergeFromClient(client);
        onExecute(client);
        checkNodeAccountIds();
        setNodesFromNodeAccountIds(client);

        var timeoutTime = Instant.now().plus(timeout);

        for (int attempt = 1; /* condition is done within loop */ ; attempt++) {
            if (attempt > maxAttempts) {
                throw new MaxAttemptsExceededException(lastException);
            }

            Duration currentTimeout = Duration.between(Instant.now(), timeoutTime);
            if (currentTimeout.isNegative() || currentTimeout.isZero()) {
                throw new TimeoutException();
            }

            GrpcRequest grpcRequest = new GrpcRequest(client.network, attempt, currentTimeout);
            Node node = grpcRequest.getNode();
            ResponseT response = null;

            // If we get an unhealthy node here, we've cycled through all the "good" nodes that have failed
            // and have no choice but to try a bad one.
            if (!node.isHealthy()) {
                delay(node.getRemainingTimeForBackoff());
            }

            if (node.channelFailedToConnect(timeoutTime)) {
                logger.trace("Failed to connect channel for node {} for request #{}", node.getAccountId(), attempt);
                lastException = grpcRequest.reactToConnectionFailure();
                continue;
            }

            currentTimeout = Duration.between(Instant.now(), timeoutTime);
            grpcRequest.setGrpcDeadline(currentTimeout);

            try {
                response = blockingUnaryCall.apply(grpcRequest);
                logTransaction(this.getTransactionIdInternal(), client, node, false, attempt, response, null);
            } catch (Throwable e) {
                if (e instanceof StatusRuntimeException) {
                    StatusRuntimeException statusRuntimeException = (StatusRuntimeException) e;
                    if (statusRuntimeException.getStatus().getCode().equals(Code.DEADLINE_EXCEEDED)) {
                        throw new TimeoutException();
                    }
                }
                lastException = e;
                logTransaction(this.getTransactionIdInternal(), client, node, false, attempt, null, e);
            }

            if (response == null) {
                if (grpcRequest.shouldRetryExceptionally(lastException)) {
                    continue;
                } else {
                    throw new RuntimeException(lastException);
                }
            }

            var status = mapResponseStatus(response);
            var executionState = getExecutionState(status, response);
            grpcRequest.handleResponse(response, status, executionState);

            switch (executionState) {
                case SERVER_ERROR:
                    lastException = grpcRequest.mapStatusException();
                    continue;
                case RETRY:
                    // Response is not ready yet from server, need to wait.
                    lastException = grpcRequest.mapStatusException();
                    if (attempt < maxAttempts) {
                        currentTimeout = Duration.between(Instant.now(), timeoutTime);
                        delay(Math.min(currentTimeout.toMillis(), grpcRequest.getDelay()));
                    }
                    continue;
                case REQUEST_ERROR:
                    throw grpcRequest.mapStatusException();
                case SUCCESS:
                default:
                    return grpcRequest.mapResponse();
            }
        }
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 31
     * because it uses features introduced in API level 31 (Android 12).</p>*
     *
     * @param client The client with which this will be executed.
     * @return Future result of execution
     */
    public CompletableFuture<O> executeAsync(Client client) {
        return executeAsync(client, client.getRequestTimeout());
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 31
     * because it uses features introduced in API level 31 (Android 12).</p>*
     *
     * @param client  The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return Future result of execution
     */
    public CompletableFuture<O> executeAsync(Client client, Duration timeout) {
        var retval = new CompletableFuture<O>().orTimeout(timeout.toMillis(), TimeUnit.MILLISECONDS);

        mergeFromClient(client);

        onExecuteAsync(client).thenRun(() -> {
            checkNodeAccountIds();
            setNodesFromNodeAccountIds(client);

            executeAsyncInternal(client, 1, null, retval, timeout);
        }).exceptionally(error -> {
            retval.completeExceptionally(error);
            return null;
        });
        return retval;
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client   The client with which this will be executed.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, BiConsumer<O, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client), callback);
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client   The client with which this will be executed.
     * @param timeout  The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, Duration timeout, BiConsumer<O, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client, timeout), callback);
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client    The client with which this will be executed.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Consumer<O> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client), onSuccess, onFailure);
    }

    /**
     * Execute this transaction or query asynchronously.
     *
     * @param client    The client with which this will be executed.
     * @param timeout   The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Duration timeout, Consumer<O> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client, timeout), onSuccess, onFailure);
    }

    /**
     * Logs the transaction's parameters
     *
     * @param transactionId the transaction's id
     * @param client        the client that executed the transaction
     * @param node          the node the transaction was sent to
     * @param isAsync       whether the transaction was executed asynchronously
     * @param attempt       the attempt number
     * @param response      the transaction response if the transaction was successful
     * @param error         the error if the transaction was not successful
     */
    protected void logTransaction(
        TransactionId transactionId,
        Client client,
        Node node,
        boolean isAsync,
        int attempt,
        @Nullable ResponseT response,
        @Nullable Throwable error) {

        if (!logger.isEnabledForLevel(LogLevel.TRACE)) {
            return;
        }

        logger.trace("Execute{} Transaction ID: {}, submit to {}, node: {}, attempt: {}",
            isAsync ? "Async" : "",
            transactionId,
            client.network,
            node.getAccountId(),
            attempt);

        if (response != null) {
            logger.trace(" - Response: {}", response);
        }

        if (error != null) {
            logger.trace(" - Error: {}", error.getMessage());
        }
    }

    @SuppressWarnings("java:S2245")
    @VisibleForTesting
    void setNodesFromNodeAccountIds(Client client) {
        nodes.clear();

        // When a single node is explicitly set we get all of its proxies so in case of
        // failure the system can retry with different proxy on each attempt
        if (nodeAccountIds.size() == 1) {
            var nodeProxies = client.network.getNodeProxies(nodeAccountIds.get(0));
            if (nodeProxies == null || nodeProxies.size() == 0) {
                throw new IllegalStateException("Account ID did not map to valid node in the client's network");
            }

            nodes.addAll(nodeProxies).shuffle();

            return;
        }

        // When multiple nodes are available the system retries with different node on each attempt
        // instead of different proxy of the same node
        for (var accountId : nodeAccountIds) {
            @Nullable
            var nodeProxies = client.network.getNodeProxies(accountId);
            if (nodeProxies == null || nodeProxies.size() == 0) {
                throw new IllegalStateException(
                    "Some node account IDs did not map to valid nodes in the client's network");
            }

            var node = nodeProxies.get(random.nextInt(nodeProxies.size()));

            nodes.add(Objects.requireNonNull(node));
        }
    }

    /**
     * Return the next node for execution. Will select the first node that is deemed healthy. If we cannot find such a
     * node and have tried n nodes (n being the size of the node list), we will select the node with the smallest
     * remaining delay. All delays MUST be executed in calling layer as this method will be called for sync + async
     * scenarios.
     */
    @VisibleForTesting
    Node getNodeForExecute(int attempt) {
        Node node = null;
        Node candidate = null;
        long smallestDelay = Long.MAX_VALUE;

        for (int _i = 0; _i < nodes.size(); _i++) {
            // NOTE: _i is NOT the index into this.nodes, it is just keeping track of how many times we've iterated.
            // In the event of ServerErrors, this method depends on the nodes list to have advanced to
            // the next node.
            node = nodes.getCurrent();

            if (!node.isHealthy()) {
                // Keep track of the node with the smallest delay seen thus far. If we go through the entire list
                // (meaning all nodes are unhealthy) then we will select the node with the smallest delay.
                long backoff = node.getRemainingTimeForBackoff();
                if (backoff < smallestDelay) {
                    candidate = node;
                    smallestDelay = backoff;
                }

                node = null;
                advanceRequest();
            } else {
                break; // got a good node, use it
            }
        }

        if (node == null) {
            node = candidate;

            // If we've tried all nodes, index will be +1 too far. Index increment happens outside
            // this method so try to be consistent with happy path.
            nodeAccountIds.setIndex(Math.max(0, nodeAccountIds.getIndex()));
        }

        // node won't be null at this point because execute() validates before this method is called.
        // Add null check here to work around sonar NPE detection.
        if (node != null && logger != null) {
            logger.trace("Using node {} for request #{}: {}", node.getAccountId(), attempt, this);
        }

        return node;
    }

    private ProtoRequestT getRequestForExecute() {
        var request = makeRequest();

        // advance the internal index
        // non-free queries and transactions map to more than 1 actual transaction and this will cause
        // the next invocation of makeRequest to return the _next_ transaction
        advanceRequest();

        return request;
    }

    private void executeAsyncInternal(
        Client client,
        int attempt,
        @Nullable Throwable lastException,
        CompletableFuture<O> returnFuture,
        Duration timeout
    ) {
        // If the logger on the request is not set, use the logger in client
        // (if set, otherwise do not use logger)
        if (this.logger == null && client.getLogger() != null) {
            this.logger = client.getLogger();
        }

        if (returnFuture.isCancelled() || returnFuture.isCompletedExceptionally() || returnFuture.isDone()) {
            return;
        }

        if (attempt > maxAttempts) {
            returnFuture.completeExceptionally(
                new CompletionException(new MaxAttemptsExceededException(lastException)));
            return;
        }

        var timeoutTime = Instant.now().plus(timeout);

        GrpcRequest grpcRequest = new GrpcRequest(client.network, attempt,
            Duration.between(Instant.now(), timeoutTime));

        Supplier<CompletableFuture<Void>> afterUnhealthyDelay = () -> {
            return grpcRequest.getNode().isHealthy() ?
                CompletableFuture.completedFuture((Void) null) :
                Delayer.delayFor(grpcRequest.getNode().getRemainingTimeForBackoff(), client.executor);
        };

        afterUnhealthyDelay.get().thenRun(() -> {
            grpcRequest.getNode().channelFailedToConnectAsync().thenAccept(connectionFailed -> {
                if (connectionFailed) {
                    var connectionException = grpcRequest.reactToConnectionFailure();
                    executeAsyncInternal(client, attempt + 1, connectionException, returnFuture,
                        Duration.between(Instant.now(), timeoutTime));
                    return;
                }

                toCompletableFuture(
                    ClientCalls.futureUnaryCall(grpcRequest.createCall(), grpcRequest.getRequest())).handle(
                    (response, error) -> {
                        logTransaction(this.getTransactionIdInternal(), client, grpcRequest.getNode(), true, attempt,
                            response, error);

                        if (grpcRequest.shouldRetryExceptionally(error)) {
                            // the transaction had a network failure reaching Hedera
                            executeAsyncInternal(client, attempt + 1, error, returnFuture,
                                Duration.between(Instant.now(), timeoutTime));
                            return null;
                        }

                        if (error != null) {
                            // not a network failure, some other weirdness going on; just fail fast
                            returnFuture.completeExceptionally(new CompletionException(error));
                            return null;
                        }

                        var status = mapResponseStatus(response);
                        var executionState = getExecutionState(status, response);
                        grpcRequest.handleResponse(response, status, executionState);

                        switch (executionState) {
                            case SERVER_ERROR:
                                executeAsyncInternal(client, attempt + 1, grpcRequest.mapStatusException(),
                                    returnFuture, Duration.between(Instant.now(), timeoutTime));
                                break;
                            case RETRY:
                                Delayer.delayFor((attempt < maxAttempts) ? grpcRequest.getDelay() : 0, client.executor)
                                    .thenRun(() -> executeAsyncInternal(client, attempt + 1,
                                        grpcRequest.mapStatusException(),
                                        returnFuture, Duration.between(Instant.now(), timeoutTime)));
                                break;
                            case REQUEST_ERROR:
                                returnFuture.completeExceptionally(
                                    new CompletionException(grpcRequest.mapStatusException()));
                                break;
                            case SUCCESS:
                            default:
                                returnFuture.complete(grpcRequest.mapResponse());
                        }
                        return null;
                    }).exceptionally(error -> {
                    returnFuture.completeExceptionally(error);
                    return null;
                });
            }).exceptionally(error -> {
                returnFuture.completeExceptionally(error);
                return null;
            });
        });
    }

    abstract ProtoRequestT makeRequest();

    GrpcRequest getGrpcRequest(int attempt) {
        return new GrpcRequest(null, attempt, this.grpcDeadline);
    }

    void advanceRequest() {
        if (nodeAccountIds.getIndex() + 1 == nodes.size() - 1) {
            attemptedAllNodes = true;
        }

        nodes.advance();
        if (nodeAccountIds.size() > 1) {
            nodeAccountIds.advance();
        }
    }

    /**
     * Called after receiving the query response from Hedera. The derived class should map into its output type.
     */
    abstract O mapResponse(ResponseT response, AccountId nodeId, ProtoRequestT request);

    abstract Status mapResponseStatus(ResponseT response);

    /**
     * Called to direct the invocation of the query to the appropriate gRPC service.
     */
    abstract MethodDescriptor<ProtoRequestT, ResponseT> getMethodDescriptor();

    @Nullable
    abstract TransactionId getTransactionIdInternal();

    boolean shouldRetryExceptionally(@Nullable Throwable error) {
        if (error instanceof StatusRuntimeException statusException) {
            var status = statusException.getStatus().getCode();
            var description = statusException.getStatus().getDescription();

            return (status == Code.UNAVAILABLE) ||
                (status == Code.RESOURCE_EXHAUSTED) ||
                (status == Code.INTERNAL && description != null && RST_STREAM.matcher(description).matches());
        }

        return false;
    }

    /**
     * Default implementation, may be overridden in subclasses (especially for query case). Called just after receiving
     * the query response from Hedera. By default it triggers a retry when the pre-check status is {@code BUSY}.
     */
    ExecutionState getExecutionState(Status status, ResponseT response) {
        switch (status) {
            case PLATFORM_TRANSACTION_NOT_CREATED:
            case PLATFORM_NOT_ACTIVE:
                return ExecutionState.SERVER_ERROR;
            case BUSY:
                return ExecutionState.RETRY;
            case OK:
                return ExecutionState.SUCCESS;
            default:
                return ExecutionState.REQUEST_ERROR;     // user error
        }
    }

    @VisibleForTesting
    class GrpcRequest {
        @Nullable
        private final Network network;
        private final Node node;
        private final int attempt;
        //private final ClientCall<ProtoRequestT, ResponseT> call;
        private final ProtoRequestT request;
        private final long startAt;
        private final long delay;
        private Duration grpcDeadline;
        private ResponseT response;
        private double latency;
        private Status responseStatus;

        GrpcRequest(@Nullable Network network, int attempt, Duration grpcDeadline) {
            this.network = network;
            this.attempt = attempt;
            this.grpcDeadline = grpcDeadline;
            this.node = getNodeForExecute(attempt);
            this.request = getRequestForExecute(); // node index gets incremented here
            this.startAt = System.nanoTime();

            // Exponential back-off for Delayer: 250ms, 500ms, 1s, 2s, 4s, 8s, ... 8s
            delay = (long) Math.min(Objects.requireNonNull(minBackoff).toMillis() * Math.pow(2, attempt - 1.0),
                Objects.requireNonNull(maxBackoff).toMillis());
        }

        public CallOptions getCallOptions() {
            long deadline = Math.min(
                this.grpcDeadline.toMillis(),
                Executable.this.grpcDeadline.toMillis());

            return CallOptions.DEFAULT.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);
        }

        public void setGrpcDeadline(Duration grpcDeadline) {
            this.grpcDeadline = grpcDeadline;
        }

        public Node getNode() {
            return node;
        }

        public ClientCall<ProtoRequestT, ResponseT> createCall() {
            verboseLog(node);
            return this.node.getChannel().newCall(Executable.this.getMethodDescriptor(), getCallOptions());
        }

        public ProtoRequestT getRequest() {
            return Executable.this.requestListener.apply(request);
        }

        public long getDelay() {
            return delay;
        }

        Throwable reactToConnectionFailure() {
            Objects.requireNonNull(network).increaseBackoff(node);
            logger.warn("Retrying in {} ms after channel connection failure with node {} during attempt #{}",
                node.getRemainingTimeForBackoff(), node.getAccountId(), attempt);
            verboseLog(node);
            return new IllegalStateException("Failed to connect to node " + node.getAccountId());
        }

        boolean shouldRetryExceptionally(@Nullable Throwable e) {
            latency = (double) (System.nanoTime() - startAt) / 1000000000.0;

            var retry = Executable.this.shouldRetryExceptionally(e);

            if (retry) {
                Objects.requireNonNull(network).increaseBackoff(node);
                logger.warn("Retrying in {} ms after failure with node {} during attempt #{}: {}",
                    node.getRemainingTimeForBackoff(), node.getAccountId(), attempt,
                    e != null ? e.getMessage() : "NULL");
                verboseLog(node);
            }

            return retry;
        }

        PrecheckStatusException mapStatusException() {
            // request to hedera failed in a non-recoverable way
            return new PrecheckStatusException(responseStatus, Executable.this.getTransactionIdInternal());
        }

        O mapResponse() {
            // successful response from Hedera
            return Executable.this.mapResponse(response, node.getAccountId(), request);
        }

        void handleResponse(ResponseT response, Status status, ExecutionState executionState) {
            node.decreaseBackoff();

            this.response = Executable.this.responseListener.apply(response);
            this.responseStatus = status;

            logger.trace("Received {} response in {} s from node {} during attempt #{}: {}",
                responseStatus, latency, node.getAccountId(), attempt, response);

            if (executionState == ExecutionState.SERVER_ERROR && attemptedAllNodes) {
                executionState = ExecutionState.RETRY;
                attemptedAllNodes = false;
            }
            switch (executionState) {
                case RETRY -> {
                    logger.warn("Retrying in {} ms after failure with node {} during attempt #{}: {}",
                        delay, node.getAccountId(), attempt, responseStatus);
                    verboseLog(node);
                }
                case SERVER_ERROR ->
                    logger.warn("Problem submitting request to node {} for attempt #{}, retry with new node: {}",
                        node.getAccountId(), attempt, responseStatus);
                default -> {
                }
            }
        }

        void verboseLog(Node node) {
            String ipAddress;
            if (node.address == null) {
                ipAddress = "NULL";
            } else if (node.address.getAddress() == null) {
                ipAddress = "NULL";
            } else {
                ipAddress = node.address.getAddress();
            }
            logger.trace("Node IP {} Timestamp {} Transaction Type {}",
                ipAddress,
                System.currentTimeMillis(),
                this.getClass().getSimpleName()
            );
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ExecutionState.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Enum for the execution states.
 */
public enum ExecutionState {
    /**
     * Indicates that the execution was successful
     */
    SUCCESS,
    /**
     * Indicates that the call was successful but the operation did not complete. Retry with same/new node
     */
    RETRY,
    /**
     * Indicates that the receiver was bad node. Retry with new node
     */
    SERVER_ERROR,
    /**
     * Indicates that the request was incorrect
     */
    REQUEST_ERROR
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FeeAssessmentMethod.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Enum for the fee assessment method.
 * <p>
 * The terminology here (exclusive vs inclusive) is borrowed from tax assessment.
 */
public enum FeeAssessmentMethod {

    /**
     * If Alice is paying Bob, and an <b>inclusive</b> fractional fee is collected to be sent to Charlie,
     * the amount Alice declares she will pay in the transfer transaction <b>includes</b> the fee amount.
     * <p>
     * In other words, Bob receives the amount that Alice intended to send, minus the fee.
     */
    INCLUSIVE(false),
    /**
     * If Alice is paying Bob, and an <b>exclusive</b> fractional fee is collected to be sent to Charlie,
     * the amount Alice declares she will pay in the transfer transaction <b>does not</b> include the fee amount.
     * <p>
     * In other words, Alice is charged the fee <b>in addition to</b> the amount she intended to send to Bob.
     */
    EXCLUSIVE(true);

    final boolean code;

    FeeAssessmentMethod(boolean code) {
        this.code = code;
    }

    static FeeAssessmentMethod valueOf(boolean code) {
        return code ? EXCLUSIVE : INCLUSIVE;
    }

    @Override
    public String toString() {
        return code ? "EXCLUSIVE" : "INCLUSIVE";
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FeeComponents.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

/**
 * Utility class used internally by the sdk.
 */
public class FeeComponents implements Cloneable {
    /**
     * A minimum, the calculated fee must be greater than this value
     */
    private long min;
    /**
     * A maximum, the calculated fee must be less than this value
     */
    private long max;
    /**
     * A constant contribution to the fee
     */
    private long constant;
    /**
     * The price of bandwidth consumed by a transaction, measured in bytes
     */
    private long transactionBandwidthByte;
    /**
     * The price per signature verification for a transaction
     */
    private long transactionVerification;
    /**
     * The price of RAM consumed by a transaction, measured in byte-hours
     */
    private long transactionRamByteHour;
    /**
     * The price of storage consumed by a transaction, measured in byte-hours
     */
    private long transactionStorageByteHour;
    /**
     * The price of computation for a smart contract transaction, measured in gas
     */
    private long contractTransactionGas;
    /**
     * The price per hbar transferred for a transfer
     */
    private long transferVolumeHbar;
    /**
     * The price of bandwidth for data retrieved from memory for a response, measured in bytes
     */
    private long responseMemoryByte;
    /**
     * The price of bandwidth for data retrieved from disk for a response, measured in bytes
     */
    private long responseDiskByte;

    /**
     * Constructor.
     */
    public FeeComponents() {
    }

    /**
     * Create a fee components object from a protobuf.
     *
     * @param feeComponents             the protobuf
     * @return                          the fee component object
     */
    static FeeComponents fromProtobuf(com.hedera.hashgraph.sdk.proto.FeeComponents feeComponents) {
        return new FeeComponents()
            .setMin(feeComponents.getMin())
            .setMax(feeComponents.getMax())
            .setConstant(feeComponents.getConstant())
            .setTransactionBandwidthByte(feeComponents.getBpt())
            .setTransactionVerification(feeComponents.getVpt())
            .setTransactionRamByteHour(feeComponents.getRbh())
            .setTransactionStorageByteHour(feeComponents.getSbh())
            .setContractTransactionGas(feeComponents.getGas())
            .setTransferVolumeHbar(feeComponents.getTv())
            .setResponseMemoryByte(feeComponents.getBpr())
            .setResponseDiskByte(feeComponents.getSbpr());
    }

    /**
     * Create a fee component object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the fee component object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static FeeComponents fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.FeeComponents.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the minimum component.
     *
     * @return                          the minimum component
     */
    public long getMin() {
        return min;
    }

    /**
     * Assign the minimum component.
     *
     * @param min                       the minimum component
     * @return {@code this}
     */
    public FeeComponents setMin(long min) {
        this.min = min;
        return this;
    }

    /**
     * Extract the maximum component.
     *
     * @return                          the maximum component
     */
    public long getMax() {
        return max;
    }

    /**
     * Assign the maximum component.
     *
     * @param max                       the maximum component
     * @return {@code this}
     */
    public FeeComponents setMax(long max) {
        this.max = max;
        return this;
    }

    /**
     * Extract the constant component.
     *
     * @return                          the constant component
     */
    public long getConstant() {
        return constant;
    }

    /**
     * Assign the constant component.
     *
     * @param constant                  the constant component
     * @return {@code this}
     */
    public FeeComponents setConstant(long constant) {
        this.constant = constant;
        return this;
    }

    /**
     * Extract the transaction bandwidth bytes.
     *
     * @return                          the transaction bandwidth bytes
     */
    public long getTransactionBandwidthByte() {
        return transactionBandwidthByte;
    }

    /**
     * Assign the transaction bandwidth bytes.
     *
     * @param transactionBandwidthByte  the transaction bandwidth bytes
     * @return {@code this}
     */
    public FeeComponents setTransactionBandwidthByte(long transactionBandwidthByte) {
        this.transactionBandwidthByte = transactionBandwidthByte;
        return this;
    }

    /**
     * Extract the transaction verification price per signature.
     *
     * @return                          the transaction verification price per signature
     */
    public long getTransactionVerification() {
        return transactionVerification;
    }

    /**
     * Assign the transaction verification price per signature.
     *
     * @param transactionVerification   the transaction verification price per signature
     * @return {@code this}
     */
    public FeeComponents setTransactionVerification(long transactionVerification) {
        this.transactionVerification = transactionVerification;
        return this;
    }

    /**
     * Extract the of ram consumed in byte hours.
     *
     * @return                          price of ram consumed in byte hours
     */
    public long getTransactionRamByteHour() {
        return transactionRamByteHour;
    }

    /**
     * Assign the price of ram consumed in byte hours.
     *
     * @param transactionRamByteHour    price of ram consumed in byte hours
     * @return {@code this}
     */
    public FeeComponents setTransactionRamByteHour(long transactionRamByteHour) {
        this.transactionRamByteHour = transactionRamByteHour;
        return this;
    }

    /**
     * Extract the of storage in byte hours.
     *
     * @return                          price of storage in byte hours
     */
    public long getTransactionStorageByteHour() {
        return transactionStorageByteHour;
    }

    /**
     * Assign the price of storage consumed in byte hours.
     *
     * @param transactionStorageByteHour    price of storage in byte hours
     * @return {@code this}
     */
    public FeeComponents setTransactionStorageByteHour(long transactionStorageByteHour) {
        this.transactionStorageByteHour = transactionStorageByteHour;
        return this;
    }

    /**
     * Extract the of gas for computation.
     *
     * @return                          price of gas for computation
     */
    public long getContractTransactionGas() {
        return contractTransactionGas;
    }

    /**
     * Assign the price of computation in gas.
     *
     * @param contractTransactionGas    price of gas for computation
     * @return {@code this}
     */
    public FeeComponents setContractTransactionGas(long contractTransactionGas) {
        this.contractTransactionGas = contractTransactionGas;
        return this;
    }

    /**
     * Extract the per hbar transferred.
     *
     * @return                          price per hbar transferred
     */
    public long getTransferVolumeHbar() {
        return transferVolumeHbar;
    }

    /**
     * Assign the price per hbar transferred.
     *
     * @param transferVolumeHbar        price per hbar transferred
     * @return {@code this}
     */
    public FeeComponents setTransferVolumeHbar(long transferVolumeHbar) {
        this.transferVolumeHbar = transferVolumeHbar;
        return this;
    }

    /**
     * Extract the for data retrieved.
     *
     * @return                          price for data retrieved
     */
    public long getResponseMemoryByte() {
        return responseMemoryByte;
    }

    /**
     * Assign the price for data retrieved in bytes.
     *
     * @param responseMemoryByte        price for data retrieved
     * @return {@code this}
     */
    public FeeComponents setResponseMemoryByte(long responseMemoryByte) {
        this.responseMemoryByte = responseMemoryByte;
        return this;
    }

    /**
     * Extract the for data retrieved from disk.
     *
     * @return                          price for data retrieved from disk
     */
    public long getResponseDiskByte() {
        return responseDiskByte;
    }

    /**
     * Assign the price for data retrieved from disk.
     *
     * @param responseDiskByte          price for data retrieved from disk
     * @return {@code this}
     */
    public FeeComponents setResponseDiskByte(long responseDiskByte) {
        this.responseDiskByte = responseDiskByte;
        return this;
    }

    /**
     * Convert fee component object to protobuf.
     *
     * @return                          the protobuf
     */
    com.hedera.hashgraph.sdk.proto.FeeComponents toProtobuf() {
        return com.hedera.hashgraph.sdk.proto.FeeComponents.newBuilder()
            .setMin(getMin())
            .setMax(getMax())
            .setConstant(getConstant())
            .setBpt(getTransactionBandwidthByte())
            .setVpt(getTransactionVerification())
            .setRbh(getTransactionRamByteHour())
            .setSbh(getTransactionStorageByteHour())
            .setGas(getContractTransactionGas())
            .setTv(getTransferVolumeHbar())
            .setBpr(getResponseMemoryByte())
            .setSbpr(getResponseDiskByte())
            .build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("min", getMin())
            .add("max", getMax())
            .add("constant", getConstant())
            .add("transactionBandwidthByte", getTransactionBandwidthByte())
            .add("transactionVerification", getTransactionVerification())
            .add("transactionRamByteHour", getTransactionRamByteHour())
            .add("transactionStorageByteHour", getTransactionStorageByteHour())
            .add("contractTransactionGas", getContractTransactionGas())
            .add("transferVolumeHbar", getTransferVolumeHbar())
            .add("responseMemoryByte", getResponseMemoryByte())
            .add("responseDiskByte", getResponseDiskByte())
            .toString();
    }

    /**
     * Convert fee component object to byte array.
     *
     * @return                          the byte array
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public FeeComponents clone() {
        try {
            return (FeeComponents) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FeeData.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

import javax.annotation.Nullable;

/**
 * The total fees charged for a transaction. It contains three parts namely
 * node data, network data and service data.
 */
public class FeeData implements Cloneable {
    @Nullable
    private FeeComponents nodeData = null;
    @Nullable
    private FeeComponents networkData = null;
    @Nullable
    private FeeComponents serviceData = null;
    private FeeDataType type = FeeDataType.DEFAULT;

    /**
     * Constructor.
     */
    public FeeData() {
    }

    /**
     * Initialize fee data object from a protobuf.
     *
     * @param feeData                   the protobuf
     * @return                          the fee data object
     */
    static FeeData fromProtobuf(com.hedera.hashgraph.sdk.proto.FeeData feeData) {
        return new FeeData()
            .setNodeData(feeData.hasNodedata() ? FeeComponents.fromProtobuf(feeData.getNodedata()) : null)
            .setNetworkData(feeData.hasNetworkdata() ? FeeComponents.fromProtobuf(feeData.getNetworkdata()) : null)
            .setServiceData(feeData.hasNodedata() ? FeeComponents.fromProtobuf(feeData.getServicedata()) : null)
            .setType(FeeDataType.valueOf(feeData.getSubType()));
    }

    /**
     * Initialize fee data object from byte array.
     *
     * @param bytes                     the byte array
     * @return                          the fee data object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static FeeData fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.FeeData.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the node data.
     *
     * @return                          the node data fee components object
     */
    @Nullable
    FeeComponents getNodeData() {
        return nodeData;
    }

    /**
     * Assign the node data fee component object.
     *
     * @param nodeData                  the node data fee component object
     * @return {@code this}
     */
    FeeData setNodeData(@Nullable FeeComponents nodeData) {
        this.nodeData = nodeData;
        return this;
    }

    /**
     * Extract the network data.
     *
     * @return                          the network data fee component object
     */
    @Nullable
    FeeComponents getNetworkData() {
        return networkData;
    }

    /**
     * Assign the network data fee component object.
     *
     * @param networkData               the network data fee component object
     * @return {@code this}
     */
    FeeData setNetworkData(@Nullable FeeComponents networkData) {
        this.networkData = networkData;
        return this;
    }

    /**
     * Extract the service data.
     *
     * @return                          the service data fee component object
     */
    @Nullable
    FeeComponents getServiceData() {
        return serviceData;
    }

    /**
     * Assign the service data fee component object.
     *
     * @param serviceData               the service data fee component object
     * @return {@code this}
     */
    FeeData setServiceData(@Nullable FeeComponents serviceData) {
        this.serviceData = serviceData;
        return this;
    }

    /**
     * Extract the fee data type.
     *
     * @return                          the fee data type
     */
    FeeDataType getType() {
        return type;
    }

    /**
     * Assign the fee data type.
     * {@link com.hedera.hashgraph.sdk.FeeDataType}
     *
     * @param type                      the fee data type
     * @return {@code this}
     */
    FeeData setType(FeeDataType type) {
        this.type = type;
        return this;
    }

    /**
     * Convert the fee data type into a protobuf.
     *
     * @return                          the protobuf
     */
    com.hedera.hashgraph.sdk.proto.FeeData toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.FeeData.newBuilder().setSubType(type.code);
        if (nodeData != null) {
            builder.setNodedata(nodeData.toProtobuf());
        }
        if (networkData != null) {
            builder.setNetworkdata(networkData.toProtobuf());
        }
        if (serviceData != null) {
            builder.setServicedata(serviceData.toProtobuf());
        }
        return builder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("nodeData", getNodeData())
            .add("networkData", getNetworkData())
            .add("serviceData", getServiceData())
            .add("type", getType())
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          a byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public FeeData clone() {
        try {
            FeeData clone = (FeeData) super.clone();
            clone.nodeData = nodeData != null ? nodeData.clone() : null;
            clone.networkData = networkData != null ? networkData.clone() : null;
            clone.serviceData = serviceData != null ? serviceData.clone() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FeeDataType.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SubType;

/**
 * Enum for the fee data types.
 */
public enum FeeDataType {
    /**
     * The resource prices have no special scope
     */
    DEFAULT(SubType.DEFAULT),

    /**
     * The resource prices are scoped to an operation on a fungible common token
     */
    TOKEN_FUNGIBLE_COMMON(SubType.TOKEN_FUNGIBLE_COMMON),

    /**
     * The resource prices are scoped to an operation on a non-fungible unique token
     */
    TOKEN_NON_FUNGIBLE_UNIQUE(SubType.TOKEN_NON_FUNGIBLE_UNIQUE),

    /**
     * The resource prices are scoped to an operation on a fungible common
     * token with a custom fee schedule
     */
    TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES(SubType.TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES),

    /**
     * The resource prices are scoped to an operation on a non-fungible unique
     * token with a custom fee schedule
     */
    TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES(SubType.TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES),

    /**
     * The resource prices are scoped to a ScheduleCreate containing a ContractCall.
     */
    SCHEDULE_CREATE_CONTRACT_CALL(SubType.SCHEDULE_CREATE_CONTRACT_CALL);


    final SubType code;

    FeeDataType(SubType code) {
        this.code = code;
    }

    static FeeDataType valueOf(SubType code) {
        return switch (code) {
            case DEFAULT -> DEFAULT;
            case TOKEN_FUNGIBLE_COMMON -> TOKEN_FUNGIBLE_COMMON;
            case TOKEN_NON_FUNGIBLE_UNIQUE -> TOKEN_NON_FUNGIBLE_UNIQUE;
            case TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES -> TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES;
            case TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES -> TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES;
            case SCHEDULE_CREATE_CONTRACT_CALL -> SCHEDULE_CREATE_CONTRACT_CALL;
            default -> throw new IllegalStateException("(BUG) unhandled SubType (FeeDataType)");
        };
    }

    @Override
    public String toString() {
        return switch (this) {
            case DEFAULT -> "DEFAULT";
            case TOKEN_FUNGIBLE_COMMON -> "TOKEN_FUNGIBLE_COMMON";
            case TOKEN_NON_FUNGIBLE_UNIQUE -> "TOKEN_NON_FUNGIBLE_UNIQUE";
            case TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES -> "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES";
            case TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES -> "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES";
            case SCHEDULE_CREATE_CONTRACT_CALL -> "SCHEDULE_CREATE_CONTRACT_CALL";
        };
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FeeSchedule.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * The fee schedule for a specific hedera functionality and the time period this fee schedule will expire.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/feeschedule">Hedera Documentation</a>
 */
public class FeeSchedule implements Cloneable {
    private List<TransactionFeeSchedule> transactionFeeSchedules = new ArrayList<>();
    @Nullable
    private Instant expirationTime;

    /**
     * Constructor.
     */
    public FeeSchedule() {
    }

    /**
     * Create a fee schedule from a protobuf.
     *
     * @param feeSchedule               the protobuf
     * @return                          the fee schedule
     */
    static FeeSchedule fromProtobuf(com.hedera.hashgraph.sdk.proto.FeeSchedule feeSchedule) {
        FeeSchedule returnFeeSchedule = new FeeSchedule()
            .setExpirationTime(feeSchedule.hasExpiryTime() ? InstantConverter.fromProtobuf(feeSchedule.getExpiryTime()) : null);
        for (var transactionFeeSchedule : feeSchedule.getTransactionFeeScheduleList()) {
            returnFeeSchedule
                .addTransactionFeeSchedule(TransactionFeeSchedule.fromProtobuf(transactionFeeSchedule));
        }
        return returnFeeSchedule;
    }

    /**
     * Create a fee schedule from byte array.
     *
     * @param bytes                     the bye array
     * @return                          the fee schedule
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static FeeSchedule fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.FeeSchedule.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the of transaction fee schedules.
     *
     * @return                          list of transaction fee schedules
     */
    public List<TransactionFeeSchedule> getTransactionFeeSchedules() {
        return Collections.unmodifiableList(cloneTransactionFeeSchedules(transactionFeeSchedules));
    }

    static List<TransactionFeeSchedule> cloneTransactionFeeSchedules(List<TransactionFeeSchedule> schedules) {
        List<TransactionFeeSchedule> cloneSchedules = new ArrayList<>(schedules.size());
        for (var schedule : schedules) {
            cloneSchedules.add(schedule.clone());
        }
        return cloneSchedules;
    }

    /**
     * Assign the list of transaction fee schedules.
     *
     * @param transactionFeeSchedules   list of transaction fee schedules
     * @return {@code this}
     */
    public FeeSchedule setTransactionFeeSchedules(List<TransactionFeeSchedule> transactionFeeSchedules) {
        this.transactionFeeSchedules = cloneTransactionFeeSchedules(Objects.requireNonNull(transactionFeeSchedules));
        return this;
    }

    /**
     * Add a transaction fee schedule.
     *
     * @param transactionFeeSchedule    transaction fee schedule to add
     * @return {@code this}
     */
    public FeeSchedule addTransactionFeeSchedule(TransactionFeeSchedule transactionFeeSchedule) {
        transactionFeeSchedules.add(Objects.requireNonNull(transactionFeeSchedule));
        return this;
    }

    /**
     * Extract the expiration time.
     *
     * @return                          the expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Assign the expiration time.
     *
     * @param expirationTime            the expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public FeeSchedule setExpirationTime(@Nullable Instant expirationTime) {
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Convert to a protobuf.
     *
     * @return                          the protobuf
     */
    com.hedera.hashgraph.sdk.proto.FeeSchedule toProtobuf() {
        var returnBuilder = com.hedera.hashgraph.sdk.proto.FeeSchedule.newBuilder();
        if (expirationTime != null) {
            returnBuilder.setExpiryTime(InstantConverter.toSecondsProtobuf(expirationTime));
        }
        for (TransactionFeeSchedule tFeeSchedule : getTransactionFeeSchedules()) {
            returnBuilder.addTransactionFeeSchedule(tFeeSchedule.toProtobuf());
        }
        return returnBuilder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("transactionFeeSchedules", getTransactionFeeSchedules())
            .add("expirationTime", getExpirationTime())
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          a byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public FeeSchedule clone() {
        try {
            FeeSchedule clone = (FeeSchedule) super.clone();
            clone.transactionFeeSchedules = cloneTransactionFeeSchedules(transactionFeeSchedules);
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FeeSchedules.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CurrentAndNextFeeSchedule;

import javax.annotation.Nullable;

/**
 * This contains two Fee Schedules with expiry timestamp.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/currentandnextfeeschedule">Hedera Documentation</a>
 */
public class FeeSchedules {
    @Nullable
    private FeeSchedule current;
    @Nullable
    private FeeSchedule next;

    /**
     * Constructor.
     */
    public FeeSchedules() {
        current = next = null;
    }

    /**
     * Create a fee schedules object from a protobuf.
     *
     * @param feeSchedules              the protobuf
     * @return                          the fee schedules object
     */
    static FeeSchedules fromProtobuf(CurrentAndNextFeeSchedule feeSchedules) {
        return new FeeSchedules()
            .setCurrent(feeSchedules.hasCurrentFeeSchedule() ? FeeSchedule.fromProtobuf(feeSchedules.getCurrentFeeSchedule()) : null)
            .setNext(feeSchedules.hasNextFeeSchedule() ? FeeSchedule.fromProtobuf(feeSchedules.getNextFeeSchedule()) : null);
    }

    /**
     * Create a fee schedules object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the fee schedules object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static FeeSchedules fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(CurrentAndNextFeeSchedule.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the current fee schedule.
     *
     * @return                          the current fee schedule
     */
    @Nullable
    public FeeSchedule getCurrent() {
        return current != null ? current.clone() : null;
    }

    /**
     * Assign the current fee schedule.
     *
     * @param current                   the fee schedule
     * @return {@code this}
     */
    public FeeSchedules setCurrent(@Nullable FeeSchedule current) {
        this.current = current != null ? current.clone() : null;
        return this;
    }

    /**
     * Extract the next fee schedule.
     *
     * @return                          the next fee schedule
     */
    @Nullable
    public FeeSchedule getNext() {
        return next != null ? next.clone() : null;
    }

    /**
     * Assign the next fee schedule.
     *
     * @param next                      the fee schedule
     * @return {@code this}
     */
    public FeeSchedules setNext(@Nullable FeeSchedule next) {
        this.next = next != null ? next.clone() : null;
        return this;
    }

    /**
     * Create the protobuf.
     *
     * @return                          protobuf representation
     */
    CurrentAndNextFeeSchedule toProtobuf() {
        var returnBuilder = CurrentAndNextFeeSchedule.newBuilder();
        if (current != null) {
            returnBuilder.setCurrentFeeSchedule(current.toProtobuf());
        }
        if (next != null) {
            returnBuilder.setNextFeeSchedule(next.toProtobuf());
        }
        return returnBuilder.build();
    }

    /**
     * Create the byte array.
     *
     * @return                          byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("current", getCurrent())
            .add("next", getNext())
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileAppendTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileAppendTransactionBody;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * <p>A transaction specifically to append data to a file on the network.
 *
 * <p>If a file has multiple keys, all keys must sign to modify its contents.
 * (See {@link FileCreateTransaction#setKeys(Key...)} for more information.)
 */
public final class FileAppendTransaction extends ChunkedTransaction<FileAppendTransaction> {
    static int DEFAULT_CHUNK_SIZE = 4096;

    @Nullable
    private FileId fileId = null;

    /**
     * Constructor.
     */
    public FileAppendTransaction() {
        super();

        defaultMaxTransactionFee = new Hbar(5);
        setChunkSize(2048);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    FileAppendTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);

        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    FileAppendTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * <p>Set the ID of the file to append to. Required.
     *
     * @param fileId the ID of the file to append to.
     * @return {@code this}
     */
    public FileAppendTransaction setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        requireNotFrozen();
        this.fileId = fileId;
        return this;
    }

    /**
     * Extract the byte string representing the file.
     *
     * @return                          the byte string representing the file
     */
    @Nullable
    public ByteString getContents() {
        return getData();
    }

    /**
     * <p>Set the contents to append to the file as identified by {@link #setFileId(FileId)}.
     *
     * @param contents the contents to append to the file.
     * @return {@code this}
     * @see #setContents(String) for an overload which takes {@link String}.
     */
    public FileAppendTransaction setContents(byte[] contents) {
        return setData(contents);
    }

    /**
     * <p>Set the contents to append to the file as identified by {@link #setFileId(FileId)}.
     *
     * @param contents the contents to append to the file.
     * @return {@code this}
     * @see #setContents(String) for an overload which takes {@link String}.
     */
    public FileAppendTransaction setContents(ByteString contents) {
        return setData(contents);
    }


    /**
     * <p>Encode the given {@link String} as UTF-8 and append it to file as identified by
     * {@link #setFileId(FileId)}.
     *
     * <p>If the whole file is UTF-8 encoded, the string can later be recovered from
     * {@link FileContentsQuery#execute(Client)} via
     * {@link String#String(byte[], java.nio.charset.Charset)} using
     * {@link java.nio.charset.StandardCharsets#UTF_8}.
     *
     * @param text The String to be set as the contents of the file
     * @return {@code this}
     * @see #setContents(byte[]) for appending arbitrary data.
     */
    public FileAppendTransaction setContents(String text) {
        return setData(text);
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return FileServiceGrpc.getAppendContentMethod();
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getFileAppend();
        if (body.hasFileID()) {
            fileId = FileId.fromProtobuf(body.getFileID());
        }

        if (!innerSignedTransactions.isEmpty()) {
            try {
                for (var i = 0; i < innerSignedTransactions.size();
                    i += nodeAccountIds.isEmpty() ? 1 : nodeAccountIds.size()) {
                    data = data.concat(
                        TransactionBody.parseFrom(innerSignedTransactions.get(i).getBodyBytes())
                            .getFileAppend().getContents()
                    );
                }
            } catch (InvalidProtocolBufferException exc) {
                throw new IllegalArgumentException(exc.getMessage());
            }
        } else {
            data = body.getContents();
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.FileAppendTransactionBody builder}
     */
    FileAppendTransactionBody.Builder build() {
        var builder = FileAppendTransactionBody.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }
        builder.setContents(data);

        return builder;
    }

    @Override
    void onFreezeChunk(TransactionBody.Builder body, @Nullable TransactionID initialTransactionId, int startIndex, int endIndex, int chunk, int total) {
        body.setFileAppend(build().setContents(data.substring(startIndex, endIndex)));
    }

    @Override
    boolean shouldGetReceipt() {
        return true;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setFileAppend(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setFileAppend(build().setContents(data));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileContentsQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.FileGetContentsQuery;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Get the contents of a file. The content field is empty (no bytes) if the
 * file is empty.
 *
 * A query to get the contents of a file. Queries do not change the state of
 * the file or require network consensus. The information is returned from a
 * single node processing the query.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/file-storage/get-file-contents">Hedera Documentation</a>
 */
public final class FileContentsQuery extends Query<ByteString, FileContentsQuery> {

    @Nullable
    private FileId fileId = null;

    /**
     * Constructor.
     */
    public FileContentsQuery() {
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * Sets the file ID of the file whose contents are requested.
     *
     * @param fileId The FileId to be set
     * @return {@code this}
     */
    public FileContentsQuery setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        this.fileId = fileId;
        return this;
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `FILE_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = FileGetContentsQuery.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }

        queryBuilder.setFileGetContents(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getFileGetContents().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getFileGetContents().getHeader();
    }

    @Override
    ByteString mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return response.getFileGetContents().getFileContents().getContents();
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return FileServiceGrpc.getGetFileContentMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Instant;

import javax.annotation.Nullable;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Creates a file with the content by submitting the transaction.
 *
 * See <a href="https://docs.hedera.com/guides/getting-started/try-examples/deploy-a-contract-using-the-hedera-token-service#2.-store-the-smart-contract-bytecode-on-hedera">Hedera Documentation</a>
 */
public final class FileCreateTransaction extends Transaction<FileCreateTransaction> {

    @Nullable
    private Instant expirationTime = null;
    @Nullable
    private KeyList keys = null;
    private byte[] contents = {};
    private String fileMemo = "";

    /**
     * Constructor.
     */
    public FileCreateTransaction() {
        setExpirationTime(Instant.now().plus(DEFAULT_AUTO_RENEW_PERIOD));
        defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    FileCreateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    FileCreateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the time.
     *
     * @return                          expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * <p>Set the instant at which this file will expire, after which its contents will no longer be
     * available.
     *
     * <p>Defaults to 1/4 of a Julian year from the instant {@link #FileCreateTransaction()}
     * was invoked.
     *
     * <p>May be extended using {@link FileUpdateTransaction#setExpirationTime(Instant)}.
     *
     * @param expirationTime the {@link Instant} at which this file should expire.
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public FileCreateTransaction setExpirationTime(Instant expirationTime) {
        requireNotFrozen();
        Objects.requireNonNull(expirationTime);
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Extract the of keys.
     *
     * @return                          list of keys
     */
    @Nullable
    public Collection<Key> getKeys() {
        return keys != null ? Collections.unmodifiableCollection(keys) : null;
    }

    /**
     * <p>Set the keys which must sign any transactions modifying this file. Required.
     *
     * <p>All keys must sign to modify the file's contents or keys. No key is required
     * to sign for extending the expiration time (except the one for the operator account
     * paying for the transaction). Only one key must sign to delete the file, however.
     *
     * <p>To require more than one key to sign to delete a file, add them to a
     * {@link com.hedera.hashgraph.sdk.KeyList} and pass that here.
     *
     * <p>The network currently requires a file to have at least one key (or key list or threshold key)
     * but this requirement may be lifted in the future.
     *
     * @param keys The Key or Keys to be set
     * @return {@code this}
     */
    public FileCreateTransaction setKeys(Key... keys) {
        requireNotFrozen();
        this.keys = KeyList.of(keys);
        return this;
    }

    /**
     * Create the byte string.
     *
     * @return                          byte string representation
     */
    public ByteString getContents() {
        return ByteString.copyFrom(contents);
    }

    /**
     * <p>Set the given byte array as the file's contents.
     *
     * <p>This may be omitted to create an empty file.
     *
     * <p>Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a {@link PrecheckStatusException}
     * with {@link com.hedera.hashgraph.sdk.Status#TRANSACTION_OVERSIZE}.
     *
     * <p>In this case, you can use {@link FileAppendTransaction}, which automatically breaks the contents
     * into chunks for you, to append contents of arbitrary size.
     *
     * @param bytes the contents of the file.
     * @return {@code this}
     */
    public FileCreateTransaction setContents(byte[] bytes) {
        requireNotFrozen();
        Objects.requireNonNull(bytes);
        contents = Arrays.copyOf(bytes, bytes.length);
        return this;
    }

    /**
     * <p>Encode the given {@link String} as UTF-8 and set it as the file's contents.
     *
     * <p>This may be omitted to create an empty file.
     *
     * <p>The string can later be recovered from {@link FileContentsQuery#execute(Client)}
     * via {@link String#String(byte[], java.nio.charset.Charset)} using
     * {@link java.nio.charset.StandardCharsets#UTF_8}.
     *
     * <p>Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a {@link PrecheckStatusException}
     * with {@link com.hedera.hashgraph.sdk.Status#TRANSACTION_OVERSIZE}.
     *
     * <p>In this case, you can use {@link FileAppendTransaction}, which automatically breaks the contents
     * into chunks for you, to append contents of arbitrary size.
     *
     * @param text the contents of the file.
     * @return {@code this}
     */
    public FileCreateTransaction setContents(String text) {
        requireNotFrozen();
        Objects.requireNonNull(text);
        contents = text.getBytes(StandardCharsets.UTF_8);
        return this;
    }

    /**
     * Extract the file's memo field.
     *
     * @return                          the file's memo field
     */
    public String getFileMemo() {
        return fileMemo;
    }

    /**
     * Assign a memo to the file (100 bytes max).
     *
     * @param memo                      memo string
     * @return {@code this}
     */
    public FileCreateTransaction setFileMemo(String memo) {
        requireNotFrozen();
        Objects.requireNonNull(memo);
        fileMemo = memo;
        return this;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return FileServiceGrpc.getCreateFileMethod();
    }

    @Override
    void validateChecksums(Client client) {
        // do nothing
    }

    /**
     * Initialize from transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getFileCreate();
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
        if (body.hasKeys()) {
            keys = KeyList.fromProtobuf(body.getKeys(), null);
        }
        contents = body.getContents().toByteArray();
        fileMemo = body.getMemo();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.FileCreateTransactionBody builder}
     */
    FileCreateTransactionBody.Builder build() {
        var builder = FileCreateTransactionBody.newBuilder();

        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }
        if (keys != null) {
            builder.setKeys(keys.toProtobuf());
        }
        builder.setContents(ByteString.copyFrom(contents));
        builder.setMemo(fileMemo);

        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setFileCreate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setFileCreate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * <p>A transaction to delete a file on the Hedera network.
 *
 * <p>When deleted, a file's contents are truncated to zero length and it can no longer be updated
 * or appended to, or its expiration time extended. {@link FileContentsQuery} and {@link FileInfoQuery}
 * will throw {@link PrecheckStatusException} with a status of {@link Status#FILE_DELETED}.
 *
 * <p>Only one of the file's keys needs to sign to delete the file, unless the key you have is part
 * of a {@link com.hedera.hashgraph.sdk.KeyList}.
 */
public final class FileDeleteTransaction extends Transaction<FileDeleteTransaction> {

    @Nullable
    private FileId fileId = null;

    /**
     * Constructor.
     */
    public FileDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    FileDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    FileDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * <p>Set the ID of the file to delete. Required.
     *
     * @param fileId the ID of the file to delete.
     * @return {@code this}
     */
    public FileDeleteTransaction setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        requireNotFrozen();
        this.fileId = fileId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getFileDelete();
        if (body.hasFileID()) {
            fileId = FileId.fromProtobuf(body.getFileID());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.FileDeleteTransactionBody builder}
     */
    FileDeleteTransactionBody.Builder build() {
        var builder = FileDeleteTransactionBody.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return FileServiceGrpc.getDeleteFileMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setFileDelete(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setFileDelete(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileID;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.Objects;

/**
 * The ID for a file on Hedera.
 */
public final class FileId implements Comparable<FileId> {
    /**
     * The public node address book for the current network.
     */
    public static final FileId ADDRESS_BOOK = new FileId(0, 0, 102);
    /**
     * The current fee schedule for the network.
     */
    public static final FileId FEE_SCHEDULE = new FileId(0, 0, 111);
    /**
     * The current exchange rate of HBAR to USD.
     */
    public static final FileId EXCHANGE_RATES = new FileId(0, 0, 112);
    /**
     * The shard number
     */
    @Nonnegative
    public final long shard;
    /**
     * The realm number
     */
    @Nonnegative
    public final long realm;
    /**
     * The id number
     */
    @Nonnegative
    public final long num;
    @Nullable
    private final String checksum;

    /**
     * Assign the num portion of the file id.
     *
     * @param num                       the num portion not negative
     */
    public FileId(@Nonnegative long num) {
        this(0, 0, num);
    }

    /**
     * Assign the file id.
     *
     * @param shard                     the shard portion
     * @param realm                     the realm portion
     * @param num                       the num portion
     */
    @SuppressWarnings("InconsistentOverloads")
    public FileId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num) {
        this(shard, realm, num, null);
    }

    /**
     * Assign the file id and optional checksum.
     *
     * @param shard                     the shard portion
     * @param realm                     the realm portion
     * @param num                       the num portion
     * @param checksum                  the optional checksum
     */
    @SuppressWarnings("InconsistentOverloads")
    FileId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num, @Nullable String checksum) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
    }

    /**
     * Assign the file id from a string.
     *
     * @param id                        the string representation of a file id
     * @return                          the file id object
     */
    public static FileId fromString(String id) {
        return EntityIdHelper.fromString(id, FileId::new);
    }

    /**
     * Assign the file id from a byte array.
     *
     * @param bytes                     the byte array representation of a file id
     * @return                          the file id object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static FileId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(FileID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create a file id object from a protobuf.
     *
     * @param fileId                    the protobuf
     * @return                          the file id object
     */
    static FileId fromProtobuf(FileID fileId) {
        Objects.requireNonNull(fileId);
        return new FileId(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum());
    }

    /**
     * Create a file id object from a solidity address.
     *
     * @param address                   the solidity address
     * @return                          the file id object
     */
    public static FileId fromSolidityAddress(String address) {
        return EntityIdHelper.fromSolidityAddress(address, FileId::new);
    }

    /**
     * Extract the string representation of file id.
     *
     * @return                          the string representation of file id
     */
    public String toSolidityAddress() {
        return EntityIdHelper.toSolidityAddress(shard, realm, num);
    }

    /**
      * @return                         protobuf representing the file id
     */
    FileID toProtobuf() {
        return FileID.newBuilder()
            .setShardNum(shard)
            .setRealmNum(realm)
            .setFileNum(num)
            .build();
    }

    /**
     * @param client to validate against
     * @throws BadEntityIdException if entity ID is formatted poorly
     * @deprecated Use {@link #validateChecksum(Client)} instead.
     */
    @Deprecated
    public void validate(Client client) throws BadEntityIdException {
        validateChecksum(client);
    }

    /**
     * Validate that the client is configured correctly.
     *
     * @param client                    the client to validate
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    public void validateChecksum(Client client) throws BadEntityIdException {
        EntityIdHelper.validate(shard, realm, num, client, checksum);
    }

    /**
     * Extract the checksum.
     *
     * @return                          the checksum
     */
    @Nullable
    public String getChecksum() {
        return checksum;
    }

    /**
     * Create the byte array.
     *
     * @return                          byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return EntityIdHelper.toString(shard, realm, num);
    }

    /**
     * Convert the client to a string representation with a checksum.
     *
     * @param client                    the client to stringify
     * @return                          string representation with checksum
     */
    public String toStringWithChecksum(Client client) {
        return EntityIdHelper.toStringWithChecksum(shard, realm, num, client, checksum);
    }

    @Override
    public int hashCode() {
        return Objects.hash(shard, realm, num);
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof FileId)) {
            return false;
        }

        FileId otherId = (FileId) o;
        return shard == otherId.shard && realm == otherId.realm && num == otherId.num;
    }

    @Override
    public int compareTo(FileId o) {
        Objects.requireNonNull(o);
        int shardComparison = Long.compare(shard, o.shard);
        if (shardComparison != 0) {
            return shardComparison;
        }
        int realmComparison = Long.compare(realm, o.realm);
        if (realmComparison != 0) {
            return realmComparison;
        }
        return Long.compare(num, o.num);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileGetInfoResponse;
import java.time.Instant;

import javax.annotation.Nullable;

/**
 * Current information for a file, including its size.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/file-storage/get-file-info">Hedera Documentation</a>
 */
public final class FileInfo {
    /**
     * The ID of the file for which information is requested.
     */
    public final FileId fileId;

    /**
     * Number of bytes in contents.
     */
    public final long size;

    /**
     * The current time at which this account is set to expire.
     */
    public final Instant expirationTime;

    /**
     * True if deleted but not yet expired.
     */
    public final boolean isDeleted;

    /**
     * One of these keys must sign in order to delete the file.
     * All of these keys must sign in order to update the file.
     */
    @Nullable
    public final KeyList keys;

    /**
     * The memo associated with the file
     */
    public final String fileMemo;

    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    public final LedgerId ledgerId;

    private FileInfo(
        FileId fileId,
        long size,
        Instant expirationTime,
        boolean isDeleted,
        @Nullable KeyList keys,
        String fileMemo,
        LedgerId ledgerId
    ) {
        this.fileId = fileId;
        this.size = size;
        this.expirationTime = expirationTime;
        this.isDeleted = isDeleted;
        this.keys = keys;
        this.fileMemo = fileMemo;
        this.ledgerId = ledgerId;
    }

    /**
     * Create a file info object from a ptotobuf.
     *
     * @param fileInfo                  the protobuf
     * @return                          the new file info object
     */
    static FileInfo fromProtobuf(FileGetInfoResponse.FileInfo fileInfo) {
        @Nullable KeyList keys = fileInfo.hasKeys() ?
            KeyList.fromProtobuf(fileInfo.getKeys(), null) :
            null;

        return new FileInfo(
            FileId.fromProtobuf(fileInfo.getFileID()),
            fileInfo.getSize(),
            InstantConverter.fromProtobuf(fileInfo.getExpirationTime()),
            fileInfo.getDeleted(),
            keys,
            fileInfo.getMemo(),
            LedgerId.fromByteString(fileInfo.getLedgerId())
        );
    }

    /**
     * Create a file info object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new file info object
     * @throws InvalidProtocolBufferException   when there is an issue with the protobuf
     */
    public static FileInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(FileGetInfoResponse.FileInfo.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    FileGetInfoResponse.FileInfo toProtobuf() {
        var fileInfoBuilder = FileGetInfoResponse.FileInfo.newBuilder()
            .setFileID(fileId.toProtobuf())
            .setSize(size)
            .setExpirationTime(InstantConverter.toProtobuf(expirationTime))
            .setDeleted(isDeleted)
            .setMemo(fileMemo)
            .setLedgerId(ledgerId.toByteString());

        if (keys != null) {
            var keyList = com.hedera.hashgraph.sdk.proto.KeyList.newBuilder();

            for (Key key : keys) {
                keyList.addKeys(key.toProtobufKey());
            }

            fileInfoBuilder.setKeys(keyList);
        }

        return fileInfoBuilder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("fileId", fileId)
            .add("size", size)
            .add("expirationTime", expirationTime)
            .add("isDeleted", isDeleted)
            .add("keys", keys)
            .add("fileMemo", fileMemo)
            .add("ledgerId", ledgerId)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FileGetInfoQuery;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Get all of the information about a file, except for its contents.
 * <p>
 * When a file expires, it no longer exists, and there will be no info about it, and the fileInfo field
 * will be blank.
 * <p>
 * If a transaction or smart contract deletes the file, but it has not yet expired, then the
 * fileInfo field will be non-empty, the deleted field will be true, its size will be 0,
 * and its contents will be empty. Note that each file has a FileID, but does not have a filename.
 */
public final class FileInfoQuery extends Query<FileInfo, FileInfoQuery> {

    @Nullable
    private FileId fileId = null;

    /**
     * Constructor.
     */
    public FileInfoQuery() {
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * Sets the file ID for which information is requested.
     *
     * @param fileId The FileId to be set
     * @return {@code this}
     */
    public FileInfoQuery setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        this.fileId = fileId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = FileGetInfoQuery.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }

        queryBuilder.setFileGetInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getFileGetInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getFileGetInfo().getHeader();
    }

    @Override
    FileInfo mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return FileInfo.fromProtobuf(response.getFileGetInfo().getFileInfo());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return FileServiceGrpc.getGetFileInfoMethod();
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `FILE_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FileUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.FileUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Instant;

import javax.annotation.Nullable;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Updates a file by submitting the transaction.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/sdks/file-storage/update-a-file">Hedera Documentation</a>
 */
public final class FileUpdateTransaction extends Transaction<FileUpdateTransaction> {

    @Nullable
    private FileId fileId = null;
    @Nullable
    private KeyList keys = null;
    @Nullable
    private Instant expirationTime = null;
    private byte[] contents = {};
    @Nullable
    private String fileMemo = null;

    /**
     * Constructor.
     */
    public FileUpdateTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    FileUpdateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    FileUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * Set the ID of the file to update; required.
     *
     * @param fileId the ID of the file to update.
     * @return {@code this}
     */
    public FileUpdateTransaction setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        requireNotFrozen();
        this.fileId = fileId;
        return this;
    }

    /**
     * Get the keys which must sign any transactions modifying this file.
     *
      * @return                         the list of keys
     */
    @Nullable
    public Collection<Key> getKeys() {
        return keys != null ? Collections.unmodifiableCollection(keys) : null;
    }

    /**
     * Set the keys which must sign any transactions modifying this file. Required.
     *
     * @param keys The Key or Keys to be set
     * @return {@code this}
     */
    public FileUpdateTransaction setKeys(Key... keys) {
        requireNotFrozen();

        this.keys = KeyList.of(keys);

        return this;
    }

    /**
     * Extract the expiration time.
     *
     * @return                          the expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * If set, update the expiration time of the file.
     * <p>
     * Must be in the future (may only be used to extend the expiration).
     * To make a file inaccessible use {@link FileDeleteTransaction} instead.
     *
     * @param expirationTime the new {@link Instant} at which the transaction will expire.
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public FileUpdateTransaction setExpirationTime(Instant expirationTime) {
        Objects.requireNonNull(expirationTime);
        requireNotFrozen();
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Extract the files contents as a byte string.
     *
     * @return                          the files contents as a byte string
     */
    public ByteString getContents() {
        return ByteString.copyFrom(contents);
    }

    /**
     * If set, replace contents of the file identified by {@link #setFileId(FileId)}
     * with the given bytes.
     * <p>
     * If the contents of the file are longer than the given byte array, then the file will
     * be truncated.
     * <p>
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a {@link Status#TRANSACTION_OVERSIZE}.
     * <p>
     * In this case, you will need to keep the initial file contents under ~6KiB and
     * then use {@link FileAppendTransaction}, which automatically breaks the contents
     * into chunks for you, to append contents of arbitrary size.
     *
     * @param bytes the bytes to replace the contents of the file with.
     * @return {@code this}
     * @see #setContents(String) for an overload which takes a {@link String}.
     * @see FileAppendTransaction if you merely want to add data to a file's existing contents.
     */
    public FileUpdateTransaction setContents(byte[] bytes) {
        requireNotFrozen();
        Objects.requireNonNull(bytes);
        contents = Arrays.copyOf(bytes, bytes.length);
        return this;
    }

    /**
     * If set, encode the given {@link String} as UTF-8 and replace the contents of the file
     * identified by {@link #setFileId(FileId)}.
     * <p>
     * If the contents of the file are longer than the UTF-8 encoding of the given string, then the
     * file will be truncated.
     * <p>
     * The string can later be recovered from {@link FileContentsQuery#execute(Client)}
     * via {@link String#String(byte[], java.nio.charset.Charset)} using
     * {@link java.nio.charset.StandardCharsets#UTF_8}.
     * <p>
     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the
     * network; if you exceed this you may receive a  {@link Status#TRANSACTION_OVERSIZE}.
     * <p>
     * In this case, you will need to keep the initial file contents under ~6KiB and
     * then use {@link FileAppendTransaction}, which automatically breaks the contents
     * into chunks for you, to append contents of arbitrary size.
     *
     * @param text the string to replace the contents of the file with.
     * @return {@code this}
     * @see #setContents(byte[]) for replacing the contents with arbitrary data.
     * @see FileAppendTransaction if you merely want to add data to a file's existing contents.
     */
    public FileUpdateTransaction setContents(String text) {
        Objects.requireNonNull(text);
        requireNotFrozen();
        contents = text.getBytes(StandardCharsets.UTF_8);
        return this;
    }

    /**
     * Extract the file's memo up to 100 bytes.
     *
     * @return                          the file's memo up to 100 bytes
     */
    @Nullable
    public String getFileMemo() {
        return fileMemo;
    }

    /**
     * Assign the file memo up to 100 bytes max.
     *
     * @param memo                      the file's memo
     * @return {@code this}
     */
    public FileUpdateTransaction setFileMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        fileMemo = memo;
        return this;
    }

    /**
     * Remove the file memo.
     *
     * @return {@code this}
     */
    public FileUpdateTransaction clearMemo() {
        requireNotFrozen();
        fileMemo = "";
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getFileUpdate();
        if (body.hasFileID()) {
            fileId = FileId.fromProtobuf(body.getFileID());
        }
        if (body.hasKeys()) {
            keys = KeyList.fromProtobuf(body.getKeys(), null);
        }
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
        if (body.hasMemo()) {
            fileMemo = body.getMemo().getValue();
        }
        contents = body.getContents().toByteArray();
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.FileUpdateTransactionBody builder }
     */
    FileUpdateTransactionBody.Builder build() {
        var builder = FileUpdateTransactionBody.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }
        if (keys != null) {
            builder.setKeys(keys.toProtobuf());
        }
        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }
        builder.setContents(ByteString.copyFrom(contents));
        if (fileMemo != null) {
            builder.setMemo(StringValue.of(fileMemo));
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return FileServiceGrpc.getUpdateFileMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setFileUpdate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setFileUpdate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FreezeTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FreezeServiceGrpc;
import com.hedera.hashgraph.sdk.proto.FreezeTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Instant;
import java.time.OffsetTime;
import java.time.ZoneOffset;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Set the freezing period in which the platform will stop creating events and accepting transactions.
 * This is used before safely shut down the platform for maintenance.
 */
public final class FreezeTransaction extends Transaction<FreezeTransaction> {
    private int endHour = 0;
    private int endMinute = 0;
    @Nullable
    private Instant startTime = null;
    @Nullable
    private FileId fileId = null;
    private byte[] fileHash = {};
    private FreezeType freezeType = FreezeType.UNKNOWN_FREEZE_TYPE;

    /**
     * Constructor.
     */
    public FreezeTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    FreezeTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    FreezeTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the start time.
     *
     * @return                          the start time
     */
    public Instant getStartTime() {
        return startTime != null ? startTime : Instant.EPOCH;
    }

    /**
     * Assign the start time.
     *
     * @param startTime                 the start time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public FreezeTransaction setStartTime(Instant startTime) {
        requireNotFrozen();
        Objects.requireNonNull(startTime);
        this.startTime = startTime;
        return this;
    }

    /**
     * @deprecated Use {@link #setStartTime(Instant)} instead.
     * @param hour   The hour to be set
     * @param minute The minute to be set
     * @return {@code this}
     */
    @Deprecated
    public FreezeTransaction setStartTime(int hour, int minute) {
        return setStartTime(Instant.ofEpochMilli(((long)hour * 60 * 60 + (long)minute * 60) * 1000));
    }

    /**
     * @deprecated with no replacement
     * @return the end time
     */
    @Deprecated
    @SuppressWarnings("FromTemporalAccessor")
    public Instant getEndTime() {
        return Instant.from(OffsetTime.of(endHour, endMinute, 0, 0, ZoneOffset.UTC));
    }

    /**
     * Sets the end time (in UTC).
     *
     * @deprecated with no replacement
     * @param hour   The hour to be set
     * @param minute The minute to be set
     * @return {@code this}
     */
    @Deprecated
    public FreezeTransaction setEndTime(int hour, int minute) {
        requireNotFrozen();

        endHour = hour;
        endMinute = minute;

        return this;
    }

    /**
     * @deprecated Use {@link #getFileId()} instead.
     * @return the fileId
     */
    @Deprecated
    @Nullable
    public FileId getUpdateFileId() {
        return fileId;
    }

    /**
     * @deprecated Use {@link #setFileId(FileId)} instead.
     * @param updateFileId the new fileId
     * @return {@code this}
     */
    @Deprecated
    public FreezeTransaction setUpdateFileId(FileId updateFileId) {
        return setFileId(updateFileId);
    }

    /**
     * @deprecated Use {@link #getFileHash()} instead.
     * @return the fileHash
     */
    @Deprecated
    public byte[] getUpdateFileHash() {
        return Arrays.copyOf(fileHash, fileHash.length);
    }

    /**
     * @deprecated Use {@link #setFileHash(byte[])} instead.
     * @param updateFileHash fileHash to set
     * @return {@code this}
     */
    @Deprecated
    public FreezeTransaction setUpdateFileHash(byte[] updateFileHash) {
        return setFileHash(updateFileHash);
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public FileId getFileId() {
        return fileId;
    }

    /**
     * Assign the file id.
     *
      * @param fileId                    the file id
     * @return {@code this}
     */
    public FreezeTransaction setFileId(FileId fileId) {
        requireNotFrozen();
        Objects.requireNonNull(fileId);
        this.fileId = fileId;
        return this;
    }

    /**
     * The expected hash of the contents of the update file (used to verify the update)
     *
     * @return                          the file's hash
     */
    public byte[] getFileHash() {
        return Arrays.copyOf(fileHash, fileHash.length);
    }

    /**
     * The expected hash of the contents of the update file (used to verify the update)
     *
     * @param fileHash the fileHash to set
     * @return {@code this}
     */
    public FreezeTransaction setFileHash(byte[] fileHash) {
        requireNotFrozen();
        Objects.requireNonNull(fileHash);
        this.fileHash = Arrays.copyOf(fileHash, fileHash.length);
        return this;
    }

    /**
     * Extract the freeze type.
     *
     * @return                          the freeze type
     */
    public FreezeType getFreezeType() {
        return freezeType;
    }

    /**
     * Assign the freeze type.
     * {@link com.hedera.hashgraph.sdk.FreezeTransaction}
     *
     * @param freezeType                the freeze type
     * @return {@code this}
     */
    public FreezeTransaction setFreezeType(FreezeType freezeType) {
        requireNotFrozen();
        Objects.requireNonNull(freezeType);
        this.freezeType = freezeType;
        return this;
    }

    @Override
    void validateChecksums(Client client) {
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return FreezeServiceGrpc.getFreezeMethod();
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getFreeze();
        freezeType = FreezeType.valueOf(body.getFreezeType());
        if (body.hasUpdateFile()) {
            fileId = FileId.fromProtobuf(body.getUpdateFile());
        }
        fileHash = body.getFileHash().toByteArray();
        if (body.hasStartTime()) {
            startTime = InstantConverter.fromProtobuf(body.getStartTime());
        }
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.FreezeTransactionBody builder }
     */
    FreezeTransactionBody.Builder build() {
        var builder = FreezeTransactionBody.newBuilder();
        builder.setFreezeType(freezeType.code);
        if (fileId != null) {
            builder.setUpdateFile(fileId.toProtobuf());
        }
        builder.setFileHash(ByteString.copyFrom(fileHash));
        if (startTime != null) {
            builder.setStartTime(InstantConverter.toProtobuf(startTime));
        }
        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setFreeze(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setFreeze(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FreezeType.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Enum for the freeze types.
 */
public enum FreezeType {
    /**
     * An (invalid) default value for this enum, to ensure the client explicitly sets
     * the intended type of freeze transaction.
     */
    UNKNOWN_FREEZE_TYPE(com.hedera.hashgraph.sdk.proto.FreezeType.UNKNOWN_FREEZE_TYPE),

    /**
     * Freezes the network at the specified time. The start_time field must be provided and
     * must reference a future time. Any values specified for the update_file and file_hash
     * fields will be ignored. This transaction does not perform any network changes or
     * upgrades and requires manual intervention to restart the network.
     */
    FREEZE_ONLY(com.hedera.hashgraph.sdk.proto.FreezeType.FREEZE_ONLY),

    /**
     * A non-freezing operation that initiates network wide preparation in advance of a
     * scheduled freeze upgrade. The update_file and file_hash fields must be provided and
     * valid. The start_time field may be omitted and any value present will be ignored.
     */
    PREPARE_UPGRADE(com.hedera.hashgraph.sdk.proto.FreezeType.PREPARE_UPGRADE),

    /**
     * Freezes the network at the specified time and performs the previously prepared
     * automatic upgrade across the entire network.
     */
    FREEZE_UPGRADE(com.hedera.hashgraph.sdk.proto.FreezeType.FREEZE_UPGRADE),

    /**
     * Aborts a pending network freeze operation.
     */
    FREEZE_ABORT(com.hedera.hashgraph.sdk.proto.FreezeType.FREEZE_ABORT),

    /**
     * Performs an immediate upgrade on auxilary services and containers providing
     * telemetry/metrics. Does not impact network operations.
     */
    TELEMETRY_UPGRADE(com.hedera.hashgraph.sdk.proto.FreezeType.TELEMETRY_UPGRADE);

    final com.hedera.hashgraph.sdk.proto.FreezeType code;

    FreezeType(com.hedera.hashgraph.sdk.proto.FreezeType code) {
        this.code = code;
    }

    static FreezeType valueOf(com.hedera.hashgraph.sdk.proto.FreezeType code) {
        return switch (code) {
            case UNKNOWN_FREEZE_TYPE -> UNKNOWN_FREEZE_TYPE;
            case FREEZE_ONLY -> FREEZE_ONLY;
            case PREPARE_UPGRADE -> PREPARE_UPGRADE;
            case FREEZE_UPGRADE -> FREEZE_UPGRADE;
            case FREEZE_ABORT -> FREEZE_ABORT;
            case TELEMETRY_UPGRADE -> TELEMETRY_UPGRADE;
            case UNRECOGNIZED ->
                // NOTE: Protobuf deserialization will not give us the code on the wire
                throw new IllegalArgumentException(
                    "network returned unrecognized response code; your SDK may be out of date");
        };
    }

    @Override
    public String toString() {
        return code.name();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/FutureConverter.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.MoreExecutors;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

// Converts between ListenableFuture (Guava) and CompletableFuture (StreamSupport).
// https://github.com/lukas-krecan/future-converter/blob/master/java8-guava/src/main/java/net/javacrumbs/futureconverter/java8guava/FutureConverter.java#L28
final class FutureConverter {
    private FutureConverter() {
    }

    /**
     * Generate a T object from a listenable future.
     *
     * @param listenableFuture          the T object generator
     * @return                          the T type object
     */
    static <T> CompletableFuture<T> toCompletableFuture(ListenableFuture<T> listenableFuture) {
        return Java8FutureUtils.createCompletableFuture(
            GuavaFutureUtils.createValueSourceFuture(listenableFuture));
    }

    // https://github.com/lukas-krecan/future-converter/blob/master/common/src/main/java/net/javacrumbs/futureconverter/common/internal/ValueSource.java
    private interface ValueSource<T> {
        void addCallbacks(Consumer<T> successCallback, Consumer<Throwable> failureCallback);

        boolean cancel(boolean mayInterruptIfRunning);
    }

    // https://github.com/lukas-krecan/future-converter/blob/master/common/src/main/java/net/javacrumbs/futureconverter/common/internal/ValueSourceFuture.java
    private abstract static class ValueSourceFuture<T> extends FutureWrapper<T>
        implements ValueSource<T> {
        ValueSourceFuture(Future<T> wrappedFuture) {
            super(wrappedFuture);
        }
    }

    // https://github.com/lukas-krecan/future-converter/blob/652b845824de90b075cf5ddbbda6fdf440f3ed0a/common/src/main/java/net/javacrumbs/futureconverter/common/internal/FutureWrapper.java
    private static class FutureWrapper<T> implements Future<T> {
        private final Future<T> wrappedFuture;

        FutureWrapper(Future<T> wrappedFuture) {
            this.wrappedFuture = wrappedFuture;
        }

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            return wrappedFuture.cancel(mayInterruptIfRunning);
        }

        @Override
        public boolean isCancelled() {
            return wrappedFuture.isCancelled();
        }

        @Override
        public boolean isDone() {
            return wrappedFuture.isDone();
        }

        @Override
        public T get() throws InterruptedException, ExecutionException {
            return wrappedFuture.get();
        }

        @Override
        public T get(long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
            return wrappedFuture.get(timeout, unit);
        }

        Future<T> getWrappedFuture() {
            return wrappedFuture;
        }
    }

    // https://github.com/lukas-krecan/future-converter/blob/master/guava-common/src/main/java/net/javacrumbs/futureconverter/guavacommon/GuavaFutureUtils.java
    private static class GuavaFutureUtils {
        public static <T> ValueSourceFuture<T> createValueSourceFuture(
            ListenableFuture<T> listenableFuture) {
            if (listenableFuture instanceof ValueSourceFutureBackedListenableFuture) {
                return ((ValueSourceFutureBackedListenableFuture<T>) listenableFuture)
                    .getWrappedFuture();
            } else {
                return new ListenableFutureBackedValueSourceFuture<>(listenableFuture);
            }
        }

        private static class ValueSourceFutureBackedListenableFuture<T> extends FutureWrapper<T>
            implements ListenableFuture<T> {
            ValueSourceFutureBackedListenableFuture(ValueSourceFuture<T> valueSourceFuture) {
                super(valueSourceFuture);
            }

            @Override
            ValueSourceFuture<T> getWrappedFuture() {
                return (ValueSourceFuture<T>) super.getWrappedFuture();
            }

            @Override
            public void addListener(Runnable listener, Executor executor) {
                getWrappedFuture()
                    .addCallbacks(
                        value -> executor.execute(listener),
                        ex -> executor.execute(listener));
            }
        }

        private static class ListenableFutureBackedValueSourceFuture<T>
            extends ValueSourceFuture<T> {
            private ListenableFutureBackedValueSourceFuture(ListenableFuture<T> wrappedFuture) {
                super(wrappedFuture);
            }

            @Override
            public void addCallbacks(
                Consumer<T> successCallback, Consumer<Throwable> failureCallback) {
                Futures.addCallback(
                    getWrappedFuture(),
                    new FutureCallback<T>() {
                        @Override
                        public void onSuccess(T result) {
                            successCallback.accept(result);
                        }

                        @Override
                        public void onFailure(Throwable t) {
                            failureCallback.accept(t);
                        }
                    },
                    MoreExecutors.directExecutor());
            }

            @Override
            ListenableFuture<T> getWrappedFuture() {
                return (ListenableFuture<T>) super.getWrappedFuture();
            }
        }
    }

    // https://github.com/lukas-krecan/future-converter/blob/master/java8-common/src/main/java/net/javacrumbs/futureconverter/java8common/Java8FutureUtils.java
    private static class Java8FutureUtils {
        public static <T> CompletableFuture<T> createCompletableFuture(ValueSource<T> valueSource) {
            if (valueSource instanceof CompletableFutureBackedValueSource) {
                return ((CompletableFutureBackedValueSource<T>) valueSource).getWrappedFuture();
            } else {
                return new ValueSourceBackedCompletableFuture<T>(valueSource);
            }
        }

        private static final class ValueSourceBackedCompletableFuture<T>
            extends CompletableFuture<T> {
            private final ValueSource<T> valueSource;

            @SuppressWarnings("ConstructorLeaksThis")
            private ValueSourceBackedCompletableFuture(ValueSource<T> valueSource) {
                this.valueSource = valueSource;
                valueSource.addCallbacks(this::complete, this::completeExceptionally);
            }

            @Override
            public boolean cancel(boolean mayInterruptIfRunning) {
                if (isDone()) {
                    return false;
                }
                boolean result = valueSource.cancel(mayInterruptIfRunning);
                super.cancel(mayInterruptIfRunning);
                return result;
            }
        }

        private static final class CompletableFutureBackedValueSource<T>
            extends ValueSourceFuture<T> {
            private CompletableFutureBackedValueSource(CompletableFuture<T> completableFuture) {
                super(completableFuture);
            }

            @Override
            public void addCallbacks(
                Consumer<T> successCallback, Consumer<Throwable> failureCallback) {
                getWrappedFuture()
                    .whenComplete(
                        (v, t) -> {
                            if (t == null) {
                                successCallback.accept(v);
                            } else {
                                failureCallback.accept(t);
                            }
                        });
            }

            @Override
            CompletableFuture<T> getWrappedFuture() {
                return (CompletableFuture<T>) super.getWrappedFuture();
            }
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Hbar.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.Splitter;

import javax.annotation.Nullable;
import java.math.BigDecimal;
import java.math.MathContext;
import java.util.Objects;
import java.util.regex.Pattern;

/**
 * Represents a quantity of hbar.
 * <p>
 * Implemented as a wrapper class to force handling of units. Direct interfacing with Hedera accepts amounts
 * in tinybars however the nominal unit is hbar.
 */
public final class Hbar implements Comparable<Hbar> {
    /**
     * A constant value of zero hbars.
     */
    public static final Hbar ZERO = Hbar.fromTinybars(0);
    /**
     * A constant value of the maximum number of hbars.
     */
    public static final Hbar MAX = Hbar.from(50_000_000_000L);
    /**
     * A constant value of the minimum number of hbars.
     */
    public static final Hbar MIN = Hbar.from(-50_000_000_000L);
    private static final Pattern FROM_STRING_PATTERN = Pattern.compile("^((?:\\+|\\-)?\\d+(?:\\.\\d+)?)(\\ (t||m||k|M|G))?$");
    private final long valueInTinybar;

    /**
     * Constructs a new Hbar of the specified value.
     *
     * @param amount The amount of Hbar
     */
    public Hbar(long amount) {
        this(amount, HbarUnit.HBAR);
    }

    /**
     * Constructs a new hbar of the specified value in the specified unit.
     * {@link com.hedera.hashgraph.sdk.HbarUnit}
     *
     * @param amount                            the amount
     * @param unit                              the unit for amount
     */
    Hbar(long amount, HbarUnit unit) {
        valueInTinybar = amount * unit.tinybar;
    }

    /**
     * Constructs a new Hbar of the specified, possibly fractional value.
     * <p>
     * The equivalent amount in tinybar must be an integer and fit in a {@code long} (64-bit signed integer).
     * <p>
     * E.g., {@code 1.23456789} is a valid amount of hbar but {@code 0.123456789} is not.
     *
     * @param amount The amount of Hbar
     */
    public Hbar(BigDecimal amount) {
        this(amount, HbarUnit.HBAR);
    }

    /**
     * Constructs a new hbar of the specified value in the specified unit.
     * {@link com.hedera.hashgraph.sdk.HbarUnit}
     *
     * @param amount                            the amount
     * @param unit                              the unit for amount
     */
    Hbar(BigDecimal amount, HbarUnit unit) {
        var tinybars = amount.multiply(BigDecimal.valueOf(unit.tinybar));

        if (tinybars.doubleValue() % 1 != 0) {
            throw new IllegalArgumentException("Amount and Unit combination results in a fractional value for tinybar.  Ensure tinybar value is a whole number.");
        }

        valueInTinybar = tinybars.longValue();
    }

    private static HbarUnit getUnit(String symbolString) {
        for (var unit : HbarUnit.values()) {
            if (unit.getSymbol().equals(symbolString)) {
                return unit;
            }
        }
        throw new IllegalArgumentException("Attempted to convert string to Hbar, but unit symbol \"" + symbolString + "\" was not recognized");
    }

    /**
     * Converts the provided string into an amount of hbars.
     *
     * @param text The string representing the amount of Hbar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar fromString(CharSequence text) {
        var matcher = FROM_STRING_PATTERN.matcher(text);
        if (!matcher.matches()) {
            throw new IllegalArgumentException("Attempted to convert string to Hbar, but \"" + text + "\" was not correctly formatted");
        }
        var parts = Splitter.on(' ').splitToList(text.toString());
        return new Hbar(new BigDecimal(parts.get(0)), parts.size() == 2 ? getUnit(parts.get(1)) : HbarUnit.HBAR);
    }

    /**
     * Converts the provided string into an amount of hbars.
     *
     * @param text The string representing the amount of set units
     * @param unit The unit to convert from to Hbar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar fromString(CharSequence text, HbarUnit unit) {
        return new Hbar(new BigDecimal(text.toString()), unit);
    }

    /**
     * Returns an Hbar whose value is equal to the specified long.
     *
     * @param hbars The value of Hbar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar from(long hbars) {
        return new Hbar(hbars, HbarUnit.HBAR);
    }

    /**
     * Returns an Hbar representing the value in the given units.
     *
     * @param amount The long representing the amount of set units
     * @param unit   The unit to convert from to Hbar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar from(long amount, HbarUnit unit) {
        return new Hbar(amount, unit);
    }

    /**
     * Returns an Hbar whose value is equal to the specified long.
     *
     * @param hbars The BigDecimal representing the amount of Hbar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar from(BigDecimal hbars) {
        return new Hbar(hbars, HbarUnit.HBAR);
    }

    /**
     * Returns an Hbar representing the value in the given units.
     *
     * @param amount The BigDecimal representing the amount of set units
     * @param unit   The unit to convert from to Hbar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar from(BigDecimal amount, HbarUnit unit) {
        return new Hbar(amount, unit);
    }

    /**
     * Returns an Hbar converted from the specified number of tinybars.
     *
     * @param tinybars The long representing the amount of tinybar
     * @return {@link com.hedera.hashgraph.sdk.Hbar}
     */
    public static Hbar fromTinybars(long tinybars) {
        return new Hbar(tinybars, HbarUnit.TINYBAR);
    }

    /**
     * Convert this hbar value to a different unit.
     *
     * @param unit The unit to convert to from Hbar
     * @return BigDecimal
     */
    public BigDecimal to(HbarUnit unit) {
        return BigDecimal.valueOf(valueInTinybar).divide(BigDecimal.valueOf(unit.tinybar), MathContext.UNLIMITED);
    }

    /**
     * Convert this hbar value to Tinybars.
     *
     * @return long
     */
    public long toTinybars() {
        return valueInTinybar;
    }

    /**
     * Returns the number of Hbars.
     *
     * @return BigDecimal
     */
    public BigDecimal getValue() {
        return to(HbarUnit.HBAR);
    }

    /**
     * Returns a Hbar whose value is {@code -this}.
     *
     * @return Hbar
     */
    public Hbar negated() {
        return Hbar.fromTinybars(-valueInTinybar);
    }

    @Override
    public String toString() {
        if (valueInTinybar < 10_000 && valueInTinybar > -10_000) {
            return Long.toString(this.valueInTinybar) + " " + HbarUnit.TINYBAR.getSymbol();
        }

        return to(HbarUnit.HBAR).toString() + " " + HbarUnit.HBAR.getSymbol();
    }

    /**
     * Convert hbar to string representation in specified units.
     *
     * @param unit                      the desired unit
     * @return                          the string representation
     */
    public String toString(HbarUnit unit) {
        return to(unit).toString();
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        Hbar hbar = (Hbar) o;
        return valueInTinybar == hbar.valueInTinybar;
    }

    @Override
    public int hashCode() {
        return Objects.hash(valueInTinybar);
    }

    @Override
    public int compareTo(Hbar o) {
        return Long.compare(valueInTinybar, o.valueInTinybar);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/HbarAllowance.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoAllowance;
import com.hedera.hashgraph.sdk.proto.GrantedCryptoAllowance;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * An approved allowance of hbar transfers for a spender.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/cryptoallowance">Hedera Documentation</a>
 */
public class HbarAllowance {

    /**
     * The account ID of the hbar owner (ie. the grantor of the allowance)
     */
    @Nullable
    public final AccountId ownerAccountId;

    /**
     * The account ID of the spender of the hbar allowance
     */
    @Nullable
    public final AccountId spenderAccountId;

    /**
     * The amount of the spender's allowance in tinybars
     */
    @Nullable
    public final Hbar amount;

    /**
     * Constructor.
     * @param ownerAccountId            the owner granting the allowance
     * @param spenderAccountId          the spender
     * @param amount                    the amount of hbar
     */
    HbarAllowance(@Nullable AccountId ownerAccountId, @Nullable AccountId spenderAccountId, @Nullable Hbar amount) {
        this.ownerAccountId = ownerAccountId;
        this.spenderAccountId = spenderAccountId;
        this.amount = amount;
    }

    /**
     * Create a hbar allowance from a crypto allowance protobuf.
     *
     * @param allowanceProto            the crypto allowance protobuf
     * @return                          the new hbar allowance
     */
    static HbarAllowance fromProtobuf(CryptoAllowance allowanceProto) {
        return new HbarAllowance(
            allowanceProto.hasOwner() ? AccountId.fromProtobuf(allowanceProto.getOwner()) : null,
            allowanceProto.hasSpender() ? AccountId.fromProtobuf(allowanceProto.getSpender()) : null,
            Hbar.fromTinybars(allowanceProto.getAmount())
        );
    }

    /**
     * Create a hbar allowance from a granted crypto allowance protobuf.
     *
     * @param allowanceProto            the granted crypto allowance protobuf
     * @return                          the new hbar allowance
     */
    static HbarAllowance fromProtobuf(GrantedCryptoAllowance allowanceProto) {
        return new HbarAllowance(
            null,
            allowanceProto.hasSpender() ? AccountId.fromProtobuf(allowanceProto.getSpender()) : null,
            Hbar.fromTinybars(allowanceProto.getAmount())
        );
    }

    /**
     * Create a hbar allowance from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new hbar allowance
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static HbarAllowance fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(CryptoAllowance.parseFrom(Objects.requireNonNull(bytes)));
    }

    /**
     * Validate that the client is configured correctly.
     *
     * @param client                    the client to verify
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    void validateChecksums(Client client) throws BadEntityIdException {
        if (ownerAccountId != null) {
            ownerAccountId.validateChecksum(client);
        }
        if (spenderAccountId != null) {
            spenderAccountId.validateChecksum(client);
        }
    }

    /**
     * Convert a crypto allowance into a protobuf.
     *
     * @return                          the protobuf
     */
    CryptoAllowance toProtobuf() {
        var builder = CryptoAllowance.newBuilder()
            .setAmount(amount.toTinybars());
        if (ownerAccountId != null) {
            builder.setOwner(ownerAccountId.toProtobuf());
        }
        if (spenderAccountId != null) {
            builder.setSpender(spenderAccountId.toProtobuf());
        }
        return builder.build();
    }

    /**
     * Convert a crypto allowance into a granted crypto allowance protobuf.
     *
     * @return                          the granted crypto allowance
     */
    GrantedCryptoAllowance toGrantedProtobuf() {
        var builder = GrantedCryptoAllowance.newBuilder()
            .setAmount(amount.toTinybars());
        if (spenderAccountId != null) {
            builder.setSpender(spenderAccountId.toProtobuf());
        }
        return builder.build();
    }

    /**
     * Create the byte array.
     *
     * @return                          a byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("ownerAccountId", ownerAccountId)
            .add("spenderAccountId", spenderAccountId)
            .add("amount", amount)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/HbarUnit.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Common units of hbar; for the most part they follow SI prefix conventions.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/hbars#hbar-units">Hedera Documentation</a>
 */
public enum HbarUnit {
    /**
     * The atomic (smallest) unit of hbar, used natively by the Hedera network.
     * <p>
     * It is equivalent to <sup>1</sup>&frasl;<sub>100,000,000</sub> hbar.
     */
    TINYBAR("t", 1),

    /**
     * Equivalent to 100 tinybar or <sup>1</sup>&frasl;<sub>1,000,000</sub> hbar.
     */
    MICROBAR("", 100),

    /**
     * Equivalent to 100,000 tinybar or <sup>1</sup>&frasl;<sub>1,000</sub> hbar.
     */
    MILLIBAR("m", 100_000),

    /**
     * The base unit of hbar, equivalent to 100 million tinybar.
     */
    HBAR("", 100_000_000),

    /**
     * Equivalent to 1 thousand hbar or 100 billion tinybar.
     */
    KILOBAR("k", 1000 * 100_000_000L),

    /**
     * Equivalent to 1 million hbar or 100 trillion tinybar.
     */
    MEGABAR("M", 1_000_000 * 100_000_000L),

    /**
     * Equivalent to 1 billion hbar or 100 quadillion tinybar.
     * <p>
     * The maximum hbar amount supported by Hedera in any context is ~92 gigabar
     * (2<sup>63</sup> tinybar); use this unit sparingly.
     */
    GIGABAR("G", 1_000_000_000 * 100_000_000L);

    final long tinybar;

    private final String symbol;

    HbarUnit(String symbol, long tinybar) {
        this.symbol = symbol;
        this.tinybar = tinybar;
    }

    /**
     * Get the preferred symbol of the current unit.
     * <p>
     * E.g. {@link #TINYBAR}.getSymbol() returns "t".
     *
     * @return the symbol
     */
    public String getSymbol() {
        return symbol;
    }

    /**
     * Get the name of this unit.
     */
    @Override
    public String toString() {
        return name().toLowerCase();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/HederaPreCheckStatusException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;

/**
 * Signals that a transaction has failed the pre-check.
 * <p>
 * Before a node submits a transaction to the rest of the network,
 * it attempts some cheap assertions. This process is called the "pre-check".
 */
@Deprecated
public final class HederaPreCheckStatusException extends PrecheckStatusException {
    HederaPreCheckStatusException(Status status, @Nullable TransactionId transactionId) {
        super(status, transactionId);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/HederaReceiptStatusException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * An Exception thrown on error status by {@link TransactionId#getReceipt(Client)}.
 * <p>
 * The receipt is included, though only the {@link TransactionReceipt#status} field will be
 * initialized; all the getters should throw.
 */
@Deprecated
public class HederaReceiptStatusException extends ReceiptStatusException {
    HederaReceiptStatusException(TransactionId transactionId, TransactionReceipt receipt) {
        super(transactionId, receipt);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/HederaTrustManager.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.bouncycastle.util.encoders.Hex;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import javax.net.ssl.X509TrustManager;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

/**
 * Internal class used by node.
 */
class HederaTrustManager implements X509TrustManager {
    private static final String CERTIFICATE = "CERTIFICATE";
    private static final String PEM_HEADER = "-----BEGIN CERTIFICATE-----\n";
    private static final String PEM_FOOTER = "-----END CERTIFICATE-----\n";
    protected final Logger logger = LoggerFactory.getLogger(getClass());

    @Nullable
    private final String certHash;

    /**
     * Constructor.
     *
     * @param certHash                  a byte string of the certificate hash
     * @param verifyCertificate         should be verified
     */
    HederaTrustManager(@Nullable ByteString certHash, boolean verifyCertificate) {
        if (certHash == null || certHash.isEmpty()) {
            if (verifyCertificate) {
                throw new IllegalStateException("transport security and certificate verification are enabled, but no applicable address book was found");
            }

            logger.warn("skipping certificate check since no cert hash was found");
            this.certHash = null;
        } else {
            this.certHash = new String(certHash.toByteArray(), StandardCharsets.UTF_8);
        }
    }

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType) {
        throw new UnsupportedOperationException("Attempted to use HederaTrustManager to verify a client, but this trust manager is for verifying server only");
    }

    @Override
    @SuppressFBWarnings(
        value = "DLS_DEAD_LOCAL_STORE",
        justification = "SpotBugs seems to be getting confused by the control flow here.  It thinks certHashBytes is not used."
    )
    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        if (certHash == null) {
            return;
        }

        for (var cert : chain) {
            byte[] pem;

            try (
                var outputStream = new ByteArrayOutputStream();
                var pemWriter = new PemWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8))
            ) {
                pemWriter.writeObject(new PemObject(CERTIFICATE, cert.getEncoded()));
                pemWriter.flush();

                pem = outputStream.toByteArray();
            } catch (IOException e) {
                logger.warn("Failed to write PEM to byte array: ", e);
                continue;
            }

            var certHashBytes = new byte[0];

            try {
                certHashBytes = MessageDigest.getInstance("SHA-384").digest(pem);
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException("Failed to find SHA-384 digest for certificate hashing", e);
            }

            if (this.certHash.equals(Hex.toHexString(certHashBytes))) {
                return;
            }
        }

        throw new CertificateException("Failed to confirm the server's certificate from a known address book");
    }

    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return new X509Certificate[0];
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/InstantConverter.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TimestampSeconds;
import java.time.Instant;

/**
 * Instance in time utilities.
 */
final class InstantConverter {
    /**
     * Constructor.
     */
    private InstantConverter() {
    }

    /**
     * Create an instance from a timestamp protobuf.
     *
     * @param timestamp                 the protobuf
     * @return                          the instance
     */
    static Instant fromProtobuf(Timestamp timestamp) {
        return Instant.ofEpochSecond(timestamp.getSeconds(), timestamp.getNanos());
    }

    /**
     * Create an instance from a timestamp in seconds protobuf.
     *
     * @param timestampSeconds          the protobuf
     * @return                          the instance
     */
    static Instant fromProtobuf(TimestampSeconds timestampSeconds) {
        return Instant.ofEpochSecond(timestampSeconds.getSeconds());
    }

    /**
     * Convert an instance into a timestamp.
     *
     * @param instant                   the instance
     * @return                          the timestamp
     */
    static Timestamp toProtobuf(Instant instant) {
        return Timestamp.newBuilder()
            .setSeconds(instant.getEpochSecond())
            .setNanos(instant.getNano())
            .build();
    }

    /**
     * Convert an instance into a timestamp in seconds.
     *
     * @param instant                   the instance
     * @return                          the timestamp in seconds
     */
    static TimestampSeconds toSecondsProtobuf(Instant instant) {
        return TimestampSeconds.newBuilder()
            .setSeconds(instant.getEpochSecond())
            .build();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Key.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.sec.SECNamedCurves;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.crypto.params.ECDomainParameters;

/**
 * A common base for the signing authority or key that entities in Hedera may have.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/key">Hedera Documentation</a>
 * @see KeyList
 * @see PublicKey
 */
public abstract class Key {
    static final ASN1ObjectIdentifier ID_ED25519 = new ASN1ObjectIdentifier("1.3.101.112");
    static final ASN1ObjectIdentifier ID_ECDSA_SECP256K1 = new ASN1ObjectIdentifier("1.3.132.0.10");
    static final ASN1ObjectIdentifier ID_EC_PUBLIC_KEY = new ASN1ObjectIdentifier("1.2.840.10045.2.1");

    static final X9ECParameters ECDSA_SECP256K1_CURVE = SECNamedCurves.getByName("secp256k1");
    static final ECDomainParameters ECDSA_SECP256K1_DOMAIN =
        new ECDomainParameters(
            ECDSA_SECP256K1_CURVE.getCurve(),
            ECDSA_SECP256K1_CURVE.getG(),
            ECDSA_SECP256K1_CURVE.getN(),
            ECDSA_SECP256K1_CURVE.getH()
        );

    /**
     * Create a specific key type from the protobuf.
     *
     * @param key                       the protobuf key of unknown type
     * @return                          the differentiated key
     */
    static Key fromProtobufKey(com.hedera.hashgraph.sdk.proto.Key key) {
        switch (key.getKeyCase()) {
            case ED25519 -> {
                return new PublicKeyED25519(key.getEd25519().toByteArray());
            }
            case ECDSA_SECP256K1 -> {
                if (key.getECDSASecp256K1().size() == 20) {
                    return new EvmAddress(key.getECDSASecp256K1().toByteArray());
                } else {
                    return new PublicKeyECDSA(key.getECDSASecp256K1().toByteArray());
                }
            }
            case KEYLIST -> {
                return KeyList.fromProtobuf(key.getKeyList(), null);
            }
            case THRESHOLDKEY -> {
                return KeyList.fromProtobuf(key.getThresholdKey().getKeys(), key.getThresholdKey().getThreshold());
            }
            case CONTRACTID -> {
                return ContractId.fromProtobuf(key.getContractID());
            }
            case DELEGATABLE_CONTRACT_ID -> {
                return DelegateContractId.fromProtobuf(key.getDelegatableContractId());
            }
            case KEY_NOT_SET -> {
                return null;
            }
            default -> throw new IllegalStateException("Key#fromProtobuf: unhandled key case: " + key.getKeyCase());
        }
    }

    /**
     * Serialize this key as a protobuf object
     */
    abstract com.hedera.hashgraph.sdk.proto.Key toProtobufKey();

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobufKey().toByteArray();
    }

    /**
     * Create Key from proto.Key byte array
     *
     * @param bytes
     * @return Key representation
     * @throws InvalidProtocolBufferException
     */
    public static Key fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobufKey(com.hedera.hashgraph.sdk.proto.Key.parseFrom(bytes));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/KeyList.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.hedera.hashgraph.sdk.proto.ThresholdKey;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;

/**
 * A list of keys that are required to sign in unison, with an optional threshold controlling how many keys of
 * the list are required.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/key">Hedera Documentation</a>
 */
public final class KeyList extends Key implements Collection<Key> {
    /**
     * The list of keys.
     */
    private final List<Key> keys = new ArrayList<>();

    /**
     * The minimum number of keys that must sign.
     */
    @Nullable
    public Integer threshold;

    /**
     * Create a new key list where all keys that are added will be required to sign.
     */
    public KeyList() {
        this.threshold = null;
    }

    /**
     * Number of keys that need to sign.
     *
     * @param threshold                 the minimum number of keys that must sign
     */
    private KeyList(int threshold) {
        this.threshold = threshold;
    }

    /**
     * List of keys in the key.
     *
     * @param keys                      the key / key list
     * @return                          a list of the keys
     */
    public static KeyList of(Key... keys) {
        var list = new KeyList();

        for (var key : keys) {
            list.add(key);
        }

        return list;
    }

    /**
     * Create a new key list where at least {@code threshold} keys must sign.
     *
     * @param threshold the minimum number of keys that must sign
     * @return KeyList
     */
    public static KeyList withThreshold(int threshold) {
        return new KeyList(threshold);
    }

    /**
     * Create key list from protobuf.
     *
     * @param keyList                   the key list
     * @param threshold                 the minimum number of keys that must sign
     * @return                          the key list
     */
    static KeyList fromProtobuf(com.hedera.hashgraph.sdk.proto.KeyList keyList, @Nullable Integer threshold) {
        var keys = (threshold != null ? new KeyList(threshold) : new KeyList());
        for (var i = 0; i < keyList.getKeysCount(); ++i) {
            keys.add(Key.fromProtobufKey(keyList.getKeys(i)));
        }

        return keys;
    }

    /**
     * Get the threshold for the KeyList.
     *
     * @return int
     */
    @Nullable
    public Integer getThreshold() {
        return threshold;
    }

    /**
     * Set a threshold for the KeyList.
     *
     * @param threshold the minimum number of keys that must sign
     * @return KeyList
     */
    public KeyList setThreshold(int threshold) {
        this.threshold = threshold;
        return this;
    }

    @Override
    public int size() {
        return keys.size();
    }

    @Override
    public boolean isEmpty() {
        return keys.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        return keys.contains(o);
    }

    @Override
    public Iterator<Key> iterator() {
        return keys.iterator();
    }

    @Override
    public Object[] toArray() {
        return keys.toArray();
    }

    @Override
    public <T> T[] toArray(T[] ts) {
        // noinspection unchecked,SuspiciousToArrayCall
        return (T[]) keys.toArray((Key[]) ts);
    }

    @Override
    public boolean add(Key key) {
        return keys.add(key);
    }

    @Override
    public boolean remove(Object o) {
        return keys.remove(o);
    }

    @Override
    public boolean containsAll(Collection<?> collection) {
        return keys.containsAll(collection);
    }

    @Override
    public boolean addAll(Collection<? extends Key> collection) {
        return keys.addAll(collection);
    }

    @Override
    public boolean removeAll(Collection<?> collection) {
        return keys.removeAll(collection);
    }

    @Override
    public boolean retainAll(Collection<?> collection) {
        return keys.retainAll(collection);
    }

    @Override
    public void clear() {
        keys.clear();
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        var protoKeyList = com.hedera.hashgraph.sdk.proto.KeyList.newBuilder();
        for (var key : keys) {
            protoKeyList.addKeys(key.toProtobufKey());
        }

        if (threshold != null) {
            return com.hedera.hashgraph.sdk.proto.Key.newBuilder()
                .setThresholdKey(ThresholdKey.newBuilder()
                    .setThreshold(threshold)
                    .setKeys(protoKeyList))
                .build();
        }

        return com.hedera.hashgraph.sdk.proto.Key.newBuilder()
            .setKeyList(protoKeyList)
            .build();
    }

    /**
     * Convert into protobuf representation.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.KeyList toProtobuf() {
        var keyList = com.hedera.hashgraph.sdk.proto.KeyList.newBuilder();

        for (Key key : keys) {
            keyList.addKeys(key.toProtobufKey());
        }

        return keyList.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("threshold", threshold)
            .add("keys", keys)
            .toString();
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof KeyList)) {
            return false;
        }

        KeyList keyList = (KeyList) o;

        if (keyList.size() != size()) {
            return false;
        }

        for (int i = 0; i < keyList.size(); i++) {
            if (!Arrays.equals(keyList.keys.get(i).toBytes(), keys.get(i).toBytes())) {
                return false;
            }
        }

        return true;
    }

    @Override
    public int hashCode() {
        return Objects.hash(keys.hashCode(), threshold != null ? threshold : -1);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Keystore.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonWriter;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.Optional;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.encoders.Hex;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Objects;

/**
 * Internal utility class to serialize / deserialize between java object / json representation.
 */
final class Keystore {
    private static final Gson gson = new Gson();
    private static final JsonParser jsonParser = new JsonParser();

    private byte[] keyBytes;

    private Keystore(byte[] keyBytes) {
        this.keyBytes = keyBytes;
    }

    public Keystore(PrivateKey privateKey) {
        this.keyBytes = privateKey.toBytes();
    }

    public static Keystore fromStream(InputStream stream, String passphrase) throws IOException {
        try {
            JsonObject jsonObject = jsonParser.parse(new InputStreamReader(stream, StandardCharsets.UTF_8))
                .getAsJsonObject();
            return fromJson(jsonObject, passphrase);
        } catch (IllegalStateException e) {
            throw new BadKeyException(Optional.ofNullable(e.getMessage()).orElse("failed to parse Keystore"));
        } catch (JsonIOException e) {
            // RFC (@abonander): I'm all for keeping this as an unchecked exception
            // but I want consistency with export() so this may involve creating our own exception
            // because JsonIOException is kinda leaking implementation details.
            throw (IOException) Objects.requireNonNull(e.getCause());
        } catch (JsonSyntaxException e) {
            throw new BadKeyException(e);
        }
    }

    private static Keystore fromJson(JsonObject object, String passphrase) {
        int version = expectInt(object, "version");

        //noinspection SwitchStatementWithTooFewBranches
        switch (version) {
            case 1:
                return parseKeystoreV1(expectObject(object, "crypto"), passphrase);
            case 2:
                return parseKeystoreV2(expectObject(object, "crypto"), passphrase);
            default:
                throw new BadKeyException("unsupported keystore version: " + version);
        }
    }

    private static Keystore parseKeystoreV1(JsonObject crypto, String passphrase) {
        String ciphertext = expectString(crypto, "ciphertext");
        String ivString = expectString(expectObject(crypto, "cipherparams"), "iv");
        String cipher = expectString(crypto, "cipher");
        String kdf = expectString(crypto, "kdf");
        JsonObject kdfParams = expectObject(crypto, "kdfparams");
        String macString = expectString(crypto, "mac");

        if (!cipher.equals("aes-128-ctr")) {
            throw new BadKeyException("unsupported keystore cipher: " + cipher);
        }

        if (!kdf.equals("pbkdf2")) {
            throw new BadKeyException("unsuppported KDF: " + kdf);
        }

        int dkLen = expectInt(kdfParams, "dkLen");
        String saltStr = expectString(kdfParams, "salt");
        int count = expectInt(kdfParams, "c");
        String prf = expectString(kdfParams, "prf");

        if (!prf.equals("hmac-sha256")) {
            throw new BadKeyException("unsupported KDF hash function: " + prf);
        }

        byte[] cipherBytes = Hex.decode(ciphertext);
        byte[] iv = Hex.decode(ivString);
        byte[] mac = Hex.decode(macString);
        byte[] salt = Hex.decode(saltStr);

        KeyParameter cipherKey = Crypto.deriveKeySha256(passphrase, salt, count, dkLen);

        byte[] testHmac = Crypto.calcHmacSha384(cipherKey, null, cipherBytes);

        if (!MessageDigest.isEqual(mac, testHmac)) {
            throw new BadKeyException("HMAC mismatch; passphrase is incorrect");
        }

        return new Keystore(Crypto.decryptAesCtr128(cipherKey, iv, cipherBytes));
    }

    private static Keystore parseKeystoreV2(JsonObject crypto, String passphrase) {
        String ciphertext = expectString(crypto, "ciphertext");
        String ivString = expectString(expectObject(crypto, "cipherparams"), "iv");
        String cipher = expectString(crypto, "cipher");
        String kdf = expectString(crypto, "kdf");
        JsonObject kdfParams = expectObject(crypto, "kdfparams");
        String macString = expectString(crypto, "mac");

        if (!cipher.equals("aes-128-ctr")) {
            throw new BadKeyException("unsupported keystore cipher: " + cipher);
        }

        if (!kdf.equals("pbkdf2")) {
            throw new BadKeyException("unsuppported KDF: " + kdf);
        }

        int dkLen = expectInt(kdfParams, "dkLen");
        String saltStr = expectString(kdfParams, "salt");
        int count = expectInt(kdfParams, "c");
        String prf = expectString(kdfParams, "prf");

        if (!prf.equals("hmac-sha256")) {
            throw new BadKeyException("unsupported KDF hash function: " + prf);
        }

        byte[] cipherBytes = Hex.decode(ciphertext);
        byte[] iv = Hex.decode(ivString);
        byte[] mac = Hex.decode(macString);
        byte[] salt = Hex.decode(saltStr);

        KeyParameter cipherKey = Crypto.deriveKeySha256(passphrase, salt, count, dkLen);

        byte[] testHmac = Crypto.calcHmacSha384(cipherKey, iv, cipherBytes);

        if (!MessageDigest.isEqual(mac, testHmac)) {
            throw new BadKeyException("HMAC mismatch; passphrase is incorrect");
        }

        return new Keystore(Crypto.decryptAesCtr128(cipherKey, iv, cipherBytes));
    }

    @SuppressFBWarnings(
        value = "DCN_NULLPOINTER_EXCEPTION",
        justification = "This control flow seems reasonable to me"
    )
    private static JsonObject expectObject(JsonObject object, String key) {
        try {
            return object.get(key).getAsJsonObject();
        } catch (ClassCastException | NullPointerException e) {
            throw new Error("expected key '" + key + "' to be an object", e);
        }
    }

    @SuppressFBWarnings(
        value = "DCN_NULLPOINTER_EXCEPTION",
        justification = "This control flow seems reasonable to me"
    )
    private static int expectInt(JsonObject object, String key) {
        try {
            return object.get(key).getAsInt();
        } catch (ClassCastException | NullPointerException e) {
            throw new Error("expected key '" + key + "' to be an integer", e);
        }
    }

    @SuppressFBWarnings(
        value = "DCN_NULLPOINTER_EXCEPTION",
        justification = "This control flow seems reasonable to me"
    )
    private static String expectString(JsonObject object, String key) {
        try {
            return object.get(key).getAsString();
        } catch (ClassCastException | NullPointerException e) {
            throw new Error("expected key '" + key + "' to be a string", e);
        }
    }

    /**
     * Get the decoded key from this keystore as an {@link PrivateKey}.
     *
     * @throws BadKeyException if the key bytes are of an incorrect length for a raw
     *                         private key or private key + public key, or do not represent a DER encoded Ed25519
     *                         private key.
     */
    public PrivateKey getEd25519() {
        return PrivateKey.fromBytes(keyBytes);
    }

    public void export(OutputStream outputStream, String passphrase) throws IOException {
        JsonWriter writer = new JsonWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
        gson.toJson(exportJson(passphrase), writer);
        writer.flush();
    }

    private JsonObject exportJson(String passphrase) {
        JsonObject object = new JsonObject();
        object.addProperty("version", 2);

        JsonObject crypto = new JsonObject();
        crypto.addProperty("cipher", "aes-128-ctr");
        crypto.addProperty("kdf", "pbkdf2");

        byte[] salt = Crypto.randomBytes(Crypto.SALT_LEN);

        KeyParameter cipherKey = Crypto.deriveKeySha256(passphrase, salt, Crypto.ITERATIONS, Crypto.DK_LEN);

        byte[] iv = Crypto.randomBytes(Crypto.IV_LEN);

        byte[] cipherBytes = Crypto.encryptAesCtr128(cipherKey, iv, keyBytes);

        byte[] mac = Crypto.calcHmacSha384(cipherKey, iv, cipherBytes);

        JsonObject cipherParams = new JsonObject();
        cipherParams.addProperty("iv", Hex.toHexString(iv));

        JsonObject kdfParams = new JsonObject();
        kdfParams.addProperty("dkLen", Crypto.DK_LEN);
        kdfParams.addProperty("salt", Hex.toHexString(salt));
        kdfParams.addProperty("c", Crypto.ITERATIONS);
        kdfParams.addProperty("prf", "hmac-sha256");

        crypto.add("cipherparams", cipherParams);
        crypto.addProperty("ciphertext", Hex.toHexString(cipherBytes));
        crypto.add("kdfparams", kdfParams);
        crypto.addProperty("mac", Hex.toHexString(mac));

        object.add("crypto", crypto);

        return object;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/LedgerId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import org.bouncycastle.util.encoders.Hex;

import javax.annotation.Nullable;
import java.util.Arrays;

/**
 * Internal utility class for ledger id manipulation.
 */
public class LedgerId {
    final private byte[] idBytes;

    /**
     * The mainnet ledger id
     */
    public final static LedgerId MAINNET = new LedgerId(new byte[]{0});

    /**
     * The testnet ledger id
     */
    public final static LedgerId TESTNET = new LedgerId(new byte[]{1});

    /**
     * The previewnet ledger id
     */
    public final static LedgerId PREVIEWNET = new LedgerId(new byte[]{2});

    /**
     * Constructor.
     *
     * @param idBytes                   the id (0=mainnet, 1=testnet, 2=previewnet, ...)
     */
    LedgerId(byte[] idBytes) {
        this.idBytes = idBytes;
    }

    /**
     * Assign the ledger id via a string name or Hex encoded String.
     *
     * @param string                    the string containing the ledger id
     * @return                          the ledger id
     */
    public static LedgerId fromString(String string) {
        switch (string) {
            case "mainnet":
                return MAINNET;
            case "testnet":
                return TESTNET;
            case "previewnet":
                return PREVIEWNET;
            default:
                return new LedgerId(Hex.decode(string));
        }
    }

    /**
     * Create a ledger id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the ledger id
     */
    public static LedgerId fromBytes(byte[] bytes) {
        return new LedgerId(bytes);
    }

    /**
     * Create a ledger id from a string.
     *
     * @param byteString                the string
     * @return                          the ledger id
     */
    static LedgerId fromByteString(ByteString byteString) {
        return fromBytes(byteString.toByteArray());
    }

    /**
     * Create a ledger id from a network name.
     *
     * @param networkName               the network name
     * @return                          the ledger id
     */
    @Deprecated
    public static LedgerId fromNetworkName(NetworkName networkName) {
        switch (networkName) {
            case MAINNET:
                return MAINNET;
            case TESTNET:
                return TESTNET;
            case PREVIEWNET:
                return PREVIEWNET;
            default:
                throw new IllegalArgumentException("networkName must be MAINNET, TESTNET, or PREVIEWNET");
        }
    }

    /**
     * Are we on Mionnet?
     *
     * @return                          is it mainnet
     */
    public boolean isMainnet() {
        return this.equals(MAINNET);
    }

    /**
     * Are we on Testnet?
     *
     * @return                          is it testnet
     */
    public boolean isTestnet() {
        return this.equals(TESTNET);
    }

    /**
     * Are we on Previewnet?
     *
     * @return                          is it previewnet
     */
    public boolean isPreviewnet() {
        return this.equals(PREVIEWNET);
    }

    /**
     * Are we one of the three standard networks?
     *
     * @return                          is it one of the three standard networks
     */
    boolean isKnownNetwork() {
        return isMainnet() || isTestnet() || isPreviewnet();
    }

    /**
     * Extract the string representation.
     *
     * @return                          the string representation
     */
    public String toString() {
        if (isMainnet()) {
            return "mainnet";
        } else if (isTestnet()) {
            return "testnet";
        } else if (isPreviewnet()) {
            return "previewnet";
        } else {
            return Hex.toHexString(idBytes);
        }
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return Arrays.copyOf(idBytes, idBytes.length);
    }

    /**
     * Extract the byte string representation.
     *
     * @return                          the byte string representation
     */
    ByteString toByteString() {
        return ByteString.copyFrom(idBytes);
    }

    /**
     * Extract the network name.
     *
     * @return                          the network name
     */
    @Deprecated
    public NetworkName toNetworkName() {
        if (isMainnet()) {
            return NetworkName.MAINNET;
        } else if (isTestnet()) {
            return NetworkName.TESTNET;
        } else if (isPreviewnet()) {
            return NetworkName.PREVIEWNET;
        } else {
            return NetworkName.OTHER;
        }
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof LedgerId)) {
            return false;
        }

        LedgerId otherId = (LedgerId) o;
        return Arrays.equals(idBytes, otherId.idBytes);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(idBytes);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/LiveHash.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import java.time.Duration;

/**
 *A hash (presumably of some kind of credential or certificate), along with a
 * list of keys (each of which is either a primitive or a threshold key). Each
 * of them must reach its threshold when signing the transaction, to attach
 * this livehash to this account. At least one of them must reach its
 * threshold to delete this livehash from this account.
 *
 * See <a href="https://docs.hedera.com/guides/core-concepts/accounts#livehash">Hedera Documentation</a>
 */
public class LiveHash {

    /**
     * The account to which the livehash is attached
     */
    public final AccountId accountId;

    /**
     * The SHA-384 hash of a credential or certificate
     */
    public final ByteString hash;

    /**
     * A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it.
     */
    public final KeyList keys;

    /**
     * The duration for which the livehash will remain valid
     */
    public final Duration duration;

    /**
     * Constructor.
     *
     * @param accountId                 the account id
     * @param hash                      the hash
     * @param keys                      the key list
     * @param duration                  the duration
     */
    private LiveHash(AccountId accountId, ByteString hash, KeyList keys, Duration duration) {
        this.accountId = accountId;
        this.hash = hash;
        this.keys = keys;
        this.duration = duration;
    }

    /**
     * Create a live hash from a protobuf.
     *
     * @param liveHash                  the protobuf
     * @return                          the new live hash
     */
    protected static LiveHash fromProtobuf(com.hedera.hashgraph.sdk.proto.LiveHash liveHash) {
        return new LiveHash(
            AccountId.fromProtobuf(liveHash.getAccountId()),
            liveHash.getHash(),
            KeyList.fromProtobuf(liveHash.getKeys(), null),
            DurationConverter.fromProtobuf(liveHash.getDuration())
        );
    }

    /**
     * Create a live hash from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new live hash
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static LiveHash fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.LiveHash.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Convert the live hash into a protobuf.
     *
     * @return                          the protobuf
     */
    protected com.hedera.hashgraph.sdk.proto.LiveHash toProtobuf() {
        var keyList = com.hedera.hashgraph.sdk.proto.KeyList.newBuilder();
        for (Key key : keys) {
            keyList.addKeys(key.toProtobufKey());
        }

        return com.hedera.hashgraph.sdk.proto.LiveHash.newBuilder()
            .setAccountId(accountId.toProtobuf())
            .setHash(hash)
            .setKeys(keyList)
            .setDuration(DurationConverter.toProtobuf(duration))
            .build();
    }

    /**
     * Extract the byte array.
     *
     * @return                          the byte array representation
     */
    public ByteString toBytes() {
        return toProtobuf().toByteString();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("accountId", accountId)
            .add("hash", hash.toByteArray())
            .add("keys", keys)
            .add("duration", duration)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/LiveHashAddTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoAddLiveHashTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.LiveHash;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * A hash---presumably of some kind of credential or certificate---along with a list of keys,
 * each of which may be either a primitive or a threshold key.
 */
public final class LiveHashAddTransaction extends Transaction<LiveHashAddTransaction> {
    @Nullable
    private AccountId accountId = null;
    private byte[] hash = {};
    @Nullable
    private KeyList keys = null;
    @Nullable
    private Duration duration = null;

    /**
     * Constructor.
     */
    public LiveHashAddTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    LiveHashAddTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * The account to which the livehash is attached
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public LiveHashAddTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the hash.
     *
     * @return                          the hash
     */
    public ByteString getHash() {
        return ByteString.copyFrom(hash);
    }

    /**
     * The SHA-384 hash of a credential or certificate.
     *
     * @param hash The array of bytes to be set as the hash
     * @return {@code this}
     */
    public LiveHashAddTransaction setHash(byte[] hash) {
        requireNotFrozen();
        Objects.requireNonNull(hash);
        this.hash = Arrays.copyOf(hash, hash.length);
        return this;
    }

    /**
     * The SHA-384 hash of a credential or certificate.
     *
     * @param hash The array of bytes to be set as the hash
     * @return {@code this}
     */
    public LiveHashAddTransaction setHash(ByteString hash) {
        Objects.requireNonNull(hash);
        return setHash(hash.toByteArray());
    }

    /**
     * Extract the key / key list.
     *
     * @return                          the key / key list
     */
    @Nullable
    public Collection<Key> getKeys() {
        return keys != null ? Collections.unmodifiableCollection(keys) : null;
    }

    /**
     * A list of keys (primitive or threshold), all of which must sign to attach the livehash to an
     * account, and any one of which can later delete it.
     *
     * @param keys The Key or Keys to be set
     * @return {@code this}
     */
    public LiveHashAddTransaction setKeys(Key... keys) {
        requireNotFrozen();

        this.keys = KeyList.of(keys);

        return this;
    }

    /**
     * Extract the duration.
     *
     * @return                          the duration
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getDuration() {
        return duration;
    }

    /**
     * The duration for which the livehash will remain valid
     *
     * @param duration The Duration to be set
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public LiveHashAddTransaction setDuration(Duration duration) {
        requireNotFrozen();
        Objects.requireNonNull(duration);
        this.duration = duration;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoAddLiveHash();
        var hashBody = body.getLiveHash();

        if (hashBody.hasAccountId()) {
            accountId = AccountId.fromProtobuf(hashBody.getAccountId());
        }
        hash = hashBody.getHash().toByteArray();
        if (hashBody.hasKeys()) {
            keys = KeyList.fromProtobuf(hashBody.getKeys(), null);
        }
        if (hashBody.hasDuration()) {
            duration = DurationConverter.fromProtobuf(hashBody.getDuration());
        }
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.CryptoAddLiveHashTransactionBody}
     */
    CryptoAddLiveHashTransactionBody.Builder build() {
        var builder = CryptoAddLiveHashTransactionBody.newBuilder();
        var hashBuilder = LiveHash.newBuilder();
        if (accountId != null) {
            hashBuilder.setAccountId(accountId.toProtobuf());
        }
        hashBuilder.setHash(ByteString.copyFrom(hash));
        if (keys != null) {
            hashBuilder.setKeys(keys.toProtobuf());
        }
        if (duration != null) {
            hashBuilder.setDuration(DurationConverter.toProtobuf(duration));
        }

        return builder.setLiveHash(hashBuilder);
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getAddLiveHashMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoAddLiveHash(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("Cannot schedule LiveHashAddTransaction");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/LiveHashDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoDeleteLiveHashTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * At consensus, deletes a livehash associated to the given account. The transaction must be signed
 * by either the key of the owning account, or at least one of the keys associated to the livehash.
 */
public final class LiveHashDeleteTransaction extends Transaction<LiveHashDeleteTransaction> {
    @Nullable
    private AccountId accountId = null;
    private byte[] hash = {};

    /**
     * Constructor.
     */
    public LiveHashDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    LiveHashDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * The account owning the livehash
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public LiveHashDeleteTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the hash.
     *
     * @return                          the hash
     */
    public ByteString getHash() {
        return ByteString.copyFrom(hash);
    }

    /**
     * The SHA-384 livehash to delete from the account
     *
     * @param hash The array of bytes to be set as hash
     * @return {@code this}
     */
    public LiveHashDeleteTransaction setHash(byte[] hash) {
        requireNotFrozen();
        Objects.requireNonNull(hash);
        this.hash = Arrays.copyOf(hash, hash.length);
        return this;
    }

    /**
     * The SHA-384 livehash to delete from the account
     *
     * @param hash The array of bytes to be set as hash
     * @return {@code this}
     */
    public LiveHashDeleteTransaction setHash(ByteString hash) {
        Objects.requireNonNull(hash);
        return setHash(hash.toByteArray());
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoDeleteLiveHash();
        if (body.hasAccountOfLiveHash()) {
            accountId = AccountId.fromProtobuf(body.getAccountOfLiveHash());
        }
        hash = body.getLiveHashToDelete().toByteArray();
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.CryptoAddLiveHashTransactionBody}
     */
    CryptoDeleteLiveHashTransactionBody.Builder build() {
        var builder = CryptoDeleteLiveHashTransactionBody.newBuilder();
        if (accountId != null) {
            builder.setAccountOfLiveHash(accountId.toProtobuf());
        }
        builder.setLiveHashToDelete(ByteString.copyFrom(hash));

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getDeleteLiveHashMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoDeleteLiveHash(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("Cannot schedule LiveHashDeleteTransaction");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/LiveHashQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.CryptoGetLiveHashQuery;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.Objects;

/**
 * Requests a livehash associated to an account.
 */
public final class LiveHashQuery extends Query<LiveHash, LiveHashQuery> {
    @Nullable
    private AccountId accountId = null;
    private byte[] hash = {};

    /**
     * Constructor.
     */
    public LiveHashQuery() {
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * The account to which the livehash is associated
     *
     * @param accountId The AccountId to be set
     * @return {@code this}
     */
    public LiveHashQuery setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the hash.
     *
     * @return                          the hash
     */
    public ByteString getHash() {
        return ByteString.copyFrom(hash);
    }

    /**
     * The SHA-384 data in the livehash
     *
     * @param hash The array of bytes to be set as hash
     * @return {@code this}
     */
    public LiveHashQuery setHash(byte[] hash) {
        this.hash = Arrays.copyOf(hash, hash.length);
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = CryptoGetLiveHashQuery.newBuilder();
        if (accountId != null) {
            builder.setAccountID(accountId.toProtobuf());
        }
        builder.setHash(ByteString.copyFrom(hash));

        queryBuilder.setCryptoGetLiveHash(builder.setHeader(header));
    }

    @Override
    LiveHash mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return LiveHash.fromProtobuf(response.getCryptoGetLiveHash().getLiveHash());
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getCryptoGetLiveHash().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getCryptoGetLiveHash().getHeader();
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getCryptoGetBalanceMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/LockableList.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.*;

/**
 * Internal utility class for a new lockable list type.
 *
 * @param <T>                           the lockable list type
 */
class LockableList<T> implements Iterable<T> {
    private ArrayList<T> list = new ArrayList<>();
    private int index = 0;
    private boolean locked = false;

    /**
     * Constructor.
     */
    LockableList() {
    }

    /**
     * Assign a list of items to this list instance.
     *
     * @param list                      the lockable list
     */
    LockableList(ArrayList<T> list) {
        this.list = list;
    }

    /**
     * Verify that this list instance is not locked.
     */
    void requireNotLocked() {
        if (locked) {
            throw new IllegalStateException("Cannot modify a locked list");
        }
    }

    /**
     * Make sure that this list instance has the requested capacity.
     *
     * @param capacity                  the minimum capacity
     * @return                          the updated list
     */
    LockableList<T> ensureCapacity(int capacity) {
        list.ensureCapacity(capacity);
        return this;
    }

    /**
     * Assign a list to this list instance.
     *
     * @param list                      the lockable list to assign
     * @return                          the updated list
     */
    LockableList<T> setList(List<T> list) {
        requireNotLocked();
        this.list = new ArrayList<>(list);
        this.index = 0;
        return this;
    }

    /**
     * Extract the lockable list.
     *
     * @return                          the lockable list
     */
    ArrayList<T> getList() {
        return list;
    }

    /**
     * Add items to this list instance.
     *
     * @param elements                  the items to add
     * @return                          the updated list
     */
    LockableList<T> add(T ...elements) {
        requireNotLocked();

        for (var e : elements) {
            list.add(e);
        }

        return this;
    }

    /**
     * Add all items to this list instance.
     *
     * @param elements                  the list of items to add
     * @return                          the updated list
     */
    LockableList<T> addAll(Collection<? extends T> elements) {
        requireNotLocked();

        list.addAll(elements);

        return this;
    }

    /**
     * Shuffle the list items.
     *
     * @return                          the updated list
     */
    public LockableList<T> shuffle() {
        requireNotLocked();

        Collections.shuffle(list);

        return this;
    }

    /**
     * Remove an item from this list instance.
     *
     * @param element                   the element to remove
     * @return                          the updated list
     */
    LockableList<T> remove(T element) {
        requireNotLocked();
        list.remove(element);
        return this;
    }

    /**
     * Extract the current list.
     *
     * @return                          the current list item
     */
    T getCurrent() {
        return get(index);
    }

    /**
     * Extract the next item.
     *
     * @return                          the next list item
     */
    T getNext() {
        return get(advance());
    }

    /**
     * Get a specific list item.
     *
     * @param index                     the index of the item
     * @return                          the item
     */
    T get(int index) {
        return list.get(index);
    }

    /**
     * Assign an item at the specified index.
     *
     * @param index                     the index of the item
     * @param item                      the item
     * @return                          the updated list
     */
    LockableList<T> set(int index, T item) {
        requireNotLocked();

        if (index == list.size()) {
            list.add(item);
        } else {
            list.set(index, item);
        }

        return this;
    }

    /**
     * Assign an item to the list if:
     * - item at index is null
     * - index is not greater than size of existing list
     *
     * @param index                     the requested index
     * @param item                      the item
     * @return                          the updated list
     */
    LockableList<T> setIfAbsent(int index, T item) {
        if (index == list.size() || list.get(index) == null) {
            set(index, item);
        }

        return this;
    }

    /**
     * Advance to the next item wraps if needed.
     *
     * @return                          the next index wrapped
     */
    int advance() {
        var index = this.index;
        this.index = (this.index + 1) % list.size();
        return index;
    }

    /**
     * Is the list empty?
     *
     * @return                          is the list empty
     */
    boolean isEmpty() {
        return list.isEmpty();
    }

    /**
     * Is the list locked?
     *
     * @return                          is the list locked
     */
    boolean isLocked() {
        return locked;
    }

    /**
     * Assign the lock status.
     *
     * @param locked                    the lock status
     * @return                          the updated list
     */
    LockableList<T> setLocked(boolean locked) {
        this.locked = locked;
        return this;
    }

    /**
     * How many items are in the list.
     *
     * @return                          the size of the list
     */
    int size() {
        return list.size();
    }

    /**
     * Assign the current list index.
     *
     * @param index                     the index
     * @return                          the updated list
     */
    LockableList<T> setIndex(int index) {
        this.index = index;
        return this;
    }

    /**
     * What is the current index.
     *
     * @return                          the index of the current item
     */
    int getIndex() {
        return index;
    }

    /**
     * Empty the list.
     *
     * @return                          an empty list
     */
    LockableList<T> clear() {
        requireNotLocked();
        list.clear();
        return this;
    }

    @Override
    public Iterator<T> iterator() {
        return list.iterator();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/MaxAttemptsExceededException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;

/**
 * Utility exception class.
 */
public class MaxAttemptsExceededException extends IllegalStateException {
    MaxAttemptsExceededException(@Nullable Throwable e) {
        super("exceeded maximum attempts for request with last exception being", e);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/MaxQueryPaymentExceededException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Signals that a query will cost more than a pre-configured maximum payment amount.
 */
public final class MaxQueryPaymentExceededException extends RuntimeException {
    /**
     * The cost of the query that was attempted as returned by {@link Query#getCost(Client)}.
     */
    public final Hbar queryCost;

    /**
     * The limit for a single automatic query payment, set by
     * {@link Client#setDefaultMaxQueryPayment(Hbar)} (Hbar)} or {@link Query#setMaxQueryPayment(Hbar)}.
     */
    public final Hbar maxQueryPayment;

    /**
     * Constructor.
     *
     * @param builder                   the query builder object
     * @param cost                      the query cost
     * @param maxQueryPayment           the maximum query payment
     */
    MaxQueryPaymentExceededException(Query<?, ?> builder, Hbar cost, Hbar maxQueryPayment) {
        super(String.format(
            "cost for %s, of %s, without explicit payment is greater than "
                + "the maximum allowed payment of %s",
            builder.getClass().getSimpleName(),
            cost,
            maxQueryPayment));

        this.queryCost = cost;
        this.maxQueryPayment = maxQueryPayment;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/MirrorNetwork.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeoutException;

/**
 * Utility class.
 */
class MirrorNetwork extends BaseNetwork<MirrorNetwork, BaseNodeAddress, MirrorNode> {
    private MirrorNetwork(ExecutorService executor, List<String> addresses) {
        super(executor);
        this.transportSecurity = true;
        try {
            setNetwork(addresses);
        } catch (InterruptedException | TimeoutException e) {
            // This should never occur. The network is empty.
        }
    }

    /**
     * Create an arbitrary mirror network.
     *
     * @param executor  the executor service
     * @param addresses the arbitrary address for the network
     * @return the new mirror network object
     */
    static MirrorNetwork forNetwork(ExecutorService executor, List<String> addresses) {
        return new MirrorNetwork(executor, addresses);
    }

    /**
     * Create a mirror network for mainnet.
     *
     * @param executor the executor service
     * @return the new mirror network for mainnet
     */
    static MirrorNetwork forMainnet(ExecutorService executor) {
        return new MirrorNetwork(executor, List.of("mainnet-public.mirrornode.hedera.com:443"));
    }

    /**
     * Create a mirror network for testnet.
     *
     * @param executor the executor service
     * @return the new mirror network for testnet
     */
    static MirrorNetwork forTestnet(ExecutorService executor) {
        return new MirrorNetwork(executor, List.of("testnet.mirrornode.hedera.com:443"));
    }

    /**
     * Create a mirror network for previewnet.
     *
     * @param executor the executor service
     * @return the new mirror network for previewnet
     */
    static MirrorNetwork forPreviewnet(ExecutorService executor) {
        return new MirrorNetwork(executor, List.of("previewnet.mirrornode.hedera.com:443"));
    }

    /**
     * Extract the network names.
     *
     * @return the network names
     */
    synchronized List<String> getNetwork() {
        List<String> retval = new ArrayList<>(network.size());
        for (var address : network.keySet()) {
            retval.add(address.toString());
        }
        return retval;
    }

    /**
     * Assign the desired network.
     *
     * @param network the desired network
     * @return the mirror network
     * @throws TimeoutException     when the transaction times out
     * @throws InterruptedException when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    synchronized MirrorNetwork setNetwork(List<String> network) throws TimeoutException, InterruptedException {
        var map = new HashMap<String, BaseNodeAddress>(network.size());
        for (var address : network) {
            map.put(address, BaseNodeAddress.fromString(address));
        }
        return super.setNetwork(map);
    }

    @Override
    protected MirrorNode createNodeFromNetworkEntry(Map.Entry<String, BaseNodeAddress> entry) {
        return new MirrorNode(entry.getKey(), executor);
    }

    /**
     * Extract the next healthy mirror node on the list.
     *
     * @return the next healthy mirror node on the list
     * @throws InterruptedException when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    synchronized MirrorNode getNextMirrorNode() throws InterruptedException {
        return getNumberOfMostHealthyNodes(1).get(0);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/MirrorNode.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.concurrent.ExecutorService;

/**
 * An individual mirror node.
 */
class MirrorNode extends BaseNode<MirrorNode, BaseNodeAddress> {
    /**
     * Constructor.
     *
     * @param address                   the node address as a managed node address
     * @param executor                  the executor service
     */
    MirrorNode(BaseNodeAddress address, ExecutorService executor) {
        super(address, executor);
    }

    /**
     * Constructor.
     *
     * @param address                   the node address as a string
     * @param executor                  the executor service
     */
    MirrorNode(String address, ExecutorService executor) {
        this(BaseNodeAddress.fromString(address), executor);
    }

    @Override
    protected String getAuthority() {
        return null;
    }

    @Override
    BaseNodeAddress getKey() {
        return address;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Mnemonic.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.Joiner;
import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.utils.Bip32Utils;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;
import org.bouncycastle.crypto.params.KeyParameter;

import javax.annotation.Nullable;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.ref.SoftReference;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * BIP-39 24-word mnemonic phrases compatible with the Android and iOS mobile wallets.
 */
public final class Mnemonic {
    // by storing our word list in a SoftReference, the GC is free to evict it at its discretion
    // but the implementation is meant to wait until free space is needed
    @Nullable
    private static SoftReference<List<String>> bip39WordList = null;
    @Nullable
    private static SoftReference<List<String>> legacyWordList = null;

    /**
     * The list of words in this mnemonic.
     */
    public final List<CharSequence> words;

    @Nullable
    private String asString;

    @SuppressWarnings("StaticAssignmentInConstructor")
    private Mnemonic(List<? extends CharSequence> words) {
        this.words = Collections.unmodifiableList(words);
    }

    /**
     * Construct a mnemonic from a 24-word list. {@link Mnemonic#validate()}
     * is called before returning, and it will throw an exception if it
     * does not pass validation. An invalid mnemonic can still create valid
     * Ed25519 private keys, so the exception will contain the mnemonic in case
     * the user wants to ignore the outcome of the validation.
     *
     * @param words the 24-word list that constitutes a mnemonic phrase.
     * @return {@code this}
     * @throws BadMnemonicException if the mnemonic does not pass validation.
     * @see #validate() the function that validates the mnemonic.
     */
    public static Mnemonic fromWords(List<? extends CharSequence> words) throws BadMnemonicException {
        Mnemonic mnemonic = new Mnemonic(words);

        if (words.size() != 22) {
            mnemonic.validate();
        }

        return mnemonic;
    }

    /**
     * Recover a mnemonic from a string, splitting on spaces.
     *
     * @param mnemonicString The string to recover the mnemonic from
     * @return {@code this}
     * @throws BadMnemonicException if the mnemonic does not pass validation.
     */
    public static Mnemonic fromString(String mnemonicString) throws BadMnemonicException {
        String toLowerCase = mnemonicString.toLowerCase();
        return Mnemonic.fromWords(Arrays.asList(toLowerCase.split(" ")));
    }

    /**
     * Returns a new random 24-word mnemonic from the BIP-39 standard English word list.
     *
     * @return {@code this}
     */
    public static Mnemonic generate24() {
        var entropy = new byte[32];
        ThreadLocalSecureRandom.current().nextBytes(entropy);

        return new Mnemonic(entropyToWords(entropy));
    }

    /**
     * Returns a new random 12-word mnemonic from the BIP-39 standard English word list.
     *
     * @return {@code this}
     */
    public static Mnemonic generate12() {
        var entropy = new byte[16];
        ThreadLocalSecureRandom.current().nextBytes(entropy);

        return new Mnemonic(entropyToWords(entropy));
    }

    private static List<String> entropyToWords(byte[] entropy) {
        if (entropy.length != 16 && entropy.length != 32) {
            throw new IllegalArgumentException("invalid entropy byte length: " + entropy.length);
        }

        // checksum for 256 bits is one byte
        List<String> wordList;
        ArrayList<String> words;
        byte[] bytes;
        if (entropy.length == 16) {
            wordList = getWordList(false);
            bytes = Arrays.copyOf(entropy, 17);
            bytes[16] = (byte) (checksum(entropy) & 0xF0);

            words = new ArrayList<>(12);
        } else {
            wordList = getWordList(false);
            bytes = Arrays.copyOf(entropy, 33);
            bytes[32] = checksum(entropy);

            words = new ArrayList<>(24);
        }
        @Var var scratch = 0;
        @Var var offset = 0;

        for (var b : bytes) {
            // shift `bytes` into `scratch`, popping off 11-bit indices when we can
            scratch <<= 8;
            // bitwise operations implicitly widen to `int` so mask off sign-extended bits
            scratch |= b & 0xFF;
            offset += 8;

            if (offset >= 11) {
                // pop 11 bits off the end of `scratch` and into `index`
                var index = (scratch >> (offset - 11)) & 0x7FF;
                offset -= 11;

                words.add(wordList.get(index));
            }
        }

        return words;
    }

    // hash the first 32 bytes of `entropy` and return the first byte of the digest
    private static byte checksum(byte[] entropy) {
        SHA256Digest digest = new SHA256Digest();
        // hash the first

        if (entropy.length == 17 || entropy.length == 16) {
            digest.update(entropy, 0, 16);
        } else {
            digest.update(entropy, 0, 32);
        }

        byte[] checksum = new byte[digest.getDigestSize()];
        digest.doFinal(checksum, 0);

        return checksum[0];
    }

    private static int getWordIndex(CharSequence word, boolean isLegacy) {
        var wordList = getWordList(isLegacy);
        @Var
        var found = -1;
        for (var i = 0; i < wordList.size(); i++) {
            if (word.toString().equals(wordList.get(i))) {
                found = i;
            }
        }
        return found;
    }

    private static List<String> getWordList(boolean isLegacy) {
        if (isLegacy) {
            return getSpecificWordList(
                () -> legacyWordList,
                () -> readWordList(true),
                (newWordList) -> legacyWordList = newWordList
            );
        } else {
            return getSpecificWordList(
                () -> bip39WordList,
                () -> readWordList(false),
                (newWordList) -> bip39WordList = newWordList
            );
        }
    }

    private static synchronized List<String> getSpecificWordList(
        Supplier<SoftReference<List<String>>> getCurrentWordList,
        Supplier<List<String>> getNewWordList,
        Consumer<SoftReference<List<String>>> setCurrentWordList
    ) {
        var localWordList = getCurrentWordList.get();
        if (localWordList == null || localWordList.get() == null) {
            List<String> words = getNewWordList.get();
            setCurrentWordList.accept(new SoftReference<>(words));
            // immediately return the strong reference
            return words;
        }

        return localWordList.get();
    }

    private static List<String> readWordList(boolean isLegacy) {
        if (isLegacy) {
            InputStream wordStream = Mnemonic.class.getClassLoader().getResourceAsStream("legacy-english.txt");
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(wordStream), UTF_8))) {
                ArrayList<String> words = new ArrayList<>(4096);

                for (String word = reader.readLine(); word != null; word = reader.readLine()) {
                    words.add(word);
                }
                return Collections.unmodifiableList(words);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        } else {
            InputStream wordStream = Mnemonic.class.getClassLoader().getResourceAsStream("bip39-english.txt");
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(wordStream), UTF_8))) {
                ArrayList<String> words = new ArrayList<>(2048);

                for (String word = reader.readLine(); word != null; word = reader.readLine()) {
                    words.add(word);
                }
                return Collections.unmodifiableList(words);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private static int[] convertRadix(int[] nums, int fromRadix, int toRadix, int toLength) {
        @Var BigInteger num = BigInteger.valueOf(0);
        for (int element : nums) {
            num = num.multiply(BigInteger.valueOf(fromRadix));
            num = num.add(BigInteger.valueOf(element));
        }

        var result = new int[toLength];
        for (@Var var i = toLength - 1; i >= 0; i -= 1) {
            BigInteger tem = num.divide(BigInteger.valueOf(toRadix));
            BigInteger rem = num.mod(BigInteger.valueOf(toRadix));
            num = tem;
            result[i] = rem.intValue();
        }

        return result;
    }

    private static int crc8(int[] data) {
        @Var var crc = 0xFF;

        for (var i = 0; i < data.length - 1; i += 1) {
            crc ^= data[i];
            for (var j = 0; j < 8; j += 1) {
                crc = (crc >>> 1) ^ (((crc & 1) == 0) ? 0 : 0xB2);
            }
        }

        return crc ^ 0xFF;
    }

    private static boolean[] bytesToBits(byte[] dat) {
        var bits = new boolean[dat.length * 8];
        Arrays.fill(bits, Boolean.FALSE);

        for (int i = 0; i < dat.length; i++) {
            for (int j = 0; j < 8; j++) {
                bits[(i * 8) + j] = (dat[i] & (1 << (7 - j))) != 0;
            }
        }

        return bits;
    }

    /**
     * @deprecated use {@link #toStandardEd25519PrivateKey(String, int)} ()} or {@link #toStandardECDSAsecp256k1PrivateKey(String, int)} (String, int)} instead
     * Recover a private key from this mnemonic phrase.
     * <p>
     * This is not compatible with the phrases generated by the Android and iOS wallets;
     * use the no-passphrase version instead.
     *
     * @param passphrase the passphrase used to protect the mnemonic
     * @return the recovered key; use {@link PrivateKey#derive(int)} to get a
     * key for an account index (0 for default account)
     * @see PrivateKey#fromMnemonic(Mnemonic, String)
     */
    @Deprecated
    public PrivateKey toPrivateKey(String passphrase) {
        return PrivateKey.fromMnemonic(this, passphrase);
    }

    /**
     * Extract the private key.
     *
     * @return the private key
     * @throws BadMnemonicException when there are issues with the mnemonic
     */
    public PrivateKey toLegacyPrivateKey() throws BadMnemonicException {
        if (this.words.size() == 22) {
            return PrivateKey.fromBytes(this.wordsToLegacyEntropy());
        }

        return PrivateKey.fromBytes(this.wordsToLegacyEntropy2());
    }

    /**
     * @deprecated use {@link #toStandardEd25519PrivateKey(String, int)} ()} or {@link #toStandardECDSAsecp256k1PrivateKey(String, int)} (String, int)} instead
     * Recover a private key from this mnemonic phrase.
     *
     * @return the recovered key; use
     * {@link PrivateKey#derive(int)} to get
     * a key for an account index (0 for
     * default account)
     * @see PrivateKey#fromMnemonic(Mnemonic)
     */
    @Deprecated
    public PrivateKey toPrivateKey() {
        return toPrivateKey("");
    }

    private void validate() throws BadMnemonicException {
        if (words.size() != 24 && words.size() != 12) {
            throw new BadMnemonicException(this, BadMnemonicReason.BadLength);
        }

        ArrayList<Integer> unknownIndices = new ArrayList<>();

        for (int i = 0; i < words.size(); i++) {
            if (getWordIndex(words.get(i), false) < 0) {
                unknownIndices.add(i);
            }
        }

        if (!unknownIndices.isEmpty()) {
            throw new BadMnemonicException(this, BadMnemonicReason.UnknownWords, unknownIndices);
        }

        if (words.size() != 22) {
            // test the checksum encoded in the mnemonic
            byte[] entropyAndChecksum = wordsToEntropyAndChecksum();
            // ignores the 33rd byte
            byte expectedChecksum;
            byte givenChecksum;

            if (words.size() == 12) {
                expectedChecksum = (byte) (checksum(entropyAndChecksum) & 0xF0);
                givenChecksum = entropyAndChecksum[16];
            } else {
                expectedChecksum = checksum(entropyAndChecksum);
                givenChecksum = entropyAndChecksum[32];
            }

            if (givenChecksum != expectedChecksum) {
                throw new BadMnemonicException(this, BadMnemonicReason.ChecksumMismatch);
            }
        }
    }

    @Override
    public String toString() {
        if (asString == null) {
            asString = Joiner.on(' ').join(words);
        }

        return asString;
    }

    /**
     * Convert passphrase to a byte array.
     *
     * @param passphrase the passphrase
     * @return the byte array
     */
    byte[] toSeed(String passphrase) {
        String salt = Normalizer.normalize("mnemonic" + passphrase, Normalizer.Form.NFKD);

        // BIP-39 seed generation
        PKCS5S2ParametersGenerator pbkdf2 = new PKCS5S2ParametersGenerator(new SHA512Digest());
        pbkdf2.init(
            toString().getBytes(UTF_8),
            salt.getBytes(UTF_8),
            2048);

        KeyParameter key = (KeyParameter) pbkdf2.generateDerivedParameters(512);
        return key.getKey();
    }

    private byte[] wordsToEntropyAndChecksum() {
        if (words.size() != 24 && words.size() != 12) {
            // should be checked in `validate()`
            throw new IllegalStateException(
                "(BUG) expected 24-word mnemonic, got " + words.size() + " words");
        }
        ByteBuffer buffer;
        if (words.size() == 12) {
            buffer = ByteBuffer.allocate(17);
        } else {
            buffer = ByteBuffer.allocate(33);
        }
        // reverse algorithm of `entropyToWords()` below
        @Var int scratch = 0;
        @Var int offset = 0;
        for (CharSequence word : words) {
            int index = getWordIndex(word, false);

            if (index < 0) {
                // should also be checked in `validate()`
                throw new IllegalStateException("(BUG) word not in word list: " + word);
            } else if (index > 0x7FF) {
                throw new IndexOutOfBoundsException("(BUG) index out of bounds: " + index);
            }

            scratch <<= 11;
            scratch |= index;
            offset += 11;

            while (offset >= 8) {
                // truncation is what we want here
                buffer.put((byte) (scratch >> (offset - 8)));
                offset -= 8;
            }
        }

        if (offset != 0) {
            buffer.put((byte) (scratch << offset));
        }

        return buffer.array();
    }

    private byte[] wordsToLegacyEntropy() throws BadMnemonicException {
        var indices = new int[words.size()];
        for (var i = 0; i < words.size(); i++) {
            indices[i] = getWordIndex(words.get(i), true);
        }
        var data = convertRadix(indices, 4096, 256, 33);
        var crc = data[data.length - 1];
        var result = new int[data.length - 1];
        for (var i = 0; i < data.length - 1; i += 1) {
            result[i] = data[i] ^ crc;
        }
        //int to byte conversion
        ByteBuffer byteBuffer = ByteBuffer.allocate(result.length * 4);
        IntBuffer intBuffer = byteBuffer.asIntBuffer();
        intBuffer.put(result);

        var crc2 = crc8(result);
        if (crc != crc2) {
            throw new BadMnemonicException(this, BadMnemonicReason.ChecksumMismatch);
        }

        byte[] array = byteBuffer.array();
        @Var var i = 0;
        @Var var j = 3;
        byte[] array2 = new byte[data.length - 1];
        //remove all the fill 0s
        while (j < array.length) {
            array2[i] = array[j];
            i++;
            j = j + 4;
        }

        return array2;
    }

    private byte[] wordsToLegacyEntropy2() throws BadMnemonicException {
        var concatBitsLen = this.words.size() * 11;
        var concatBits = new boolean[concatBitsLen];
        Arrays.fill(concatBits, Boolean.FALSE);

        for (int index = 0; index < this.words.size(); index++) {
            var nds = Collections.binarySearch(getWordList(false), this.words.get(index), null);

            for (int i = 0; i < 11; i++) {
                concatBits[(index * 11) + i] = (nds & (1 << (10 - i))) != 0;
            }
        }

        var checksumBitsLen = concatBitsLen / 33;
        var entropyBitsLen = concatBitsLen - checksumBitsLen;

        var entropy = new byte[entropyBitsLen / 8];

        for (int i = 0; i < entropy.length; i++) {
            for (int j = 0; j < 8; j++) {
                if (concatBits[(i * 8) + j]) {
                    entropy[i] |= (byte) (1 << (7 - j));
                }
            }
        }

        var digest = new SHA256Digest();
        byte[] hash = new byte[entropy.length];
        digest.update(entropy, 0, entropy.length);
        digest.doFinal(hash, 0);
        var hashBits = bytesToBits(hash);

        for (int i = 0; i < checksumBitsLen; i++) {
            if (concatBits[entropyBitsLen + i] != hashBits[i]) {
                throw new BadMnemonicException(this, BadMnemonicReason.ChecksumMismatch);
            }
        }

        return entropy;
    }

    /**
     * Recover an Ed25519 private key from this mnemonic phrase, with an
     * optional passphrase.
     *
     * @param passphrase    the passphrase used to protect the mnemonic
     * @param index         the derivation index
     * @return the private key
     */
    public PrivateKey toStandardEd25519PrivateKey(String passphrase, int index) {
        var seed = this.toSeed(passphrase);
        PrivateKey derivedKey = PrivateKey.fromSeedED25519(seed);

        for (int i : new int[]{44, 3030, 0, 0, index}) {
            derivedKey = derivedKey.derive(i);
        }

        return derivedKey;
    }

    /**
     * Converts a derivation path from string to an array of integers.
     * Note that this expects precisely 5 components in the derivation path,
     * as per BIP-44:
     * `m / purpose' / coin_type' / account' / change / address_index`
     * Takes into account `'` for hardening as per BIP-32,
     * and does not prescribe which components should be hardened.
     *
     * @param derivationPath  the derivation path in BIP-44 format,
     *                        e.g. "m/44'/60'/0'/0/0"
     * @return an array of integers designed to be used with PrivateKey#derive
     */
    private int[] calculateDerivationPathValues(String derivationPath)
        throws IllegalArgumentException
    {
        if (derivationPath == null || derivationPath.isEmpty()) {
            throw new IllegalArgumentException("Derivation path cannot be null or empty");
        }

        // Parse the derivation path from string into values
        Pattern pattern = Pattern.compile("m/(\\d+'?)/(\\d+'?)/(\\d+'?)/(\\d+'?)/(\\d+'?)");
        Matcher matcher = pattern.matcher(derivationPath);
        if (!matcher.matches()) {
            throw new IllegalArgumentException("Invalid derivation path format");
        }

        int[] numbers = new int[5];
        boolean[] isHardened = new boolean[5];
        try {
            // Extract numbers and use apostrophe to select if is hardened
            for (int i = 1; i <= 5; i++) {
                String value = matcher.group(i);
                if (value.endsWith("'")) {
                    isHardened[i - 1] = true;
                    value = value.substring(0, value.length() - 1);
                } else {
                    isHardened[i - 1] = false;
                }
                numbers[i - 1] = Integer.parseInt(value);
            }
        } catch (NumberFormatException nfe) {
            throw new IllegalArgumentException("Invalid number format in derivation path", nfe);
        }

        // Derive private key one index at a time
        int[] values = new int[5];
        for (int i = 0; i < numbers.length; i++) {
            values[i] = (isHardened[i] ? Bip32Utils.toHardenedIndex(numbers[i]) : numbers[i]);
        }

        return values;
    }

    /**
     * Common implementation for both `toStandardECDSAsecp256k1PrivateKey`
     * functions.
     *
     * @param passphrase            the passphrase used to protect the
     *                              mnemonic, use "" for none
     * @param derivationPathValues  derivation path as an integer array,
     *                              see: `calculateDerivationPathValues`
     * @return a private key
     */
    private PrivateKey toStandardECDSAsecp256k1PrivateKeyImpl(String passphrase, int[] derivationPathValues) {
        var seed = this.toSeed(passphrase);
        PrivateKey derivedKey = PrivateKey.fromSeedECDSAsecp256k1(seed);

        for (int derivationPathValue : derivationPathValues) {
            derivedKey = derivedKey.derive(derivationPathValue);
        }
        return derivedKey;
    }

    /**
     * Recover an ECDSAsecp256k1 private key from this mnemonic phrase, with an
     * optional passphrase.
     * Uses the default derivation path of `m/44'/3030'/0'/0/${index}`.
     *
     * @param passphrase    the passphrase used to protect the mnemonic,
     *                      use "" for none
     * @param index         the derivation index
     * @return the private key
     */
    public PrivateKey toStandardECDSAsecp256k1PrivateKey(String passphrase, int index) {
        // Harden the first 3 indexes
        final int[] derivationPathValues = new int[]{
            Bip32Utils.toHardenedIndex(44),
            Bip32Utils.toHardenedIndex(3030),
            Bip32Utils.toHardenedIndex(0),
            0,
            index
        };
        return toStandardECDSAsecp256k1PrivateKeyImpl(passphrase, derivationPathValues);
    }

    /**
     * Recover an ECDSAsecp256k1 private key from this mnemonic phrase and
     * derivation path, with an optional passphrase.
     *
     * @param passphrase      the passphrase used to protect the mnemonic,
     *                        use "" for none
     * @param derivationPath  the derivation path in BIP-44 format,
     *                        e.g. "m/44'/60'/0'/0/0"
     * @return the private key
     */
    public PrivateKey toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(String passphrase, String derivationPath) {
        final int[] derivationPathValues = calculateDerivationPathValues(derivationPath);
        return toStandardECDSAsecp256k1PrivateKeyImpl(passphrase, derivationPathValues);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Network.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.io.ByteStreams;
import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeoutException;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

/**
 * Internal utility class.
 */
class Network extends BaseNetwork<Network, AccountId, Node> {
    @Nullable
    private Integer maxNodesPerRequest;

    /**
     * The protobuf address book converted into a map of node account IDs to NodeAddress
     *
     * This variable is package private so tests can use it
     */
    @Nullable
    Map<AccountId, NodeAddress> addressBook;

    private boolean verifyCertificates = true;

    private Network(ExecutorService executor, Map<String, AccountId> network) {
        super(executor);

        try {
            setNetwork(network);
        } catch (InterruptedException | TimeoutException e) {
            // This should never occur. The network is empty.
        }
    }

    /**
     * Create a network.
     *
     * @param executor                  the executor service
     * @param network                   the network records
     * @return                          the new network
     */
    static Network forNetwork(ExecutorService executor, Map<String, AccountId> network) {
        return new Network(executor, network);
    }

    /**
     * Create a mainnet network.
     *
     * @param executor                  the executor service
     * @return                          the new mainnet network
     */
    static Network forMainnet(ExecutorService executor) {
        var addressBook = getAddressBookForLedger(LedgerId.MAINNET);
        HashMap<String, AccountId> network = addressBookToNetwork(
            Objects.requireNonNull(addressBook).values());
        return new Network(executor, network).setLedgerIdInternal(LedgerId.MAINNET, addressBook);
    }

    /**
     * Create a testnet network.
     *
     * @param executor                  the executor service
     * @return                          the new testnet network
     */
    static Network forTestnet(ExecutorService executor) {
        var addressBook = getAddressBookForLedger(LedgerId.TESTNET);
        HashMap<String, AccountId> network = addressBookToNetwork(
            Objects.requireNonNull(addressBook).values());
        return new Network(executor, network).setLedgerIdInternal(LedgerId.TESTNET, addressBook);
    }

    /**
     * Create a previewnet network.
     *
     * @param executor                  the executor service
     * @return                          the new previewnet network
     */
    static Network forPreviewnet(ExecutorService executor) {
        var addressBook = getAddressBookForLedger(LedgerId.PREVIEWNET);
        HashMap<String, AccountId> network = addressBookToNetwork(
            Objects.requireNonNull(addressBook).values());
        return new Network(executor, network).setLedgerIdInternal(LedgerId.PREVIEWNET, addressBook);
    }

    /**
     * Are certificates being verified?
     *
     * @return                          are certificates being verified
     */
    boolean isVerifyCertificates() {
        return verifyCertificates;
    }

    /**
     * Assign the desired verify certificate status.
     *
     * @param verifyCertificates        the desired status
     * @return {@code this}
     */
    synchronized Network setVerifyCertificates(boolean verifyCertificates) {
        this.verifyCertificates = verifyCertificates;

        for (var node : nodes) {
            node.setVerifyCertificates(verifyCertificates);
        }

        return this;
    }

    @Override
    synchronized Network setLedgerId(@Nullable LedgerId ledgerId) {
        return setLedgerIdInternal(ledgerId, getAddressBookForLedger(ledgerId));
    }

    private Network setLedgerIdInternal(@Nullable LedgerId ledgerId, @Nullable Map<AccountId, NodeAddress> addressBook) {
        super.setLedgerId(ledgerId);

        this.addressBook = addressBook;
        for (var node : nodes) {
            node.setAddressBookEntry(addressBook == null ? null : addressBook.get(node.getAccountId()));
        }

        return this;
    }

    void setAddressBook(NodeAddressBook addressBook) {
        Map<AccountId, NodeAddress> newAddressBook = addressBook.getNodeAddresses().stream()
            .filter(nodeAddress -> Objects.nonNull(nodeAddress.getAccountId()))
            .collect(Collectors.toMap(NodeAddress::getAccountId, Function.identity(),
                /*
                * Here we index by AccountId ignoring any subsequent entries with the same AccountId.
                *
                * Currently, this seems to be needed when reloading predefined address book for testnet which contains
                * multiple entries with the same AccountId.
                *
                * If it becomes necessary to better handle such cases, either the one-to-one mapping from AccountId to
                * single NodeAddress should be abandoned or NodeAddresses with the same AccountId may need to be merged.
                * */
                (a, b) -> a));
        /*
        * Here we preserve the certificate hash in the case where one is previously defined and no new one is provided.
        *
        * Currently, this seems to be needed since the downloaded address book lacks the certificate hash. However,
        * it is expected the certificate hash will be provided in the future in which case this workaround will no
        * longer be necessary.
        * */
        if (null != this.addressBook) {
            for (Map.Entry<AccountId, NodeAddress> entry : newAddressBook.entrySet()) {
                NodeAddress previous = this.addressBook.get(entry.getKey());
                if (null != previous) {
                    ByteString certHash = entry.getValue().getCertHash();
                    if (null == certHash || certHash.isEmpty()) {
                        entry.getValue().setCertHash(previous.certHash);
                    }
                }
            }
        }
        this.addressBook = newAddressBook;
        for (var node : nodes) {
            node.setAddressBookEntry(this.addressBook.get(node.getAccountId()));
        }
    }

    @Nullable
    private static Map<AccountId, NodeAddress> getAddressBookForLedger(@Nullable LedgerId ledgerId) {
        return (ledgerId == null || !ledgerId.isKnownNetwork()) ?
            null :
            readAddressBookResource("addressbook/" + ledgerId + ".pb");
    }

    static HashMap<String, AccountId> addressBookToNetwork(Collection<NodeAddress> addressBook) {
        var network = new HashMap<String, AccountId>();
        for (var nodeAddress : addressBook) {
            for (var endpoint : nodeAddress.addresses) {
                    network.put(endpoint.toString(), nodeAddress.accountId);
            }
        }
        return network;
    }

    /**
     * Import an address book.
     *
     * @param fileName                  the file name
     * @return                          the list of address book records
     */
    static Map<AccountId, NodeAddress> readAddressBookResource(String fileName) {
        try (var inputStream = Objects.requireNonNull(Network.class.getResource("/" + fileName)).openStream()) {
            var contents = ByteStreams.toByteArray(inputStream);
            var nodeAddressBook = NodeAddressBook.fromBytes(ByteString.copyFrom(contents));
            var map = new HashMap<AccountId, NodeAddress>();

            for (var nodeAddress : nodeAddressBook.nodeAddresses) {
                if (nodeAddress.accountId == null) {
                    continue;
                }

                map.put(nodeAddress.accountId, nodeAddress);
            }

            return map;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Extract the of network records.
     *
     * @return                          list of network records
     */
    synchronized Map<String, AccountId> getNetwork() {
        Map<String, AccountId> returnMap = new HashMap<>();
        for (var node : nodes) {
            returnMap.put(node.address.toString(), node.getAccountId());
        }
        return returnMap;
    }

    @Override
    protected Node createNodeFromNetworkEntry(Map.Entry<String, AccountId> entry) {
        return new Node(entry.getValue(), entry.getKey(), executor)
            .setVerifyCertificates(verifyCertificates);
    }

    /**
     * Pick 1/3 of the nodes sorted by health and expected delay from the network.
     * This is used by Query and Transaction for selecting node AccountId's.
     *
     * @return {@link java.util.List<com.hedera.hashgraph.sdk.AccountId>}
     */
    synchronized List<AccountId> getNodeAccountIdsForExecute() throws InterruptedException {
        var nodes = getNumberOfMostHealthyNodes(getNumberOfNodesForRequest());
        var nodeAccountIds = new ArrayList<AccountId>(nodes.size());

        for (var node : nodes) {
            nodeAccountIds.add(node.getAccountId());
        }

        return nodeAccountIds;
    }

    /**
     * Assign the maximum nodes to be returned for each request.
     *
     * @param maxNodesPerRequest        the desired number of nodes
     * @return {@code this}
     */
    Network setMaxNodesPerRequest(int maxNodesPerRequest) {
        this.maxNodesPerRequest = maxNodesPerRequest;
        return this;
    }

    /**
     * Extract the number of nodes for each request.
     *
     * @return                          the number of nodes for each request
     */
    int getNumberOfNodesForRequest() {
        if (maxNodesPerRequest != null) {
            return Math.min(maxNodesPerRequest, network.size());
        } else {
            return (network.size() + 3 - 1) / 3;
        }
    }

    private List<Node> getNodesForKey(AccountId key) {
        if (network.containsKey(key)) {
            return network.get(key);
        } else {
            var newList = new ArrayList<Node>();
            network.put(key, newList);
            return newList;
        }
    }

    /**
     * Enable or disable transport security (TLS).
     *
     * @param transportSecurity         should transport security be enabled
     * @return {@code this}
     * @throws InterruptedException     when a thread is interrupted while it's waiting, sleeping, or otherwise occupied
     */
    synchronized Network setTransportSecurity(boolean transportSecurity) throws InterruptedException {
        if (this.transportSecurity != transportSecurity) {
            network.clear();

            for (int i = 0; i < nodes.size(); i++) {
                @Var var node = nodes.get(i);
                node.close(closeTimeout);

                node = transportSecurity ? node.toSecure() : node.toInsecure();

                nodes.set(i, node);
                getNodesForKey(node.getKey()).add(node);
            }
        }

        healthyNodes = new ArrayList<>(nodes);

        this.transportSecurity = transportSecurity;

        return this;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NetworkName.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Enum for the network names.
 */
@Deprecated
public enum NetworkName {
    /**
     * The mainnet network
     */
    @Deprecated
    MAINNET(0),
    /**
     * The testnet network
     */
    @Deprecated
    TESTNET(1),
    /**
     * The previewnet network
     */
    @Deprecated
    PREVIEWNET(2),
    /**
     * Other network
     */
    @Deprecated
    OTHER(Integer.MAX_VALUE);

    final int id;

    NetworkName(int id) {
        this.id = id;
    }

    /**
     * Assign the network name via a string name.
     *
     * @param networkName               the string containing the network name
     * @return                          the ledger id
     */
    public static NetworkName fromString(String networkName) {
        switch (networkName) {
            case "mainnet":
                return NetworkName.MAINNET;
            case "testnet":
                return NetworkName.TESTNET;
            case "previewnet":
                return NetworkName.PREVIEWNET;
            default:
                throw new IllegalArgumentException("The only supported network names are 'mainnet', 'testnet', and 'previewnet'");
        }
    }

    @Override
    public String toString() {
        switch (this) {
            case MAINNET:
                return "mainnet";
            case TESTNET:
                return "testnet";
            case PREVIEWNET:
                return "previewnet";
            default:
                throw new IllegalStateException("(BUG) `NetworkName.toString()` switch is non-exhaustive");
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NetworkVersionInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.NetworkGetVersionInfoResponse;

/**
 * Internal utility class.
 */
public class NetworkVersionInfo {
    /**
     * Version of the protobuf schema in use by the network
     */
    public final SemanticVersion protobufVersion;

    /**
     * Version of the Hedera services in use by the network
     */
    public final SemanticVersion servicesVersion;

    /**
     * Constructor.
     *
     * @param hapi                      the protobuf version
     * @param hedera                    the hedera version
     */
    NetworkVersionInfo(SemanticVersion hapi, SemanticVersion hedera) {
        this.protobufVersion = hapi;
        this.servicesVersion = hedera;
    }

    /**
     * Create a network version info object from a protobuf.
     *
     * @param proto                     the protobuf
     * @return                          the new network version object
     */
    protected static NetworkVersionInfo fromProtobuf(NetworkGetVersionInfoResponse proto) {
        return new NetworkVersionInfo(
            SemanticVersion.fromProtobuf(proto.getHapiProtoVersion()),
            SemanticVersion.fromProtobuf(proto.getHederaServicesVersion())
        );
    }

    /**
     * Create a network version info object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new network version object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static NetworkVersionInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(NetworkGetVersionInfoResponse.parseFrom(bytes));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    protected NetworkGetVersionInfoResponse toProtobuf() {
        return NetworkGetVersionInfoResponse.newBuilder()
            .setHapiProtoVersion(protobufVersion.toProtobuf())
            .setHederaServicesVersion(servicesVersion.toProtobuf())
            .build();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NetworkVersionInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.NetworkGetVersionInfoQuery;
import com.hedera.hashgraph.sdk.proto.NetworkServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;

/**
 * Information about the versions of protobuf and hedera.
 */
public class NetworkVersionInfoQuery extends Query<NetworkVersionInfo, NetworkVersionInfoQuery> {
    /**
     * Constructor.
     */
    public NetworkVersionInfoQuery() {
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        queryBuilder.setNetworkGetVersionInfo(NetworkGetVersionInfoQuery.newBuilder().setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getNetworkGetVersionInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getNetworkGetVersionInfo().getHeader();
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        // do nothing
    }

    @Override
    NetworkVersionInfo mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return NetworkVersionInfo.fromProtobuf(response.getNetworkGetVersionInfo());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return NetworkServiceGrpc.getGetVersionInfoMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NftId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.NftID;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.Objects;

/**
 * The (non-fungible) token of which this NFT is an instance
 */
public class NftId implements Comparable<NftId> {
    /**
     * The (non-fungible) token of which this NFT is an instance
     */
    public final TokenId tokenId;

    /**
     * The unique identifier of this instance
     */
    @Nonnegative
    public final long serial;

    /**
     * Constructor.
     *
     * @param tokenId                   the token id
     * @param serial                    the serial number
     */
    public NftId(TokenId tokenId, @Nonnegative long serial) {
        this.tokenId = Objects.requireNonNull(tokenId);
        this.serial = serial;
    }

    /**
     * Create a new nft id from a string.
     *
     * @param id                        the string representation
     * @return                          the new nft id
     */
    public static NftId fromString(String id) {
        @SuppressWarnings("StringSplitter")
        var parts = id.split("[/@]");
        if (parts.length != 2) {
            throw new IllegalArgumentException("Expecting {shardNum}.{realmNum}.{idNum}-{checksum}/{serialNum}");
        }
        return new NftId(TokenId.fromString(parts[0]), Long.parseLong(parts[1]));
    }

    /**
     * Create a new ntf id from a protobuf.
     *
     * @param nftId                     the protobuf representation
     * @return                          the new nft id
     */
    static NftId fromProtobuf(NftID nftId) {
        Objects.requireNonNull(nftId);
        var tokenId = nftId.getTokenID();
        return new NftId(TokenId.fromProtobuf(tokenId), nftId.getSerialNumber());
    }

    /**
     * Create a new nft id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new nft id
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static NftId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(NftID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create the protobuf.
     *
     * @return                          a protobuf representation
     */
    NftID toProtobuf() {
        return NftID.newBuilder()
            .setTokenID(tokenId.toProtobuf())
            .setSerialNumber(serial)
            .build();
    }

    /**
     * Create the byte array.
     *
     * @return                          a byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return tokenId.toString() + "/" + serial;
    }

    /**
     * Generate a string representation with checksum.
     *
     * @param client                    the configured client
     * @return                          the string representation with checksum
     */
    public String toStringWithChecksum(Client client) {
        return tokenId.toStringWithChecksum(client) + "/" + serial;
    }

    @Override
    public int hashCode() {
        return Objects.hash(tokenId.shard, tokenId.realm, tokenId.num, serial);
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof NftId)) {
            return false;
        }

        NftId otherId = (NftId) o;
        return tokenId.equals(otherId.tokenId) && serial == otherId.serial;
    }

    @Override
    public int compareTo(NftId o) {
        Objects.requireNonNull(o);
        int tokenComparison = tokenId.compareTo(o.tokenId);
        if (tokenComparison != 0) {
            return tokenComparison;
        }
        return Long.compare(serial, o.serial);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Node.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.grpc.ChannelCredentials;
import io.grpc.TlsChannelCredentials;

import javax.annotation.Nullable;
import java.util.concurrent.ExecutorService;

/**
 * Internal utility class.
 */
class Node extends BaseNode<Node, AccountId> {
    private final AccountId accountId;

    // This kind of shadows the address field inherited from BaseNode.
    // This is only needed for the cert hash
    @Nullable
    private NodeAddress addressBookEntry;

    private boolean verifyCertificates;

    /**
     * Constructor.
     *
     * @param accountId                 the account id
     * @param address                   the address as a managed node address
     * @param executor                  the executor service
     */
    Node(AccountId accountId, BaseNodeAddress address, ExecutorService executor) {
        super(address, executor);

        this.accountId = accountId;
    }

    /**
     * Constructor.
     * @param accountId                 the account id
     * @param address                   the address as a string
     * @param executor                  the executor service
     */
    Node(AccountId accountId, String address, ExecutorService executor) {
        this(accountId, BaseNodeAddress.fromString(address), executor);
    }

    /**
     * Constructor for a node that verifies certificates.
     *
     * @param node                      the node
     * @param address                   the address as a managed node address
     */
    Node(Node node, BaseNodeAddress address) {
        super(node, address);

        this.accountId = node.accountId;
        this.verifyCertificates = node.verifyCertificates;
        this.addressBookEntry = node.addressBookEntry;
    }

    /**
     * Create an insecure version of this node
     *
     * @return                          the insecure version of the node
     */
    Node toInsecure() {
        return new Node(this, address.toInsecure());
    }

    /**
     * Create a secure version of this node
     *
     * @return                          the secure version of the node
     */
    Node toSecure() {
        return new Node(this, address.toSecure());
    }

    @Override
    AccountId getKey() {
        return accountId;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    AccountId getAccountId() {
        return accountId;
    }

    /**
     * Extract the address book.
     *
     * @return                          the address book
     */
    NodeAddress getAddressBookEntry() {
        return addressBookEntry;
    }

    /**
     * Assign the address book.
     *
     * @param addressBookEntry               the address book
     * @return {@code this}
     */
    Node setAddressBookEntry(@Nullable NodeAddress addressBookEntry) {
        this.addressBookEntry = addressBookEntry;
        return this;
    }

    /**
     * Are the certificates being verified?
     *
     * @return                          are the certificates being verified
     */
    boolean isVerifyCertificates() {
        return verifyCertificates;
    }

    /**
     * Assign the certificate status.
     *
     * @param verifyCertificates        should certificates be verified
     * @return {@code this}
     */
    Node setVerifyCertificates(boolean verifyCertificates) {
        this.verifyCertificates = verifyCertificates;
        return this;
    }

    @Override
    ChannelCredentials getChannelCredentials() {
        return TlsChannelCredentials.newBuilder()
            .trustManager(new HederaTrustManager(addressBookEntry == null ? null : addressBookEntry.certHash, verifyCertificates))
            .build();
    }

    @Override
    public String toString() {
        return address.toString() + "->" + accountId.toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NodeAddress.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ServiceEndpoint;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

import javax.annotation.Nullable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * The metadata for a Node  including IP Address, and the crypto account associated with the Node.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/nodeaddress">Hedera Documentation</a>
 */
public class NodeAddress implements Cloneable {
    /**
     * The RSA public key of the node.
     */
    @Nullable
    String publicKey;
    /**
     * The account to be paid for queries and transactions sent to this node.
     */
    @Nullable
    AccountId accountId;
    /**
     * A non-sequential identifier for the node.
     */
    long nodeId;
    /**
     * A hash of the X509 cert used for gRPC traffic to this node.
     */
    @Nullable
    ByteString certHash;
    /**
     * A node's service IP addresses and ports.
     */
    List<Endpoint> addresses = Collections.emptyList();
    /**
     * A description of the node, with UTF-8 encoding up to 100 bytes.
     */
    @Nullable
    String description = null;
    /**
     * The amount of tinybars staked to the node.
     */
    long stake;

    /**
     * Constructor.
     */
    NodeAddress() {
    }

    /**
     * Create a node from a protobuf.
     *
     * @param nodeAddress               the protobuf
     * @return                          the new node
     */
    static NodeAddress fromProtobuf(com.hedera.hashgraph.sdk.proto.NodeAddress nodeAddress) {
        var address = new ArrayList<Endpoint>(nodeAddress.getServiceEndpointCount());

        if (!nodeAddress.getIpAddress().isEmpty()) {
            address.add(
                Endpoint.fromProtobuf(ServiceEndpoint.newBuilder()
                    .setIpAddressV4(nodeAddress.getIpAddress())
                    .setPort(nodeAddress.getPortno())
                    .build())
            );
        }

        for (var endpoint : nodeAddress.getServiceEndpointList()) {
            address.add(Endpoint.fromProtobuf(endpoint));
        }

        var node = new NodeAddress()
            .setPublicKey(nodeAddress.getRSAPubKey())
            .setNodeId(nodeAddress.getNodeId())
            .setCertHash(nodeAddress.getNodeCertHash())
            .setAddresses(address)
            .setDescription(nodeAddress.getDescription())
            .setStake(nodeAddress.getStake());

        if (nodeAddress.hasNodeAccountId()) {
            node.setAccountId(AccountId.fromProtobuf(nodeAddress.getNodeAccountId()));
        }

        return node;
    }

    /**
     * Extract the public key.
     *
     * @return                          the public key
     */
    @Nullable
    public String getPublicKey() {
        return publicKey;
    }

    /**
     * Assign the public key.
     *
      * @param publicKey                the public key
     * @return {@code this}
     */
    public NodeAddress setPublicKey(String publicKey) {
        this.publicKey = publicKey;
        return this;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public NodeAddress setAccountId(AccountId accountId) {
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the node id.
     *
      * @return                         the node id
     */
    public long getNodeId() {
        return nodeId;
    }

    /**
     * Assign the node id.
     *
     * @param nodeId                    the node id
     * @return {@code this}
     */
    public NodeAddress setNodeId(long nodeId) {
        this.nodeId = nodeId;
        return this;
    }

    /**
     * Extract the certificate hash.
     *
     * @return                          the certificate hash
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A ByteString can't actually be mutated"
    )
    public ByteString getCertHash() {
        return certHash;
    }

    /**
     * Assign the certificate hash.
     *
     * @param certHash                  the certificate hash
     * @return {@code this}
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A ByteString can't actually be mutated"
    )
    public NodeAddress setCertHash(ByteString certHash) {
        this.certHash = certHash;
        return this;
    }

    /**
     * Extract the list of addresses.
     *
     * @return                          the list of addresses
     */
    public List<Endpoint> getAddresses() {
        return cloneEndpoints(addresses);
    }

    /**
     * Assign the list of addresses.
     *
     * @param addresses                 the list of addresses
     * @return {@code this}
     */
    public NodeAddress setAddresses(List<Endpoint> addresses) {
        this.addresses = cloneEndpoints(addresses);
        return this;
    }

    static List<Endpoint> cloneEndpoints(List<Endpoint> endpoints) {
        List<Endpoint> cloneEndpoints = new ArrayList<>(endpoints.size());
        for (var endpoint : endpoints) {
            cloneEndpoints.add(endpoint.clone());
        }
        return cloneEndpoints;
    }

    /**
     * Extract the description.
     *
     * @return                          the description
     */
    @Nullable
    public String getDescription() {
        return description;
    }

    /**
     * Assign the description.
     *
     * @param description               the description
     * @return {@code this}
     */
    public NodeAddress setDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Extract the tiny stake.
     *
     * @return                          the tiny stake
     */
    public long getStake() {
        return stake;
    }

    /**
     * Assign the tiny bar stake.
     *
     * @param stake                     the tiny bar stake
     * @return {@code this}
     */
    public NodeAddress setStake(long stake) {
        this.stake = stake;
        return this;
    }

    /**
     * Convert the node address object into a protobuf.
     *
     * @return                          the protobuf representation.
     */
    com.hedera.hashgraph.sdk.proto.NodeAddress toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.NodeAddress.newBuilder()
            .setNodeId(nodeId);

        if (certHash != null) {
            builder.setNodeCertHash(certHash);
        }

        if (publicKey != null) {
            builder.setRSAPubKey(publicKey);
        }

        if (accountId != null) {
            builder.setNodeAccountId(accountId.toProtobuf());
        }

        if (description != null) {
            builder.setDescription(description);
        }

        for (var address : addresses) {
            builder.addServiceEndpoint(address.toProtobuf());
        }

        return builder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("publicKey", publicKey)
            .add("accountId", accountId)
            .add("nodeId", nodeId)
            .add("certHash", certHash != null ? new String(certHash.toByteArray(), StandardCharsets.UTF_8) : null)
            .add("addresses", addresses)
            .add("description", description)
            .add("stake", stake)
            .toString();
    }

    @Override
    public NodeAddress clone() {
        try {
            NodeAddress clone = (NodeAddress) super.clone();
            clone.addresses = cloneEndpoints(addresses);
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NodeAddressBook.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * A list of nodes and their metadata.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/nodeaddressbook">Hedera Documentation</a>
 */
public class NodeAddressBook {
    List<NodeAddress> nodeAddresses = Collections.emptyList();

    /**
     * Constructor.
     */
    NodeAddressBook() {
    }

    /**
     * Extract the of node addresses.
     *
     * @return                          list of node addresses
     */
    public List<NodeAddress> getNodeAddresses() {
        return cloneNodeAddresses(nodeAddresses);
    }

    /**
     * Assign the list of node addresses.
     *
     * @param nodeAddresses             list of node addresses
     * @return {@code this}
     */
    public NodeAddressBook setNodeAddresses(List<NodeAddress> nodeAddresses) {
        this.nodeAddresses = cloneNodeAddresses(nodeAddresses);
        return this;
    }

    static List<NodeAddress> cloneNodeAddresses(List<NodeAddress> addresses) {
        List<NodeAddress> cloneAddresses = new ArrayList<>(addresses.size());
        for (var address : addresses) {
            cloneAddresses.add(address.clone());
        }
        return cloneAddresses;
    }

    /**
     * Create a node address book from a protobuf.
     *
     * @param book                      the protobuf
     * @return                          the new node address book
     */
    static NodeAddressBook fromProtobuf(com.hedera.hashgraph.sdk.proto.NodeAddressBook book) {
        var addresses = new ArrayList<NodeAddress>(book.getNodeAddressCount());

        for (var address : book.getNodeAddressList()) {
            addresses.add(NodeAddress.fromProtobuf(address));
        }

        return new NodeAddressBook().setNodeAddresses(addresses);
    }

    /**
     * Create a node address book from a byte string.
     *
     * @param bytes                     the byte string
     * @return                          the new node address book
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static NodeAddressBook fromBytes(ByteString bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.NodeAddressBook.parseFrom(bytes));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.NodeAddressBook toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.NodeAddressBook.newBuilder();

        for (var nodeAdress : nodeAddresses) {
            builder.addNodeAddress(nodeAdress.toProtobuf());
        }

        return builder.build();
    }

    /**
     * Create the byte string.
     *
     * @return                          the byte string representation
     */
    public ByteString toBytes() {
        return toProtobuf().toByteString();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("nodeAddresses", nodeAddresses)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NodeCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AddressBookServiceGrpc;
import com.hedera.hashgraph.sdk.proto.NodeCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;
import org.bouncycastle.util.Arrays;

/**
 * A transaction to create a new node in the network address book.
 * The transaction, once complete, enables a new consensus node
 * to join the network, and requires governing council authorization.
 * <p>
 * This transaction body SHALL be considered a "privileged transaction".
 * <p>
 *
 * - MUST be signed by the governing council.
 * - MUST be signed by the `Key` assigned to the
 *   `admin_key` field.
 * - The newly created node information SHALL be added to the network address
 *   book information in the network state.
 * - The new entry SHALL be created in "state" but SHALL NOT participate in
 *   network consensus and SHALL NOT be present in network "configuration"
 *   until the next "upgrade" transaction (as noted below).
 * - All new address book entries SHALL be added to the active network
 *   configuration during the next `freeze` transaction with the field
 *   `freeze_type` set to `PREPARE_UPGRADE`.
 *
 * ### Record Stream Effects
 * Upon completion the newly assigned `node_id` SHALL be in the transaction
 * receipt.
 */
public class NodeCreateTransaction extends Transaction<NodeCreateTransaction> {

    /**
     * A Node account identifier.
     * <p>
     * This account identifier MUST be in the "account number" form.<br/>
     * This account identifier MUST NOT use the alias field.<br/>
     * If the identified account does not exist, this transaction SHALL fail.<br/>
     * Multiple nodes MAY share the same node account.<br/>
     * This field is REQUIRED.
     */
    @Nullable
    private AccountId accountId = null;

    /**
     * A short description of the node.
     * <p>
     * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
     * This field is OPTIONAL.
     */
    private String description = "";

    /**
     * A list of service endpoints for gossip.
     * <p>
     * These endpoints SHALL represent the published endpoints to which other
     * consensus nodes may _gossip_ transactions.<br/>
     * These endpoints MUST specify a port.<br/>
     * This list MUST NOT be empty.<br/>
     * This list MUST NOT contain more than `10` entries.<br/>
     * The first two entries in this list SHALL be the endpoints published to
     * all consensus nodes.<br/>
     * All other entries SHALL be reserved for future use.
     * <p>
     * Each network may have additional requirements for these endpoints.
     * A client MUST check network-specific documentation for those
     * details.<br/>
     * If the network configuration value `gossipFqdnRestricted` is set, then
     * all endpoints in this list MUST supply only IP address.<br/>
     * If the network configuration value `gossipFqdnRestricted` is _not_ set,
     * then endpoints in this list MAY supply either IP address or FQDN, but
     * MUST NOT supply both values for the same endpoint.
     */
    private List<Endpoint> gossipEndpoints = new ArrayList<>();

    /**
     * A list of service endpoints for gRPC calls.
     * <p>
     * These endpoints SHALL represent the published gRPC endpoints to which
     * clients may submit transactions.<br/>
     * These endpoints MUST specify a port.<br/>
     * Endpoints in this list MAY supply either IP address or FQDN, but MUST
     * NOT supply both values for the same endpoint.<br/>
     * This list MUST NOT be empty.<br/>
     * This list MUST NOT contain more than `8` entries.
     */
    private List<Endpoint> serviceEndpoints = new ArrayList<>();

    /**
     * A certificate used to sign gossip events.
     * <p>
     * This value MUST be a certificate of a type permitted for gossip
     * signatures.<br/>
     * This value MUST be the DER encoding of the certificate presented.<br/>
     * This field is REQUIRED and MUST NOT be empty.
     */
    @Nullable
    private byte[] gossipCaCertificate = null;

    /**
     * A hash of the node gRPC TLS certificate.
     * <p>
     * This value MAY be used to verify the certificate presented by the node
     * during TLS negotiation for gRPC.<br/>
     * This value MUST be a SHA-384 hash.<br/>
     * The TLS certificate to be hashed MUST first be in PEM format and MUST be
     * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
     * the hash algorithm.<br/>
     * This field is OPTIONAL.
     */
    @Nullable
    private byte[] grpcCertificateHash = null;

    /**
     * An administrative key controlled by the node operator.
     * <p>
     * This key MUST sign this transaction.<br/>
     * This key MUST sign each transaction to update this node.<br/>
     * This field MUST contain a valid `Key` value.<br/>
     * This field is REQUIRED and MUST NOT be set to an empty `KeyList`.
     */
    @Nullable
    private Key adminKey = null;

    /**
     * Constructor.
     */
    public NodeCreateTransaction() {}

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    NodeCreateTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    NodeCreateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the Account ID of the Node.
     * @return the Account ID of the Node.
     */
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the Account ID of the Node.
     * @param accountId the Account ID of the Node.
     * @return {@code this}
     */
    public NodeCreateTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the description of the node.
     * @return the node's description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the description of the node.
     * @param description The String to be set as the description of the node.
     * @return {@code this}
     */
    public NodeCreateTransaction setDescription(String description) {
        requireNotFrozen();
        Objects.requireNonNull(description);
        this.description = description;
        return this;
    }

    /**
     * Extract the list of service endpoints for gossip.
     * @return the list of service endpoints for gossip.
     */
    public List<Endpoint> getGossipEndpoints() {
        return gossipEndpoints;
    }

    /**
     * Assign the list of service endpoints for gossip.
     * @param gossipEndpoints the list of service endpoints for gossip.
     * @return {@code this}
     */
    public NodeCreateTransaction setGossipEndpoints(List<Endpoint> gossipEndpoints) {
        requireNotFrozen();
        Objects.requireNonNull(gossipEndpoints);
        this.gossipEndpoints = new ArrayList<>(gossipEndpoints);
        return this;
    }

    /**
     * Add an endpoint for gossip to the list of service endpoints for gossip.
     * @param gossipEndpoint endpoints for gossip to add.
     * @return {@code this}
     */
    public NodeCreateTransaction addGossipEndpoint(Endpoint gossipEndpoint) {
        requireNotFrozen();
        gossipEndpoints.add(gossipEndpoint);
        return this;
    }

    /**
     * Extract the list of service endpoints for gRPC calls.
     * @return the list of service endpoints for gRPC calls.
     */
    public List<Endpoint> getServiceEndpoints() {
        return serviceEndpoints;
    }

    /**
     * Assign the list of service endpoints for gRPC calls.
     * @param serviceEndpoints list of service endpoints for gRPC calls.
     * @return {@code this}
     */
    public NodeCreateTransaction setServiceEndpoints(List<Endpoint> serviceEndpoints) {
        requireNotFrozen();
        Objects.requireNonNull(serviceEndpoints);
        this.serviceEndpoints = new ArrayList<>(serviceEndpoints);
        return this;
    }

    /**
     * Add an endpoint for gRPC calls to the list of service endpoints for gRPC calls.
     * @param serviceEndpoint endpoints for gRPC calls to add.
     * @return {@code this}
     */
    public NodeCreateTransaction addServiceEndpoint(Endpoint serviceEndpoint) {
        requireNotFrozen();
        serviceEndpoints.add(serviceEndpoint);
        return this;
    }

    /**
     * Extract the certificate used to sign gossip events.
     * @return the DER encoding of the certificate presented.
     */
    @Nullable
    public byte[] getGossipCaCertificate() {
        return gossipCaCertificate != null ? Arrays.copyOf(gossipCaCertificate, gossipCaCertificate.length) : null;
    }

    /**
     * Sets the certificate used to sign gossip events.
     * <br>
     * This value MUST be the DER encoding of the certificate presented.
     * @param gossipCaCertificate the DER encoding of the certificate presented.
     * @return {@code this}
     */
    public NodeCreateTransaction setGossipCaCertificate(byte[] gossipCaCertificate) {
        Objects.requireNonNull(gossipCaCertificate);
        requireNotFrozen();
        this.gossipCaCertificate = Arrays.copyOf(gossipCaCertificate, gossipCaCertificate.length);
        return this;
    }

    /**
     * Extract the hash of the node gRPC TLS certificate.
     * @return SHA-384 hash of the node gRPC TLS certificate.
     */
    @Nullable
    public byte[] getGrpcCertificateHash() {
        return grpcCertificateHash != null ? Arrays.copyOf(grpcCertificateHash, grpcCertificateHash.length) : null;
    }

    /**
     * Sets the hash of the node gRPC TLS certificate.
     * <br>
     * This value MUST be a SHA-384 hash.
     * @param grpcCertificateHash SHA-384 hash of the node gRPC TLS certificate.
     * @return {@code this}
     */
    public NodeCreateTransaction setGrpcCertificateHash(byte[] grpcCertificateHash) {
        Objects.requireNonNull(grpcCertificateHash);
        requireNotFrozen();
        this.grpcCertificateHash = Arrays.copyOf(grpcCertificateHash, grpcCertificateHash.length);
        return this;
    }

    /**
     * Get an administrative key controlled by the node operator.
     * @return an administrative key controlled by the node operator.
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Sets an administrative key controlled by the node operator.
     * @param adminKey an administrative key to be set.
     * @return {@code this}
     */
    public NodeCreateTransaction setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        requireNotFrozen();
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.NodeCreateTransactionBody}
     */
    NodeCreateTransactionBody.Builder build() {
        var builder = NodeCreateTransactionBody.newBuilder();

        if (accountId != null) {
            builder.setAccountId(accountId.toProtobuf());
        }

        builder.setDescription(description);

        for (Endpoint gossipEndpoint : gossipEndpoints) {
            builder.addGossipEndpoint(gossipEndpoint.toProtobuf());
        }

        for (Endpoint serviceEndpoint : serviceEndpoints) {
            builder.addServiceEndpoint(serviceEndpoint.toProtobuf());
        }

        if (gossipCaCertificate != null) {
            builder.setGossipCaCertificate(ByteString.copyFrom(gossipCaCertificate));
        }

        if (grpcCertificateHash != null) {
            builder.setGrpcCertificateHash(ByteString.copyFrom(grpcCertificateHash));
        }

        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getNodeCreate();

        if (body.hasAccountId()) {
            accountId = AccountId.fromProtobuf(body.getAccountId());
        }

        description = body.getDescription();

        for (var gossipEndpoint : body.getGossipEndpointList()) {
            gossipEndpoints.add(Endpoint.fromProtobuf(gossipEndpoint));
        }

        for (var serviceEndpoint : body.getServiceEndpointList()) {
            serviceEndpoints.add(Endpoint.fromProtobuf(serviceEndpoint));
        }

        gossipCaCertificate = body.getGossipCaCertificate().toByteArray();

        grpcCertificateHash = body.getGrpcCertificateHash().toByteArray();

        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return AddressBookServiceGrpc.getCreateNodeMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setNodeCreate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setNodeCreate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NodeDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AddressBookServiceGrpc;
import com.hedera.hashgraph.sdk.proto.NodeDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.LinkedHashMap;

/**
 * A transaction to delete a node from the network address book.
 *
 * This transaction body SHALL be considered a "privileged transaction".
 *
 * - A transaction MUST be signed by the governing council.
 * - Upon success, the address book entry SHALL enter a "pending delete"
 *   state.
 * - All address book entries pending deletion SHALL be removed from the
 *   active network configuration during the next `freeze` transaction with
 *   the field `freeze_type` set to `PREPARE_UPGRADE`.<br/>
 * - A deleted address book node SHALL be removed entirely from network state.
 * - A deleted address book node identifier SHALL NOT be reused.
 *
 * ### Record Stream Effects
 * Upon completion the "deleted" `node_id` SHALL be in the transaction
 * receipt.
 */
public class NodeDeleteTransaction extends Transaction<NodeDeleteTransaction> {

    /**
     * A consensus node identifier in the network state.
     * <p>
     * The node identified MUST exist in the network address book.<br/>
     * The node identified MUST NOT be deleted.<br/>
     * This value is REQUIRED.
     */
    private long nodeId = 0;

    /**
     * Constructor.
     */
    public NodeDeleteTransaction() {}

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    NodeDeleteTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    NodeDeleteTransaction(TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the consensus node identifier in the network state.
     * @return the consensus node identifier in the network state.
     */
    public long getNodeId() {
        return nodeId;
    }

    /**
     * Assign the consensus node identifier in the network state.
     * @param nodeId the consensus node identifier in the network state.
     * @return {@code this}
     */
    public NodeDeleteTransaction setNodeId(long nodeId) {
        requireNotFrozen();
        this.nodeId = nodeId;
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.NodeDeleteTransactionBody}
     */
    NodeDeleteTransactionBody.Builder build() {
        var builder = NodeDeleteTransactionBody.newBuilder();
        builder.setNodeId(nodeId);
        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getNodeDelete();
        nodeId = body.getNodeId();
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        // no-op
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return AddressBookServiceGrpc.getDeleteNodeMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setNodeDelete(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setNodeDelete(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/NodeUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.AddressBookServiceGrpc;
import com.hedera.hashgraph.sdk.proto.NodeUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;
import org.bouncycastle.util.Arrays;

/**
 * A transaction to modify address book node attributes.
 *
 * - This transaction SHALL enable the node operator, as identified by the
 *   `admin_key`, to modify operational attributes of the node.
 * - This transaction MUST be signed by the active `admin_key` for the node.
 * - If this transaction sets a new value for the `admin_key`, then both the
 *   current `admin_key`, and the new `admin_key` MUST sign this transaction.
 * - This transaction SHALL NOT change any field that is not set (is null) in
 *   this transaction body.
 * - This SHALL create a pending update to the node, but the change SHALL NOT
 *   be immediately applied to the active configuration.
 * - All pending node updates SHALL be applied to the active network
 *   configuration during the next `freeze` transaction with the field
 *   `freeze_type` set to `PREPARE_UPGRADE`.
 *
 * ### Record Stream Effects
 * Upon completion the `node_id` for the updated entry SHALL be in the
 * transaction receipt.
 */
public class NodeUpdateTransaction extends Transaction<NodeUpdateTransaction> {

    /**
     * A consensus node identifier in the network state.
     * <p>
     * The node identified MUST exist in the network address book.<br/>
     * The node identified MUST NOT be deleted.<br/>
     * This value is REQUIRED.
     */
    private long nodeId = 0;

    /**
     * An account identifier.
     * <p>
     * If set, this SHALL replace the node account identifier.<br/>
     * If set, this transaction MUST be signed by the active `key` for _both_
     * the current node account _and_ the identified new node account.
     */
    @Nullable
    private AccountId accountId = null;

    /**
     * A short description of the node.
     * <p>
     * This value, if set, MUST NOT exceed 100 bytes when encoded as UTF-8.<br/>
     * If set, this value SHALL replace the previous value.
     */
    @Nullable
    private String description = null;

    /**
     * A list of service endpoints for gossip.
     * <p>
     * If set, this list MUST meet the following requirements.
     * <hr/>
     * These endpoints SHALL represent the published endpoints to which other
     * consensus nodes may _gossip_ transactions.<br/>
     * These endpoints SHOULD NOT specify both address and DNS name.<br/>
     * This list MUST NOT be empty.<br/>
     * This list MUST NOT contain more than `10` entries.<br/>
     * The first two entries in this list SHALL be the endpoints published to
     * all consensus nodes.<br/>
     * All other entries SHALL be reserved for future use.
     * <p>
     * Each network may have additional requirements for these endpoints.
     * A client MUST check network-specific documentation for those
     * details.<br/>
     * <blockquote>Example<blockquote>
     * Hedera Mainnet _requires_ that address be specified, and does not
     * permit DNS name (FQDN) to be specified.<br/>
     * Mainnet also requires that the first entry be an "internal" IP
     * address and the second entry be an "external" IP address.
     * </blockquote>
     * <blockquote>
     * Solo, however, _requires_ DNS name (FQDN) but also permits
     * address.
     * </blockquote></blockquote>
     * <p>
     * If set, the new list SHALL replace the existing list.
     */
    private List<Endpoint> gossipEndpoints = new ArrayList<>();

    /**
     * A list of service endpoints for gRPC calls.
     * <p>
     * If set, this list MUST meet the following requirements.
     * <hr/>
     * These endpoints SHALL represent the published endpoints to which clients
     * may submit transactions.<br/>
     * These endpoints SHOULD specify address and port.<br/>
     * These endpoints MAY specify a DNS name.<br/>
     * These endpoints SHOULD NOT specify both address and DNS name.<br/>
     * This list MUST NOT be empty.<br/>
     * This list MUST NOT contain more than `8` entries.
     * <p>
     * Each network may have additional requirements for these endpoints.
     * A client MUST check network-specific documentation for those
     * details.
     * <p>
     * If set, the new list SHALL replace the existing list.
     */
    private List<Endpoint> serviceEndpoints = new ArrayList<>();

    /**
     * A certificate used to sign gossip events.
     * <p>
     * This value MUST be a certificate of a type permitted for gossip
     * signatures.<br/>
     * This value MUST be the DER encoding of the certificate presented.
     * <p>
     * If set, the new value SHALL replace the existing bytes value.
     */
    @Nullable
    private byte[] gossipCaCertificate = null;

    /**
     * A hash of the node gRPC TLS certificate.
     * <p>
     * This value MAY be used to verify the certificate presented by the node
     * during TLS negotiation for gRPC.<br/>
     * This value MUST be a SHA-384 hash.<br/>
     * The TLS certificate to be hashed MUST first be in PEM format and MUST be
     * encoded with UTF-8 NFKD encoding to a stream of bytes provided to
     * the hash algorithm.<br/>
     * <p>
     * If set, the new value SHALL replace the existing hash value.
     */
    @Nullable
    private byte[] grpcCertificateHash = null;

    /**
     * An administrative key controlled by the node operator.
     * <p>
     * This field is OPTIONAL.<br/>
     * If set, this key MUST sign this transaction.<br/>
     * If set, this key MUST sign each subsequent transaction to
     * update this node.<br/>
     * If set, this field MUST contain a valid `Key` value.<br/>
     * If set, this field MUST NOT be set to an empty `KeyList`.
     */
    @Nullable
    private Key adminKey = null;

    /**
     * Constructor.
     */
    public NodeUpdateTransaction() {}

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    NodeUpdateTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    NodeUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the consensus node identifier in the network state.
     * @return the consensus node identifier in the network state.
     */
    public long getNodeId() {
        return nodeId;
    }

    /**
     * Assign the consensus node identifier in the network state.
     * @param nodeId the consensus node identifier in the network state.
     * @return {@code this}
     */
    public NodeUpdateTransaction setNodeId(long nodeId) {
        requireNotFrozen();
        this.nodeId = nodeId;
        return this;
    }

    /**
     * Extract the Account ID of the Node.
     * @return the Account ID of the Node.
     */
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the Account ID of the Node.
     * @param accountId the Account ID of the Node.
     * @return {@code this}
     */
    public NodeUpdateTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the description of the node.
     * @return the node's description.
     */
    @Nullable
    public String getDescription() {
        return description;
    }

    /**
     * Sets the description of the node.
     * @param description The String to be set as the description of the node.
     * @return {@code this}
     */
    public NodeUpdateTransaction setDescription(String description) {
        requireNotFrozen();
        Objects.requireNonNull(description);
        this.description = description;
        return this;
    }

    /**
     * Remove the description contents.
     * @return {@code this}
     */
    public NodeUpdateTransaction clearDescription() {
        requireNotFrozen();
        description = "";
        return this;
    }

    /**
     * Extract the list of service endpoints for gossip.
     * @return the list of service endpoints for gossip.
     */
    public List<Endpoint> getGossipEndpoints() {
        return gossipEndpoints;
    }

    /**
     * Assign the list of service endpoints for gossip.
     * @param gossipEndpoints the list of service endpoints for gossip.
     * @return {@code this}
     */
    public NodeUpdateTransaction setGossipEndpoints(List<Endpoint> gossipEndpoints) {
        requireNotFrozen();
        Objects.requireNonNull(gossipEndpoints);
        this.gossipEndpoints = new ArrayList<>(gossipEndpoints);
        return this;
    }

    /**
     * Add an endpoint for gossip to the list of service endpoints for gossip.
     * @param gossipEndpoint endpoints for gossip to add.
     * @return {@code this}
     */
    public NodeUpdateTransaction addGossipEndpoint(Endpoint gossipEndpoint) {
        requireNotFrozen();
        gossipEndpoints.add(gossipEndpoint);
        return this;
    }

    /**
     * Extract the list of service endpoints for gRPC calls.
     * @return the list of service endpoints for gRPC calls.
     */
    public List<Endpoint> getServiceEndpoints() {
        return serviceEndpoints;
    }

    /**
     * Assign the list of service endpoints for gRPC calls.
     * @param serviceEndpoints list of service endpoints for gRPC calls.
     * @return {@code this}
     */
    public NodeUpdateTransaction setServiceEndpoints(List<Endpoint> serviceEndpoints) {
        requireNotFrozen();
        Objects.requireNonNull(serviceEndpoints);
        this.serviceEndpoints = new ArrayList<>(serviceEndpoints);
        return this;
    }

    /**
     * Add an endpoint for gRPC calls to the list of service endpoints for gRPC calls.
     * @param serviceEndpoint endpoints for gRPC calls to add.
     * @return {@code this}
     */
    public NodeUpdateTransaction addServiceEndpoint(Endpoint serviceEndpoint) {
        requireNotFrozen();
        serviceEndpoints.add(serviceEndpoint);
        return this;
    }

    /**
     * Extract the certificate used to sign gossip events.
     * @return the DER encoding of the certificate presented.
     */
    @Nullable
    public byte[] getGossipCaCertificate() {
        return gossipCaCertificate != null ? Arrays.copyOf(gossipCaCertificate, gossipCaCertificate.length) : null;
    }

    /**
     * Sets the certificate used to sign gossip events.
     * <br>
     * This value MUST be the DER encoding of the certificate presented.
     * @param gossipCaCertificate the DER encoding of the certificate presented.
     * @return {@code this}
     */
    public NodeUpdateTransaction setGossipCaCertificate(byte[] gossipCaCertificate) {
        Objects.requireNonNull(gossipCaCertificate);
        requireNotFrozen();
        this.gossipCaCertificate = Arrays.copyOf(gossipCaCertificate, gossipCaCertificate.length);
        return this;
    }

    /**
     * Extract the hash of the node gRPC TLS certificate.
     * @return SHA-384 hash of the node gRPC TLS certificate.
     */
    @Nullable
    public byte[] getGrpcCertificateHash() {
        return grpcCertificateHash != null ? Arrays.copyOf(grpcCertificateHash, grpcCertificateHash.length) : null;
    }

    /**
     * Sets the hash of the node gRPC TLS certificate.
     * <br>
     * This value MUST be a SHA-384 hash.
     * @param grpcCertificateHash SHA-384 hash of the node gRPC TLS certificate.
     * @return {@code this}
     */
    public NodeUpdateTransaction setGrpcCertificateHash(byte[] grpcCertificateHash) {
        Objects.requireNonNull(grpcCertificateHash);
        requireNotFrozen();
        this.grpcCertificateHash = Arrays.copyOf(grpcCertificateHash, grpcCertificateHash.length);
        return this;
    }

    /**
     * Get an administrative key controlled by the node operator.
     * @return an administrative key controlled by the node operator.
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Sets an administrative key controlled by the node operator.
     * @param adminKey an administrative key to be set.
     * @return {@code this}
     */
    public NodeUpdateTransaction setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        requireNotFrozen();
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.NodeUpdateTransactionBody}
     */
    NodeUpdateTransactionBody.Builder build() {
        var builder = NodeUpdateTransactionBody.newBuilder();

        builder.setNodeId(nodeId);

        if (accountId != null) {
            builder.setAccountId(accountId.toProtobuf());
        }

        if (description != null) {
            builder.setDescription(StringValue.of(description));
        }

        for (Endpoint gossipEndpoint : gossipEndpoints) {
            builder.addGossipEndpoint(gossipEndpoint.toProtobuf());
        }

        for (Endpoint serviceEndpoint : serviceEndpoints) {
            builder.addServiceEndpoint(serviceEndpoint.toProtobuf());
        }

        if (gossipCaCertificate != null) {
            builder.setGossipCaCertificate(BytesValue.of(ByteString.copyFrom(gossipCaCertificate)));
        }

        if (grpcCertificateHash != null) {
            builder.setGrpcCertificateHash(BytesValue.of(ByteString.copyFrom(grpcCertificateHash)));
        }

        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getNodeUpdate();

        nodeId = body.getNodeId();

        if (body.hasAccountId()) {
            accountId = AccountId.fromProtobuf(body.getAccountId());
        }

        description = body.getDescription().getValue();

        for (var gossipEndpoint : body.getGossipEndpointList()) {
            gossipEndpoints.add(Endpoint.fromProtobuf(gossipEndpoint));
        }

        for (var serviceEndpoint : body.getServiceEndpointList()) {
            serviceEndpoints.add(Endpoint.fromProtobuf(serviceEndpoint));
        }

        gossipCaCertificate = body.getGossipCaCertificate().getValue().toByteArray();

        grpcCertificateHash = body.getGrpcCertificateHash().getValue().toByteArray();

        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return AddressBookServiceGrpc.getUpdateNodeMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setNodeUpdate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setNodeUpdate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Pem.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.nist.NISTObjectIdentifiers;
import org.bouncycastle.asn1.pkcs.EncryptedPrivateKeyInfo;
import org.bouncycastle.asn1.pkcs.EncryptionScheme;
import org.bouncycastle.asn1.pkcs.KeyDerivationFunc;
import org.bouncycastle.asn1.pkcs.PBES2Parameters;
import org.bouncycastle.asn1.pkcs.PBKDF2Params;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMEncryptedKeyPair;
import org.bouncycastle.openssl.PEMKeyPair;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JceOpenSSLPKCS8DecryptorProviderBuilder;
import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;
import org.bouncycastle.pkcs.PKCSException;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemWriter;

import javax.annotation.Nullable;
import javax.crypto.Cipher;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

/**
 * Internal utility class for handling PEM objects.
 * <br>
 * Privacy-Enhanced Mail (PEM) is a de facto file format for storing and
 * sending cryptographic keys, certificates, and other data, based on a set of
 * 1993 IETF standards defining "privacy-enhanced mail."
 */
final class Pem {
    private static final String TYPE_PRIVATE_KEY = "PRIVATE KEY";
    private static final String TYPE_ENCRYPTED_PRIVATE_KEY = "ENCRYPTED PRIVATE KEY";

    /**
     * Constructor.
     */
    private Pem() {
    }

    /**
     * For some reason, this generates PEM encodings that we ourselves can import, but OpenSSL
     * doesn't like. We decided to punt on generating encrypted PEMs for now but saving
     * the code for when we get back to it and/or any demand arises.
     */
    @SuppressWarnings("unused")
    static void writeEncryptedPrivateKey(PrivateKeyInfo pkInfo, Writer out, String passphrase) throws IOException {
        byte[] salt = Crypto.randomBytes(Crypto.SALT_LEN);

        KeyParameter derivedKey = Crypto.deriveKeySha256(
            passphrase, salt, Crypto.ITERATIONS, Crypto.CBC_DK_LEN);

        byte[] iv = Crypto.randomBytes(Crypto.IV_LEN);

        Cipher cipher = Crypto.initAesCbc128Encrypt(derivedKey, iv);

        byte[] encryptedKey = Crypto.runCipher(cipher, pkInfo.getEncoded());

        // I wanted to just do this with BC's PKCS8Generator and KcePKCSPBEOutputEncryptorBuilder
        // but it tries to init AES instance of `Cipher` with a `PBKDF2Key` and the former complains

        // So this is basically a reimplementation of that minus the excess OO
        PBES2Parameters parameters = new PBES2Parameters(
            new KeyDerivationFunc(
                PKCSObjectIdentifiers.id_PBKDF2,
                new PBKDF2Params(
                    salt,
                    Crypto.ITERATIONS,
                    Crypto.CBC_DK_LEN,
                    new AlgorithmIdentifier(PKCSObjectIdentifiers.id_hmacWithSHA256))),
            new EncryptionScheme(NISTObjectIdentifiers.id_aes128_CBC,
                ASN1Primitive.fromByteArray(cipher.getParameters().getEncoded())));

        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(
            new AlgorithmIdentifier(PKCSObjectIdentifiers.id_PBES2, parameters),
            encryptedKey);

        PemWriter writer = new PemWriter(out);
        writer.writeObject(new PemObject(TYPE_ENCRYPTED_PRIVATE_KEY, encryptedPrivateKeyInfo.getEncoded()));
        writer.flush();
    }

    /**
     * Create a private key info object from a reader.
     *
     * @param input                     reader object
     * @param passphrase                passphrase
     * @return                          private key info object
     * @throws IOException              if IO operations fail
     */
    static PrivateKeyInfo readPrivateKey(Reader input, @Nullable String passphrase) throws IOException {
        try (final var parser = new PEMParser(input)){
            Object parsedObject = parser.readObject();
            var password = (passphrase != null) ? passphrase.toCharArray() : "".toCharArray();
            if (parsedObject == null) {
                throw new BadKeyException("PEM file did not contain a private key");
            } else if (parsedObject instanceof PKCS8EncryptedPrivateKeyInfo) {
                var decryptProvider = new JceOpenSSLPKCS8DecryptorProviderBuilder()
                    .setProvider(new BouncyCastleProvider())
                    .build(password);
                var encryptedPrivateKeyInfo = (PKCS8EncryptedPrivateKeyInfo) parsedObject;
                return encryptedPrivateKeyInfo.decryptPrivateKeyInfo(decryptProvider);
            } else if (parsedObject instanceof PrivateKeyInfo){
                return (PrivateKeyInfo) parsedObject;
            } else if (parsedObject instanceof PEMEncryptedKeyPair) {
                var decryptProvider = new JcePEMDecryptorProviderBuilder()
                    .setProvider(new BouncyCastleProvider())
                    .build(password);
                var encryptedKeyPair = (PEMEncryptedKeyPair) parsedObject;
                return encryptedKeyPair.decryptKeyPair(decryptProvider).getPrivateKeyInfo();
            } else if (parsedObject instanceof PEMKeyPair) {
                var keyPair = (PEMKeyPair) parsedObject;
                return keyPair.getPrivateKeyInfo();
            } else {
                throw new BadKeyException("PEM file contained something the SDK didn't know what to do with: " + parsedObject.getClass().getName());
            }
        } catch (PKCSException e) {
            if (e.getMessage().contains("password empty")) {
                throw new BadKeyException("PEM file contained an encrypted private key but no passphrase was given");
            }
            throw new RuntimeException(e);
        } catch (OperatorCreationException e) {
            throw new RuntimeException(e);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PendingAirdropId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * A unique, composite, identifier for a pending airdrop.
 *
 * Each pending airdrop SHALL be uniquely identified by a PendingAirdropId.
 * A PendingAirdropId SHALL be recorded when created and MUST be provided in any transaction
 * that would modify that pending airdrop (such as a `claimAirdrop` or `cancelAirdrop`).
 */
public class PendingAirdropId {
    private AccountId sender;
    private AccountId receiver;
    @Nullable
    private TokenId tokenId;
    @Nullable
    private NftId nftId;

    public PendingAirdropId() {}

    PendingAirdropId(AccountId sender, AccountId receiver, TokenId tokenId) {
        this.sender = sender;
        this.receiver = receiver;
        this.tokenId = tokenId;
        this.nftId = null;
    }

    PendingAirdropId(AccountId sender, AccountId receiver, NftId nftId) {
        this.sender = sender;
        this.receiver = receiver;
        this.nftId = nftId;
        this.tokenId = null;
    }

    public AccountId getSender() {
        return sender;
    }

    public PendingAirdropId setSender(@Nonnull AccountId sender) {
        this.sender = sender;
        return this;
    }

    public AccountId getReceiver() {
        return receiver;
    }

    public PendingAirdropId setReceiver(@Nonnull AccountId receiver) {
        this.receiver = receiver;
        return this;
    }

    public TokenId getTokenId() {
        return tokenId;
    }

    public PendingAirdropId setTokenId(@Nullable TokenId tokenId) {
        this.tokenId = tokenId;
        return this;
    }

    public NftId getNftId() {
        return nftId;
    }

    public PendingAirdropId setNftId(@Nullable NftId nftId) {
        this.nftId = nftId;
        return this;
    }

    static PendingAirdropId fromProtobuf(com.hedera.hashgraph.sdk.proto.PendingAirdropId pendingAirdropId) {
        if (pendingAirdropId.hasFungibleTokenType()) {
            return new PendingAirdropId(AccountId.fromProtobuf(pendingAirdropId.getSenderId()),
                AccountId.fromProtobuf(pendingAirdropId.getReceiverId()),
                TokenId.fromProtobuf(pendingAirdropId.getFungibleTokenType()));
        } else {
            return new PendingAirdropId(AccountId.fromProtobuf(pendingAirdropId.getSenderId()),
                AccountId.fromProtobuf(pendingAirdropId.getReceiverId()),
                NftId.fromProtobuf(pendingAirdropId.getNonFungibleToken()));
        }
    }

    com.hedera.hashgraph.sdk.proto.PendingAirdropId toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.PendingAirdropId.newBuilder()
            .setSenderId(sender.toProtobuf())
            .setReceiverId(receiver.toProtobuf());

        if (tokenId != null) {
            builder.setFungibleTokenType(tokenId.toProtobuf());
        } else if (nftId != null) {
            builder.setNonFungibleToken(nftId.toProtobuf());
        }
        return builder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("sender", sender)
            .add("receiver", receiver)
            .add("tokenId", tokenId)
            .add("nftId", nftId)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PendingAirdropLogic.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

abstract class PendingAirdropLogic<T extends PendingAirdropLogic<T>> extends Transaction<T> {

    protected List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();


    protected PendingAirdropLogic() {}

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    PendingAirdropLogic(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    PendingAirdropLogic(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
    }

    /**
     * Extract the pending airdrop ids
     *
     * @return the pending airdrop ids
     */
    public List<PendingAirdropId> getPendingAirdropIds() {
        return this.pendingAirdropIds;
    }

    /**
     * Set the pending airdrop ids
     *
     * @param pendingAirdropIds
     * @return {@code this}
     */
    public T setPendingAirdropIds(List<PendingAirdropId> pendingAirdropIds) {
        Objects.requireNonNull(pendingAirdropIds);
        requireNotFrozen();
        this.pendingAirdropIds = pendingAirdropIds;
        // noinspection unchecked
        return (T) this;
    }

    /**
     * clear the pending airdrop ids
     *
     * @return {@code this}
     */
    public T clearPendingAirdropIds() {
        requireNotFrozen();
        this.pendingAirdropIds = new ArrayList<>();
        // noinspection unchecked
        return (T) this;
    }

    /**
     * Add pendingAirdropId
     *
     * @param pendingAirdropId
     * @return {@code this}
     */
    public T addPendingAirdrop(PendingAirdropId pendingAirdropId) {
        Objects.requireNonNull(pendingAirdropId);
        requireNotFrozen();
        this.pendingAirdropIds.add(pendingAirdropId);
        // noinspection unchecked
        return (T) this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        for (var pendingAirdropId : pendingAirdropIds) {
            if (pendingAirdropId.getTokenId() != null) {
                pendingAirdropId.getTokenId().validateChecksum(client);
            }

            if (pendingAirdropId.getReceiver() != null) {
                pendingAirdropId.getReceiver().validateChecksum(client);
            }

            if (pendingAirdropId.getSender() != null) {
                pendingAirdropId.getSender().validateChecksum(client);
            }

            if (pendingAirdropId.getNftId() != null) {
                pendingAirdropId.getNftId().tokenId.validateChecksum(client);
            }
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PendingAirdropRecord.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.hedera.hashgraph.sdk.proto.PendingAirdropValue;

public class PendingAirdropRecord {
    private final PendingAirdropId pendingAirdropId;
    private final long pendingAirdropAmount;

    PendingAirdropRecord(PendingAirdropId pendingAirdropId, long pendingAirdropAmount) {
        this.pendingAirdropId = pendingAirdropId;
        this.pendingAirdropAmount = pendingAirdropAmount;
    }

    public PendingAirdropId getPendingAirdropId() {
        return pendingAirdropId;
    }

    public long getPendingAirdropAmount() {
        return pendingAirdropAmount;
    }

    com.hedera.hashgraph.sdk.proto.PendingAirdropRecord toProtobuf() {
        return com.hedera.hashgraph.sdk.proto.PendingAirdropRecord.newBuilder()
            .setPendingAirdropId(this.pendingAirdropId.toProtobuf())
            .setPendingAirdropValue(PendingAirdropValue.newBuilder().setAmount(pendingAirdropAmount))
            .build();
    }

    static PendingAirdropRecord fromProtobuf(com.hedera.hashgraph.sdk.proto.PendingAirdropRecord pendingAirdropRecord) {
        return new PendingAirdropRecord(
            PendingAirdropId.fromProtobuf(pendingAirdropRecord.getPendingAirdropId()),
            pendingAirdropRecord.getPendingAirdropValue().getAmount());
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("pendingAirdropId", pendingAirdropId)
            .add("pendingAirdropAmount", pendingAirdropAmount)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PrecheckStatusException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;

/**
 * Signals that a transaction has failed the pre-check.
 * <p>
 * Before a node submits a transaction to the rest of the network,
 * it attempts some cheap assertions. This process is called the "pre-check".
 */
public class PrecheckStatusException extends Exception {
    /**
     * The status of the failing transaction
     */
    public final Status status;

    /**
     * The ID of the transaction that failed.
     * <p>
     * This can be `null` if a query fails pre-check without an
     * associated payment transaction.
     */
    @Nullable
    public final TransactionId transactionId;

    /**
     * Constructor.
     *
     * @param status                    the status
     * @param transactionId             the transaction id
     */
    PrecheckStatusException(Status status, @Nullable TransactionId transactionId) {
        this.status = status;
        this.transactionId = transactionId;
    }

    @Override
    public String getMessage() {
        var stringBuilder = new StringBuilder();

        if (transactionId != null) {
            stringBuilder.append("Hedera transaction `").append(transactionId).append("` ");
        }

        stringBuilder.append("failed pre-check with the status `").append(status).append("`");

        return stringBuilder.toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PrivateKey.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.sec.ECPrivateKey;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.math.ec.rfc8032.Ed25519;
import org.bouncycastle.util.encoders.Hex;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.Arrays;

/**
 * A private key on the Hedera network.
 */
public abstract class PrivateKey extends Key {
    /**
     * The public key derived from the private key
     */
    @Nullable
    protected PublicKey publicKey = null; // Cache the derivation of the public key

    /**
     * Generates a new <a href="https://ed25519.cr.yp.to/">Ed25519</a> private key.
     *
     * @deprecated use {@link #generateED25519()} or {@link #generateECDSA()} instead
     *
     * @return the new Ed25519 private key.
     */
    public static PrivateKey generate() {
        return generateED25519();
    }

    /**
     * Extract the new ED25519 private key.
     *
     * @return                          the new ED25519 private key
     */
    public static PrivateKey generateED25519() {
        return PrivateKeyED25519.generateInternal();
    }

    /**
     * Extract the new ECDSA private key.
     *
     * @return                          the new ECDSA private key
     */
    public static PrivateKey generateECDSA() {
        return PrivateKeyECDSA.generateInternal();
    }

    /**
     * Extract the ED25519 private key from a seed.
     *
     * @param seed  the seed
     * @return      the ED25519 private key
     */
    public static PrivateKey fromSeedED25519(byte[] seed) {
        return PrivateKeyED25519.fromSeed(seed);
    }

    /**
     * Extract the ECDSA private key from a seed.
     *
     * @param seed  the seed
     * @return      the ECDSA private key
     */
    public static PrivateKey fromSeedECDSAsecp256k1(byte[] seed) {
        return PrivateKeyECDSA.fromSeed(seed);
    }

    /**
     * @deprecated use {@link Mnemonic#toStandardEd25519PrivateKey(String, int)} ()} or {@link Mnemonic#toStandardECDSAsecp256k1PrivateKey(String, int)} (String, int)} instead
     * This function uses incomplete and the key should not be used directly.
     * <p>
     * Recover a private key from a generated mnemonic phrase and a passphrase.
     * <p>
     * This is not compatible with the phrases generated by the Android and iOS wallets;
     * use the no-passphrase version instead.
     *
     * @param mnemonic   the mnemonic phrase which should be a 24 byte list of words.
     * @param passphrase the passphrase used to protect the mnemonic (not used in the
     *                   mobile wallets, use {@link #fromMnemonic(Mnemonic)} instead.)
     * @return the recovered key; use {@link #derive(int)} to get a key for an account index (0
     * for default account)
     */
    @Deprecated
    public static PrivateKey fromMnemonic(Mnemonic mnemonic, String passphrase) {
        var seed = mnemonic.toSeed(passphrase);
        @Var PrivateKey derivedKey = fromSeedED25519(seed);

        // BIP-44 path with the Hedera Hbar coin-type (omitting key index)
        // we pre-derive most of the path as the mobile wallets don't expose more than the index
        // https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
        // https://github.com/satoshilabs/slips/blob/master/slip-0044.md
        for (int index : new int[]{44, 3030, 0, 0}) {
            derivedKey = derivedKey.derive(index);
        }

        return derivedKey;
    }

    /**
     * @deprecated use {@link Mnemonic#toStandardEd25519PrivateKey(String, int)} ()} or {@link Mnemonic#toStandardECDSAsecp256k1PrivateKey(String, int)} (String, int)} instead
     * Recover a private key from a mnemonic phrase compatible with the iOS and Android wallets.
     * <p>
     * An overload of {@link #fromMnemonic(Mnemonic, String)} which uses an empty string for the
     * passphrase.
     *
     * @param mnemonic the mnemonic phrase which should be a 24 byte list of words.
     * @return the recovered key; use {@link #derive(int)} to get a key for an account index (0
     * for default account)
     */
    @Deprecated
    public static PrivateKey fromMnemonic(Mnemonic mnemonic) {
        return fromMnemonic(mnemonic, "");
    }

    /**
     * Retrieve a private key from a string.
     *
     * @param privateKey                string representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromString(String privateKey) {
        return fromBytes(Hex.decode(privateKey.startsWith("0x") ? privateKey.substring(2) : privateKey));
    }

    /**
     * Retrieve a private key from a DER encoded string.
     *
     * @param privateKey                DER encoded string representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromStringDER(String privateKey) {
        return fromBytesDER(Hex.decode(privateKey));
    }

    /**
     * Retrieve a private key from an ED25519 encoded string.
     *
     * @param privateKey                ED25519 encoded string representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromStringED25519(String privateKey) {
        return fromBytesED25519(Hex.decode(privateKey));
    }

    /**
     * Retrieve a private key from an ECDSA encoded string.
     *
     * @param privateKey                ECDSA encoded string representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromStringECDSA(String privateKey) {
        return fromBytesECDSA(Hex.decode(privateKey));
    }

    /**
     * Retrieve a private key from a byte array.
     *
     * @param privateKey                byte array representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromBytes(byte[] privateKey) {
        if ((privateKey.length == Ed25519.SECRET_KEY_SIZE)
            || (privateKey.length == Ed25519.SECRET_KEY_SIZE + Ed25519.PUBLIC_KEY_SIZE)) {
            // If this is a 32 or 64 byte string, assume an Ed25519 private key
            return new PrivateKeyED25519(Arrays.copyOfRange(privateKey, 0, Ed25519.SECRET_KEY_SIZE), null);
        }

        // Assume a DER-encoded private key descriptor
        return fromBytesDER(privateKey);
    }

    /**
     * Retrieve a private key from an ED25519 encoded byte array.
     *
     * @param privateKey                ED25519 encoded byte array representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromBytesED25519(byte[] privateKey) {
        return PrivateKeyED25519.fromBytesInternal(privateKey);
    }

    /**
     * Retrieve a private key from an ECDSA encoded byte array.
     *
     * @param privateKey                ECDSA encoded byte array representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromBytesECDSA(byte[] privateKey) {
        return PrivateKeyECDSA.fromBytesInternal(privateKey);
    }

    /**
     * Retrieve a private key from a DER encoded byte array.
     *
     * @param privateKey                DER encoded byte array representing a private key
     * @return                          the private key
     */
    public static PrivateKey fromBytesDER(byte[] privateKey) {
        try {
            return fromPrivateKeyInfo(PrivateKeyInfo.getInstance(privateKey));
        } catch (ClassCastException | IllegalArgumentException e) {
            return PrivateKeyECDSA.fromECPrivateKeyInternal(ECPrivateKey.getInstance(privateKey));
        }
    }

    /**
     * Retrieve a private key from a private key info object.
     *
     * @param privateKeyInfo            private key info object
     * @return                          the private key
     */
    private static PrivateKey fromPrivateKeyInfo(PrivateKeyInfo privateKeyInfo) {
        if (privateKeyInfo.getPrivateKeyAlgorithm().equals(new AlgorithmIdentifier(ID_ED25519))) {
            return PrivateKeyED25519.fromPrivateKeyInfoInternal(privateKeyInfo);
        } else {
            // assume ECDSA
            return PrivateKeyECDSA.fromPrivateKeyInfoInternal(privateKeyInfo);
        }
    }

    /**
     * Parse a private key from a PEM encoded reader.
     * <p>
     * This will read the first "PRIVATE KEY" section in the stream as an Ed25519 private key.
     *
     * @param pemFile The Reader containing the pem file
     * @return {@link com.hedera.hashgraph.sdk.PrivateKey}
     * @throws IOException     if one occurred while reading.
     * @throws BadKeyException if no "PRIVATE KEY" section was found or the key was not an Ed25519
     *                         private key.
     */
    public static PrivateKey readPem(Reader pemFile) throws IOException {
        return readPem(pemFile, null);
    }

    /**
     * Parse a private key from a PEM encoded stream. The key may be encrypted, e.g. if it was
     * generated by OpenSSL.
     * <p>
     * If <i>password</i> is not null or empty, this will read the first "ENCRYPTED PRIVATE KEY"
     * section in the stream as a PKCS#8
     * <a href="https://tools.ietf.org/html/rfc5208#page-4">EncryptedPrivateKeyInfo</a> structure
     * and use that algorithm to decrypt the private key with the given password. Otherwise,
     * it will read the first "PRIVATE KEY" section as DER-encoded Ed25519 private key.
     * <p>
     * To generate an encrypted private key with OpenSSL, open a terminal and enter the following
     * command:
     * <pre>
     * {@code openssl genpkey -algorithm ed25519 -aes-128-cbc > key.pem}
     * </pre>
     * <p>
     * Then enter your password of choice when prompted. When the command completes, your encrypted
     * key will be saved as `key.pem` in the working directory of your terminal.
     *
     * @param pemFile  the PEM encoded file
     * @param password the password to decrypt the PEM file; if null or empty, no decryption is performed.
     * @return {@link com.hedera.hashgraph.sdk.PrivateKey}
     * @throws IOException     if one occurred while reading the PEM file
     * @throws BadKeyException if no "ENCRYPTED PRIVATE KEY" or "PRIVATE KEY" section was found,
     *                         if the passphrase is wrong or the key was not an Ed25519 private key.
     */
    public static PrivateKey readPem(Reader pemFile, @Nullable String password) throws IOException {
        return fromPrivateKeyInfo(Pem.readPrivateKey(pemFile, password));
    }

    /**
     * Parse a private key from a PEM encoded string.
     *
     * @param pemEncoded The String containing the pem
     * @return {@link com.hedera.hashgraph.sdk.PrivateKey}
     * @throws IOException     if the PEM string was improperly encoded
     * @throws BadKeyException if no "PRIVATE KEY" section was found or the key was not an Ed25519
     *                         private key.
     * @see #readPem(Reader)
     */
    public static PrivateKey fromPem(String pemEncoded) throws IOException {
        return readPem(new StringReader(pemEncoded));
    }

    /**
     * Parse a private key from a PEM encoded string.
     * <p>
     * The private key may be encrypted, e.g. if it was generated by OpenSSL.
     *
     * @param encodedPem the encoded PEM string
     * @param password   the password to decrypt the PEM file; if null or empty, no decryption is performed.
     * @return {@link com.hedera.hashgraph.sdk.PrivateKey}
     * @throws IOException     if the PEM string was improperly encoded
     * @throws BadKeyException if no "ENCRYPTED PRIVATE KEY" or "PRIVATE KEY" section was found,
     *                         if the passphrase is wrong or the key was not an Ed25519 private key.
     * @see #readPem(Reader, String)
     */
    public static PrivateKey fromPem(String encodedPem, @Nullable String password) throws IOException {
        return readPem(new StringReader(encodedPem), password);
    }

    /**
     * Derive a child key based on the index.
     *
     * @param index                     the index
     * @return                          the derived child key
     */
    public PrivateKey legacyDerive(int index) {
        return legacyDerive((long) index);
    }

    /**
     * Derive a child key based on the index.
     *
     * @param index                     the index
     * @return                          the derived child key
     */
    public abstract PrivateKey legacyDerive(long index);

    /**
     * Check if this private key supports derivation.
     * <p>
     * This is currently only the case if this private key was created from a mnemonic.
     *
     * @return boolean
     */
    public abstract boolean isDerivable();

    /**
     * Given a wallet/account index, derive a child key compatible with the iOS and Android wallets.
     * <p>
     * Use index 0 for the default account.
     *
     * @param index the wallet/account index of the account, 0 for the default account.
     * @return the derived key
     * @throws IllegalStateException if this key does not support derivation.
     * @see #isDerivable()
     */
    public abstract PrivateKey derive(int index);

    /**
     * Derive a public key from this private key.
     *
     * <p>The public key can be freely given and used by other parties to verify the signatures
     * generated by this private key.
     *
     * @return the corresponding public key for this private key.
     */
    public abstract PublicKey getPublicKey();

    /**
     * Sign a message with this private key.
     *
     * @param message The array of bytes to sign with
     * @return the signature of the message.
     */
    public abstract byte[] sign(byte[] message);

    /**
     * Sign a transaction.
     *
     * @param transaction               the transaction
     * @return                          the signed transaction
     */
    public byte[] signTransaction(Transaction<?> transaction) {
        transaction.requireOneNodeAccountId();

        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        var builder = (SignedTransaction.Builder) transaction.innerSignedTransactions.get(0);
        var signature = sign(builder.getBodyBytes().toByteArray());

        transaction.addSignature(getPublicKey(), signature);

        return signature;
    }

    @Override
    public abstract byte[] toBytes();

    /**
     * Extract the byte array encoded as DER.
     *
     * @return                          the byte array encoded as DER
     */
    public abstract byte[] toBytesDER();

    /**
     * Extract the raw byte array.
     *
     * @return                          the raw byte array
     */
    public abstract byte[] toBytesRaw();

    @Override
    public String toString() {
        return toStringDER();
    }

    /**
     * Extract the DER encoded hex string.
     *
     * @return                          the DER encoded hex string
     */
    public String toStringDER() {
        return Hex.toHexString(toBytesDER());
    }

    /**
     * Extract the raw hex string.
     *
     * @return                          the raw hex string
     */
    public String toStringRaw() {
        return Hex.toHexString(toBytesRaw());
    }

    /**
     * Retrieve the account id.
     *
     * @param shard                     the shard
     * @param realm                     the realm
     * @return                          the account id
     */
    public AccountId toAccountId(@Nonnegative long shard, @Nonnegative long realm) {
        return getPublicKey().toAccountId(shard, realm);
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        // Forward to the corresponding public key.
        return getPublicKey().toProtobufKey();
    }

    /**
     * Are we an ED25519 key?
     *
     * @return                          are we an ED25519 key
     */
    public abstract boolean isED25519();

    /**
     * Are we an ECDSA key?
     *
     * @return                          are we an ECDSA key
     */
    public abstract boolean isECDSA();

    /**
     * Get the chain code of the key
     *
     * @return the chainCode
     */
    public abstract KeyParameter getChainCode();
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PrivateKeyECDSA.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.utils.Bip32Utils;
import org.bouncycastle.asn1.*;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.sec.ECPrivateKey;
import org.bouncycastle.asn1.x9.X962Parameters;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.generators.ECKeyPairGenerator;
import org.bouncycastle.crypto.macs.HMac;
import org.bouncycastle.crypto.params.ECKeyGenerationParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.signers.ECDSASigner;
import org.bouncycastle.crypto.signers.HMacDSAKCalculator;
import org.bouncycastle.util.Arrays;

import javax.annotation.Nullable;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;

/**
 * Encapsulate the ECDSA private key.
 */
public class PrivateKeyECDSA extends PrivateKey {

    private final BigInteger keyData;

    @Nullable
    private final KeyParameter chainCode;

    /**
     * Constructor.
     *
     * @param keyData                   the key data
     */
    PrivateKeyECDSA(BigInteger keyData, @Nullable KeyParameter chainCode) {
        this.keyData = keyData;
        this.chainCode = chainCode;
    }

    /**
     * Create a new private ECDSA key.
     *
     * @return                          the new key
     */
    static PrivateKeyECDSA generateInternal() {
        var generator = new ECKeyPairGenerator();
        var keygenParams = new ECKeyGenerationParameters(ECDSA_SECP256K1_DOMAIN, ThreadLocalSecureRandom.current());
        generator.init(keygenParams);
        var keypair = generator.generateKeyPair();
        var privParams = (ECPrivateKeyParameters) keypair.getPrivate();
        return new PrivateKeyECDSA(privParams.getD(), null);
    }

    /**
     * Create a new private key from a private key ino object.
     *
     * @param privateKeyInfo            the private key info object
     * @return                          the new key
     */
    static PrivateKey fromPrivateKeyInfoInternal(PrivateKeyInfo privateKeyInfo) {
        try {
            var privateKey = ECPrivateKey.getInstance(privateKeyInfo.parsePrivateKey());
            return fromECPrivateKeyInternal(privateKey);
        } catch (IllegalArgumentException e) {
            // Try legacy import
            try {
                var privateKey = (ASN1OctetString) privateKeyInfo.parsePrivateKey();
                return new PrivateKeyECDSA(new BigInteger(1, privateKey.getOctets()), null);
            } catch (IOException ex) {
                throw new BadKeyException(ex);
            }
        } catch (IOException e) {
            throw new BadKeyException(e);
        }
    }

    /**
     * Create a new private key from a ECPrivateKey object.
     *
     * @param privateKey                the ECPrivateKey object
     * @return                          the new key
     */
    static PrivateKey fromECPrivateKeyInternal(ECPrivateKey privateKey) {
        return new PrivateKeyECDSA(privateKey.getKey(), null);
    }

    /**
     * Create a private key from a byte array.
     *
     * @param privateKey                the byte array
     * @return                          the new key
     */
    static PrivateKey fromBytesInternal(byte[] privateKey) {
        if (privateKey.length == 32) {
            return new PrivateKeyECDSA(new BigInteger(1, privateKey), null);
        }

        // Assume a DER-encoded private key descriptor
        return fromECPrivateKeyInternal(ECPrivateKey.getInstance(privateKey));
    }

    /**
     * Throws an exception when trying to derive a child key.
     *
     * @param entropy                   entropy byte array
     * @param index                     the child key index
     * @return                          the new key
     */
    static byte[] legacyDeriveChildKey(byte[] entropy, long index) {
        throw new IllegalStateException("ECDSA secp256k1 keys do not currently support derivation");
    }

    @Override
    public PrivateKey legacyDerive(long index) {
        throw new IllegalStateException("ECDSA secp256k1 keys do not currently support derivation");
    }

    @Override
    public boolean isDerivable() {
        return this.chainCode != null;
    }

    @Override
    public PrivateKey derive(int index) {
        if (!isDerivable()) {
            throw new IllegalStateException("this private key does not support derivation");
        }

        boolean isHardened = Bip32Utils.isHardenedIndex(index);
        ByteBuffer data = ByteBuffer.allocate(37);

        if (isHardened) {
            byte[] bytes33 = new byte[33];
            byte[] priv = toBytesRaw();
            System.arraycopy(priv, 0, bytes33, 33 - priv.length, priv.length);
            data.put(bytes33);
        } else {
            data.put(getPublicKey().toBytesRaw());
        }
        data.putInt(index);

        byte[] dataArray = data.array();
        HMac hmacSha512 = new HMac(new SHA512Digest());
        hmacSha512.init(new KeyParameter(chainCode.getKey()));
        hmacSha512.update(dataArray, 0, dataArray.length);

        byte[] i = new byte[64];
        hmacSha512.doFinal(i, 0);

        var il = java.util.Arrays.copyOfRange(i, 0, 32);
        var ir = java.util.Arrays.copyOfRange(i, 32, 64);

        var ki = keyData.add(new BigInteger(1, il)).mod(ECDSA_SECP256K1_CURVE.getN());

        return new PrivateKeyECDSA(ki, new KeyParameter(ir));
    }

    /**
     * Create an ECDSA key from seed.
     *
     * @param seed                      the seed bytes
     * @return                          the new key
     */
    public static PrivateKey fromSeed(byte[] seed) {
        var hmacSha512 = new HMac(new SHA512Digest());
        hmacSha512.init(new KeyParameter("Bitcoin seed".getBytes(StandardCharsets.UTF_8)));
        hmacSha512.update(seed, 0, seed.length);

        var derivedState = new byte[hmacSha512.getMacSize()];
        hmacSha512.doFinal(derivedState, 0);

        return derivableKeyECDSA(derivedState);
    }

    /**
     * Create a derived key.
     *
     * @param deriveData                data to derive the key
     * @return                          the new key
     */
    static PrivateKeyECDSA derivableKeyECDSA(byte[] deriveData) {
        var keyData = java.util.Arrays.copyOfRange(deriveData, 0, 32);
        var chainCode = new KeyParameter(deriveData, 32, 32);

        return new PrivateKeyECDSA(new BigInteger(1, keyData), chainCode);
    }

    @Override
    public PublicKey getPublicKey() {
        if (publicKey != null) {
            return publicKey;
        }

        var q = ECDSA_SECP256K1_DOMAIN.getG().multiply(keyData);
        var publicParams = new ECPublicKeyParameters(q, ECDSA_SECP256K1_DOMAIN);
        publicKey = new PublicKeyECDSA(publicParams.getQ().getEncoded(true));
        return publicKey;
    }

    public KeyParameter getChainCode() {
        return chainCode;
    }

    @Override
    public byte[] sign(byte[] message) {
        var hash = Crypto.calcKeccak256(message);

        var signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));
        signer.init(true, new ECPrivateKeyParameters(keyData, ECDSA_SECP256K1_DOMAIN));
        BigInteger[] bigSig = signer.generateSignature(hash);

        byte[] sigBytes = Arrays.copyOf(bigIntTo32Bytes(bigSig[0]), 64);
        System.arraycopy(bigIntTo32Bytes(bigSig[1]), 0, sigBytes, 32, 32);

        return sigBytes;
    }

    public int getRecoveryId(byte[] r, byte[] s, byte[] message) {
        int recId = -1;
        var hash = Crypto.calcKeccak256(message);
        var publicKey = getPublicKey().toBytesRaw();
        // On this curve, there are only two possible values for the recovery id.
        for (int i = 0; i < 2; i++) {
            byte[] k = Crypto.recoverPublicKeyECDSAFromSignature(i, new BigInteger(1, r), new BigInteger(1, s), hash);
            if (k != null && java.util.Arrays.equals(k, publicKey)) {
                recId = i;
                break;
            }
        }

        if (recId == -1) {
            // this should never happen
            throw new IllegalStateException("Unexpected error - could not construct a recoverable key.");
        }

        return recId;
    }

    @Override
    public byte[] toBytes() {
        return toBytesDER();
    }

    /**
     * Create a big int byte array.
     *
     * @param n                         the big integer
     * @return                          the 32 byte array
     */
    private static byte[] bigIntTo32Bytes(BigInteger n) {
        byte[] bytes = n.toByteArray();
        byte[] bytes32 = new byte[32];
        System.arraycopy(
            bytes, Math.max(0, bytes.length - 32),
            bytes32, Math.max(0, 32 - bytes.length),
            Math.min(32, bytes.length)
        );
        return bytes32;
    }

    @Override
    public byte[] toBytesRaw() {
        return bigIntTo32Bytes(keyData);
    }

    @Override
    public byte[] toBytesDER() {
        try {
            return new ECPrivateKey(
                256,
                keyData,
                new DERBitString(getPublicKey().toBytesRaw()),
                new X962Parameters(ID_ECDSA_SECP256K1)
            ).getEncoded("DER");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public boolean isED25519() {
        return false;
    }

    @Override
    public boolean isECDSA() {
        return true;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PrivateKeyED25519.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.utils.Bip32Utils;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;
import org.bouncycastle.crypto.macs.HMac;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.math.ec.rfc8032.Ed25519;

import javax.annotation.Nullable;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

/**
 * Encapsulate the ED25519 private key.
 */
class PrivateKeyED25519 extends PrivateKey {
    private final byte[] keyData;

    @Nullable
    private final KeyParameter chainCode;

    /**
     * Constructor.
     *
     * @param keyData                   the key data
     * @param chainCode                 the chain code
     */
    PrivateKeyED25519(byte[] keyData, @Nullable KeyParameter chainCode) {
        this.keyData = keyData;
        this.chainCode = chainCode;
    }

    /**
     * Create a new private ED25519 key.
     *
     * @return                          the new key
     */
    static PrivateKeyED25519 generateInternal() {
        // extra 32 bytes for chain code
        byte[] data = new byte[Ed25519.SECRET_KEY_SIZE + 32];
        ThreadLocalSecureRandom.current().nextBytes(data);

        return derivableKeyED25519(data);
    }

    /**
     * Create a new private key from a private key info object.
     *
     * @param privateKeyInfo            the private key info object
     * @return                          the new key
     */
    static PrivateKeyED25519 fromPrivateKeyInfoInternal(PrivateKeyInfo privateKeyInfo) {
        try {
            var privateKey = (ASN1OctetString) privateKeyInfo.parsePrivateKey();

            return new PrivateKeyED25519(privateKey.getOctets(), null);
        } catch (IOException e) {
            throw new BadKeyException(e);
        }
    }

    /**
     * Create an ED25519 key from seed.
     *
     * @param seed                      the seed bytes
     * @return                          the new key
     */
    public static PrivateKey fromSeed(byte[] seed) {
        var hmacSha512 = new HMac(new SHA512Digest());
        hmacSha512.init(new KeyParameter("ed25519 seed".getBytes(StandardCharsets.UTF_8)));
        hmacSha512.update(seed, 0, seed.length);

        var derivedState = new byte[hmacSha512.getMacSize()];
        hmacSha512.doFinal(derivedState, 0);

        return PrivateKeyED25519.derivableKeyED25519(derivedState);
    }

    /**
     * Create a derived key.
     *
     * @param deriveData                data to derive the key
     * @return                          the new key
     */
    static PrivateKeyED25519 derivableKeyED25519(byte[] deriveData) {
        var keyData = Arrays.copyOfRange(deriveData, 0, 32);
        var chainCode = new KeyParameter(deriveData, 32, 32);

        return new PrivateKeyED25519(keyData, chainCode);
    }

    /**
     * Create a private key from a byte array.
     *
     * @param privateKey                the byte array
     * @return                          the new key
     */
    static PrivateKey fromBytesInternal(byte[] privateKey) {
        if ((privateKey.length == Ed25519.SECRET_KEY_SIZE)
            || (privateKey.length == Ed25519.SECRET_KEY_SIZE + Ed25519.PUBLIC_KEY_SIZE)) {
            // If this is a 32 or 64 byte string, assume an Ed25519 private key
            return new PrivateKeyED25519(Arrays.copyOfRange(privateKey, 0, Ed25519.SECRET_KEY_SIZE), null);
        }

        // Assume a DER-encoded private key descriptor
        return fromPrivateKeyInfoInternal(PrivateKeyInfo.getInstance(privateKey));
    }

    /**
     * Derive a legacy child key.
     *
     * @param entropy                   entropy byte array
     * @param index                     the child key index
     * @return                          the new key
     */
    static byte[] legacyDeriveChildKey(byte[] entropy, long index) {
        byte[] seed = new byte[entropy.length + 8];
        Arrays.fill(seed, 0, seed.length, (byte) 0);
        if (index == 0xffffffffffL) {
            seed[entropy.length + 3] = (byte) 0xff;
            Arrays.fill(seed, entropy.length + 4, seed.length, (byte) (index >>> 32));
        } else {
            if (index < 0) {
                Arrays.fill(seed, entropy.length, entropy.length + 4, (byte) -1);
            } else {
                Arrays.fill(seed, entropy.length, entropy.length + 4, (byte) 0);
            }
            Arrays.fill(seed, entropy.length + 4, seed.length, Long.valueOf(index).byteValue());
        }
        System.arraycopy(entropy, 0, seed, 0, entropy.length);

        byte[] salt = new byte[1];
        salt[0] = -1;
        PKCS5S2ParametersGenerator pbkdf2 = new PKCS5S2ParametersGenerator(new SHA512Digest());
        pbkdf2.init(
            seed,
            salt,
            2048);

        KeyParameter key = (KeyParameter) pbkdf2.generateDerivedParameters(256);
        return key.getKey();
    }

    @Override
    public PrivateKey legacyDerive(long index) {
        var keyBytes = legacyDeriveChildKey(this.keyData, index);

        return fromBytesInternal(keyBytes);
    }

    @Override
    public boolean isDerivable() {
        return this.chainCode != null;
    }

    @Override
    public PrivateKey derive(int index) {
        if (this.chainCode == null) {
            throw new IllegalStateException("this private key does not support derivation");
        }

        if (Bip32Utils.isHardenedIndex(index)) {
            throw new IllegalArgumentException("the index should not be pre-hardened");
        }

        // SLIP-10 child key derivation
        // https://github.com/satoshilabs/slips/blob/master/slip-0010.md#master-key-generation
        var hmacSha512 = new HMac(new SHA512Digest());

        hmacSha512.init(chainCode);
        hmacSha512.update((byte) 0);

        hmacSha512.update(keyData, 0, Ed25519.SECRET_KEY_SIZE);

        // write the index in big-endian order, setting the 31st bit to mark it "hardened"
        var indexBytes = new byte[4];
        ByteBuffer.wrap(indexBytes).order(ByteOrder.BIG_ENDIAN).putInt(index);
        indexBytes[0] |= (byte) 0b10000000;

        hmacSha512.update(indexBytes, 0, indexBytes.length);

        var output = new byte[64];
        hmacSha512.doFinal(output, 0);

        return derivableKeyED25519(output);
    }

    @Override
    public PublicKey getPublicKey() {
        if (publicKey != null) {
            return publicKey;
        }

        byte[] publicKeyData = new byte[Ed25519.PUBLIC_KEY_SIZE];
        Ed25519.generatePublicKey(keyData, 0, publicKeyData, 0);

        publicKey = new PublicKeyED25519(publicKeyData);
        return publicKey;
    }

    public KeyParameter getChainCode() {
        return chainCode;
    }

    @Override
    public byte[] sign(byte[] message) {
        byte[] signature = new byte[Ed25519.SIGNATURE_SIZE];
        Ed25519.sign(keyData, 0, message, 0, message.length, signature, 0);

        return signature;
    }

    @Override
    public byte[] toBytes() {
        return toBytesRaw();
    }

    @Override
    public byte[] toBytesRaw() {
        return keyData;
    }

    @Override
    public byte[] toBytesDER() {
        try {
            return new PrivateKeyInfo(
                new AlgorithmIdentifier(ID_ED25519),
                new DEROctetString(keyData)
            ).getEncoded("DER");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public boolean isED25519() {
        return true;
    }

    @Override
    public boolean isECDSA() {
        return false;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PrngTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.*;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;

/**
 * Random Number Generator Transaction.
 */
public class PrngTransaction extends Transaction<PrngTransaction> {

    /**
     * If provided and is positive, returns a 32-bit pseudorandom number from the given range in the transaction record.
     * If not set or set to zero, will return a 384-bit pseudorandom data in the record.
     */
    @Nullable
    private Integer range = null;

    /**
     * Constructor.
     */
    public PrngTransaction() {
    }

    /**
     * Assign the range.
     *
     * @param range                     if > 0 32 bit else 384 bit
     * @return {@code this}
     */
    public PrngTransaction setRange(Integer range) {
        this.range = range;
        return this;
    }

    /**
     * Retrieve the range.
     *
     * @return                          the range
     */
    public Integer getRange() {
        return range;
    }

    UtilPrngTransactionBody.Builder build() {
        var builder = UtilPrngTransactionBody.newBuilder();

        if (range != null) {
            builder.setRange(range);
        }

        return builder;
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setUtilPrng(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("cannot schedule RngTransaction");
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return UtilServiceGrpc.getPrngMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ProxyStaker.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Information about a single account that is proxy staking.
 */
public final class ProxyStaker {
    /**
     * The Account ID that is proxy staking.
     */
    public final AccountId accountId;

    /**
     * The number of hbars that are currently proxy staked.
     */
    public final Hbar amount;

    /**
     * Constructor.
     *
     * @param accountId                 the account id
     * @param amount                    the amount
     */
    private ProxyStaker(AccountId accountId, long amount) {
        this.accountId = accountId;
        this.amount = Hbar.fromTinybars(amount);
    }

    /**
     * Create a proxy staker object from a protobuf.
     *
     * @param proxyStaker               the protobuf
     * @return                          the new proxy staker object
     */
    static ProxyStaker fromProtobuf(com.hedera.hashgraph.sdk.proto.ProxyStaker proxyStaker) {
        return new ProxyStaker(AccountId.fromProtobuf(proxyStaker.getAccountID()), proxyStaker.getAmount());
    }

    @Override
    public String toString() {
        return "ProxyStaker{" +
            "accountId=" + accountId +
            ", amount=" + amount +
            '}';
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PublicKey.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SignaturePair;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.math.ec.rfc8032.Ed25519;
import org.bouncycastle.util.encoders.Hex;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;

/**
 * A public key on the Hedera network.
 */
public abstract class PublicKey extends Key {
    /**
     * Create a public key from a byte array.
     *
     * @param publicKey                 the byte array
     * @return                          the new public key
     */
    public static PublicKey fromBytes(byte[] publicKey) {
        if (publicKey.length == Ed25519.PUBLIC_KEY_SIZE) {
            // If this is a 32 byte string, assume an Ed25519 public key
            return new PublicKeyED25519(publicKey);
        } else if (publicKey.length == 33) {
            // compressed 33 byte raw form
            return new PublicKeyECDSA(publicKey);
        } else if (publicKey.length == 65) {
            // compress the 65 byte form
            return new PublicKeyECDSA(
                Key.ECDSA_SECP256K1_CURVE.getCurve().decodePoint(publicKey).getEncoded(true)
            );
        }

        // Assume a DER-encoded private key descriptor
        return fromBytesDER(publicKey);
    }

    /**
     * Create a public key from a DER encoded byte array.
     *
     * @param publicKey                 the DER encoded byte array
     * @return                          the new key
     */
    public static PublicKey fromBytesDER(byte[] publicKey) {
        return PublicKey.fromSubjectKeyInfo(SubjectPublicKeyInfo.getInstance(publicKey));
    }

    /**
     * Create a public key from a byte array.
     *
     * @param publicKey                 the byte array
     * @return                          the new key
     */
    public static PublicKey fromBytesED25519(byte[] publicKey) {
        return PublicKeyED25519.fromBytesInternal(publicKey);
    }

    /**
     * Create a public key from a byte array.
     *
     * @param publicKey                 the byte array
     * @return                          the new key
     */
    public static PublicKey fromBytesECDSA(byte[] publicKey) {
        return PublicKeyECDSA.fromBytesInternal(publicKey);
    }

    /**
     * Create a public key from a string.
     *
     * @param publicKey                 the string
     * @return                          the new key
     */
    public static PublicKey fromString(String publicKey) {
        return PublicKey.fromBytes(Hex.decode(publicKey));
    }

    /**
     * Create a public key from a string.
     *
     * @param publicKey                 the string
     * @return                          the new key
     */
    public static PublicKey fromStringED25519(String publicKey) {
        return fromBytesED25519(Hex.decode(publicKey));
    }

    /**
     * Create a public key from a string.
     *
     * @param publicKey                 the string
     * @return                          the new key
     */
    public static PublicKey fromStringECDSA(String publicKey) {
        return fromBytesECDSA(Hex.decode(publicKey));
    }

    /**
     * Create a public key from a string.
     *
     * @param publicKey                 the string
     * @return                          the new key
     */
    public static PublicKey fromStringDER(String publicKey) {
        return fromBytesDER(Hex.decode(publicKey));
    }

    /**
     * Create a public key from a subject public key info object.
     *
     * @param subjectPublicKeyInfo      the subject public key info object
     * @return                          the new key
     */
    private static PublicKey fromSubjectKeyInfo(SubjectPublicKeyInfo subjectPublicKeyInfo) {
        if(subjectPublicKeyInfo.getAlgorithm().equals(new AlgorithmIdentifier(ID_ED25519))) {
            return PublicKeyED25519.fromSubjectKeyInfoInternal(subjectPublicKeyInfo);
        } else {
            // assume ECDSA
            return PublicKeyECDSA.fromSubjectKeyInfoInternal(subjectPublicKeyInfo);
        }
    }

    /**
     * The public key from an immutable byte string.
     *
     * @param aliasBytes                the immutable byte string
     * @return                          the key
     */
    @Nullable
    static PublicKey fromAliasBytes(ByteString aliasBytes) {
        if (!aliasBytes.isEmpty()) {
            try {
                var key = Key.fromProtobufKey(com.hedera.hashgraph.sdk.proto.Key.parseFrom(aliasBytes));
                return (key instanceof PublicKey) ? ((PublicKey) key) : null;
            } catch (InvalidProtocolBufferException ignored) {
            }
        }
        return null;
    }

    /**
     * Verify a signature on a message with this public key.
     *
     * @param message   The array of bytes representing the message
     * @param signature The array of bytes representing the signature
     * @return boolean
     */
    public abstract boolean verify(byte[] message, byte[] signature);

    /**
     * Get the signature from a signature pair protobuf.
     *
     * @param pair                      the protobuf
     * @return                          the signature
     */
    abstract ByteString extractSignatureFromProtobuf(SignaturePair pair);

    /**
     * Is the given transaction valid?
     *
     * @param transaction               the transaction
     * @return                          is it valid
     */
    public boolean verifyTransaction(Transaction<?> transaction) {
        if (!transaction.isFrozen()) {
            transaction.freeze();
        }

        for (var publicKey : transaction.publicKeys) {
            if (publicKey.equals(this)) {
                return true;
            }
        }

        for (var signedTransaction : transaction.innerSignedTransactions) {
            @Var var found = false;

            for (var sigPair : signedTransaction.getSigMap().getSigPairList()) {
                if (sigPair.getPubKeyPrefix().equals(ByteString.copyFrom(toBytesRaw()))) {
                    found = true;

                    if (!verify(signedTransaction.getBodyBytes().toByteArray(), extractSignatureFromProtobuf(sigPair).toByteArray())) {
                        return false;
                    }
                }
            }

            if (!found) {
                return false;
            }
        }

        return true;
    }

    /**
     * Serialize this key as a SignaturePair protobuf object
     */
    abstract SignaturePair toSignaturePairProtobuf(byte[] signature);

    @Override
    public abstract byte[] toBytes();

    /**
     * Extract the DER represented as a byte array.
     *
     * @return                          the DER represented as a byte array
     */
    public abstract byte[] toBytesDER();

    /**
     * Extract the raw byte representation.
     *
     * @return                          the raw byte representation
     */
    public abstract byte[] toBytesRaw();

    @Override
    public String toString() {
        return toStringDER();
    }

    /**
     * Extract the DER encoded string.
     *
     * @return                          the DER encoded string
     */
    public String toStringDER() {
        return Hex.toHexString(toBytesDER());
    }

    /**
     * Extract the raw string.
     *
     * @return                          the raw string
     */
    public String toStringRaw() {
        return Hex.toHexString(toBytesRaw());
    }

    /**
     * Create a new account id.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @return                          the new account id
     */
    public AccountId toAccountId(@Nonnegative long shard, @Nonnegative long realm) {
        return new AccountId(shard, realm, 0, null, this, null);
    }

    /**
     * Is this an ED25519 key?
     *
     * @return                          is this an ED25519 key
     */
    public abstract boolean isED25519();

    /**
     * Is this an ECDSA key?
     *
     * @return                          is this an ECDSA key
     */
    public abstract boolean isECDSA();

    /**
     * Converts the key to EVM address
     *
     * @return                          the EVM address
     */
    public abstract EvmAddress toEvmAddress();

    /**
     * Returns an "unusable" public key.
     * Unusable refers to a key such as an Ed25519 0x00000... public key,
     * since it is (presumably) impossible to find the 32-byte string whose SHA-512 hash begins with 32 bytes of zeros.
     *
     * @return The "unusable" key
     */
    public static PublicKey unusableKey() {
        return PublicKey.fromStringED25519("0000000000000000000000000000000000000000000000000000000000000000");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PublicKeyECDSA.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.SignaturePair;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.signers.ECDSASigner;

import java.io.IOException;
import java.math.BigInteger;
import java.util.Arrays;

import static com.hedera.hashgraph.sdk.Crypto.calcKeccak256;

/**
 * Encapsulate the ECDSA public key.
 */
public class PublicKeyECDSA extends PublicKey {
    // Compressed 33 byte form
    private byte[] keyData;

    /**
     * Constructor.
     *
     * @param keyData                   the byte array representing the key
     */
    PublicKeyECDSA(byte[] keyData) {
        this.keyData = keyData;
    }

    /**
     * Create a key from a byte array representation.
     *
     * @param publicKey                 the byte array representing the key
     * @return                          the new key
     */
    static PublicKeyECDSA fromBytesInternal(byte[] publicKey) {
        if (publicKey.length == 33) {
            // compressed 33 byte raw form
            return new PublicKeyECDSA(publicKey);
        } else if (publicKey.length == 65) {
            // compress the 65 byte form
            return new PublicKeyECDSA(
                Key.ECDSA_SECP256K1_CURVE.getCurve().decodePoint(publicKey).getEncoded(true)
            );
        }

        // Assume a DER-encoded public key descriptor
        return fromSubjectKeyInfoInternal(SubjectPublicKeyInfo.getInstance(publicKey));
    }

    /**
     * Create a key from a subject public key info object.
     *
     * @param subjectPublicKeyInfo      the subject public key info object
     * @return                          the new public key
     */
    static PublicKeyECDSA fromSubjectKeyInfoInternal(SubjectPublicKeyInfo subjectPublicKeyInfo) {
        return fromBytesInternal(subjectPublicKeyInfo.getPublicKeyData().getBytes());
    }

    @Override
    ByteString extractSignatureFromProtobuf(SignaturePair pair) {
        return pair.getECDSA384();
    }

    @Override
    public boolean verify(byte[] message, byte[] signature) {
        var hash = calcKeccak256(message);

        ECDSASigner signer = new ECDSASigner();
        signer.init(false, new ECPublicKeyParameters(
            Key.ECDSA_SECP256K1_CURVE.getCurve().decodePoint(keyData),
            Key.ECDSA_SECP256K1_DOMAIN
        ));

        BigInteger r = new BigInteger(1, Arrays.copyOf(signature, 32));
        BigInteger s = new BigInteger(1, Arrays.copyOfRange(signature, 32, 64));

        return signer.verifySignature(hash, r, s);
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        return com.hedera.hashgraph.sdk.proto.Key.newBuilder()
            .setECDSASecp256K1(ByteString.copyFrom(keyData))
            .build();
    }

    @Override
    SignaturePair toSignaturePairProtobuf(byte[] signature) {
        return SignaturePair.newBuilder()
            .setPubKeyPrefix(ByteString.copyFrom(keyData))
            .setECDSASecp256K1(ByteString.copyFrom(signature))
            .build();
    }

    @Override
    public byte[] toBytesDER() {
        try {
            return new SubjectPublicKeyInfo(
                new AlgorithmIdentifier(ID_EC_PUBLIC_KEY, ID_ECDSA_SECP256K1),
                keyData
            ).getEncoded("DER");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public byte[] toBytes() {
        return toBytesDER();
    }

    @Override
    public byte[] toBytesRaw() {
        return Arrays.copyOf(keyData, keyData.length);
    }

    @Override
    public EvmAddress toEvmAddress() {
        // Calculate the Keccak-256 hash of the uncompressed key without "04" prefix
        byte[] uncompressed = Key.ECDSA_SECP256K1_CURVE
            .getCurve().decodePoint(toBytesRaw()).getEncoded(false);
        byte[] keccakBytes = calcKeccak256(Arrays.copyOfRange(uncompressed, 1, uncompressed.length));

        // Return the last 20 bytes
        return EvmAddress.fromBytes(Arrays.copyOfRange(keccakBytes, 12, 32));
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        PublicKeyECDSA publicKey = (PublicKeyECDSA) o;
        return Arrays.equals(keyData, publicKey.keyData);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(keyData);
    }

    @Override
    public boolean isED25519() {
        return false;
    }

    @Override
    public boolean isECDSA() {
        return true;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/PublicKeyED25519.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.SignaturePair;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.math.ec.rfc8032.Ed25519;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.Arrays;

/**
 * Encapsulate the ED25519 public key.
 */
class PublicKeyED25519 extends PublicKey {
    private final byte[] keyData;

    /**
     * Constructor.
     *
     * @param keyData                   the byte array representing the key
     */
    PublicKeyED25519(byte[] keyData) {
        this.keyData = keyData;
    }

    /**
     * Create a key from a byte array representation.
     *
     * @param publicKey                 the byte array representing the key
     * @return                          the new key
     */
    static PublicKeyED25519 fromBytesInternal(byte[] publicKey) {
        if (publicKey.length == Ed25519.PUBLIC_KEY_SIZE) {
            // If this is a 32 byte string, assume an Ed25519 public key
            return new PublicKeyED25519(publicKey);
        }

        // Assume a DER-encoded public key descriptor
        return fromSubjectKeyInfoInternal(SubjectPublicKeyInfo.getInstance(publicKey));
    }

    /**
     * Create a key from a subject public key info object.
     *
     * @param subjectPublicKeyInfo      the subject public key info object
     * @return                          the new public key
     */
    static PublicKeyED25519 fromSubjectKeyInfoInternal(SubjectPublicKeyInfo subjectPublicKeyInfo) {
        return new PublicKeyED25519(subjectPublicKeyInfo.getPublicKeyData().getBytes());
    }

    @Override
    ByteString extractSignatureFromProtobuf(SignaturePair pair) {
        return pair.getEd25519();
    }

    @Override
    public boolean verify(byte[] message, byte[] signature) {
        return Ed25519.verify(signature, 0, keyData, 0, message, 0, message.length);
    }

    @Override
    com.hedera.hashgraph.sdk.proto.Key toProtobufKey() {
        return com.hedera.hashgraph.sdk.proto.Key.newBuilder()
            .setEd25519(ByteString.copyFrom(keyData))
            .build();
    }

    @Override
    SignaturePair toSignaturePairProtobuf(byte[] signature) {
        return SignaturePair.newBuilder()
            .setPubKeyPrefix(ByteString.copyFrom(keyData))
            .setEd25519(ByteString.copyFrom(signature))
            .build();
    }

    @Override
    public byte[] toBytesDER() {
        try {
            return new SubjectPublicKeyInfo(
                new AlgorithmIdentifier(ID_ED25519),
                keyData
            ).getEncoded("DER");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public byte[] toBytes() {
        return toBytesRaw();
    }

    @Override
    public byte[] toBytesRaw() {
        return keyData;
    }

    @Override
    public EvmAddress toEvmAddress() {
        throw new IllegalStateException("unsupported operation on Ed25519PublicKey");
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        PublicKeyED25519 publicKey = (PublicKeyED25519) o;
        return Arrays.equals(keyData, publicKey.keyData);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(keyData);
    }

    @Override
    public boolean isED25519() {
        return true;
    }

    @Override
    public boolean isECDSA() {
        return false;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Query.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.ResponseType;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.grpc.MethodDescriptor;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;

/**
 * Base class for all queries that can be submitted to Hedera.
 *
 * @param <O> The output type of the query.
 * @param <T> The type of the query itself. Used to enable chaining.
 */
public abstract class Query<O, T extends Query<O, T>> extends Executable<T, com.hedera.hashgraph.sdk.proto.Query, Response, O> {
    private final com.hedera.hashgraph.sdk.proto.Query.Builder builder;

    private final QueryHeader.Builder headerBuilder;

    /**
     * The transaction ID
     */
    @Nullable
    protected TransactionId paymentTransactionId = null;

    /**
     * List of payment transactions
     */
    @Nullable
    protected List<Transaction> paymentTransactions = null;
    @Nullable
    private Client.Operator paymentOperator = null;
    @Nullable
    private Hbar queryPayment = null;

    @Nullable
    private Hbar maxQueryPayment = null;

    @Nullable
    private Hbar chosenQueryPayment = null;

    /**
     * Constructor.
     */
    Query() {
        builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        headerBuilder = QueryHeader.newBuilder();
    }

    /**
     * Create a payment transaction.
     *
     * @param paymentTransactionId      the transaction id
     * @param nodeId                    the node id
     * @param operator                  the operator
     * @param paymentAmount             the amount
     * @return                          the new payment transaction
     */
    private static Transaction makePaymentTransaction(
        TransactionId paymentTransactionId,
        AccountId nodeId,
        Client.Operator operator,
        Hbar paymentAmount
    ) {
        return new TransferTransaction()
            .setTransactionId(paymentTransactionId)
            .setNodeAccountIds(Collections.singletonList(nodeId))
            .setMaxTransactionFee(new Hbar(1)) // 1 Hbar
            .addHbarTransfer(operator.accountId, paymentAmount.negated())
            .addHbarTransfer(nodeId, paymentAmount)
            .freeze()
            .signWith(operator.publicKey, operator.transactionSigner)
            .makeRequest();
    }

    /**
     * Set an explicit payment amount for this query.
     * <p>
     * The client will submit exactly this amount for the payment of this query. Hedera
     * will not return any remainder.
     *
     * @param queryPayment The explicit payment amount to set
     * @return {@code this}
     */
    public T setQueryPayment(Hbar queryPayment) {
        this.queryPayment = queryPayment;

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Set the maximum payment allowable for this query.
     * <p>
     * When a query is executed without an explicit {@link Query#setQueryPayment(Hbar)} call,
     * the client will first request the cost
     * of the given query from the node it will be submitted to and attach a payment for that amount
     * from the operator account on the client.
     * <p>
     * If the returned value is greater than this value, a
     * {@link MaxQueryPaymentExceededException} will be thrown from
     * {@link Query#execute(Client)} or returned in the second callback of
     * {@link Query#executeAsync(Client, Consumer, Consumer)}.
     * <p>
     * Set to 0 to disable automatic implicit payments.
     *
     * @param maxQueryPayment The maximum payment amount to set
     * @return {@code this}
     */
    public T setMaxQueryPayment(Hbar maxQueryPayment) {
        this.maxQueryPayment = maxQueryPayment;

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Fetch the expected cost.
     *
     * @param client                    the client
     * @return                          the cost in hbar
     * @throws TimeoutException         when the transaction times out
     * @throws PrecheckStatusException  when the precheck fails
     */
    public Hbar getCost(Client client) throws TimeoutException, PrecheckStatusException {
        return getCost(client, client.getRequestTimeout());
    }

    /**
     * Fetch the expected cost.
     *
     * @param client                    the client
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the cost in hbar
     * @throws TimeoutException         when the transaction times out
     * @throws PrecheckStatusException  when the precheck fails
     */
    public Hbar getCost(Client client, Duration timeout) throws TimeoutException, PrecheckStatusException {
        initWithNodeIds(client);
        return getCostExecutable().setNodeAccountIds(Objects.requireNonNull(getNodeAccountIds())).execute(client, timeout);
    }

    /**
     * Fetch the expected cost asynchronously.
     *
     * @param client                    the client
     * @return                          Future result of the cost in hbar
     */
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        return getCostAsync(client, client.getRequestTimeout());
    }

    /**
     * Fetch the expected cost asynchronously.
     *
     * @param client                    the client
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          Future result of the cost in hbar
     */
    public CompletableFuture<Hbar> getCostAsync(Client client, Duration timeout) {
        initWithNodeIds(client);
        return getCostExecutable().setNodeAccountIds(Objects.requireNonNull(getNodeAccountIds())).executeAsync(client, timeout);
    }

    /**
     * Fetch the expected cost asynchronously.
     *
     * @param client                    the client
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getCostAsync(Client client, Duration timeout, BiConsumer<Hbar, Throwable> callback) {
        ConsumerHelper.biConsumer(getCostAsync(client, timeout), callback);
    }

    /**
     * Fetch the expected cost asynchronously.
     *
     * @param client                    the client
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getCostAsync(Client client, BiConsumer<Hbar, Throwable> callback) {
        ConsumerHelper.biConsumer(getCostAsync(client), callback);
    }

    /**
     * Fetch the expected cost asynchronously.
     *
     * @param client                    the client
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getCostAsync(Client client, Duration timeout, Consumer<Hbar> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getCostAsync(client, timeout), onSuccess, onFailure);
    }

    /**
     * Fetch the expected cost asynchronously.
     *
     * @param client                    the client
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getCostAsync(Client client, Consumer<Hbar> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getCostAsync(client), onSuccess, onFailure);
    }

    /**
     * Does this query require a payment?
     *
     * @return                          does this query require a payment
     */
    boolean isPaymentRequired() {
        // nearly all queries require a payment
        return true;
    }

    /**
     * Called in {@link #makeRequest} just before the query is built. The intent is for the derived
     * class to assign their data variant to the query.
     */
    abstract void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header);

    /**
     * The derived class should access its response header and return.
     */
    abstract ResponseHeader mapResponseHeader(Response response);

    /**
     * The derived class should access its request header and return.
     */
    abstract QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request);

    /**
     * Crate the new Query.
     *
     * @return                          the new Query
     */
    private Query<Hbar, QueryCostQuery> getCostExecutable() {
        return new QueryCostQuery();
    }

    /**
     * Validate the checksums.
     */
    abstract void validateChecksums(Client client) throws BadEntityIdException;

    /**
     * Retrieve the operator from the configured client.
     *
     * @param client                    the configured client
     * @return                          the operator
     */
    Client.Operator getOperatorFromClient(Client client) {
        var operator = client.getOperator();

        if (operator == null) {
            throw new IllegalStateException(
                "`client` must have an `operator` or an explicit payment transaction must be provided");
        }

        return operator;
    }

    @Override
    void onExecute(Client client) throws TimeoutException, PrecheckStatusException {
        var grpcCostQuery = new GrpcCostQuery(client);

        if (grpcCostQuery.isNotRequired()) {
            return;
        }

        if (grpcCostQuery.getCost() == null) {
            grpcCostQuery.setCost(getCost(client));

            if (grpcCostQuery.shouldError()) {
                throw grpcCostQuery.mapError();
            }
        }

        grpcCostQuery.finish();
    }

    /**
     * <p>Note: This method requires API level 33 or higher. It will not work on devices running API versions below 31
     * because it uses features introduced in API level 31 (Android 12).</p>*
     */
    @Override
    CompletableFuture<Void> onExecuteAsync(Client client) {
        var grpcCostQuery = new GrpcCostQuery(client);

        if (grpcCostQuery.isNotRequired()) {
            return CompletableFuture.completedFuture(null);
        }

        return CompletableFuture.supplyAsync(() -> {
                if (grpcCostQuery.getCost() == null) {
                    // No payment was specified so we need to go ask
                    // This is a query in its own right so we use a nested future here
                    return getCostAsync(client).thenCompose(cost -> {
                        grpcCostQuery.setCost(cost);

                        if (grpcCostQuery.shouldError()) {
                            return CompletableFuture.failedFuture(grpcCostQuery.mapError());
                        }

                        return CompletableFuture.completedFuture(null);
                    });
                }

                return CompletableFuture.completedFuture(null);
            }, client.executor)
            .thenCompose(x -> x)
            .thenAccept((paymentAmount) -> {
                grpcCostQuery.finish();
            });
    }

    private void initWithNodeIds(Client client) {
        if (client.isAutoValidateChecksumsEnabled()) {
            try {
                validateChecksums(client);
            } catch (BadEntityIdException exc) {
                throw new IllegalArgumentException(exc.getMessage());
            }
        }

        if (nodeAccountIds.size() == 0) {
            // Get a list of node AccountId's if the user has not set them manually.
            try {
                nodeAccountIds.setList(client.network.getNodeAccountIdsForExecute());
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Retrieve the transaction at the given index.
     *
     * @param index                     the index
     * @return                          the transaction
     */
    Transaction getPaymentTransaction(int index) {
        var paymentTx = Objects.requireNonNull(paymentTransactions).get(index);
        if (paymentTx != null) {
            return paymentTx;
        } else {
            if (paymentTransactionId == null) {
                paymentTransactionId = TransactionId.generate(Objects.requireNonNull(paymentOperator).accountId);
            }

            var newPaymentTx = makePaymentTransaction(
                paymentTransactionId,
                nodeAccountIds.get(index),
                paymentOperator,
                Objects.requireNonNull(chosenQueryPayment)
            );
            paymentTransactions.set(index, newPaymentTx);
            return newPaymentTx;
        }
    }

    @Override
    final com.hedera.hashgraph.sdk.proto.Query makeRequest() {
        // If payment is required, set the next payment transaction on the query
        if (isPaymentRequired() && paymentTransactions != null) {
            headerBuilder.setPayment(getPaymentTransaction(nodeAccountIds.getIndex()));
        }

        // Delegate to the derived class to apply the header because the common header struct is
        // within the nested type
        onMakeRequest(builder, headerBuilder.setResponseType(ResponseType.ANSWER_ONLY).build());

        return builder.build();
    }

    @Override
    Status mapResponseStatus(Response response) {
        var preCheckCode = mapResponseHeader(response).getNodeTransactionPrecheckCode();

        return Status.valueOf(preCheckCode);
    }

    @Override
    @Nullable
    TransactionId getTransactionIdInternal() {
        // this is only called on an error about either the payment transaction or missing a payment transaction
        // as we make sure the latter can't happen, this will never be null
        return paymentTransactionId;
    }

    /**
     * Extract the transaction id.
     *
     * @return                          the transaction id
     */
    @Nullable
    public TransactionId getPaymentTransactionId() {
        return paymentTransactionId;
    }

    /**
     * Assign the transaction id.
     *
     * @param paymentTransactionId      the transaction id
     * @return {@code this}
     */
    @Nullable
    public T setPaymentTransactionId(TransactionId paymentTransactionId) {
        this.paymentTransactionId = paymentTransactionId;

        // noinspection unchecked
        return (T) this;
    }

    @Override
    @SuppressWarnings("LiteProtoToString")
    public String toString() {
        var request = makeRequest();

        StringBuilder builder = new StringBuilder(request.toString().replaceAll("(?m)^# com.hedera.hashgraph.sdk.proto.Query.*", ""));

        var queryHeader = mapRequestHeader(request);
        if (queryHeader.hasPayment()) {
            builder.append("\n");

            try {
                // the replaceAll() is for removing the class name from Transaction Body
                builder.append(TransactionBody.parseFrom(queryHeader.getPayment().getBodyBytes()).toString().replaceAll("(?m)^# com.hedera.hashgraph.sdk.proto.TransactionBuilder.*", ""));
            } catch (InvalidProtocolBufferException e) {
                throw new RuntimeException(e);
            }
        }

        return builder.toString();
    }

    private class GrpcCostQuery {
        private final Hbar maxCost;
        private final boolean notRequired;

        private Client.Operator operator;
        private Hbar cost;

        GrpcCostQuery(Client client) {
            Query.this.initWithNodeIds(client);

            cost = Query.this.queryPayment;
            notRequired = (Query.this.paymentTransactions != null) || !Query.this.isPaymentRequired();
            maxCost = MoreObjects.firstNonNull(Query.this.maxQueryPayment, client.defaultMaxQueryPayment);

            if (!notRequired) {
                operator = Query.this.getOperatorFromClient(client);
            }
        }

        public Client.Operator getOperator() {
            return operator;
        }

        public Hbar getCost() {
            return cost;
        }

        public boolean isNotRequired() {
            return notRequired;
        }

        GrpcCostQuery setCost(Hbar cost) {
            this.cost = cost;
            return this;
        }

        boolean shouldError() {
            // Check if this is below our configured maximum query payment
            return cost.compareTo(maxCost) > 0;
        }

        MaxQueryPaymentExceededException mapError() {
            return new MaxQueryPaymentExceededException(Query.this, cost, maxCost);
        }

        void finish() {
            Query.this.chosenQueryPayment = cost;
            Query.this.paymentOperator = operator;
            Query.this.paymentTransactions = new ArrayList<>(Query.this.nodeAccountIds.size());

            for (int i = 0; i < Query.this.nodeAccountIds.size(); i++) {
                Query.this.paymentTransactions.add(null);
            }
        }
    }

    @SuppressWarnings("NullableDereference")
    private class QueryCostQuery extends Query<Hbar, QueryCostQuery> {
        @Override
        void validateChecksums(Client client) throws BadEntityIdException {
        }

        @Override
        void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
            headerBuilder.setResponseType(ResponseType.COST_ANSWER);

            // COST_ANSWER requires a payment to pass validation but doesn't actually process it
            // yes, this transaction is completely invalid
            // that is okay
            // now go back to sleep
            // without this, an error of MISSING_QUERY_HEADER is returned
            headerBuilder.setPayment(new TransferTransaction()
                .setNodeAccountIds(Collections.singletonList(new AccountId(0)))
                .setTransactionId(TransactionId.withValidStart(new AccountId(0), Instant.ofEpochSecond(0)))
                .freeze()
                .makeRequest());

            Query.this.onMakeRequest(queryBuilder, headerBuilder.build());
        }

        @Override
        ResponseHeader mapResponseHeader(Response response) {
            return Query.this.mapResponseHeader(response);
        }

        @Override
        QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
            return Query.this.mapRequestHeader(request);
        }

        @Override
        Hbar mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
            return Hbar.fromTinybars(mapResponseHeader(response).getCost());
        }

        @Override
        MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
            return Query.this.getMethodDescriptor();
        }

        @Override
        boolean isPaymentRequired() {
            // combo breaker
            return false;
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ReceiptStatusException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;

/**
 * An Exception thrown on error status by {@link TransactionId#getReceipt(Client)}.
 * <p>
 * The receipt is included, though only the {@link TransactionReceipt#status} field will be
 * initialized; all the getters should throw.
 */
public class ReceiptStatusException extends Exception {
    /**
     * The ID of the transaction that failed, in case that context is no longer available
     * (e.g. the exception was bubbled up).
     */
    @Nullable
    public final TransactionId transactionId;

    /**
     * The receipt of the transaction that failed; the only initialized field is
     * {@link TransactionReceipt#status}.
     */
    public final TransactionReceipt receipt;

    /**
     * Constructor.
     *
     * @param transactionId             the transaction id
     * @param receipt                   the receipt
     */
    ReceiptStatusException(@Nullable TransactionId transactionId, TransactionReceipt receipt) {
        this.transactionId = transactionId;
        this.receipt = receipt;
    }

    @Override
    public String getMessage() {
        return "receipt for transaction " + transactionId + " raised status " + receipt.status;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/RequestType.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.HederaFunctionality;

/**
 * Enum for the request types.
 */
public enum RequestType {
    /**
     * UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
     * not parsed (0 is ignored by parser)
     */
    NONE(HederaFunctionality.NONE),

    /**
     * crypto transfer
     */
    CRYPTO_TRANSFER(HederaFunctionality.CryptoTransfer),

    /**
     * crypto update account
     */
    CRYPTO_UPDATE(HederaFunctionality.CryptoUpdate),

    /**
     * crypto delete account
     */
    CRYPTO_DELETE(HederaFunctionality.CryptoDelete),

    /**
     * Add a livehash to a crypto account
     */
    CRYPTO_ADD_LIVE_HASH(HederaFunctionality.CryptoAddLiveHash),

    /**
     * Delete a livehash from a crypto account
     */
    CRYPTO_DELETE_LIVE_HASH(HederaFunctionality.CryptoDeleteLiveHash),

    /**
     * Smart Contract Call
     */
    CONTRACT_CALL(HederaFunctionality.ContractCall),

    /**
     * Smart Contract Create Contract
     */
    CONTRACT_CREATE(HederaFunctionality.ContractCreate),

    /**
     * Smart Contract update contract
     */
    CONTRACT_UPDATE(HederaFunctionality.ContractUpdate),

    /**
     * File Operation create file
     */
    FILE_CREATE(HederaFunctionality.FileCreate),

    /**
     * File Operation append file
     */
    FILE_APPEND(HederaFunctionality.FileAppend),

    /**
     * File Operation update file
     */
    FILE_UPDATE(HederaFunctionality.FileUpdate),

    /**
     * File Operation delete file
     */
    FILE_DELETE(HederaFunctionality.FileDelete),

    /**
     * crypto get account balance
     */
    CRYPTO_GET_ACCOUNT_BALANCE(HederaFunctionality.CryptoGetAccountBalance),

    /**
     * crypto get account record
     */
    CRYPTO_GET_ACCOUNT_RECORDS(HederaFunctionality.CryptoGetAccountRecords),

    /**
     * Crypto get info
     */
    CRYPTO_GET_INFO(HederaFunctionality.CryptoGetInfo),

    /**
     * Smart Contract Call
     */
    CONTRACT_CALL_LOCAL(HederaFunctionality.ContractCallLocal),

    /**
     * Smart Contract get info
     */
    CONTRACT_GET_INFO(HederaFunctionality.ContractGetInfo),

    /**
     * Smart Contract, get the runtime code
     */
    CONTRACT_GET_BYTECODE(HederaFunctionality.ContractGetBytecode),

    /**
     * Smart Contract, get by solidity ID
     */
    GET_BY_SOLIDITY_ID(HederaFunctionality.GetBySolidityID),

    /**
     * Smart Contract, get by key
     */
    GET_BY_KEY(HederaFunctionality.GetByKey),

    /**
     * Get a live hash from a crypto account
     */
    CRYPTO_GET_LIVE_HASH(HederaFunctionality.CryptoGetLiveHash),

    /**
     * Crypto, get the stakers for the node
     */
    CRYPTO_GET_STAKERS(HederaFunctionality.CryptoGetStakers),

    /**
     * File Operations get file contents
     */
    FILE_GET_CONTENTS(HederaFunctionality.FileGetContents),

    /**
     * File Operations get the info of the file
     */
    FILE_GET_INFO(HederaFunctionality.FileGetInfo),

    /**
     * Crypto get the transaction records
     */
    TRANSACTION_GET_RECORD(HederaFunctionality.TransactionGetRecord),

    /**
     * Contract get the transaction records
     */
    CONTRACT_GET_RECORDS(HederaFunctionality.ContractGetRecords),

    /**
     * crypto create account
     */
    CRYPTO_CREATE(HederaFunctionality.CryptoCreate),

    /**
     * system delete file
     */
    SYSTEM_DELETE(HederaFunctionality.SystemDelete),

    /**
     * system undelete file
     */
    SYSTEM_UNDELETE(HederaFunctionality.SystemUndelete),

    /**
     * delete contract
     */
    CONTRACT_DELETE(HederaFunctionality.ContractDelete),

    /**
     * freeze
     */
    FREEZE(HederaFunctionality.Freeze),

    /**
     * Create Tx Record
     */
    CREATE_TRANSACTION_RECORD(HederaFunctionality.CreateTransactionRecord),

    /**
     * Crypto Auto Renew
     */
    CRYPTO_ACCOUNT_AUTO_RENEW(HederaFunctionality.CryptoAccountAutoRenew),

    /**
     * Contract Auto Renew
     */
    CONTRACT_AUTO_RENEW(HederaFunctionality.ContractAutoRenew),

    /**
     * Get Version
     */
    GET_VERSION_INFO(HederaFunctionality.GetVersionInfo),

    /**
     * Transaction Get Receipt
     */
    TRANSACTION_GET_RECEIPT(HederaFunctionality.TransactionGetReceipt),

    /**
     * Create Topic
     */
    CONSENSUS_CREATE_TOPIC(HederaFunctionality.ConsensusCreateTopic),

    /**
     * Update Topic
     */
    CONSENSUS_UPDATE_TOPIC(HederaFunctionality.ConsensusUpdateTopic),

    /**
     * Delete Topic
     */
    CONSENSUS_DELETE_TOPIC(HederaFunctionality.ConsensusDeleteTopic),

    /**
     * Get Topic information
     */
    CONSENSUS_GET_TOPIC_INFO(HederaFunctionality.ConsensusGetTopicInfo),

    /**
     * Submit message to topic
     */
    CONSENSUS_SUBMIT_MESSAGE(HederaFunctionality.ConsensusSubmitMessage),

    UNCHECKED_SUBMIT(HederaFunctionality.UncheckedSubmit),

    /**
     * Create Token
     */
    TOKEN_CREATE(HederaFunctionality.TokenCreate),

    /**
     * Get Token information
     */
    TOKEN_GET_INFO(HederaFunctionality.TokenGetInfo),

    /**
     * Freeze Account
     */
    TOKEN_FREEZE_ACCOUNT(HederaFunctionality.TokenFreezeAccount),

    /**
     * Unfreeze Account
     */
    TOKEN_UNFREEZE_ACCOUNT(HederaFunctionality.TokenUnfreezeAccount),

    /**
     * Grant KYC to Account
     */
    TOKEN_GRANT_KYC_TO_ACCOUNT(HederaFunctionality.TokenGrantKycToAccount),

    /**
     * Revoke KYC from Account
     */
    TOKEN_REVOKE_KYC_FROM_ACCOUNT(HederaFunctionality.TokenRevokeKycFromAccount),

    /**
     * Delete Token
     */
    TOKEN_DELETE(HederaFunctionality.TokenDelete),

    /**
     * Update Token
     */
    TOKEN_UPDATE(HederaFunctionality.TokenUpdate),

    /**
     * Mint tokens to treasury
     */
    TOKEN_MINT(HederaFunctionality.TokenMint),

    /**
     * Burn tokens from treasury
     */
    TOKEN_BURN(HederaFunctionality.TokenBurn),

    /**
     * Wipe token amount from Account holder
     */
    TOKEN_ACCOUNT_WIPE(HederaFunctionality.TokenAccountWipe),

    /**
     * Associate tokens to an account
     */
    TOKEN_ASSOCIATE_TO_ACCOUNT(HederaFunctionality.TokenAssociateToAccount),

    /**
     * Dissociate tokens from an account
     */
    TOKEN_DISSOCIATE_FROM_ACCOUNT(HederaFunctionality.TokenDissociateFromAccount),

    /**
     * Create Scheduled Transaction
     */
    SCHEDULE_CREATE(HederaFunctionality.ScheduleCreate),

    /**
     * Delete Scheduled Transaction
     */
    SCHEDULE_DELETE(HederaFunctionality.ScheduleDelete),

    /**
     * Sign Scheduled Transaction
     */
    SCHEDULE_SIGN(HederaFunctionality.ScheduleSign),

    /**
     * Get Scheduled Transaction Information
     */
    SCHEDULE_GET_INFO(HederaFunctionality.ScheduleGetInfo),

    /**
     * Get Token Account Nft Information
     */
    TOKEN_GET_ACCOUNT_NFT_INFOS(HederaFunctionality.TokenGetAccountNftInfos),

    /**
     * Get Token Nft Information
     */
    TOKEN_GET_NFT_INFO(HederaFunctionality.TokenGetNftInfo),

    /**
     * Get Token Nft List Information
     */
    TOKEN_GET_NFT_INFOS(HederaFunctionality.TokenGetNftInfos),

    /**
     * Update a token's custom fee schedule, if permissible
     */
    TOKEN_FEE_SCHEDULE_UPDATE(HederaFunctionality.TokenFeeScheduleUpdate),

    /**
     * Get execution time(s) by TransactionID, if available
     */
    NETWORK_GET_EXECUTION_TIME(HederaFunctionality.NetworkGetExecutionTime),

    /**
     * Pause the Token
     */
    TOKEN_PAUSE(HederaFunctionality.TokenPause),

    /**
     * Unpause the Token
     */
    TOKEN_UNPAUSE(HederaFunctionality.TokenUnpause),

    /**
     * Approve allowance for a spender relative to the owner account
     */
    CRYPTO_APPROVE_ALLOWANCE(HederaFunctionality.CryptoApproveAllowance),

    /**
     * Deletes granted allowances on owner account
     */
    CRYPTO_DELETE_ALLOWANCE(HederaFunctionality.CryptoDeleteAllowance),

    /**
     * Gets all the information about an account, including balance and allowances. This does not get the list of
     * account records.
     */
    GET_ACCOUNT_DETAILS(HederaFunctionality.GetAccountDetails),

    /**
     * Ethereum Transaction
     */
    ETHEREUM_TRANSACTION(HederaFunctionality.EthereumTransaction),

    /**
     * Updates the staking info at the end of staking period to indicate new staking period has started.
     */
    NODE_STAKE_UPDATE(HederaFunctionality.NodeStakeUpdate),

    /**
     * Generates a pseudorandom number.
     */
    PRNG(HederaFunctionality.UtilPrng),

    /**
     * Get a record for a transaction.
     */
    TRANSACTION_GET_FAST_RECORD(HederaFunctionality.TransactionGetFastRecord),

    /**
     * Update the metadata of one or more NFT's of a specific token type.
     */
    TOKEN_UPDATE_NFTS(HederaFunctionality.TokenUpdateNfts),

    /**
     * Create a node
     */
    NODE_CREATE(HederaFunctionality.NodeCreate),

    /**
     * Update a node
     */
    NODE_UPDATE(HederaFunctionality.NodeUpdate),

    /**
     * Delete a node
     */
    NODE_DELETE(HederaFunctionality.NodeDelete),

    /**
     * Transfer one or more token balances held by the requesting account to the treasury for each token type.
     */
    TOKEN_REJECT(HederaFunctionality.TokenReject),

    /**
     * Airdrop one or more tokens to one or more accounts.
     */
    TOKEN_AIRDROP(HederaFunctionality.TokenAirdrop),

    /**
     * Remove one or more pending airdrops from state on behalf of the sender(s) for each airdrop.
     */
    TOKEN_CANCEL_AIRDROP(HederaFunctionality.TokenCancelAirdrop),

    /**
     * Claim one or more pending airdrops
     */
    TOKEN_CLAIM_AIRDROP(HederaFunctionality.TokenClaimAirdrop);

    final HederaFunctionality code;

    RequestType(HederaFunctionality code) {
        this.code = code;
    }

    static RequestType valueOf(HederaFunctionality code) {
        return switch (code) {
            case NONE -> NONE;
            case CryptoTransfer -> CRYPTO_TRANSFER;
            case CryptoUpdate -> CRYPTO_UPDATE;
            case CryptoDelete -> CRYPTO_DELETE;
            case CryptoAddLiveHash -> CRYPTO_ADD_LIVE_HASH;
            case CryptoDeleteLiveHash -> CRYPTO_DELETE_LIVE_HASH;
            case ContractCall -> CONTRACT_CALL;
            case ContractCreate -> CONTRACT_CREATE;
            case ContractUpdate -> CONTRACT_UPDATE;
            case FileCreate -> FILE_CREATE;
            case FileAppend -> FILE_APPEND;
            case FileUpdate -> FILE_UPDATE;
            case FileDelete -> FILE_DELETE;
            case CryptoGetAccountBalance -> CRYPTO_GET_ACCOUNT_BALANCE;
            case CryptoGetAccountRecords -> CRYPTO_GET_ACCOUNT_RECORDS;
            case CryptoGetInfo -> CRYPTO_GET_INFO;
            case ContractCallLocal -> CONTRACT_CALL_LOCAL;
            case ContractGetInfo -> CONTRACT_GET_INFO;
            case ContractGetBytecode -> CONTRACT_GET_BYTECODE;
            case GetBySolidityID -> GET_BY_SOLIDITY_ID;
            case GetByKey -> GET_BY_KEY;
            case CryptoGetLiveHash -> CRYPTO_GET_LIVE_HASH;
            case CryptoGetStakers -> CRYPTO_GET_STAKERS;
            case FileGetContents -> FILE_GET_CONTENTS;
            case FileGetInfo -> FILE_GET_INFO;
            case TransactionGetRecord -> TRANSACTION_GET_RECORD;
            case ContractGetRecords -> CONTRACT_GET_RECORDS;
            case CryptoCreate -> CRYPTO_CREATE;
            case SystemDelete -> SYSTEM_DELETE;
            case SystemUndelete -> SYSTEM_UNDELETE;
            case ContractDelete -> CONTRACT_DELETE;
            case Freeze -> FREEZE;
            case CreateTransactionRecord -> CREATE_TRANSACTION_RECORD;
            case CryptoAccountAutoRenew -> CRYPTO_ACCOUNT_AUTO_RENEW;
            case ContractAutoRenew -> CONTRACT_AUTO_RENEW;
            case GetVersionInfo -> GET_VERSION_INFO;
            case TransactionGetReceipt -> TRANSACTION_GET_RECEIPT;
            case ConsensusCreateTopic -> CONSENSUS_CREATE_TOPIC;
            case ConsensusUpdateTopic -> CONSENSUS_UPDATE_TOPIC;
            case ConsensusDeleteTopic -> CONSENSUS_DELETE_TOPIC;
            case ConsensusGetTopicInfo -> CONSENSUS_GET_TOPIC_INFO;
            case ConsensusSubmitMessage -> CONSENSUS_SUBMIT_MESSAGE;
            case UncheckedSubmit -> UNCHECKED_SUBMIT;
            case TokenCreate -> TOKEN_CREATE;
            case TokenGetInfo -> TOKEN_GET_INFO;
            case TokenFreezeAccount -> TOKEN_FREEZE_ACCOUNT;
            case TokenUnfreezeAccount -> TOKEN_UNFREEZE_ACCOUNT;
            case TokenGrantKycToAccount -> TOKEN_GRANT_KYC_TO_ACCOUNT;
            case TokenRevokeKycFromAccount -> TOKEN_REVOKE_KYC_FROM_ACCOUNT;
            case TokenDelete -> TOKEN_DELETE;
            case TokenUpdate -> TOKEN_UPDATE;
            case TokenMint -> TOKEN_MINT;
            case TokenBurn -> TOKEN_BURN;
            case TokenAccountWipe -> TOKEN_ACCOUNT_WIPE;
            case TokenAssociateToAccount -> TOKEN_ASSOCIATE_TO_ACCOUNT;
            case TokenDissociateFromAccount -> TOKEN_DISSOCIATE_FROM_ACCOUNT;
            case ScheduleCreate -> SCHEDULE_CREATE;
            case ScheduleDelete -> SCHEDULE_DELETE;
            case ScheduleSign -> SCHEDULE_SIGN;
            case ScheduleGetInfo -> SCHEDULE_GET_INFO;
            case TokenGetAccountNftInfos -> TOKEN_GET_ACCOUNT_NFT_INFOS;
            case TokenGetNftInfo -> TOKEN_GET_NFT_INFO;
            case TokenGetNftInfos -> TOKEN_GET_NFT_INFOS;
            case TokenFeeScheduleUpdate -> TOKEN_FEE_SCHEDULE_UPDATE;
            case NetworkGetExecutionTime -> NETWORK_GET_EXECUTION_TIME;
            case TokenPause -> TOKEN_PAUSE;
            case TokenUnpause -> TOKEN_UNPAUSE;
            case CryptoApproveAllowance -> CRYPTO_APPROVE_ALLOWANCE;
            case CryptoDeleteAllowance -> CRYPTO_DELETE_ALLOWANCE;
            case GetAccountDetails -> GET_ACCOUNT_DETAILS;
            case EthereumTransaction -> ETHEREUM_TRANSACTION;
            case NodeStakeUpdate -> NODE_STAKE_UPDATE;
            case UtilPrng -> PRNG;
            case TransactionGetFastRecord -> TRANSACTION_GET_FAST_RECORD;
            case TokenUpdateNfts -> TOKEN_UPDATE_NFTS;
            case NodeCreate -> NODE_CREATE;
            case NodeUpdate -> NODE_UPDATE;
            case NodeDelete -> NODE_DELETE;
            case TokenReject -> TOKEN_REJECT;
            case TokenAirdrop -> TOKEN_AIRDROP;
            case TokenCancelAirdrop -> TOKEN_CANCEL_AIRDROP;
            case TokenClaimAirdrop -> TOKEN_CLAIM_AIRDROP;
            default -> throw new IllegalStateException("(BUG) unhandled HederaFunctionality");
        };
    }

    @Override
    public String toString() {
        return switch (this) {
            case NONE -> "NONE";
            case CRYPTO_TRANSFER -> "CRYPTO_TRANSFER";
            case CRYPTO_UPDATE -> "CRYPTO_UPDATE";
            case CRYPTO_DELETE -> "CRYPTO_DELETE";
            case CRYPTO_ADD_LIVE_HASH -> "CRYPTO_ADD_LIVE_HASH";
            case CRYPTO_DELETE_LIVE_HASH -> "CRYPTO_DELETE_LIVE_HASH";
            case CONTRACT_CALL -> "CONTRACT_CALL";
            case CONTRACT_CREATE -> "CONTRACT_CREATE";
            case CONTRACT_UPDATE -> "CONTRACT_UPDATE";
            case FILE_CREATE -> "FILE_CREATE";
            case FILE_APPEND -> "FILE_APPEND";
            case FILE_UPDATE -> "FILE_UPDATE";
            case FILE_DELETE -> "FILE_DELETE";
            case CRYPTO_GET_ACCOUNT_BALANCE -> "CRYPTO_GET_ACCOUNT_BALANCE";
            case CRYPTO_GET_ACCOUNT_RECORDS -> "CRYPTO_GET_ACCOUNT_RECORDS";
            case CRYPTO_GET_INFO -> "CRYPTO_GET_INFO";
            case CONTRACT_CALL_LOCAL -> "CONTRACT_CALL_LOCAL";
            case CONTRACT_GET_INFO -> "CONTRACT_GET_INFO";
            case CONTRACT_GET_BYTECODE -> "CONTRACT_GET_BYTECODE";
            case GET_BY_SOLIDITY_ID -> "GET_BY_SOLIDITY_ID";
            case GET_BY_KEY -> "GET_BY_KEY";
            case CRYPTO_GET_LIVE_HASH -> "CRYPTO_GET_LIVE_HASH";
            case CRYPTO_GET_STAKERS -> "CRYPTO_GET_STAKERS";
            case FILE_GET_CONTENTS -> "FILE_GET_CONTENTS";
            case FILE_GET_INFO -> "FILE_GET_INFO";
            case TRANSACTION_GET_RECORD -> "TRANSACTION_GET_RECORD";
            case CONTRACT_GET_RECORDS -> "CONTRACT_GET_RECORDS";
            case CRYPTO_CREATE -> "CRYPTO_CREATE";
            case SYSTEM_DELETE -> "SYSTEM_DELETE";
            case SYSTEM_UNDELETE -> "SYSTEM_UNDELETE";
            case CONTRACT_DELETE -> "CONTRACT_DELETE";
            case FREEZE -> "FREEZE";
            case CREATE_TRANSACTION_RECORD -> "CREATE_TRANSACTION_RECORD";
            case CRYPTO_ACCOUNT_AUTO_RENEW -> "CRYPTO_ACCOUNT_AUTO_RENEW";
            case CONTRACT_AUTO_RENEW -> "CONTRACT_AUTO_RENEW";
            case GET_VERSION_INFO -> "GET_VERSION_INFO";
            case TRANSACTION_GET_RECEIPT -> "TRANSACTION_GET_RECEIPT";
            case CONSENSUS_CREATE_TOPIC -> "CONSENSUS_CREATE_TOPIC";
            case CONSENSUS_UPDATE_TOPIC -> "CONSENSUS_UPDATE_TOPIC";
            case CONSENSUS_DELETE_TOPIC -> "CONSENSUS_DELETE_TOPIC";
            case CONSENSUS_GET_TOPIC_INFO -> "CONSENSUS_GET_TOPIC_INFO";
            case CONSENSUS_SUBMIT_MESSAGE -> "CONSENSUS_SUBMIT_MESSAGE";
            case UNCHECKED_SUBMIT -> "UNCHECKED_SUBMIT";
            case TOKEN_CREATE -> "TOKEN_CREATE";
            case TOKEN_GET_INFO -> "TOKEN_GET_INFO";
            case TOKEN_FREEZE_ACCOUNT -> "TOKEN_FREEZE_ACCOUNT";
            case TOKEN_UNFREEZE_ACCOUNT -> "TOKEN_UNFREEZE_ACCOUNT";
            case TOKEN_GRANT_KYC_TO_ACCOUNT -> "TOKEN_GRANT_KYC_TO_ACCOUNT";
            case TOKEN_REVOKE_KYC_FROM_ACCOUNT -> "TOKEN_REVOKE_KYC_FROM_ACCOUNT";
            case TOKEN_DELETE -> "TOKEN_DELETE";
            case TOKEN_UPDATE -> "TOKEN_UPDATE";
            case TOKEN_MINT -> "TOKEN_MINT";
            case TOKEN_BURN -> "TOKEN_BURN";
            case TOKEN_ACCOUNT_WIPE -> "TOKEN_ACCOUNT_WIPE";
            case TOKEN_ASSOCIATE_TO_ACCOUNT -> "TOKEN_ASSOCIATE_TO_ACCOUNT";
            case TOKEN_DISSOCIATE_FROM_ACCOUNT -> "TOKEN_DISSOCIATE_FROM_ACCOUNT";
            case SCHEDULE_CREATE -> "SCHEDULE_CREATE";
            case SCHEDULE_DELETE -> "SCHEDULE_DELETE";
            case SCHEDULE_SIGN -> "SCHEDULE_SIGN";
            case SCHEDULE_GET_INFO -> "SCHEDULE_GET_INFO";
            case TOKEN_GET_ACCOUNT_NFT_INFOS -> "TOKEN_GET_ACCOUNT_NFT_INFOS";
            case TOKEN_GET_NFT_INFO -> "TOKEN_GET_NFT_INFO";
            case TOKEN_GET_NFT_INFOS -> "TOKEN_GET_NFT_INFOS";
            case TOKEN_FEE_SCHEDULE_UPDATE -> "TOKEN_FEE_SCHEDULE_UPDATE";
            case NETWORK_GET_EXECUTION_TIME -> "NETWORK_GET_EXECUTION_TIME";
            case TOKEN_PAUSE -> "TOKEN_PAUSE";
            case TOKEN_UNPAUSE -> "TOKEN_UNPAUSE";
            case CRYPTO_APPROVE_ALLOWANCE -> "CRYPTO_APPROVE_ALLOWANCE";
            case CRYPTO_DELETE_ALLOWANCE -> "CRYPTO_DELETE_ALLOWANCE";
            case GET_ACCOUNT_DETAILS -> "GET_ACCOUNT_DETAILS";
            case ETHEREUM_TRANSACTION -> "ETHEREUM_TRANSACTION";
            case NODE_STAKE_UPDATE -> "NODE_STAKE_UPDATE";
            case PRNG -> "PRNG";
            case TRANSACTION_GET_FAST_RECORD -> "TRANSACTION_GET_FAST_RECORD";
            case TOKEN_UPDATE_NFTS -> "TOKEN_UPDATE_NFTS";
            case NODE_CREATE -> "NODE_CREATE";
            case NODE_UPDATE -> "NODE_UPDATE";
            case NODE_DELETE -> "NODE_DELETE";
            case TOKEN_REJECT -> "TOKEN_REJECT";
            case TOKEN_AIRDROP -> "TOKEN_AIRDROP";
            case TOKEN_CANCEL_AIRDROP -> "TOKEN_CANCEL_AIRDROP";
            case TOKEN_CLAIM_AIRDROP -> "TOKEN_CLAIM_AIRDROP";
        };
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ScheduleCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Create a scheduled transaction.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/sdks/schedule-transaction/create-a-schedule-transaction">Hedera Documentation</a>
 */
public final class ScheduleCreateTransaction extends Transaction<ScheduleCreateTransaction> {
    @Nullable
    private AccountId payerAccountId = null;
    @Nullable
    private SchedulableTransactionBody transactionToSchedule = null;
    @Nullable
    private Key adminKey = null;
    private String scheduleMemo = "";

    @Nullable
    private Instant expirationTime = null;

    private boolean waitForExpiry = false;

    /**
     * Constructor.
     */
    public ScheduleCreateTransaction() {
        defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ScheduleCreateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Get the expiration time
     *
     * @return The expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
     * Defaults to 30 minutes after the transaction's consensus timestamp.
     * <p>
     * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
     *       expire in 30 minutes if Long Term Scheduled Transactions are not enabled.
     *
     * @param expirationTime The expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public ScheduleCreateTransaction setExpirationTime(Instant expirationTime) {
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * get the status of the waitForExpiry boolean
     *
     * @return waitForExpiry boolean
     */
    public boolean isWaitForExpiry() {
        return waitForExpiry;
    }

    /**
     * When set to true, the transaction will be evaluated for execution at expiration_time instead
     * of when all required signatures are received.
     * When set to false, the transaction will execute immediately after sufficient signatures are received
     * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
     * Defaults to false.
     * <p>
     * Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
     *  <p>
     *  For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
     *  such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
     *  ScheduleSign comes in to poke it and force it to go through immediately.
     * <p>
     * Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
     *       Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
     *       execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
     *       expire at expiration_time.
     *
     * @param waitForExpiry Whether to wait for expiry
     * @return {@code this}
     */
    public ScheduleCreateTransaction setWaitForExpiry(boolean waitForExpiry) {
        this.waitForExpiry = waitForExpiry;
        return this;
    }

    /**
     * Get the payer's account ID.
     *
     * @return The payer's account ID
     */
    @Nullable
    public AccountId getPayerAccountId() {
        return payerAccountId;
    }

    /**
     * Assign the payer's account ID.
     *
     * @param accountId                 the payer's account ID
     * @return {@code this}
     */
    public ScheduleCreateTransaction setPayerAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.payerAccountId = accountId;
        return this;
    }

    /**
     * Assign the transaction to schedule.
     *
     * @param transaction               the transaction to schedule
     * @return {@code this}
     */
    public ScheduleCreateTransaction setScheduledTransaction(Transaction<?> transaction) {
        requireNotFrozen();
        Objects.requireNonNull(transaction);

        var scheduled = transaction.schedule();
        transactionToSchedule = scheduled.transactionToSchedule;

        return this;
    }

    /**
     * Assign the transaction body to schedule.
     *
     * @param tx                        the transaction body to schedule
     * @return {@code this}
     */
    ScheduleCreateTransaction setScheduledTransactionBody(SchedulableTransactionBody tx) {
        requireNotFrozen();
        Objects.requireNonNull(tx);
        transactionToSchedule = tx;
        return this;
    }

    /**
     * Extract the admin key.
     *
     * @return                          the admin key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Assign the admin key.
     *
     * @param key                       the admin key
     * @return {@code this}
     */
    public ScheduleCreateTransaction setAdminKey(Key key) {
        requireNotFrozen();
        adminKey = key;
        return this;
    }

    /**
     * Extract the schedule's memo.
     *
     * @return                          the schedule's memo
     */
    public String getScheduleMemo() {
        return scheduleMemo;
    }

    /**
     * Assign the schedule's memo.
     *
     * @param memo                      the schedule's memo
     * @return {@code this}
     */
    public ScheduleCreateTransaction setScheduleMemo(String memo) {
        requireNotFrozen();
        scheduleMemo = memo;
        return this;
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.ScheduleCreateTransactionBody builder }
     */
    ScheduleCreateTransactionBody.Builder build() {
        var builder = ScheduleCreateTransactionBody.newBuilder();
        if (payerAccountId != null) {
            builder.setPayerAccountID(payerAccountId.toProtobuf());
        }
        if (transactionToSchedule != null) {
            builder.setScheduledTransactionBody(transactionToSchedule);
        }
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }
        builder.setMemo(scheduleMemo).setWaitForExpiry(waitForExpiry);
        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getScheduleCreate();
        if (body.hasPayerAccountID()) {
            payerAccountId = AccountId.fromProtobuf(body.getPayerAccountID());
        }
        if (body.hasScheduledTransactionBody()) {
            transactionToSchedule = body.getScheduledTransactionBody();
        }
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
        scheduleMemo = body.getMemo();
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (payerAccountId != null) {
            payerAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ScheduleServiceGrpc.getCreateScheduleMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setScheduleCreate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("Cannot schedule ScheduleCreateTransaction");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ScheduleDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Delete a scheduled transaction.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/sdks/schedule-transaction/delete-a-schedule-transaction">Hedera Documentation</a>
 */
public final class ScheduleDeleteTransaction extends Transaction<ScheduleDeleteTransaction> {

    @Nullable
    private ScheduleId scheduleId = null;

    /**
     * Constructor.
     */
    public ScheduleDeleteTransaction() {
        defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ScheduleDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    ScheduleDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the schedule id.
     *
     * @return                          the schedule id
     */
    @Nullable
    public ScheduleId getScheduleId() {
        return scheduleId;
    }

    /**
     * Assign the scheduled id.
     *
     * @param scheduleId                the schedule id
     * @return {@code this}
     */
    public ScheduleDeleteTransaction setScheduleId(ScheduleId scheduleId) {
        Objects.requireNonNull(scheduleId);
        requireNotFrozen();
        this.scheduleId = scheduleId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getScheduleDelete();
        if (body.hasScheduleID()) {
            scheduleId = ScheduleId.fromProtobuf(body.getScheduleID());
        }
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.ScheduleDeleteTransactionBody builder }
     */
    ScheduleDeleteTransactionBody.Builder build() {
        var builder = ScheduleDeleteTransactionBody.newBuilder();
        if (scheduleId != null) {
            builder.setScheduleID(scheduleId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (scheduleId != null) {
            scheduleId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ScheduleServiceGrpc.getDeleteScheduleMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setScheduleDelete(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setScheduleDelete(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ScheduleId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ScheduleID;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.Objects;

/**
 * The entity ID of a schedule transaction.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/schedule-transaction/schedule-id">Hedera Documentation</a>
 */
public final class ScheduleId implements Comparable<ScheduleId> {
    /**
     * The shard number
     */
    @Nonnegative
    public final long shard;

    /**
     * The realm number
     */
    @Nonnegative
    public final long realm;

    /**
     * The id number
     */
    @Nonnegative
    public final long num;

    @Nullable
    private final String checksum;

    /**
     * Constructor.
     *
     * @param num                       the num part
     */
    public ScheduleId(@Nonnegative long num) {
        this(0, 0, num);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @param num                       the num part
     */
    @SuppressWarnings("InconsistentOverloads")
    public ScheduleId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num) {
        this(shard, realm, num, null);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @param num                       the num part
     * @param checksum                  the checksum
     */
    @SuppressWarnings("InconsistentOverloads")
    ScheduleId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num, @Nullable String checksum) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
    }

    /**
     * Create a schedule id from a string.
     *
     * @param id                        the string representing the schedule id
     * @return                          the new schedule id
     */
    public static ScheduleId fromString(String id) {
        return EntityIdHelper.fromString(id, ScheduleId::new);
    }

    /**
     * Create a schedule id from a protobuf.
     *
     * @param scheduleId                the protobuf
     * @return                          the new schedule id
     */
    static ScheduleId fromProtobuf(ScheduleID scheduleId) {
        Objects.requireNonNull(scheduleId);
        return new ScheduleId(scheduleId.getShardNum(), scheduleId.getRealmNum(), scheduleId.getScheduleNum());
    }

    /**
     * Create a schedule id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new schedule id
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static ScheduleId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(ScheduleID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representing the schedule id
     */
    ScheduleID toProtobuf() {
        return ScheduleID.newBuilder()
            .setShardNum(shard)
            .setRealmNum(realm)
            .setScheduleNum(num)
            .build();
    }

    /**
     * @param client to validate against
     * @throws BadEntityIdException if entity ID is formatted poorly
     * @deprecated Use {@link #validateChecksum(Client)} instead.
     */
    @Deprecated
    public void validate(Client client) throws BadEntityIdException {
        validateChecksum(client);
    }

    /**
     * Validate the configured client.
     *
     * @param client                    the configured client
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    public void validateChecksum(Client client) throws BadEntityIdException {
        EntityIdHelper.validate(shard, realm, num, client, checksum);
    }

    /**
     * Extract the checksum.
     *
     * @return                          the checksum
     */
    @Nullable
    public String getChecksum() {
        return checksum;
    }

    /**
     * Create the byte array.
     *
     * @return                          byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return EntityIdHelper.toString(shard, realm, num);
    }

    /**
     * Convert the schedule id into a string with checksum.
     *
     * @param client                    the configured client
     * @return                          the string representation
     */
    public String toStringWithChecksum(Client client) {
        return EntityIdHelper.toStringWithChecksum(shard, realm, num, client, checksum);
    }

    @Override
    public int hashCode() {
        return Objects.hash(shard, realm, num);
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof ScheduleId)) {
            return false;
        }

        ScheduleId otherId = (ScheduleId) o;
        return shard == otherId.shard && realm == otherId.realm && num == otherId.num;
    }

    @Override
    public int compareTo(ScheduleId o) {
        Objects.requireNonNull(o);
        int shardComparison = Long.compare(shard, o.shard);
        if (shardComparison != 0) {
            return shardComparison;
        }
        int realmComparison = Long.compare(realm, o.realm);
        if (realmComparison != 0) {
            return realmComparison;
        }
        return Long.compare(num, o.num);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ScheduleInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleGetInfoResponse;
import java.time.Instant;

import javax.annotation.Nullable;

/**
 * A query that returns information about the current state of a scheduled
 * transaction on a Hedera network.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/sdks/schedule-transaction/get-schedule-info">Hedera Documentation</a>
 */
public final class ScheduleInfo {
    /**
     * The ID of the schedule transaction
     */
    public final ScheduleId scheduleId;
    /**
     * The Hedera account that created the schedule transaction in x.y.z format
     */
    public final AccountId creatorAccountId;
    /**
     * The Hedera account paying for the execution of the schedule transaction
     * in x.y.z format
     */
    public final AccountId payerAccountId;
    /**
     * The signatories that have provided signatures so far for the schedule
     * transaction
     */
    public final KeyList signatories;

    /**
     * The Key which is able to delete the schedule transaction if set
     */
    @Nullable
    public final Key adminKey;

    /**
     * The scheduled transaction
     */
    @Nullable
    public final TransactionId scheduledTransactionId;

    /**
     * Publicly visible information about the Schedule entity, up to
     * 100 bytes. No guarantee of uniqueness.
     */
    public final String memo;

    /**
     * The date and time the schedule transaction will expire
     */
    @Nullable
    public final Instant expirationTime;

    /**
     * The time the schedule transaction was executed. If the schedule
     * transaction has not executed this field will be left null.
     */
    @Nullable
    public final Instant executedAt;

    /**
     * The consensus time the schedule transaction was deleted. If the
     * schedule transaction was not deleted, this field will be left null.
     */
    @Nullable
    public final Instant deletedAt;

    /**
     * The scheduled transaction (inner transaction).
     */
    final SchedulableTransactionBody transactionBody;

    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    @Nullable
    public final LedgerId ledgerId;

    /**
     * When set to true, the transaction will be evaluated for execution at expiration_time instead
     * of when all required signatures are received.
     * When set to false, the transaction will execute immediately after sufficient signatures are received
     * to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
     *
     * Note: this field is unused until Long Term Scheduled Transactions are enabled.
     */
    public final boolean waitForExpiry;

    /**
     * Constructor.
     *
     * @param scheduleId                the schedule id
     * @param creatorAccountId          the creator account id
     * @param payerAccountId            the payer account id
     * @param transactionBody           the transaction body
     * @param signers                   the signers key list
     * @param adminKey                  the admin key
     * @param scheduledTransactionId    the transaction id
     * @param memo                      the memo 100 bytes max
     * @param expirationTime            the expiration time
     * @param executed                  the time transaction was executed
     * @param deleted                   the time it was deleted
     * @param ledgerId                  the ledger id
     * @param waitForExpiry             the wait for expiry field
     */
    ScheduleInfo(
        ScheduleId scheduleId,
        AccountId creatorAccountId,
        AccountId payerAccountId,
        SchedulableTransactionBody transactionBody,
        KeyList signers,
        @Nullable Key adminKey,
        @Nullable TransactionId scheduledTransactionId,
        String memo,
        @Nullable Instant expirationTime,
        @Nullable Instant executed,
        @Nullable Instant deleted,
        LedgerId ledgerId,
        boolean waitForExpiry
    ) {
        this.scheduleId = scheduleId;
        this.creatorAccountId = creatorAccountId;
        this.payerAccountId = payerAccountId;
        this.signatories = signers;
        this.adminKey = adminKey;
        this.transactionBody = transactionBody;
        this.scheduledTransactionId = scheduledTransactionId;
        this.memo = memo;
        this.expirationTime = expirationTime;
        this.executedAt = executed;
        this.deletedAt = deleted;
        this.ledgerId = ledgerId;
        this.waitForExpiry = waitForExpiry;
    }

    /**
     * Create a schedule info object from a protobuf.
     *
     * @param info              the protobuf
     * @return                          the new schedule info object
     */
    static ScheduleInfo fromProtobuf(com.hedera.hashgraph.sdk.proto.ScheduleInfo info) {
        var scheduleId = ScheduleId.fromProtobuf(info.getScheduleID());
        var creatorAccountId = AccountId.fromProtobuf(info.getCreatorAccountID());
        var payerAccountId = AccountId.fromProtobuf(info.getPayerAccountID());
        var adminKey = info.hasAdminKey() ? Key.fromProtobufKey(info.getAdminKey()) : null;
        var scheduledTransactionId = info.hasScheduledTransactionID() ?
            TransactionId.fromProtobuf(info.getScheduledTransactionID()) :
            null;

        return new ScheduleInfo(
            scheduleId,
            creatorAccountId,
            payerAccountId,
            info.getScheduledTransactionBody(),
            KeyList.fromProtobuf(info.getSigners(), null),
            adminKey,
            scheduledTransactionId,
            info.getMemo(),
            info.hasExpirationTime() ? InstantConverter.fromProtobuf(info.getExpirationTime()) : null,
            info.hasExecutionTime() ? InstantConverter.fromProtobuf(info.getExecutionTime()) : null,
            info.hasDeletionTime() ? InstantConverter.fromProtobuf(info.getDeletionTime()) : null,
            LedgerId.fromByteString(info.getLedgerId()),
            info.getWaitForExpiry()
        );
    }

    /**
     * Create a schedule info object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new schedule info object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static ScheduleInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.ScheduleInfo.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.ScheduleInfo toProtobuf() {
        var info = com.hedera.hashgraph.sdk.proto.ScheduleInfo.newBuilder();

        if (adminKey != null) {
            info.setAdminKey(adminKey.toProtobufKey());
        }

        if (scheduledTransactionId != null) {
            info.setScheduledTransactionID(scheduledTransactionId.toProtobuf());
        }

        if (expirationTime != null) {
            info.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }

        if (executedAt != null) {
            info.setExecutionTime(InstantConverter.toProtobuf(executedAt));
        }

        if (deletedAt != null) {
            info.setDeletionTime(InstantConverter.toProtobuf(deletedAt));
        }

        return info
            .setScheduleID(scheduleId.toProtobuf())
            .setCreatorAccountID(creatorAccountId.toProtobuf())
            .setScheduledTransactionBody(transactionBody)
            .setPayerAccountID(payerAccountId.toProtobuf())
            .setSigners(signatories.toProtobuf())
            .setMemo(memo)
            .setLedgerId(ledgerId.toByteString())
            .setWaitForExpiry(waitForExpiry)
            .build();
    }

    /**
     * Extract the transaction.
     *
     * @return                          the transaction
     */
    public Transaction<?> getScheduledTransaction() {
        return Transaction.fromScheduledTransaction(transactionBody);
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("scheduleId", scheduleId)
            .add("scheduledTransactionId", scheduledTransactionId)
            .add("creatorAccountId", creatorAccountId)
            .add("payerAccountId", payerAccountId)
            .add("signatories", signatories)
            .add("adminKey", adminKey)
            .add("expirationTime", expirationTime)
            .add("memo", memo)
            .add("executedAt", executedAt)
            .add("deletedAt", deletedAt)
            .add("ledgerId", ledgerId)
            .add("waitForExpiry", waitForExpiry)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ScheduleInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Query;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.ScheduleGetInfoQuery;
import com.hedera.hashgraph.sdk.proto.ScheduleServiceGrpc;
import io.grpc.MethodDescriptor;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * A query that returns information about the current state of a schedule
 * transaction on a Hedera network.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/schedule-transaction/get-schedule-info">Hedera Documentation</a>
 */
public class ScheduleInfoQuery extends com.hedera.hashgraph.sdk.Query<ScheduleInfo, ScheduleInfoQuery> {
    @Nullable
    private ScheduleId scheduleId = null;

    /**
     * Constructor.
     */
    public ScheduleInfoQuery() {
    }

    /**
     * Extract the schedule id.
     *
     * @return                          the schedule id
     */
    @Nullable
    public ScheduleId getScheduleId() {
        return scheduleId;
    }

    /**
     * Assign the schedule id.
     *
     * @param scheduleId                the schedule id
     * @return {@code this}
     */
    public ScheduleInfoQuery setScheduleId(ScheduleId scheduleId) {
        Objects.requireNonNull(scheduleId);
        this.scheduleId = scheduleId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (scheduleId != null) {
            scheduleId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = ScheduleGetInfoQuery.newBuilder();
        if (scheduleId != null) {
            builder.setScheduleID(scheduleId.toProtobuf());
        }

        queryBuilder.setScheduleGetInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getScheduleGetInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getScheduleGetInfo().getHeader();
    }

    @Override
    ScheduleInfo mapResponse(Response response, AccountId nodeId, Query request) {
        return ScheduleInfo.fromProtobuf(response.getScheduleGetInfo().getScheduleInfo());
    }

    @Override
    MethodDescriptor<Query, Response> getMethodDescriptor() {
        return ScheduleServiceGrpc.getGetScheduleInfoMethod();
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `Token_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ScheduleSignTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleServiceGrpc;
import com.hedera.hashgraph.sdk.proto.ScheduleSignTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * A transaction that appends signatures to a schedule transaction.
 * You will need to know the schedule ID to reference the schedule
 * transaction to submit signatures to. A record will be generated
 * for each ScheduleSign transaction that is successful and the schedule
 * entity will subsequently update with the public keys that have signed
 * the schedule transaction. To view the keys that have signed the
 * schedule transaction, you can query the network for the schedule info.
 * Once a schedule transaction receives the last required signature, the
 * schedule transaction executes.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/schedule-transaction/sign-a-schedule-transaction">Hedera Documentation</a>
 */
public final class ScheduleSignTransaction extends Transaction<ScheduleSignTransaction> {

    @Nullable
    private ScheduleId scheduleId = null;

    /**
     * Constructor.
     */
    public ScheduleSignTransaction() {
        defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    ScheduleSignTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Extract the schedule id.
     *
     * @return                          the schedule id
     */
    @Nullable
    public ScheduleId getScheduleId() {
        return scheduleId;
    }

    /**
     * Assign the schedule id.
     *
     * @param scheduleId                the schedule id
     * @return {@code this}
     */
    public ScheduleSignTransaction setScheduleId(ScheduleId scheduleId) {
        Objects.requireNonNull(scheduleId);
        requireNotFrozen();
        this.scheduleId = scheduleId;
        return this;
    }

    /**
     * Clears the schedule id
     *
     * @return {@code this}
     */
    @Deprecated
    public ScheduleSignTransaction clearScheduleId() {
        requireNotFrozen();
        this.scheduleId = null;
        return this;
    }

    /**
     * Build the correct transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.ScheduleSignTransactionBody
     *         builder }
     */
    ScheduleSignTransactionBody.Builder build() {
        var builder = ScheduleSignTransactionBody.newBuilder();
        if (scheduleId != null) {
            builder.setScheduleID(scheduleId.toProtobuf());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getScheduleSign();
        if (body.hasScheduleID()) {
            scheduleId = ScheduleId.fromProtobuf(body.getScheduleID());
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (scheduleId != null) {
            scheduleId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ScheduleServiceGrpc.getSignScheduleMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setScheduleSign(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("cannot schedule ScheduleSignTransaction");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/SemanticVersion.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;

/**
 * Hedera follows semantic versioning () for both the HAPI protobufs and
 * the Services software. This type allows the getVersionInfo query in the
 * NetworkService to return the deployed versions of both protobufs and
 * software on the node answering the query.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/semanticversion">Hedera Documentation</a>
 */
public class SemanticVersion {
    /**
     * Increases with incompatible API changes
     */
    public int major;
    /**
     * Increases with backwards-compatible new functionality
     */
    public int minor;
    /**
     * Increases with backwards-compatible bug fixes
     */
    public int patch;

    /**
     * Constructor.
     *
     * @param major                     the major part
     * @param minor                     the minor part
     * @param patch                     the patch part
     */
    SemanticVersion(int major, int minor, int patch) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
    }

    /**
     * Create a semantic version object from a protobuf.
     *
     * @param version                   the protobuf
     * @return                          the new semantic version
     */
    protected static SemanticVersion fromProtobuf(com.hedera.hashgraph.sdk.proto.SemanticVersion version) {
        return new SemanticVersion(
            version.getMajor(),
            version.getMinor(),
            version.getPatch()
        );
    }

    /**
     * Create a semantic version from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new semantic version
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static SemanticVersion fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.SemanticVersion.parseFrom(bytes));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    protected com.hedera.hashgraph.sdk.proto.SemanticVersion toProtobuf() {
        return com.hedera.hashgraph.sdk.proto.SemanticVersion.newBuilder()
            .setMajor(major)
            .setMinor(minor)
            .setPatch(patch)
            .build();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return String.format("%d.%d.%d", major, minor, patch);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/StakingInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import java.time.Instant;

import javax.annotation.Nullable;

/**
 * Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
 */
public class StakingInfo {
    /**
     * If true, the contract declines receiving a staking reward. The default value is false.
     */
    public final boolean declineStakingReward;
    /**
     * The staking period during which either the staking settings for this account or contract changed (such as starting
     * staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
     * is not currently staked to a node, then this field is not set.
     */
    public final Instant stakePeriodStart;
    /**
     * The amount in Hbar that will be received in the next reward situation.
     */
    public final Hbar pendingReward;
    /**
     * The total of balance of all accounts staked to this account or contract.
     */
    public final Hbar stakedToMe;

    /**
     * The account to which this account or contract is staking.
     */
    @Nullable
    public final AccountId stakedAccountId;

    /**
     * The ID of the node this account or contract is staked to.
     */
    @Nullable
    public final Long stakedNodeId;

    /**
     * Constructor
     *
     * @param declineStakingReward  the declineStakingReward
     * @param stakePeriodStart      the stakePeriodStart
     * @param pendingReward         the amount in Hbar that will be received in the next reward situation
     * @param stakedToMe            the total of balance of all accounts staked to this account or contract
     * @param stakedAccountId       the account to which this account or contract is staking
     * @param stakedNodeId          the ID of the node this account or contract is staked to
     */
    public StakingInfo(boolean declineStakingReward, Instant stakePeriodStart, Hbar pendingReward, Hbar stakedToMe, @Nullable AccountId stakedAccountId, @Nullable Long stakedNodeId) {
        this.declineStakingReward = declineStakingReward;
        this.stakePeriodStart = stakePeriodStart;
        this.pendingReward = pendingReward;
        this.stakedToMe = stakedToMe;
        this.stakedAccountId = stakedAccountId;
        this.stakedNodeId = stakedNodeId;
    }

    static StakingInfo fromProtobuf(com.hedera.hashgraph.sdk.proto.StakingInfo info) {
        return new StakingInfo(
            info.getDeclineReward(),
            InstantConverter.fromProtobuf(info.getStakePeriodStart()),
            Hbar.fromTinybars(info.getPendingReward()),
            Hbar.fromTinybars(info.getStakedToMe()),
            info.hasStakedAccountId() ? AccountId.fromProtobuf(info.getStakedAccountId()) : null,
            info.hasStakedNodeId() ? info.getStakedNodeId() : null
        );
    }

    /**
     * Convert a byte array to a staking info object.
     *
     * @param bytes                     the byte array
     * @return                          the converted staking info object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static StakingInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.StakingInfo.parseFrom(bytes));
    }

    com.hedera.hashgraph.sdk.proto.StakingInfo toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.StakingInfo.newBuilder()
            .setDeclineReward(declineStakingReward)
            .setStakePeriodStart(InstantConverter.toProtobuf(stakePeriodStart))
            .setPendingReward(pendingReward.toTinybars())
            .setStakedToMe(stakedToMe.toTinybars());

        if (stakedAccountId != null) {
            builder.setStakedAccountId(stakedAccountId.toProtobuf());
        }

        if (stakedNodeId != null) {
            builder.setStakedNodeId(stakedNodeId);
        }

        return builder.build();
    }

    /**
     * Convert the staking info object to a byte array.
     *
     * @return                          the converted staking info object
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("declineStakingReward", declineStakingReward)
            .add("stakePeriodStart", stakePeriodStart)
            .add("pendingReward", pendingReward)
            .add("stakedToMe", stakedToMe)
            .add("stakedAccountId", stakedAccountId)
            .add("stakedNodeId", stakedNodeId)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Status.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;

import java.util.Objects;

/**
 * Returned in {@link TransactionReceipt}, {@link PrecheckStatusException}
 * and {@link ReceiptStatusException}.
 * <p>
 * The success variant is {@link #SUCCESS} which is what a {@link TransactionReceipt} will contain for a
 * successful transaction.
 */
public enum Status {
    /**
     * The transaction passed the precheck validations.
     */
    OK(ResponseCodeEnum.OK),

    /**
     * For any error not handled by specific error codes listed below.
     */
    INVALID_TRANSACTION(ResponseCodeEnum.INVALID_TRANSACTION),

    /**
     * Payer account does not exist.
     */
    PAYER_ACCOUNT_NOT_FOUND(ResponseCodeEnum.PAYER_ACCOUNT_NOT_FOUND),

    /**
     * Node Account provided does not match the node account of the node the transaction was submitted
     * to.
     */
    INVALID_NODE_ACCOUNT(ResponseCodeEnum.INVALID_NODE_ACCOUNT),

    /**
     * Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
     * consensus time.
     */
    TRANSACTION_EXPIRED(ResponseCodeEnum.TRANSACTION_EXPIRED),

    /**
     * Transaction start time is greater than current consensus time
     */
    INVALID_TRANSACTION_START(ResponseCodeEnum.INVALID_TRANSACTION_START),

    /**
     * The given transactionValidDuration was either non-positive, or greater than the maximum
     * valid duration of 180 secs.
     */
    INVALID_TRANSACTION_DURATION(ResponseCodeEnum.INVALID_TRANSACTION_DURATION),

    /**
     * The transaction signature is not valid
     */
    INVALID_SIGNATURE(ResponseCodeEnum.INVALID_SIGNATURE),

    /**
     * Transaction memo size exceeded 100 bytes
     */
    MEMO_TOO_LONG(ResponseCodeEnum.MEMO_TOO_LONG),

    /**
     * The fee provided in the transaction is insufficient for this type of transaction
     */
    INSUFFICIENT_TX_FEE(ResponseCodeEnum.INSUFFICIENT_TX_FEE),

    /**
     * The payer account has insufficient cryptocurrency to pay the transaction fee
     */
    INSUFFICIENT_PAYER_BALANCE(ResponseCodeEnum.INSUFFICIENT_PAYER_BALANCE),

    /**
     * This transaction ID is a duplicate of one that was submitted to this node or reached consensus
     * in the last 180 seconds (receipt period)
     */
    DUPLICATE_TRANSACTION(ResponseCodeEnum.DUPLICATE_TRANSACTION),

    /**
     * If API is throttled out
     */
    BUSY(ResponseCodeEnum.BUSY),

    /**
     * The API is not currently supported
     */
    NOT_SUPPORTED(ResponseCodeEnum.NOT_SUPPORTED),

    /**
     * The file id is invalid or does not exist
     */
    INVALID_FILE_ID(ResponseCodeEnum.INVALID_FILE_ID),

    /**
     * The account id is invalid or does not exist
     */
    INVALID_ACCOUNT_ID(ResponseCodeEnum.INVALID_ACCOUNT_ID),

    /**
     * The contract id is invalid or does not exist
     */
    INVALID_CONTRACT_ID(ResponseCodeEnum.INVALID_CONTRACT_ID),

    /**
     * Transaction id is not valid
     */
    INVALID_TRANSACTION_ID(ResponseCodeEnum.INVALID_TRANSACTION_ID),

    /**
     * Receipt for given transaction id does not exist
     */
    RECEIPT_NOT_FOUND(ResponseCodeEnum.RECEIPT_NOT_FOUND),

    /**
     * Record for given transaction id does not exist
     */
    RECORD_NOT_FOUND(ResponseCodeEnum.RECORD_NOT_FOUND),

    /**
     * The solidity id is invalid or entity with this solidity id does not exist
     */
    INVALID_SOLIDITY_ID(ResponseCodeEnum.INVALID_SOLIDITY_ID),

    /**
     * The responding node has submitted the transaction to the network. Its final status is still
     * unknown.
     */
    UNKNOWN(ResponseCodeEnum.UNKNOWN),

    /**
     * The transaction succeeded
     */
    SUCCESS(ResponseCodeEnum.SUCCESS),

    /**
     * There was a system error and the transaction failed because of invalid request parameters.
     */
    FAIL_INVALID(ResponseCodeEnum.FAIL_INVALID),

    /**
     * There was a system error while performing fee calculation, reserved for future.
     */
    FAIL_FEE(ResponseCodeEnum.FAIL_FEE),

    /**
     * There was a system error while performing balance checks, reserved for future.
     */
    FAIL_BALANCE(ResponseCodeEnum.FAIL_BALANCE),

    /**
     * Key not provided in the transaction body
     */
    KEY_REQUIRED(ResponseCodeEnum.KEY_REQUIRED),

    /**
     * Unsupported algorithm/encoding used for keys in the transaction
     */
    BAD_ENCODING(ResponseCodeEnum.BAD_ENCODING),

    /**
     * When the account balance is not sufficient for the transfer
     */
    INSUFFICIENT_ACCOUNT_BALANCE(ResponseCodeEnum.INSUFFICIENT_ACCOUNT_BALANCE),

    /**
     * During an update transaction when the system is not able to find the Users Solidity address
     */
    INVALID_SOLIDITY_ADDRESS(ResponseCodeEnum.INVALID_SOLIDITY_ADDRESS),

    /**
     * Not enough gas was supplied to execute transaction
     */
    INSUFFICIENT_GAS(ResponseCodeEnum.INSUFFICIENT_GAS),

    /**
     * contract byte code size is over the limit
     */
    CONTRACT_SIZE_LIMIT_EXCEEDED(ResponseCodeEnum.CONTRACT_SIZE_LIMIT_EXCEEDED),

    /**
     * local execution (query) is requested for a function which changes state
     */
    LOCAL_CALL_MODIFICATION_EXCEPTION(ResponseCodeEnum.LOCAL_CALL_MODIFICATION_EXCEPTION),

    /**
     * Contract REVERT OPCODE executed
     */
    CONTRACT_REVERT_EXECUTED(ResponseCodeEnum.CONTRACT_REVERT_EXECUTED),

    /**
     * For any contract execution related error not handled by specific error codes listed above.
     */
    CONTRACT_EXECUTION_EXCEPTION(ResponseCodeEnum.CONTRACT_EXECUTION_EXCEPTION),

    /**
     * In Query validation, account with +ve(amount) value should be Receiving node account, the
     * receiver account should be only one account in the list
     */
    INVALID_RECEIVING_NODE_ACCOUNT(ResponseCodeEnum.INVALID_RECEIVING_NODE_ACCOUNT),

    /**
     * Header is missing in Query request
     */
    MISSING_QUERY_HEADER(ResponseCodeEnum.MISSING_QUERY_HEADER),

    /**
     * The update of the account failed
     */
    ACCOUNT_UPDATE_FAILED(ResponseCodeEnum.ACCOUNT_UPDATE_FAILED),

    /**
     * Provided key encoding was not supported by the system
     */
    INVALID_KEY_ENCODING(ResponseCodeEnum.INVALID_KEY_ENCODING),

    /**
     * null solidity address
     */
    NULL_SOLIDITY_ADDRESS(ResponseCodeEnum.NULL_SOLIDITY_ADDRESS),

    /**
     * update of the contract failed
     */
    CONTRACT_UPDATE_FAILED(ResponseCodeEnum.CONTRACT_UPDATE_FAILED),

    /**
     * the query header is invalid
     */
    INVALID_QUERY_HEADER(ResponseCodeEnum.INVALID_QUERY_HEADER),

    /**
     * Invalid fee submitted
     */
    INVALID_FEE_SUBMITTED(ResponseCodeEnum.INVALID_FEE_SUBMITTED),

    /**
     * Payer signature is invalid
     */
    INVALID_PAYER_SIGNATURE(ResponseCodeEnum.INVALID_PAYER_SIGNATURE),

    /**
     * The keys were not provided in the request.
     */
    KEY_NOT_PROVIDED(ResponseCodeEnum.KEY_NOT_PROVIDED),

    /**
     * Expiration time provided in the transaction was invalid.
     */
    INVALID_EXPIRATION_TIME(ResponseCodeEnum.INVALID_EXPIRATION_TIME),

    /**
     * WriteAccess Control Keys are not provided for the file
     */
    NO_WACL_KEY(ResponseCodeEnum.NO_WACL_KEY),

    /**
     * The contents of file are provided as empty.
     */
    FILE_CONTENT_EMPTY(ResponseCodeEnum.FILE_CONTENT_EMPTY),

    /**
     * The crypto transfer credit and debit do not sum equal to 0
     */
    INVALID_ACCOUNT_AMOUNTS(ResponseCodeEnum.INVALID_ACCOUNT_AMOUNTS),

    /**
     * Transaction body provided is empty
     */
    EMPTY_TRANSACTION_BODY(ResponseCodeEnum.EMPTY_TRANSACTION_BODY),

    /**
     * Invalid transaction body provided
     */
    INVALID_TRANSACTION_BODY(ResponseCodeEnum.INVALID_TRANSACTION_BODY),

    /**
     * the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
     * signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
     */
    INVALID_SIGNATURE_TYPE_MISMATCHING_KEY(ResponseCodeEnum.INVALID_SIGNATURE_TYPE_MISMATCHING_KEY),

    /**
     * the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
     * or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
     * signatureList should also have 3 base signatures.
     */
    INVALID_SIGNATURE_COUNT_MISMATCHING_KEY(ResponseCodeEnum.INVALID_SIGNATURE_COUNT_MISMATCHING_KEY),

    /**
     * the livehash body is empty
     */
    EMPTY_LIVE_HASH_BODY(ResponseCodeEnum.EMPTY_LIVE_HASH_BODY),

    /**
     * the livehash data is missing
     */
    EMPTY_LIVE_HASH(ResponseCodeEnum.EMPTY_LIVE_HASH),

    /**
     * the keys for a livehash are missing
     */
    EMPTY_LIVE_HASH_KEYS(ResponseCodeEnum.EMPTY_LIVE_HASH_KEYS),

    /**
     * the livehash data is not the output of a SHA-384 digest
     */
    INVALID_LIVE_HASH_SIZE(ResponseCodeEnum.INVALID_LIVE_HASH_SIZE),

    /**
     * the query body is empty
     */
    EMPTY_QUERY_BODY(ResponseCodeEnum.EMPTY_QUERY_BODY),

    /**
     * the crypto livehash query is empty
     */
    EMPTY_LIVE_HASH_QUERY(ResponseCodeEnum.EMPTY_LIVE_HASH_QUERY),

    /**
     * the livehash is not present
     */
    LIVE_HASH_NOT_FOUND(ResponseCodeEnum.LIVE_HASH_NOT_FOUND),

    /**
     * the account id passed has not yet been created.
     */
    ACCOUNT_ID_DOES_NOT_EXIST(ResponseCodeEnum.ACCOUNT_ID_DOES_NOT_EXIST),

    /**
     * the livehash already exists for a given account
     */
    LIVE_HASH_ALREADY_EXISTS(ResponseCodeEnum.LIVE_HASH_ALREADY_EXISTS),

    /**
     * File WACL keys are invalid
     */
    INVALID_FILE_WACL(ResponseCodeEnum.INVALID_FILE_WACL),

    /**
     * Serialization failure
     */
    SERIALIZATION_FAILED(ResponseCodeEnum.SERIALIZATION_FAILED),

    /**
     * The size of the Transaction is greater than transactionMaxBytes
     */
    TRANSACTION_OVERSIZE(ResponseCodeEnum.TRANSACTION_OVERSIZE),

    /**
     * The Transaction has more than 50 levels
     */
    TRANSACTION_TOO_MANY_LAYERS(ResponseCodeEnum.TRANSACTION_TOO_MANY_LAYERS),

    /**
     * Contract is marked as deleted
     */
    CONTRACT_DELETED(ResponseCodeEnum.CONTRACT_DELETED),

    /**
     * the platform node is either disconnected or lagging behind.
     */
    PLATFORM_NOT_ACTIVE(ResponseCodeEnum.PLATFORM_NOT_ACTIVE),

    /**
     * one public key matches more than one prefixes on the signature map
     */
    KEY_PREFIX_MISMATCH(ResponseCodeEnum.KEY_PREFIX_MISMATCH),

    /**
     * transaction not created by platform due to large backlog
     */
    PLATFORM_TRANSACTION_NOT_CREATED(ResponseCodeEnum.PLATFORM_TRANSACTION_NOT_CREATED),

    /**
     * auto renewal period is not a positive number of seconds
     */
    INVALID_RENEWAL_PERIOD(ResponseCodeEnum.INVALID_RENEWAL_PERIOD),

    /**
     * the response code when a smart contract id is passed for a crypto API request
     */
    INVALID_PAYER_ACCOUNT_ID(ResponseCodeEnum.INVALID_PAYER_ACCOUNT_ID),

    /**
     * the account has been marked as deleted
     */
    ACCOUNT_DELETED(ResponseCodeEnum.ACCOUNT_DELETED),

    /**
     * the file has been marked as deleted
     */
    FILE_DELETED(ResponseCodeEnum.FILE_DELETED),

    /**
     * same accounts repeated in the transfer account list
     */
    ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS(ResponseCodeEnum.ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS),

    /**
     * attempting to set negative balance value for crypto account
     */
    SETTING_NEGATIVE_ACCOUNT_BALANCE(ResponseCodeEnum.SETTING_NEGATIVE_ACCOUNT_BALANCE),

    /**
     * when deleting smart contract that has crypto balance either transfer account or transfer smart
     * contract is required
     */
    OBTAINER_REQUIRED(ResponseCodeEnum.OBTAINER_REQUIRED),

    /**
     * when deleting smart contract that has crypto balance you can not use the same contract id as
     * transferContractId as the one being deleted
     */
    OBTAINER_SAME_CONTRACT_ID(ResponseCodeEnum.OBTAINER_SAME_CONTRACT_ID),

    /**
     * transferAccountId or transferContractId specified for contract delete does not exist
     */
    OBTAINER_DOES_NOT_EXIST(ResponseCodeEnum.OBTAINER_DOES_NOT_EXIST),

    /**
     * attempting to modify (update or delete a immutable smart contract, i.e. one created without a
     * admin key)
     */
    MODIFYING_IMMUTABLE_CONTRACT(ResponseCodeEnum.MODIFYING_IMMUTABLE_CONTRACT),

    /**
     * Unexpected exception thrown by file system functions
     */
    FILE_SYSTEM_EXCEPTION(ResponseCodeEnum.FILE_SYSTEM_EXCEPTION),

    /**
     * the duration is not a subset of [MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION]
     */
    AUTORENEW_DURATION_NOT_IN_RANGE(ResponseCodeEnum.AUTORENEW_DURATION_NOT_IN_RANGE),

    /**
     * Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
     * string.
     */
    ERROR_DECODING_BYTESTRING(ResponseCodeEnum.ERROR_DECODING_BYTESTRING),

    /**
     * File to create a smart contract was of length zero
     */
    CONTRACT_FILE_EMPTY(ResponseCodeEnum.CONTRACT_FILE_EMPTY),

    /**
     * Bytecode for smart contract is of length zero
     */
    CONTRACT_BYTECODE_EMPTY(ResponseCodeEnum.CONTRACT_BYTECODE_EMPTY),

    /**
     * Attempt to set negative initial balance
     */
    INVALID_INITIAL_BALANCE(ResponseCodeEnum.INVALID_INITIAL_BALANCE),

    /**
     * [Deprecated]. attempt to set negative receive record threshold
     */
    INVALID_RECEIVE_RECORD_THRESHOLD(ResponseCodeEnum.INVALID_RECEIVE_RECORD_THRESHOLD),

    /**
     * [Deprecated]. attempt to set negative send record threshold
     */
    INVALID_SEND_RECORD_THRESHOLD(ResponseCodeEnum.INVALID_SEND_RECORD_THRESHOLD),

    /**
     * Special Account Operations should be performed by only Genesis account, return this code if it
     * is not Genesis Account
     */
    ACCOUNT_IS_NOT_GENESIS_ACCOUNT(ResponseCodeEnum.ACCOUNT_IS_NOT_GENESIS_ACCOUNT),

    /**
     * The fee payer account doesn't have permission to submit such Transaction
     */
    PAYER_ACCOUNT_UNAUTHORIZED(ResponseCodeEnum.PAYER_ACCOUNT_UNAUTHORIZED),

    /**
     * FreezeTransactionBody is invalid
     */
    INVALID_FREEZE_TRANSACTION_BODY(ResponseCodeEnum.INVALID_FREEZE_TRANSACTION_BODY),

    /**
     * FreezeTransactionBody does not exist
     */
    FREEZE_TRANSACTION_BODY_NOT_FOUND(ResponseCodeEnum.FREEZE_TRANSACTION_BODY_NOT_FOUND),

    /**
     * Exceeded the number of accounts (both from and to) allowed for crypto transfer list
     */
    TRANSFER_LIST_SIZE_LIMIT_EXCEEDED(ResponseCodeEnum.TRANSFER_LIST_SIZE_LIMIT_EXCEEDED),

    /**
     * Smart contract result size greater than specified maxResultSize
     */
    RESULT_SIZE_LIMIT_EXCEEDED(ResponseCodeEnum.RESULT_SIZE_LIMIT_EXCEEDED),

    /**
     * The payer account is not a special account(account 0.0.55)
     */
    NOT_SPECIAL_ACCOUNT(ResponseCodeEnum.NOT_SPECIAL_ACCOUNT),

    /**
     * Negative gas was offered in smart contract call
     */
    CONTRACT_NEGATIVE_GAS(ResponseCodeEnum.CONTRACT_NEGATIVE_GAS),

    /**
     * Negative value / initial balance was specified in a smart contract call / create
     */
    CONTRACT_NEGATIVE_VALUE(ResponseCodeEnum.CONTRACT_NEGATIVE_VALUE),

    /**
     * Failed to update fee file
     */
    INVALID_FEE_FILE(ResponseCodeEnum.INVALID_FEE_FILE),

    /**
     * Failed to update exchange rate file
     */
    INVALID_EXCHANGE_RATE_FILE(ResponseCodeEnum.INVALID_EXCHANGE_RATE_FILE),

    /**
     * Payment tendered for contract local call cannot cover both the fee and the gas
     */
    INSUFFICIENT_LOCAL_CALL_GAS(ResponseCodeEnum.INSUFFICIENT_LOCAL_CALL_GAS),

    /**
     * Entities with Entity ID below 1000 are not allowed to be deleted
     */
    ENTITY_NOT_ALLOWED_TO_DELETE(ResponseCodeEnum.ENTITY_NOT_ALLOWED_TO_DELETE),

    /**
     * Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
     * account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
     * A/c 0.0.50 - Update all Network Function accounts and perform all the Network Functions listed
     * below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
     * ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
     * (0.0.112).
     */
    AUTHORIZATION_FAILED(ResponseCodeEnum.AUTHORIZATION_FAILED),

    /**
     * Fee Schedule Proto uploaded but not valid (append or update is required)
     */
    FILE_UPLOADED_PROTO_INVALID(ResponseCodeEnum.FILE_UPLOADED_PROTO_INVALID),

    /**
     * Fee Schedule Proto uploaded but not valid (append or update is required)
     */
    FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK(ResponseCodeEnum.FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK),

    /**
     * Fee Schedule Proto File Part uploaded
     */
    FEE_SCHEDULE_FILE_PART_UPLOADED(ResponseCodeEnum.FEE_SCHEDULE_FILE_PART_UPLOADED),

    /**
     * The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
     */
    EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED(ResponseCodeEnum.EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED),

    /**
     * Contract permanent storage exceeded the currently allowable limit
     */
    MAX_CONTRACT_STORAGE_EXCEEDED(ResponseCodeEnum.MAX_CONTRACT_STORAGE_EXCEEDED),

    /**
     * Transfer Account should not be same as Account to be deleted
     */
    TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT(ResponseCodeEnum.TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT),

    TOTAL_LEDGER_BALANCE_INVALID(ResponseCodeEnum.TOTAL_LEDGER_BALANCE_INVALID),

    /**
     * The expiration date/time on a smart contract may not be reduced
     */
    EXPIRATION_REDUCTION_NOT_ALLOWED(ResponseCodeEnum.EXPIRATION_REDUCTION_NOT_ALLOWED),

    /**
     * Gas exceeded currently allowable gas limit per transaction
     */
    MAX_GAS_LIMIT_EXCEEDED(ResponseCodeEnum.MAX_GAS_LIMIT_EXCEEDED),

    /**
     * File size exceeded the currently allowable limit
     */
    MAX_FILE_SIZE_EXCEEDED(ResponseCodeEnum.MAX_FILE_SIZE_EXCEEDED),

    /**
     * When a valid signature is not provided for operations on account with receiverSigRequired=true
     */
    RECEIVER_SIG_REQUIRED(ResponseCodeEnum.RECEIVER_SIG_REQUIRED),

    /**
     * The Topic ID specified is not in the system.
     */
    INVALID_TOPIC_ID(ResponseCodeEnum.INVALID_TOPIC_ID),

    /**
     * A provided admin key was invalid. Verify the bytes for an Ed25519 public key are exactly 32 bytes; and the bytes for a compressed ECDSA(secp256k1) key are exactly 33 bytes, with the first byte either 0x02 or 0x03..
     */
    INVALID_ADMIN_KEY(ResponseCodeEnum.INVALID_ADMIN_KEY),

    /**
     * A provided submit key was invalid.
     */
    INVALID_SUBMIT_KEY(ResponseCodeEnum.INVALID_SUBMIT_KEY),

    /**
     * An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
     */
    UNAUTHORIZED(ResponseCodeEnum.UNAUTHORIZED),

    /**
     * A ConsensusService message is empty.
     */
    INVALID_TOPIC_MESSAGE(ResponseCodeEnum.INVALID_TOPIC_MESSAGE),

    /**
     * The autoRenewAccount specified is not a valid, active account.
     */
    INVALID_AUTORENEW_ACCOUNT(ResponseCodeEnum.INVALID_AUTORENEW_ACCOUNT),

    /**
     * An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
     */
    AUTORENEW_ACCOUNT_NOT_ALLOWED(ResponseCodeEnum.AUTORENEW_ACCOUNT_NOT_ALLOWED),

    /**
     * The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
     * topic will be deleted unrecoverably. This error response code will not be returned until
     * autoRenew functionality is supported by HAPI.
     */
    TOPIC_EXPIRED(ResponseCodeEnum.TOPIC_EXPIRED),

    /**
     * chunk number must be from 1 to total (chunks) inclusive.
     */
    INVALID_CHUNK_NUMBER(ResponseCodeEnum.INVALID_CHUNK_NUMBER),

    /**
     * For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.
     */
    INVALID_CHUNK_TRANSACTION_ID(ResponseCodeEnum.INVALID_CHUNK_TRANSACTION_ID),

    /**
     * Account is frozen and cannot transact with the token
     */
    ACCOUNT_FROZEN_FOR_TOKEN(ResponseCodeEnum.ACCOUNT_FROZEN_FOR_TOKEN),

    /**
     * An involved account already has more than tokens.maxPerAccount associations with non-deleted tokens.
     */
    TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED(ResponseCodeEnum.TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED),

    /**
     * The token is invalid or does not exist
     */
    INVALID_TOKEN_ID(ResponseCodeEnum.INVALID_TOKEN_ID),

    /**
     * Invalid token decimals
     */
    INVALID_TOKEN_DECIMALS(ResponseCodeEnum.INVALID_TOKEN_DECIMALS),

    /**
     * Invalid token initial supply
     */
    INVALID_TOKEN_INITIAL_SUPPLY(ResponseCodeEnum.INVALID_TOKEN_INITIAL_SUPPLY),

    /**
     * Treasury Account does not exist or is deleted
     */
    INVALID_TREASURY_ACCOUNT_FOR_TOKEN(ResponseCodeEnum.INVALID_TREASURY_ACCOUNT_FOR_TOKEN),

    /**
     * Token Symbol is not UTF-8 capitalized alphabetical string
     */
    INVALID_TOKEN_SYMBOL(ResponseCodeEnum.INVALID_TOKEN_SYMBOL),

    /**
     * Freeze key is not set on token
     */
    TOKEN_HAS_NO_FREEZE_KEY(ResponseCodeEnum.TOKEN_HAS_NO_FREEZE_KEY),

    /**
     * Amounts in transfer list are not net zero
     */
    TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN(ResponseCodeEnum.TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN),

    /**
     * A token symbol was not provided
     */
    MISSING_TOKEN_SYMBOL(ResponseCodeEnum.MISSING_TOKEN_SYMBOL),

    /**
     * The provided token symbol was too long
     */
    TOKEN_SYMBOL_TOO_LONG(ResponseCodeEnum.TOKEN_SYMBOL_TOO_LONG),

    /**
     * KYC must be granted and account does not have KYC granted
     */
    ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN(ResponseCodeEnum.ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN),

    /**
     * KYC key is not set on token
     */
    TOKEN_HAS_NO_KYC_KEY(ResponseCodeEnum.TOKEN_HAS_NO_KYC_KEY),

    /**
     * Token balance is not sufficient for the transaction
     */
    INSUFFICIENT_TOKEN_BALANCE(ResponseCodeEnum.INSUFFICIENT_TOKEN_BALANCE),

    /**
     * Token transactions cannot be executed on deleted token
     */
    TOKEN_WAS_DELETED(ResponseCodeEnum.TOKEN_WAS_DELETED),

    /**
     * Supply key is not set on token
     */
    TOKEN_HAS_NO_SUPPLY_KEY(ResponseCodeEnum.TOKEN_HAS_NO_SUPPLY_KEY),

    /**
     * Wipe key is not set on token
     */
    TOKEN_HAS_NO_WIPE_KEY(ResponseCodeEnum.TOKEN_HAS_NO_WIPE_KEY),

    /**
     * The requested token mint amount would cause an invalid total supply
     */
    INVALID_TOKEN_MINT_AMOUNT(ResponseCodeEnum.INVALID_TOKEN_MINT_AMOUNT),

    /**
     * The requested token burn amount would cause an invalid total supply
     */
    INVALID_TOKEN_BURN_AMOUNT(ResponseCodeEnum.INVALID_TOKEN_BURN_AMOUNT),

    /**
     * A required token-account relationship is missing
     */
    TOKEN_NOT_ASSOCIATED_TO_ACCOUNT(ResponseCodeEnum.TOKEN_NOT_ASSOCIATED_TO_ACCOUNT),

    /**
     * The target of a wipe operation was the token treasury account
     */
    CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT(ResponseCodeEnum.CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT),

    /**
     * The provided KYC key was invalid.
     */
    INVALID_KYC_KEY(ResponseCodeEnum.INVALID_KYC_KEY),

    /**
     * The provided wipe key was invalid.
     */
    INVALID_WIPE_KEY(ResponseCodeEnum.INVALID_WIPE_KEY),

    /**
     * The provided freeze key was invalid.
     */
    INVALID_FREEZE_KEY(ResponseCodeEnum.INVALID_FREEZE_KEY),

    /**
     * The provided supply key was invalid.
     */
    INVALID_SUPPLY_KEY(ResponseCodeEnum.INVALID_SUPPLY_KEY),

    /**
     * Token Name is not provided
     */
    MISSING_TOKEN_NAME(ResponseCodeEnum.MISSING_TOKEN_NAME),

    /**
     * Token Name is too long
     */
    TOKEN_NAME_TOO_LONG(ResponseCodeEnum.TOKEN_NAME_TOO_LONG),

    /**
     * The provided wipe amount must not be negative, zero or bigger than the token holder balance
     */
    INVALID_WIPING_AMOUNT(ResponseCodeEnum.INVALID_WIPING_AMOUNT),

    /**
     * Token does not have Admin key set, thus update/delete transactions cannot be performed
     */
    TOKEN_IS_IMMUTABLE(ResponseCodeEnum.TOKEN_IS_IMMUTABLE),

    /**
     * An associateToken operation specified a token already associated to the account
     */
    TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT(ResponseCodeEnum.TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT),

    /**
     * An attempted operation is invalid until all token balances for the target account are zero
     */
    TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES(ResponseCodeEnum.TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES),

    /**
     * An attempted operation is invalid because the account is a treasury
     */
    ACCOUNT_IS_TREASURY(ResponseCodeEnum.ACCOUNT_IS_TREASURY),

    /**
     * Same TokenIDs present in the token list
     */
    TOKEN_ID_REPEATED_IN_TOKEN_LIST(ResponseCodeEnum.TOKEN_ID_REPEATED_IN_TOKEN_LIST),

    /**
     * Exceeded the number of token transfers (both from and to) allowed for token transfer list
     */
    TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED(ResponseCodeEnum.TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED),

    /**
     * TokenTransfersTransactionBody has no TokenTransferList
     */
    EMPTY_TOKEN_TRANSFER_BODY(ResponseCodeEnum.EMPTY_TOKEN_TRANSFER_BODY),

    /**
     * TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts
     */
    EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS(ResponseCodeEnum.EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS),

    /**
     * The Scheduled entity does not exist; or has now expired, been deleted, or been executed
     */
    INVALID_SCHEDULE_ID(ResponseCodeEnum.INVALID_SCHEDULE_ID),

    /**
     * The Scheduled entity cannot be modified. Admin key not set
     */
    SCHEDULE_IS_IMMUTABLE(ResponseCodeEnum.SCHEDULE_IS_IMMUTABLE),

    /**
     * The provided Scheduled Payer does not exist
     */
    INVALID_SCHEDULE_PAYER_ID(ResponseCodeEnum.INVALID_SCHEDULE_PAYER_ID),

    /**
     * The Schedule Create Transaction TransactionID account does not exist
     */
    INVALID_SCHEDULE_ACCOUNT_ID(ResponseCodeEnum.INVALID_SCHEDULE_ACCOUNT_ID),

    /**
     * The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
     */
    NO_NEW_VALID_SIGNATURES(ResponseCodeEnum.NO_NEW_VALID_SIGNATURES),

    /**
     * The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted
     */
    UNRESOLVABLE_REQUIRED_SIGNERS(ResponseCodeEnum.UNRESOLVABLE_REQUIRED_SIGNERS),

    /**
     * Only whitelisted transaction types may be scheduled
     */
    SCHEDULED_TRANSACTION_NOT_IN_WHITELIST(ResponseCodeEnum.SCHEDULED_TRANSACTION_NOT_IN_WHITELIST),

    /**
     * At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
     */
    SOME_SIGNATURES_WERE_INVALID(ResponseCodeEnum.SOME_SIGNATURES_WERE_INVALID),

    /**
     * The scheduled field in the TransactionID may not be set to true
     */
    TRANSACTION_ID_FIELD_NOT_ALLOWED(ResponseCodeEnum.TRANSACTION_ID_FIELD_NOT_ALLOWED),

    /**
     * A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)
     */
    IDENTICAL_SCHEDULE_ALREADY_CREATED(ResponseCodeEnum.IDENTICAL_SCHEDULE_ALREADY_CREATED),

    /**
     * A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
     */
    INVALID_ZERO_BYTE_IN_STRING(ResponseCodeEnum.INVALID_ZERO_BYTE_IN_STRING),

    /**
     * A schedule being signed or deleted has already been deleted
     */
    SCHEDULE_ALREADY_DELETED(ResponseCodeEnum.SCHEDULE_ALREADY_DELETED),

    /**
     * A schedule being signed or deleted has already been executed
     */
    SCHEDULE_ALREADY_EXECUTED(ResponseCodeEnum.SCHEDULE_ALREADY_EXECUTED),

    /**
     * ConsensusSubmitMessage request's message size is larger than allowed.
     */
    MESSAGE_SIZE_TOO_LARGE(ResponseCodeEnum.MESSAGE_SIZE_TOO_LARGE),

    /**
     * An operation was assigned to more than one throttle group in a given bucket
     */
    OPERATION_REPEATED_IN_BUCKET_GROUPS(ResponseCodeEnum.OPERATION_REPEATED_IN_BUCKET_GROUPS),

    /**
     * The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
     */
    BUCKET_CAPACITY_OVERFLOW(ResponseCodeEnum.BUCKET_CAPACITY_OVERFLOW),

    /**
     * Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased
     */
    NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION(ResponseCodeEnum.NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION),

    /**
     * A bucket was defined without any throttle groups
     */
    BUCKET_HAS_NO_THROTTLE_GROUPS(ResponseCodeEnum.BUCKET_HAS_NO_THROTTLE_GROUPS),

    /**
     * A throttle group was granted zero opsPerSec
     */
    THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC(ResponseCodeEnum.THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC),

    /**
     * The throttle definitions file was updated, but some supported operations were not assigned a bucket
     */
    SUCCESS_BUT_MISSING_EXPECTED_OPERATION(ResponseCodeEnum.SUCCESS_BUT_MISSING_EXPECTED_OPERATION),

    /**
     * The new contents for the throttle definitions system file were not valid protobuf
     */
    UNPARSEABLE_THROTTLE_DEFINITIONS(ResponseCodeEnum.UNPARSEABLE_THROTTLE_DEFINITIONS),

    /**
     * The new throttle definitions system file were invalid, and no more specific error could be divined
     */
    INVALID_THROTTLE_DEFINITIONS(ResponseCodeEnum.INVALID_THROTTLE_DEFINITIONS),

    /**
     * The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities
     */
    ACCOUNT_EXPIRED_AND_PENDING_REMOVAL(ResponseCodeEnum.ACCOUNT_EXPIRED_AND_PENDING_REMOVAL),

    /**
     * Invalid token max supply
     */
    INVALID_TOKEN_MAX_SUPPLY(ResponseCodeEnum.INVALID_TOKEN_MAX_SUPPLY),

    /**
     * Invalid token nft serial number
     */
    INVALID_TOKEN_NFT_SERIAL_NUMBER(ResponseCodeEnum.INVALID_TOKEN_NFT_SERIAL_NUMBER),

    /**
     * Invalid nft id
     */
    INVALID_NFT_ID(ResponseCodeEnum.INVALID_NFT_ID),

    /**
     * Nft metadata is too long
     */
    METADATA_TOO_LONG(ResponseCodeEnum.METADATA_TOO_LONG),

    /**
     * Repeated operations count exceeds the limit
     */
    BATCH_SIZE_LIMIT_EXCEEDED(ResponseCodeEnum.BATCH_SIZE_LIMIT_EXCEEDED),

    /**
     * The range of data to be gathered is out of the set boundaries
     */
    INVALID_QUERY_RANGE(ResponseCodeEnum.INVALID_QUERY_RANGE),

    /**
     * A custom fractional fee set a denominator of zero
     */
    FRACTION_DIVIDES_BY_ZERO(ResponseCodeEnum.FRACTION_DIVIDES_BY_ZERO),

    /**
     * The transaction payer could not afford a custom fee
     */
    INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE(ResponseCodeEnum.INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE),

    /**
     * More than 10 custom fees were specified
     */
    CUSTOM_FEES_LIST_TOO_LONG(ResponseCodeEnum.CUSTOM_FEES_LIST_TOO_LONG),

    /**
     * Any of the feeCollector accounts for customFees is invalid
     */
    INVALID_CUSTOM_FEE_COLLECTOR(ResponseCodeEnum.INVALID_CUSTOM_FEE_COLLECTOR),

    /**
     * Any of the token Ids in customFees is invalid
     */
    INVALID_TOKEN_ID_IN_CUSTOM_FEES(ResponseCodeEnum.INVALID_TOKEN_ID_IN_CUSTOM_FEES),

    /**
     * Any of the token Ids in customFees are not associated to feeCollector
     */
    TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR(ResponseCodeEnum.TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR),

    /**
     * A token cannot have more units minted due to its configured supply ceiling
     */
    TOKEN_MAX_SUPPLY_REACHED(ResponseCodeEnum.TOKEN_MAX_SUPPLY_REACHED),

    /**
     * The transaction attempted to move an NFT serial number from an account other than its owner
     */
    SENDER_DOES_NOT_OWN_NFT_SERIAL_NO(ResponseCodeEnum.SENDER_DOES_NOT_OWN_NFT_SERIAL_NO),

    /**
     * A custom fee schedule entry did not specify either a fixed or fractional fee
     */
    CUSTOM_FEE_NOT_FULLY_SPECIFIED(ResponseCodeEnum.CUSTOM_FEE_NOT_FULLY_SPECIFIED),

    /**
     * Only positive fees may be assessed at this time
     */
    CUSTOM_FEE_MUST_BE_POSITIVE(ResponseCodeEnum.CUSTOM_FEE_MUST_BE_POSITIVE),

    /**
     * Fee schedule key is not set on token
     */
    TOKEN_HAS_NO_FEE_SCHEDULE_KEY(ResponseCodeEnum.TOKEN_HAS_NO_FEE_SCHEDULE_KEY),

    /**
     * A fractional custom fee exceeded the range of a 64-bit signed integer
     */
    CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE(ResponseCodeEnum.CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE),

    /**
     * A royalty cannot exceed the total fungible value exchanged for an NFT
     */
    ROYALTY_FRACTION_CANNOT_EXCEED_ONE(ResponseCodeEnum.ROYALTY_FRACTION_CANNOT_EXCEED_ONE),

    /**
     * Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
     */
    FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT(ResponseCodeEnum.FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT),

    /**
     * A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
     */
    CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES(ResponseCodeEnum.CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES),

    /**
     * Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
     */
    CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON(ResponseCodeEnum.CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON),

    /**
     * Only tokens of type FUNGIBLE_COMMON can have fractional fees
     */
    CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON(ResponseCodeEnum.CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON),

    /**
     * The provided custom fee schedule key was invalid
     */
    INVALID_CUSTOM_FEE_SCHEDULE_KEY(ResponseCodeEnum.INVALID_CUSTOM_FEE_SCHEDULE_KEY),

    /**
     * The requested token mint metadata was invalid
     */
    INVALID_TOKEN_MINT_METADATA(ResponseCodeEnum.INVALID_TOKEN_MINT_METADATA),

    /**
     * The requested token burn metadata was invalid
     */
    INVALID_TOKEN_BURN_METADATA(ResponseCodeEnum.INVALID_TOKEN_BURN_METADATA),

    /**
     * The treasury for a unique token cannot be changed until it owns no NFTs
     */
    CURRENT_TREASURY_STILL_OWNS_NFTS(ResponseCodeEnum.CURRENT_TREASURY_STILL_OWNS_NFTS),

    /**
     * An account cannot be dissociated from a unique token if it owns NFTs for the token
     */
    ACCOUNT_STILL_OWNS_NFTS(ResponseCodeEnum.ACCOUNT_STILL_OWNS_NFTS),

    /**
     * A NFT can only be burned when owned by the unique token's treasury
     */
    TREASURY_MUST_OWN_BURNED_NFT(ResponseCodeEnum.TREASURY_MUST_OWN_BURNED_NFT),

    /**
     * An account did not own the NFT to be wiped
     */
    ACCOUNT_DOES_NOT_OWN_WIPED_NFT(ResponseCodeEnum.ACCOUNT_DOES_NOT_OWN_WIPED_NFT),

    /**
     * An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
     */
    ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON(ResponseCodeEnum.ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON),

    /**
     * All the NFTs allowed in the current price regime have already been minted
     */
    MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED(ResponseCodeEnum.MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED),

    /**
     * The payer account has been marked as deleted
     */
    PAYER_ACCOUNT_DELETED(ResponseCodeEnum.PAYER_ACCOUNT_DELETED),

    /**
     * The reference chain of custom fees for a transferred token exceeded the maximum length of 2
     */
    CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH(ResponseCodeEnum.CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH),

    /**
     * More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
     */
    CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS(ResponseCodeEnum.CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS),

    /**
     * The sender account in the token transfer transaction could not afford a custom fee
     */
    INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE(ResponseCodeEnum.INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE),

    /**
     * Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
     */
    SERIAL_NUMBER_LIMIT_REACHED(ResponseCodeEnum.SERIAL_NUMBER_LIMIT_REACHED),

    /**
     * Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
     */
    CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE(ResponseCodeEnum.CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE),

    /**
     * The account has reached the limit on the automatic associations count.
     */
    NO_REMAINING_AUTOMATIC_ASSOCIATIONS(ResponseCodeEnum.NO_REMAINING_AUTOMATIC_ASSOCIATIONS),

    /**
     * Already existing automatic associations are more than the new maximum automatic associations.
     */
    EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT(ResponseCodeEnum.EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT),

    /**
     * Cannot set the number of automatic associations for an account more than the maximum allowed
     * token associations tokens.maxPerAccount.
     */
    REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT(ResponseCodeEnum.REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT),

    /**
     * Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
     */
    TOKEN_IS_PAUSED(ResponseCodeEnum.TOKEN_IS_PAUSED),

    /**
     * Pause key is not set on token
     */
    TOKEN_HAS_NO_PAUSE_KEY(ResponseCodeEnum.TOKEN_HAS_NO_PAUSE_KEY),

    /**
     * The provided pause key was invalid
     */
    INVALID_PAUSE_KEY(ResponseCodeEnum.INVALID_PAUSE_KEY),

    /**
     * The update file in a freeze transaction body must exist.
     */
    FREEZE_UPDATE_FILE_DOES_NOT_EXIST(ResponseCodeEnum.FREEZE_UPDATE_FILE_DOES_NOT_EXIST),

    /**
     * The hash of the update file in a freeze transaction body must match the in-memory hash.
     */
    FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH(ResponseCodeEnum.FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH),

    /**
     * A FREEZE_UPGRADE transaction was handled with no previous update prepared.
     */
    NO_UPGRADE_HAS_BEEN_PREPARED(ResponseCodeEnum.NO_UPGRADE_HAS_BEEN_PREPARED),

    /**
     * A FREEZE_ABORT transaction was handled with no scheduled freeze.
     */
    NO_FREEZE_IS_SCHEDULED(ResponseCodeEnum.NO_FREEZE_IS_SCHEDULED),

    /**
     * The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
     * hash at the time of handling the PREPARE_UPGRADE transaction.
     */
    UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE(ResponseCodeEnum.UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE),

    /**
     * The given freeze start time was in the (consensus) past.
     */
    FREEZE_START_TIME_MUST_BE_FUTURE(ResponseCodeEnum.FREEZE_START_TIME_MUST_BE_FUTURE),

    /**
     * The prepared update file cannot be updated or appended until either the upgrade has
     * been completed, or a FREEZE_ABORT has been handled.
     */
    PREPARED_UPDATE_FILE_IS_IMMUTABLE(ResponseCodeEnum.PREPARED_UPDATE_FILE_IS_IMMUTABLE),

    /**
     * Once a freeze is scheduled, it must be aborted before any other type of freeze can
     * can be performed.
     */
    FREEZE_ALREADY_SCHEDULED(ResponseCodeEnum.FREEZE_ALREADY_SCHEDULED),

    /**
     * If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
     * (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
     */
    FREEZE_UPGRADE_IN_PROGRESS(ResponseCodeEnum.FREEZE_UPGRADE_IN_PROGRESS),

    /**
     * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
     * confirm the id of the file to be used in the upgrade.
     */
    UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED(ResponseCodeEnum.UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED),

    /**
     * If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
     * confirm the hash of the file to be used in the upgrade.
     */
    UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED(ResponseCodeEnum.UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED),

    /**
     * Consensus throttle did not allow execution of this transaction. System is throttled at
     * consensus level.
     */
    CONSENSUS_GAS_EXHAUSTED(ResponseCodeEnum.CONSENSUS_GAS_EXHAUSTED),

    /**
     * A precompiled contract succeeded, but was later reverted.
     */
    REVERTED_SUCCESS(ResponseCodeEnum.REVERTED_SUCCESS),

    /**
     * All contract storage allocated to the current price regime has been consumed.
     */
    MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED(ResponseCodeEnum.MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED),

    /**
     * An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
     * message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
     * unknown protobuf fields.
     */
    INVALID_ALIAS_KEY(ResponseCodeEnum.INVALID_ALIAS_KEY),

    /**
     * A fungible token transfer expected a different number of decimals than the involved
     * type actually has.
     */
    UNEXPECTED_TOKEN_DECIMALS(ResponseCodeEnum.UNEXPECTED_TOKEN_DECIMALS),

    /**
     * [Deprecated] The proxy account id is invalid or does not exist.
     */
    INVALID_PROXY_ACCOUNT_ID(ResponseCodeEnum.INVALID_PROXY_ACCOUNT_ID),

    /**
     * The transfer account id in CryptoDelete transaction is invalid or does not exist.
     */
    INVALID_TRANSFER_ACCOUNT_ID(ResponseCodeEnum.INVALID_TRANSFER_ACCOUNT_ID),

    /**
     * The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
     */
    INVALID_FEE_COLLECTOR_ACCOUNT_ID(ResponseCodeEnum.INVALID_FEE_COLLECTOR_ACCOUNT_ID),

    /**
     * The alias already set on an account cannot be updated using CryptoUpdate transaction.
     */
    ALIAS_IS_IMMUTABLE(ResponseCodeEnum.ALIAS_IS_IMMUTABLE),

    /**
     * An approved allowance specifies a spender account that is the same as the hbar/token
     * owner account.
     */
    SPENDER_ACCOUNT_SAME_AS_OWNER(ResponseCodeEnum.SPENDER_ACCOUNT_SAME_AS_OWNER),

    /**
     * The establishment or adjustment of an approved allowance cause the token allowance
     * to exceed the token maximum supply.
     */
    AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY(ResponseCodeEnum.AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY),

    /**
     * The specified amount for an approved allowance cannot be negative.
     */
    NEGATIVE_ALLOWANCE_AMOUNT(ResponseCodeEnum.NEGATIVE_ALLOWANCE_AMOUNT),

    /**
     * [Deprecated] The approveForAll flag cannot be set for a fungible token.
     */
    CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON(ResponseCodeEnum.CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON),

    /**
     * The spender does not have an existing approved allowance with the hbar/token owner.
     */
    SPENDER_DOES_NOT_HAVE_ALLOWANCE(ResponseCodeEnum.SPENDER_DOES_NOT_HAVE_ALLOWANCE),

    /**
     * The transfer amount exceeds the current approved allowance for the spender account.
     */
    AMOUNT_EXCEEDS_ALLOWANCE(ResponseCodeEnum.AMOUNT_EXCEEDS_ALLOWANCE),

    /**
     * The payer account of an approveAllowances or adjustAllowance transaction is attempting
     * to go beyond the maximum allowed number of allowances.
     */
    MAX_ALLOWANCES_EXCEEDED(ResponseCodeEnum.MAX_ALLOWANCES_EXCEEDED),

    /**
     * No allowances have been specified in the approval transaction.
     */
    EMPTY_ALLOWANCES(ResponseCodeEnum.EMPTY_ALLOWANCES),

    /**
     * [Deprecated] Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
     * CryptoApproveAllowance transaction.
     */
    SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES(ResponseCodeEnum.SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES),

    /**
     * [Deprecated] Serial numbers are repeated in nft allowance for a single spender account
     */
    REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES(ResponseCodeEnum.REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES),

    /**
     * Fungible common token used in NFT allowances
     */
    FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES(ResponseCodeEnum.FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES),

    /**
     * Non fungible token used in fungible token allowances
     */
    NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES(ResponseCodeEnum.NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES),

    /**
     * The account id specified as the owner is invalid or does not exist.
     */
    INVALID_ALLOWANCE_OWNER_ID(ResponseCodeEnum.INVALID_ALLOWANCE_OWNER_ID),

    /**
     * The account id specified as the spender is invalid or does not exist.
     */
    INVALID_ALLOWANCE_SPENDER_ID(ResponseCodeEnum.INVALID_ALLOWANCE_SPENDER_ID),

    /**
     * [Deprecated] If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.
     */
    REPEATED_ALLOWANCES_TO_DELETE(ResponseCodeEnum.REPEATED_ALLOWANCES_TO_DELETE),

    /**
     * If the account Id specified as the delegating spender is invalid or does not exist.
     */
    INVALID_DELEGATING_SPENDER(ResponseCodeEnum.INVALID_DELEGATING_SPENDER),

    /**
     * The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
     */
    DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL(ResponseCodeEnum.DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL),

    /**
     * The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
     * granted on token-owner.
     */
    DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL(ResponseCodeEnum.DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL),

    /**
     * The scheduled transaction could not be created because it's expiration_time was too far in the future.
     */
    SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE(ResponseCodeEnum.SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE),

    /**
     * The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus time.
     */
    SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME(ResponseCodeEnum.SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME),

    /**
     * The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.
     */
    SCHEDULE_FUTURE_THROTTLE_EXCEEDED(ResponseCodeEnum.SCHEDULE_FUTURE_THROTTLE_EXCEEDED),

    /**
     * The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.
     */
    SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED(ResponseCodeEnum.SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED),

    /**
     * The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.
     */
    INVALID_ETHEREUM_TRANSACTION(ResponseCodeEnum.INVALID_ETHEREUM_TRANSACTION),

    /**
     * EthereumTransaction was signed against a chainId that this network does not support.
     */
    WRONG_CHAIN_ID(ResponseCodeEnum.WRONG_CHAIN_ID),

    /**
     * This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
     */
    WRONG_NONCE(ResponseCodeEnum.WRONG_NONCE),

    /**
     * The ethereum transaction specified an access list, which the network does not support.
     */
    ACCESS_LIST_UNSUPPORTED(ResponseCodeEnum.ACCESS_LIST_UNSUPPORTED),

    /**
     * A schedule being signed or deleted has passed it's expiration date and is pending execution if needed and then expiration.
     */
    SCHEDULE_PENDING_EXPIRATION(ResponseCodeEnum.SCHEDULE_PENDING_EXPIRATION),

    /**
     * A selfdestruct or ContractDelete targeted a contract that is a token treasury.
     */
    CONTRACT_IS_TOKEN_TREASURY(ResponseCodeEnum.CONTRACT_IS_TOKEN_TREASURY),

    /**
     * A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
     */
    CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES(ResponseCodeEnum.CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES),

    /**
     * A contract referenced by a transaction is "detached"; that is, expired and lacking any
     * hbar funds for auto-renewal payment---but still within its post-expiry grace period.
     */
    CONTRACT_EXPIRED_AND_PENDING_REMOVAL(ResponseCodeEnum.CONTRACT_EXPIRED_AND_PENDING_REMOVAL),

    /**
     * A ContractUpdate requested removal of a contract's auto-renew account, but that contract has
     * no auto-renew account.
     */
    CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT(ResponseCodeEnum.CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT),

    /**
     * A delete transaction submitted via HAPI set permanent_removal=true
     */
    PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION(ResponseCodeEnum.PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION),

    /**
     * A CryptoCreate or ContractCreate used the deprecated proxyAccountID field.
     */
    PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED(ResponseCodeEnum.PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED),

    /**
     * An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
     */
    SELF_STAKING_IS_NOT_ALLOWED(ResponseCodeEnum.SELF_STAKING_IS_NOT_ALLOWED),

    /**
     * The staking account id or staking node id given is invalid or does not exist.
     */
    INVALID_STAKING_ID(ResponseCodeEnum.INVALID_STAKING_ID),

    /**
     * Native staking, while implemented, has not yet enabled by the council.
     */
    STAKING_NOT_ENABLED(ResponseCodeEnum.STAKING_NOT_ENABLED),

    /**
     * The range provided in UtilPrng transaction is negative.
     */
    INVALID_PRNG_RANGE(ResponseCodeEnum.INVALID_PRNG_RANGE),

    /**
     * The maximum number of entities allowed in the current price regime have been created.
     */
    MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED(ResponseCodeEnum.MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED),

    /**
     * The full prefix signature for precompile is not valid
     */
    INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE(ResponseCodeEnum.INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE),

    /**
     * The combined balances of a contract and its auto-renew account (if any) did not cover
     * the rent charged for net new storage used in a transaction.
     */
    INSUFFICIENT_BALANCES_FOR_STORAGE_RENT(ResponseCodeEnum.INSUFFICIENT_BALANCES_FOR_STORAGE_RENT),

    /**
     * A contract transaction tried to use more than the allowed number of child records, via
     * either system contract records or internal contract creations.
     */
    MAX_CHILD_RECORDS_EXCEEDED(ResponseCodeEnum.MAX_CHILD_RECORDS_EXCEEDED),

    /**
     * The combined balances of a contract and its auto-renew account (if any) or balance of an account did not cover
     * the auto-renewal fees in a transaction.
     */
    INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES(ResponseCodeEnum.INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES),

    /**
     * A transaction's protobuf message includes unknown fields; could mean that a client
     * expects not-yet-released functionality to be available.
     */
    TRANSACTION_HAS_UNKNOWN_FIELDS(ResponseCodeEnum.TRANSACTION_HAS_UNKNOWN_FIELDS),

    /**
     * The account cannot be modified. Account's key is not set
     */
    ACCOUNT_IS_IMMUTABLE(ResponseCodeEnum.ACCOUNT_IS_IMMUTABLE),

    /**
     * An alias that is assigned to an account or contract cannot be assigned to another account or contract.
     */
    ALIAS_ALREADY_ASSIGNED(ResponseCodeEnum.ALIAS_ALREADY_ASSIGNED),

    /**
     * A provided metadata key was invalid. Verification includes, for example, checking the size of Ed25519 and ECDSA(secp256k1) public keys.
     */
    INVALID_METADATA_KEY(ResponseCodeEnum.INVALID_METADATA_KEY),

    /**
     * Metadata key is not set on token
     */
    TOKEN_HAS_NO_METADATA_KEY(ResponseCodeEnum.TOKEN_HAS_NO_METADATA_KEY),

    /**
     * Token Metadata is not provided
     */
    MISSING_TOKEN_METADATA(ResponseCodeEnum.MISSING_TOKEN_METADATA),

    /**
     * NFT serial numbers are missing in the TokenUpdateNftsTransactionBody
     */
    MISSING_SERIAL_NUMBERS(ResponseCodeEnum.MISSING_SERIAL_NUMBERS),

    /**
     * Admin key is not set on token
     */
    TOKEN_HAS_NO_ADMIN_KEY(ResponseCodeEnum.TOKEN_HAS_NO_ADMIN_KEY),

    /**
     * A transaction failed because the consensus node identified is
     * deleted from the address book.
     */
    NODE_DELETED(ResponseCodeEnum.NODE_DELETED),

    /**
     * A transaction failed because the consensus node identified is not valid or
     * does not exist in state.
     */
    INVALID_NODE_ID(ResponseCodeEnum.INVALID_NODE_ID),

    /**
     * A transaction failed because one or more entries in the list of
     * service endpoints for the `gossip_endpoint` field is invalid.<br/>
     * The most common cause for this response is a service endpoint that has
     * the domain name (DNS) set rather than address and port.
     */
    INVALID_GOSSIP_ENDPOINT(ResponseCodeEnum.INVALID_GOSSIP_ENDPOINT),

    /**
     * A transaction failed because the node account identifier provided
     * does not exist or is not valid.<br/>
     * One common source of this error is providing a node account identifier
     * using the "alias" form rather than "numeric" form.
     */
    INVALID_NODE_ACCOUNT_ID(ResponseCodeEnum.INVALID_NODE_ACCOUNT_ID),

    /**
     * A transaction failed because the description field cannot be encoded
     * as UTF-8 or is more than 100 bytes when encoded.
     */
    INVALID_NODE_DESCRIPTION(ResponseCodeEnum.INVALID_NODE_DESCRIPTION),

    /**
     * A transaction failed because one or more entries in the list of
     * service endpoints for the `service_endpoint` field is invalid.<br/>
     * The most common cause for this response is a service endpoint that has
     * the domain name (DNS) set rather than address and port.
     */
    INVALID_SERVICE_ENDPOINT(ResponseCodeEnum.INVALID_SERVICE_ENDPOINT),

    /**
     * A transaction failed because the TLS certificate provided for the
     * node is missing or invalid.<br/>
     * The certificate MUST be a TLS certificate of a type permitted for gossip
     * signatures.<br/>
     * The value presented MUST be a UTF-8 NFKD encoding of the TLS
     * certificate.<br/>
     * The certificate encoded MUST be in PEM format.<br/>
     * The `gossip_ca_certificate` field is REQUIRED and MUST NOT be empty.
     */
    INVALID_GOSSIP_CA_CERTIFICATE(ResponseCodeEnum.INVALID_GOSSIP_CA_CERTIFICATE),

    /**
     * A transaction failed because the hash provided for the gRPC certificate
     * is present but invalid.<br/>
     * The `grpc_certificate_hash` MUST be a SHA-384 hash.<br/>
     * The input hashed MUST be a UTF-8 NFKD encoding of the actual TLS
     * certificate.<br/>
     * The certificate to be encoded MUST be in PEM format.
     */
    INVALID_GRPC_CERTIFICATE(ResponseCodeEnum.INVALID_GRPC_CERTIFICATE),

    /**
     * The maximum automatic associations value is not valid.<br/>
     * The most common cause for this error is a value less than `-1`.
     */
    INVALID_MAX_AUTO_ASSOCIATIONS(ResponseCodeEnum.INVALID_MAX_AUTO_ASSOCIATIONS),

    /**
     * The maximum number of nodes allowed in the address book have been created.
     */
    MAX_NODES_CREATED(ResponseCodeEnum.MAX_NODES_CREATED),

    /**
     * In ServiceEndpoint, domain_name and ipAddressV4 are mutually exclusive
     */
    IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT(ResponseCodeEnum.IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT),

    /**
     * Fully qualified domain name is not allowed in gossip_endpoint
     */
    GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN(ResponseCodeEnum.GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN),

    /**
     * In ServiceEndpoint, domain_name size too large
     */
    FQDN_SIZE_TOO_LARGE(ResponseCodeEnum.FQDN_SIZE_TOO_LARGE),

    /**
     * ServiceEndpoint is invalid
     */
    INVALID_ENDPOINT(ResponseCodeEnum.INVALID_ENDPOINT),

    /**
     * The number of gossip endpoints exceeds the limit
     */
    GOSSIP_ENDPOINTS_EXCEEDED_LIMIT(ResponseCodeEnum.GOSSIP_ENDPOINTS_EXCEEDED_LIMIT),

    /**
     * The transaction attempted to use duplicate `TokenReference`.<br/>
     * This affects `TokenReject` attempting to reject same token reference more than once.
     */
    TOKEN_REFERENCE_REPEATED(ResponseCodeEnum.TOKEN_REFERENCE_REPEATED),

    /**
     * The account id specified as the owner in `TokenReject` is invalid or does not exist.
     */
    INVALID_OWNER_ID(ResponseCodeEnum.INVALID_OWNER_ID),

    /**
     * The transaction attempted to use more than the allowed number of `TokenReference`.
     */
    TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED(ResponseCodeEnum.TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED),

    /**
     * The number of service endpoints exceeds the limit
     */
    SERVICE_ENDPOINTS_EXCEEDED_LIMIT(ResponseCodeEnum.SERVICE_ENDPOINTS_EXCEEDED_LIMIT),

    /**
     * The IPv4 address is invalid
     */
    INVALID_IPV4_ADDRESS(ResponseCodeEnum.INVALID_IPV4_ADDRESS),

    /**
     * The transaction attempted to use empty `TokenReference` list.
     */
    EMPTY_TOKEN_REFERENCE_LIST(ResponseCodeEnum.EMPTY_TOKEN_REFERENCE_LIST),

    /**
     * The node account is not allowed to be updated
     */
    UPDATE_NODE_ACCOUNT_NOT_ALLOWED(ResponseCodeEnum.UPDATE_NODE_ACCOUNT_NOT_ALLOWED),

    /**
     * The token has no metadata or supply key
     */
    TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY(ResponseCodeEnum.TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY),

    /**
     * The transaction attempted to the use an empty List of `PendingAirdropId`.
     */
    EMPTY_PENDING_AIRDROP_ID_LIST(ResponseCodeEnum.EMPTY_PENDING_AIRDROP_ID_LIST),

    /**
     * The transaction attempted to the same `PendingAirdropId` twice.
     */
    PENDING_AIRDROP_ID_REPEATED(ResponseCodeEnum.PENDING_AIRDROP_ID_REPEATED),

    /**
     * The transaction attempted to use more than the allowed number of `PendingAirdropId`.
     */
    PENDING_AIRDROP_ID_LIST_TOO_LONG(ResponseCodeEnum.PENDING_AIRDROP_ID_LIST_TOO_LONG),

    /**
     * A pending airdrop already exists for the specified NFT.
     */
    PENDING_NFT_AIRDROP_ALREADY_EXISTS(ResponseCodeEnum.PENDING_NFT_AIRDROP_ALREADY_EXISTS),

    /**
     * The identified account is sender for one or more pending airdrop(s)
     * and cannot be deleted.<br/>
     * Requester should cancel all pending airdrops before resending
     * this transaction.
     */
    ACCOUNT_HAS_PENDING_AIRDROPS(ResponseCodeEnum.ACCOUNT_HAS_PENDING_AIRDROPS),

    /**
     * Consensus throttle did not allow execution of this transaction.<br/>
     * The transaction should be retried after a modest delay.
     */
    THROTTLED_AT_CONSENSUS(ResponseCodeEnum.THROTTLED_AT_CONSENSUS),

    /**
     * The provided pending airdrop id is invalid.<br/>
     * This pending airdrop MAY already be claimed or cancelled.
     * <p>
     * The client SHOULD query a mirror node to determine the current status of
     * the pending airdrop.
     */
    INVALID_PENDING_AIRDROP_ID(ResponseCodeEnum.INVALID_PENDING_AIRDROP_ID),

    /**
     * The token to be airdropped has a fallback royalty fee and cannot be
     * sent or claimed via an airdrop transaction.
     */
    TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY(ResponseCodeEnum.TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY),

    /**
     * This airdrop claim is for a pending airdrop with an invalid token.<br/>
     * The token might be deleted, or the sender may not have enough tokens
     * to fulfill the offer.
     * <p>
     * The client SHOULD query mirror node to determine the status of the pending
     * airdrop and whether the sender can fulfill the offer.
     */
    INVALID_TOKEN_IN_PENDING_AIRDROP(ResponseCodeEnum.INVALID_TOKEN_IN_PENDING_AIRDROP);

    final ResponseCodeEnum code;

    Status(ResponseCodeEnum code) {
        this.code = code;
    }

    static Status valueOf(ResponseCodeEnum code) {
        return switch (code) {
            case OK -> OK;
            case INVALID_TRANSACTION -> INVALID_TRANSACTION;
            case PAYER_ACCOUNT_NOT_FOUND -> PAYER_ACCOUNT_NOT_FOUND;
            case INVALID_NODE_ACCOUNT -> INVALID_NODE_ACCOUNT;
            case TRANSACTION_EXPIRED -> TRANSACTION_EXPIRED;
            case INVALID_TRANSACTION_START -> INVALID_TRANSACTION_START;
            case INVALID_TRANSACTION_DURATION -> INVALID_TRANSACTION_DURATION;
            case INVALID_SIGNATURE -> INVALID_SIGNATURE;
            case MEMO_TOO_LONG -> MEMO_TOO_LONG;
            case INSUFFICIENT_TX_FEE -> INSUFFICIENT_TX_FEE;
            case INSUFFICIENT_PAYER_BALANCE -> INSUFFICIENT_PAYER_BALANCE;
            case DUPLICATE_TRANSACTION -> DUPLICATE_TRANSACTION;
            case BUSY -> BUSY;
            case NOT_SUPPORTED -> NOT_SUPPORTED;
            case INVALID_FILE_ID -> INVALID_FILE_ID;
            case INVALID_ACCOUNT_ID -> INVALID_ACCOUNT_ID;
            case INVALID_CONTRACT_ID -> INVALID_CONTRACT_ID;
            case INVALID_TRANSACTION_ID -> INVALID_TRANSACTION_ID;
            case RECEIPT_NOT_FOUND -> RECEIPT_NOT_FOUND;
            case RECORD_NOT_FOUND -> RECORD_NOT_FOUND;
            case INVALID_SOLIDITY_ID -> INVALID_SOLIDITY_ID;
            case UNKNOWN -> UNKNOWN;
            case SUCCESS -> SUCCESS;
            case FAIL_INVALID -> FAIL_INVALID;
            case FAIL_FEE -> FAIL_FEE;
            case FAIL_BALANCE -> FAIL_BALANCE;
            case KEY_REQUIRED -> KEY_REQUIRED;
            case BAD_ENCODING -> BAD_ENCODING;
            case INSUFFICIENT_ACCOUNT_BALANCE -> INSUFFICIENT_ACCOUNT_BALANCE;
            case INVALID_SOLIDITY_ADDRESS -> INVALID_SOLIDITY_ADDRESS;
            case INSUFFICIENT_GAS -> INSUFFICIENT_GAS;
            case CONTRACT_SIZE_LIMIT_EXCEEDED -> CONTRACT_SIZE_LIMIT_EXCEEDED;
            case LOCAL_CALL_MODIFICATION_EXCEPTION -> LOCAL_CALL_MODIFICATION_EXCEPTION;
            case CONTRACT_REVERT_EXECUTED -> CONTRACT_REVERT_EXECUTED;
            case CONTRACT_EXECUTION_EXCEPTION -> CONTRACT_EXECUTION_EXCEPTION;
            case INVALID_RECEIVING_NODE_ACCOUNT -> INVALID_RECEIVING_NODE_ACCOUNT;
            case MISSING_QUERY_HEADER -> MISSING_QUERY_HEADER;
            case ACCOUNT_UPDATE_FAILED -> ACCOUNT_UPDATE_FAILED;
            case INVALID_KEY_ENCODING -> INVALID_KEY_ENCODING;
            case NULL_SOLIDITY_ADDRESS -> NULL_SOLIDITY_ADDRESS;
            case CONTRACT_UPDATE_FAILED -> CONTRACT_UPDATE_FAILED;
            case INVALID_QUERY_HEADER -> INVALID_QUERY_HEADER;
            case INVALID_FEE_SUBMITTED -> INVALID_FEE_SUBMITTED;
            case INVALID_PAYER_SIGNATURE -> INVALID_PAYER_SIGNATURE;
            case KEY_NOT_PROVIDED -> KEY_NOT_PROVIDED;
            case INVALID_EXPIRATION_TIME -> INVALID_EXPIRATION_TIME;
            case NO_WACL_KEY -> NO_WACL_KEY;
            case FILE_CONTENT_EMPTY -> FILE_CONTENT_EMPTY;
            case INVALID_ACCOUNT_AMOUNTS -> INVALID_ACCOUNT_AMOUNTS;
            case EMPTY_TRANSACTION_BODY -> EMPTY_TRANSACTION_BODY;
            case INVALID_TRANSACTION_BODY -> INVALID_TRANSACTION_BODY;
            case INVALID_SIGNATURE_TYPE_MISMATCHING_KEY -> INVALID_SIGNATURE_TYPE_MISMATCHING_KEY;
            case INVALID_SIGNATURE_COUNT_MISMATCHING_KEY -> INVALID_SIGNATURE_COUNT_MISMATCHING_KEY;
            case EMPTY_LIVE_HASH_BODY -> EMPTY_LIVE_HASH_BODY;
            case EMPTY_LIVE_HASH -> EMPTY_LIVE_HASH;
            case EMPTY_LIVE_HASH_KEYS -> EMPTY_LIVE_HASH_KEYS;
            case INVALID_LIVE_HASH_SIZE -> INVALID_LIVE_HASH_SIZE;
            case EMPTY_QUERY_BODY -> EMPTY_QUERY_BODY;
            case EMPTY_LIVE_HASH_QUERY -> EMPTY_LIVE_HASH_QUERY;
            case LIVE_HASH_NOT_FOUND -> LIVE_HASH_NOT_FOUND;
            case ACCOUNT_ID_DOES_NOT_EXIST -> ACCOUNT_ID_DOES_NOT_EXIST;
            case LIVE_HASH_ALREADY_EXISTS -> LIVE_HASH_ALREADY_EXISTS;
            case INVALID_FILE_WACL -> INVALID_FILE_WACL;
            case SERIALIZATION_FAILED -> SERIALIZATION_FAILED;
            case TRANSACTION_OVERSIZE -> TRANSACTION_OVERSIZE;
            case TRANSACTION_TOO_MANY_LAYERS -> TRANSACTION_TOO_MANY_LAYERS;
            case CONTRACT_DELETED -> CONTRACT_DELETED;
            case PLATFORM_NOT_ACTIVE -> PLATFORM_NOT_ACTIVE;
            case KEY_PREFIX_MISMATCH -> KEY_PREFIX_MISMATCH;
            case PLATFORM_TRANSACTION_NOT_CREATED -> PLATFORM_TRANSACTION_NOT_CREATED;
            case INVALID_RENEWAL_PERIOD -> INVALID_RENEWAL_PERIOD;
            case INVALID_PAYER_ACCOUNT_ID -> INVALID_PAYER_ACCOUNT_ID;
            case ACCOUNT_DELETED -> ACCOUNT_DELETED;
            case FILE_DELETED -> FILE_DELETED;
            case ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS -> ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS;
            case SETTING_NEGATIVE_ACCOUNT_BALANCE -> SETTING_NEGATIVE_ACCOUNT_BALANCE;
            case OBTAINER_REQUIRED -> OBTAINER_REQUIRED;
            case OBTAINER_SAME_CONTRACT_ID -> OBTAINER_SAME_CONTRACT_ID;
            case OBTAINER_DOES_NOT_EXIST -> OBTAINER_DOES_NOT_EXIST;
            case MODIFYING_IMMUTABLE_CONTRACT -> MODIFYING_IMMUTABLE_CONTRACT;
            case FILE_SYSTEM_EXCEPTION -> FILE_SYSTEM_EXCEPTION;
            case AUTORENEW_DURATION_NOT_IN_RANGE -> AUTORENEW_DURATION_NOT_IN_RANGE;
            case ERROR_DECODING_BYTESTRING -> ERROR_DECODING_BYTESTRING;
            case CONTRACT_FILE_EMPTY -> CONTRACT_FILE_EMPTY;
            case CONTRACT_BYTECODE_EMPTY -> CONTRACT_BYTECODE_EMPTY;
            case INVALID_INITIAL_BALANCE -> INVALID_INITIAL_BALANCE;
            case INVALID_RECEIVE_RECORD_THRESHOLD -> INVALID_RECEIVE_RECORD_THRESHOLD;
            case INVALID_SEND_RECORD_THRESHOLD -> INVALID_SEND_RECORD_THRESHOLD;
            case ACCOUNT_IS_NOT_GENESIS_ACCOUNT -> ACCOUNT_IS_NOT_GENESIS_ACCOUNT;
            case PAYER_ACCOUNT_UNAUTHORIZED -> PAYER_ACCOUNT_UNAUTHORIZED;
            case INVALID_FREEZE_TRANSACTION_BODY -> INVALID_FREEZE_TRANSACTION_BODY;
            case FREEZE_TRANSACTION_BODY_NOT_FOUND -> FREEZE_TRANSACTION_BODY_NOT_FOUND;
            case TRANSFER_LIST_SIZE_LIMIT_EXCEEDED -> TRANSFER_LIST_SIZE_LIMIT_EXCEEDED;
            case RESULT_SIZE_LIMIT_EXCEEDED -> RESULT_SIZE_LIMIT_EXCEEDED;
            case NOT_SPECIAL_ACCOUNT -> NOT_SPECIAL_ACCOUNT;
            case CONTRACT_NEGATIVE_GAS -> CONTRACT_NEGATIVE_GAS;
            case CONTRACT_NEGATIVE_VALUE -> CONTRACT_NEGATIVE_VALUE;
            case INVALID_FEE_FILE -> INVALID_FEE_FILE;
            case INVALID_EXCHANGE_RATE_FILE -> INVALID_EXCHANGE_RATE_FILE;
            case INSUFFICIENT_LOCAL_CALL_GAS -> INSUFFICIENT_LOCAL_CALL_GAS;
            case ENTITY_NOT_ALLOWED_TO_DELETE -> ENTITY_NOT_ALLOWED_TO_DELETE;
            case AUTHORIZATION_FAILED -> AUTHORIZATION_FAILED;
            case FILE_UPLOADED_PROTO_INVALID -> FILE_UPLOADED_PROTO_INVALID;
            case FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK -> FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK;
            case FEE_SCHEDULE_FILE_PART_UPLOADED -> FEE_SCHEDULE_FILE_PART_UPLOADED;
            case EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED -> EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED;
            case MAX_CONTRACT_STORAGE_EXCEEDED -> MAX_CONTRACT_STORAGE_EXCEEDED;
            case TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT -> TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT;
            case TOTAL_LEDGER_BALANCE_INVALID -> TOTAL_LEDGER_BALANCE_INVALID;
            case EXPIRATION_REDUCTION_NOT_ALLOWED -> EXPIRATION_REDUCTION_NOT_ALLOWED;
            case MAX_GAS_LIMIT_EXCEEDED -> MAX_GAS_LIMIT_EXCEEDED;
            case MAX_FILE_SIZE_EXCEEDED -> MAX_FILE_SIZE_EXCEEDED;
            case RECEIVER_SIG_REQUIRED -> RECEIVER_SIG_REQUIRED;
            case INVALID_TOPIC_ID -> INVALID_TOPIC_ID;
            case INVALID_ADMIN_KEY -> INVALID_ADMIN_KEY;
            case INVALID_SUBMIT_KEY -> INVALID_SUBMIT_KEY;
            case UNAUTHORIZED -> UNAUTHORIZED;
            case INVALID_TOPIC_MESSAGE -> INVALID_TOPIC_MESSAGE;
            case INVALID_AUTORENEW_ACCOUNT -> INVALID_AUTORENEW_ACCOUNT;
            case AUTORENEW_ACCOUNT_NOT_ALLOWED -> AUTORENEW_ACCOUNT_NOT_ALLOWED;
            case TOPIC_EXPIRED -> TOPIC_EXPIRED;
            case INVALID_CHUNK_NUMBER -> INVALID_CHUNK_NUMBER;
            case INVALID_CHUNK_TRANSACTION_ID -> INVALID_CHUNK_TRANSACTION_ID;
            case ACCOUNT_FROZEN_FOR_TOKEN -> ACCOUNT_FROZEN_FOR_TOKEN;
            case TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED -> TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED;
            case INVALID_TOKEN_ID -> INVALID_TOKEN_ID;
            case INVALID_TOKEN_DECIMALS -> INVALID_TOKEN_DECIMALS;
            case INVALID_TOKEN_INITIAL_SUPPLY -> INVALID_TOKEN_INITIAL_SUPPLY;
            case INVALID_TREASURY_ACCOUNT_FOR_TOKEN -> INVALID_TREASURY_ACCOUNT_FOR_TOKEN;
            case INVALID_TOKEN_SYMBOL -> INVALID_TOKEN_SYMBOL;
            case TOKEN_HAS_NO_FREEZE_KEY -> TOKEN_HAS_NO_FREEZE_KEY;
            case TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN -> TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN;
            case MISSING_TOKEN_SYMBOL -> MISSING_TOKEN_SYMBOL;
            case TOKEN_SYMBOL_TOO_LONG -> TOKEN_SYMBOL_TOO_LONG;
            case ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN -> ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN;
            case TOKEN_HAS_NO_KYC_KEY -> TOKEN_HAS_NO_KYC_KEY;
            case INSUFFICIENT_TOKEN_BALANCE -> INSUFFICIENT_TOKEN_BALANCE;
            case TOKEN_WAS_DELETED -> TOKEN_WAS_DELETED;
            case TOKEN_HAS_NO_SUPPLY_KEY -> TOKEN_HAS_NO_SUPPLY_KEY;
            case TOKEN_HAS_NO_WIPE_KEY -> TOKEN_HAS_NO_WIPE_KEY;
            case INVALID_TOKEN_MINT_AMOUNT -> INVALID_TOKEN_MINT_AMOUNT;
            case INVALID_TOKEN_BURN_AMOUNT -> INVALID_TOKEN_BURN_AMOUNT;
            case TOKEN_NOT_ASSOCIATED_TO_ACCOUNT -> TOKEN_NOT_ASSOCIATED_TO_ACCOUNT;
            case CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT -> CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT;
            case INVALID_KYC_KEY -> INVALID_KYC_KEY;
            case INVALID_WIPE_KEY -> INVALID_WIPE_KEY;
            case INVALID_FREEZE_KEY -> INVALID_FREEZE_KEY;
            case INVALID_SUPPLY_KEY -> INVALID_SUPPLY_KEY;
            case MISSING_TOKEN_NAME -> MISSING_TOKEN_NAME;
            case TOKEN_NAME_TOO_LONG -> TOKEN_NAME_TOO_LONG;
            case INVALID_WIPING_AMOUNT -> INVALID_WIPING_AMOUNT;
            case TOKEN_IS_IMMUTABLE -> TOKEN_IS_IMMUTABLE;
            case TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT -> TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT;
            case TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES -> TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES;
            case ACCOUNT_IS_TREASURY -> ACCOUNT_IS_TREASURY;
            case TOKEN_ID_REPEATED_IN_TOKEN_LIST -> TOKEN_ID_REPEATED_IN_TOKEN_LIST;
            case TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED -> TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED;
            case EMPTY_TOKEN_TRANSFER_BODY -> EMPTY_TOKEN_TRANSFER_BODY;
            case EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS -> EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS;
            case INVALID_SCHEDULE_ID -> INVALID_SCHEDULE_ID;
            case SCHEDULE_IS_IMMUTABLE -> SCHEDULE_IS_IMMUTABLE;
            case INVALID_SCHEDULE_PAYER_ID -> INVALID_SCHEDULE_PAYER_ID;
            case INVALID_SCHEDULE_ACCOUNT_ID -> INVALID_SCHEDULE_ACCOUNT_ID;
            case NO_NEW_VALID_SIGNATURES -> NO_NEW_VALID_SIGNATURES;
            case UNRESOLVABLE_REQUIRED_SIGNERS -> UNRESOLVABLE_REQUIRED_SIGNERS;
            case SCHEDULED_TRANSACTION_NOT_IN_WHITELIST -> SCHEDULED_TRANSACTION_NOT_IN_WHITELIST;
            case SOME_SIGNATURES_WERE_INVALID -> SOME_SIGNATURES_WERE_INVALID;
            case TRANSACTION_ID_FIELD_NOT_ALLOWED -> TRANSACTION_ID_FIELD_NOT_ALLOWED;
            case IDENTICAL_SCHEDULE_ALREADY_CREATED -> IDENTICAL_SCHEDULE_ALREADY_CREATED;
            case INVALID_ZERO_BYTE_IN_STRING -> INVALID_ZERO_BYTE_IN_STRING;
            case SCHEDULE_ALREADY_DELETED -> SCHEDULE_ALREADY_DELETED;
            case SCHEDULE_ALREADY_EXECUTED -> SCHEDULE_ALREADY_EXECUTED;
            case MESSAGE_SIZE_TOO_LARGE -> MESSAGE_SIZE_TOO_LARGE;
            case OPERATION_REPEATED_IN_BUCKET_GROUPS -> OPERATION_REPEATED_IN_BUCKET_GROUPS;
            case BUCKET_CAPACITY_OVERFLOW -> BUCKET_CAPACITY_OVERFLOW;
            case NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION -> NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION;
            case BUCKET_HAS_NO_THROTTLE_GROUPS -> BUCKET_HAS_NO_THROTTLE_GROUPS;
            case THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC -> THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC;
            case SUCCESS_BUT_MISSING_EXPECTED_OPERATION -> SUCCESS_BUT_MISSING_EXPECTED_OPERATION;
            case UNPARSEABLE_THROTTLE_DEFINITIONS -> UNPARSEABLE_THROTTLE_DEFINITIONS;
            case INVALID_THROTTLE_DEFINITIONS -> INVALID_THROTTLE_DEFINITIONS;
            case ACCOUNT_EXPIRED_AND_PENDING_REMOVAL -> ACCOUNT_EXPIRED_AND_PENDING_REMOVAL;
            case INVALID_TOKEN_MAX_SUPPLY -> INVALID_TOKEN_MAX_SUPPLY;
            case INVALID_TOKEN_NFT_SERIAL_NUMBER -> INVALID_TOKEN_NFT_SERIAL_NUMBER;
            case INVALID_NFT_ID -> INVALID_NFT_ID;
            case METADATA_TOO_LONG -> METADATA_TOO_LONG;
            case BATCH_SIZE_LIMIT_EXCEEDED -> BATCH_SIZE_LIMIT_EXCEEDED;
            case INVALID_QUERY_RANGE -> INVALID_QUERY_RANGE;
            case FRACTION_DIVIDES_BY_ZERO -> FRACTION_DIVIDES_BY_ZERO;
            case INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE -> INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE;
            case CUSTOM_FEES_LIST_TOO_LONG -> CUSTOM_FEES_LIST_TOO_LONG;
            case INVALID_CUSTOM_FEE_COLLECTOR -> INVALID_CUSTOM_FEE_COLLECTOR;
            case INVALID_TOKEN_ID_IN_CUSTOM_FEES -> INVALID_TOKEN_ID_IN_CUSTOM_FEES;
            case TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR -> TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR;
            case TOKEN_MAX_SUPPLY_REACHED -> TOKEN_MAX_SUPPLY_REACHED;
            case SENDER_DOES_NOT_OWN_NFT_SERIAL_NO -> SENDER_DOES_NOT_OWN_NFT_SERIAL_NO;
            case CUSTOM_FEE_NOT_FULLY_SPECIFIED -> CUSTOM_FEE_NOT_FULLY_SPECIFIED;
            case CUSTOM_FEE_MUST_BE_POSITIVE -> CUSTOM_FEE_MUST_BE_POSITIVE;
            case TOKEN_HAS_NO_FEE_SCHEDULE_KEY -> TOKEN_HAS_NO_FEE_SCHEDULE_KEY;
            case CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE -> CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE;
            case ROYALTY_FRACTION_CANNOT_EXCEED_ONE -> ROYALTY_FRACTION_CANNOT_EXCEED_ONE;
            case FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT -> FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT;
            case CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES -> CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES;
            case CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON -> CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON;
            case CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON -> CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON;
            case INVALID_CUSTOM_FEE_SCHEDULE_KEY -> INVALID_CUSTOM_FEE_SCHEDULE_KEY;
            case INVALID_TOKEN_MINT_METADATA -> INVALID_TOKEN_MINT_METADATA;
            case INVALID_TOKEN_BURN_METADATA -> INVALID_TOKEN_BURN_METADATA;
            case CURRENT_TREASURY_STILL_OWNS_NFTS -> CURRENT_TREASURY_STILL_OWNS_NFTS;
            case ACCOUNT_STILL_OWNS_NFTS -> ACCOUNT_STILL_OWNS_NFTS;
            case TREASURY_MUST_OWN_BURNED_NFT -> TREASURY_MUST_OWN_BURNED_NFT;
            case ACCOUNT_DOES_NOT_OWN_WIPED_NFT -> ACCOUNT_DOES_NOT_OWN_WIPED_NFT;
            case ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON -> ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON;
            case MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED -> MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED;
            case PAYER_ACCOUNT_DELETED -> PAYER_ACCOUNT_DELETED;
            case CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH -> CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH;
            case CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS -> CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS;
            case INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE -> INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE;
            case SERIAL_NUMBER_LIMIT_REACHED -> SERIAL_NUMBER_LIMIT_REACHED;
            case CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE -> CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE;
            case NO_REMAINING_AUTOMATIC_ASSOCIATIONS -> NO_REMAINING_AUTOMATIC_ASSOCIATIONS;
            case EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT -> EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT;
            case REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT -> REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT;
            case TOKEN_IS_PAUSED -> TOKEN_IS_PAUSED;
            case TOKEN_HAS_NO_PAUSE_KEY -> TOKEN_HAS_NO_PAUSE_KEY;
            case INVALID_PAUSE_KEY -> INVALID_PAUSE_KEY;
            case FREEZE_UPDATE_FILE_DOES_NOT_EXIST -> FREEZE_UPDATE_FILE_DOES_NOT_EXIST;
            case FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH -> FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH;
            case NO_UPGRADE_HAS_BEEN_PREPARED -> NO_UPGRADE_HAS_BEEN_PREPARED;
            case NO_FREEZE_IS_SCHEDULED -> NO_FREEZE_IS_SCHEDULED;
            case UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE -> UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE;
            case FREEZE_START_TIME_MUST_BE_FUTURE -> FREEZE_START_TIME_MUST_BE_FUTURE;
            case PREPARED_UPDATE_FILE_IS_IMMUTABLE -> PREPARED_UPDATE_FILE_IS_IMMUTABLE;
            case FREEZE_ALREADY_SCHEDULED -> FREEZE_ALREADY_SCHEDULED;
            case FREEZE_UPGRADE_IN_PROGRESS -> FREEZE_UPGRADE_IN_PROGRESS;
            case UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED -> UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED;
            case UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED -> UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED;
            case CONSENSUS_GAS_EXHAUSTED -> CONSENSUS_GAS_EXHAUSTED;
            case REVERTED_SUCCESS -> REVERTED_SUCCESS;
            case MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED -> MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED;
            case INVALID_ALIAS_KEY -> INVALID_ALIAS_KEY;
            case UNEXPECTED_TOKEN_DECIMALS -> UNEXPECTED_TOKEN_DECIMALS;
            case INVALID_PROXY_ACCOUNT_ID -> INVALID_PROXY_ACCOUNT_ID;
            case INVALID_TRANSFER_ACCOUNT_ID -> INVALID_TRANSFER_ACCOUNT_ID;
            case INVALID_FEE_COLLECTOR_ACCOUNT_ID -> INVALID_FEE_COLLECTOR_ACCOUNT_ID;
            case ALIAS_IS_IMMUTABLE -> ALIAS_IS_IMMUTABLE;
            case SPENDER_ACCOUNT_SAME_AS_OWNER -> SPENDER_ACCOUNT_SAME_AS_OWNER;
            case AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY -> AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY;
            case NEGATIVE_ALLOWANCE_AMOUNT -> NEGATIVE_ALLOWANCE_AMOUNT;
            case CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON -> CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON;
            case SPENDER_DOES_NOT_HAVE_ALLOWANCE -> SPENDER_DOES_NOT_HAVE_ALLOWANCE;
            case AMOUNT_EXCEEDS_ALLOWANCE -> AMOUNT_EXCEEDS_ALLOWANCE;
            case MAX_ALLOWANCES_EXCEEDED -> MAX_ALLOWANCES_EXCEEDED;
            case EMPTY_ALLOWANCES -> EMPTY_ALLOWANCES;
            case SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES -> SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES;
            case REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES -> REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES;
            case FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES -> FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES;
            case NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES -> NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES;
            case INVALID_ALLOWANCE_OWNER_ID -> INVALID_ALLOWANCE_OWNER_ID;
            case INVALID_ALLOWANCE_SPENDER_ID -> INVALID_ALLOWANCE_SPENDER_ID;
            case REPEATED_ALLOWANCES_TO_DELETE -> REPEATED_ALLOWANCES_TO_DELETE;
            case INVALID_DELEGATING_SPENDER -> INVALID_DELEGATING_SPENDER;
            case DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL -> DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL;
            case DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL -> DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL;
            case SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE -> SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE;
            case SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME -> SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME;
            case SCHEDULE_FUTURE_THROTTLE_EXCEEDED -> SCHEDULE_FUTURE_THROTTLE_EXCEEDED;
            case SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED -> SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED;
            case INVALID_ETHEREUM_TRANSACTION -> INVALID_ETHEREUM_TRANSACTION;
            case WRONG_CHAIN_ID -> WRONG_CHAIN_ID;
            case WRONG_NONCE -> WRONG_NONCE;
            case ACCESS_LIST_UNSUPPORTED -> ACCESS_LIST_UNSUPPORTED;
            case SCHEDULE_PENDING_EXPIRATION -> SCHEDULE_PENDING_EXPIRATION;
            case CONTRACT_IS_TOKEN_TREASURY -> CONTRACT_IS_TOKEN_TREASURY;
            case CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES -> CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES;
            case CONTRACT_EXPIRED_AND_PENDING_REMOVAL -> CONTRACT_EXPIRED_AND_PENDING_REMOVAL;
            case CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT -> CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT;
            case PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION -> PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION;
            case PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED -> PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED;
            case SELF_STAKING_IS_NOT_ALLOWED -> SELF_STAKING_IS_NOT_ALLOWED;
            case INVALID_STAKING_ID -> INVALID_STAKING_ID;
            case STAKING_NOT_ENABLED -> STAKING_NOT_ENABLED;
            case INVALID_PRNG_RANGE -> INVALID_PRNG_RANGE;
            case MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED -> MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED;
            case INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE -> INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE;
            case INSUFFICIENT_BALANCES_FOR_STORAGE_RENT -> INSUFFICIENT_BALANCES_FOR_STORAGE_RENT;
            case MAX_CHILD_RECORDS_EXCEEDED -> MAX_CHILD_RECORDS_EXCEEDED;
            case INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES -> INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES;
            case TRANSACTION_HAS_UNKNOWN_FIELDS -> TRANSACTION_HAS_UNKNOWN_FIELDS;
            case ACCOUNT_IS_IMMUTABLE -> ACCOUNT_IS_IMMUTABLE;
            case ALIAS_ALREADY_ASSIGNED -> ALIAS_ALREADY_ASSIGNED;
            case INVALID_METADATA_KEY -> INVALID_METADATA_KEY;
            case TOKEN_HAS_NO_METADATA_KEY -> TOKEN_HAS_NO_METADATA_KEY;
            case MISSING_TOKEN_METADATA -> MISSING_TOKEN_METADATA;
            case MISSING_SERIAL_NUMBERS -> MISSING_SERIAL_NUMBERS;
            case TOKEN_HAS_NO_ADMIN_KEY -> TOKEN_HAS_NO_ADMIN_KEY;
            case NODE_DELETED -> NODE_DELETED;
            case INVALID_NODE_ID -> INVALID_NODE_ID;
            case INVALID_GOSSIP_ENDPOINT -> INVALID_GOSSIP_ENDPOINT;
            case INVALID_NODE_ACCOUNT_ID -> INVALID_NODE_ACCOUNT_ID;
            case INVALID_NODE_DESCRIPTION -> INVALID_NODE_DESCRIPTION;
            case INVALID_SERVICE_ENDPOINT -> INVALID_SERVICE_ENDPOINT;
            case INVALID_GOSSIP_CA_CERTIFICATE -> INVALID_GOSSIP_CA_CERTIFICATE;
            case INVALID_GRPC_CERTIFICATE -> INVALID_GRPC_CERTIFICATE;
            case INVALID_MAX_AUTO_ASSOCIATIONS -> INVALID_MAX_AUTO_ASSOCIATIONS;
            case MAX_NODES_CREATED -> MAX_NODES_CREATED;
            case IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT -> IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT;
            case GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN -> GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN;
            case FQDN_SIZE_TOO_LARGE -> FQDN_SIZE_TOO_LARGE;
            case INVALID_ENDPOINT -> INVALID_ENDPOINT;
            case GOSSIP_ENDPOINTS_EXCEEDED_LIMIT -> GOSSIP_ENDPOINTS_EXCEEDED_LIMIT;
            case TOKEN_REFERENCE_REPEATED -> TOKEN_REFERENCE_REPEATED;
            case INVALID_OWNER_ID -> INVALID_OWNER_ID;
            case TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED -> TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED;
            case SERVICE_ENDPOINTS_EXCEEDED_LIMIT -> SERVICE_ENDPOINTS_EXCEEDED_LIMIT;
            case INVALID_IPV4_ADDRESS -> INVALID_IPV4_ADDRESS;
            case EMPTY_TOKEN_REFERENCE_LIST -> EMPTY_TOKEN_REFERENCE_LIST;
            case UPDATE_NODE_ACCOUNT_NOT_ALLOWED -> UPDATE_NODE_ACCOUNT_NOT_ALLOWED;
            case TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY -> TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY;
            case EMPTY_PENDING_AIRDROP_ID_LIST -> EMPTY_PENDING_AIRDROP_ID_LIST;
            case PENDING_AIRDROP_ID_REPEATED -> PENDING_AIRDROP_ID_REPEATED;
            case PENDING_AIRDROP_ID_LIST_TOO_LONG -> PENDING_AIRDROP_ID_LIST_TOO_LONG;
            case PENDING_NFT_AIRDROP_ALREADY_EXISTS -> PENDING_NFT_AIRDROP_ALREADY_EXISTS;
            case ACCOUNT_HAS_PENDING_AIRDROPS -> ACCOUNT_HAS_PENDING_AIRDROPS;
            case THROTTLED_AT_CONSENSUS -> THROTTLED_AT_CONSENSUS;
            case INVALID_PENDING_AIRDROP_ID -> INVALID_PENDING_AIRDROP_ID;
            case TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY -> TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY;
            case INVALID_TOKEN_IN_PENDING_AIRDROP -> INVALID_TOKEN_IN_PENDING_AIRDROP;
            case UNRECOGNIZED ->
                // NOTE: Protobuf deserialization will not give us the code on the wire
                throw new IllegalArgumentException(
                    "network returned unrecognized response code; your SDK may be out of date");
        };
    }

    public static Status fromResponseCode(int reponseCode) {
        return Status.valueOf(Objects.requireNonNull(ResponseCodeEnum.forNumber(reponseCode)));
    }

    public int toResponseCode() {
        return code.getNumber();
    }

    @Override
    public String toString() {
        return code.name();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/StorageChange.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.InvalidProtocolBufferException;

import javax.annotation.Nullable;
import java.math.BigInteger;

/**
 * @deprecated - User mirror nodes for contract traceability instead
 *
 * A storage slot change description.
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/smart-contracts/contractcalllocal#storagechange">Hedera Documentation</a>
 */
@Deprecated
public class StorageChange {
    /**
     * The storage slot changed. Up to 32 bytes, big-endian, zero bytes left trimmed
     */
    public final BigInteger slot;
    /**
     * The value read from the storage slot. Up to 32 bytes, big-endian, zero
     * bytes left trimmed. Because of the way SSTORE operations are charged
     * the slot is always read before being written to
     */
    public final BigInteger valueRead;
    /**
     * The new value written to the slot. Up to 32 bytes, big-endian, zero
     * bytes left trimmed. If a value of zero is written the valueWritten
     * will be present but the inner value will be absent. If a value was
     * read and not written this value will not be present.
     */
    @Nullable
    public final BigInteger valueWritten;

    /**
     * Constructor.
     *
     * @param slot                      the storage slot charged
     * @param valueRead                 the value read
     * @param valueWritten              the value written
     */
    StorageChange(BigInteger slot, BigInteger valueRead, @Nullable BigInteger valueWritten) {
        this.slot = slot;
        this.valueRead = valueRead;
        this.valueWritten = valueWritten;
    }

    // /**
    //  * Create a storage charge from a protobuf.
    //  *
    //  * @param storageChangeProto        the protobuf
    //  * @return                          the new storage charge object
    //  */
    // static StorageChange fromProtobuf(com.hedera.hashgraph.sdk.proto.StorageChange storageChangeProto) {
    //     return new StorageChange(
    //         new BigInteger(storageChangeProto.getSlot().toByteArray()),
    //         new BigInteger(storageChangeProto.getValueRead().toByteArray()),
    //         storageChangeProto.hasValueWritten() ? (
    //             storageChangeProto.getValueWritten().getValue().size() == 0 ?
    //                 BigInteger.ZERO :
    //                 new BigInteger(storageChangeProto.getValueWritten().getValue().toByteArray())
    //         ) : null
    //     );
    // }
    //
    // /**
    //  * Create a storage charge from a byte array.
    //  *
    //  * @param bytes                     the byte array
    //  * @return                          the new storage charge object
    //  * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
    //  */
    // public static StorageChange fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
    //     return fromProtobuf(com.hedera.hashgraph.sdk.proto.StorageChange.parseFrom(bytes));
    // }
    //
    // /**
    //  * Create the byte array.
    //  *
    //  * @return                          the byte array representation
    //  */
    // com.hedera.hashgraph.sdk.proto.StorageChange toProtobuf() {
    //     var builder = com.hedera.hashgraph.sdk.proto.StorageChange.newBuilder()
    //         .setSlot(ByteString.copyFrom(slot.toByteArray()))
    //         .setValueRead(ByteString.copyFrom(valueRead.toByteArray()));
    //     if (valueWritten != null) {
    //         if (valueWritten.equals(BigInteger.ZERO)) {
    //             builder.setValueWritten(BytesValue.newBuilder().setValue(ByteString.EMPTY).build());
    //         } else {
    //             builder.setValueWritten(BytesValue.newBuilder().setValue(ByteString.copyFrom(valueWritten.toByteArray())).build());
    //         }
    //     }
    //     return builder.build();
    // }
    //
    // /**
    //  * Create the byte array.
    //  *
    //  * @return                          the byte array representation
    //  */
    // public byte[] toBytes() {
    //     return toProtobuf().toByteArray();
    // }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/SubscriptionHandle.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import javax.annotation.Nullable;

/**
 * Subscribe to a topic ID's messages from a mirror node. You will receive
 * all messages for the specified topic or within the defined start and end
 * time.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/consensus/get-topic-message">Hedera Documentation</a>
 */
public final class SubscriptionHandle {
    @Nullable
    private Runnable onUnsubscribe;

    /**
     * Constructor.
     */
    SubscriptionHandle() {
    }

    /**
     * Assign the callback method.
     *
     * @param onUnsubscribe             the callback method
     */
    void setOnUnsubscribe(Runnable onUnsubscribe) {
        this.onUnsubscribe = onUnsubscribe;
    }

    /**
     * Call the callback.
     */
    public void unsubscribe() {
        var unsubscribe = this.onUnsubscribe;

        // Set onUnsubscribe back to null to make sure it is run just once.
        this.onUnsubscribe = null;

        if (unsubscribe != null) {
            unsubscribe.run();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/SystemDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SystemDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Delete a file or smart contract - can only be done with a Hedera admin.
 * <p>
 * When it is deleted, it immediately disappears from the system as seen by the user,
 * but is still stored internally until the expiration time, at which time it
 * is truly and permanently deleted.
 * <p>
 * Until that time, it can be undeleted by the Hedera admin.
 * When a smart contract is deleted, the cryptocurrency account within it continues
 * to exist, and is not affected by the expiration time here.
 */
public final class SystemDeleteTransaction extends Transaction<SystemDeleteTransaction> {
    @Nullable
    private FileId fileId = null;
    @Nullable
    private ContractId contractId = null;
    @Nullable
    private Instant expirationTime = null;

    /**
     * Constructor.
     */
    public SystemDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    SystemDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    SystemDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public final FileId getFileId() {
        return fileId;
    }

    /**
     * Sets the file ID to delete.
     * <p>
     * Mutually exclusive with {@link #setContractId(ContractId)}.
     *
     * @param fileId The FileId to be set
     * @return {@code this}
     */
    public SystemDeleteTransaction setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        requireNotFrozen();
        this.fileId = fileId;
        return this;
    }

    /**
     * Extract the contract id.
     *
     * @return                          the contract id
     */
    @Nullable
    public final ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract ID to delete.
     * <p>
     * Mutually exclusive with {@link #setFileId(FileId)}.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public SystemDeleteTransaction setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        requireNotFrozen();
        this.contractId = contractId;
        return this;
    }

    /**
     * Extract the expiration time.
     *
     * @return                          the expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Sets the timestamp at which the "deleted" file should
     * truly be permanently deleted.
     *
     * @param expirationTime The Instant to be set as expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public SystemDeleteTransaction setExpirationTime(Instant expirationTime) {
        Objects.requireNonNull(expirationTime);
        requireNotFrozen();

        this.expirationTime = expirationTime;

        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.SystemDeleteTransactionBody}
     */
    SystemDeleteTransactionBody.Builder build() {
        var builder = SystemDeleteTransactionBody.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }
        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toSecondsProtobuf(expirationTime));
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getSystemDelete();
        if (body.hasFileID()) {
            fileId = FileId.fromProtobuf(body.getFileID());
        }
        if (body.hasContractID()) {
            contractId = ContractId.fromProtobuf(body.getContractID());
        }
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }

        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    CompletableFuture<Void> onExecuteAsync(Client client) {
        int modesEnabled = (fileId != null ? 1 : 0) + (contractId != null ? 1 : 0);
        if (modesEnabled != 1) {
            throw new IllegalStateException("SystemDeleteTransaction must have exactly 1 of the following fields set: contractId, fileId");
        }
        return super.onExecuteAsync(client);
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        if (fileId != null) {
            return FileServiceGrpc.getSystemDeleteMethod();
        } else {
            return SmartContractServiceGrpc.getSystemDeleteMethod();
        }
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setSystemDelete(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setSystemDelete(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/SystemUndeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SystemUndeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.LinkedHashMap;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Undelete a file or smart contract that was deleted by AdminDelete.
 * <p>
 * Can only be done with a Hedera admin.
 */
public final class SystemUndeleteTransaction extends Transaction<SystemUndeleteTransaction> {
    @Nullable
    private FileId fileId;
    @Nullable
    private ContractId contractId;

    /**
     * Constructor.
     */
    public SystemUndeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    SystemUndeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    SystemUndeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the file id.
     *
     * @return                          the file id
     */
    @Nullable
    public final FileId getFileId() {
        return fileId;
    }

    /**
     * Sets the file ID to undelete.
     * <p>
     * Mutually exclusive with {@link #setContractId(ContractId)}.
     *
     * @param fileId The FileId to be set
     * @return {@code this}
     */
    public final SystemUndeleteTransaction setFileId(FileId fileId) {
        Objects.requireNonNull(fileId);
        requireNotFrozen();
        this.fileId = fileId;
        return this;
    }

    /**
     * The contract ID instance to undelete, in the format used in transactions
     *
     * @return the contractId
     */
    @Nullable
    public ContractId getContractId() {
        return contractId;
    }

    /**
     * Sets the contract ID to undelete.
     * <p>
     * Mutually exclusive with {@link #setFileId(FileId)}.
     *
     * @param contractId The ContractId to be set
     * @return {@code this}
     */
    public final SystemUndeleteTransaction setContractId(ContractId contractId) {
        Objects.requireNonNull(contractId);
        requireNotFrozen();
        this.contractId = contractId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getSystemUndelete();
        if (body.hasFileID()) {
            fileId = FileId.fromProtobuf(body.getFileID());
        }
        if (body.hasContractID()) {
            contractId = ContractId.fromProtobuf(body.getContractID());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.SystemUndeleteTransactionBody}
     */
    SystemUndeleteTransactionBody.Builder build() {
        var builder = SystemUndeleteTransactionBody.newBuilder();
        if (fileId != null) {
            builder.setFileID(fileId.toProtobuf());
        }
        if (contractId != null) {
            builder.setContractID(contractId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (fileId != null) {
            fileId.validateChecksum(client);
        }

        if (contractId != null) {
            contractId.validateChecksum(client);
        }
    }

    @Override
    CompletableFuture<Void> onExecuteAsync(Client client) {
        int modesEnabled = (fileId != null ? 1 : 0) + (contractId != null ? 1 : 0);
        if (modesEnabled != 1) {
            throw new IllegalStateException("SystemDeleteTransaction must have exactly 1 of the following fields set: contractId, fileId");
        }
        return super.onExecuteAsync(client);
    }


    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        if (fileId != null) {
            return FileServiceGrpc.getSystemUndeleteMethod();
        } else {
            return SmartContractServiceGrpc.getSystemUndeleteMethod();
        }
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setSystemUndelete(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setSystemUndelete(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/ThreadLocalSecureRandom.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.security.SecureRandom;

/**
 * Internal utility class.
 */
final class ThreadLocalSecureRandom {
    @SuppressWarnings("AnonymousHasLambdaAlternative")
    private static final ThreadLocal<SecureRandom> secureRandom =
        new ThreadLocal<SecureRandom>() {
            @Override
            protected SecureRandom initialValue() {
                return new SecureRandom();
            }
        };

    /**
     * Constructor.
     */
    private ThreadLocalSecureRandom() {
    }

    /**
     * Extract seme randomness.
     *
     * @return                          some randomness
     */
    static SecureRandom current() {
        return secureRandom.get();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenAirdropTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenAirdropTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.LinkedHashMap;

/**
 * Token Airdrop
 * An "airdrop" is a distribution of tokens from a funding account
 * to one or more recipient accounts, ideally with no action required
 * by the recipient account(s).
 */
public class TokenAirdropTransaction extends AbstractTokenTransferTransaction<TokenAirdropTransaction> {
    /**
     * Constructor.
     */
    public TokenAirdropTransaction() {
        super();
        defaultMaxTransactionFee = new Hbar(1);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenAirdropTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenAirdropTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenAirdropTransactionBody}
     */
    TokenAirdropTransactionBody.Builder build() {
        var transfers = sortTransfersAndBuild();
        var builder = TokenAirdropTransactionBody.newBuilder();

        for (var transfer : transfers) {
            builder.addTokenTransfers(transfer.toProtobuf());
        }

        return builder;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getAirdropTokensMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenAirdrop(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenAirdrop(build());
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenAirdrop();

        for (var tokenTransferList : body.getTokenTransfersList()) {
            var token = TokenId.fromProtobuf(tokenTransferList.getToken());

            for (var transfer : tokenTransferList.getTransfersList()) {
                tokenTransfers.add(new TokenTransfer(
                    token,
                    AccountId.fromProtobuf(transfer.getAccountID()),
                    transfer.getAmount(),
                    tokenTransferList.hasExpectedDecimals() ? tokenTransferList.getExpectedDecimals().getValue() : null,
                    transfer.getIsApproval()
                ));
            }

            for (var transfer : tokenTransferList.getNftTransfersList()) {
                nftTransfers.add(new TokenNftTransfer(
                    token,
                    AccountId.fromProtobuf(transfer.getSenderAccountID()),
                    AccountId.fromProtobuf(transfer.getReceiverAccountID()),
                    transfer.getSerialNumber(),
                    transfer.getIsApproval()
                ));
            }
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenAllowance.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.GrantedTokenAllowance;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * An approved allowance of token transfers for a spender.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/tokenallowance">Hedera Documentation</a>
 */
public class TokenAllowance {
    /**
     * The token that the allowance pertains to
     */
    @Nullable
    public final TokenId tokenId;
    /**
     * The account ID of the hbar owner (ie. the grantor of the allowance)
     */
    @Nullable
    public final AccountId ownerAccountId;
    /**
     * The account ID of the spender of the hbar allowance
     */
    @Nullable
    public final AccountId spenderAccountId;
    /**
     * The amount of the spender's token allowance
     */
    public final long amount;

    /**
     * Constructor.
     *
     * @param tokenId                   the token id
     * @param ownerAccountId            the grantor account id
     * @param spenderAccountId          the spender account id
     * @param amount                    the token allowance
     */
    TokenAllowance(
        @Nullable TokenId tokenId,
        @Nullable AccountId ownerAccountId,
        @Nullable AccountId spenderAccountId,
        long amount
    ) {
        this.tokenId = tokenId;
        this.ownerAccountId = ownerAccountId;
        this.spenderAccountId = spenderAccountId;
        this.amount = amount;
    }

    /**
     * Create a token allowance from a protobuf.
     *
     * @param allowanceProto            the protobuf
     * @return                          the new token allowance
     */
    static TokenAllowance fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenAllowance allowanceProto) {
        return new TokenAllowance(
            allowanceProto.hasTokenId() ? TokenId.fromProtobuf(allowanceProto.getTokenId()) : null,
            allowanceProto.hasOwner() ? AccountId.fromProtobuf(allowanceProto.getOwner()) : null,
            allowanceProto.hasSpender() ? AccountId.fromProtobuf(allowanceProto.getSpender()) : null,
            allowanceProto.getAmount()
        );
    }

    /**
     * Create a token allowance from a protobuf.
     *
     * @param allowanceProto            the protobuf
     * @return                          the new token allowance
     */
    static TokenAllowance fromProtobuf(GrantedTokenAllowance allowanceProto) {
        return new TokenAllowance(
            allowanceProto.hasTokenId() ? TokenId.fromProtobuf(allowanceProto.getTokenId()) : null,
            null,
            allowanceProto.hasSpender() ? AccountId.fromProtobuf(allowanceProto.getSpender()) : null,
            allowanceProto.getAmount()
        );
    }

    /**
     * Create a token allowance from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new token allowance
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenAllowance fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenAllowance.parseFrom(Objects.requireNonNull(bytes)));
    }

    /**
     * Validate the configured client.
     *
     * @param client                    the configured client
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
        if (ownerAccountId != null) {
            ownerAccountId.validateChecksum(client);
        }
        if (spenderAccountId != null) {
            spenderAccountId.validateChecksum(client);
        }
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.TokenAllowance toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.TokenAllowance.newBuilder()
            .setAmount(amount);
        if (tokenId != null) {
            builder.setTokenId(tokenId.toProtobuf());
        }
        if (ownerAccountId != null) {
            builder.setOwner(ownerAccountId.toProtobuf());
        }
        if (spenderAccountId != null) {
            builder.setSpender(spenderAccountId.toProtobuf());
        }
        return builder.build();
    }

    /**
     * Create the byte array.
     *
     * @return                          the protobuf representation
     */
    GrantedTokenAllowance toGrantedProtobuf() {
        var builder = GrantedTokenAllowance.newBuilder()
            .setAmount(amount);
        if (tokenId != null) {
            builder.setTokenId(tokenId.toProtobuf());
        }
        if (spenderAccountId != null) {
            builder.setSpender(spenderAccountId.toProtobuf());
        }
        return builder.build();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("ownerAccountId", ownerAccountId)
            .add("spenderAccountId", spenderAccountId)
            .add("amount", amount)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenAssociateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenAssociateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * The transaction that will associate accounts to a token id.
 */
public class TokenAssociateTransaction extends Transaction<TokenAssociateTransaction> {
    @Nullable
    private AccountId accountId = null;
    private List<TokenId> tokenIds = new ArrayList<>();

    /**
     * Constructor.
     */
    public TokenAssociateTransaction() {
        defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenAssociateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenAssociateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenAssociateTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the list of token id's.
     *
     * @return                          the list of token id's
     */
    public List<TokenId> getTokenIds() {
        return new ArrayList<>(tokenIds);
    }

    /**
     * Assign a new list of token id's.
     *
     * @param tokens                    the list of token id's
     * @return {@code this}
     */
    public TokenAssociateTransaction setTokenIds(List<TokenId> tokens) {
        Objects.requireNonNull(tokens);
        requireNotFrozen();
        this.tokenIds = new ArrayList<>(tokens);
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenAssociateTransactionBody}
     */
    TokenAssociateTransactionBody.Builder build() {
        var builder = TokenAssociateTransactionBody.newBuilder();
        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }

        for (var token : tokenIds) {
            if (token != null) {
                builder.addTokens(token.toProtobuf());
            }
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenAssociate();
        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }

        for (var token : body.getTokensList()) {
            tokenIds.add(TokenId.fromProtobuf(token));
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        Objects.requireNonNull(client);
        if (accountId != null) {
            accountId.validateChecksum(client);
        }

        for (var token : tokenIds) {
            if (token != null) {
                token.validateChecksum(client);
            }
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getAssociateTokensMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenAssociate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenAssociate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenAssociation.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

/**
 * Associates the provided Hedera account with the provided Hedera token(s).
 * Hedera accounts must be associated with a fungible or non-fungible token
 * first before you can transfer tokens to that account. In the case of
 * NON_FUNGIBLE Type, once an account is associated, it can hold any number
 * of NFTs (serial numbers) of that token type. The Hedera account that is
 * being associated with a token is required to sign the transaction.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/associate-tokens-to-an-account">Hedera Documentation</a>
 */
public class TokenAssociation {

    /**
     * The token involved in the association
     */
    public final TokenId tokenId;

    /**
     * The account involved in the association
     */
    public final AccountId accountId;

    /**
     * Constructor.
     *
     * @param tokenId                   the token id
     * @param accountId                 the account id
     */
    TokenAssociation(TokenId tokenId, AccountId accountId) {
        this.tokenId = tokenId;
        this.accountId = accountId;
    }

    /**
     * Create a token association from a protobuf.
     *
     * @param tokenAssociation          the protobuf
     * @return                          the new token association
     */
    static TokenAssociation fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenAssociation tokenAssociation) {
        return new TokenAssociation(
            tokenAssociation.hasTokenId() ? TokenId.fromProtobuf(tokenAssociation.getTokenId()) : new TokenId(0, 0, 0),
            tokenAssociation.hasAccountId() ? AccountId.fromProtobuf(tokenAssociation.getAccountId()) : new AccountId(0, 0, 0)
        );
    }

    /**
     * Create a token association from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new token association
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenAssociation fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenAssociation.parseFrom(bytes));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.TokenAssociation toProtobuf() {
        return com.hedera.hashgraph.sdk.proto.TokenAssociation.newBuilder()
            .setTokenId(tokenId.toProtobuf())
            .setAccountId(accountId.toProtobuf())
            .build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("accountId", accountId)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenBurnTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenBurnTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * Burns fungible and non-fungible tokens owned by the Treasury Account.
 * If no Supply Key is defined, the transaction will resolve to
 * TOKEN_HAS_NO_SUPPLY_KEY.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/burn-a-token">Hedera Documentation</a>
 */
public class TokenBurnTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenBurnTransaction> {
    /**
     * The ID of the token to burn supply
     */
    @Nullable
    private TokenId tokenId = null;
    /**
     * The ID of the token to burn supply
     */
    private long amount = 0;
    /**
     * Applicable to tokens of type NON_FUNGIBLE_UNIQUE.The  list of NFT serial IDs to burn.
     */
    private List<Long> serials = new ArrayList<>();

    /**
     * Constructor.
     */
    public TokenBurnTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenBurnTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenBurnTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenBurnTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the amount of tokens to burn.
     *
     * @return                          the amount of tokens to burn
     */
    public long getAmount() {
        return amount;
    }

    /**
     * Assign the amount of tokens to burn.
     *
     * The amount provided must be in the lowest denomination possible.
     *
     * Example: Token A has 2 decimals. In order to burn 100 tokens, one must
     * provide an amount of 10000. In order to burn 100.55 tokens, one must
     * provide an amount of 10055.
     *
     * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/burn-a-token">Hedera Documentation</a>
     *
     * @param amount                    the amount of tokens to burn
     * @return {@code this}
     */
    public TokenBurnTransaction setAmount(@Nonnegative long amount) {
        requireNotFrozen();
        this.amount = amount;
        return this;
    }

    /**
     * Extract the of token serials.
     *
     * @return                          list of token serials
     */
    public List<Long> getSerials() {
        return new ArrayList<>(serials);
    }

    /**
     * Assign the list of token serials.
     *
     * @param serials                   list of token serials
     * @return {@code this}
     */
    public TokenBurnTransaction setSerials(List<Long> serials) {
        requireNotFrozen();
        Objects.requireNonNull(serials);
        this.serials = new ArrayList<>(serials);
        return this;
    }

    /**
     * Add a serial number to the list of serials.
     *
     * @param serial                    the serial number to add
     * @return {@code this}
     */
    public TokenBurnTransaction addSerial(@Nonnegative long serial) {
        requireNotFrozen();
        serials.add(serial);
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenBurnTransactionBody}
     */
    TokenBurnTransactionBody.Builder build() {
        var builder = TokenBurnTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }
        builder.setAmount(amount);

        for (var serial : serials) {
            builder.addSerialNumbers(serial);
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenBurn();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
        amount = body.getAmount();
        serials = body.getSerialNumbersList();
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getBurnTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenBurn(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenBurn(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenCancelAirdropTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenCancelAirdropTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody.Builder;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.LinkedHashMap;

public class TokenCancelAirdropTransaction extends PendingAirdropLogic<TokenCancelAirdropTransaction> {

    /**
     * Constructor.
     */
    public TokenCancelAirdropTransaction() {
        defaultMaxTransactionFee = Hbar.from(1);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    TokenCancelAirdropTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenCancelAirdropTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }


    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenCancelAirdropTransactionBody}
     */
    TokenCancelAirdropTransactionBody.Builder build() {
        var builder = TokenCancelAirdropTransactionBody.newBuilder();

        for (var pendingAirdropId : pendingAirdropIds) {
            builder.addPendingAirdrops(pendingAirdropId.toProtobuf());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenCancelAirdrop();
        for (var pendingAirdropId : body.getPendingAirdropsList()) {
            this.pendingAirdropIds.add(PendingAirdropId.fromProtobuf(pendingAirdropId));
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getCancelAirdropMethod();
    }

    @Override
    void onFreeze(Builder bodyBuilder) {
        bodyBuilder.setTokenCancelAirdrop(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenCancelAirdrop(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenClaimAirdropTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenClaimAirdropTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody.Builder;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.LinkedHashMap;

public class TokenClaimAirdropTransaction extends PendingAirdropLogic<TokenClaimAirdropTransaction> {

    /**
     * Constructor.
     */
    public TokenClaimAirdropTransaction() {
        defaultMaxTransactionFee = Hbar.from(1);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    TokenClaimAirdropTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenClaimAirdropTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenClaimAirdropTransactionBody}
     */
    TokenClaimAirdropTransactionBody.Builder build() {
        var builder = TokenClaimAirdropTransactionBody.newBuilder();

        for (var pendingAirdropId : pendingAirdropIds) {
            builder.addPendingAirdrops(pendingAirdropId.toProtobuf());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenClaimAirdrop();
        for (var pendingAirdropId : body.getPendingAirdropsList()) {
            this.pendingAirdropIds.add(PendingAirdropId.fromProtobuf(pendingAirdropId));
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getClaimAirdropMethod();
    }

    @Override
    void onFreeze(Builder bodyBuilder) {
        bodyBuilder.setTokenClaimAirdrop(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenClaimAirdrop(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * Create a new fungible or non-fungible token (NFT) on the Hedera network.
 * After you submit the transaction to the Hedera network, you can obtain the
 * new token ID by requesting the receipt. Smart contracts cannot access or
 * transfer HTS tokens at this time.
 *
 * NFTs
 *
 * For non-fungible tokens, the token ID represents a NFT class. Once the token
 * is created, you will have to mint each NFT using the token mint operation.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/define-a-token">Hedera Documentation</a>
 */
public class TokenCreateTransaction extends Transaction<TokenCreateTransaction> {
    private List<CustomFee> customFees = new ArrayList<>();
    /**
     * The account which will act as a treasury for the token. This account
     * will receive the specified initial supply and any additional tokens
     * that are minted.  If tokens are burned, the supply will be decreased
     * from the treasury account.
     */
    @Nullable
    private AccountId treasuryAccountId = null;
    /**
     * An account which will be automatically charged to renew the token's
     * expiration, at autoRenewPeriod interval. This key is required to
     * sign the transaction if present. This is not currently enabled.
     */
    @Nullable
    private AccountId autoRenewAccountId = null;
    /**
     * Set the publicly visible name of the token. The token name is specified
     * as a string of UTF-8 characters in Unicode. UTF-8 encoding of this
     * Unicode cannot contain the 0 byte (NUL). The token name is not unique.
     * Maximum of 100 characters.
     */
    private String tokenName = "";
    /**
     * The publicly visible token symbol. Set the publicly visible name of the
     * token. The token symbol is specified as a string of UTF-8 characters in
     * Unicode. UTF-8 encoding of this Unicode cannot contain the 0 byte (NUL).
     * The token symbol is not unique. Maximum of 100 characters.
     */
    private String tokenSymbol = "";
    /**
     * The number of decimal places a token is divisible by. This field can
     * never be changed.
     */
    private int decimals = 0;
    /**
     * Specifies the initial supply of fungible tokens to be put in
     * circulation. The initial supply is sent to the Treasury Account.
     * The maximum supply of tokens is 9,223,372,036,854,775,807(2^63-1)
     * tokens and is in the lowest denomination possible. For creating an
     * NFT, you must set the initial supply to 0.
     */
    private long initialSupply = 0;
    /**
     * The key which can perform token update and token delete operations on
     * the token.The admin key has the authority to change the freeze key,
     * wipe key, and KYC key. It can also update the treasury account of the
     * token.  If empty, the token can be perceived as immutable (not being
     * able to be updated/deleted). (KYC - Know Your Customer)
     */
    @Nullable
    private Key adminKey = null;
    /**
     * The key which can grant or revoke KYC of an account for the token's
     * transactions. If empty, KYC is not required, and KYC grant or revoke
     * operations are not possible.
     */
    @Nullable
    private Key kycKey = null;
    /**
     * The key which can sign to freeze or unfreeze an account for token
     * transactions. If empty, freezing is not possible.
     */
    @Nullable
    private Key freezeKey = null;
    /**
     * The key which can wipe the token balance of an account. If empty,
     * wipe is not possible.
     */
    @Nullable
    private Key wipeKey = null;
    /**
     * The key which can change the total supply of a token. This key is
     * used to authorize token mint and burn transactions. If this is left
     * empty, minting/burning tokens is not possible.
     */
    @Nullable
    private Key supplyKey = null;
    /**
     * The key that can change the token's  schedule. A custom fee schedule
     * token without a fee schedule key is immutable.
     */
    @Nullable
    private Key feeScheduleKey = null;
    /**
     * The key that has the authority to pause or unpause a token. Pausing
     * a token prevents the token from participating in all transactions.
     */
    @Nullable
    private Key pauseKey = null;
    /**
     * The key which can change the metadata of a token
     * (token definition, partition definition, and individual NFTs).
     */
    @Nullable
    private Key metadataKey = null;
    /**
     * The default Freeze status (frozen or unfrozen) of Hedera accounts
     * relative to this token. If true, an account must be unfrozen before
     * it can receive the token.
     */
    private boolean freezeDefault = false;
    /**
     * The epoch second at which the token should expire; if an auto-renew
     * account and period are specified, this is coerced to the current
     * epoch second plus the autoRenewPeriod. The default expiration time
     * is 90 days.
     */
    @Nullable
    private Instant expirationTime = null;
    /**
     * The interval at which the auto-renew account will be charged to
     * extend the token's expiry. The default auto-renew period is
     * 131,500 minutes. This is not currently enabled.
     */
    @Nullable
    private Duration autoRenewPeriod = null;
    /**
     * A short publicly visible memo about the token.
     */
    private String tokenMemo = "";
    /**
     * The type of token to create. Either fungible or non-fungible.
     */
    private TokenType tokenType = TokenType.FUNGIBLE_COMMON;
    /**
     * Specifies the token supply type. Defaults to INFINITE.
     */
    private TokenSupplyType tokenSupplyType = TokenSupplyType.INFINITE;
    /**
     * For tokens of type FUNGIBLE_COMMON - the maximum number of tokens that
     * can be in circulation.
     *
     * For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs
     * (serial numbers) that can be minted. This field can never be changed.
     *
     * You must set the token supply type to FINITE if you set this field.
     */
    private long maxSupply = 0;
    /**
     * Metadata of the created token definition.
     */
    private byte[] tokenMetadata = {};
    /**
     * Constructor.
     */
    public TokenCreateTransaction() {
        setAutoRenewPeriod(DEFAULT_AUTO_RENEW_PERIOD);
        defaultMaxTransactionFee = new Hbar(40);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenCreateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenCreateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token name.
     *
     * @return                          the token name
     */
    @Nullable
    public String getTokenName() {
        return tokenName;
    }

    /**
     * Assign the token's name 100 bytes max.
     *
     * @param name                      the token name
     * @return {@code this}
     */
    public TokenCreateTransaction setTokenName(String name) {
        Objects.requireNonNull(name);
        requireNotFrozen();
        tokenName = name;
        return this;
    }

    /**
     * Extract the token symbol.
     *
     * @return                          the token symbol
     */
    public String getTokenSymbol() {
        return tokenSymbol;
    }

    /**
     * Assign the token's symbol 100 bytes max.
     *
     * @param symbol                    the token symbol
     * @return {@code this}
     */
    public TokenCreateTransaction setTokenSymbol(String symbol) {
        Objects.requireNonNull(symbol);
        requireNotFrozen();
        tokenSymbol = symbol;
        return this;
    }

    /**
     * Extract the decimals.
     *
     * @return                          the decimals
     */
    public int getDecimals() {
        return decimals;
    }

    /**
     * Assign the number of decimal places a token is divisible by.
     *
     * This field can never be changed.
     *
     * @param decimals                  the number of decimals
     * @return {@code this}
     */
    public TokenCreateTransaction setDecimals(@Nonnegative int decimals) {
        requireNotFrozen();
        this.decimals = decimals;
        return this;
    }

    /**
     * Extract the initial supply of tokens.
     *
     * @return                          the initial supply of tokens
     */
    public long getInitialSupply() {
        return initialSupply;
    }

    /**
     * Assign the initial supply of tokens.
     *
     * @param initialSupply             the initial supply of tokens
     * @return {@code this}
     */
    public TokenCreateTransaction setInitialSupply(@Nonnegative long initialSupply) {
        requireNotFrozen();
        this.initialSupply = initialSupply;
        return this;
    }

    /**
     * Extract the treasury account id.
     *
     * @return                          the treasury account id
     */
    @Nullable
    public AccountId getTreasuryAccountId() {
        return treasuryAccountId;
    }

    /**
     * Assign the treasury account id.
     *
     * @param accountId                 the treasury account id
     * @return {@code this}
     */
    public TokenCreateTransaction setTreasuryAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.treasuryAccountId = accountId;
        return this;
    }

    /**
     * Extract the admin key.
     *
     * @return                          the admin key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Assign the admin key.
     *
     * @param key                       the admin key
     * @return {@code this}
     */
    public TokenCreateTransaction setAdminKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        adminKey = key;
        return this;
    }

    /**
     * Extract the know your customer key.
     *
     * @return                          the know your customer key
     */
    @Nullable
    public Key getKycKey() {
        return kycKey;
    }

    /**
     * Assign the kyc key.
     *
     * @param key                       the know your customer key
     * @return {@code this}
     */
    public TokenCreateTransaction setKycKey(Key key) {
        requireNotFrozen();
        kycKey = key;
        return this;
    }

    /**
     * Extract the freeze key.
     *
     * @return                          the freeze key
     */
    @Nullable
    public Key getFreezeKey() {
        return freezeKey;
    }

    /**
     * Assign the freeze key.
     *
     * @param key                       the freeze key
     * @return {@code this}
     */
    public TokenCreateTransaction setFreezeKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        freezeKey = key;
        return this;
    }

    /**
     * Extract the wipe key.
     *
     * @return                          the wipe key
     */
    @Nullable
    public Key getWipeKey() {
        return wipeKey;
    }

    /**
     * Assign the wipe key.
     *
     * @param key                       the wipe key
     * @return {@code this}
     */
    public TokenCreateTransaction setWipeKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        wipeKey = key;
        return this;
    }

    /**
     * Extract the supply key.
     *
     * @return                          the supply key
     */
    @Nullable
    public Key getSupplyKey() {
        return supplyKey;
    }

    /**
     * Assign the supply key.
     *
     * @param key                       the supply key
     * @return {@code this}
     */
    public TokenCreateTransaction setSupplyKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        supplyKey = key;
        return this;
    }

    /**
     * Extract the fee schedule key.
     *
     * @return                          the fee schedule key
     */
    @Nullable
    public Key getFeeScheduleKey() {
        return feeScheduleKey;
    }

    /**
     * Assign the fee schedule key.
     *
     * @param key                       the fee schedule key
     * @return {@code this}
     */
    public TokenCreateTransaction setFeeScheduleKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        feeScheduleKey = key;
        return this;
    }

    /**
     * Extract the pause key.
     *
     * @return                          the pause key
     */
    @Nullable
    public Key getPauseKey() {
        return pauseKey;
    }

    /**
     * Assign the pause key.
     *
      * @param key                      the pause key
     * @return {@code this}
     */
    public TokenCreateTransaction setPauseKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        pauseKey = key;
        return this;
    }

    /**
     * Extract the metadata key.
     *
     * @return                          the metadata key
     */
    @Nullable
    public Key getMetadataKey() {
        return metadataKey;
    }

    /**
     * Assign the metadata key.
     *
     * @param key                      the metadata key
     * @return {@code this}
     */
    public TokenCreateTransaction setMetadataKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        metadataKey = key;
        return this;
    }

    /**
     * Extract the freeze default.
     *
     * @return                          the freeze default
     */
    public boolean getFreezeDefault() {
        return freezeDefault;
    }

    /**
     * Assign the freeze default.
     *
     * @param freezeDefault             the freeze default
     * @return {@code this}
     */
    public TokenCreateTransaction setFreezeDefault(boolean freezeDefault) {
        requireNotFrozen();
        this.freezeDefault = freezeDefault;
        return this;
    }

    /**
     * Extract the expiration time.
     *
     * @return                          the expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Assign the expiration time.
     *
     * @param expirationTime            the expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public TokenCreateTransaction setExpirationTime(Instant expirationTime) {
        Objects.requireNonNull(expirationTime);
        requireNotFrozen();
        autoRenewPeriod = null;
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Extract the auto renew account id.
     *
     * @return                          the auto renew account id
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * Assign the auto renew account id.
     *
     * @param accountId                 the auto renew account id
     * @return {@code this}
     */
    public TokenCreateTransaction setAutoRenewAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.autoRenewAccountId = accountId;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Assign the auto renew period.
     *
     * @param period                    the auto renew period
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public TokenCreateTransaction setAutoRenewPeriod(Duration period) {
        Objects.requireNonNull(period);
        requireNotFrozen();
        autoRenewPeriod = period;
        return this;
    }

    /**
     * Extract the token's memo 100 bytes max.
     *
     * @return                          the token's memo 100 bytes max
     */
    public String getTokenMemo() {
        return tokenMemo;
    }

    /**
     * Assign the token's memo.
     *
     * @param memo                      the token's memo 100 bytes max
     * @return {@code this}
     */
    public TokenCreateTransaction setTokenMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        tokenMemo = memo;
        return this;
    }

    /**
     * Extract the custom fees.
     *
     * @return                          the custom fees
     */
    @Nullable
    public List<CustomFee> getCustomFees() {
        return CustomFee.deepCloneList(customFees);
    }

    /**
     * Assign the custom fees.
     *
     * @param customFees                the custom fees
     * @return {@code this}
     */
    public TokenCreateTransaction setCustomFees(List<CustomFee> customFees) {
        requireNotFrozen();
        this.customFees = CustomFee.deepCloneList(customFees);
        return this;
    }

    /**
     * Extract the token type.
     *
     * @return                          the token type
     */
    public TokenType getTokenType() {
        return tokenType;
    }

    /**
     * Assign the token type.
     *
     * @param tokenType                 the token type
     * @return {@code this}
     */
    public TokenCreateTransaction setTokenType(TokenType tokenType) {
        requireNotFrozen();
        Objects.requireNonNull(tokenType);
        this.tokenType = tokenType;
        return this;
    }

    /**
     * Extract the supply type.
     *
     * @return                          the supply type
     */
    public TokenSupplyType getSupplyType() {
        return tokenSupplyType;
    }

    /**
     * Assign the supply type.
     *
      * @param supplyType               the supply type
     * @return {@code this}
     */
    public TokenCreateTransaction setSupplyType(TokenSupplyType supplyType) {
        requireNotFrozen();
        Objects.requireNonNull(supplyType);
        tokenSupplyType = supplyType;
        return this;
    }

    /**
     * Extract the max supply of tokens.
     *
     * @return                          the max supply of tokens
     */
    public long getMaxSupply() {
        return maxSupply;
    }

    /**
     * Assign the max supply of tokens.
     *
     * @param maxSupply                 the max supply of tokens
     * @return {@code this}
     */
    public TokenCreateTransaction setMaxSupply(@Nonnegative long maxSupply) {
        requireNotFrozen();
        this.maxSupply = maxSupply;
        return this;
    }

    /**
     * Extract the token metadata.
     *
     * @return the token metadata
     */
    public byte[] getTokenMetadata() {
        return tokenMetadata;
    }

    /**
     * Assign the token metadata.
     *
     * @param tokenMetadata the token metadata
     * @return {@code this}
     */
    public TokenCreateTransaction setTokenMetadata(byte[] tokenMetadata) {
        requireNotFrozen();
        this.tokenMetadata = tokenMetadata;
        return this;
    }

    @Override
    public TokenCreateTransaction freezeWith(@Nullable Client client) {
        if (
            autoRenewPeriod != null &&
                autoRenewAccountId == null &&
                client != null &&
                client.getOperatorAccountId() != null
        ) {
            autoRenewAccountId = client.getOperatorAccountId();
        }

        return super.freezeWith(client);
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenCreateTransactionBody}
     */
    TokenCreateTransactionBody.Builder build() {
        var builder = TokenCreateTransactionBody.newBuilder();
        if (treasuryAccountId != null) {
            builder.setTreasury(treasuryAccountId.toProtobuf());
        }

        if (autoRenewAccountId != null) {
            builder.setAutoRenewAccount(autoRenewAccountId.toProtobuf());
        }
        builder.setName(tokenName);
        builder.setSymbol(tokenSymbol);
        builder.setDecimals(decimals);
        builder.setInitialSupply(initialSupply);
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        if (kycKey != null) {
            builder.setKycKey(kycKey.toProtobufKey());
        }
        if (freezeKey != null) {
            builder.setFreezeKey(freezeKey.toProtobufKey());
        }
        if (wipeKey != null) {
            builder.setWipeKey(wipeKey.toProtobufKey());
        }
        if (supplyKey != null) {
            builder.setSupplyKey(supplyKey.toProtobufKey());
        }
        if (feeScheduleKey != null) {
            builder.setFeeScheduleKey(feeScheduleKey.toProtobufKey());
        }
        if (pauseKey != null) {
            builder.setPauseKey(pauseKey.toProtobufKey());
        }
        if (metadataKey != null) {
            builder.setMetadataKey(metadataKey.toProtobufKey());
        }
        builder.setFreezeDefault(freezeDefault);
        if (expirationTime != null) {
            builder.setExpiry(InstantConverter.toProtobuf(expirationTime));
        }
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        builder.setMemo(tokenMemo);
        builder.setTokenType(tokenType.code);
        builder.setSupplyType(tokenSupplyType.code);
        builder.setMaxSupply(maxSupply);
        builder.setMetadata(ByteString.copyFrom(tokenMetadata));

        for (var fee : customFees) {
            builder.addCustomFees(fee.toProtobuf());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenCreation();
        if (body.hasTreasury()) {
            treasuryAccountId = AccountId.fromProtobuf(body.getTreasury());
        }
        if (body.hasAutoRenewAccount()) {
            autoRenewAccountId = AccountId.fromProtobuf(body.getAutoRenewAccount());
        }
        tokenName = body.getName();
        tokenSymbol = body.getSymbol();
        decimals = body.getDecimals();
        initialSupply = body.getInitialSupply();
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        if (body.hasKycKey()) {
            kycKey = Key.fromProtobufKey(body.getKycKey());
        }
        if (body.hasFreezeKey()) {
            freezeKey = Key.fromProtobufKey(body.getFreezeKey());
        }
        if (body.hasWipeKey()) {
            wipeKey = Key.fromProtobufKey(body.getWipeKey());
        }
        if (body.hasSupplyKey()) {
            supplyKey = Key.fromProtobufKey(body.getSupplyKey());
        }
        if (body.hasFeeScheduleKey()) {
            feeScheduleKey = Key.fromProtobufKey(body.getFeeScheduleKey());
        }
        if (body.hasPauseKey()) {
            pauseKey = Key.fromProtobufKey(body.getPauseKey());
        }
        if (body.hasMetadataKey()) {
            metadataKey = Key.fromProtobufKey(body.getMetadataKey());
        }
        freezeDefault = body.getFreezeDefault();
        if (body.hasExpiry()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpiry());
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        tokenMemo = body.getMemo();
        tokenType = TokenType.valueOf(body.getTokenType());
        tokenSupplyType = TokenSupplyType.valueOf(body.getSupplyType());
        maxSupply = body.getMaxSupply();
        tokenMetadata = body.getMetadata().toByteArray();

        for (var fee : body.getCustomFeesList()) {
            customFees.add(CustomFee.fromProtobuf(fee));
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        for (var fee : customFees) {
            fee.validateChecksums(client);
        }

        if (treasuryAccountId != null) {
            treasuryAccountId.validateChecksum(client);
        }

        if (autoRenewAccountId != null) {
            autoRenewAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getCreateTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenCreation(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenCreation(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Deleting a token marks a token as deleted, though it will remain in the
 * ledger. The operation must be signed by the specified Admin Key of the
 * Token. If the Admin Key is not set, Transaction will result in
 * TOKEN_IS_IMMUTABlE. Once deleted update, mint, burn, wipe, freeze,
 * unfreeze, grant kyc, revoke kyc and token transfer transactions will
 * resolve to TOKEN_WAS_DELETED.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/delete-a-token">Hedera Documentation</a>
 */
public class TokenDeleteTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenDeleteTransaction> {
    @Nullable
    private TokenId tokenId = null;

    /**
     * Constructor.
     */
    public TokenDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenDeleteTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenDeletion();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenDeleteTransactionBody}
     */
    TokenDeleteTransactionBody.Builder build() {
        var builder = TokenDeleteTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getDeleteTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenDeletion(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenDeletion(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenDissociateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenDissociateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * Disassociates the provided Hedera account from the provided Hedera tokens.
 * This transaction must be signed by the provided account's key. Once the
 * association is removed, no token related operation can be performed to that
 * account. AccountBalanceQuery and AccountInfoQuery will not return anything
 * related to the token that was disassociated.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/dissociate-tokens-from-an-account">Hedera Documentation</a>
 */
public class TokenDissociateTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenDissociateTransaction> {
    @Nullable
    private AccountId accountId = null;
    private List<TokenId> tokenIds = new ArrayList<>();

    /**
     * Constructor.
     */
    public TokenDissociateTransaction() {
        defaultMaxTransactionFee = new Hbar(5);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenDissociateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenDissociateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenDissociateTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the list of token id's.
     *
     * @return                          the list of token id's
     */
    public List<TokenId> getTokenIds() {
        return new ArrayList<>(tokenIds);
    }

    /**
     * Assign the list of token id's.
     *
     * @param tokens                    the list of token id's.
     * @return {@code this}
     */
    public TokenDissociateTransaction setTokenIds(List<TokenId> tokens) {
        requireNotFrozen();
        this.tokenIds = new ArrayList<>(tokens);
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenDissociate();
        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }

        for (var token : body.getTokensList()) {
            tokenIds.add(TokenId.fromProtobuf(token));
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenDissociateTransactionBody}
     */
    TokenDissociateTransactionBody.Builder build() {
        var builder = TokenDissociateTransactionBody.newBuilder();
        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }

        for (var token : tokenIds) {
            if (token != null) {
                builder.addTokens(token.toProtobuf());
            }
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (accountId != null) {
            accountId.validateChecksum(client);
        }

        for (var token : tokenIds) {
            if (token != null) {
                token.validateChecksum(client);
            }
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getDissociateTokensMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenDissociate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenDissociate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenFeeScheduleUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenFeeScheduleUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * Update the custom fees for a given token. If the token does not have a
 * fee schedule, the network response returned will be
 * CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES. You will need to sign the transaction
 * with the fee schedule key to update the fee schedule for the token. If you
 * do not have a fee schedule key set for the token, you will not be able to
 * update the fee schedule.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/update-a-fee-schedule">Hedera Documentation</a>
 */
public class TokenFeeScheduleUpdateTransaction extends Transaction<TokenFeeScheduleUpdateTransaction> {
    @Nullable
    private TokenId tokenId = null;
    private List<CustomFee> customFees = new ArrayList<>();

    /**
     * Constructor.
     */
    public TokenFeeScheduleUpdateTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenFeeScheduleUpdateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenFeeScheduleUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenFeeScheduleUpdateTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the list of custom fees.
     *
     * @return                          the list of custom fees
     */
    public List<CustomFee> getCustomFees() {
        return CustomFee.deepCloneList(customFees);
    }

    /**
     * Assign the list of custom fees.
     *
      * @param customFees               the list of custom fees
     * @return {@code this}
     */
    public TokenFeeScheduleUpdateTransaction setCustomFees(List<CustomFee> customFees) {
        Objects.requireNonNull(customFees);
        requireNotFrozen();
        this.customFees = CustomFee.deepCloneList(customFees);
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenFeeScheduleUpdate();
        if (body.hasTokenId()) {
            tokenId = TokenId.fromProtobuf(body.getTokenId());
        }

        for (var fee : body.getCustomFeesList()) {
            customFees.add(CustomFee.fromProtobuf(fee));
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenFeeScheduleUpdateTransactionBody}
     */
    TokenFeeScheduleUpdateTransactionBody.Builder build() {
        var builder = TokenFeeScheduleUpdateTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setTokenId(tokenId.toProtobuf());
        }

        builder.clearCustomFees();
        for (var fee : customFees) {
            builder.addCustomFees(fee.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        for (CustomFee fee : customFees) {
            fee.validateChecksums(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getUpdateTokenFeeScheduleMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenFeeScheduleUpdate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        throw new UnsupportedOperationException("Cannot schedule TokenFeeScheduleUpdateTransaction");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenFreezeTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenFreezeAccountTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Freezes transfers of the specified token for the account.
 *
 * The transaction must be signed by the token's Freeze Key.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/freeze-an-account">Hedera Documentation</a>
 */
public class TokenFreezeTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenFreezeTransaction> {
    @Nullable
    private TokenId tokenId = null;
    @Nullable
    private AccountId accountId = null;

    /**
     * Constructor.
     */
    public TokenFreezeTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenFreezeTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenFreezeTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenFreezeTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenFreezeTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenFreeze();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }

        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenFreezeAccountTransactionBody}
     */
    TokenFreezeAccountTransactionBody.Builder build() {
        var builder = TokenFreezeAccountTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getFreezeTokenAccountMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenFreeze(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenFreeze(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenGrantKycTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenGrantKycTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Grants KYC to the Hedera accounts for the given Hedera token.
 *
 * This transaction must be signed by the token's KYC Key.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/enable-kyc-account-flag-1">Hedera Documentation</a>
 */
public class TokenGrantKycTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenGrantKycTransaction> {
    @Nullable
    private TokenId tokenId = null;
    @Nullable
    private AccountId accountId = null;

    /**
     * Configure.
     */
    public TokenGrantKycTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenGrantKycTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenGrantKycTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenGrantKycTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenGrantKycTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenGrantKyc();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }

        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenGrantKycTransactionBody}
     */
    TokenGrantKycTransactionBody.Builder build() {
        var builder = TokenGrantKycTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getFreezeTokenAccountMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenGrantKyc(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenGrantKyc(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.TokenID;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Constructs a TokenId.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/token-id">Hedera Documentation</a>
 */
public class TokenId implements Comparable<TokenId> {
    /**
     * The shard number
     */
    @Nonnegative
    public final long shard;

    /**
     * The realm number
     */
    @Nonnegative
    public final long realm;

    /**
     * The id number
     */
    @Nonnegative
    public final long num;

    @Nullable
    private final String checksum;

    /**
     * Constructor.
     *
     * @param num                       the num part
     */
    public TokenId(@Nonnegative long num) {
        this(0, 0, num);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @param num                       the num part
     */
    @SuppressWarnings("InconsistentOverloads")
    public TokenId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num) {
        this(shard, realm, num, null);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @param num                       the num part
     * @param checksum                  the checksum
     */
    @SuppressWarnings("InconsistentOverloads")
    TokenId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num, @Nullable String checksum) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
    }

    /**
     * Create a token id from a string.
     *
     * @param id                        the string representation
     * @return                          the new token id
     */
    public static TokenId fromString(String id) {
        return EntityIdHelper.fromString(id, TokenId::new);
    }

    /**
     * Create a token id from a protobuf.
     *
     * @param tokenId                   the protobuf
     * @return                          the new token id
     */
    static TokenId fromProtobuf(TokenID tokenId) {
        Objects.requireNonNull(tokenId);
        return new TokenId(tokenId.getShardNum(), tokenId.getRealmNum(), tokenId.getTokenNum());
    }

    /**
     * Create a token id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new token id
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(TokenID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create a token id from a solidity address.
     *
     * @param address                   the solidity address as a string
     * @return                          the new token id
     */
    public static TokenId fromSolidityAddress(String address) {
        return EntityIdHelper.fromSolidityAddress(address, TokenId::new);
    }

    /**
     * Create an nft id.
     *
     * @param serial                    the serial number
     * @return                          the new nft id
     */
    public NftId nft(@Nonnegative long serial) {
        return new NftId(this, serial);
    }

    /**
     * Extract the solidity address as a string.
     *
      * @return                         the solidity address as a string
     */
    public String toSolidityAddress() {
        return EntityIdHelper.toSolidityAddress(shard, realm, num);
    }

    /**
     * Create the protobuf.
     *
     * @return                          a protobuf representation
     */
    TokenID toProtobuf() {
        return TokenID.newBuilder()
            .setShardNum(shard)
            .setRealmNum(realm)
            .setTokenNum(num)
            .build();
    }

    /**
     * @param client to validate against
     * @throws BadEntityIdException if entity ID is formatted poorly
     * @deprecated Use {@link #validateChecksum(Client)} instead.
     */
    @Deprecated
    public void validate(Client client) throws BadEntityIdException {
        validateChecksum(client);
    }

    /**
     * Validate the configured client.
     *
     * @param client                    the configured client
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    public void validateChecksum(Client client) throws BadEntityIdException {
        EntityIdHelper.validate(shard, realm, num, client, checksum);
    }

    /**
     * Extract the checksum.
     *
     * @return                          the checksum
     */
    @Nullable
    public String getChecksum() {
        return checksum;
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return EntityIdHelper.toString(shard, realm, num);
    }

    /**
     * Create a string representation with checksum.
     *
     * @param client                    the configured client
     * @return                          the string representation with checksum
     */
    public String toStringWithChecksum(Client client) {
        return EntityIdHelper.toStringWithChecksum(shard, realm, num, client, checksum);
    }

    @Override
    public int hashCode() {
        return Objects.hash(shard, realm, num);
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof TokenId)) {
            return false;
        }

        TokenId otherId = (TokenId) o;
        return shard == otherId.shard && realm == otherId.realm && num == otherId.num;
    }

    @Override
    public int compareTo(TokenId o) {
        Objects.requireNonNull(o);
        int shardComparison = Long.compare(shard, o.shard);
        if (shardComparison != 0) {
            return shardComparison;
        }
        int realmComparison = Long.compare(realm, o.realm);
        if (realmComparison != 0) {
            return realmComparison;
        }
        return Long.compare(num, o.num);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.TokenFreezeStatus;
import com.hedera.hashgraph.sdk.proto.TokenGetInfoResponse;
import com.hedera.hashgraph.sdk.proto.TokenKycStatus;
import com.hedera.hashgraph.sdk.proto.TokenPauseStatus;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

/**
 * Gets information about a fungible or non-fungible token instance.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/get-token-info">Hedera Documentation</a>
 */
public class TokenInfo {
    /**
     * The ID of the token for which information is requested.
     */
    public final TokenId tokenId;

    /**
     * Name of token.
     */
    public final String name;

    /**
     * Symbol of token.
     */
    public final String symbol;

    /**
     * The amount of decimal places that this token supports.
     */
    public final int decimals;

    /**
     * Total Supply of token.
     */
    public final long totalSupply;

    /**
     * The ID of the account which is set as Treasury
     */
    public final AccountId treasuryAccountId;

    /**
     * The key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)
     */
    @Nullable
    public final Key adminKey;

    /**
     * The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.
     */
    @Nullable
    public final Key kycKey;

    /**
     * The key which can freeze or unfreeze an account for token transactions. If empty, freezing is not possible
     */
    @Nullable
    public final Key freezeKey;

    /**
     * The key which can wipe token balance of an account. If empty, wipe is not possible
     */
    @Nullable
    public final Key wipeKey;

    /**
     * The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
     */
    @Nullable
    public final Key supplyKey;

    /**
     * The key which can change the custom fees of the token; if not set, the fees are immutable
     */
    @Nullable
    public final Key feeScheduleKey;

    /**
     * The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token Freeze Key is set and defaultFreeze is set to false
     */
    @Nullable
    public final Boolean defaultFreezeStatus;

    /**
     * The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
     */
    @Nullable
    public final Boolean defaultKycStatus;

    /**
     * Specifies whether the token was deleted or not
     */
    public final boolean isDeleted;

    /**
     * An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
     */
    @Nullable
    public final AccountId autoRenewAccount;

    /**
     * The interval at which the auto-renew account will be charged to extend the token's expiry
     */
    @Nullable
    public final Duration autoRenewPeriod;

    /**
     * The epoch second at which the token will expire
     */
    @Nullable
    public final Instant expirationTime;

    /**
     * The memo associated with the token
     */
    public final String tokenMemo;

    /**
     * The custom fees to be assessed during a CryptoTransfer that transfers units of this token
     */
    public final List<CustomFee> customFees;

    /**
     * The token type
     */
    public final TokenType tokenType;

    /**
     * The token supply type
     */
    public final TokenSupplyType supplyType;

    /**
     * For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
     * circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
     * numbers) that can be in circulation
     */
    public final long maxSupply;

    /**
     * The Key which can pause and unpause the Token.
     */
    @Nullable
    public final Key pauseKey;

    /**
     * Specifies whether the token is paused or not. Null if pauseKey is not set.
     */
    @Nullable
    public final Boolean pauseStatus;

    /**
     * Represents the metadata of the token definition.
     */
    public byte[] metadata = {};

    /**
     * The key which can change the metadata of a token
     * (token definition and individual NFTs).
     */
    @Nullable
    public final Key metadataKey;

    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    public final LedgerId ledgerId;

    TokenInfo(
        TokenId tokenId,
        String name,
        String symbol,
        int decimals,
        long totalSupply,
        AccountId treasuryAccountId,
        @Nullable Key adminKey,
        @Nullable Key kycKey,
        @Nullable Key freezeKey,
        @Nullable Key wipeKey,
        @Nullable Key supplyKey,
        @Nullable Key feeScheduleKey,
        @Nullable Boolean defaultFreezeStatus,
        @Nullable Boolean defaultKycStatus,
        boolean isDeleted,
        @Nullable AccountId autoRenewAccount,
        @Nullable Duration autoRenewPeriod,
        @Nullable Instant expirationTime,
        String tokenMemo,
        List<CustomFee> customFees,
        TokenType tokenType,
        TokenSupplyType supplyType,
        long maxSupply,
        @Nullable Key pauseKey,
        @Nullable Boolean pauseStatus,
        byte[] metadata,
        @Nullable Key metadataKey,
        LedgerId ledgerId
    ) {
        this.tokenId = tokenId;
        this.name = name;
        this.symbol = symbol;
        this.decimals = decimals;
        this.totalSupply = totalSupply;
        this.treasuryAccountId = treasuryAccountId;
        this.adminKey = adminKey;
        this.kycKey = kycKey;
        this.freezeKey = freezeKey;
        this.wipeKey = wipeKey;
        this.supplyKey = supplyKey;
        this.feeScheduleKey = feeScheduleKey;
        this.defaultFreezeStatus = defaultFreezeStatus;
        this.defaultKycStatus = defaultKycStatus;
        this.isDeleted = isDeleted;
        this.autoRenewAccount = autoRenewAccount;
        this.autoRenewPeriod = autoRenewPeriod;
        this.expirationTime = expirationTime;
        this.tokenMemo = tokenMemo;
        this.customFees = customFees;
        this.tokenType = tokenType;
        this.supplyType = supplyType;
        this.maxSupply = maxSupply;
        this.pauseKey = pauseKey;
        this.pauseStatus = pauseStatus;
        this.metadata = metadata;
        this.metadataKey = metadataKey;
        this.ledgerId = ledgerId;
    }

    /**
     * Are we frozen?
     *
     * @param freezeStatus              the freeze status
     * @return                          true / false / null
     */
    @Nullable
    static Boolean freezeStatusFromProtobuf(TokenFreezeStatus freezeStatus) {
        return freezeStatus == TokenFreezeStatus.FreezeNotApplicable ? null : freezeStatus == TokenFreezeStatus.Frozen;
    }

    /**
     * Is kyc required?
     *
     * @param kycStatus                 the kyc status
     * @return                          true / false / null
     */
    @Nullable
    static Boolean kycStatusFromProtobuf(TokenKycStatus kycStatus) {
        return kycStatus == TokenKycStatus.KycNotApplicable ? null : kycStatus == TokenKycStatus.Granted;
    }

    /**
     * Are we paused?
     *
     * @param pauseStatus               the paused status
     * @return                          true / false / null
     */
    @Nullable
    static Boolean pauseStatusFromProtobuf(TokenPauseStatus pauseStatus) {
        return pauseStatus == TokenPauseStatus.PauseNotApplicable ? null : pauseStatus == TokenPauseStatus.Paused;
    }

    /**
     * Create a token info object from a protobuf.
     *
     * @param response                  the protobuf
     * @return                          new token info object
     */
    static TokenInfo fromProtobuf(TokenGetInfoResponse response) {
        var info = response.getTokenInfo();

        return new TokenInfo(
            TokenId.fromProtobuf(info.getTokenId()),
            info.getName(),
            info.getSymbol(),
            info.getDecimals(),
            info.getTotalSupply(),
            AccountId.fromProtobuf(info.getTreasury()),
            info.hasAdminKey() ? Key.fromProtobufKey(info.getAdminKey()) : null,
            info.hasKycKey() ? Key.fromProtobufKey(info.getKycKey()) : null,
            info.hasFreezeKey() ? Key.fromProtobufKey(info.getFreezeKey()) : null,
            info.hasWipeKey() ? Key.fromProtobufKey(info.getWipeKey()) : null,
            info.hasSupplyKey() ? Key.fromProtobufKey(info.getSupplyKey()) : null,
            info.hasFeeScheduleKey() ? Key.fromProtobufKey(info.getFeeScheduleKey()) : null,
            freezeStatusFromProtobuf(info.getDefaultFreezeStatus()),
            kycStatusFromProtobuf(info.getDefaultKycStatus()),
            info.getDeleted(),
            info.hasAutoRenewAccount() ? AccountId.fromProtobuf(info.getAutoRenewAccount()) : null,
            info.hasAutoRenewPeriod() ? DurationConverter.fromProtobuf(info.getAutoRenewPeriod()) : null,
            info.hasExpiry() ? InstantConverter.fromProtobuf(info.getExpiry()) : null,
            info.getMemo(),
            customFeesFromProto(info),
            TokenType.valueOf(info.getTokenType()),
            TokenSupplyType.valueOf(info.getSupplyType()),
            info.getMaxSupply(),
            info.hasPauseKey() ? Key.fromProtobufKey(info.getPauseKey()) : null,
            pauseStatusFromProtobuf(info.getPauseStatus()),
            info.getMetadata().toByteArray(),
            info.hasMetadataKey() ? Key.fromProtobufKey(info.getMetadataKey()) : null,
            LedgerId.fromByteString(info.getLedgerId())
        );
    }

    /**
     * Create a token info object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new token info object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(TokenGetInfoResponse.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create custom fee list from protobuf.
     *
     * @param info                      the protobuf
     * @return                          the list of custom fee's
     */
    private static List<CustomFee> customFeesFromProto(com.hedera.hashgraph.sdk.proto.TokenInfo info) {
        var returnCustomFees = new ArrayList<CustomFee>(info.getCustomFeesCount());
        for (var feeProto : info.getCustomFeesList()) {
            returnCustomFees.add(CustomFee.fromProtobuf(feeProto));
        }
        return returnCustomFees;
    }

    /**
     * Create a token freeze status protobuf.
     *
     * @param freezeStatus              the freeze status
     * @return                          the protobuf
     */
    static TokenFreezeStatus freezeStatusToProtobuf(@Nullable Boolean freezeStatus) {
        return freezeStatus == null ? TokenFreezeStatus.FreezeNotApplicable : freezeStatus ? TokenFreezeStatus.Frozen : TokenFreezeStatus.Unfrozen;
    }

    /**
     * Create a kyc status protobuf.
     *
     * @param kycStatus                 the kyc status
     * @return                          the protobuf
     */
    static TokenKycStatus kycStatusToProtobuf(@Nullable Boolean kycStatus) {
        return kycStatus == null ? TokenKycStatus.KycNotApplicable : kycStatus ? TokenKycStatus.Granted : TokenKycStatus.Revoked;
    }

    /**
     * Create a pause status protobuf.
     *
     * @param pauseStatus               the pause status
     * @return                          the protobuf
     */
    static TokenPauseStatus pauseStatusToProtobuf(@Nullable Boolean pauseStatus) {
        return pauseStatus == null ? TokenPauseStatus.PauseNotApplicable : pauseStatus ? TokenPauseStatus.Paused : TokenPauseStatus.Unpaused;
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    TokenGetInfoResponse toProtobuf() {
        var tokenInfoBuilder = com.hedera.hashgraph.sdk.proto.TokenInfo.newBuilder()
            .setTokenId(tokenId.toProtobuf())
            .setName(name)
            .setSymbol(symbol)
            .setDecimals(decimals)
            .setTotalSupply(totalSupply)
            .setTreasury(treasuryAccountId.toProtobuf())
            .setDefaultFreezeStatus(freezeStatusToProtobuf(defaultFreezeStatus))
            .setDefaultKycStatus(kycStatusToProtobuf(defaultKycStatus))
            .setDeleted(isDeleted)
            .setMemo(tokenMemo)
            .setTokenType(tokenType.code)
            .setSupplyType(supplyType.code)
            .setMaxSupply(maxSupply)
            .setPauseStatus(pauseStatusToProtobuf(pauseStatus))
            .setLedgerId(ledgerId.toByteString());
        if (adminKey != null) {
            tokenInfoBuilder.setAdminKey(adminKey.toProtobufKey());
        }
        if (kycKey != null) {
            tokenInfoBuilder.setKycKey(kycKey.toProtobufKey());
        }
        if (freezeKey != null) {
            tokenInfoBuilder.setFreezeKey(freezeKey.toProtobufKey());
        }
        if (wipeKey != null) {
            tokenInfoBuilder.setWipeKey(wipeKey.toProtobufKey());
        }
        if (supplyKey != null) {
            tokenInfoBuilder.setSupplyKey(supplyKey.toProtobufKey());
        }
        if (feeScheduleKey != null) {
            tokenInfoBuilder.setFeeScheduleKey(feeScheduleKey.toProtobufKey());
        }
        if (pauseKey != null) {
            tokenInfoBuilder.setPauseKey(pauseKey.toProtobufKey());
        }
        if (metadata != null) {
            tokenInfoBuilder.setMetadata(ByteString.copyFrom(metadata));
        }
        if (metadataKey != null) {
            tokenInfoBuilder.setMetadataKey(metadataKey.toProtobufKey());
        }
        if (autoRenewAccount != null) {
            tokenInfoBuilder.setAutoRenewAccount(autoRenewAccount.toProtobuf());
        }
        if (autoRenewPeriod != null) {
            tokenInfoBuilder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        if (expirationTime != null) {
            tokenInfoBuilder.setExpiry(InstantConverter.toProtobuf(expirationTime));
        }
        for (var fee : customFees) {
            tokenInfoBuilder.addCustomFees(fee.toProtobuf());
        }
        return TokenGetInfoResponse.newBuilder().setTokenInfo(tokenInfoBuilder).build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("name", name)
            .add("symbol", symbol)
            .add("decimals", decimals)
            .add("totalSupply", totalSupply)
            .add("treasuryAccountId", treasuryAccountId)
            .add("adminKey", adminKey)
            .add("kycKey", kycKey)
            .add("freezeKey", freezeKey)
            .add("wipeKey", wipeKey)
            .add("supplyKey", supplyKey)
            .add("feeScheduleKey", feeScheduleKey)
            .add("defaultFreezeStatus", defaultFreezeStatus)
            .add("defaultKycStatus", defaultKycStatus)
            .add("isDeleted", isDeleted)
            .add("autoRenewAccount", autoRenewAccount)
            .add("autoRenewPeriod", autoRenewPeriod)
            .add("expirationTime", expirationTime)
            .add("tokenMemo", tokenMemo)
            .add("customFees", customFees)
            .add("tokenType", tokenType)
            .add("supplyType", supplyType)
            .add("maxSupply", maxSupply)
            .add("pauseKey", pauseKey)
            .add("pauseStatus", pauseStatus)
            .add("metadata", metadata)
            .add("metadataKey", metadataKey)
            .add("ledgerId", ledgerId)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Query;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.TokenGetInfoQuery;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import io.grpc.MethodDescriptor;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nullable;

/**
 * Initializes the TokenInfoQuery object.
 */
public class TokenInfoQuery extends com.hedera.hashgraph.sdk.Query<TokenInfo, TokenInfoQuery> {
    @Nullable
    TokenId tokenId = null;

    /**
     * Constructor.
     */
    public TokenInfoQuery() {
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Sets the Token ID for which information is requested.
     *
     * @param tokenId                           The TokenId to be set
     * @return {@code this}
     */
    public TokenInfoQuery setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        this.tokenId = tokenId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = TokenGetInfoQuery.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        queryBuilder.setTokenGetInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getTokenGetInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getTokenGetInfo().getHeader();
    }

    @Override
    TokenInfo mapResponse(Response response, AccountId nodeId, Query request) {
        return TokenInfo.fromProtobuf(response.getTokenGetInfo());
    }

    @Override
    MethodDescriptor<Query, Response> getMethodDescriptor() {
        return TokenServiceGrpc.getGetTokenInfoMethod();
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `Token_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenKeyValidation.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Types of validation strategies for token keys.
 *
 */
public enum TokenKeyValidation {
    /**
     * Currently the default behaviour. It will perform all token key validations.
     */
    FULL_VALIDATION(com.hedera.hashgraph.sdk.proto.TokenKeyValidation.FULL_VALIDATION),

    /**
     * Perform no validations at all for all passed token keys.
     */
    NO_VALIDATION(com.hedera.hashgraph.sdk.proto.TokenKeyValidation.NO_VALIDATION);

    final com.hedera.hashgraph.sdk.proto.TokenKeyValidation code;

    /**
     * Constructor.
     *
     * @param code the token key validation
     */
    TokenKeyValidation(com.hedera.hashgraph.sdk.proto.TokenKeyValidation code) {
        this.code = code;
    }

    static TokenKeyValidation valueOf(com.hedera.hashgraph.sdk.proto.TokenKeyValidation code) {
        return switch (code) {
            case FULL_VALIDATION -> FULL_VALIDATION;
            case NO_VALIDATION -> NO_VALIDATION;
            default -> throw new IllegalStateException("(BUG) unhandled TokenKeyValidation");
        };
    }

    @Override
    public String toString() {
        return switch (this) {
            case FULL_VALIDATION -> "FULL_VALIDATION";
            case NO_VALIDATION -> "NO_VALIDATION";
        };
    }

    public com.hedera.hashgraph.sdk.proto.TokenKeyValidation toProtobuf() {
        return this.code;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenMintTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenMintTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * Minting fungible token allows you to increase the total supply of the
 * token. Minting a non-fungible token creates an NFT with its unique
 * metadata for the class of NFTs defined by the token ID. The Supply
 * Key must sign the transaction.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/mint-a-token">Hedera Documentation</a>
 */
public class TokenMintTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenMintTransaction> {
    @Nullable
    private TokenId tokenId = null;
    /**
     * The metadata field is specific to NFTs.
     *
     * Once an NFT is minted, the metadata cannot be changed and is immutable.
     *
     * You can use the metadata field to add a URI that contains additional
     * information about the token.
     *
     * The metadata field has a 100 byte limit.
     */
    private List<byte[]> metadataList = new ArrayList<>();
    /**
     * amount provided must be in the lowest denomination possible.
     *
     * Example: Token A has 2 decimals.
     *
     * In order to mint 100 tokens, one must provide an amount of 10000.
     *
     * In order to mint 100.55 tokens, one must provide an amount of 10055.
     */
    private long amount = 0;

    /**
     * Constructor.
     */
    public TokenMintTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenMintTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenMintTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenMintTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the amount.
     *
     * @return                          the amount to mint
     */
    public long getAmount() {
        return amount;
    }

    /**
     * Assign the amount to mint.
     *
     * @param amount                    the amount to mint
     * @return {@code this}
     */
    public TokenMintTransaction setAmount(@Nonnegative long amount) {
        requireNotFrozen();
        this.amount = amount;
        return this;
    }

    /**
     * Add to the metadata list.
     *
     * @param metadata                  the metadata 100 bytes max
     * @return {@code this}
     */
    public TokenMintTransaction addMetadata(byte[] metadata) {
        requireNotFrozen();
        Objects.requireNonNull(metadata);
        metadataList.add(metadata);
        return this;
    }

    /**
     * Extract the list of metadata byte array records.
     *
     * @return                          the metadata list
     */
    public List<byte[]> getMetadata() {
        return new ArrayList<>(metadataList);
    }

    /**
     * Assign the metadata list.
     *
     * @param metadataList              the metadata list
     * @return {@code this}
     */
    public TokenMintTransaction setMetadata(List<byte[]> metadataList) {
        requireNotFrozen();
        this.metadataList = new ArrayList<>(metadataList);
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenMint();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
        amount = body.getAmount();
        for (var metadata : body.getMetadataList()) {
            metadataList.add(metadata.toByteArray());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenMintTransactionBody}
     */
    TokenMintTransactionBody.Builder build() {
        var builder = TokenMintTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }
        builder.setAmount(amount);
        for (var metadata : metadataList) {
            builder.addMetadata(ByteString.copyFrom(metadata));
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getMintTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenMint(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenMint(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenNftAllowance.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.BoolValue;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.GrantedNftAllowance;
import com.hedera.hashgraph.sdk.proto.NftAllowance;
import com.hedera.hashgraph.sdk.proto.NftRemoveAllowance;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * Class to encapsulate the nft methods for token allowance's.
 */
public class TokenNftAllowance {

    /**
     * The NFT token type that the allowance pertains to
     */
    @Nullable
    public final TokenId tokenId;

    /**
     * The account ID of the token owner (ie. the grantor of the allowance)
     */
    @Nullable
    public final AccountId ownerAccountId;

    /**
     * The account ID of the token allowance spender
     */
    @Nullable
    public final AccountId spenderAccountId;

    /**
     * The account ID of the spender who is granted approvedForAll allowance and granting
     * approval on an NFT serial to another spender.
     */
    @Nullable AccountId delegatingSpender;

    /**
     * The list of serial numbers that the spender is permitted to transfer.
     */
    public final List<Long> serialNumbers;

    /**
     * If true, the spender has access to all of the owner's NFT units of type tokenId (currently
     * owned and any in the future).
     */
    @Nullable
    public final Boolean allSerials;

    /**
     * Constructor.
     *
     * @param tokenId                   the token id
     * @param ownerAccountId            the grantor's account id
     * @param spenderAccountId          the spender's account id
     * @param delegatingSpender         the delegating spender's account id
     * @param serialNumbers             the list of serial numbers
     * @param allSerials                grant for all serial's
     */
    TokenNftAllowance(
        @Nullable TokenId tokenId,
        @Nullable AccountId ownerAccountId,
        @Nullable AccountId spenderAccountId,
        @Nullable AccountId delegatingSpender,
        Collection<Long> serialNumbers,
        @Nullable Boolean allSerials
    ) {
        this.tokenId = tokenId;
        this.ownerAccountId = ownerAccountId;
        this.spenderAccountId = spenderAccountId;
        this.delegatingSpender = delegatingSpender;
        this.serialNumbers = new ArrayList<>(serialNumbers);
        this.allSerials = allSerials;
    }

    /**
     * Create a copy of a nft token allowance object.
     *
     * @param allowance                 the nft token allowance to copj
     * @return                          a new copy
     */
    static TokenNftAllowance copyFrom(TokenNftAllowance allowance) {
        return new TokenNftAllowance(
            allowance.tokenId,
            allowance.ownerAccountId,
            allowance.spenderAccountId,
            allowance.delegatingSpender,
            allowance.serialNumbers,
            allowance.allSerials
        );
    }

    /**
     * Create a nft token allowance from a protobuf.
     *
     * @param allowanceProto            the protobuf
     * @return                          the nft token allowance
     */
    static TokenNftAllowance fromProtobuf(NftAllowance allowanceProto) {
        return new TokenNftAllowance(
            allowanceProto.hasTokenId() ? TokenId.fromProtobuf(allowanceProto.getTokenId()) : null,
            allowanceProto.hasOwner() ? AccountId.fromProtobuf(allowanceProto.getOwner()) : null,
            allowanceProto.hasSpender() ? AccountId.fromProtobuf(allowanceProto.getSpender()) : null,
            allowanceProto.hasDelegatingSpender() ? AccountId.fromProtobuf(allowanceProto.getDelegatingSpender()) : null,
            allowanceProto.getSerialNumbersList(),
            allowanceProto.hasApprovedForAll() ? allowanceProto.getApprovedForAll().getValue() : null
        );
    }

    /**
     * Create a nft token allowance from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the nft token allowance
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenNftAllowance fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(NftAllowance.parseFrom(Objects.requireNonNull(bytes)));
    }

    /**
     * Validate the configured client.
     *
     * @param client                    the configured client
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
        if (ownerAccountId != null) {
            ownerAccountId.validateChecksum(client);
        }
        if (spenderAccountId != null) {
            spenderAccountId.validateChecksum(client);
        }
        if (delegatingSpender != null) {
            delegatingSpender.validateChecksum(client);
        }
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    NftAllowance toProtobuf() {
        var builder = NftAllowance.newBuilder();
        if (tokenId != null) {
            builder.setTokenId(tokenId.toProtobuf());
        }
        if (ownerAccountId != null) {
            builder.setOwner(ownerAccountId.toProtobuf());
        }
        if (spenderAccountId != null) {
            builder.setSpender(spenderAccountId.toProtobuf());
        }
        if (delegatingSpender != null) {
            builder.setDelegatingSpender(delegatingSpender.toProtobuf());
        }
        builder.addAllSerialNumbers(serialNumbers);
        if (allSerials != null) {
            builder.setApprovedForAll(BoolValue.newBuilder().setValue(allSerials).build());
        }
        return builder.build();
    }

    /**
     * Create the protobuf.
     *
     * @return                          the remove protobuf
     */
    NftRemoveAllowance toRemoveProtobuf() {
        var builder = NftRemoveAllowance.newBuilder();
        if (tokenId != null) {
            builder.setTokenId(tokenId.toProtobuf());
        }
        if (ownerAccountId != null) {
            builder.setOwner(ownerAccountId.toProtobuf());
        }
        builder.addAllSerialNumbers(serialNumbers);
        return builder.build();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        var stringHelper = MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("ownerAccountId", ownerAccountId)
            .add("spenderAccountId", spenderAccountId)
            .add("delegatingSpender", delegatingSpender);
        if (allSerials != null) {
            stringHelper.add("allSerials", allSerials);
        } else {
            stringHelper.add("serials", serialNumbers);
        }
        return stringHelper.toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenNftInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 *
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/token-service/tokengetnftinfo#tokennftinfo">Hedera Documentation</a>
 */
public class TokenNftInfo {
    /**
     * The ID of the NFT
     */
    public final NftId nftId;

    /**
     * The current owner of the NFT
     */
    public final AccountId accountId;

    /**
     * The effective consensus timestamp at which the NFT was minted
     */
    public final Instant creationTime;

    /**
     * Represents the unique metadata of the NFT
     */
    public final byte[] metadata;

    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    public final LedgerId ledgerId;

    /**
     * If an allowance is granted for the NFT, its corresponding spender account
     */
    @Nullable
    public final AccountId spenderId;

    /**
     * Constructor.
     *
     * @param nftId                     the id of the nft
     * @param accountId                 the current owner of the nft
     * @param creationTime              the effective consensus time
     * @param metadata                  the unique metadata
     * @param ledgerId                  the ledger id of the response
     * @param spenderId the spender of the allowance (null if not an allowance)
     */
    TokenNftInfo(
        NftId nftId,
        AccountId accountId,
        Instant creationTime,
        byte[] metadata,
        LedgerId ledgerId,
        @Nullable AccountId spenderId
    ) {
        this.nftId = nftId;
        this.accountId = accountId;
        this.creationTime = Objects.requireNonNull(creationTime);
        this.metadata = metadata;
        this.ledgerId = ledgerId;
        this.spenderId = spenderId;
    }

    /**
     * Create token nft info from a protobuf.
     *
     * @param info                      the protobuf
     * @return                          the new token nft info
     */
    static TokenNftInfo fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenNftInfo info) {
        return new TokenNftInfo(
            NftId.fromProtobuf(info.getNftID()),
            AccountId.fromProtobuf(info.getAccountID()),
            InstantConverter.fromProtobuf(info.getCreationTime()),
            info.getMetadata().toByteArray(),
            LedgerId.fromByteString(info.getLedgerId()),
            info.hasSpenderId() ? AccountId.fromProtobuf(info.getSpenderId()) : null
        );
    }

    /**
     * Create token nft info from byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new token nft info
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenNftInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenNftInfo.parseFrom(bytes));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.TokenNftInfo toProtobuf() {
        var builder = com.hedera.hashgraph.sdk.proto.TokenNftInfo.newBuilder()
            .setNftID(nftId.toProtobuf())
            .setAccountID(accountId.toProtobuf())
            .setCreationTime(InstantConverter.toProtobuf(creationTime))
            .setMetadata(ByteString.copyFrom(metadata))
            .setLedgerId(ledgerId.toByteString());
        if (spenderId != null) {
            builder.setSpenderId(spenderId.toProtobuf());
        }
        return builder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("nftId", nftId)
            .add("accountId", accountId)
            .add("creationTime", creationTime)
            .add("metadata", metadata)
            .add("ledgerId", ledgerId)
            .add("spenderId", spenderId)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenNftInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Query;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.TokenGetNftInfoQuery;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import io.grpc.MethodDescriptor;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;

/**
 * A query that returns information about a non-fungible token (NFT).
 *
 * You request the info for an NFT by specifying the NFT ID.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/get-nft-token-info#methods">Hedera Documentation</a>
 */
public class TokenNftInfoQuery extends com.hedera.hashgraph.sdk.Query<List<TokenNftInfo>, TokenNftInfoQuery> {
    /**
     * The ID of the non-fungible token in x.y.z format.
     */
    @Nullable
    private NftId nftId = null;
    @Nullable
    private TokenId tokenId = null;
    /**
     * The account ID of the current owner of the NFT
     */
    @Nullable
    private AccountId accountId = null;
    private long start = 0;
    private long end = 0;

    /**
     * Constructor.
     */
    public TokenNftInfoQuery() {
    }

    /**
     * Sets the NFT ID for which information is requested.
     *
     * @deprecated use {@link TokenNftInfoQuery#setNftId(NftId)} instead
     * @param nftId The NftId to be set
     * @return {@code this}
     */
    @Deprecated
    public TokenNftInfoQuery byNftId(NftId nftId) {
        return setNftId(nftId);
    }

    /**
     * Sets the NFT ID for which information is requested.
     *
     * @param nftId The NftId to be set
     * @return {@code this}
     */
    public TokenNftInfoQuery setNftId(NftId nftId) {
        Objects.requireNonNull(nftId);
        this.nftId = nftId;
        return this;
    }

    /**
     * Extract the nft id.
     *
     * @return                          the nft id
     */
    @Nullable
    public NftId getNftId() {
        return nftId;
    }

    /**
     * Sets the Token ID and the index range for which information is requested.
     *
     * @deprecated with no replacement
     * @param tokenId The ID of the token for which information is requested
     * @return {@code this}
     */
    @Deprecated
    public TokenNftInfoQuery byTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the token id
     *
     * @return the tokenId
     */
    @Nullable
    @Deprecated
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Sets the Account ID for which information is requested.
     *
     * @deprecated with no replacement
     * @param accountId The Account ID for which information is requested
     * @return {@code this}
     */
    @Deprecated
    public TokenNftInfoQuery byAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        this.accountId = accountId;
        return this;
    }

    /**
     * Get the Account ID for which information is requested
     *
     * @return the accountId
     */
    @Nullable
    @Deprecated
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Get the start of the index range for which information is requested
     *
     * @return the start
     */
    @Deprecated
    public long getStart() {
        return start;
    }

    /**
     * Sets the start of the index range for which information is requested.
     *
     * @deprecated with no replacement
     * @param start The start index (inclusive) of the range of NFTs to query for. Value must be in the range [0; ownedNFTs-1]
     * @return {@code this}
     */
    @Deprecated
    public TokenNftInfoQuery setStart(@Nonnegative long start) {
        this.start = start;
        return this;
    }

    /**
     * Get the end of the index range for which information is requested
     *
     * @return the end
     */
    @Deprecated
    public long getEnd() {
        return end;
    }

    /**
     * Sets the end of the index range for which information is requested.
     *
     * @deprecated with no replacement
     * @param end The end index (exclusive) of the range of NFTs to query for. Value must be in the range (start; ownedNFTs]
     * @return {@code this}
     */
    @Deprecated
    public TokenNftInfoQuery setEnd(@Nonnegative long end) {
        this.end = end;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (nftId != null) {
            nftId.tokenId.validateChecksum(client);
        }
    }

    @Override
    CompletableFuture<Void> onExecuteAsync(Client client) {
        int modesEnabled = (nftId != null ? 1 : 0) + (tokenId != null ? 1 : 0) + (accountId != null ? 1 : 0);
        if (modesEnabled > 1) {
            throw new IllegalStateException("TokenNftInfoQuery must be one of byNftId, byTokenId, or byAccountId, but multiple of these modes have been selected");
        } else if (modesEnabled == 0) {
            throw new IllegalStateException("TokenNftInfoQuery must be one of byNftId, byTokenId, or byAccountId, but none of these modes have been selected");
        }
        return super.onExecuteAsync(client);
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = TokenGetNftInfoQuery.newBuilder();
        if(nftId != null) {
            builder.setNftID(nftId.toProtobuf());
        }
        queryBuilder.setTokenGetNftInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getTokenGetNftInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getTokenGetInfo().getHeader();
    }

    @Override
    List<TokenNftInfo> mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return Collections.singletonList(TokenNftInfo.fromProtobuf(response.getTokenGetNftInfo().getNft()));
    }

    @Override
    MethodDescriptor<Query, Response> getMethodDescriptor() {
        return TokenServiceGrpc.getGetTokenNftInfoMethod();
    }

    @Override
    public CompletableFuture<Hbar> getCostAsync(Client client) {
        // deleted accounts return a COST_ANSWER of zero which triggers `INSUFFICIENT_TX_FEE`
        // if you set that as the query payment; 25 tinybar seems to be enough to get
        // `Token_DELETED` back instead.
        return super.getCostAsync(client).thenApply((cost) -> Hbar.fromTinybars(Math.max(cost.toTinybars(), 25)));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenNftTransfer.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.NftTransfer;
import com.hedera.hashgraph.sdk.proto.TokenID;
import com.hedera.hashgraph.sdk.proto.TokenTransferList;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Internal utility class.
 */
public class TokenNftTransfer implements Comparable<TokenNftTransfer> {
    /**
     * The ID of the token
     */
    public final TokenId tokenId;
    /**
     * The accountID of the sender
     */
    public final AccountId sender;
    /**
     * The accountID of the receiver
     */
    public final AccountId receiver;
    /**
     * The serial number of the NFT
     */
    public final long serial;
    /**
     * If true then the transfer is expected to be an approved allowance and the sender is expected to be the owner. The
     * default is false.
     */
    public boolean isApproved;

    /**
     * Constructor.
     *
     * @param tokenId    the token id
     * @param sender     the sender account id
     * @param receiver   the receiver account id
     * @param serial     the serial number
     * @param isApproved is it approved
     */
    TokenNftTransfer(TokenId tokenId, AccountId sender, AccountId receiver, long serial, boolean isApproved) {
        this.tokenId = tokenId;
        this.sender = sender;
        this.receiver = receiver;
        this.serial = serial;
        this.isApproved = isApproved;
    }

    /**
     * Create a list of token nft transfer records from a protobuf.
     *
     * @param tokenTransferList the protobuf
     * @return the new list
     */
    static ArrayList<TokenNftTransfer> fromProtobuf(List<TokenTransferList> tokenTransferList) {
        var transfers = new ArrayList<TokenNftTransfer>();

        for (var tokenTransfer : tokenTransferList) {
            var tokenId = TokenId.fromProtobuf(tokenTransfer.getToken());

            for (var transfer : tokenTransfer.getNftTransfersList()) {
                transfers.add(new TokenNftTransfer(
                    tokenId,
                    AccountId.fromProtobuf(transfer.getSenderAccountID()),
                    AccountId.fromProtobuf(transfer.getReceiverAccountID()),
                    transfer.getSerialNumber(),
                    transfer.getIsApproval()
                ));
            }
        }

        return transfers;
    }

    /**
     * Convert a byte array to a token NFT transfer object.
     *
     * @param bytes the byte array
     * @return the converted token nft transfer object
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    @Deprecated
    public static TokenNftTransfer fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(
            List.of(
                TokenTransferList.newBuilder()
                    .setToken(TokenID.newBuilder().build())
                    .addNftTransfers(NftTransfer.parseFrom(bytes))
                    .build()
            )
        ).get(0);
    }

    /**
     * Create the protobuf.
     *
     * @return the protobuf representation
     */
    NftTransfer toProtobuf() {
        return NftTransfer.newBuilder()
            .setSenderAccountID(sender.toProtobuf())
            .setReceiverAccountID(receiver.toProtobuf())
            .setSerialNumber(serial)
            .setIsApproval(isApproved)
            .build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("sender", sender)
            .add("receiver", receiver)
            .add("serial", serial)
            .add("isApproved", isApproved)
            .toString();
    }

    /**
     * Convert the token NFT transfer object to a byte array.
     *
     * @return the converted token NFT transfer object
     */
    @Deprecated
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public int compareTo(TokenNftTransfer o) {
        int senderComparison = sender.compareTo(o.sender);
        if (senderComparison != 0) {
            return senderComparison;
        }
        int receiverComparison = receiver.compareTo(o.receiver);
        if (receiverComparison != 0) {
            return receiverComparison;
        }
        return Long.compare(serial, o.serial);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TokenNftTransfer that = (TokenNftTransfer) o;
        return serial == that.serial && isApproved == that.isApproved && tokenId.equals(that.tokenId) && sender.equals(
            that.sender) && receiver.equals(that.receiver);
    }

    @Override
    public int hashCode() {
        return Objects.hash(tokenId, sender, receiver, serial, isApproved);
    }

}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenPauseTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenPauseTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * A token pause transaction prevents the token from being involved in any
 * kind of operation. The token's pause key is required to sign the
 * transaction. This is a key that is specified during the creation of a
 * token. If a token has no pause key, you will not be able to pause the
 * token.  If the pause key was not set during the creation of a token, you
 * will not be able to update the token to add this key.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/pause-a-token">Hedera Documentation</a>
 */
public class TokenPauseTransaction extends Transaction<TokenPauseTransaction>{
    @Nullable
    private TokenId tokenId = null;

    /**
     * Constructor.
     */
    public TokenPauseTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenPauseTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenPauseTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenPauseTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenPause();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenPauseTransactionBody}
     */
    TokenPauseTransactionBody.Builder build() {
        var builder = TokenPauseTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        return builder;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getPauseTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenPause(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenPause(build());
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenRejectFlow.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;

/**
 * Reject undesired token(s) and dissociate in a single flow.
 */
public class TokenRejectFlow {
    /**
     * An account holding the tokens to be rejected.
     */
    @Nullable
    private AccountId ownerId = null;

    /**
     * A list of one or more token rejections (a fungible/common token type).
     */
    private List<TokenId> tokenIds  = new ArrayList<>();

    /**
     * A list of one or more token rejections (a single specific serialized non-fungible/unique token).
     */
    private List<NftId> nftIds  = new ArrayList<>();

    @Nullable
    private List<AccountId> nodeAccountIds = null;

    @Nullable
    private Client freezeWithClient = null;

    @Nullable
    private PrivateKey signPrivateKey = null;

    @Nullable
    private PublicKey signPublicKey = null;

    @Nullable
    private UnaryOperator<byte[]> transactionSigner = null;

    public TokenRejectFlow() {}

    /**
     * Extract the Account ID of the Owner.
     * @return the Account ID of the Owner.
     */
    public AccountId getOwnerId() {
        return ownerId;
    }

    /**
     * Assign the Account ID of the Owner.
     * @param ownerId the Account ID of the Owner.
     * @return {@code this}
     */
    public TokenRejectFlow setOwnerId(AccountId ownerId) {
        Objects.requireNonNull(ownerId);
        this.ownerId = ownerId;
        return this;
    }

    /**
     * Extract the list of tokenIds.
     * @return the list of tokenIds.
     */
    public List<TokenId> getTokenIds() {
        return tokenIds;
    }

    /**
     * Assign the list of tokenIds.
     * @param tokenIds the list of tokenIds.
     * @return {@code this}
     */
    public TokenRejectFlow setTokenIds(List<TokenId> tokenIds) {
        Objects.requireNonNull(tokenIds);
        this.tokenIds = new ArrayList<>(tokenIds);
        return this;
    }

    /**
     * Add a token to the list of tokens.
     * @param tokenId token to add.
     * @return {@code this}
     */
    public TokenRejectFlow addTokenId(TokenId tokenId) {
        tokenIds.add(tokenId);
        return this;
    }

    /**
     * Extract the list of nftIds.
     * @return the list of nftIds.
     */
    public List<NftId> getNftIds() {
        return nftIds;
    }

    /**
     * Assign the list of nftIds.
     * @param nftIds the list of nftIds.
     * @return {@code this}
     */
    public TokenRejectFlow setNftIds(List<NftId> nftIds) {
        Objects.requireNonNull(nftIds);
        this.nftIds = new ArrayList<>(nftIds);
        return this;
    }

    /**
     * Add a nft to the list of nfts.
     * @param nftId nft to add.
     * @return {@code this}
     */
    public TokenRejectFlow addNftId(NftId nftId) {
        nftIds.add(nftId);
        return this;
    }

    /**
     * Set the account IDs of the nodes that this transaction will be submitted to.
     * <p>
     * Providing an explicit node account ID interferes with client-side load balancing of the network. By default, the
     * SDK will pre-generate a transaction for 1/3 of the nodes on the network. If a node is down, busy, or otherwise
     * reports a fatal error, the SDK will try again with a different node.
     *
     * @param nodeAccountIds The list of node AccountIds to be set
     * @return {@code this}
     */
    public TokenRejectFlow setNodeAccountIds(List<AccountId> nodeAccountIds) {
        Objects.requireNonNull(nodeAccountIds);
        this.nodeAccountIds = new ArrayList(nodeAccountIds);
        return this;
    }

    /**
     * Set the client that this transaction will be frozen with.
     *
     * @param client the client with the transaction to execute
     * @return {@code this}
     */
    public TokenRejectFlow freezeWith(Client client) {
        this.freezeWithClient = client;
        return this;
    }

    /**
     * Set the private key that this transaction will be signed with.
     *
     * @param privateKey the private key used for signing
     * @return {@code this}
     */
    public TokenRejectFlow sign(PrivateKey privateKey) {
        this.signPrivateKey = privateKey;
        this.signPublicKey = null;
        this.transactionSigner = null;
        return this;
    }

    /**
     * Set the public key and key list that this transaction will be signed with.
     *
     * @param publicKey         the public key
     * @param transactionSigner the key list
     * @return {@code this}
     */
    public TokenRejectFlow signWith(PublicKey publicKey, UnaryOperator<byte[]> transactionSigner) {
        this.signPublicKey = publicKey;
        this.transactionSigner = transactionSigner;
        this.signPrivateKey = null;
        return this;
    }

    /**
     * Set the operator that this transaction will be signed with.
     *
     * @param client the client with the transaction to execute
     * @return {@code this}
     */
    public TokenRejectFlow signWithOperator(Client client) {
        var operator = Objects.requireNonNull(client.getOperator());
        this.signPublicKey = operator.publicKey;
        this.transactionSigner = operator.transactionSigner;
        this.signPrivateKey = null;
        return this;
    }


    private void fillOutTransaction(final Transaction<?> transaction) {
        if (nodeAccountIds != null) {
            transaction.setNodeAccountIds(nodeAccountIds);
        }
        if (freezeWithClient != null) {
            transaction.freezeWith(freezeWithClient);
        }
        if (signPrivateKey != null) {
            transaction.sign(signPrivateKey);
        } else if (signPublicKey != null && transactionSigner != null) {
            transaction.signWith(signPublicKey, transactionSigner);
        }
    }

    private TokenRejectTransaction createTokenRejectTransaction() {
        var tokenRejectTransaction = new TokenRejectTransaction()
            .setOwnerId(ownerId)
            .setTokenIds(tokenIds)
            .setNftIds(nftIds);

        fillOutTransaction(tokenRejectTransaction);

        return tokenRejectTransaction;
    }

    private TokenDissociateTransaction createTokenDissociateTransaction() {
        List<TokenId> tokenIdsToReject = Stream.concat(tokenIds.stream(), nftIds.stream().map(nftId -> nftId.tokenId))
            .distinct()
            .collect(Collectors.toList());

        var tokenDissociateTransaction = new TokenDissociateTransaction()
            .setAccountId(ownerId)
            .setTokenIds(tokenIdsToReject);

        fillOutTransaction(tokenDissociateTransaction);

        return tokenDissociateTransaction;
    }

    /**
     * Execute the transactions in the flow with the passed in client.
     *
     * @param client the client with the transaction to execute
     * @return the response
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public TransactionResponse execute(Client client) throws PrecheckStatusException, TimeoutException {
        return execute(client, client.getRequestTimeout());
    }

    /**
     * Execute the transactions in the flow with the passed in client.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @return the response of TokenRejectTransaction
     * @throws PrecheckStatusException when the precheck fails
     * @throws TimeoutException        when the transaction times out
     */
    public TransactionResponse execute(Client client, Duration timeoutPerTransaction)
        throws PrecheckStatusException, TimeoutException {
        try {
            var tokenRejectTxResponse = createTokenRejectTransaction().execute(client, timeoutPerTransaction);
            tokenRejectTxResponse.getReceipt(client, timeoutPerTransaction);

            var tokenDissociateTxResponse = createTokenDissociateTransaction().execute(client, timeoutPerTransaction);
            tokenDissociateTxResponse.getReceipt(client, timeoutPerTransaction);

            return tokenRejectTxResponse;
        } catch (ReceiptStatusException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client the client with the transaction to execute
     * @return the response
     */
    public CompletableFuture<TransactionResponse> executeAsync(Client client) {
        return executeAsync(client, client.getRequestTimeout());
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @return the response
     */
    public CompletableFuture<TransactionResponse> executeAsync(Client client, Duration timeoutPerTransaction) {
        return createTokenRejectTransaction().executeAsync(client, timeoutPerTransaction)
            .thenCompose(tokenRejectResponse -> tokenRejectResponse.getReceiptQuery().executeAsync(client, timeoutPerTransaction))
            .thenCompose(receipt -> createTokenDissociateTransaction().executeAsync(client, timeoutPerTransaction));
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client   the client with the transaction to execute
     * @param callback a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, BiConsumer<TransactionResponse, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client), callback);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @param callback              a BiConsumer which handles the result or error.
     */
    public void executeAsync(Client client, Duration timeoutPerTransaction,
        BiConsumer<TransactionResponse, Throwable> callback) {
        ConsumerHelper.biConsumer(executeAsync(client, timeoutPerTransaction), callback);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client    the client with the transaction to execute
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Consumer<TransactionResponse> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client), onSuccess, onFailure);
    }

    /**
     * Execute the transactions in the flow with the passed in client asynchronously.
     *
     * @param client                the client with the transaction to execute
     * @param timeoutPerTransaction The timeout after which each transaction's execution attempt will be cancelled.
     * @param onSuccess             a Consumer which consumes the result on success.
     * @param onFailure             a Consumer which consumes the error on failure.
     */
    public void executeAsync(Client client, Duration timeoutPerTransaction, Consumer<TransactionResponse> onSuccess,
        Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(executeAsync(client, timeoutPerTransaction), onSuccess, onFailure);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenRejectTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenReference;
import com.hedera.hashgraph.sdk.proto.TokenRejectTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;

/**
 * Reject undesired token(s).<br/>
 * Transfer one or more token balances held by the requesting account to the treasury for each
 * token type.<br/>
 */
public class TokenRejectTransaction extends Transaction<TokenRejectTransaction> {

    /**
     * An account holding the tokens to be rejected.
     */
    @Nullable
    private AccountId ownerId = null;

    /**
     * A list of one or more token rejections (a fungible/common token type).
     */
    private List<TokenId> tokenIds  = new ArrayList<>();

    /**
     * A list of one or more token rejections (a single specific serialized non-fungible/unique token).
     */
    private List<NftId> nftIds  = new ArrayList<>();

    /**
     * Constructor
     */
    public TokenRejectTransaction() {}

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    TokenRejectTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenRejectTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the Account ID of the Owner.
     * @return the Account ID of the Owner.
     */
    @Nullable
    public AccountId getOwnerId() {
        return ownerId;
    }

    /**
     * Assign the Account ID of the Owner.
     * @param ownerId the Account ID of the Owner.
     * @return {@code this}
     */
    public TokenRejectTransaction setOwnerId(AccountId ownerId) {
        Objects.requireNonNull(ownerId);
        requireNotFrozen();
        this.ownerId = ownerId;
        return this;
    }

    /**
     * Extract the list of tokenIds.
     * @return the list of tokenIds.
     */
    public List<TokenId> getTokenIds() {
        return tokenIds;
    }

    /**
     * Assign the list of tokenIds.
     * @param tokenIds the list of tokenIds.
     * @return {@code this}
     */
    public TokenRejectTransaction setTokenIds(List<TokenId> tokenIds) {
        requireNotFrozen();
        Objects.requireNonNull(tokenIds);
        this.tokenIds = new ArrayList<>(tokenIds);
        return this;
    }

    /**
     * Add a token to the list of tokens.
     * @param tokenId token to add.
     * @return {@code this}
     */
    public TokenRejectTransaction addTokenId(TokenId tokenId) {
        requireNotFrozen();
        tokenIds.add(tokenId);
        return this;
    }

    /**
     * Extract the list of nftIds.
     * @return the list of nftIds.
     */
    public List<NftId> getNftIds() {
        return nftIds;
    }

    /**
     * Assign the list of nftIds.
     * @param nftIds the list of nftIds.
     * @return {@code this}
     */
    public TokenRejectTransaction setNftIds(List<NftId> nftIds) {
        requireNotFrozen();
        Objects.requireNonNull(nftIds);
        this.nftIds = new ArrayList<>(nftIds);
        return this;
    }

    /**
     * Add a nft to the list of nfts.
     * @param nftId nft to add.
     * @return {@code this}
     */
    public TokenRejectTransaction addNftId(NftId nftId) {
        requireNotFrozen();
        nftIds.add(nftId);
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenRejectTransactionBody}
     */
    TokenRejectTransactionBody.Builder build() {
        var builder = TokenRejectTransactionBody.newBuilder();

        if (ownerId != null) {
            builder.setOwner(ownerId.toProtobuf());
        }

        for (TokenId tokenId : tokenIds) {
            builder.addRejections(TokenReference.newBuilder().setFungibleToken(tokenId.toProtobuf()).build());
        }

        for (NftId nftId : nftIds) {
            builder.addRejections(TokenReference.newBuilder().setNft(nftId.toProtobuf()).build());
        }

        return builder;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenReject();
        if (body.hasOwner()) {
            ownerId = AccountId.fromProtobuf(body.getOwner());
        }

        for (TokenReference tokenReference : body.getRejectionsList()) {
            if (tokenReference.hasFungibleToken()) {
                tokenIds.add(TokenId.fromProtobuf(tokenReference.getFungibleToken()));
            } else if (tokenReference.hasNft()) {
                nftIds.add(NftId.fromProtobuf(tokenReference.getNft()));
            }
        }
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (ownerId != null) {
            ownerId.validateChecksum(client);
        }

        for (var token : tokenIds) {
            if (token != null) {
                token.validateChecksum(client);
            }
        }

        for (var nftId : nftIds) {
            nftId.tokenId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getRejectTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenReject(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenReject(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenRelationship.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.TokenFreezeStatus;
import com.hedera.hashgraph.sdk.proto.TokenKycStatus;

import javax.annotation.Nullable;

/**
 * Token's information related to the given Account.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/tokenrelationship">Hedera Documentation</a>
 */
public class TokenRelationship {
    /**
     * A unique token id
     */
    public final TokenId tokenId;
    /**
     * The Symbol of the token
     */
    public final String symbol;
    /**
     * For token of type FUNGIBLE_COMMON - the balance that the Account holds
     * in the smallest denomination.
     *
     * For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the
     * account
     */
    public final long balance;
    /**
     * The KYC status of the account (KycNotApplicable, Granted or Revoked).
     *
     * If the token does not have KYC key, KycNotApplicable is returned
     */
    @Nullable
    public final Boolean kycStatus;
    /**
     * The Freeze status of the account (FreezeNotApplicable, Frozen or
     * Unfrozen). If the token does not have Freeze key,
     * FreezeNotApplicable is returned
     */
    @Nullable
    public final Boolean freezeStatus;
    /**
     * The amount of decimal places that this token supports.
     */
    public final int decimals;
    /**
     * Specifies if the relationship is created implicitly.
     * False : explicitly associated,
     * True : implicitly associated.
     */
    public final boolean automaticAssociation;

    TokenRelationship(
        TokenId tokenId,
        String symbol,
        long balance,
        @Nullable Boolean kycStatus,
        @Nullable Boolean freezeStatus,
        int decimals,
        boolean automaticAssociation
    ) {
        this.tokenId = tokenId;
        this.symbol = symbol;
        this.balance = balance;
        this.kycStatus = kycStatus;
        this.freezeStatus = freezeStatus;
        this.decimals = decimals;
        this.automaticAssociation = automaticAssociation;
    }

    /**
     * Retrieve freeze status from a protobuf.
     *
     * @param freezeStatus              the protobuf
     * @return                          the freeze status
     */
    @Nullable
    static Boolean freezeStatusFromProtobuf(TokenFreezeStatus freezeStatus) {
        return freezeStatus == TokenFreezeStatus.FreezeNotApplicable ? null : freezeStatus == TokenFreezeStatus.Frozen;
    }

    /**
     * Retrieve the kyc status from a protobuf.
     *
     * @param kycStatus                 the protobuf
     * @return                          the kyc status
     */
    @Nullable
    static Boolean kycStatusFromProtobuf(TokenKycStatus kycStatus) {
        return kycStatus == TokenKycStatus.KycNotApplicable ? null : kycStatus == TokenKycStatus.Granted;
    }

    /**
     * Create a token relationship object from a protobuf.
     *
     * @param tokenRelationship         the protobuf
     * @return                          the new token relationship
     */
    static TokenRelationship fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenRelationship tokenRelationship) {
        return new TokenRelationship(
            TokenId.fromProtobuf(tokenRelationship.getTokenId()),
            tokenRelationship.getSymbol(),
            tokenRelationship.getBalance(),
            kycStatusFromProtobuf(tokenRelationship.getKycStatus()),
            freezeStatusFromProtobuf(tokenRelationship.getFreezeStatus()),
            tokenRelationship.getDecimals(),
            tokenRelationship.getAutomaticAssociation()
        );
    }

    /**
     * Create a token relationship from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new token relationship
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TokenRelationship fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TokenRelationship.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Retrieve the freeze status from a protobuf.
     *
     * @param freezeStatus              the protobuf
     * @return                          the freeze status
     */
    static TokenFreezeStatus freezeStatusToProtobuf(@Nullable Boolean freezeStatus) {
        return freezeStatus == null ? TokenFreezeStatus.FreezeNotApplicable : freezeStatus ? TokenFreezeStatus.Frozen : TokenFreezeStatus.Unfrozen;
    }

    /**
     * Retrieve the kyc status from a protobuf.
     *
     * @param kycStatus                 the protobuf
     * @return                          the kyc status
     */
    static TokenKycStatus kycStatusToProtobuf(@Nullable Boolean kycStatus) {
        return kycStatus == null ? TokenKycStatus.KycNotApplicable : kycStatus ? TokenKycStatus.Granted : TokenKycStatus.Revoked;
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.TokenRelationship toProtobuf() {
        return com.hedera.hashgraph.sdk.proto.TokenRelationship.newBuilder()
            .setTokenId(tokenId.toProtobuf())
            .setSymbol(symbol)
            .setBalance(balance)
            .setKycStatus(kycStatusToProtobuf(kycStatus))
            .setFreezeStatus(freezeStatusToProtobuf(freezeStatus))
            .setDecimals(decimals)
            .setAutomaticAssociation(automaticAssociation)
            .build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("symbol", symbol)
            .add("balance", balance)
            .add("kycStatus", kycStatus)
            .add("freezeStatus", freezeStatus)
            .add("decimals", decimals)
            .add("automaticAssociation", automaticAssociation)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenRevokeKycTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenRevokeKycTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Revokes the KYC flag to the Hedera account for the given Hedera token.
 * This transaction must be signed by the token's KYC Key. If this key is
 * not set, you can submit a TokenUpdateTransaction to provide the token
 * with this key.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/disable-kyc-account-flag">Hedera Documentation</a>
 */
public class TokenRevokeKycTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenRevokeKycTransaction> {
    /**
     * The token ID that is associated with the account to remove the KYC flag for
     */
    @Nullable
    private TokenId tokenId = null;
    /**
     * The account ID that is associated with the account to remove the KYC flag
     */
    @Nullable
    private AccountId accountId = null;

    /**
     * Constructor.
     */
    public TokenRevokeKycTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenRevokeKycTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenRevokeKycTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenRevokeKycTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenRevokeKycTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenRevokeKyc();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }

        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenRevokeKycTransactionBody}
     */
    TokenRevokeKycTransactionBody.Builder build() {
        var builder = TokenRevokeKycTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getFreezeTokenAccountMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenRevokeKyc(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenRevokeKyc(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenSupplyType.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Possible Token Supply Types (IWA Compatibility).
 * <p>
 * Indicates how many tokens can have during its lifetime.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/tokensupplytype">Hedera Documentation</a>
 */
public enum TokenSupplyType {
    /**
     * Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
     */
    INFINITE(com.hedera.hashgraph.sdk.proto.TokenSupplyType.INFINITE),
    /**
     * Indicates that tokens of that type have an upper bound of maxSupply, provided on token creation.
     */
    FINITE(com.hedera.hashgraph.sdk.proto.TokenSupplyType.FINITE);

    final com.hedera.hashgraph.sdk.proto.TokenSupplyType code;

    /**
     * Constructor.
     *
     * @param code the token supply type
     */
    TokenSupplyType(com.hedera.hashgraph.sdk.proto.TokenSupplyType code) {
        this.code = code;
    }

    /**
     * What type are we.
     *
     * @param code the token supply type in question
     * @return the token supply type
     */
    static TokenSupplyType valueOf(com.hedera.hashgraph.sdk.proto.TokenSupplyType code) {
        return switch (code) {
            case INFINITE -> INFINITE;
            case FINITE -> FINITE;
            default -> throw new IllegalStateException("(BUG) unhandled TokenSupplyType");
        };
    }

    @Override
    public String toString() {
        return switch (this) {
            case INFINITE -> "INFINITE";
            case FINITE -> "FINITE";
        };
    }

    public com.hedera.hashgraph.sdk.proto.TokenSupplyType toProtobuf() {
        return this.code;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenTransfer.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.hedera.hashgraph.sdk.proto.AccountAmount;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

/**
 * A token transfer record.
 *
 * Internal utility class.
 */
public class TokenTransfer {
    final TokenId tokenId;
    final AccountId accountId;

    @Nullable
    Integer expectedDecimals;
    long amount;

    boolean isApproved;

    /**
     * Constructor.
     *
     * @param tokenId                   the token id
     * @param accountId                 the account id
     * @param amount                    the amount
     * @param isApproved                is it approved
     */
    TokenTransfer(TokenId tokenId, AccountId accountId, long amount, boolean isApproved) {
        this(tokenId, accountId, amount, null, isApproved);
    }

    /**
     * Constructor.
     *
     * @param tokenId                   the token id
     * @param accountId                 the account id
     * @param amount                    the amount
     * @param expectedDecimals          the expected decimals
     * @param isApproved                is it approved
     */
    TokenTransfer(TokenId tokenId, AccountId accountId, long amount, @Nullable Integer expectedDecimals, boolean isApproved) {
        this.tokenId = tokenId;
        this.accountId = accountId;
        this.amount = amount;
        this.expectedDecimals = expectedDecimals;
        this.isApproved = isApproved;
    }

    /**
     * Create a list of token transfer records from a protobuf.
     *
     * @param tokenTransferLists        the protobuf
     * @return                          the list of token transfer records
     */
    static List<TokenTransfer> fromProtobuf(List<com.hedera.hashgraph.sdk.proto.TokenTransferList> tokenTransferLists) {
        var transfers = new ArrayList<TokenTransfer>();

        for (var tokenTransferList : tokenTransferLists) {
            var tokenId = TokenId.fromProtobuf(tokenTransferList.getToken());

            for (var transfer : tokenTransferList.getTransfersList()) {
                transfers.add(new TokenTransfer(
                    tokenId,
                    AccountId.fromProtobuf(transfer.getAccountID()),
                    transfer.getAmount(),
                    tokenTransferList.hasExpectedDecimals() ? tokenTransferList.getExpectedDecimals().getValue() : null,
                    transfer.getIsApproval()
                ));
            }
        }

        return transfers;
    }

    /**
     * Create the protobuf.
     *
     * @return                          an account amount protobuf
     */
    AccountAmount toProtobuf() {
        return AccountAmount.newBuilder()
            .setAccountID(accountId.toProtobuf())
            .setAmount(amount)
            .setIsApproval(isApproved)
            .build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("tokenId", tokenId)
            .add("accountId", accountId)
            .add("amount", amount)
            .add("expectedDecimals", expectedDecimals)
            .add("isApproved", isApproved)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenTransferList.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.UInt32Value;
import com.hedera.hashgraph.sdk.proto.AccountAmount;
import com.hedera.hashgraph.sdk.proto.NftTransfer;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;

class TokenTransferList {
    final TokenId tokenId;
    @Nullable
    final Integer expectDecimals;
    List<TokenTransfer> transfers = new ArrayList<>();
    List<TokenNftTransfer> nftTransfers = new ArrayList<>();

    TokenTransferList(TokenId tokenId, @Nullable Integer expectDecimals, @Nullable TokenTransfer transfer,
        @Nullable TokenNftTransfer nftTransfer) {
        this.tokenId = tokenId;
        this.expectDecimals = expectDecimals;

        if (transfer != null) {
            this.transfers.add(transfer);
        }

        if (nftTransfer != null) {
            this.nftTransfers.add(nftTransfer);
        }
    }

    com.hedera.hashgraph.sdk.proto.TokenTransferList toProtobuf() {
        var transfers = new ArrayList<AccountAmount>();
        var nftTransfers = new ArrayList<NftTransfer>();

        for (var transfer : this.transfers) {
            transfers.add(transfer.toProtobuf());
        }

        for (var transfer : this.nftTransfers) {
            nftTransfers.add(transfer.toProtobuf());
        }

        var builder = com.hedera.hashgraph.sdk.proto.TokenTransferList.newBuilder()
            .setToken(tokenId.toProtobuf())
            .addAllTransfers(transfers)
            .addAllNftTransfers(nftTransfers);

        if (expectDecimals != null) {
            builder.setExpectedDecimals(UInt32Value.newBuilder().setValue(expectDecimals).build());
        }

        return builder.build();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenType.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

/**
 * Possible Token Types (IWA Compatibility).
 * <p>
 * Apart from fungible and non-fungible, Tokens can have either a common or
 * unique representation. This distinction might seem subtle, but it is
 * important when considering how tokens can be traced and if they can have
 * isolated and unique properties.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/tokentype">Hedera Documentation</a>
 */
public enum TokenType {
    /**
     * Interchangeable value with one another, where any quantity of them has the same value as another equal quantity if they are in the same class.
     * Share a single set of properties, not distinct from one another. Simply represented as a balance or quantity to a given Hedera account.
     */
    FUNGIBLE_COMMON(com.hedera.hashgraph.sdk.proto.TokenType.FUNGIBLE_COMMON),
    /**
     * Unique, not interchangeable with other tokens of the same type as they typically have different values.
     * Individually traced and can carry unique properties (e.g. serial number).
     */
    NON_FUNGIBLE_UNIQUE(com.hedera.hashgraph.sdk.proto.TokenType.NON_FUNGIBLE_UNIQUE);

    final com.hedera.hashgraph.sdk.proto.TokenType code;

    /**
     * Constructor.
     *
     * @param code the token type
     */
    TokenType(com.hedera.hashgraph.sdk.proto.TokenType code) {
        this.code = code;
    }

    /**
     * What type are we.
     *
     * @param code the token type in question
     * @return the token type
     */
    static TokenType valueOf(com.hedera.hashgraph.sdk.proto.TokenType code) {
        return switch (code) {
            case FUNGIBLE_COMMON -> FUNGIBLE_COMMON;
            case NON_FUNGIBLE_UNIQUE -> NON_FUNGIBLE_UNIQUE;
            default -> throw new IllegalStateException("(BUG) unhandled TokenType");
        };
    }

    @Override
    public String toString() {
        return switch (this) {
            case FUNGIBLE_COMMON -> "FUNGIBLE_COMMON";
            case NON_FUNGIBLE_UNIQUE -> "NON_FUNGIBLE_UNIQUE";
        };
    }

    public com.hedera.hashgraph.sdk.proto.TokenType toProtobuf() {
        return this.code;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenUnfreezeTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TokenUnfreezeAccountTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Unfreezes transfers of the specified token for the account.
 *
 * The transaction must be signed by the token's Freeze Key.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/unfreeze-an-account">Hedera Documentation</a>
 */
public class TokenUnfreezeTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenUnfreezeTransaction> {
    @Nullable
    private TokenId tokenId = null;
    @Nullable
    private AccountId accountId = null;

    /**
     * Constructor.
     */
    public TokenUnfreezeTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenUnfreezeTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenUnfreezeTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenUnfreezeTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenUnfreezeTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenUnfreeze();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }

        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@code @link
     *         com.hedera.hashgraph.sdk.proto.TokenUnfreezeAccountTransactionBody}
     */
    TokenUnfreezeAccountTransactionBody.Builder build() {
        var builder = TokenUnfreezeAccountTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getFreezeTokenAccountMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenUnfreeze(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenUnfreeze(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenUnpauseTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TokenUnpauseTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * A token unpause transaction is a transaction that unpauses the token
 * that was previously disabled from participating in transactions. The
 * token's pause key is required to sign the transaction. Once the unpause
 * transaction is submitted the token pause status is updated to unpause.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/unpause-a-token">Hedera Documentation</a>
 */
public class TokenUnpauseTransaction extends Transaction<TokenUnpauseTransaction>{
    @Nullable
    private TokenId tokenId = null;

    /**
     * Constructor
     */
    public TokenUnpauseTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenUnpauseTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenUnpauseTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenUnpauseTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenUnpause();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenUnpauseTransactionBody}
     */
    TokenUnpauseTransactionBody.Builder build() {
        var builder = TokenUnpauseTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        return builder;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getUnpauseTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenUnpause(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenUnpause(build());
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenUpdateNftsTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TokenUpdateNftsTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;

public class TokenUpdateNftsTransaction extends Transaction<TokenUpdateNftsTransaction> {

    /**
     * The token for which to update NFTs.
     */
    @Nullable
    private TokenId tokenId = null;

    /**
     * The list of serial numbers to be updated.
     */
    private List<Long> serials = new ArrayList<>();

    /**
     * The new metadata of the NFT(s)
     */
    private byte[] metadata = null;

    /**
     * Constructor.
     */
    public TokenUpdateNftsTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    TokenUpdateNftsTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    TokenUpdateNftsTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId the token id
     * @return {@code this}
     */
    public TokenUpdateNftsTransaction setTokenId(@Nullable TokenId tokenId) {
        requireNotFrozen();
        Objects.requireNonNull(tokenId);
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the list of serial numbers.
     *
     * @return the list of serial numbers
     */
    public List<Long> getSerials() {
        return serials;
    }

    /**
     * Assign the list of serial numbers.
     *
     * @param serials the list of serial numbers
     * @return {@code this}
     */
    public TokenUpdateNftsTransaction setSerials(List<Long> serials) {
        requireNotFrozen();
        Objects.requireNonNull(serials);
        this.serials = new ArrayList<>(serials);
        return this;
    }

    /**
     * Add a serial number to the list of serial numbers.
     *
     * @param serial the serial number to add
     * @return {@code this}
     */
    public TokenUpdateNftsTransaction addSerial(@Nonnegative long serial) {
        requireNotFrozen();
        serials.add(serial);
        return this;
    }

    /**
     * Extract the metadata.
     *
     * @return the metadata
     */
    @Nullable
    public byte[] getMetadata() {
        return metadata;
    }

    /**
     * Assign the metadata.
     *
     * @param metadata the metadata
     * @return {@code this}
     */
    public TokenUpdateNftsTransaction setMetadata(byte[] metadata) {
        requireNotFrozen();
        this.metadata = metadata;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenUpdateNfts();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
        serials = body.getSerialNumbersList();
        if (body.hasMetadata()) {
            metadata = body.getMetadata().getValue().toByteArray();
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.TokenUpdateNftsTransactionBody}
     */
    TokenUpdateNftsTransactionBody.Builder build() {
        var builder = TokenUpdateNftsTransactionBody.newBuilder();

        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        for (var serial : serials) {
            builder.addSerialNumbers(serial);
        }

        if (metadata != null) {
            builder.setMetadata(BytesValue.of(ByteString.copyFrom(metadata)));
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getUpdateNftsMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenUpdateNfts(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenUpdateNfts(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TokenUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * A transaction that updates the properties of an existing token. The admin
 * key must sign this transaction to update any of the token properties. The
 * admin key can update exisitng keys, but cannot add new keys if they were
 * not set during the creation of the token. If no value is given for a
 * field, that field is left unchanged.
 *
 * For an immutable token (that is, a token created without an admin key),
 * only the expiry may be updated. Setting any other field, in that case,
 * will cause the transaction status to resolve to TOKEN_IS_IMMUTABlE.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/update-a-token">Hedera Documentation</a>
 */
public class TokenUpdateTransaction extends Transaction<TokenUpdateTransaction> {
    /**
     * The token's id
     */
    @Nullable
    private TokenId tokenId = null;
    /**
     * The new treasury account of the token. If the provided treasury
     * account is not existing or deleted, the response will be
     * INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token balance
     * held in the previous Treasury Account is transferred to the new one.
     */
    @Nullable
    private AccountId treasuryAccountId = null;
    /**
     * The new account which will be automatically charged to renew the
     * token's expiration, at autoRenewPeriod interval.
     */
    @Nullable
    private AccountId autoRenewAccountId = null;
    /**
     * The new name of the token. The token name is specified as a string of
     * UTF-8 characters in Unicode. UTF-8 encoding of this Unicode cannot
     * contain the 0 byte (NUL). Is not required to be unique.
     */
    private String tokenName = "";
    /**
     * The new symbol of the token. The token symbol is specified as a string
     * of UTF-8 characters in Unicode. UTF-8 encoding of this Unicode cannot
     * contain the 0 byte (NUL). Is not required to be unique.
     */
    private String tokenSymbol = "";
    /**
     * The new admin key of the token. If the token is immutable (no Admin
     * Key was assigned during token creation), the transaction will resolve
     * to TOKEN_IS_IMMUTABlE. Admin keys cannot update to add new keys that
     * were not specified during the creation of the token.
     */
    @Nullable
    private Key adminKey = null;
    /**
     * The new KYC key of the token. If the token does not have currently
     * a KYC key, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
     */
    @Nullable
    private Key kycKey = null;
    /**
     * The new freeze key of the token. If the token does not have currently
     * a freeze key, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
     */
    @Nullable
    private Key freezeKey = null;
    /**
     * The new wipe key of the token. If the token does not have currently
     * a wipe key, the transaction will resolve to TOKEN_HAS_NO_WIPE_KEY.
     */
    @Nullable
    private Key wipeKey = null;
    /**
     * The new supply key of the token. If the token does not have currently
     * a supply key, the transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
     */
    @Nullable
    private Key supplyKey = null;
    /**
     * If set, the new key to use to update the token's custom fee schedule;
     * if the token does not currently have this key, transaction will
     * resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
     */
    @Nullable
    private Key feeScheduleKey = null;
    /**
     * Update the token's existing pause key. The pause key has the ability
     * to pause or unpause a token.
     */
    @Nullable
    private Key pauseKey = null;
    /**
     * The new metadata key of the token. The metadata key has the ability to
     * change the metadata of a token (token definition, partition definition,
     * and individual NFTs). If the Token does not currently have a Metadata key,
     * the transaction will resolve to TOKEN_HAS_NO_METADATA_KEY.
     */
    @Nullable
    private Key metadataKey = null;
    /**
     * The new expiry time of the token. Expiry can be updated even if the
     * admin key is not set. If the provided expiry is earlier than the
     * current token expiry, the transaction will resolve to
     * INVALID_EXPIRATION_TIME.
     */
    @Nullable
    private Instant expirationTime = null;
    /**
     * The new interval at which the auto-renew account will be charged to
     * extend the token's expiry.
     *
     * The default auto-renew period is 131,500 minutes.
     */
    @Nullable
    private Duration autoRenewPeriod = null;
    /**
     * Short publicly visible memo about the token. No guarantee of
     * uniqueness. (100 characters max)
     */
    @Nullable
    private String tokenMemo = null;
    /**
     * Metadata of the created token definition
     */
    private byte[] tokenMetadata = null;
    /**
     * Determines whether the system should check the validity of the passed keys for update.
     * Defaults to FULL_VALIDATION;
     */
    private TokenKeyValidation tokenKeyVerificationMode = TokenKeyValidation.FULL_VALIDATION;
    /**
     * Constructor.
     */
    public TokenUpdateTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenUpdateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenUpdateTransaction setTokenId(TokenId tokenId) {
        requireNotFrozen();
        Objects.requireNonNull(tokenId);
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the token name.
     *
     * @return                          the token name
     */
    @Nullable
    public String getTokenName() {
        return tokenName;
    }

    /**
     * Assign the token name.
     *
     * @param name                      the token name
     * @return {@code this}
     */
    public TokenUpdateTransaction setTokenName(String name) {
        Objects.requireNonNull(name);
        requireNotFrozen();
        tokenName = name;
        return this;
    }

    /**
     * Extract the token symbol.
     *
     * @return                          the token symbol
     */
    public String getTokenSymbol() {
        return tokenSymbol;
    }

    /**
     * Assign the token symbol.
     *
     * @param symbol                    the token symbol
     * @return {@code this}
     */
    public TokenUpdateTransaction setTokenSymbol(String symbol) {
        Objects.requireNonNull(symbol);
        requireNotFrozen();
        tokenSymbol = symbol;
        return this;
    }

    /**
     * Extract the treasury account id.
     *
     * @return                          the treasury account id
     */
    @Nullable
    public AccountId getTreasuryAccountId() {
        return treasuryAccountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenUpdateTransaction setTreasuryAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.treasuryAccountId = accountId;
        return this;
    }

    /**
     * Extract the admin key.
     *
     * @return                          the admin key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Assign the key.
     *
     * @param key                       the key
     * @return {@code this}
     */
    public TokenUpdateTransaction setAdminKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        adminKey = key;
        return this;
    }

    /**
     * Extract the kyc key.
     *
     * @return                          the kyc key
     */
    @Nullable
    public Key getKycKey() {
        return kycKey;
    }

    /**
     * Assign the kyc key.
     *
     * @param key                       the kyc key
     * @return {@code this}
     */
    public TokenUpdateTransaction setKycKey(Key key) {
        requireNotFrozen();
        kycKey = key;
        return this;
    }

    /**
     * Extract the freeze key.
     *
     * @return                          the freeze key
     */
    @Nullable
    public Key getFreezeKey() {
        return freezeKey;
    }

    /**
     * Assign the freeze key.
     *
     * @param key                       the freeze key
     * @return {@code this}
     */
    public TokenUpdateTransaction setFreezeKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        freezeKey = key;
        return this;
    }

    /**
     * Extract the wipe key.
     *
     * @return                          the wipe key
     */
    @Nullable
    public Key getWipeKey() {
        return wipeKey;
    }

    /**
     * Assign the wipe key.
     *
     * @param key                       the wipe key
     * @return {@code this}
     */
    public TokenUpdateTransaction setWipeKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        wipeKey = key;
        return this;
    }

    /**
     * Extract the supply key.
     *
     * @return                          the supply key
     */
    @Nullable
    public Key getSupplyKey() {
        return supplyKey;
    }

    /**
     * Assign the supply key.
     *
     * @param key                       the supply key
     * @return {@code this}
     */
    public TokenUpdateTransaction setSupplyKey(Key key) {
        Objects.requireNonNull(key);
        requireNotFrozen();
        supplyKey = key;
        return this;
    }

    /**
     * Extract the fee schedule key.
     *
     * @return                          the fee schedule key
     */
    @Nullable
    public Key getFeeScheduleKey() {
        return feeScheduleKey;
    }

    /**
     * Assign the fee schedule key.
     *
     * @param key                       the fee schedule key
     * @return {@code this}
     */
    public TokenUpdateTransaction setFeeScheduleKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        feeScheduleKey = key;
        return this;
    }

    /**
     * Extract the pause key.
     *
     * @return                          the pause key
     */
    @Nullable
    public Key getPauseKey() {
        return pauseKey;
    }

    /**
     * Assign the pause key.
     *
     * @param key                       the pause key
     * @return {@code this}
     */
    public TokenUpdateTransaction setPauseKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        pauseKey = key;
        return this;
    }

    /**
     * Extract the metadata key.
     *
     * @return                          the metadata key
     */
    @Nullable
    public Key getMetadataKey() {
        return metadataKey;
    }

    /**
     * Assign the metadata key.
     *
     * @param key                       the metadata key
     * @return {@code this}
     */
    public TokenUpdateTransaction setMetadataKey(Key key) {
        requireNotFrozen();
        Objects.requireNonNull(key);
        metadataKey = key;
        return this;
    }

    /**
     * Extract the expiration time.
     *
     * @return                          the expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Assign the expiration time.
     *
     * @param expirationTime            the expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public TokenUpdateTransaction setExpirationTime(Instant expirationTime) {
        Objects.requireNonNull(expirationTime);
        requireNotFrozen();
        autoRenewPeriod = null;
        this.expirationTime = expirationTime;
        return this;
    }

    /**
     * Extract the auto renew account id.
     *
     * @return                          the auto renew account id
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * Assign the auto renew account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenUpdateTransaction setAutoRenewAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.autoRenewAccountId = accountId;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Assign the auto renew period.
     *
     * @param period                    the auto renew period
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public TokenUpdateTransaction setAutoRenewPeriod(Duration period) {
        Objects.requireNonNull(period);
        requireNotFrozen();
        autoRenewPeriod = period;
        return this;
    }

    /**
     * Extract the token memo.
     *
     * @return                          the token memo
     */
    @Nullable
    public String getTokenMemo() {
        return tokenMemo;
    }

    /**
     * Assign the token memo.
     *
     * @param memo                      the token memo 100 bytes max
     * @return {@code this}
     */
    public TokenUpdateTransaction setTokenMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        tokenMemo = memo;
        return this;
    }

    /**
     * Remove the token memo.
     *
     * @return {@code this}
     */
    public TokenUpdateTransaction clearMemo() {
        requireNotFrozen();
        tokenMemo = "";
        return this;
    }

    /**
     * Extract the metadata.
     *
     * @return the metadata
     */
    @Nullable
    public byte[] getTokenMetadata() {
        return tokenMetadata;
    }

    /**
     * Assign the metadata.
     *
     * @param tokenMetadata the metadata
     * @return {@code this}
     */
    public TokenUpdateTransaction setTokenMetadata(byte[] tokenMetadata) {
        requireNotFrozen();
        this.tokenMetadata = tokenMetadata;
        return this;
    }

    /**
     * Extract the key verification mode
     *
     * @return the key verification mode
     */
    public TokenKeyValidation getKeyVerificationMode() {
        return tokenKeyVerificationMode;
    }

    /**
     * Assign the key verification mode.
     *
     * @param tokenKeyVerificationMode the key verification mode
     * @return {@code this}
     */
    public TokenUpdateTransaction setKeyVerificationMode(TokenKeyValidation tokenKeyVerificationMode) {
        requireNotFrozen();
        Objects.requireNonNull(tokenKeyVerificationMode);
        this.tokenKeyVerificationMode = tokenKeyVerificationMode;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenUpdate();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }
        if (body.hasTreasury()) {
            treasuryAccountId = AccountId.fromProtobuf(body.getTreasury());
        }
        if (body.hasAutoRenewAccount()) {
            autoRenewAccountId = AccountId.fromProtobuf(body.getAutoRenewAccount());
        }
        tokenName = body.getName();
        tokenSymbol = body.getSymbol();
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        if (body.hasKycKey()) {
            kycKey = Key.fromProtobufKey(body.getKycKey());
        }
        if (body.hasFreezeKey()) {
            freezeKey = Key.fromProtobufKey(body.getFreezeKey());
        }
        if (body.hasWipeKey()) {
            wipeKey = Key.fromProtobufKey(body.getWipeKey());
        }
        if (body.hasSupplyKey()) {
            supplyKey = Key.fromProtobufKey(body.getSupplyKey());
        }
        if (body.hasFeeScheduleKey()) {
            feeScheduleKey = Key.fromProtobufKey(body.getFeeScheduleKey());
        }
        if (body.hasPauseKey()) {
            pauseKey = Key.fromProtobufKey(body.getPauseKey());
        }
        if (body.hasMetadataKey()) {
            metadataKey = Key.fromProtobufKey(body.getMetadataKey());
        }
        if (body.hasExpiry()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpiry());
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        if (body.hasMemo()) {
            tokenMemo = body.getMemo().getValue();
        }
        if (body.hasMetadata()) {
            tokenMetadata = body.getMetadata().getValue().toByteArray();
        }
        tokenKeyVerificationMode = TokenKeyValidation.valueOf(body.getKeyVerificationMode());
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenUpdateTransactionBody}
     */
    TokenUpdateTransactionBody.Builder build() {
        var builder = TokenUpdateTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }
        if (treasuryAccountId != null) {
            builder.setTreasury(treasuryAccountId.toProtobuf());
        }

        if (autoRenewAccountId != null) {
            builder.setAutoRenewAccount(autoRenewAccountId.toProtobuf());
        }
        builder.setName(tokenName);
        builder.setSymbol(tokenSymbol);
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        if (kycKey != null) {
            builder.setKycKey(kycKey.toProtobufKey());
        }
        if (freezeKey != null) {
            builder.setFreezeKey(freezeKey.toProtobufKey());
        }
        if (wipeKey != null) {
            builder.setWipeKey(wipeKey.toProtobufKey());
        }
        if (supplyKey != null) {
            builder.setSupplyKey(supplyKey.toProtobufKey());
        }
        if (feeScheduleKey != null) {
            builder.setFeeScheduleKey(feeScheduleKey.toProtobufKey());
        }
        if (pauseKey != null) {
            builder.setPauseKey(pauseKey.toProtobufKey());
        }
        if (metadataKey != null) {
            builder.setMetadataKey(metadataKey.toProtobufKey());
        }
        if (expirationTime != null) {
            builder.setExpiry(InstantConverter.toProtobuf(expirationTime));
        }
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        if (tokenMemo != null) {
            builder.setMemo(StringValue.of(tokenMemo));
        }
        if (tokenMetadata != null) {
            builder.setMetadata(BytesValue.of(ByteString.copyFrom(tokenMetadata)));
        }
        builder.setKeyVerificationMode(tokenKeyVerificationMode.code);

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        if (treasuryAccountId != null) {
            treasuryAccountId.validateChecksum(client);
        }

        if (autoRenewAccountId != null) {
            autoRenewAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getUpdateTokenMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenUpdate(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenUpdate(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TokenWipeTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TokenWipeAccountTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

/**
 * Wipes the provided amount of fungible or non-fungible tokens from the
 * specified Hedera account. This transaction does not delete tokens from the
 * treasury account. This transaction must be signed by the token's Wipe Key.
 * Wiping an account's tokens burns the tokens and decreases the total supply.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks/tokens/wipe-a-token">Hedera Documentation</a>
 */
public class TokenWipeTransaction extends com.hedera.hashgraph.sdk.Transaction<TokenWipeTransaction> {
    /**
     * The ID of the token to wipe from the account
     */
    @Nullable
    private TokenId tokenId = null;
    /**
     * Applicable to tokens of type NON_FUNGIBLE_UNIQUE.
     * The account ID to wipe the NFT from.
     */
    @Nullable
    private AccountId accountId = null;
    /**
     * Applicable to tokens of type  FUNGIBLE_COMMON.The amount of token
     * to wipe from the specified account. The amount must be a positive
     * non-zero number in the lowest denomination possible, not bigger
     * than the token balance of the account.
     */
    private long amount = 0;
    /**
     * Applicable to tokens of type NON_FUNGIBLE_UNIQUE.
     * The list of NFTs to wipe.
     */
    private List<Long> serials = new ArrayList<>();

    /**
     * Constructor.
     */
    public TokenWipeTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TokenWipeTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TokenWipeTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the token id.
     *
     * @return                          the token id
     */
    @Nullable
    public TokenId getTokenId() {
        return tokenId;
    }

    /**
     * Assign the token id.
     *
     * @param tokenId                   the token id
     * @return {@code this}
     */
    public TokenWipeTransaction setTokenId(TokenId tokenId) {
        Objects.requireNonNull(tokenId);
        requireNotFrozen();
        this.tokenId = tokenId;
        return this;
    }

    /**
     * Extract the account id.
     *
     * @return                          the account id
     */
    @Nullable
    public AccountId getAccountId() {
        return accountId;
    }

    /**
     * Assign the account id.
     *
     * @param accountId                 the account id
     * @return {@code this}
     */
    public TokenWipeTransaction setAccountId(AccountId accountId) {
        Objects.requireNonNull(accountId);
        requireNotFrozen();
        this.accountId = accountId;
        return this;
    }

    /**
     * Extract the amount.
     *
     * @return                          the amount
     */
    public long getAmount() {
        return amount;
    }

    /**
     * Assign the amount.
     *
     * @param amount                    the amount
     * @return {@code this}
     */
    public TokenWipeTransaction setAmount(@Nonnegative long amount) {
        requireNotFrozen();
        this.amount = amount;
        return this;
    }

    /**
     * Extract the list of serial numbers.
     *
     * @return                          the list of serial numbers
     */
    public List<Long> getSerials() {
        return new ArrayList<>(serials);
    }

    /**
     * Assign the list of serial numbers.
     *
     * @param serials                   the list of serial numbers
     * @return {@code this}
     */
    public TokenWipeTransaction setSerials(List<Long> serials) {
        requireNotFrozen();
        Objects.requireNonNull(serials);
        this.serials = new ArrayList<>(serials);
        return this;
    }

    /**
     * Add a serial number to the list of serial numbers.
     *
     * @param serial                    the serial number to add
     * @return {@code this}
     */
    public TokenWipeTransaction addSerial(@Nonnegative long serial) {
        requireNotFrozen();
        serials.add(serial);
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getTokenWipe();
        if (body.hasToken()) {
            tokenId = TokenId.fromProtobuf(body.getToken());
        }

        if (body.hasAccount()) {
            accountId = AccountId.fromProtobuf(body.getAccount());
        }
        amount = body.getAmount();
        serials = body.getSerialNumbersList();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TokenWipeAccountTransactionBody}
     */
    TokenWipeAccountTransactionBody.Builder build() {
        var builder = TokenWipeAccountTransactionBody.newBuilder();
        if (tokenId != null) {
            builder.setToken(tokenId.toProtobuf());
        }

        if (accountId != null) {
            builder.setAccount(accountId.toProtobuf());
        }
        builder.setAmount(amount);
        for (var serial : serials) {
            builder.addSerialNumbers(serial);
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (tokenId != null) {
            tokenId.validateChecksum(client);
        }

        if (accountId != null) {
            accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return TokenServiceGrpc.getWipeTokenAccountMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setTokenWipe(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setTokenWipe(build());
    }
}

// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicCreateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ConsensusCreateTopicTransactionBody;
import com.hedera.hashgraph.sdk.proto.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Create a topic to be used for consensus.
 * <p>
 * If an autoRenewAccount is specified, that account must also sign this transaction.
 * <p>
 * If an adminKey is specified, the adminKey must sign the transaction.
 * <p>
 * On success, the resulting TransactionReceipt contains the newly created TopicId.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/consensus-service/consensus-service">Hedera Documentation</a>
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/consensus-service/consensuscreatetopic">Hedera Documentation</a>
 */
public final class TopicCreateTransaction extends Transaction<TopicCreateTransaction> {
    /**
     * Optional account to be used at the topic's expirationTime to extend
     * the life of the topic (once autoRenew functionality is supported by
     * HAPI).
     *
     * The topic lifetime will be extended up to a maximum of the
     * autoRenewPeriod or however long the topic can be extended using all
     * funds on the account (whichever is the smaller duration/amount and
     * if any extension is possible with the account's funds).
     * If specified, there must be an adminKey and the autoRenewAccount
     * must sign this transaction.
     */
    @Nullable
    private AccountId autoRenewAccountId = null;
    /**
     * The initial lifetime of the topic and the amount of time to attempt
     * to extend the topic's lifetime by,automatically at the topic's
     * expirationTime if the autoRenewAccount is configured (once autoRenew
     * functionality is supported by HAPI). Limited to MIN_AUTORENEW_PERIOD
     * and MAX_AUTORENEW_PERIOD value by server-side configuration.
     * Required.
     */
    @Nullable
    private Duration autoRenewPeriod = null;
    /**
     * Short publicly visible memo about the topic.
     *
     * No guarantee of uniqueness.
     *
     * 100 bytes max.
     */
    private String topicMemo = "";
    /**
     * Access control for updateTopic/deleteTopic. Anyone can increase the
     * topic's expirationTime via ConsensusService.updateTopic(), regardless
     * of the adminKey. If no adminKey is specified, updateTopic may only be
     * used to extend the topic's expirationTime, and deleteTopic is disallowed.
     */
    @Nullable
    private Key adminKey = null;
    /**
     * Access control for submitMessage. If unspecified, no access control
     * is performed on ConsensusService.submitMessage (all submissions are
     * allowed).
     */
    @Nullable
    private Key submitKey = null;

    /**
     * Constructor.
     */
    public TopicCreateTransaction() {
        setAutoRenewPeriod(DEFAULT_AUTO_RENEW_PERIOD);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TopicCreateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TopicCreateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the topic memo.
     *
     * @return                          the topic memo
     */
    public String getTopicMemo() {
        return topicMemo;
    }

    /**
     * Set a short publicly visible memo on the new topic.
     *
     * @param memo The memo to be set
     * @return {@code this}
     */
    public TopicCreateTransaction setTopicMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        topicMemo = memo;
        return this;
    }

    /**
     * Extract the admin key.
     *
     * @return                          the admin key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Set the admin key for the new topic.
     * <p>
     * Access control for updateTopic/deleteTopic.
     * <p>
     * Anyone can increase the topic's expirationTime regardless of the adminKey.
     * If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic
     * is disallowed.
     *
     * @param adminKey The Key to be set
     * @return {@code this}
     */
    public TopicCreateTransaction setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        requireNotFrozen();
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Extract the submit key.
     *
     * @return                          the submit key
     */
    @Nullable
    public Key getSubmitKey() {
        return submitKey;
    }

    /**
     * Set the submit key for the new topic.
     * <p>
     * Access control for submitMessage.
     * If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).
     *
     * @param submitKey The Key to be set
     * @return {@code this}
     */
    public TopicCreateTransaction setSubmitKey(Key submitKey) {
        Objects.requireNonNull(submitKey);
        requireNotFrozen();
        this.submitKey = submitKey;
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Set the auto renew period for the new topic.
     * <p>
     * The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by
     * automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
     * is supported by HAPI).
     *
     * @param autoRenewPeriod The Duration to be set for auto renewal
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public TopicCreateTransaction setAutoRenewPeriod(Duration autoRenewPeriod) {
        Objects.requireNonNull(autoRenewPeriod);
        requireNotFrozen();
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * Extract the auto renew account id.
     *
     * @return                          the auto renew account id
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * Set the ID of the auto renew account for the new topic.
     * <p>
     * Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew
     * functionality is supported by HAPI).
     * <p>
     * The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
     * can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
     * is possible with the account's funds).
     * <p>
     * If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
     *
     * @param autoRenewAccountId The AccountId to be set for auto renewal
     * @return {@code this}
     */
    public TopicCreateTransaction setAutoRenewAccountId(AccountId autoRenewAccountId) {
        Objects.requireNonNull(autoRenewAccountId);
        requireNotFrozen();
        this.autoRenewAccountId = autoRenewAccountId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getConsensusCreateTopic();
        if (body.hasAutoRenewAccount()) {
            autoRenewAccountId = AccountId.fromProtobuf(body.getAutoRenewAccount());
        }
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        if (body.hasSubmitKey()) {
            submitKey = Key.fromProtobufKey(body.getSubmitKey());
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        topicMemo = body.getMemo();
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.ConsensusCreateTopicTransactionBody}
     */
    ConsensusCreateTopicTransactionBody.Builder build() {
        var builder = ConsensusCreateTopicTransactionBody.newBuilder();
        if (autoRenewAccountId != null) {
            builder.setAutoRenewAccount(autoRenewAccountId.toProtobuf());
        }
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        if (submitKey != null) {
            builder.setSubmitKey(submitKey.toProtobufKey());
        }
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        builder.setMemo(topicMemo);

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (autoRenewAccountId != null) {
            autoRenewAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ConsensusServiceGrpc.getCreateTopicMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setConsensusCreateTopic(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setConsensusCreateTopic(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicDeleteTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ConsensusDeleteTopicTransactionBody;
import com.hedera.hashgraph.sdk.proto.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Delete a topic.
 * <p>
 * No more transactions or queries on the topic will succeed.
 * <p>
 * If an {@code adminKey} is set, this transaction must be signed by that key.
 * If there is no {@code adminKey}, this transaction will fail with {@link Status#UNAUTHORIZED}.
 */
public final class TopicDeleteTransaction extends Transaction<TopicDeleteTransaction> {
    @Nullable
    private TopicId topicId = null;

    /**
     * Constructor.
     */
    public TopicDeleteTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TopicDeleteTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TopicDeleteTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the topic id.
     *
     * @return                          the topic id
     */
    @Nullable
    public TopicId getTopicId() {
        return topicId;
    }

    /**
     * Set the topic ID to delete.
     *
     * @param topicId The TopicId to be set
     * @return {@code this}
     */
    public TopicDeleteTransaction setTopicId(TopicId topicId) {
        Objects.requireNonNull(topicId);
        requireNotFrozen();
        this.topicId = topicId;
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getConsensusDeleteTopic();
        if (body.hasTopicID()) {
            topicId = TopicId.fromProtobuf(body.getTopicID());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.ConsensusDeleteTopicTransactionBody}
     */
    ConsensusDeleteTopicTransactionBody.Builder build() {
        var builder = ConsensusDeleteTopicTransactionBody.newBuilder();
        if (topicId != null) {
            builder.setTopicID(topicId.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (topicId != null) {
            topicId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ConsensusServiceGrpc.getDeleteTopicMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setConsensusDeleteTopic(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setConsensusDeleteTopic(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.TopicID;

import javax.annotation.Nonnegative;
import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Unique identifier for a topic (used by the consensus service).
 */
public final class TopicId implements Comparable<TopicId> {
    /**
     * The shard number
     */
    @Nonnegative
    public final long shard;

    /**
     * The realm number
     */
    @Nonnegative
    public final long realm;

    /**
     * The id number
     */
    @Nonnegative
    public final long num;

    @Nullable
    private final String checksum;

    /**
     * Constructor.
     *
     * @param num                       the num part
     */
    public TopicId(@Nonnegative long num) {
        this(0, 0, num);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @param num                       the num part
     */
    @SuppressWarnings("InconsistentOverloads")
    public TopicId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num) {
        this(shard, realm, num, null);
    }

    /**
     * Constructor.
     *
     * @param shard                     the shard part
     * @param realm                     the realm part
     * @param num                       the num part
     * @param checksum                  the checksum
     */
    @SuppressWarnings("InconsistentOverloads")
    TopicId(@Nonnegative long shard, @Nonnegative long realm, @Nonnegative long num, @Nullable String checksum) {
        this.shard = shard;
        this.realm = realm;
        this.num = num;
        this.checksum = checksum;
    }

    /**
     * Create a topic id from a string.
     *
     * @param id                        the string representation
     * @return                          the new topic id
     */
    public static TopicId fromString(String id) {
        return EntityIdHelper.fromString(id, TopicId::new);
    }

    /**
     * Create a topic id from a solidity address.
     *
     * @param address                   the solidity address
     * @return                          the new topic id
     */
    public static TopicId fromSolidityAddress(String address) {
        return EntityIdHelper.fromSolidityAddress(address, TopicId::new);
    }

    /**
     * Create a topic id from a protobuf.
     *
     * @param topicId                   the protobuf
     * @return                          the new topic id
     */
    static TopicId fromProtobuf(TopicID topicId) {
        Objects.requireNonNull(topicId);

        return new TopicId(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum());
    }

    /**
     * Create a topic id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new topic id
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TopicId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(TopicID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the solidity address representation.
     *
     * @return                          the solidity address representation
     */
    public String toSolidityAddress() {
        return EntityIdHelper.toSolidityAddress(shard, realm, num);
    }

    /**
     * Extracts a protobuf representing the token id.
     *
     * @return                          the protobuf representation
     */
    TopicID toProtobuf() {
        return TopicID.newBuilder()
            .setShardNum(shard)
            .setRealmNum(realm)
            .setTopicNum(num)
            .build();
    }

    /**
     * @param client to validate against
     * @throws BadEntityIdException if entity ID is formatted poorly
     * @deprecated Use {@link #validateChecksum(Client)} instead.
     */
    @Deprecated
    public void validate(Client client) throws BadEntityIdException {
        validateChecksum(client);
    }

    /**
     * Verify that the client has a valid checksum.
     *
     * @param client                    the client to verify
     * @throws BadEntityIdException     if entity ID is formatted poorly
     */
    public void validateChecksum(Client client) throws BadEntityIdException {
        EntityIdHelper.validate(shard, realm, num, client, checksum);
    }

    /**
     * Extracts the checksum.
     *
     * @return                          the checksum
     */
    @Nullable
    public String getChecksum() {
        return checksum;
    }

    /**
     * Extracts a byte array representation.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public String toString() {
        return EntityIdHelper.toString(shard, realm, num);
    }

    /**
     * Create a string representation that includes the checksum.
     *
     * @param client                    the client
     * @return                          the string representation with the checksum
     */
    public String tostringwithchecksum(Client client) {
        return EntityIdHelper.toStringWithChecksum(shard, realm, num, client, checksum);
    }

    @Override
    public int hashCode() {
        return Objects.hash(shard, realm, num);
    }

    @Override
    public boolean equals( Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof TopicId)) {
            return false;
        }

        TopicId otherId = (TopicId) o;
        return shard == otherId.shard && realm == otherId.realm && num == otherId.num;
    }

    @Override
    public int compareTo(TopicId o) {
        Objects.requireNonNull(o);
        int shardComparison = Long.compare(shard, o.shard);
        if (shardComparison != 0) {
            return shardComparison;
        }
        int realmComparison = Long.compare(realm, o.realm);
        if (realmComparison != 0) {
            return realmComparison;
        }
        return Long.compare(num, o.num);
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicInfo.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ConsensusGetTopicInfoResponse;
import com.hedera.hashgraph.sdk.proto.ConsensusTopicInfo;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;

/**
 * Current state of a topic.
 */
public final class TopicInfo {
    /**
     * The ID of the topic for which information is requested.
     */
    public final TopicId topicId;

    /**
     * Short publicly visible memo about the topic. No guarantee of uniqueness.
     */
    public final String topicMemo;

    /**
     * SHA-384 running hash of (previousRunningHash, topicId, consensusTimestamp, sequenceNumber, message).
     */
    public final ByteString runningHash;

    /**
     * Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
     */
    public final long sequenceNumber;

    /**
     * Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic.
     */
    public final Instant expirationTime;

    /**
     * Access control for update/delete of the topic. Null if there is no key.
     */
    @Nullable
    public final Key adminKey;

    /**
     * Access control for ConsensusService.submitMessage. Null if there is no key.
     */
    @Nullable
    public final Key submitKey;

    /**
     * If an auto-renew account is specified, when the topic expires, its lifetime will be extended
     * by up to this duration (depending on the solvency of the auto-renew account). If the
     * auto-renew account has no funds at all, the topic will be deleted instead.
     */
    public final Duration autoRenewPeriod;

    /**
     * The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry.
     */
    @Nullable
    public final AccountId autoRenewAccountId;

    /**
     * The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
     */
    public final LedgerId ledgerId;

    private TopicInfo(
        TopicId topicId,
        String topicMemo,
        ByteString runningHash,
        long sequenceNumber,
        Instant expirationTime,
        @Nullable Key adminKey,
        @Nullable Key submitKey,
        Duration autoRenewPeriod,
        @Nullable AccountId autoRenewAccountId,
        LedgerId ledgerId
    ) {
        this.topicId = topicId;
        this.topicMemo = topicMemo;
        this.runningHash = runningHash;
        this.sequenceNumber = sequenceNumber;
        this.expirationTime = expirationTime;
        this.adminKey = adminKey;
        this.submitKey = submitKey;
        this.autoRenewPeriod = autoRenewPeriod;
        this.autoRenewAccountId = autoRenewAccountId;
        this.ledgerId = ledgerId;
    }

    /**
     * Create a topic info object from a protobuf.
     *
     * @param topicInfoResponse         the protobuf
     * @return                          the new topic info object
     */
    static TopicInfo fromProtobuf(ConsensusGetTopicInfoResponse topicInfoResponse) {
        var topicInfo = topicInfoResponse.getTopicInfo();

        var adminKey = topicInfo.hasAdminKey()
            ? Key.fromProtobufKey(topicInfo.getAdminKey())
            : null;

        var submitKey = topicInfo.hasSubmitKey()
            ? Key.fromProtobufKey(topicInfo.getSubmitKey())
            : null;

        var autoRenewAccountId = topicInfo.hasAutoRenewAccount()
            ? AccountId.fromProtobuf(topicInfo.getAutoRenewAccount())
            : null;

        return new TopicInfo(
            TopicId.fromProtobuf(topicInfoResponse.getTopicID()),
            topicInfo.getMemo(),
            topicInfo.getRunningHash(),
            topicInfo.getSequenceNumber(),
            InstantConverter.fromProtobuf(topicInfo.getExpirationTime()),
            adminKey,
            submitKey,
            DurationConverter.fromProtobuf(topicInfo.getAutoRenewPeriod()),
            autoRenewAccountId,
            LedgerId.fromByteString(topicInfo.getLedgerId())
        );
    }

    /**
     * Create a topic info object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new topic info object
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TopicInfo fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(ConsensusGetTopicInfoResponse.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    ConsensusGetTopicInfoResponse toProtobuf() {
        var topicInfoResponseBuilder = ConsensusGetTopicInfoResponse.newBuilder()
            .setTopicID(topicId.toProtobuf());

        var topicInfoBuilder = ConsensusTopicInfo.newBuilder()
            .setMemo(topicMemo)
            .setRunningHash(runningHash)
            .setSequenceNumber(sequenceNumber)
            .setExpirationTime(InstantConverter.toProtobuf(expirationTime))
            .setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod))
            .setLedgerId(ledgerId.toByteString());

        if (adminKey != null) {
            topicInfoBuilder.setAdminKey(adminKey.toProtobufKey());
        }

        if (submitKey != null) {
            topicInfoBuilder.setSubmitKey(submitKey.toProtobufKey());
        }

        if (autoRenewAccountId != null) {
            topicInfoBuilder.setAutoRenewAccount(autoRenewAccountId.toProtobuf());
        }

        return topicInfoResponseBuilder.setTopicInfo(topicInfoBuilder).build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("topicId", topicId)
            .add("topicMemo", topicMemo)
            .add("runningHash", runningHash.toByteArray())
            .add("sequenceNumber", sequenceNumber)
            .add("expirationTime", expirationTime)
            .add("adminKey", adminKey)
            .add("submitKey", submitKey)
            .add("autoRenewPeriod", autoRenewPeriod)
            .add("autoRenewAccountId", autoRenewAccountId)
            .add("ledgerId", ledgerId)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicInfoQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ConsensusGetTopicInfoQuery;
import com.hedera.hashgraph.sdk.proto.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.Objects;

/**
 * Retrieve the latest state of a topic.
 * <p>
 * This method is unrestricted and allowed on any topic by any payer account.
 */
public final class TopicInfoQuery extends Query<TopicInfo, TopicInfoQuery> {
    @Nullable
    TopicId topicId = null;

    /**
     * Constructor.
     */
    public TopicInfoQuery() {
    }

    /**
     * Extract the topic id.
     *
     * @return                          the topic id
     */
    @Nullable
    public TopicId getTopicId() {
        return topicId;
    }

    /**
     * Set the topic to retrieve info about (the parameters and running state of).
     *
     * @param topicId The TopicId to be set
     * @return {@code this}
     */
    public TopicInfoQuery setTopicId(TopicId topicId) {
        Objects.requireNonNull(topicId);
        this.topicId = topicId;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (topicId != null) {
            topicId.validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = ConsensusGetTopicInfoQuery.newBuilder();
        if (topicId != null) {
            builder.setTopicID(topicId.toProtobuf());
        }

        queryBuilder.setConsensusGetTopicInfo(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getConsensusGetTopicInfo().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getConsensusGetTopicInfo().getHeader();
    }

    @Override
    TopicInfo mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        return TopicInfo.fromProtobuf(response.getConsensusGetTopicInfo());
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return ConsensusServiceGrpc.getGetTopicInfoMethod();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicMessage.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicResponse;
import java.time.Instant;

import javax.annotation.Nullable;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.List;

/**
 * Topic message records.
 */
public final class TopicMessage {
    /**
     * The consensus timestamp of the message in seconds.nanoseconds
     */
    public final Instant consensusTimestamp;
    /**
     * The content of the message
     */
    public final byte[] contents;
    /**
     * The new running hash of the topic that received the message
     */
    public final byte[] runningHash;
    /**
     * The sequence number of the message relative to all other messages
     * for the same topic
     */
    public final long sequenceNumber;
    /**
     * Array of topic message chunks.
     */
    @Nullable
    public final TopicMessageChunk[] chunks;
    /**
     * The transaction id
     */
    @Nullable
    public final TransactionId transactionId;

    /**
     * Constructor.
     *
     * @param lastConsensusTimestamp    the last consensus time
     * @param message                   the message
     * @param lastRunningHash           the last running hash
     * @param lastSequenceNumber        the last sequence number
     * @param chunks                    the array of chunks
     * @param transactionId             the transaction id
     */
    TopicMessage(
        Instant lastConsensusTimestamp,
        byte[] message,
        byte[] lastRunningHash,
        long lastSequenceNumber,
        @Nullable TopicMessageChunk[] chunks,
        @Nullable TransactionId transactionId
    ) {
        this.consensusTimestamp = lastConsensusTimestamp;
        this.contents = message;
        this.runningHash = lastRunningHash;
        this.sequenceNumber = lastSequenceNumber;
        this.chunks = chunks;
        this.transactionId = transactionId;
    }

    /**
     * Create a new topic message from a response protobuf.
     *
     * @param response                  the protobuf response
     * @return                          the new topic message
     */
    static TopicMessage ofSingle(ConsensusTopicResponse response) {
        return new TopicMessage(
            InstantConverter.fromProtobuf(response.getConsensusTimestamp()),
            response.getMessage().toByteArray(),
            response.getRunningHash().toByteArray(),
            response.getSequenceNumber(),
            new TopicMessageChunk[]{new TopicMessageChunk(response)},
            response.hasChunkInfo() && response.getChunkInfo().hasInitialTransactionID() ?
                TransactionId.fromProtobuf(response.getChunkInfo().getInitialTransactionID()) :
                null
        );
    }

    /**
     * Create a new topic message from a list of response's protobuf.
     *
     * @param responses                 the protobuf response
     * @return                          the new topic message
     */
    static TopicMessage ofMany(List<ConsensusTopicResponse> responses) {
        // response should be in the order of oldest to newest (not chunk order)
        var chunks = new TopicMessageChunk[responses.size()];
        @Var TransactionId transactionId = null;
        var contents = new ByteString[responses.size()];
        @Var long totalSize = 0;

        for (ConsensusTopicResponse r : responses) {
            if (transactionId == null && r.getChunkInfo().hasInitialTransactionID()) {
                transactionId = TransactionId.fromProtobuf(r.getChunkInfo().getInitialTransactionID());
            }

            int index = r.getChunkInfo().getNumber() - 1;

            chunks[index] = new TopicMessageChunk(r);
            contents[index] = r.getMessage();
            totalSize += r.getMessage().size();
        }

        var wholeMessage = ByteBuffer.allocate((int) totalSize);

        for (var content : contents) {
            wholeMessage.put(content.asReadOnlyByteBuffer());
        }

        var lastReceived = responses.get(responses.size() - 1);

        return new TopicMessage(
            InstantConverter.fromProtobuf(lastReceived.getConsensusTimestamp()),
            wholeMessage.array(),
            lastReceived.getRunningHash().toByteArray(),
            lastReceived.getSequenceNumber(),
            chunks,
            transactionId
        );
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("consensusTimestamp", consensusTimestamp)
            .add("contents", new String(contents, StandardCharsets.UTF_8))
            .add("runningHash", runningHash)
            .add("sequenceNumber", sequenceNumber)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicMessageChunk.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicResponse;
import java.time.Instant;

/**
 * A chunk of the topic message.
 */
final class TopicMessageChunk {
    public final Instant consensusTimestamp;
    public final long contentSize;
    public final byte[] runningHash;
    public final long sequenceNumber;

    /**
     * Create a topic message chunk from a protobuf.
     *
     * @param response                  the protobuf
     */
    TopicMessageChunk(ConsensusTopicResponse response) {
        consensusTimestamp = InstantConverter.fromProtobuf(response.getConsensusTimestamp());
        contentSize = response.getMessage().size();
        runningHash = response.getRunningHash().toByteArray();
        sequenceNumber = response.getSequenceNumber();
    }
}

// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicMessageQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicQuery;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.CallOptions;
import io.grpc.ClientCall;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.ClientCalls;
import io.grpc.stub.StreamObserver;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Predicate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Subscribe to a topic ID's messages from a mirror node. You will receive all messages for the specified topic or
 * within the defined start and end time.
 */
public final class TopicMessageQuery {

    private static final Logger LOGGER = LoggerFactory.getLogger(TopicMessageQuery.class);

    private final ConsensusTopicQuery.Builder builder;
    private Runnable completionHandler = this::onComplete;
    private BiConsumer<Throwable, TopicMessage> errorHandler = this::onError;
    private int maxAttempts = 10;
    private Duration maxBackoff = Duration.ofSeconds(8L);
    private Predicate<Throwable> retryHandler = this::shouldRetry;

    /**
     * Constructor.
     */
    public TopicMessageQuery() {
        builder = ConsensusTopicQuery.newBuilder();
    }

    /**
     * Assign the topic id.
     *
     * @param topicId the topic id
     * @return {@code this}
     */
    public TopicMessageQuery setTopicId(TopicId topicId) {
        Objects.requireNonNull(topicId, "topicId must not be null");
        builder.setTopicID(topicId.toProtobuf());
        return this;
    }

    /**
     * Assign the start time.
     *
     * @param startTime the start time
     * @return {@code this}
     */
    public TopicMessageQuery setStartTime(Instant startTime) {
        Objects.requireNonNull(startTime, "startTime must not be null");
        builder.setConsensusStartTime(InstantConverter.toProtobuf(startTime));
        return this;
    }

    /**
     * Assign the end time.
     *
     * @param endTime the end time
     * @return {@code this}
     */
    public TopicMessageQuery setEndTime(Instant endTime) {
        Objects.requireNonNull(endTime, "endTime must not be null");
        builder.setConsensusEndTime(InstantConverter.toProtobuf(endTime));
        return this;
    }

    /**
     * Assign the number of messages to return.
     *
     * @param limit the number of messages to return
     * @return {@code this}
     */
    public TopicMessageQuery setLimit(long limit) {
        builder.setLimit(limit);
        return this;
    }

    /**
     * Assign the call back function.
     *
     * @param completionHandler the call back function
     * @return {@code this}
     */
    public TopicMessageQuery setCompletionHandler(Runnable completionHandler) {
        Objects.requireNonNull(completionHandler, "completionHandler must not be null");
        this.completionHandler = completionHandler;
        return this;
    }

    /**
     * Assign the error handler does not return a value.
     *
     * @param errorHandler the error handler
     * @return {@code this}
     */
    public TopicMessageQuery setErrorHandler(BiConsumer<Throwable, TopicMessage> errorHandler) {
        Objects.requireNonNull(errorHandler, "errorHandler must not be null");
        this.errorHandler = errorHandler;
        return this;
    }

    /**
     * Assign the maximum number of attempts.
     *
     * @param maxAttempts the max attempts
     * @return {@code this}
     */
    public TopicMessageQuery setMaxAttempts(int maxAttempts) {
        if (maxAttempts < 0) {
            throw new IllegalArgumentException("maxAttempts must be positive");
        }
        this.maxAttempts = maxAttempts;
        return this;
    }

    /**
     * The maximum backoff in milliseconds.
     *
     * @param maxBackoff the maximum backoff
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public TopicMessageQuery setMaxBackoff(Duration maxBackoff) {
        if (maxBackoff == null || maxBackoff.toMillis() < 500L) {
            throw new IllegalArgumentException("maxBackoff must be at least 500 ms");
        }
        this.maxBackoff = maxBackoff;
        return this;
    }

    /**
     * Assign the retry handler.
     *
     * @param retryHandler the retry handler
     * @return {@code this}
     */
    public TopicMessageQuery setRetryHandler(Predicate<Throwable> retryHandler) {
        Objects.requireNonNull(retryHandler, "retryHandler must not be null");
        this.retryHandler = retryHandler;
        return this;
    }

    private void onComplete() {
        var topicId = TopicId.fromProtobuf(builder.getTopicID());
        LOGGER.info("Subscription to topic {} complete", topicId);
    }

    private void onError(Throwable throwable, TopicMessage topicMessage) {
        var topicId = TopicId.fromProtobuf(builder.getTopicID());

        if (throwable instanceof StatusRuntimeException sre && sre.getStatus().getCode()
            .equals(Status.Code.CANCELLED)) {
            LOGGER.warn("Call is cancelled for topic {}.", topicId);
        } else {
            LOGGER.error("Error attempting to subscribe to topic {}:", topicId, throwable);
        }
    }

    /**
     * This method will retry the following scenarios:
     * <p>
     * NOT_FOUND: Can occur when a client creates a topic and attempts to subscribe to it immediately before it is
     * available in the mirror node.
     * <p>
     * UNAVAILABLE: Can occur when the mirror node's database or other downstream components are temporarily down.
     * <p>
     * RESOURCE_EXHAUSTED: Can occur when the mirror node's resources (database, threads, etc.) are temporarily
     * exhausted.
     * <p>
     * INTERNAL: With a gRPC error status description that indicates the stream was reset. Stream resets can sometimes
     * occur when a proxy or load balancer disconnects the client.
     *
     * @param throwable the potentially retryable exception
     * @return if the request should be retried or not
     */
    @SuppressWarnings("MethodCanBeStatic")
    private boolean shouldRetry(Throwable throwable) {
        if (throwable instanceof StatusRuntimeException statusRuntimeException) {
            var code = statusRuntimeException.getStatus().getCode();
            var description = statusRuntimeException.getStatus().getDescription();

            return (code == Status.Code.NOT_FOUND) ||
                (code == Status.Code.UNAVAILABLE) ||
                (code == Status.Code.RESOURCE_EXHAUSTED) ||
                (code == Status.Code.INTERNAL && description != null && Executable.RST_STREAM.matcher(description)
                    .matches());
        }

        return false;
    }

    /**
     * Subscribe to the topic.
     *
     * @param client the configured client
     * @param onNext the consumer
     * @return the subscription handle
     */
    // TODO: Refactor into a base class when we add more mirror query types
    public SubscriptionHandle subscribe(Client client, Consumer<TopicMessage> onNext) {
        SubscriptionHandle subscriptionHandle = new SubscriptionHandle();
        HashMap<TransactionID, ArrayList<ConsensusTopicResponse>> pendingMessages = new HashMap<>();

        try {
            makeStreamingCall(client, subscriptionHandle, onNext, 0, new AtomicLong(), new AtomicReference<>(),
                pendingMessages);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        return subscriptionHandle;
    }

    private void makeStreamingCall(
        Client client,
        SubscriptionHandle subscriptionHandle,
        Consumer<TopicMessage> onNext,
        int attempt,
        AtomicLong counter,
        AtomicReference<ConsensusTopicResponse> lastMessage,
        HashMap<TransactionID, ArrayList<ConsensusTopicResponse>> pendingMessages
    ) throws InterruptedException {
        // TODO: check status of channel before using it?
        ClientCall<ConsensusTopicQuery, ConsensusTopicResponse> call =
            client.mirrorNetwork.getNextMirrorNode().getChannel()
                .newCall(ConsensusServiceGrpc.getSubscribeTopicMethod(), CallOptions.DEFAULT);

        subscriptionHandle.setOnUnsubscribe(() -> {
            client.untrackSubscription(subscriptionHandle);

            call.cancel("unsubscribe", null);
        });

        client.trackSubscription(subscriptionHandle);

        @Var
        var newBuilder = builder;

        // Update the start time and limit on retry
        if (lastMessage.get() != null) {
            newBuilder = builder.clone();

            if (builder.getLimit() > 0) {
                newBuilder.setLimit(builder.getLimit() - counter.get());
            }

            var lastStartTime = lastMessage.get().getConsensusTimestamp();
            var nextStartTime = Timestamp.newBuilder(lastStartTime).setNanos(lastStartTime.getNanos() + 1);
            newBuilder.setConsensusStartTime(nextStartTime);
        }

        ClientCalls.asyncServerStreamingCall(call, newBuilder.build(), new StreamObserver<>() {
            @Override
            public void onNext(ConsensusTopicResponse consensusTopicResponse) {
                counter.incrementAndGet();
                lastMessage.set(consensusTopicResponse);

                // Short circuit for no chunks or 1/1 chunks
                if (!consensusTopicResponse.hasChunkInfo() || consensusTopicResponse.getChunkInfo().getTotal() == 1) {
                    var message = TopicMessage.ofSingle(consensusTopicResponse);

                    try {
                        onNext.accept(message);
                    } catch (Throwable t) {
                        errorHandler.accept(t, message);
                    }

                    return;
                }

                // get the list of chunks for this pending message
                var initialTransactionID = consensusTopicResponse.getChunkInfo().getInitialTransactionID();

                // Can't use `HashMap.putIfAbsent()` since that method is not available on Android
                if (!pendingMessages.containsKey(initialTransactionID)) {
                    pendingMessages.put(initialTransactionID, new ArrayList<>());
                }

                ArrayList<ConsensusTopicResponse> chunks = pendingMessages.get(initialTransactionID);

                // not possible as we do [putIfAbsent]
                // add our response to the pending chunk list
                Objects.requireNonNull(chunks).add(consensusTopicResponse);

                // if we now have enough chunks, emit
                if (chunks.size() == consensusTopicResponse.getChunkInfo().getTotal()) {
                    var message = TopicMessage.ofMany(chunks);

                    try {
                        onNext.accept(message);
                    } catch (Throwable t) {
                        errorHandler.accept(t, message);
                    }
                }
            }

            @Override
            public void onError(Throwable t) {
                if (attempt >= maxAttempts || !retryHandler.test(t)) {
                    errorHandler.accept(t, null);
                    return;
                }

                var delay = Math.min(500 * (long) Math.pow(2, attempt), maxBackoff.toMillis());
                var topicId = TopicId.fromProtobuf(builder.getTopicID());
                LOGGER.warn("Error subscribing to topic {} during attempt #{}. Waiting {} ms before next attempt: {}",
                    topicId, attempt, delay, t.getMessage());
                call.cancel("unsubscribed", null);

                // Cannot use `CompletableFuture<U>` here since this future is never polled
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }

                try {
                    makeStreamingCall(client, subscriptionHandle, onNext, attempt + 1, counter, lastMessage,
                        pendingMessages);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }

            @Override
            public void onCompleted() {
                completionHandler.run();
            }
        });
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicMessageSubmitTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ConsensusMessageChunkInfo;
import com.hedera.hashgraph.sdk.proto.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.ConsensusSubmitMessageTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Submit a message for consensus.
 * <p>
 * Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
 * mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
 * <p>
 * The submitKey (if any) must sign this transaction.
 * <p>
 * On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
 * topicRunningHash.
 */
public final class TopicMessageSubmitTransaction extends ChunkedTransaction<TopicMessageSubmitTransaction> {
    @Nullable
    private TopicId topicId = null;

    /**
     * Constructor.
     */
    public TopicMessageSubmitTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TopicMessageSubmitTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TopicMessageSubmitTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the topic id.
     *
     * @return                          the topic id
     */
    @Nullable
    public TopicId getTopicId() {
        return topicId;
    }

    /**
     * Assign the topic id.
     *
     * @param topicId                   the topic id
     * @return {@code this}
     */
    public TopicMessageSubmitTransaction setTopicId(TopicId topicId) {
        Objects.requireNonNull(topicId);
        requireNotFrozen();
        this.topicId = topicId;
        return this;
    }

    /**
     * Extract the message.
     *
     * @return                          the message
     */
    public ByteString getMessage() {
        return getData();
    }

    /**
     * Assign the message from a byte string.
     *
     * @param message                   the byte string
     * @return                          the message
     */
    public TopicMessageSubmitTransaction setMessage(ByteString message) {
        return setData(message);
    }

    /**
     * Assign the message from a byte array.
     *
     * @param message                   the byte array
     * @return                          the message
     */
    public TopicMessageSubmitTransaction setMessage(byte[] message) {
        return setData(message);
    }

    /**
     * Assign the message from a string.
     *
     * @param message                   the string
     * @return                          the message
     */
    public TopicMessageSubmitTransaction setMessage(String message) {
        return setData(message);
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getConsensusSubmitMessage();
        if (body.hasTopicID()) {
            topicId = TopicId.fromProtobuf(body.getTopicID());
        }

        if (!innerSignedTransactions.isEmpty()) {
            try {
                for (var i = 0; i < innerSignedTransactions.size();
                    i += nodeAccountIds.isEmpty() ? 1 : nodeAccountIds.size()) {
                    data = data.concat(
                        TransactionBody.parseFrom(innerSignedTransactions.get(i).getBodyBytes())
                            .getConsensusSubmitMessage().getMessage()
                    );
                }
            } catch (InvalidProtocolBufferException exc) {
                throw new IllegalArgumentException(exc.getMessage());
            }
        } else {
            data = body.getMessage();
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.ConsensusSubmitMessageTransactionBody}
     */
    ConsensusSubmitMessageTransactionBody.Builder build() {
        var builder = ConsensusSubmitMessageTransactionBody.newBuilder();
        if (topicId != null) {
            builder.setTopicID(topicId.toProtobuf());
        }
        builder.setMessage(data);

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (topicId != null) {
            topicId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ConsensusServiceGrpc.getSubmitMessageMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setConsensusSubmitMessage(build());
    }

    @Override
    void onFreezeChunk(TransactionBody.Builder body, @Nullable TransactionID initialTransactionId, int startIndex, int endIndex, int chunk, int total) {
        if (total == 1) {
            body.setConsensusSubmitMessage(build().setMessage(data.substring(startIndex, endIndex)));
        } else {
            body.setConsensusSubmitMessage(build().setMessage(data.substring(startIndex, endIndex))
                .setChunkInfo(ConsensusMessageChunkInfo.newBuilder()
                    .setInitialTransactionID(Objects.requireNonNull(initialTransactionId))
                    .setNumber(chunk + 1)
                    .setTotal(total)
                )
            );
        }

    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setConsensusSubmitMessage(build().setMessage(data));
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TopicUpdateTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.ConsensusUpdateTopicTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import java.time.Duration;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.LinkedHashMap;
import java.util.Objects;

/**
 * Update a topic.
 * <p>
 * If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
 * Otherwise transaction must be signed by the adminKey.
 * <p>
 * If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
 * <p>
 * If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
 */
public final class TopicUpdateTransaction extends Transaction<TopicUpdateTransaction> {
    /**
     * Update the topic ID
     */
    @Nullable
    private TopicId topicId = null;
    /**
     * Set a new auto-renew account ID for this topic (once autoRenew
     * functionality is supported by HAPI).
     */
    @Nullable
    private AccountId autoRenewAccountId = null;
    /**
     * Set a new short publicly visible memo on the new topic and is stored
     * with the topic. (100 bytes)
     */
    @Nullable
    private String topicMemo = null;
    /**
     * Set a new admin key that authorizes update topic and delete topic
     * transactions.
     */
    @Nullable
    private Key adminKey = null;
    /**
     * Set a new submit key for a topic that authorizes sending messages
     * to this topic.
     */
    @Nullable
    private Key submitKey = null;
    /**
     * Set a new auto -enew period for this topic (once autoRenew
     * functionality is supported by HAPI).
     */
    @Nullable
    private Duration autoRenewPeriod = null;

    @Nullable
    private Instant expirationTime = null;

    /**
     * Constructor.
     */
    public TopicUpdateTransaction() {
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction)
     *            records
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    TopicUpdateTransaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs) throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TopicUpdateTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the topic id.
     *
     * @return                          the topic id
     */
    @Nullable
    public TopicId getTopicId() {
        return topicId;
    }

    /**
     * Set the topic ID to update.
     *
     * @param topicId The TopicId to be set
     * @return {@code this}
     */
    public TopicUpdateTransaction setTopicId(TopicId topicId) {
        Objects.requireNonNull(topicId);
        requireNotFrozen();
        this.topicId = topicId;
        return this;
    }

    /**
     * Extract the topic memo.
     *
     * @return                          the topic memo
     */
    @Nullable
    public String getTopicMemo() {
        return topicMemo;
    }

    /**
     * Set a new memo for this topic.
     *
     * @param memo The memo to be set
     * @return {@code this}
     */
    public TopicUpdateTransaction setTopicMemo(String memo) {
        Objects.requireNonNull(memo);
        requireNotFrozen();
        topicMemo = memo;
        return this;
    }

    /**
     * Clear the memo for this topic.
     *
     * @return {@code this}
     */
    public TopicUpdateTransaction clearTopicMemo() {
        requireNotFrozen();
        topicMemo = "";
        return this;
    }

    /**
     * Extract the admin key.
     *
     * @return                          the admin key
     */
    @Nullable
    public Key getAdminKey() {
        return adminKey;
    }

    /**
     * Set a new admin key for this topic.
     *
     * @param adminKey The Key to be set
     * @return {@code this}
     */
    public TopicUpdateTransaction setAdminKey(Key adminKey) {
        Objects.requireNonNull(adminKey);
        requireNotFrozen();
        this.adminKey = adminKey;
        return this;
    }

    /**
     * Clear the admin key for this topic.
     *
     * @return {@code this}
     */
    public TopicUpdateTransaction clearAdminKey() {
        requireNotFrozen();
        adminKey = new KeyList();
        return this;
    }

    /**
     * Extract the submit key.
     *
     * @return                          the submit key
     */
    @Nullable
    public Key getSubmitKey() {
        return submitKey;
    }

    /**
     * Set a new submit key for this topic.
     *
     * @param submitKey The Key to be set
     * @return {@code this}
     */
    public TopicUpdateTransaction setSubmitKey(Key submitKey) {
        Objects.requireNonNull(submitKey);
        requireNotFrozen();
        this.submitKey = submitKey;
        return this;
    }

    /**
     * Clear the submit key for this topic.
     *
     * @return {@code this}
     */
    public TopicUpdateTransaction clearSubmitKey() {
        requireNotFrozen();
        submitKey = new KeyList();
        return this;
    }

    /**
     * Extract the auto renew period.
     *
     * @return                          the auto renew period
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public Duration getAutoRenewPeriod() {
        return autoRenewPeriod;
    }

    /**
     * Set a new auto renew period for this topic.
     *
     * @param autoRenewPeriod The Duration to be set for auto renewal
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public TopicUpdateTransaction setAutoRenewPeriod(Duration autoRenewPeriod) {
        Objects.requireNonNull(autoRenewPeriod);
        requireNotFrozen();
        this.autoRenewPeriod = autoRenewPeriod;
        return this;
    }

    /**
     * Extract the auto renew account id.
     *
     * @return                          the auto renew account id
     */
    @Nullable
    public AccountId getAutoRenewAccountId() {
        return autoRenewAccountId;
    }

    /**
     * Set a new auto renew account ID for this topic.
     *
     * @param autoRenewAccountId The AccountId to be set for auto renewal
     * @return {@code this}
     */
    public TopicUpdateTransaction setAutoRenewAccountId(AccountId autoRenewAccountId) {
        Objects.requireNonNull(autoRenewAccountId);
        requireNotFrozen();
        this.autoRenewAccountId = autoRenewAccountId;
        return this;
    }

    /**
     * @param autoRenewAccountId The AccountId to be cleared for auto renewal
     * @return {@code this}
     * @deprecated Use {@link #clearAutoRenewAccountId()}
     * <p>
     * Clear the auto renew account ID for this topic.
     */
    @SuppressWarnings("MissingSummary")
    @Deprecated
    public TopicUpdateTransaction clearAutoRenewAccountId(AccountId autoRenewAccountId) {
        return clearAutoRenewAccountId();
    }

    /**
     * Clear the auto renew account ID for this topic.
     *
     * @return {@code this}
     */
    public TopicUpdateTransaction clearAutoRenewAccountId() {
        requireNotFrozen();
        autoRenewAccountId = new AccountId(0);
        return this;
    }

    /**
     * @return Expiration time
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "An Instant can't actually be mutated"
    )
    public Instant getExpirationTime() {
        return expirationTime;
    }

    /**
     * Sets the effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
     * The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
     * this transaction.
     * On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
     * @param expirationTime the new expiration time
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "An Instant can't actually be mutated"
    )
    public TopicUpdateTransaction setExpirationTime(Instant expirationTime) {
        requireNotFrozen();
        this.expirationTime = Objects.requireNonNull(expirationTime);
        return this;
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getConsensusUpdateTopic();
        if (body.hasTopicID()) {
            topicId = TopicId.fromProtobuf(body.getTopicID());
        }
        if (body.hasAdminKey()) {
            adminKey = Key.fromProtobufKey(body.getAdminKey());
        }
        if (body.hasSubmitKey()) {
            submitKey = Key.fromProtobufKey(body.getSubmitKey());
        }
        if (body.hasAutoRenewPeriod()) {
            autoRenewPeriod = DurationConverter.fromProtobuf(body.getAutoRenewPeriod());
        }
        if (body.hasAutoRenewAccount()) {
            autoRenewAccountId = AccountId.fromProtobuf(body.getAutoRenewAccount());
        }
        if (body.hasMemo()) {
            topicMemo = body.getMemo().getValue();
        }
        if (body.hasExpirationTime()) {
            expirationTime = InstantConverter.fromProtobuf(body.getExpirationTime());
        }
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.ConsensusUpdateTopicTransactionBody}
     */
    ConsensusUpdateTopicTransactionBody.Builder build() {
        var builder = ConsensusUpdateTopicTransactionBody.newBuilder();
        if (topicId != null) {
            builder.setTopicID(topicId.toProtobuf());
        }
        if (autoRenewAccountId != null) {
            builder.setAutoRenewAccount(autoRenewAccountId.toProtobuf());
        }
        if (adminKey != null) {
            builder.setAdminKey(adminKey.toProtobufKey());
        }
        if (submitKey != null) {
            builder.setSubmitKey(submitKey.toProtobufKey());
        }
        if (autoRenewPeriod != null) {
            builder.setAutoRenewPeriod(DurationConverter.toProtobuf(autoRenewPeriod));
        }
        if (topicMemo != null) {
            builder.setMemo(StringValue.of(topicMemo));
        }
        if (expirationTime != null) {
            builder.setExpirationTime(InstantConverter.toProtobuf(expirationTime));
        }
        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (topicId != null) {
            topicId.validateChecksum(client);
        }

        if ((autoRenewAccountId != null) &&
            !autoRenewAccountId.equals(new AccountId(0))
        ) {
            autoRenewAccountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return ConsensusServiceGrpc.getUpdateTopicMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setConsensusUpdateTopic(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setConsensusUpdateTopic(build());
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Transaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SignatureMap;
import com.hedera.hashgraph.sdk.proto.SignaturePair;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionList;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.lang.reflect.Modifier;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import java.util.function.UnaryOperator;
import javax.annotation.Nullable;
import org.bouncycastle.crypto.digests.SHA384Digest;

/**
 * Base class for all transactions that may be built and submitted to Hedera.
 *
 * @param <T> The type of the transaction. Used to enable chaining.
 */
public abstract class Transaction<T extends Transaction<T>>
    extends
    Executable<T, com.hedera.hashgraph.sdk.proto.Transaction, com.hedera.hashgraph.sdk.proto.TransactionResponse, TransactionResponse> {

    /**
     * Default auto renew duration for accounts, contracts, topics, and files (entities)
     */
    static final Duration DEFAULT_AUTO_RENEW_PERIOD = Duration.ofDays(90);

    /**
     * Dummy account ID used to assist in deserializing incomplete Transactions.
     */
    protected static final AccountId DUMMY_ACCOUNT_ID = new AccountId(0L, 0L, 0L);

    /**
     * Dummy transaction ID used to assist in deserializing incomplete Transactions.
     */
    protected static final TransactionId DUMMY_TRANSACTION_ID = TransactionId.withValidStart(DUMMY_ACCOUNT_ID, Instant.EPOCH);

    /**
     * Default transaction duration
     */
    private static final Duration DEFAULT_TRANSACTION_VALID_DURATION = Duration.ofSeconds(120);

    /**
     * Transaction constructors end their work by setting sourceTransactionBody. The expectation is that the Transaction
     * subclass constructor will pick up where the Transaction superclass constructor left off, and will unpack the data
     * in the transaction body.
     */
    protected final TransactionBody sourceTransactionBody;
    /**
     * The builder that gets re-used to build each outer transaction. freezeWith() will create the frozenBodyBuilder.
     * The presence of frozenBodyBuilder indicates that this transaction is frozen.
     */
    @Nullable
    protected TransactionBody.Builder frozenBodyBuilder = null;

    /**
     * An SDK [Transaction] is composed of multiple, raw protobuf transactions. These should be functionally identical,
     * except pointing to different nodes. When retrying a transaction after a network error or retry-able status
     * response, we try a different transaction and thus a different node.
     */
    protected List<com.hedera.hashgraph.sdk.proto.Transaction> outerTransactions = Collections.emptyList();

    /**
     * An SDK [Transaction] is composed of multiple, raw protobuf transactions. These should be functionally identical,
     * except pointing to different nodes. When retrying a transaction after a network error or retry-able status
     * response, we try a different transaction and thus a different node.
     */
    protected List<com.hedera.hashgraph.sdk.proto.SignedTransaction.Builder> innerSignedTransactions = Collections.emptyList();

    /**
     * A set of signatures corresponding to every unique public key used to sign the transaction.
     */
    protected List<SignatureMap.Builder> sigPairLists = Collections.emptyList();

    /**
     * List of IDs for the transaction based on the operator because the transaction ID includes the operator's account
     */
    protected LockableList<TransactionId> transactionIds = new LockableList<>();

    /**
     * publicKeys and signers are parallel arrays. If the signer associated with a public key is null, that means that
     * the private key associated with that public key has already contributed a signature to sigPairListBuilders, but
     * the signer is not available (likely because this came from fromBytes())
     */
    protected List<PublicKey> publicKeys = new ArrayList<>();

    /**
     * publicKeys and signers are parallel arrays. If the signer associated with a public key is null, that means that
     * the private key associated with that public key has already contributed a signature to sigPairListBuilders, but
     * the signer is not available (likely because this came from fromBytes())
     */
    protected List<Function<byte[], byte[]>> signers = new ArrayList<>();

    /**
     * The maximum transaction fee the client is willing to pay
     */
    protected Hbar defaultMaxTransactionFee = new Hbar(2);
    /**
     * Should the transaction id be regenerated
     */
    protected Boolean regenerateTransactionId = null;
    private Duration transactionValidDuration;
    @Nullable
    private Hbar maxTransactionFee = null;
    private String memo = "";

    /**
     * Constructor.
     */
    Transaction() {
        setTransactionValidDuration(DEFAULT_TRANSACTION_VALID_DURATION);

        sourceTransactionBody = TransactionBody.getDefaultInstance();
    }

    // This constructor is used to construct from a scheduled transaction body

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    Transaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        setTransactionValidDuration(DEFAULT_TRANSACTION_VALID_DURATION);
        setMaxTransactionFee(Hbar.fromTinybars(txBody.getTransactionFee()));
        setTransactionMemo(txBody.getMemo());

        sourceTransactionBody = txBody;
    }

    // This constructor is used to construct via fromBytes

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    Transaction(LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction> transactionMap = txs.values().iterator().next();
        if (!transactionMap.isEmpty() && transactionMap.keySet().iterator().next().equals(DUMMY_ACCOUNT_ID)) {
            // If the first account ID is a dummy account ID, then only the source TransactionBody needs to be copied.
            var signedTransaction = SignedTransaction.parseFrom(transactionMap.values().iterator().next().getSignedTransactionBytes());
            sourceTransactionBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
        } else {
            var txCount = txs.keySet().size();
            var nodeCount = txs.values().iterator().next().size();

            nodeAccountIds.ensureCapacity(nodeCount);
            sigPairLists = new ArrayList<>(nodeCount * txCount);
            outerTransactions = new ArrayList<>(nodeCount * txCount);
            innerSignedTransactions = new ArrayList<>(nodeCount * txCount);
            transactionIds.ensureCapacity(txCount);

            for (var transactionEntry : txs.entrySet()) {
                if (!transactionEntry.getKey().equals(DUMMY_TRANSACTION_ID)) {
                    transactionIds.add(transactionEntry.getKey());
                }
                for (var nodeEntry : transactionEntry.getValue().entrySet()) {
                    if (nodeAccountIds.size() != nodeCount) {
                        nodeAccountIds.add(nodeEntry.getKey());
                    }

                    var transaction = SignedTransaction.parseFrom(nodeEntry.getValue().getSignedTransactionBytes());
                    outerTransactions.add(nodeEntry.getValue());
                    sigPairLists.add(transaction.getSigMap().toBuilder());
                    innerSignedTransactions.add(transaction.toBuilder());

                    if (publicKeys.isEmpty()) {
                        for (var sigPair : transaction.getSigMap().getSigPairList()) {
                            publicKeys.add(PublicKey.fromBytes(sigPair.getPubKeyPrefix().toByteArray()));
                            signers.add(null);
                        }
                    }
                }
            }

            nodeAccountIds.remove(new AccountId(0));

            // Verify that transaction bodies match
            for (@Var int i = 0; i < txCount; i++) {
                @Var TransactionBody firstTxBody = null;
                for (@Var int j = 0; j < nodeCount; j++) {
                    int k = i * nodeCount + j;
                    var txBody = TransactionBody.parseFrom(innerSignedTransactions.get(k).getBodyBytes());
                    if (firstTxBody == null) {
                        firstTxBody = txBody;
                    } else {
                        requireProtoMatches(
                            firstTxBody,
                            txBody,
                            new HashSet<>(List.of("NodeAccountID")),
                            "TransactionBody"
                        );
                    }
                }
            }
            sourceTransactionBody = TransactionBody.parseFrom(innerSignedTransactions.get(0).getBodyBytes());
        }

        setTransactionValidDuration(
            DurationConverter.fromProtobuf(sourceTransactionBody.getTransactionValidDuration()));
        setMaxTransactionFee(Hbar.fromTinybars(sourceTransactionBody.getTransactionFee()));
        setTransactionMemo(sourceTransactionBody.getMemo());

        // The presence of signatures implies the Transaction should be frozen.
        if (!publicKeys.isEmpty()) {
            frozenBodyBuilder = sourceTransactionBody.toBuilder();
        }
    }

    /**
     * Create the correct transaction from a byte array.
     *
     * @param bytes the byte array
     * @return the new transaction
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    public static Transaction<?> fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        var txs = new LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>>();
        @Var TransactionBody.DataCase dataCase = TransactionBody.DataCase.DATA_NOT_SET;

        var list = TransactionList.parseFrom(bytes);

        if (list.getTransactionListList().isEmpty()) {
            var transaction = com.hedera.hashgraph.sdk.proto.Transaction.parseFrom(bytes).toBuilder();

            TransactionBody txBody;
            if (transaction.getSignedTransactionBytes().isEmpty()) {
                txBody = TransactionBody.parseFrom(transaction.getBodyBytes());

                transaction.setSignedTransactionBytes(SignedTransaction.newBuilder()
                        .setBodyBytes(transaction.getBodyBytes())
                        .setSigMap(transaction.getSigMap())
                        .build()
                        .toByteString())
                    .clearBodyBytes()
                    .clearSigMap();
            } else {
                var signedTransaction = SignedTransaction.parseFrom(transaction.getSignedTransactionBytes());
                txBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
            }

            dataCase = txBody.getDataCase();

            var account = txBody.hasNodeAccountID() ? AccountId.fromProtobuf(txBody.getNodeAccountID())
                : DUMMY_ACCOUNT_ID;
            var transactionId = txBody.hasTransactionID() ? TransactionId.fromProtobuf(txBody.getTransactionID())
                : DUMMY_TRANSACTION_ID;

            var linked = new LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>();
            linked.put(account, transaction.build());
            txs.put(transactionId, linked);
        } else {
            for (var transaction : list.getTransactionListList()) {
                var signedTransaction = SignedTransaction.parseFrom(transaction.getSignedTransactionBytes());
                var txBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());

                if (dataCase.getNumber() == TransactionBody.DataCase.DATA_NOT_SET.getNumber()) {
                    dataCase = txBody.getDataCase();
                }

                var account = txBody.hasNodeAccountID() ? AccountId.fromProtobuf(txBody.getNodeAccountID())
                    : DUMMY_ACCOUNT_ID;
                var transactionId = txBody.hasTransactionID() ? TransactionId.fromProtobuf(txBody.getTransactionID())
                    : DUMMY_TRANSACTION_ID;

                var linked = txs.containsKey(transactionId) ?
                    Objects.requireNonNull(txs.get(transactionId)) :
                    new LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>();

                linked.put(account, transaction);

                txs.put(transactionId, linked);
            }
        }

        return switch (dataCase) {
            case CONTRACTCALL -> new ContractExecuteTransaction(txs);
            case CONTRACTCREATEINSTANCE -> new ContractCreateTransaction(txs);
            case CONTRACTUPDATEINSTANCE -> new ContractUpdateTransaction(txs);
            case CONTRACTDELETEINSTANCE -> new ContractDeleteTransaction(txs);
            case ETHEREUMTRANSACTION -> new EthereumTransaction(txs);
            case CRYPTOADDLIVEHASH -> new LiveHashAddTransaction(txs);
            case CRYPTOCREATEACCOUNT -> new AccountCreateTransaction(txs);
            case CRYPTODELETE -> new AccountDeleteTransaction(txs);
            case CRYPTODELETELIVEHASH -> new LiveHashDeleteTransaction(txs);
            case CRYPTOTRANSFER -> new TransferTransaction(txs);
            case CRYPTOUPDATEACCOUNT -> new AccountUpdateTransaction(txs);
            case FILEAPPEND -> new FileAppendTransaction(txs);
            case FILECREATE -> new FileCreateTransaction(txs);
            case FILEDELETE -> new FileDeleteTransaction(txs);
            case FILEUPDATE -> new FileUpdateTransaction(txs);
            case NODECREATE -> new NodeCreateTransaction(txs);
            case NODEUPDATE -> new NodeUpdateTransaction(txs);
            case NODEDELETE -> new NodeDeleteTransaction(txs);
            case SYSTEMDELETE -> new SystemDeleteTransaction(txs);
            case SYSTEMUNDELETE -> new SystemUndeleteTransaction(txs);
            case FREEZE -> new FreezeTransaction(txs);
            case CONSENSUSCREATETOPIC -> new TopicCreateTransaction(txs);
            case CONSENSUSUPDATETOPIC -> new TopicUpdateTransaction(txs);
            case CONSENSUSDELETETOPIC -> new TopicDeleteTransaction(txs);
            case CONSENSUSSUBMITMESSAGE -> new TopicMessageSubmitTransaction(txs);
            case TOKENASSOCIATE -> new TokenAssociateTransaction(txs);
            case TOKENBURN -> new TokenBurnTransaction(txs);
            case TOKENCREATION -> new TokenCreateTransaction(txs);
            case TOKENDELETION -> new TokenDeleteTransaction(txs);
            case TOKENDISSOCIATE -> new TokenDissociateTransaction(txs);
            case TOKENFREEZE -> new TokenFreezeTransaction(txs);
            case TOKENGRANTKYC -> new TokenGrantKycTransaction(txs);
            case TOKENMINT -> new TokenMintTransaction(txs);
            case TOKENREVOKEKYC -> new TokenRevokeKycTransaction(txs);
            case TOKENUNFREEZE -> new TokenUnfreezeTransaction(txs);
            case TOKENUPDATE -> new TokenUpdateTransaction(txs);
            case TOKEN_UPDATE_NFTS -> new TokenUpdateNftsTransaction(txs);
            case TOKENWIPE -> new TokenWipeTransaction(txs);
            case TOKEN_FEE_SCHEDULE_UPDATE -> new TokenFeeScheduleUpdateTransaction(txs);
            case SCHEDULECREATE -> new ScheduleCreateTransaction(txs);
            case SCHEDULEDELETE -> new ScheduleDeleteTransaction(txs);
            case SCHEDULESIGN -> new ScheduleSignTransaction(txs);
            case TOKEN_PAUSE -> new TokenPauseTransaction(txs);
            case TOKEN_UNPAUSE -> new TokenUnpauseTransaction(txs);
            case TOKENREJECT -> new TokenRejectTransaction(txs);
            case TOKENAIRDROP -> new TokenAirdropTransaction(txs);
            case TOKENCANCELAIRDROP -> new TokenCancelAirdropTransaction(txs);
            case TOKENCLAIMAIRDROP -> new TokenClaimAirdropTransaction(txs);
            case CRYPTOAPPROVEALLOWANCE -> new AccountAllowanceApproveTransaction(txs);
            case CRYPTODELETEALLOWANCE -> new AccountAllowanceDeleteTransaction(txs);
            default -> throw new IllegalArgumentException("parsed transaction body has no data");
        };
    }

    /**
     * Create the correct transaction from a scheduled transaction.
     *
     * @param scheduled the scheduled transaction
     * @return the new transaction
     */
    public static Transaction<?> fromScheduledTransaction(
        com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody scheduled) {
        var body = TransactionBody.newBuilder()
            .setMemo(scheduled.getMemo())
            .setTransactionFee(scheduled.getTransactionFee());

        return switch (scheduled.getDataCase()) {
            case CONTRACTCALL ->
                new ContractExecuteTransaction(body.setContractCall(scheduled.getContractCall()).build());
            case CONTRACTCREATEINSTANCE -> new ContractCreateTransaction(
                body.setContractCreateInstance(scheduled.getContractCreateInstance()).build());
            case CONTRACTUPDATEINSTANCE -> new ContractUpdateTransaction(
                body.setContractUpdateInstance(scheduled.getContractUpdateInstance()).build());
            case CONTRACTDELETEINSTANCE -> new ContractDeleteTransaction(
                body.setContractDeleteInstance(scheduled.getContractDeleteInstance()).build());
            case CRYPTOAPPROVEALLOWANCE -> new AccountAllowanceApproveTransaction(
                body.setCryptoApproveAllowance(scheduled.getCryptoApproveAllowance()).build());
            case CRYPTODELETEALLOWANCE -> new AccountAllowanceDeleteTransaction(
                body.setCryptoDeleteAllowance(scheduled.getCryptoDeleteAllowance()).build());
            case CRYPTOCREATEACCOUNT -> new AccountCreateTransaction(
                body.setCryptoCreateAccount(scheduled.getCryptoCreateAccount()).build());
            case CRYPTODELETE ->
                new AccountDeleteTransaction(body.setCryptoDelete(scheduled.getCryptoDelete()).build());
            case CRYPTOTRANSFER ->
                new TransferTransaction(body.setCryptoTransfer(scheduled.getCryptoTransfer()).build());
            case CRYPTOUPDATEACCOUNT -> new AccountUpdateTransaction(
                body.setCryptoUpdateAccount(scheduled.getCryptoUpdateAccount()).build());
            case FILEAPPEND -> new FileAppendTransaction(body.setFileAppend(scheduled.getFileAppend()).build());
            case FILECREATE -> new FileCreateTransaction(body.setFileCreate(scheduled.getFileCreate()).build());
            case FILEDELETE -> new FileDeleteTransaction(body.setFileDelete(scheduled.getFileDelete()).build());
            case FILEUPDATE -> new FileUpdateTransaction(body.setFileUpdate(scheduled.getFileUpdate()).build());
            case NODECREATE -> new NodeCreateTransaction(body.setNodeCreate(scheduled.getNodeCreate()).build());
            case NODEUPDATE -> new NodeUpdateTransaction(body.setNodeUpdate(scheduled.getNodeUpdate()).build());
            case NODEDELETE -> new NodeDeleteTransaction(body.setNodeDelete(scheduled.getNodeDelete()).build());
            case SYSTEMDELETE -> new SystemDeleteTransaction(body.setSystemDelete(scheduled.getSystemDelete()).build());
            case SYSTEMUNDELETE ->
                new SystemUndeleteTransaction(body.setSystemUndelete(scheduled.getSystemUndelete()).build());
            case FREEZE -> new FreezeTransaction(body.setFreeze(scheduled.getFreeze()).build());
            case CONSENSUSCREATETOPIC -> new TopicCreateTransaction(
                body.setConsensusCreateTopic(scheduled.getConsensusCreateTopic()).build());
            case CONSENSUSUPDATETOPIC -> new TopicUpdateTransaction(
                body.setConsensusUpdateTopic(scheduled.getConsensusUpdateTopic()).build());
            case CONSENSUSDELETETOPIC -> new TopicDeleteTransaction(
                body.setConsensusDeleteTopic(scheduled.getConsensusDeleteTopic()).build());
            case CONSENSUSSUBMITMESSAGE -> new TopicMessageSubmitTransaction(
                body.setConsensusSubmitMessage(scheduled.getConsensusSubmitMessage()).build());
            case TOKENCREATION ->
                new TokenCreateTransaction(body.setTokenCreation(scheduled.getTokenCreation()).build());
            case TOKENFREEZE -> new TokenFreezeTransaction(body.setTokenFreeze(scheduled.getTokenFreeze()).build());
            case TOKENUNFREEZE ->
                new TokenUnfreezeTransaction(body.setTokenUnfreeze(scheduled.getTokenUnfreeze()).build());
            case TOKENGRANTKYC ->
                new TokenGrantKycTransaction(body.setTokenGrantKyc(scheduled.getTokenGrantKyc()).build());
            case TOKENREVOKEKYC ->
                new TokenRevokeKycTransaction(body.setTokenRevokeKyc(scheduled.getTokenRevokeKyc()).build());
            case TOKENDELETION ->
                new TokenDeleteTransaction(body.setTokenDeletion(scheduled.getTokenDeletion()).build());
            case TOKENUPDATE -> new TokenUpdateTransaction(body.setTokenUpdate(scheduled.getTokenUpdate()).build());
            case TOKEN_UPDATE_NFTS -> new TokenUpdateNftsTransaction(body.setTokenUpdateNfts(scheduled.getTokenUpdateNfts()).build());
            case TOKENMINT -> new TokenMintTransaction(body.setTokenMint(scheduled.getTokenMint()).build());
            case TOKENBURN -> new TokenBurnTransaction(body.setTokenBurn(scheduled.getTokenBurn()).build());
            case TOKENWIPE -> new TokenWipeTransaction(body.setTokenWipe(scheduled.getTokenWipe()).build());
            case TOKENASSOCIATE ->
                new TokenAssociateTransaction(body.setTokenAssociate(scheduled.getTokenAssociate()).build());
            case TOKENDISSOCIATE ->
                new TokenDissociateTransaction(body.setTokenDissociate(scheduled.getTokenDissociate()).build());
            case TOKEN_FEE_SCHEDULE_UPDATE -> new TokenFeeScheduleUpdateTransaction(
                body.setTokenFeeScheduleUpdate(scheduled.getTokenFeeScheduleUpdate()).build());
            case TOKEN_PAUSE -> new TokenPauseTransaction(body.setTokenPause(scheduled.getTokenPause()).build());
            case TOKEN_UNPAUSE ->
                new TokenUnpauseTransaction(body.setTokenUnpause(scheduled.getTokenUnpause()).build());
            case TOKENREJECT ->
                new TokenRejectTransaction(body.setTokenReject(scheduled.getTokenReject()).build());
            case TOKENAIRDROP -> new TokenAirdropTransaction(body.setTokenAirdrop(scheduled.getTokenAirdrop()).build());
            case TOKENCANCELAIRDROP -> new TokenCancelAirdropTransaction(body.setTokenCancelAirdrop(scheduled.getTokenCancelAirdrop()).build());
            case TOKENCLAIMAIRDROP -> new TokenClaimAirdropTransaction(body.setTokenCancelAirdrop(scheduled.getTokenCancelAirdrop()).build());
            case SCHEDULEDELETE ->
                new ScheduleDeleteTransaction(body.setScheduleDelete(scheduled.getScheduleDelete()).build());
            default -> throw new IllegalStateException("schedulable transaction did not have a transaction set");
        };
    }

    private static void throwProtoMatchException(String fieldName, String aWas, String bWas) {
        throw new IllegalArgumentException(
            "fromBytes() failed because " + fieldName +
                " fields in TransactionBody protobuf messages in the TransactionList did not match: A was " +
                aWas + ", B was " + bWas
        );
    }

    private static void requireProtoMatches(Object protoA, Object protoB, Set<String> ignoreSet, String thisFieldName) {
        var aIsNull = protoA == null;
        var bIsNull = protoB == null;
        if (aIsNull != bIsNull) {
            throwProtoMatchException(thisFieldName, aIsNull ? "null" : "not null", bIsNull ? "null" : "not null");
        }
        if (aIsNull) {
            return;
        }
        var protoAClass = protoA.getClass();
        var protoBClass = protoB.getClass();
        if (!protoAClass.equals(protoBClass)) {
            throwProtoMatchException(thisFieldName, "of class " + protoAClass, "of class " + protoBClass);
        }
        if (protoA instanceof Boolean ||
            protoA instanceof Integer ||
            protoA instanceof Long ||
            protoA instanceof Float ||
            protoA instanceof Double ||
            protoA instanceof String ||
            protoA instanceof ByteString
        ) {
            // System.out.println("values A = " + protoA.toString() + ", B = " + protoB.toString());
            if (!protoA.equals(protoB)) {
                throwProtoMatchException(thisFieldName, protoA.toString(), protoB.toString());
            }
        }
        for (var method : protoAClass.getDeclaredMethods()) {
            if (method.getParameterCount() != 0) {
                continue;
            }
            int methodModifiers = method.getModifiers();
            if ((!Modifier.isPublic(methodModifiers)) || Modifier.isStatic(methodModifiers)) {
                continue;
            }
            var methodName = method.getName();
            if (!methodName.startsWith("get")) {
                continue;
            }
            var isList = methodName.endsWith("List") && List.class.isAssignableFrom(method.getReturnType());
            var methodFieldName = methodName.substring(3, methodName.length() - (isList ? 4 : 0));
            if (ignoreSet.contains(methodFieldName) || methodFieldName.equals("DefaultInstance")) {
                continue;
            }
            if (!isList) {
                try {
                    var hasMethod = protoAClass.getMethod("has" + methodFieldName);
                    var hasA = (Boolean) hasMethod.invoke(protoA);
                    var hasB = (Boolean) hasMethod.invoke(protoB);
                    if (!hasA.equals(hasB)) {
                        throwProtoMatchException(methodFieldName, hasA ? "present" : "not present",
                            hasB ? "present" : "not present");
                    }
                    if (!hasA) {
                        continue;
                    }
                } catch (NoSuchMethodException ignored) {
                    // pass if there is no has method
                } catch (IllegalArgumentException error) {
                    throw error;
                } catch (Throwable error) {
                    throw new IllegalArgumentException("fromBytes() failed due to error", error);
                }
            }
            try {
                var retvalA = method.invoke(protoA);
                var retvalB = method.invoke(protoB);
                if (isList) {
                    var listA = (List<?>) retvalA;
                    var listB = (List<?>) retvalB;
                    if (listA.size() != listB.size()) {
                        throwProtoMatchException(methodFieldName, "of size " + listA.size(), "of size " + listB.size());
                    }
                    for (@Var int i = 0; i < listA.size(); i++) {
                        // System.out.println("comparing " + thisFieldName + "." + methodFieldName + "[" + i + "]");
                        requireProtoMatches(listA.get(i), listB.get(i), ignoreSet, methodFieldName + "[" + i + "]");
                    }
                } else {
                    // System.out.println("comparing " + thisFieldName + "." + methodFieldName);
                    requireProtoMatches(retvalA, retvalB, ignoreSet, methodFieldName);
                }
            } catch (IllegalArgumentException error) {
                throw error;
            } catch (Throwable error) {
                throw new IllegalArgumentException("fromBytes() failed due to error", error);
            }
        }
    }

    /**
     * Generate a hash from a byte array.
     *
     * @param bytes the byte array
     * @return the hash
     */
    static byte[] hash(byte[] bytes) {
        var digest = new SHA384Digest();
        var hash = new byte[digest.getDigestSize()];

        digest.update(bytes, 0, bytes.length);
        digest.doFinal(hash, 0);

        return hash;
    }

    private static boolean publicKeyIsInSigPairList(ByteString publicKeyBytes, List<SignaturePair> sigPairList) {
        for (var pair : sigPairList) {
            if (pair.getPubKeyPrefix().equals(publicKeyBytes)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Converts transaction into a scheduled version
     *
     * @param bodyBuilder the transaction's body builder
     * @return the scheduled transaction
     */
    protected ScheduleCreateTransaction doSchedule(TransactionBody.Builder bodyBuilder) {
        var schedulable = SchedulableTransactionBody.newBuilder()
            .setTransactionFee(bodyBuilder.getTransactionFee())
            .setMemo(bodyBuilder.getMemo());

        onScheduled(schedulable);

        var scheduled = new ScheduleCreateTransaction()
            .setScheduledTransactionBody(schedulable.build());

        if (!transactionIds.isEmpty()) {
            scheduled.setTransactionId(transactionIds.get(0));
        }

        return scheduled;
    }

    /**
     * Extract the scheduled transaction.
     *
     * @return the scheduled transaction
     */
    public ScheduleCreateTransaction schedule() {
        requireNotFrozen();
        if (!nodeAccountIds.isEmpty()) {
            throw new IllegalStateException(
                "The underlying transaction for a scheduled transaction cannot have node account IDs set"
            );
        }

        var bodyBuilder = spawnBodyBuilder(null);

        onFreeze(bodyBuilder);

        return doSchedule(bodyBuilder);
    }

    /**
     * Set the account IDs of the nodes that this transaction will be submitted to.
     * <p>
     * Providing an explicit node account ID interferes with client-side load balancing of the network. By default, the
     * SDK will pre-generate a transaction for 1/3 of the nodes on the network. If a node is down, busy, or otherwise
     * reports a fatal error, the SDK will try again with a different node.
     *
     * @param nodeAccountIds The list of node AccountIds to be set
     * @return {@code this}
     */
    @Override
    public final T setNodeAccountIds(List<AccountId> nodeAccountIds) {
        requireNotFrozen();
        Objects.requireNonNull(nodeAccountIds);
        return super.setNodeAccountIds(nodeAccountIds);
    }

    /**
     * Extract the valid transaction duration.
     *
     * @return the transaction valid duration
     */
    @Nullable
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP",
        justification = "A Duration can't actually be mutated"
    )
    public final Duration getTransactionValidDuration() {
        return transactionValidDuration;
    }

    /**
     * Sets the duration that this transaction is valid for.
     * <p>
     * This is defaulted by the SDK to 120 seconds (or two minutes).
     *
     * @param validDuration The duration to be set
     * @return {@code this}
     */
    @SuppressFBWarnings(
        value = "EI_EXPOSE_REP2",
        justification = "A Duration can't actually be mutated"
    )
    public final T setTransactionValidDuration(Duration validDuration) {
        requireNotFrozen();
        Objects.requireNonNull(validDuration);
        transactionValidDuration = validDuration;
        // noinspection unchecked
        return (T) this;
    }

    /**
     * Extract the maximum transaction fee.
     *
     * @return the maximum transaction fee
     */
    @Nullable
    public final Hbar getMaxTransactionFee() {
        return maxTransactionFee;
    }

    /**
     * Set the maximum transaction fee the operator (paying account) is willing to pay.
     *
     * @param maxTransactionFee the maximum transaction fee, in tinybars.
     * @return {@code this}
     */
    public final T setMaxTransactionFee(Hbar maxTransactionFee) {
        requireNotFrozen();
        Objects.requireNonNull(maxTransactionFee);
        this.maxTransactionFee = maxTransactionFee;
        // noinspection unchecked
        return (T) this;
    }

    /**
     * Extract the default maximum transaction fee.
     *
     * @return the default maximum transaction fee
     */
    public final Hbar getDefaultMaxTransactionFee() {
        return defaultMaxTransactionFee;
    }

    /**
     * Extract the memo for the transaction.
     *
     * @return the memo for the transaction
     */
    public final String getTransactionMemo() {
        return memo;
    }

    /**
     * Set a note or description that should be recorded in the transaction record (maximum length of 100 characters).
     *
     * @param memo any notes or descriptions for this transaction.
     * @return {@code this}
     */
    public final T setTransactionMemo(String memo) {
        requireNotFrozen();
        Objects.requireNonNull(memo);
        this.memo = memo;
        // noinspection unchecked
        return (T) this;
    }

    /**
     * Extract a byte array representation.
     *
     * @return the byte array representation
     */
    public byte[] toBytes() {
        var list = TransactionList.newBuilder();

        // If no nodes have been selected yet,
        // the new TransactionBody can be used to build a Transaction protobuf object.
        if (nodeAccountIds.isEmpty()) {
            var bodyBuilder = spawnBodyBuilder(null);
            if (!transactionIds.isEmpty()) {
                bodyBuilder.setTransactionID(transactionIds.get(0).toProtobuf());
            }
            onFreeze(bodyBuilder);

            var signedTransaction = SignedTransaction.newBuilder()
                .setBodyBytes(bodyBuilder.build().toByteString())
                .build();

            var transaction = com.hedera.hashgraph.sdk.proto.Transaction.newBuilder()
                .setSignedTransactionBytes(signedTransaction.toByteString())
                .build();

            list.addTransactionList(transaction);
        } else {
            // Generate the SignedTransaction protobuf objects if the Transaction's not frozen.
            if (!this.isFrozen()) {
                frozenBodyBuilder = spawnBodyBuilder(null);
                if (!transactionIds.isEmpty()) {
                    frozenBodyBuilder.setTransactionID(transactionIds.get(0).toProtobuf());
                }
                onFreeze(frozenBodyBuilder);

                int requiredChunks = getRequiredChunks();
                if (!transactionIds.isEmpty()){
                    generateTransactionIds(transactionIds.get(0), requiredChunks);
                }
                wipeTransactionLists(requiredChunks);
            }

            // Build all the Transaction protobuf objects and add them to the TransactionList protobuf object.
            buildAllTransactions();
            for (var transaction : outerTransactions) {
                list.addTransactionList(transaction);
            }
        }

        return list.build().toByteArray();
    }

    /**
     * Extract a byte array of the transaction hash.
     *
     * @return the transaction hash
     */
    public byte[] getTransactionHash() {
        if (!this.isFrozen()) {
            throw new IllegalStateException(
                "transaction must have been frozen before calculating the hash will be stable, try calling `freeze`");
        }

        transactionIds.setLocked(true);
        nodeAccountIds.setLocked(true);

        var index = transactionIds.getIndex() * nodeAccountIds.size() + nodeAccountIds.getIndex();

        buildTransaction(index);

        return hash(outerTransactions.get(index).getSignedTransactionBytes().toByteArray());
    }

    /**
     * Extract the list of account id and hash records.
     *
     * @return the list of account id and hash records
     */
    public Map<AccountId, byte[]> getTransactionHashPerNode() {
        if (!this.isFrozen()) {
            throw new IllegalStateException(
                "transaction must have been frozen before calculating the hash will be stable, try calling `freeze`");
        }

        buildAllTransactions();

        var hashes = new HashMap<AccountId, byte[]>();

        for (var i = 0; i < outerTransactions.size(); i++) {
            hashes.put(nodeAccountIds.get(i), hash(outerTransactions.get(i).getSignedTransactionBytes().toByteArray()));
        }

        return hashes;
    }

    @Override
    final TransactionId getTransactionIdInternal() {
        return transactionIds.getCurrent();
    }

    /**
     * Extract the transaction id.
     *
     * @return the transaction id
     */
    public final TransactionId getTransactionId() {
        if (transactionIds.isEmpty() || !this.isFrozen()) {
            throw new IllegalStateException("No transaction ID generated yet. Try freezing the transaction or manually setting the transaction ID.");
        }

        return transactionIds.setLocked(true).getCurrent();
    }

    /**
     * Set the ID for this transaction.
     * <p>
     * The transaction ID includes the operator's account ( the account paying the transaction fee). If two transactions
     * have the same transaction ID, they won't both have an effect. One will complete normally and the other will fail
     * with a duplicate transaction status.
     * <p>
     * Normally, you should not use this method. Just before a transaction is executed, a transaction ID will be
     * generated from the operator on the client.
     *
     * @param transactionId The TransactionId to be set
     * @return {@code this}
     * @see TransactionId
     */
    public final T setTransactionId(TransactionId transactionId) {
        requireNotFrozen();

        transactionIds.setList(Collections.singletonList(transactionId)).setLocked(true);

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Should the transaction id be regenerated.
     *
     * @return should the transaction id be regenerated
     */
    public final Boolean getRegenerateTransactionId() {
        return regenerateTransactionId;
    }

    /**
     * Regenerate the transaction id.
     *
     * @param regenerateTransactionId should the transaction id be regenerated
     * @return {@code this}
     */
    public final T setRegenerateTransactionId(boolean regenerateTransactionId) {
        this.regenerateTransactionId = regenerateTransactionId;

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Sign the transaction.
     *
     * @param privateKey the private key
     * @return the signed transaction
     */
    public final T sign(PrivateKey privateKey) {
        return signWith(privateKey.getPublicKey(), privateKey::sign);
    }

    /**
     * Sign the transaction.
     *
     * @param publicKey         the public key
     * @param transactionSigner the key list
     * @return {@code this}
     */
    public T signWith(PublicKey publicKey, UnaryOperator<byte[]> transactionSigner) {
        if (!isFrozen()) {
            throw new IllegalStateException("Signing requires transaction to be frozen");
        }

        if (keyAlreadySigned(publicKey)) {
            // noinspection unchecked
            return (T) this;
        }

        for (int i = 0; i < outerTransactions.size(); i++) {
            outerTransactions.set(i, null);
        }
        publicKeys.add(publicKey);
        signers.add(transactionSigner);

        // noinspection unchecked
        return (T) this;
    }

    /**
     * Sign the transaction with the configured client.
     *
     * @param client the configured client
     * @return the signed transaction
     */
    public T signWithOperator(Client client) {
        var operator = client.getOperator();

        if (operator == null) {
            throw new IllegalStateException(
                "`client` must have an `operator` to sign with the operator");
        }

        if (!isFrozen()) {
            freezeWith(client);
        }

        return signWith(operator.publicKey, operator.transactionSigner);
    }

    /**
     * Checks if a public key is already added to the transaction
     *
     * @param key the public key
     * @return if the public key is already added
     */
    protected boolean keyAlreadySigned(PublicKey key) {
        return publicKeys.contains(key);
    }

    /**
     * Add a signature to the transaction.
     *
     * @param publicKey the public key
     * @param signature the signature
     * @return {@code this}
     */
    public T addSignature(PublicKey publicKey, byte[] signature) {
        requireOneNodeAccountId();
        if (!isFrozen()) {
            freeze();
        }

        if (keyAlreadySigned(publicKey)) {
            // noinspection unchecked
            return (T) this;
        }

        transactionIds.setLocked(true);
        nodeAccountIds.setLocked(true);

        for (int i = 0; i < outerTransactions.size(); i++) {
            outerTransactions.set(i, null);
        }
        publicKeys.add(publicKey);
        signers.add(null);
        sigPairLists.get(0).addSigPair(publicKey.toSignaturePairProtobuf(signature));

        // noinspection unchecked
        return (T) this;
    }

    protected Map<AccountId, Map<PublicKey, byte[]>> getSignaturesAtOffset(int offset) {
        var map = new HashMap<AccountId, Map<PublicKey, byte[]>>(nodeAccountIds.size());

        for (int i = 0; i < nodeAccountIds.size(); i++) {
            var sigMap = sigPairLists.get(i + offset);
            var nodeAccountId = nodeAccountIds.get(i);

            var keyMap = map.containsKey(nodeAccountId) ?
                Objects.requireNonNull(map.get(nodeAccountId)) :
                new HashMap<PublicKey, byte[]>(sigMap.getSigPairCount());
            map.put(nodeAccountId, keyMap);

            for (var sigPair : sigMap.getSigPairList()) {
                keyMap.put(
                    PublicKey.fromBytes(sigPair.getPubKeyPrefix().toByteArray()),
                    sigPair.getEd25519().toByteArray()
                );
            }
        }

        return map;
    }

    /**
     * Extract list of account id and public keys.
     *
     * @return the list of account id and public keys
     */
    public Map<AccountId, Map<PublicKey, byte[]>> getSignatures() {
        if (!isFrozen()) {
            throw new IllegalStateException("Transaction must be frozen in order to have signatures.");
        }

        if (publicKeys.isEmpty()) {
            return Collections.emptyMap();
        }

        buildAllTransactions();

        return getSignaturesAtOffset(0);
    }

    /**
     * Check if transaction is frozen.
     *
     * @return is the transaction frozen
     */
    protected boolean isFrozen() {
        return frozenBodyBuilder != null;
    }

    /**
     * Throw an exception if the transaction is frozen.
     */
    protected void requireNotFrozen() {
        if (isFrozen()) {
            throw new IllegalStateException(
                "transaction is immutable; it has at least one signature or has been explicitly frozen");
        }
    }

    /**
     * Throw an exception if there is not exactly one node id set.
     */
    protected void requireOneNodeAccountId() {
        if (nodeAccountIds.size() != 1) {
            throw new IllegalStateException("transaction did not have exactly one node ID set");
        }
    }

    protected TransactionBody.Builder spawnBodyBuilder(@Nullable Client client) {
        var clientDefaultFee = client != null ? client.getDefaultMaxTransactionFee() : null;

        var defaultFee = clientDefaultFee != null ? clientDefaultFee : defaultMaxTransactionFee;

        var feeHbars = maxTransactionFee != null ? maxTransactionFee : defaultFee;

        return TransactionBody.newBuilder()
            .setTransactionFee(feeHbars.toTinybars())
            .setTransactionValidDuration(DurationConverter.toProtobuf(transactionValidDuration).toBuilder())
            .setMemo(memo);
    }

    /**
     * Freeze this transaction from further modification to prepare for signing or serialization.
     *
     * @return {@code this}
     */
    public T freeze() {
        return freezeWith(null);
    }

    /**
     * Freeze this transaction from further modification to prepare for signing or serialization.
     * <p>
     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3 nodes to prepare this
     * transaction for.
     *
     * @param client the configured client
     * @return {@code this}
     */
    public T freezeWith(@Nullable Client client) {
        if (isFrozen()) {
            // noinspection unchecked
            return (T) this;
        }

        if (transactionIds.isEmpty()) {
            if (client != null) {
                var operator = client.getOperator();

                if (operator != null) {
                    // Set a default transaction ID, generated from the operator account ID

                    transactionIds.setList(Collections.singletonList(TransactionId.generate(operator.accountId)));
                } else {
                    // no client means there must be an explicitly set node ID and transaction ID
                    throw new IllegalStateException(
                        "`client` must have an `operator` or `transactionId` must be set");
                }
            } else {
                throw new IllegalStateException(
                    "Transaction ID must be set, or operator must be provided via freezeWith()");
            }
        }

        if (nodeAccountIds.isEmpty()) {
            if (client == null) {
                throw new IllegalStateException(
                    "`client` must be provided or both `nodeId` and `transactionId` must be set");
            }

            try {
                nodeAccountIds.setList(client.network.getNodeAccountIdsForExecute());
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

        frozenBodyBuilder = spawnBodyBuilder(client).setTransactionID(transactionIds.get(0).toProtobuf());
        onFreeze(frozenBodyBuilder);

        int requiredChunks = getRequiredChunks();
        generateTransactionIds(transactionIds.get(0), requiredChunks);
        wipeTransactionLists(requiredChunks);

        var clientDefaultRegenerateTransactionId = client != null ? client.getDefaultRegenerateTransactionId() : null;
        regenerateTransactionId =
            regenerateTransactionId != null ? regenerateTransactionId : clientDefaultRegenerateTransactionId;

        // noinspection unchecked
        return (T) this;
    }

    /**
     * There must be at least one chunk.
     *
     * @return there is 1 required chunk
     */
    int getRequiredChunks() {
        return 1;
    }

    /**
     * Generate transaction id's.
     *
     * @param initialTransactionId the initial transaction id
     * @param count                the number of id's to generate.
     */
    void generateTransactionIds(TransactionId initialTransactionId, int count) {
        var locked = transactionIds.isLocked();
        transactionIds.setLocked(false);

        if (count == 1) {
            transactionIds.setList(Collections.singletonList(initialTransactionId));
            return;
        }

        var nextTransactionId = initialTransactionId.toProtobuf().toBuilder();
        transactionIds.ensureCapacity(count);
        transactionIds.clear();
        for (int i = 0; i < count; i++) {
            transactionIds.add(TransactionId.fromProtobuf(nextTransactionId.build()));

            // add 1 ns to the validStart to make cascading transaction IDs
            var nextValidStart = nextTransactionId.getTransactionValidStart().toBuilder();
            nextValidStart.setNanos(nextValidStart.getNanos() + 1);

            nextTransactionId.setTransactionValidStart(nextValidStart);
        }

        transactionIds.setLocked(locked);
    }

    /**
     * Wipe / reset the transaction list.
     *
     * @param requiredChunks the number of required chunks
     */
    void wipeTransactionLists(int requiredChunks) {
        if (!transactionIds.isEmpty()) {
            Objects.requireNonNull(frozenBodyBuilder).setTransactionID(getTransactionIdInternal().toProtobuf());
        }

        outerTransactions = new ArrayList<>(nodeAccountIds.size());
        sigPairLists = new ArrayList<>(nodeAccountIds.size());
        innerSignedTransactions = new ArrayList<>(nodeAccountIds.size());

        for (AccountId nodeId : nodeAccountIds) {
            sigPairLists.add(SignatureMap.newBuilder());
            innerSignedTransactions.add(SignedTransaction.newBuilder()
                .setBodyBytes(Objects.requireNonNull(frozenBodyBuilder)
                    .setNodeAccountID(nodeId.toProtobuf())
                    .build()
                    .toByteString()
                ));
            outerTransactions.add(null);
        }
    }

    /**
     * Build all the transactions.
     */
    void buildAllTransactions() {
        transactionIds.setLocked(true);
        nodeAccountIds.setLocked(true);

        for (var i = 0; i < innerSignedTransactions.size(); ++i) {
            buildTransaction(i);
        }
    }

    /**
     * Will build the specific transaction at {@code index} This function is only ever called after the transaction is
     * frozen.
     *
     * @param index the index of the transaction to be built
     */
    void buildTransaction(int index) {
        // Check if transaction is already built.
        // Every time a signer is added via sign() or signWith(), all outerTransactions are nullified.
        if (
            outerTransactions.get(index) != null &&
                !outerTransactions.get(index).getSignedTransactionBytes().isEmpty()
        ) {
            return;
        }

        signTransaction(index);

        outerTransactions.set(index, com.hedera.hashgraph.sdk.proto.Transaction.newBuilder()
            .setSignedTransactionBytes(
                innerSignedTransactions.get(index)
                    .setSigMap(sigPairLists.get(index))
                    .build()
                    .toByteString()
            ).build());
    }

    /**
     * Will sign the specific transaction at {@code index} This function is only ever called after the transaction is
     * frozen.
     *
     * @param index the index of the transaction to sign
     */
    void signTransaction(int index) {
        var bodyBytes = innerSignedTransactions.get(index).getBodyBytes().toByteArray();
        var thisSigPairList = sigPairLists.get(index).getSigPairList();

        for (var i = 0; i < publicKeys.size(); i++) {
            if (signers.get(i) == null) {
                continue;
            }
            if (publicKeyIsInSigPairList(ByteString.copyFrom(publicKeys.get(i).toBytesRaw()), thisSigPairList)) {
                continue;
            }

            var signatureBytes = signers.get(i).apply(bodyBytes);

            sigPairLists
                .get(index)
                .addSigPair(publicKeys.get(i).toSignaturePairProtobuf(signatureBytes));
        }
    }

    /**
     * Called in {@link #freezeWith(Client)} just before the transaction body is built. The intent is for the derived
     * class to assign their data variant to the transaction body.
     */
    abstract void onFreeze(TransactionBody.Builder bodyBuilder);

    /**
     * Called in {@link #schedule()} when converting transaction into a scheduled version.
     */
    abstract void onScheduled(SchedulableTransactionBody.Builder scheduled);

    @Override
    final com.hedera.hashgraph.sdk.proto.Transaction makeRequest() {
        var index = nodeAccountIds.getIndex() + (transactionIds.getIndex() * nodeAccountIds.size());

        buildTransaction(index);

        return outerTransactions.get(index);
    }

    @Override
    TransactionResponse mapResponse(
        com.hedera.hashgraph.sdk.proto.TransactionResponse transactionResponse,
        AccountId nodeId,
        com.hedera.hashgraph.sdk.proto.Transaction request
    ) {
        var transactionId = Objects.requireNonNull(getTransactionIdInternal());
        var hash = hash(request.getSignedTransactionBytes().toByteArray());
        transactionIds.advance();
        return new TransactionResponse(nodeId, transactionId, hash, null);
    }

    @Override
    final Status mapResponseStatus(com.hedera.hashgraph.sdk.proto.TransactionResponse transactionResponse) {
        return Status.valueOf(transactionResponse.getNodeTransactionPrecheckCode());
    }

    abstract void validateChecksums(Client client) throws BadEntityIdException;

    /**
     * Prepare the transactions to be executed.
     *
     * @param client the configured client
     */
    void onExecute(Client client) {
        if (!isFrozen()) {
            freezeWith(client);
        }

        var accountId = Objects.requireNonNull(Objects.requireNonNull(transactionIds.get(0)).accountId);

        if (client.isAutoValidateChecksumsEnabled()) {
            try {
                accountId.validateChecksum(client);
                validateChecksums(client);
            } catch (BadEntityIdException exc) {
                throw new IllegalArgumentException(exc.getMessage());
            }
        }

        var operatorId = client.getOperatorAccountId();
        if (operatorId != null && operatorId.equals(accountId)) {
            // on execute, sign each transaction with the operator, if present
            // and we are signing a transaction that used the default transaction ID
            signWithOperator(client);
        }
    }

    @Override
    CompletableFuture<Void> onExecuteAsync(Client client) {
        onExecute(client);
        return CompletableFuture.completedFuture(null);
    }

    @Override
    ExecutionState getExecutionState(Status status, com.hedera.hashgraph.sdk.proto.TransactionResponse response) {
        if (status == Status.TRANSACTION_EXPIRED) {
            if ((regenerateTransactionId != null && !regenerateTransactionId) || transactionIds.isLocked()) {
                return ExecutionState.REQUEST_ERROR;
            } else {
                var firstTransactionId = Objects.requireNonNull(transactionIds.get(0));
                var accountId = Objects.requireNonNull(firstTransactionId.accountId);
                generateTransactionIds(TransactionId.generate(accountId), transactionIds.size());
                wipeTransactionLists(transactionIds.size());
                return ExecutionState.RETRY;
            }
        }
        return super.getExecutionState(status, response);
    }

    @Override
    @SuppressWarnings("LiteProtoToString")
    public String toString() {
        // NOTE: regex is for removing the instance address from the default debug output
        TransactionBody.Builder body = spawnBodyBuilder(null);

        if (!transactionIds.isEmpty()) {
            body.setTransactionID(transactionIds.get(0).toProtobuf());
        }
        if (!nodeAccountIds.isEmpty()) {
            body.setNodeAccountID(nodeAccountIds.get(0).toProtobuf());
        }

        onFreeze(body);

        return body.buildPartial().toString().replaceAll("@[A-Za-z0-9]+", "");
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionFeeSchedule.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * The fees for a specific transaction or query based on the fee data.
 *
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/basic-types/transactionfeeschedule">Hedera Documentation</a>
 */
public class TransactionFeeSchedule implements Cloneable {
    private RequestType requestType;
    @Nullable
    private FeeData feeData;
    private List<FeeData> fees;

    /**
     * Constructor.
     */
    public TransactionFeeSchedule() {
        requestType = RequestType.NONE;
        feeData = null;
        fees = new ArrayList<>();
    }

    /**
     * Create a transaction fee schedule object from a protobuf.
     *
     * @param transactionFeeSchedule    the protobuf
     * @return                          the new transaction fee schedule
     */
    static TransactionFeeSchedule fromProtobuf(com.hedera.hashgraph.sdk.proto.TransactionFeeSchedule transactionFeeSchedule) {
        var returnFeeSchedule = new TransactionFeeSchedule()
            .setRequestType(RequestType.valueOf(transactionFeeSchedule.getHederaFunctionality()))
            .setFeeData(transactionFeeSchedule.hasFeeData() ? FeeData.fromProtobuf(transactionFeeSchedule.getFeeData()) : null);
        for (var feeData : transactionFeeSchedule.getFeesList()) {
            returnFeeSchedule.addFee(FeeData.fromProtobuf(feeData));
        }
        return returnFeeSchedule;
    }

    /**
     * Create a transaction fee schedule object from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new transaction fee schedule
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TransactionFeeSchedule fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TransactionFeeSchedule.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the request type.
     *
     * @return                          the request type
     */
    public RequestType getRequestType() {
        return requestType;
    }

    /**
     * Assign the request type.
     *
     * @param requestType               the request type
     * @return {@code this}
     */
    public TransactionFeeSchedule setRequestType(RequestType requestType) {
        this.requestType = requestType;
        return this;
    }

    /**
     * Get the total fee charged for a transaction
     *
     * @return the feeData
     */
    @Deprecated
    @Nullable
    public FeeData getFeeData() {
        return feeData;
    }

    /**
     * Set the total fee charged for a transaction
     *
     * @param feeData the feeData to set
     * @return {@code this}
     */
    @Deprecated
    public TransactionFeeSchedule setFeeData(@Nullable FeeData feeData) {
        this.feeData = feeData;
        return this;
    }

    /**
     * Extract the list of fee's.
     *
     * @return                          the list of fee's
     */
    public List<FeeData> getFees() {
        return Collections.unmodifiableList(fees);
    }

    /**
     * Add a fee to the schedule.
     *
     * @param fee                       the fee to add
     * @return {@code this}
     */
    public TransactionFeeSchedule addFee(FeeData fee) {
        fees.add(Objects.requireNonNull(fee));
        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link
     *         com.hedera.hashgraph.sdk.proto.TransactionFeeSchedule}
     */
    com.hedera.hashgraph.sdk.proto.TransactionFeeSchedule toProtobuf() {
        var returnBuilder = com.hedera.hashgraph.sdk.proto.TransactionFeeSchedule.newBuilder()
            .setHederaFunctionality(getRequestType().code);
        if (feeData != null) {
            returnBuilder.setFeeData(feeData.toProtobuf());
        }
        for (var fee : fees) {
            returnBuilder.addFees(fee.toProtobuf());
        }
        return returnBuilder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("requestType", getRequestType())
            .add("feeData", getFeeData())
            .add("fees", getFees())
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    List<FeeData> cloneFees() {
        List<FeeData> cloneFees = new ArrayList<>(fees.size());
        for (var fee : fees) {
            cloneFees.add(fee.clone());
        }
        return cloneFees;
    }

    @Override
    public TransactionFeeSchedule clone() {
        try {
            TransactionFeeSchedule clone = (TransactionFeeSchedule) super.clone();
            clone.feeData = feeData != null ? feeData.clone() : null;
            clone.fees = fees != null ? cloneFees() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionId.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static java.util.concurrent.CompletableFuture.completedFuture;
import static java.util.concurrent.CompletableFuture.failedFuture;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import java.time.Duration;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;

/**
 * The client-generated ID for a transaction.
 *
 * <p>This is used for retrieving receipts and records for a transaction, for appending to a file
 * right after creating it, for instantiating a smart contract with bytecode in a file just created,
 * and internally by the network for detecting when duplicate transactions are submitted.
 */
public final class TransactionId implements Comparable<TransactionId> {
    /**
     * The Account ID that paid for this transaction.
     */
    @Nullable
    public final AccountId accountId;

    /**
     * The time from when this transaction is valid.
     *
     * <p>When a transaction is submitted there is additionally a validDuration (defaults to 120s)
     * and together they define a time window that a transaction may be processed in.
     */
    @Nullable
    public final Instant validStart;

    private boolean scheduled = false;

    @Nullable
    private Integer nonce = null;

    private static final long NANOSECONDS_PER_MILLISECOND = 1_000_000L;

    private static final long TIMESTAMP_INCREMENT_NANOSECONDS = 1_000L;

    private static final long NANOSECONDS_TO_REMOVE = 10000000000L;

    private static final AtomicLong monotonicTime = new AtomicLong();


    /**
     * No longer part of the public API. Use `Transaction.withValidStart()` instead.
     *
     * @param accountId     the account id
     * @param validStart    the valid start time
     */
    public TransactionId(@Nullable AccountId accountId, @Nullable Instant validStart) {
        this.accountId = accountId;
        this.validStart = validStart;
        this.scheduled = false;
    }

    /**
     * Create a transaction id.
     *
     * @param accountId                 the account id
     * @param validStart                the valid start time
     * @return                          the new transaction id
     */
    public static TransactionId withValidStart(AccountId accountId, Instant validStart) {
        return new TransactionId(accountId, validStart);
    }

    /**
     * Generates a new transaction ID for the given account ID.
     *
     * <p>Note that transaction IDs are made of the valid start of the transaction and the account
     * that will be charged the transaction fees for the transaction.
     *
     * @param accountId the ID of the Hedera account that will be charge the transaction fees.
     * @return {@link com.hedera.hashgraph.sdk.TransactionId}
     */
    public static TransactionId generate(AccountId accountId) {
        long currentTime;
        long lastTime;

        // Loop to ensure the generated timestamp is strictly increasing,
        // and it handles the case where the system clock appears to move backward
        // or if multiple threads attempt to generate a timestamp concurrently.
        do {
            // Get the current time in nanoseconds and remove a few seconds to allow for some time drift
            // between the client and the receiving node and prevented spurious INVALID_TRANSACTION_START.
            currentTime = System.currentTimeMillis() * NANOSECONDS_PER_MILLISECOND - NANOSECONDS_TO_REMOVE;

            // Get the last recorded timestamp.
            lastTime = monotonicTime.get();

            // If the current time is less than or equal to the last recorded time,
            // adjust the timestamp to ensure it is strictly increasing.
            if (currentTime <= lastTime) {
                currentTime = lastTime + TIMESTAMP_INCREMENT_NANOSECONDS;
            }
        } while (!monotonicTime.compareAndSet(lastTime, currentTime));

        return new TransactionId(accountId, Instant.ofEpochSecond(0, currentTime));
    }

    /**
     * Create a transaction id from a protobuf.
     *
     * @param transactionID             the protobuf
     * @return                          the new transaction id
     */
    static TransactionId fromProtobuf(TransactionID transactionID) {
        var accountId = transactionID.hasAccountID() ? AccountId.fromProtobuf(transactionID.getAccountID()) : null;
        var validStart = transactionID.hasTransactionValidStart() ? InstantConverter.fromProtobuf(transactionID.getTransactionValidStart()) : null;

        return new TransactionId(accountId, validStart)
            .setScheduled(transactionID.getScheduled())
            .setNonce((transactionID.getNonce() != 0) ? transactionID.getNonce() : null);
    }

    /**
     * Create a new transaction id from a string.
     *
     * @param s                         the string representing the transaction id
     * @return                          the new transaction id
     */
    public static TransactionId fromString(String s) {
        @Var
        var parts = s.split("/", 2);

        var nonce = (parts.length == 2) ? Integer.parseInt(parts[1]) : null;

        parts = parts[0].split("\\?", 2);

        var scheduled = parts.length == 2 && parts[1].equals("scheduled");

        parts = parts[0].split("@", 2);

        if (parts.length != 2) {
            throw new IllegalArgumentException("expecting {account}@{seconds}.{nanos}[?scheduled][/nonce]");
        }

        @Nullable AccountId accountId = AccountId.fromString(parts[0]);

        var validStartParts = parts[1].split("\\.", 2);

        if (validStartParts.length != 2) {
            throw new IllegalArgumentException("expecting {account}@{seconds}.{nanos}");
        }

        @Nullable Instant validStart = Instant.ofEpochSecond(
            Long.parseLong(validStartParts[0]),
            Long.parseLong(validStartParts[1]));

        return new TransactionId(accountId, validStart).setScheduled(scheduled).setNonce(nonce);
    }

    /**
     * Create a new transaction id from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new transaction id
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TransactionId fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(TransactionID.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Extract the scheduled status.
     *
     * @return                          the scheduled status
     */
    public boolean getScheduled() {
        return scheduled;
    }

    /**
     * Assign the scheduled status.
     *
     * @param scheduled                 the scheduled status
     * @return {@code this}
     */
    public TransactionId setScheduled(boolean scheduled) {
        this.scheduled = scheduled;
        return this;
    }

    /**
     * Extract the nonce.
     *
     * @return                          the nonce value
     */
    @Nullable
    public Integer getNonce() {
        return nonce;
    }

    /**
     * Assign the nonce value.
     *
     * @param nonce                     the nonce value
     * @return {@code this}
     */
    public TransactionId setNonce(@Nullable Integer nonce) {
        this.nonce = nonce;
        return this;
    }

    /**
     * Fetch the receipt of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @return                          the transaction receipt
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionReceipt getReceipt(Client client) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        return getReceipt(client, client.getRequestTimeout());
    }

    /**
     * Fetch the receipt of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the transaction receipt
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionReceipt getReceipt(Client client, Duration timeout) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        var receipt = new TransactionReceiptQuery()
            .setTransactionId(this)
            .execute(client, timeout);

        if (receipt.status != Status.SUCCESS) {
            throw new ReceiptStatusException(this, receipt);
        }

        return receipt;
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @return                          future result of the transaction receipt
     */
    public CompletableFuture<TransactionReceipt> getReceiptAsync(Client client) {
        return getReceiptAsync(client, client.getRequestTimeout());
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the transaction receipt
     */
    public CompletableFuture<TransactionReceipt> getReceiptAsync(Client client, Duration timeout) {
        return new TransactionReceiptQuery()
            .setTransactionId(this)
            .executeAsync(client, timeout)
            .thenCompose(receipt -> {
                if (receipt.status != Status.SUCCESS) {
                    return failedFuture(new ReceiptStatusException(this, receipt));
                }

                return completedFuture(receipt);
            });
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getReceiptAsync(Client client, BiConsumer<TransactionReceipt, Throwable> callback) {
        ConsumerHelper.biConsumer(getReceiptAsync(client), callback);
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getReceiptAsync(Client client, Duration timeout, BiConsumer<TransactionReceipt, Throwable> callback) {
        ConsumerHelper.biConsumer(getReceiptAsync(client, timeout), callback);
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getReceiptAsync(Client client, Consumer<TransactionReceipt> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getReceiptAsync(client), onSuccess, onFailure);
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getReceiptAsync(Client client, Duration timeout, Consumer<TransactionReceipt> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getReceiptAsync(client, timeout), onSuccess, onFailure);
    }

    /**
     * Fetch the record of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @return                          the transaction record
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionRecord getRecord(Client client) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        return getRecord(client, client.getRequestTimeout());
    }

    /**
     * Fetch the record of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the transaction record
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionRecord getRecord(Client client, Duration timeout) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        getReceipt(client, timeout);

        return new TransactionRecordQuery()
            .setTransactionId(this)
            .execute(client, timeout);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @return                          future result of the transaction record
     */
    public CompletableFuture<TransactionRecord> getRecordAsync(Client client) {
        return getRecordAsync(client, client.getRequestTimeout());
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          future result of the transaction record
     */
    public CompletableFuture<TransactionRecord> getRecordAsync(Client client, Duration timeout) {
        // note: we get the receipt first to ensure consensus has been reached
        return getReceiptAsync(client, timeout).thenCompose(receipt -> new TransactionRecordQuery()
            .setTransactionId(this)
            .executeAsync(client, timeout));
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getRecordAsync(Client client, BiConsumer<TransactionRecord, Throwable> callback) {
        ConsumerHelper.biConsumer(getRecordAsync(client), callback);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getRecordAsync(Client client, Duration timeout, BiConsumer<TransactionRecord, Throwable> callback) {
        ConsumerHelper.biConsumer(getRecordAsync(client, timeout), callback);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getRecordAsync(Client client, Consumer<TransactionRecord> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getRecordAsync(client), onSuccess, onFailure);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getRecordAsync(Client client, Duration timeout, Consumer<TransactionRecord> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getRecordAsync(client, timeout), onSuccess, onFailure);
    }

    /**
     * Extract the transaction id protobuf.
     *
     * @return                          the protobuf representation
     */
    TransactionID toProtobuf() {
        var id = TransactionID.newBuilder()
            .setScheduled(scheduled)
            .setNonce((nonce != null) ? nonce : 0);

        if (accountId != null) {
            id.setAccountID(accountId.toProtobuf());
        }

        if (validStart != null) {
            id.setTransactionValidStart(InstantConverter.toProtobuf(validStart));
        }

        return id.build();
    }

    private String toStringPostfix() {
        Objects.requireNonNull(validStart);
        return "@" + validStart.getEpochSecond() + "." + String.format("%09d", validStart.getNano()) +
            (scheduled ? "?scheduled" : "") + ((nonce != null) ? "/" + nonce : "");
    }

    @Override
    public String toString() {
        if (accountId != null && validStart != null) {
            return "" + accountId + toStringPostfix();
        } else {
            throw new IllegalStateException("`TransactionId.toString()` is non-exhaustive");
        }
    }

    /**
     * Convert to a string representation with checksum.
     *
     * @param client                    the configured client
     * @return                          the string representation with checksum
     */
    public String toStringWithChecksum(Client client) {
        if (accountId != null && validStart != null) {
            return "" + accountId.toStringWithChecksum(client) + toStringPostfix();
        } else {
            throw new IllegalStateException("`TransactionId.toStringWithChecksum()` is non-exhaustive");
        }
    }

    /**
     * Extract the byte array representation.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }

    @Override
    public boolean equals( Object object) {
        if (!(object instanceof TransactionId)) {
            return false;
        }

        var id = (TransactionId) object;

        if (accountId != null && validStart != null && id.accountId != null && id.validStart != null) {
            return id.accountId.equals(accountId) && id.validStart.equals(validStart) && scheduled == id.scheduled;
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return toString().hashCode();
    }

    @Override
    public int compareTo(TransactionId o) {
        Objects.requireNonNull(o);
        if (scheduled != o.scheduled) {
            return scheduled ? 1 : -1;
        }
        var thisAccountIdIsNull = (accountId == null);
        var otherAccountIdIsNull = (o.accountId == null);
        if (thisAccountIdIsNull != otherAccountIdIsNull) {
            return thisAccountIdIsNull ? -1 : 1;
        }
        if (!thisAccountIdIsNull) {
            int accountIdComparison = accountId.compareTo(o.accountId);
            if (accountIdComparison != 0) {
                return accountIdComparison;
            }
        }
        var thisStartIsNull = (validStart == null);
        var otherStartIsNull = (o.validStart == null);
        if (thisStartIsNull != otherStartIsNull) {
            return thisAccountIdIsNull ? -1 : 1;
        }
        if (!thisStartIsNull) {
            return validStart.compareTo(o.validStart);
        }
        return 0;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionReceipt.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ExchangeRateSet;
import com.hedera.hashgraph.sdk.proto.TimestampSeconds;
import org.bouncycastle.util.encoders.Hex;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

/**
 * The consensus result for a transaction, which might not be currently
 * known, or may succeed or fail.
 */
public final class TransactionReceipt {

    /**
     * The transaction's ID
     */
    @Nullable
    public final TransactionId transactionId;
    /**
     * Whether the transaction succeeded or failed (or is unknown).
     */
    public final Status status;

    /**
     * The exchange rate of Hbars to cents (USD).
     */
    public final ExchangeRate exchangeRate;

    /**
     * The account ID, if a new account was created.
     */
    @Nullable
    public final AccountId accountId;

    /**
     * The file ID, if a new file was created.
     */
    @Nullable
    public final FileId fileId;

    /**
     * The contract ID, if a new contract was created.
     */
    @Nullable
    public final ContractId contractId;

    /**
     * The topic ID, if a new topic was created.
     */
    @Nullable
    public final TopicId topicId;

    /**
     * The token ID, if a new token was created.
     */
    @Nullable
    public final TokenId tokenId;

    /**
     * Updated sequence number for a consensus service topic.
     * Set for {@link TopicMessageSubmitTransaction}.
     */
    @Nullable
    public final Long topicSequenceNumber;

    /**
     * Updated running hash for a consensus service topic.
     * Set for {@link TopicMessageSubmitTransaction}.
     */
    @Nullable
    public final ByteString topicRunningHash;

    /**
     * In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
     * supply of this token. For non fungible tokens - the total number of NFTs issued for a given
     * tokenID
     */
    public final Long totalSupply;

    /**
     * In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity
     */
    @Nullable
    public final ScheduleId scheduleId;

    /**
     * In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
     * TransactionID that should be used to query for the receipt or record of the relevant
     * scheduled transaction
     */
    @Nullable
    public final TransactionId scheduledTransactionId;

    /**
     * In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
     * the newly created NFTs
     */
    public final List<Long> serials;

    /**
     * In the receipt of a NodeCreate, NodeUpdate, NodeDelete, the id of the newly created node.
     * An affected node identifier.<br/>
     * This value SHALL be set following a `createNode` transaction.<br/>
     * This value SHALL be set following a `updateNode` transaction.<br/>
     * This value SHALL be set following a `deleteNode` transaction.<br/>
     * This value SHALL NOT be set following any other transaction.
     */
    public final long nodeId;

    /**
     * The receipts of processing all transactions with the given id, in consensus time order.
     */
    public final List<TransactionReceipt> duplicates;

    /**
     * The receipts (if any) of all child transactions spawned by the transaction with the
     * given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
     */
    public final List<TransactionReceipt> children;

    TransactionReceipt(
        @Nullable TransactionId transactionId,
        Status status,
        ExchangeRate exchangeRate,
        @Nullable AccountId accountId,
        @Nullable FileId fileId,
        @Nullable ContractId contractId,
        @Nullable TopicId topicId,
        @Nullable TokenId tokenId,
        @Nullable Long topicSequenceNumber,
        @Nullable ByteString topicRunningHash,
        Long totalSupply,
        @Nullable ScheduleId scheduleId,
        @Nullable TransactionId scheduledTransactionId,
        List<Long> serials,
        long nodeId,
        List<TransactionReceipt> duplicates,
        List<TransactionReceipt> children
    ) {
        this.transactionId = transactionId;
        this.status = status;
        this.exchangeRate = exchangeRate;
        this.accountId = accountId;
        this.fileId = fileId;
        this.contractId = contractId;
        this.topicId = topicId;
        this.tokenId = tokenId;
        this.topicSequenceNumber = topicSequenceNumber;
        this.topicRunningHash = topicRunningHash;
        this.totalSupply = totalSupply;
        this.scheduleId = scheduleId;
        this.scheduledTransactionId = scheduledTransactionId;
        this.serials = serials;
        this.nodeId = nodeId;
        this.duplicates = duplicates;
        this.children = children;
    }

    /**
     * Create transaction receipt from protobuf.
     *
     * @param transactionReceipt        the protobuf
     * @param duplicates                list of duplicates
     * @param children                  list of children
     * @return                          the new transaction receipt
     */
    static TransactionReceipt fromProtobuf(
        com.hedera.hashgraph.sdk.proto.TransactionReceipt transactionReceipt,
        List<TransactionReceipt> duplicates,
        List<TransactionReceipt> children,
        @Nullable TransactionId transactionId
    ) {
        var status = Status.valueOf(transactionReceipt.getStatus());

        var rate = transactionReceipt.getExchangeRate();
        var exchangeRate = ExchangeRate.fromProtobuf(rate.getCurrentRate());

        var accountId =
            transactionReceipt.hasAccountID()
                ? AccountId.fromProtobuf(transactionReceipt.getAccountID())
                : null;

        var fileId =
            transactionReceipt.hasFileID()
                ? FileId.fromProtobuf(transactionReceipt.getFileID())
                : null;

        var contractId =
            transactionReceipt.hasContractID()
                ? ContractId.fromProtobuf(transactionReceipt.getContractID())
                : null;

        var topicId =
            transactionReceipt.hasTopicID()
                ? TopicId.fromProtobuf(transactionReceipt.getTopicID())
                : null;

        var tokenId =
            transactionReceipt.hasTokenID()
                ? TokenId.fromProtobuf(transactionReceipt.getTokenID())
                : null;

        var topicSequenceNumber =
            transactionReceipt.getTopicSequenceNumber() == 0
                ? null
                : transactionReceipt.getTopicSequenceNumber();

        var topicRunningHash =
            transactionReceipt.getTopicRunningHash().isEmpty()
                ? null
                : transactionReceipt.getTopicRunningHash();

        var totalSupply = transactionReceipt.getNewTotalSupply();

        var scheduleId =
            transactionReceipt.hasScheduleID()
                ? ScheduleId.fromProtobuf(transactionReceipt.getScheduleID())
                : null;

        var scheduledTransactionId =
            transactionReceipt.hasScheduledTransactionID()
                ? TransactionId.fromProtobuf(transactionReceipt.getScheduledTransactionID())
                : null;

        var serials = transactionReceipt.getSerialNumbersList();

        var nodeId = transactionReceipt.getNodeId();

        return new TransactionReceipt(
            transactionId,
            status,
            exchangeRate,
            accountId,
            fileId,
            contractId,
            topicId,
            tokenId,
            topicSequenceNumber,
            topicRunningHash,
            totalSupply,
            scheduleId,
            scheduledTransactionId,
            serials,
            nodeId,
            duplicates,
            children
        );
    }

    /**
     * Create a transaction receipt from a protobuf.
     *
     * @param transactionReceipt        the protobuf
     * @return                          the new transaction receipt
     */
    public static TransactionReceipt fromProtobuf(com.hedera.hashgraph.sdk.proto.TransactionReceipt transactionReceipt) {
        return fromProtobuf(transactionReceipt, new ArrayList<>(), new ArrayList<>(), null);
    }

    static TransactionReceipt fromProtobuf(
        com.hedera.hashgraph.sdk.proto.TransactionReceipt transactionReceipt,
        @Nullable TransactionId transactionId
    ) {
        return fromProtobuf(transactionReceipt, new ArrayList<>(), new ArrayList<>(), transactionId);
    }

    /**
     * Create a transaction receipt from a byte array.
     *
     * @param bytes                     the byte array
     * @return                          the new transaction receipt
     * @throws InvalidProtocolBufferException       when there is an issue with the protobuf
     */
    public static TransactionReceipt fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TransactionReceipt.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Validate the transaction status in the receipt.
     *
     * @param shouldValidate Whether to perform transaction status validation
     * @return {@code this}
     * @throws ReceiptStatusException when shouldValidate is true and the transaction status is not SUCCESS
     */
    public TransactionReceipt validateStatus(boolean shouldValidate) throws ReceiptStatusException {
        if (shouldValidate && status != Status.SUCCESS && status != Status.FEE_SCHEDULE_FILE_PART_UPLOADED) {
            throw new ReceiptStatusException(transactionId, this);
        }
        return this;
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.TransactionReceipt toProtobuf() {
        var transactionReceiptBuilder = com.hedera.hashgraph.sdk.proto.TransactionReceipt.newBuilder()
            .setStatus(status.code)
            .setExchangeRate(ExchangeRateSet.newBuilder()
                .setCurrentRate(com.hedera.hashgraph.sdk.proto.ExchangeRate.newBuilder()
                    .setHbarEquiv(exchangeRate.hbars)
                    .setCentEquiv(exchangeRate.cents)
                    .setExpirationTime(TimestampSeconds.newBuilder()
                        .setSeconds(exchangeRate.expirationTime.getEpochSecond())
                    )
                )
            )
            .setNewTotalSupply(totalSupply);

        if (accountId != null) {
            transactionReceiptBuilder.setAccountID(accountId.toProtobuf());
        }

        if (fileId != null) {
            transactionReceiptBuilder.setFileID(fileId.toProtobuf());
        }

        if (contractId != null) {
            transactionReceiptBuilder.setContractID(contractId.toProtobuf());
        }

        if (topicId != null) {
            transactionReceiptBuilder.setTopicID(topicId.toProtobuf());
        }

        if (tokenId != null) {
            transactionReceiptBuilder.setTokenID(tokenId.toProtobuf());
        }

        if (topicSequenceNumber != null) {
            transactionReceiptBuilder.setTopicSequenceNumber(topicSequenceNumber);
        }

        if (topicRunningHash != null) {
            transactionReceiptBuilder.setTopicRunningHash(topicRunningHash);
        }

        if (scheduleId != null) {
            transactionReceiptBuilder.setScheduleID(scheduleId.toProtobuf());
        }

        if (scheduledTransactionId != null) {
            transactionReceiptBuilder.setScheduledTransactionID(scheduledTransactionId.toProtobuf());
        }

        for (var serial : serials) {
            transactionReceiptBuilder.addSerialNumbers(serial);
        }

        transactionReceiptBuilder.setNodeId(nodeId);

        return transactionReceiptBuilder.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("transactionId", transactionId)
            .add("status", status)
            .add("exchangeRate", exchangeRate)
            .add("accountId", accountId)
            .add("fileId", fileId)
            .add("contractId", contractId)
            .add("topicId", topicId)
            .add("tokenId", tokenId)
            .add("topicSequenceNumber", topicSequenceNumber)
            .add("topicRunningHash", topicRunningHash != null ? Hex.encode(topicRunningHash.toByteArray()) : null)
            .add("totalSupply", totalSupply)
            .add("scheduleId", scheduleId)
            .add("scheduledTransactionId", scheduledTransactionId)
            .add("serials", serials)
            .add("nodeId", nodeId)
            .add("duplicates", duplicates)
            .add("children", children)
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return                          the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionReceiptQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.TransactionGetReceiptQuery;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Get the receipt of a transaction, given its transaction ID.
 *
 * <p>Once a transaction reaches consensus, then information about whether it succeeded or failed
 * will be available until the end of the receipt period.
 *
 * <p>This query is free.
 */
public final class TransactionReceiptQuery
    extends Query<TransactionReceipt, TransactionReceiptQuery> {

    @Nullable
    private TransactionId transactionId = null;
    private boolean includeChildren = false;
    private boolean includeDuplicates = false;

    /**
     * Constructor.
     */
    public TransactionReceiptQuery() {
    }

    /**
     * Extract the transaction id.
     *
     * @return                          the transaction id
     */
    @Override
    @Nullable
    public TransactionId getTransactionIdInternal() {
        return transactionId;
    }

    /**
     * Set the ID of the transaction for which the receipt is being requested.
     *
     * @param transactionId The TransactionId to be set
     * @return {@code this}
     */
    public TransactionReceiptQuery setTransactionId(TransactionId transactionId) {
        Objects.requireNonNull(transactionId);
        this.transactionId = transactionId;
        return this;
    }

    /**
     * Should the children be included?
     *
     * @return                          should children be included
     */
    public boolean getIncludeChildren() {
        return includeChildren;
    }

    /**
     * Whether the response should include the records of any child transactions spawned by the
     * top-level transaction with the given transactionID.
     *
     * @param value The value that includeChildren should be set to; true to include children, false to exclude
     * @return {@code this}
     */
    public TransactionReceiptQuery setIncludeChildren(boolean value) {
        includeChildren = value;
        return this;
    }

    /**
     * Should duplicates be included?
     *
     * @return                          should duplicates be included
     */
    public boolean getIncludeDuplicates() {
        return includeDuplicates;
    }

    /**
     * Whether records of processing duplicate transactions should be returned along with the record
     * of processing the first consensus transaction with the given id whose status was neither
     * INVALID_NODE_ACCOUNT nor INVALID_PAYER_SIGNATURE or, if no such
     * record exists, the record of processing the first transaction to reach consensus with the
     * given transaction id.
     *
     * @param value The value that includeDuplicates should be set to; true to include duplicates, false to exclude
     * @return {@code this}
     */
    public TransactionReceiptQuery setIncludeDuplicates(boolean value) {
        includeDuplicates = value;
        return this;
    }

    @Override
    boolean isPaymentRequired() {
        return false;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (transactionId != null) {
            Objects.requireNonNull(transactionId.accountId).validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = TransactionGetReceiptQuery.newBuilder()
            .setIncludeChildReceipts(includeChildren)
            .setIncludeDuplicates(includeDuplicates);
        if (transactionId != null) {
            builder.setTransactionID(transactionId.toProtobuf());
        }

        queryBuilder.setTransactionGetReceipt(builder.setHeader(header));
    }

    @Override
    Status mapResponseStatus(Response response) {
        var preCheckCode = response.getTransactionGetReceipt().getHeader().getNodeTransactionPrecheckCode();

        return Status.valueOf(preCheckCode);
    }

    @Override
    TransactionReceipt mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        var receiptResponse = response.getTransactionGetReceipt();
        var duplicates = mapReceiptList(receiptResponse.getDuplicateTransactionReceiptsList());
        var children = mapReceiptList(receiptResponse.getChildTransactionReceiptsList());
        return TransactionReceipt.fromProtobuf(response.getTransactionGetReceipt().getReceipt(), duplicates, children, transactionId);
    }

    /**
     * Create a list of transaction receipts from a protobuf.
     *
     * @param protoReceiptList          the protobuf
     * @return                          the list of transaction receipts
     */
    private static List<TransactionReceipt> mapReceiptList(
        List<com.hedera.hashgraph.sdk.proto.TransactionReceipt> protoReceiptList
    ) {
        List<TransactionReceipt> outList = new ArrayList<>(protoReceiptList.size());
        for (var protoReceipt : protoReceiptList) {
            outList.add(TransactionReceipt.fromProtobuf(protoReceipt));
        }
        return outList;
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getTransactionGetReceipt().getHeader();
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getTransactionGetReceipt().getHeader();
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getGetTransactionReceiptsMethod();
    }

    @Override
    ExecutionState getExecutionState(Status status, Response response) {
        switch (status) {
            case BUSY:
            case UNKNOWN:
            case RECEIPT_NOT_FOUND:
            case RECORD_NOT_FOUND:
            case PLATFORM_NOT_ACTIVE:
                return ExecutionState.RETRY;

            case OK:
                break;

            default:
                return ExecutionState.REQUEST_ERROR;
        }

        var receiptStatus =
            Status.valueOf(response.getTransactionGetReceipt().getReceipt().getStatus());

        switch (receiptStatus) {
            case BUSY:
            case UNKNOWN:
            case OK:
            case RECEIPT_NOT_FOUND:
            case RECORD_NOT_FOUND:
            case PLATFORM_NOT_ACTIVE:
                return ExecutionState.RETRY;

            default:
                return ExecutionState.SUCCESS;
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionRecord.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AccountAmount;
import com.hedera.hashgraph.sdk.proto.NftTransfer;
import com.hedera.hashgraph.sdk.proto.TokenTransferList;
import com.hedera.hashgraph.sdk.proto.TransferList;
import org.bouncycastle.util.encoders.Hex;
import java.time.Instant;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * The complete record for a transaction on Hedera that has reached consensus.
 * <p>
 * This is not-free to request and is available for 1 hour after a transaction reaches consensus.
 * <p>
 * A {@link TransactionReceipt} can be thought of as a light-weight record which is free to ask for if you just
 * need what it contains. A receipt however lasts for only 180 seconds.
 */
public final class TransactionRecord {
    /**
     * The status (reach consensus, or failed, or is unknown) and the ID of
     * any new account/file/instance created.
     */
    public final TransactionReceipt receipt;

    /**
     * The hash of the Transaction that executed (not the hash of any Transaction that failed for
     * having a duplicate TransactionID).
     */
    public final ByteString transactionHash;

    /**
     * The consensus timestamp (or null if didn't reach consensus yet).
     */
    public final Instant consensusTimestamp;

    /**
     * The ID of the transaction this record represents.
     */
    public final TransactionId transactionId;

    /**
     * The memo that was submitted as part of the transaction (max 100 bytes).
     */
    public final String transactionMemo;

    /**
     * The actual transaction fee charged, not the original
     * transactionFee value from TransactionBody.
     */
    public final Hbar transactionFee;

    /**
     * Record of the value returned by the smart contract
     * function or constructor.
     */
    @Nullable
    public final ContractFunctionResult contractFunctionResult;

    /**
     * All hbar transfers as a result of this transaction, such as fees, or
     * transfers performed by the transaction, or by a smart contract it calls,
     * or by the creation of threshold records that it triggers.
     */
    public final List<Transfer> transfers;

    /**
     * All fungible token transfers as a result of this transaction as a map
     */
    public final Map<TokenId, Map<AccountId, Long>> tokenTransfers;

    /**
     * All fungible token transfers as a result of this transaction as a list
     */
    public final List<TokenTransfer> tokenTransferList;

    /**
     * All NFT Token transfers as a result of this transaction
     */
    public final Map<TokenId, List<TokenNftTransfer>> tokenNftTransfers;

    /**
     * Reference to the scheduled transaction ID that this transaction record represents
     */
    @Nullable
    public final ScheduleId scheduleRef;

    /**
     * All custom fees that were assessed during a CryptoTransfer, and must be paid if the
     * transaction status resolved to SUCCESS
     */
    public final List<AssessedCustomFee> assessedCustomFees;

    /**
     * All token associations implicitly created while handling this transaction
     */
    public final List<TokenAssociation> automaticTokenAssociations;

    /**
     * In the record of an internal CryptoCreate transaction triggered by a user
     * transaction with a (previously unused) alias, the new account's alias.
     */
    @Nullable
    public final PublicKey aliasKey;

    /**
     * The records of processing all child transaction spawned by the transaction with the given
     * top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
     */
    public final List<TransactionRecord> children;

    /**
     * The records of processing all consensus transaction with the same id as the distinguished
     * record above, in chronological order.
     */
    public final List<TransactionRecord> duplicates;

    /**
     * In the record of an internal transaction, the consensus timestamp of the user
     * transaction that spawned it.
     */
    @Nullable
    public final Instant parentConsensusTimestamp;

    /**
     * The keccak256 hash of the ethereumData. This field will only be populated for
     * EthereumTransaction.
     */
    public final ByteString ethereumHash;

    /**
     * An approved allowance of hbar transfers for a spender
     */
    @Deprecated
    public final List<HbarAllowance> hbarAllowanceAdjustments;

    /**
     * An approved allowance of token transfers for a spender
     */
    @Deprecated
    public final List<TokenAllowance> tokenAllowanceAdjustments;

    /**
     * An approved allowance of NFT transfers for a spender
     */
    @Deprecated
    public final List<TokenNftAllowance> tokenNftAllowanceAdjustments;

    /**
     * List of accounts with the corresponding staking rewards paid as a result of a transaction.
     */
    public final List<Transfer> paidStakingRewards;

    /**
     * In the record of a UtilPrng transaction with no output range, a pseudorandom 384-bit string.
     */
    @Nullable
    public final ByteString prngBytes;

    /**
     * In the record of a PRNG transaction with an output range, the output of a PRNG whose input was a 384-bit string.
     */
    @Nullable
    public final Integer prngNumber;

    /**
     * The new default EVM address of the account created by this transaction.
     * This field is populated only when the EVM address is not specified in the related transaction body.
     */
    public final ByteString evmAddress;

    /**
     * A list of pending token airdrops.
     * Each pending airdrop represents a single requested transfer from a
     * sending account to a recipient account. These pending transfers are
     * issued unilaterally by the sending account, and MUST be claimed by the
     * recipient account before the transfer MAY complete.
     * A sender MAY cancel a pending airdrop before it is claimed.
     * An airdrop transaction SHALL emit a pending airdrop when the recipient has no
     * available automatic association slots available or when the recipient
     * has set `receiver_sig_required`.
     */
    public final List<PendingAirdropRecord> pendingAirdropRecords;

    TransactionRecord(
        TransactionReceipt transactionReceipt,
        ByteString transactionHash,
        Instant consensusTimestamp,
        TransactionId transactionId,
        String transactionMemo,
        long transactionFee,
        @Nullable ContractFunctionResult contractFunctionResult,
        List<Transfer> transfers,
        Map<TokenId, Map<AccountId, Long>> tokenTransfers,
        List<TokenTransfer> tokenTransferList,
        Map<TokenId, List<TokenNftTransfer>> tokenNftTransfers,
        @Nullable ScheduleId scheduleRef,
        List<AssessedCustomFee> assessedCustomFees,
        List<TokenAssociation> automaticTokenAssociations,
        @Nullable PublicKey aliasKey,
        List<TransactionRecord> children,
        List<TransactionRecord> duplicates,
        @Nullable Instant parentConsensusTimestamp,
        ByteString ethereumHash,
        List<Transfer> paidStakingRewards,
        @Nullable ByteString prngBytes,
        @Nullable Integer prngNumber,
        ByteString evmAddress,
        List<PendingAirdropRecord> pendingAirdropRecords
    ) {
        this.receipt = transactionReceipt;
        this.transactionHash = transactionHash;
        this.consensusTimestamp = consensusTimestamp;
        this.transactionMemo = transactionMemo;
        this.transactionId = transactionId;
        this.transfers = transfers;
        this.contractFunctionResult = contractFunctionResult;
        this.transactionFee = Hbar.fromTinybars(transactionFee);
        this.tokenTransfers = tokenTransfers;
        this.tokenTransferList = tokenTransferList;
        this.tokenNftTransfers = tokenNftTransfers;
        this.scheduleRef = scheduleRef;
        this.assessedCustomFees = assessedCustomFees;
        this.automaticTokenAssociations = automaticTokenAssociations;
        this.aliasKey = aliasKey;
        this.children = children;
        this.duplicates = duplicates;
        this.parentConsensusTimestamp = parentConsensusTimestamp;
        this.ethereumHash = ethereumHash;
        this.pendingAirdropRecords = pendingAirdropRecords;
        this.hbarAllowanceAdjustments = Collections.emptyList();
        this.tokenAllowanceAdjustments = Collections.emptyList();
        this.tokenNftAllowanceAdjustments = Collections.emptyList();
        this.paidStakingRewards = paidStakingRewards;
        this.prngBytes = prngBytes;
        this.prngNumber = prngNumber;
        this.evmAddress = evmAddress;
    }

    /**
     * Create a transaction record from a protobuf.
     *
     * @param transactionRecord the protobuf
     * @param children          the list of children
     * @param duplicates        the list of duplicates
     * @return the new transaction record
     */
    static TransactionRecord fromProtobuf(
        com.hedera.hashgraph.sdk.proto.TransactionRecord transactionRecord,
        List<TransactionRecord> children,
        List<TransactionRecord> duplicates,
        @Nullable TransactionId transactionId
    ) {
        var transfers = new ArrayList<Transfer>(transactionRecord.getTransferList().getAccountAmountsCount());
        for (var accountAmount : transactionRecord.getTransferList().getAccountAmountsList()) {
            transfers.add(Transfer.fromProtobuf(accountAmount));
        }

        var tokenTransfers = new HashMap<TokenId, Map<AccountId, Long>>();
        var tokenNftTransfers = new HashMap<TokenId, List<TokenNftTransfer>>();

        var tokenTransfersList = TokenTransfer.fromProtobuf(transactionRecord.getTokenTransferListsList());
        var nftTransfersList = TokenNftTransfer.fromProtobuf(transactionRecord.getTokenTransferListsList());

        for (var transfer : tokenTransfersList) {
            var current = tokenTransfers.containsKey(transfer.tokenId) ? tokenTransfers.get(transfer.tokenId) : new HashMap<AccountId, Long>();
            current.put(transfer.accountId, transfer.amount);
            tokenTransfers.put(transfer.tokenId, current);
        }

        for (var transfer : nftTransfersList) {
            var current = tokenNftTransfers.containsKey(transfer.tokenId) ? tokenNftTransfers.get(transfer.tokenId) : new ArrayList<TokenNftTransfer>();
            current.add(transfer);
            tokenNftTransfers.put(transfer.tokenId, current);
        }

        var fees = new ArrayList<AssessedCustomFee>(transactionRecord.getAssessedCustomFeesCount());
        for (var fee : transactionRecord.getAssessedCustomFeesList()) {
            fees.add(AssessedCustomFee.fromProtobuf(fee));
        }

        // HACK: This is a bit bad, any takers to clean this up
        var contractFunctionResult = transactionRecord.hasContractCallResult() ?
            new ContractFunctionResult(transactionRecord.getContractCallResult()) :
            transactionRecord.hasContractCreateResult() ?
                new ContractFunctionResult(transactionRecord.getContractCreateResult()) :
                null;

        var automaticTokenAssociations = new ArrayList<TokenAssociation>(transactionRecord.getAutomaticTokenAssociationsCount());
        for (var tokenAssociation : transactionRecord.getAutomaticTokenAssociationsList()) {
            automaticTokenAssociations.add(TokenAssociation.fromProtobuf(tokenAssociation));
        }

        var aliasKey = PublicKey.fromAliasBytes(transactionRecord.getAlias());

        var paidStakingRewards = new ArrayList<Transfer>(transactionRecord.getPaidStakingRewardsCount());
        for (var reward : transactionRecord.getPaidStakingRewardsList()) {
            paidStakingRewards.add(Transfer.fromProtobuf(reward));
        }

        List<PendingAirdropRecord> pendingAirdropRecords = transactionRecord.getNewPendingAirdropsList()
            .stream().map(PendingAirdropRecord::fromProtobuf)
            .collect(Collectors.toList());

        return new TransactionRecord(
            TransactionReceipt.fromProtobuf(transactionRecord.getReceipt(), transactionId),
            transactionRecord.getTransactionHash(),
            InstantConverter.fromProtobuf(transactionRecord.getConsensusTimestamp()),
            TransactionId.fromProtobuf(transactionRecord.getTransactionID()),
            transactionRecord.getMemo(),
            transactionRecord.getTransactionFee(),
            contractFunctionResult,
            transfers,
            tokenTransfers,
            tokenTransfersList,
            tokenNftTransfers,
            transactionRecord.hasScheduleRef() ? ScheduleId.fromProtobuf(transactionRecord.getScheduleRef()) : null,
            fees,
            automaticTokenAssociations,
            aliasKey,
            children,
            duplicates,
            transactionRecord.hasParentConsensusTimestamp() ?
                InstantConverter.fromProtobuf(transactionRecord.getParentConsensusTimestamp()) : null,
            transactionRecord.getEthereumHash(),
            paidStakingRewards,
            transactionRecord.hasPrngBytes() ? transactionRecord.getPrngBytes() : null,
            transactionRecord.hasPrngNumber() ? transactionRecord.getPrngNumber() : null,
            transactionRecord.getEvmAddress(),
            pendingAirdropRecords
        );
    }

    /**
     * Create a transaction record from a protobuf.
     *
     * @param transactionRecord the protobuf
     * @return the new transaction record
     */
    static TransactionRecord fromProtobuf(com.hedera.hashgraph.sdk.proto.TransactionRecord transactionRecord) {
        return fromProtobuf(transactionRecord, new ArrayList<>(), new ArrayList<>(), null);
    }

    /**
     * Create a transaction record from a byte array.
     *
     * @param bytes the byte array
     * @return the new transaction record
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    public static TransactionRecord fromBytes(byte[] bytes) throws InvalidProtocolBufferException {
        return fromProtobuf(com.hedera.hashgraph.sdk.proto.TransactionRecord.parseFrom(bytes).toBuilder().build());
    }

    /**
     * Validate the transaction status in the receipt.
     *
     * @param shouldValidate Whether to perform transaction status validation
     * @return {@code this}
     * @throws ReceiptStatusException when shouldValidate is true and the transaction status is not SUCCESS
     */
    public TransactionRecord validateReceiptStatus(boolean shouldValidate) throws ReceiptStatusException {
        receipt.validateStatus(shouldValidate);
        return this;
    }

    /**
     * Create the protobuf.
     *
     * @return the protobuf representation
     */
    com.hedera.hashgraph.sdk.proto.TransactionRecord toProtobuf() {
        var transferList = TransferList.newBuilder();
        for (Transfer transfer : transfers) {
            transferList.addAccountAmounts(transfer.toProtobuf());
        }

        var transactionRecord = com.hedera.hashgraph.sdk.proto.TransactionRecord.newBuilder()
            .setReceipt(receipt.toProtobuf())
            .setTransactionHash(transactionHash)
            .setConsensusTimestamp(InstantConverter.toProtobuf(consensusTimestamp))
            .setTransactionID(transactionId.toProtobuf())
            .setMemo(transactionMemo)
            .setTransactionFee(transactionFee.toTinybars())
            .setTransferList(transferList)
            .setEthereumHash(ethereumHash)
            .setEvmAddress(evmAddress);

        for (var tokenEntry : tokenTransfers.entrySet()) {
            var tokenTransfersList = TokenTransferList.newBuilder()
                .setToken(tokenEntry.getKey().toProtobuf());
            for (var aaEntry : tokenEntry.getValue().entrySet()) {
                tokenTransfersList.addTransfers(AccountAmount.newBuilder()
                    .setAccountID(aaEntry.getKey().toProtobuf())
                    .setAmount(aaEntry.getValue()).build()
                );
            }

            transactionRecord.addTokenTransferLists(tokenTransfersList);
        }

        for (var nftEntry : tokenNftTransfers.entrySet()) {
            var nftTransferList = TokenTransferList.newBuilder()
                .setToken(nftEntry.getKey().toProtobuf());
            for (var aaEntry : nftEntry.getValue()) {
                nftTransferList.addNftTransfers(
                    NftTransfer.newBuilder()
                        .setSenderAccountID(aaEntry.sender.toProtobuf())
                        .setReceiverAccountID(aaEntry.receiver.toProtobuf())
                        .setSerialNumber(aaEntry.serial)
                        .setIsApproval(aaEntry.isApproved)
                        .build()
                );
            }

            transactionRecord.addTokenTransferLists(nftTransferList);
        }

        if (contractFunctionResult != null) {
            transactionRecord.setContractCallResult(contractFunctionResult.toProtobuf());
        }

        if (scheduleRef != null) {
            transactionRecord.setScheduleRef(scheduleRef.toProtobuf());
        }

        for (var fee : assessedCustomFees) {
            transactionRecord.addAssessedCustomFees(fee.toProtobuf());
        }

        for (var tokenAssociation : automaticTokenAssociations) {
            transactionRecord.addAutomaticTokenAssociations(tokenAssociation.toProtobuf());
        }

        if (aliasKey != null) {
            transactionRecord.setAlias(aliasKey.toProtobufKey().toByteString());
        }

        if (parentConsensusTimestamp != null) {
            transactionRecord.setParentConsensusTimestamp(InstantConverter.toProtobuf(parentConsensusTimestamp));
        }

        for (Transfer reward : paidStakingRewards) {
            transactionRecord.addPaidStakingRewards(reward.toProtobuf());
        }

        if (prngBytes != null) {
            transactionRecord.setPrngBytes(prngBytes);
        }

        if (prngNumber != null) {
            transactionRecord.setPrngNumber(prngNumber);
        }

        if (pendingAirdropRecords != null) {
            for (PendingAirdropRecord pendingAirdropRecord : pendingAirdropRecords) {
                transactionRecord.addNewPendingAirdrops(pendingAirdropRecords.indexOf(pendingAirdropRecord), pendingAirdropRecord.toProtobuf());
            }
        }

        return transactionRecord.build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("receipt", receipt)
            .add("transactionHash", Hex.toHexString(transactionHash.toByteArray()))
            .add("consensusTimestamp", consensusTimestamp)
            .add("transactionId", transactionId)
            .add("transactionMemo", transactionMemo)
            .add("transactionFee", transactionFee)
            .add("contractFunctionResult", contractFunctionResult)
            .add("transfers", transfers)
            .add("tokenTransfers", tokenTransfers)
            .add("tokenNftTransfers", tokenNftTransfers)
            .add("scheduleRef", scheduleRef)
            .add("assessedCustomFees", assessedCustomFees)
            .add("automaticTokenAssociations", automaticTokenAssociations)
            .add("aliasKey", aliasKey)
            .add("children", children)
            .add("duplicates", duplicates)
            .add("parentConsensusTimestamp", parentConsensusTimestamp)
            .add("ethereumHash", Hex.toHexString(ethereumHash.toByteArray()))
            .add("paidStakingRewards", paidStakingRewards)
            .add("prngBytes", prngBytes != null ? Hex.toHexString(prngBytes.toByteArray()) : null)
            .add("prngNumber", prngNumber)
            .add("evmAddress", Hex.toHexString(evmAddress.toByteArray()))
            .add("pendingAirdropRecords", pendingAirdropRecords.toString())
            .toString();
    }

    /**
     * Create the byte array.
     *
     * @return the byte array representation
     */
    public byte[] toBytes() {
        return toProtobuf().toByteArray();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionRecordQuery.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.TransactionGetRecordQuery;
import io.grpc.MethodDescriptor;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Get the record for a transaction.
 * <p>
 * If the transaction requested a record, then the record lasts for one hour, and a state proof is available for it.
 * If the transaction created an account, file, or smart contract instance, then the record will contain the ID for
 * what it created. If the transaction called a smart contract function, then the record contains the result of
 * that call. If the transaction was a cryptocurrency transfer, then the record includes the TransferList
 * which gives the details of that transfer. If the transaction didn't return anything that should be
 * in the record, then the results field will be set to nothing.
 */
public final class TransactionRecordQuery extends Query<TransactionRecord, TransactionRecordQuery> {
    @Nullable
    private TransactionId transactionId = null;
    private boolean includeChildren = false;
    private boolean includeDuplicates = false;

    /**
     * Constructor.
     */
    public TransactionRecordQuery() {
    }

    /**
     * Extract the transaction id.
     *
     * @return                          the transaction id
     */
    @Nullable
    @Override
    public TransactionId getTransactionIdInternal() {
        return transactionId;
    }

    /**
     * Set the ID of the transaction for which the record is requested.
     *
     * @param transactionId The TransactionId to be set
     * @return {@code this}
     */
    public TransactionRecordQuery setTransactionId(TransactionId transactionId) {
        Objects.requireNonNull(transactionId);
        this.transactionId = transactionId;
        return this;
    }

    /**
     * Should duplicates be included?
     *
     * @return                          should duplicates be included
     */
    public boolean getIncludeDuplicates() {
        return includeDuplicates;
    }

    /**
     * Whether records of processing duplicate transactions should be returned along with the record
     * of processing the first consensus transaction with the given id whose status was neither
     * INVALID_NODE_ACCOUNT nor INVALID_PAYER_SIGNATURE or, if no such
     * record exists, the record of processing the first transaction to reach consensus with the
     * given transaction id.
     *
     * @param value The value that includeDuplicates should be set to; true to include duplicates, false to exclude
     * @return {@code this}
     */
    public TransactionRecordQuery setIncludeDuplicates(boolean value) {
        includeDuplicates = value;
        return this;
    }

    /**
     * Extract the children be included.
     *
     * @return                          should children be included
     */
    public boolean getIncludeChildren() {
        return includeChildren;
    }

    /**
     * Whether the response should include the records of any child transactions spawned by the
     * top-level transaction with the given transactionID.
     *
     * @param value The value that includeChildren should be set to; true to include children, false to exclude
     * @return {@code this}
     */
    public TransactionRecordQuery setIncludeChildren(boolean value) {
        includeChildren = value;
        return this;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        if (transactionId != null) {
            Objects.requireNonNull(transactionId.accountId).validateChecksum(client);
        }
    }

    @Override
    void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        var builder = TransactionGetRecordQuery.newBuilder()
            .setIncludeChildRecords(includeChildren)
            .setIncludeDuplicates(includeDuplicates);
        if (transactionId != null) {
            builder.setTransactionID(transactionId.toProtobuf());
        }

        queryBuilder.setTransactionGetRecord(builder.setHeader(header));
    }

    @Override
    ResponseHeader mapResponseHeader(Response response) {
        return response.getTransactionGetRecord().getHeader();
    }

    @Override
    QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
        return request.getTransactionGetRecord().getHeader();
    }

    @Override
    TransactionRecord mapResponse(Response response, AccountId nodeId, com.hedera.hashgraph.sdk.proto.Query request) {
        var recordResponse = response.getTransactionGetRecord();
        List<TransactionRecord> children = mapRecordList(recordResponse.getChildTransactionRecordsList());
        List<TransactionRecord> duplicates = mapRecordList(recordResponse.getDuplicateTransactionRecordsList());
        return TransactionRecord.fromProtobuf(recordResponse.getTransactionRecord(), children, duplicates, transactionId);
    }

    private List<TransactionRecord> mapRecordList(
        List<com.hedera.hashgraph.sdk.proto.TransactionRecord> protoRecordList
    ) {
        List<TransactionRecord> outList = new ArrayList<>(protoRecordList.size());
        for (var protoRecord : protoRecordList) {
            outList.add(TransactionRecord.fromProtobuf(protoRecord));
        }
        return outList;
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
        return CryptoServiceGrpc.getGetTxRecordByTxIDMethod();
    }

    @Override
    ExecutionState getExecutionState(Status status, Response response) {
        var retry = super.getExecutionState(status, response);
        if (retry != ExecutionState.SUCCESS) {
            return retry;
        }

        switch (status) {
            case BUSY:
            case UNKNOWN:
            case RECEIPT_NOT_FOUND:
            case RECORD_NOT_FOUND:
                return ExecutionState.RETRY;
            case OK:
                // When fetching payment an `OK` in the query header means the cost is in the response
                if (paymentTransactions == null || paymentTransactions.isEmpty()) {
                    return ExecutionState.SUCCESS;
                } else {
                    break;
                }
            default:
                return ExecutionState.REQUEST_ERROR;
        }

        var receiptStatus =
            Status.valueOf(response.getTransactionGetRecord().getTransactionRecord().getReceipt().getStatus());

        switch (receiptStatus) {
            case BUSY:
            case UNKNOWN:
            case OK:
            case RECEIPT_NOT_FOUND:
            case RECORD_NOT_FOUND:
            case PLATFORM_NOT_ACTIVE:
                return ExecutionState.RETRY;

            default:
                return ExecutionState.SUCCESS;
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransactionResponse.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import java.time.Duration;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;
import org.bouncycastle.util.encoders.Hex;

/**
 * When the client sends the node a transaction of any kind, the node
 * replies with this, which simply says that the transaction passed
 * the pre-check (so the node will submit it to the network) or it failed
 * (so it won't). To learn the consensus result, the client should later
 * obtain a receipt (free), or can buy a more detailed record (not free).
 * <br>
 * See <a href="https://docs.hedera.com/guides/docs/hedera-api/miscellaneous/transactionresponse">Hedera Documentation</a>
 */
public final class TransactionResponse {

    /**
     * The node ID
     */
    public final AccountId nodeId;

    /**
     * The transaction hash
     */
    public final byte[] transactionHash;

    /**
     * The transaction ID
     */
    public final TransactionId transactionId;

    /**
     * The scheduled transaction ID
     */
    @Nullable
    @Deprecated
    public final TransactionId scheduledTransactionId;

    private boolean validateStatus = true;

    /**
     * Constructor.
     *
     * @param nodeId                    the node id
     * @param transactionId             the transaction id
     * @param transactionHash           the transaction hash
     * @param scheduledTransactionId    the scheduled transaction id
     */
    TransactionResponse(
        AccountId nodeId,
        TransactionId transactionId,
        byte[] transactionHash,
        @Nullable TransactionId scheduledTransactionId
    ) {
        this.nodeId = nodeId;
        this.transactionId = transactionId;
        this.transactionHash = transactionHash;
        this.scheduledTransactionId = scheduledTransactionId;
    }

    /**
     *
     * @return whether getReceipt() or getRecord() will throw an exception if the receipt status is not SUCCESS
     */
    public boolean getValidateStatus() {
        return validateStatus;
    }

    /**
     *
     * @param validateStatus whether getReceipt() or getRecord() will throw an exception if the receipt status is not SUCCESS
     * @return {@code this}
     */
    public TransactionResponse setValidateStatus(boolean validateStatus) {
        this.validateStatus = validateStatus;
        return this;
    }

    /**
     * Fetch the receipt of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @return                          the transaction receipt
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionReceipt getReceipt(Client client) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        return getReceipt(client, client.getRequestTimeout());
    }

    /**
     * Fetch the receipt of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the transaction receipt
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionReceipt getReceipt(Client client, Duration timeout) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        var receipt = getReceiptQuery()
            .execute(client, timeout)
            .validateStatus(validateStatus);

        return receipt;
    }

    /**
     * Create receipt query from the {@link #transactionId} and {@link #transactionHash}
     *
     * @return {@link com.hedera.hashgraph.sdk.TransactionReceiptQuery}
     */
    public TransactionReceiptQuery getReceiptQuery() {
        return new TransactionReceiptQuery()
            .setTransactionId(transactionId)
            .setNodeAccountIds(Collections.singletonList(nodeId));
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @return                          future result of the transaction receipt
     */
    public CompletableFuture<TransactionReceipt> getReceiptAsync(Client client) {
        return getReceiptAsync(client, client.getRequestTimeout());
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the transaction receipt
     */
    public CompletableFuture<TransactionReceipt> getReceiptAsync(Client client, Duration timeout) {
        return getReceiptQuery()
            .executeAsync(client, timeout)
            .thenCompose(receipt -> {
                try {
                    return CompletableFuture.completedFuture(receipt.validateStatus(validateStatus));
                } catch (ReceiptStatusException e) {
                    return CompletableFuture.failedFuture(e);
                }
            });
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getReceiptAsync(Client client, BiConsumer<TransactionReceipt, Throwable> callback) {
        ConsumerHelper.biConsumer(getReceiptAsync(client), callback);
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getReceiptAsync(Client client, Duration timeout, BiConsumer<TransactionReceipt, Throwable> callback) {
        ConsumerHelper.biConsumer(getReceiptAsync(client, timeout), callback);
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getReceiptAsync(Client client, Consumer<TransactionReceipt> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getReceiptAsync(client), onSuccess, onFailure);
    }

    /**
     * Fetch the receipt of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getReceiptAsync(Client client, Duration timeout, Consumer<TransactionReceipt> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getReceiptAsync(client, timeout), onSuccess, onFailure);
    }

    /**
     * Fetch the record of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @return                          the transaction record
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionRecord getRecord(Client client) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        return getRecord(client, client.getRequestTimeout());
    }

    /**
     * Fetch the record of the transaction.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          the transaction record
     * @throws TimeoutException             when the transaction times out
     * @throws PrecheckStatusException      when the precheck fails
     * @throws ReceiptStatusException       when there is an issue with the receipt
     */
    public TransactionRecord getRecord(Client client, Duration timeout) throws TimeoutException, PrecheckStatusException, ReceiptStatusException {
        getReceipt(client, timeout);
        return getRecordQuery().execute(client, timeout);
    }

    /**
     * Create record query from the {@link #transactionId} and {@link #transactionHash}
     *
     * @return {@link com.hedera.hashgraph.sdk.TransactionRecordQuery}
     */
    public TransactionRecordQuery getRecordQuery() {
        return new TransactionRecordQuery()
            .setTransactionId(transactionId)
            .setNodeAccountIds(Collections.singletonList(nodeId));
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @return                          future result of the transaction record
     */
    public CompletableFuture<TransactionRecord> getRecordAsync(Client client) {
        return getRecordAsync(client, client.getRequestTimeout());
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @return                          future result of the transaction record
     */
    public CompletableFuture<TransactionRecord> getRecordAsync(Client client, Duration timeout) {
        return getReceiptAsync(client, timeout).thenCompose((receipt) -> getRecordQuery().executeAsync(client, timeout));
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getRecordAsync(Client client, BiConsumer<TransactionRecord, Throwable> callback) {
        ConsumerHelper.biConsumer(getRecordAsync(client), callback);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param callback a BiConsumer which handles the result or error.
     */
    public void getRecordAsync(Client client, Duration timeout, BiConsumer<TransactionRecord, Throwable> callback) {
        ConsumerHelper.biConsumer(getRecordAsync(client, timeout), callback);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getRecordAsync(Client client, Consumer<TransactionRecord> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getRecordAsync(client), onSuccess, onFailure);
    }

    /**
     * Fetch the record of the transaction asynchronously.
     *
     * @param client                    The client with which this will be executed.
     * @param timeout The timeout after which the execution attempt will be cancelled.
     * @param onSuccess a Consumer which consumes the result on success.
     * @param onFailure a Consumer which consumes the error on failure.
     */
    public void getRecordAsync(Client client, Duration timeout, Consumer<TransactionRecord> onSuccess, Consumer<Throwable> onFailure) {
        ConsumerHelper.twoConsumers(getRecordAsync(client, timeout), onSuccess, onFailure);
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("nodeId", nodeId)
            .add("transactionHash", Hex.toHexString(transactionHash))
            .add("transactionId", transactionId)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/Transfer.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.hedera.hashgraph.sdk.proto.AccountAmount;

/**
 * A transfer of Hbar that occurred within a transaction.
 * <p>
 * Returned with a {@link TransactionRecord}.
 */
public final class Transfer {
    /**
     * The Account ID that sends or receives crypto-currency.
     */
    public final AccountId accountId;

    /**
     * The amount that the account sends (negative) or receives (positive).
     */
    public final Hbar amount;

    Transfer(AccountId accountId, Hbar amount) {
        this.accountId = accountId;
        this.amount = amount;
    }

    /**
     * Create a transfer from a protobuf.
     *
     * @param accountAmount             the protobuf
     * @return                          the new transfer
     */
    static Transfer fromProtobuf(AccountAmount accountAmount) {
        return new Transfer(AccountId.fromProtobuf(accountAmount.getAccountID()), Hbar.fromTinybars(accountAmount.getAmount()));
    }

    /**
     * Create the protobuf.
     *
     * @return                          the protobuf representation
     */
    AccountAmount toProtobuf() {
        return AccountAmount.newBuilder()
            .setAccountID(accountId.toProtobuf())
            .setAmount(amount.toTinybars())
            .build();
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
            .add("accountId", accountId)
            .add("amount", amount)
            .toString();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/TransferTransaction.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.MoreObjects;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AccountAmount;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.CryptoTransferTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import com.hedera.hashgraph.sdk.proto.TransferList;
import io.grpc.MethodDescriptor;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * A transaction that transfers hbars and tokens between Hedera accounts. You can enter multiple transfers in a single
 * transaction. The net value of hbars between the sending accounts and receiving accounts must equal zero.
 * <p>
 * See <a href="https://docs.hedera.com/guides/docs/sdks/cryptocurrency/transfer-cryptocurrency">Hedera
 * Documentation</a>
 */
public class TransferTransaction extends AbstractTokenTransferTransaction<TransferTransaction> {
    private final ArrayList<HbarTransfer> hbarTransfers = new ArrayList<>();

    private static class HbarTransfer {
        final AccountId accountId;
        Hbar amount;
        boolean isApproved;

        HbarTransfer(AccountId accountId, Hbar amount, boolean isApproved) {
            this.accountId = accountId;
            this.amount = amount;
            this.isApproved = isApproved;
        }

        AccountAmount toProtobuf() {
            return AccountAmount.newBuilder()
                .setAccountID(accountId.toProtobuf())
                .setAmount(amount.toTinybars())
                .setIsApproval(isApproved)
                .build();
        }

        @Override
        public String toString() {
            return MoreObjects.toStringHelper(this)
                .add("accountId", accountId)
                .add("amount", amount)
                .add("isApproved", isApproved)
                .toString();
        }
    }

    /**
     * Constructor.
     */
    public TransferTransaction() {
        defaultMaxTransactionFee = new Hbar(1);
    }

    /**
     * Constructor.
     *
     * @param txs Compound list of transaction id's list of (AccountId, Transaction) records
     * @throws InvalidProtocolBufferException when there is an issue with the protobuf
     */
    TransferTransaction(
        LinkedHashMap<TransactionId, LinkedHashMap<AccountId, com.hedera.hashgraph.sdk.proto.Transaction>> txs)
        throws InvalidProtocolBufferException {
        super(txs);
        initFromTransactionBody();
    }

    /**
     * Constructor.
     *
     * @param txBody protobuf TransactionBody
     */
    TransferTransaction(com.hedera.hashgraph.sdk.proto.TransactionBody txBody) {
        super(txBody);
        initFromTransactionBody();
    }

    /**
     * Extract the of hbar transfers.
     *
     * @return list of hbar transfers
     */
    public Map<AccountId, Hbar> getHbarTransfers() {
        Map<AccountId, Hbar> transfers = new HashMap<>();

        for (var transfer : hbarTransfers) {
            transfers.put(transfer.accountId, transfer.amount);
        }

        return transfers;
    }

    private TransferTransaction doAddHbarTransfer(AccountId accountId, Hbar value, boolean isApproved) {
        requireNotFrozen();

        for (var transfer : hbarTransfers) {
            if (transfer.accountId.equals(accountId) && transfer.isApproved == isApproved) {
                transfer.amount = Hbar.fromTinybars(transfer.amount.toTinybars() + value.toTinybars());
                return this;
            }
        }

        hbarTransfers.add(new HbarTransfer(accountId, value, isApproved));
        return this;
    }

    /**
     * Add a non approved hbar transfer to an EVM address.
     *
     * @param evmAddress the EVM address
     * @param value      the value
     * @return the updated transaction
     */
    public TransferTransaction addHbarTransfer(EvmAddress evmAddress, Hbar value) {
        AccountId accountId = AccountId.fromEvmAddress(evmAddress);
        return doAddHbarTransfer(accountId, value, false);
    }

    /**
     * Add a non approved hbar transfer.
     *
     * @param accountId the account id
     * @param value     the value
     * @return the updated transaction
     */
    public TransferTransaction addHbarTransfer(AccountId accountId, Hbar value) {
        return doAddHbarTransfer(accountId, value, false);
    }

    /**
     * Add an approved hbar transfer.
     *
     * @param accountId the account id
     * @param value     the value
     * @return the updated transaction
     */
    public TransferTransaction addApprovedHbarTransfer(AccountId accountId, Hbar value) {
        return doAddHbarTransfer(accountId, value, true);
    }

    /**
     * @param accountId  the account id
     * @param isApproved whether the transfer is approved
     * @return {@code this}
     * @deprecated - Use {@link #addApprovedHbarTransfer(AccountId, Hbar)} instead
     */
    @Deprecated
    public TransferTransaction setHbarTransferApproval(AccountId accountId, boolean isApproved) {
        requireNotFrozen();

        for (var transfer : hbarTransfers) {
            if (transfer.accountId.equals(accountId)) {
                transfer.isApproved = isApproved;
                return this;
            }
        }

        return this;
    }

    /**
     * Build the transaction body.
     *
     * @return {@link com.hedera.hashgraph.sdk.proto.CryptoTransferTransactionBody}
     */
    CryptoTransferTransactionBody.Builder build() {
        var transfers = sortTransfersAndBuild();

        var builder = CryptoTransferTransactionBody.newBuilder();

        this.hbarTransfers.sort(Comparator.comparing((HbarTransfer a) -> a.accountId).thenComparing(a -> a.isApproved));
        var hbarTransfersList = TransferList.newBuilder();
        for (var transfer : hbarTransfers) {
            hbarTransfersList.addAccountAmounts(transfer.toProtobuf());
        }
        builder.setTransfers(hbarTransfersList);

        for (var transfer : transfers) {
            builder.addTokenTransfers(transfer.toProtobuf());
        }

        return builder;
    }

    @Override
    void validateChecksums(Client client) throws BadEntityIdException {
        super.validateChecksums(client);
        for (var transfer : hbarTransfers) {
            transfer.accountId.validateChecksum(client);
        }
    }

    @Override
    MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, TransactionResponse> getMethodDescriptor() {
        return CryptoServiceGrpc.getCryptoTransferMethod();
    }

    @Override
    void onFreeze(TransactionBody.Builder bodyBuilder) {
        bodyBuilder.setCryptoTransfer(build());
    }

    @Override
    void onScheduled(SchedulableTransactionBody.Builder scheduled) {
        scheduled.setCryptoTransfer(build());
    }

    /**
     * Initialize from the transaction body.
     */
    void initFromTransactionBody() {
        var body = sourceTransactionBody.getCryptoTransfer();

        for (var transfer : body.getTransfers().getAccountAmountsList()) {
            hbarTransfers.add(new HbarTransfer(
                AccountId.fromProtobuf(transfer.getAccountID()),
                Hbar.fromTinybars(transfer.getAmount()),
                transfer.getIsApproval()
            ));
        }

        for (var tokenTransferList : body.getTokenTransfersList()) {
            var token = TokenId.fromProtobuf(tokenTransferList.getToken());

            for (var transfer : tokenTransferList.getTransfersList()) {
                tokenTransfers.add(new TokenTransfer(
                    token,
                    AccountId.fromProtobuf(transfer.getAccountID()),
                    transfer.getAmount(),
                    tokenTransferList.hasExpectedDecimals() ? tokenTransferList.getExpectedDecimals().getValue() : null,
                    transfer.getIsApproval()
                ));
            }

            for (var transfer : tokenTransferList.getNftTransfersList()) {
                nftTransfers.add(new TokenNftTransfer(
                    token,
                    AccountId.fromProtobuf(transfer.getSenderAccountID()),
                    AccountId.fromProtobuf(transfer.getReceiverAccountID()),
                    transfer.getSerialNumber(),
                    transfer.getIsApproval()
                ));
            }
        }
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/logger/LogLevel.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.logger;

public enum LogLevel {
    TRACE(0),
    DEBUG(1),
    INFO(2),
    WARN(3),
    ERROR(4),
    SILENT(5);

    private final int levelInt;

    LogLevel(int i) {
        this.levelInt = i;
    }

    public int toInt() {
        return levelInt;
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/logger/Logger.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.logger;

import org.slf4j.LoggerFactory;

/**
 *
 */
public class Logger {
    private org.slf4j.Logger internalLogger;
    private LogLevel currentLevel;
    private LogLevel previousLevel;

    /**
     * Constructor
     *
     * @param level the current log level
     */
    public Logger(LogLevel level) {
        internalLogger = LoggerFactory.getLogger(getClass());
        this.currentLevel = level;
        this.previousLevel = level;
    }

    /**
     * Set logger
     *
     * @param logger the new logger
     * @return {@code this}
     */
    public Logger setLogger(org.slf4j.Logger logger) {
        this.internalLogger = logger;
        return this;
    }

    public LogLevel getLevel() {
        return currentLevel;
    }

    /**
     * Set log level
     *
     * @param level the new level
     * @return {@code this}
     */
    public Logger setLevel(LogLevel level) {
        this.previousLevel = this.currentLevel;
        this.currentLevel = level;
        return this;
    }

    /**
     * Set silent mode on/off. If set to true, the logger will not display any log messages. This can also be achieved
     * by calling .setLevel(LogLevel.Silent)`
     *
     * @param silent should the logger be silent
     * @return {@code this}
     */
    public Logger setSilent(boolean silent) {
        if (silent) {
            this.currentLevel = LogLevel.SILENT;
        } else {
            this.currentLevel = this.previousLevel;
        }
        return this;
    }

    /**
     * Log trace
     *
     * @param message   the message to be logged
     * @param arguments the log arguments
     */
    public void trace(String message, Object... arguments) {
        if (isEnabledForLevel(LogLevel.TRACE)) {
            this.internalLogger.trace(message, arguments);
        }
    }

    /**
     * Log debug
     *
     * @param message   the message to be logged
     * @param arguments the log arguments
     */
    public void debug(String message, Object... arguments) {
        if (isEnabledForLevel(LogLevel.DEBUG)) {
            this.internalLogger.debug(message, arguments);
        }
    }

    /**
     * Log info
     *
     * @param message   the message to be logged
     * @param arguments the log arguments
     */
    public void info(String message, Object... arguments) {
        if (isEnabledForLevel(LogLevel.INFO)) {
            this.internalLogger.info(message, arguments);
        }
    }

    /**
     * Log warn
     *
     * @param message   the message to be logged
     * @param arguments the log arguments
     */
    public void warn(String message, Object... arguments) {
        if (isEnabledForLevel(LogLevel.WARN)) {
            this.internalLogger.warn(message, arguments);
        }
    }

    /**
     * Log error
     *
     * @param message   the message to be logged
     * @param arguments the log arguments
     */
    public void error(String message, Object... arguments) {
        if (isEnabledForLevel(LogLevel.ERROR)) {
            this.internalLogger.error(message, arguments);
        }
    }

    /**
     * Returns whether this Logger is enabled for a given {@link LogLevel}.
     *
     * @param level the log level
     * @return true if enabled, false otherwise.
     */
    public boolean isEnabledForLevel(LogLevel level) {
        return level.toInt() >= currentLevel.toInt();
    }
}
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/package-info.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * See <a href="https://docs.hedera.com/guides/docs/sdks">Hedera Documentation</a>
 */
@ParametersAreNonnullByDefault
package com.hedera.hashgraph.sdk;

import javax.annotation.ParametersAreNonnullByDefault;
// Filename: sdk/src/main/java/com/hedera/hashgraph/sdk/utils/Bip32Utils.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.utils;

/**
 * Utility class for BIP32 functionalities
 */
public class Bip32Utils {

    /**
     * Indicates if the index is hardened
     */
    public static final int HARDENED_BIT = 0x80000000;

    private Bip32Utils() {
        throw new IllegalStateException("Utility class");
    }

    /**
     * Harden the index
     *
     * @param index         the derivation index
     * @return              the hardened index
     */
    public static int toHardenedIndex(int index) {
        return index | HARDENED_BIT;
    }

    /**
     * Check if the index is hardened
     *
     * @param index         the derivation index
     * @return              true if the index is hardened
     */
    public static boolean isHardenedIndex(int index) {
        return (index & HARDENED_BIT) != 0;
    }
}
// Filename: sdk/src/main/java/module-info.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

module com.hedera.hashgraph.sdk {
    requires transitive com.google.protobuf;

    requires com.google.common;
    requires com.google.gson;
    requires headlong;
    requires io.grpc.inprocess;
    requires io.grpc.protobuf.lite;
    requires io.grpc.stub;
    requires io.grpc;
    requires java.net.http;
    requires org.bouncycastle.pkix;
    requires org.bouncycastle.provider;
    requires org.slf4j;

    requires static com.github.spotbugs.annotations;
    requires static com.google.errorprone.annotations;
    requires static java.annotation;

    exports com.hedera.hashgraph.sdk;
    exports com.hedera.hashgraph.sdk.logger;
    exports com.hedera.hashgraph.sdk.proto;

    opens com.hedera.hashgraph.sdk;
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountAllowanceApproveTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoApproveAllowanceTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class AccountAllowanceApproveTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final TokenId testTokenId = TokenId.fromString("1.2.3");
    private static final AccountId testOwnerAccountId = AccountId.fromString("4.5.7");
    private static final AccountId testSpenderAccountId = AccountId.fromString("8.9.0");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    AccountAllowanceApproveTransaction spawnTestTransaction() {
        var ownerId = AccountId.fromString("5.6.7");
        return new AccountAllowanceApproveTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .addHbarAllowance(AccountId.fromString("1.1.1"), new Hbar(3))
            .addTokenAllowance(TokenId.fromString("2.2.2"), AccountId.fromString("3.3.3"), 6)
            .addTokenNftAllowance(TokenId.fromString("4.4.4").nft(123), AccountId.fromString("5.5.5"))
            .addTokenNftAllowance(TokenId.fromString("4.4.4").nft(456), AccountId.fromString("5.5.5"))
            .addTokenNftAllowance(TokenId.fromString("8.8.8").nft(456), AccountId.fromString("5.5.5"))
            .addTokenNftAllowance(TokenId.fromString("4.4.4").nft(789), AccountId.fromString("9.9.9"))
            .addAllTokenNftAllowance(TokenId.fromString("6.6.6"), AccountId.fromString("7.7.7"))
            .approveHbarAllowance(ownerId, AccountId.fromString("1.1.1"), new Hbar(3))
            .approveTokenAllowance(TokenId.fromString("2.2.2"), ownerId, AccountId.fromString("3.3.3"), 6)
            .approveTokenNftAllowance(TokenId.fromString("4.4.4").nft(123), ownerId, AccountId.fromString("5.5.5"))
            .approveTokenNftAllowance(TokenId.fromString("4.4.4").nft(456), ownerId, AccountId.fromString("5.5.5"))
            .approveTokenNftAllowance(TokenId.fromString("8.8.8").nft(456), ownerId, AccountId.fromString("5.5.5"))
            .approveTokenNftAllowance(TokenId.fromString("4.4.4").nft(789), ownerId, AccountId.fromString("9.9.9"))
            .approveTokenNftAllowanceAllSerials(TokenId.fromString("6.6.6"), ownerId, AccountId.fromString("7.7.7"))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = AccountAllowanceApproveTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void propertiesTest() {
        var tx = spawnTestTransaction();

        assertThat(tx.getHbarAllowances()).isNotEmpty();
        assertThat(tx.getHbarApprovals()).isNotEmpty();
        assertThat(tx.getTokenAllowances()).isNotEmpty();
        assertThat(tx.getTokenApprovals()).isNotEmpty();
        assertThat(tx.getTokenNftAllowances()).isNotEmpty();
        assertThat(tx.getTokenNftApprovals()).isNotEmpty();
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setCryptoApproveAllowance(CryptoApproveAllowanceTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(AccountAllowanceApproveTransaction.class);
    }

    @Test
    void deleteNftAllowanceAllSerials() {
        var accountAllowanceApproveTransaction = new AccountAllowanceApproveTransaction()
            .deleteTokenNftAllowanceAllSerials(testTokenId, testOwnerAccountId, testSpenderAccountId);

        assertThat(accountAllowanceApproveTransaction.getTokenNftApprovals().size()).isEqualTo(1);
        assertThat(accountAllowanceApproveTransaction.getTokenNftApprovals().get(0).tokenId).isEqualTo(testTokenId);
        assertThat(accountAllowanceApproveTransaction.getTokenNftApprovals().get(0).ownerAccountId).isEqualTo(
            testOwnerAccountId);
        assertThat(accountAllowanceApproveTransaction.getTokenNftApprovals().get(0).spenderAccountId).isEqualTo(
            testSpenderAccountId);
        assertTrue(accountAllowanceApproveTransaction.getTokenNftApprovals().get(0).serialNumbers.isEmpty());
        assertFalse(accountAllowanceApproveTransaction.getTokenNftApprovals().get(0).allSerials);
        assertNull(accountAllowanceApproveTransaction.getTokenNftApprovals().get(0).delegatingSpender);
    }

    @Test
    void deleteNftAllowanceAllSerialsFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class,
            () -> tx.deleteTokenNftAllowanceAllSerials(testTokenId, testOwnerAccountId, testSpenderAccountId));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountAllowanceDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoDeleteAllowanceTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class AccountAllowanceDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    AccountAllowanceDeleteTransaction spawnTestTransaction() {
        var ownerId = AccountId.fromString("5.6.7");
        return new AccountAllowanceDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .deleteAllHbarAllowances(ownerId)
            .deleteAllTokenAllowances(TokenId.fromString("2.2.2"), ownerId)
            .deleteAllTokenNftAllowances(TokenId.fromString("4.4.4").nft(123), ownerId)
            .deleteAllTokenNftAllowances(TokenId.fromString("4.4.4").nft(456), ownerId)
            .deleteAllTokenNftAllowances(TokenId.fromString("8.8.8").nft(456), ownerId)
            .deleteAllTokenNftAllowances(TokenId.fromString("4.4.4").nft(789), ownerId)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = AccountAllowanceApproveTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setCryptoDeleteAllowance(CryptoDeleteAllowanceTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(AccountAllowanceDeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountBalanceQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class AccountBalanceQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeWithAccountId() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new AccountBalanceQuery()
            .setAccountId(AccountId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void shouldSerializeWithContractId() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new AccountBalanceQuery()
            .setContractId(ContractId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class AccountCreateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    AccountCreateTransaction spawnTestTransaction() {
        return new AccountCreateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setKey(unusedPrivateKey)
            .setInitialBalance(Hbar.fromTinybars(450))
            .setProxyAccountId(AccountId.fromString("0.0.1001"))
            .setAccountMemo("some dumb memo")
            .setReceiverSignatureRequired(true)
            .setAutoRenewPeriod(Duration.ofHours(10))
            .setStakedAccountId(AccountId.fromString("0.0.3"))
            .setAlias("0x5c562e90feaf0eebd33ea75d21024f249d451417")
            .setMaxAutomaticTokenAssociations(100)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    AccountCreateTransaction spawnTestTransaction2() {
        return new AccountCreateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setKey(unusedPrivateKey)
            .setInitialBalance(Hbar.fromTinybars(450))
            .setProxyAccountId(AccountId.fromString("0.0.1001"))
            .setAccountMemo("some dumb memo")
            .setReceiverSignatureRequired(true)
            .setAutoRenewPeriod(Duration.ofHours(10))
            .setStakedNodeId(4L)
            .setMaxAutomaticTokenAssociations(100)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = AccountCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldSerialize2() {
        SnapshotMatcher.expect(spawnTestTransaction2().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes2() throws Exception {
        var tx = spawnTestTransaction2();
        var tx2 = AccountCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void propertiesTest() {
        var tx = spawnTestTransaction();

        assertThat(tx.getKey()).isEqualTo(unusedPrivateKey);
        assertThat(tx.getInitialBalance()).isEqualTo(Hbar.fromTinybars(450));
        assertThat(tx.getReceiverSignatureRequired()).isTrue();
        assertThat(tx.getProxyAccountId()).hasToString("0.0.1001");
        assertThat(tx.getAutoRenewPeriod().toHours()).isEqualTo(10);
        assertThat(tx.getMaxAutomaticTokenAssociations()).isEqualTo(100);
        assertThat(tx.getAccountMemo()).isEqualTo("some dumb memo");
        assertThat(tx.getStakedAccountId()).hasToString("0.0.3");
        assertThat(tx.getStakedNodeId()).isNull();
        assertThat(tx.getDeclineStakingReward()).isFalse();
        assertThat(tx.getAlias()).isEqualTo(EvmAddress.fromString("0x5c562e90feaf0eebd33ea75d21024f249d451417"));
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setCryptoCreateAccount(CryptoCreateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(AccountCreateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class AccountDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private AccountDeleteTransaction spawnTestTransaction() {
        return new AccountDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.5007"))
            .setTransferAccountId(AccountId.fromString("0.0.5008"))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = AccountDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setCryptoDelete(
                CryptoDeleteTransactionBody.newBuilder()
                    .setDeleteAccountID(AccountId.fromString("6.6.6").toProtobuf()).build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(AccountDeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeoutException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountIdTest {

    static Client mainnetClient;
    static Client testnetClient;
    static Client previewnetClient;

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
        mainnetClient = Client.forMainnet();
        testnetClient = Client.forTestnet();
        previewnetClient = Client.forPreviewnet();
    }

    @AfterAll
    public static void afterAll() throws TimeoutException {
        mainnetClient.close();
        testnetClient.close();
        previewnetClient.close();
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromString() {
        SnapshotMatcher.expect(AccountId.fromString("0.0.5005").toString()).toMatchSnapshot();
    }

    @Test
    void fromStringWithChecksumOnMainnet() {
        SnapshotMatcher.expect(AccountId.fromString("0.0.123-vfmkw").toStringWithChecksum(mainnetClient)).toMatchSnapshot();
    }

    @Test
    void fromStringWithChecksumOnTestnet() {
        SnapshotMatcher.expect(AccountId.fromString("0.0.123-esxsf").toStringWithChecksum(testnetClient)).toMatchSnapshot();
    }

    @Test
    void fromStringWithChecksumOnPreviewnet() {
        SnapshotMatcher.expect(AccountId.fromString("0.0.123-ogizo").toStringWithChecksum(previewnetClient)).toMatchSnapshot();
    }

    @Test
    void goodChecksumOnMainnet() throws BadEntityIdException {
        AccountId.fromString("0.0.123-vfmkw").validateChecksum(mainnetClient);
    }

    @Test
    void goodChecksumOnTestnet() throws BadEntityIdException {
        AccountId.fromString("0.0.123-esxsf").validateChecksum(testnetClient);
    }

    @Test
    void goodChecksumOnPreviewnet() throws BadEntityIdException {
        AccountId.fromString("0.0.123-ogizo").validateChecksum(previewnetClient);
    }

    @Test
    void badChecksumOnPreviewnet() {
        assertThatExceptionOfType(BadEntityIdException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.123-ntjli").validateChecksum(previewnetClient);
        });
    }

    @Test
    void malformedIdString() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.");
        });
    }

    @Test
    void malformedIdChecksum() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.123-ntjl");
        });
    }

    @Test
    void malformedIdChecksum2() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.123-ntjl1");
        });
    }

    @Test
    void malformedAliasKey() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf777");
        });
    }

    @Test
    void malformedAliasKey2() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf777g");
        });
    }

    @Test
    void malformedAliasKey3() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            AccountId.fromString("0.0.303a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777");
        });
    }

    @Test
    void fromStringWithAliasKey() {
        SnapshotMatcher.expect(AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777").toString()).toMatchSnapshot();
    }

    @Test
    void fromStringWithEvmAddress() {
        SnapshotMatcher.expect(AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82da").toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddress() {
        SnapshotMatcher.expect(AccountId.fromSolidityAddress("000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddressWith0x() {
        SnapshotMatcher.expect(AccountId.fromSolidityAddress("0x000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(Hex.toHexString(new AccountId(5005).toProtobuf().toByteArray())).toMatchSnapshot();
    }

    @Test
    void toBytesAlias() {
        SnapshotMatcher.expect(Hex.toHexString(AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777").toBytes())).toMatchSnapshot();
    }

    @Test
    void toBytesEvmAddress() {
        SnapshotMatcher.expect(Hex.toHexString(AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82da").toBytes())).toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(AccountId.fromBytes(new AccountId(5005).toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void toFromProtobuf() {
        var id1 = new AccountId(5005);
        var id2 = AccountId.fromProtobuf(id1.toProtobuf());
        assertThat(id2).isEqualTo(id1);
    }

    @Test
    void fromBytesAlias() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(AccountId.fromBytes(AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777").toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void toFromProtobufAliasKey() {
        var id1 = AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82dab5c15ea149f02d34a012087b163516dd70f44acafabf7777");
        var id2 = AccountId.fromProtobuf(id1.toProtobuf());
        assertThat(id2).isEqualTo(id1);
    }

    @Test
    void toFromProtobufEcdsaAliasKey() {
        var id1 = AccountId.fromString("0.0.302d300706052b8104000a032200035d348292bbb8b511fdbe24e3217ec099944b4728999d337f9a025f4193324525");
        var id2 = AccountId.fromProtobuf(id1.toProtobuf());
        assertThat(id2).isEqualTo(id1);
    }

    @Test
    void fromBytesEvmAddress() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(AccountId.fromBytes(AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82da").toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void toFromProtobufEvmAddress() {
        var id1 = AccountId.fromString("0.0.302a300506032b6570032100114e6abc371b82da");
        var id2 = AccountId.fromProtobuf(id1.toProtobuf());
        assertThat(id2).isEqualTo(id1);
    }

    @Test
    void toFromProtobufRawEvmAddress() {
        var id1 = AccountId.fromString("302a300506032b6570032100114e6abc371b82da");
        var id2 = AccountId.fromProtobuf(id1.toProtobuf());
        assertThat(id2).isEqualTo(id1);
    }

    @Test
    void toSolidityAddress() {
        SnapshotMatcher.expect(new AccountId(5005).toSolidityAddress()).toMatchSnapshot();
    }

    @Test
    void fromEvmAddress() {
        String evmAddress = "302a300506032b6570032100114e6abc371b82da";
        var id = AccountId.fromEvmAddress(evmAddress, 5, 9);

        assertThat(id.evmAddress).hasToString(evmAddress);
        assertThat(id.shard).isEqualTo(5);
        assertThat(id.realm).isEqualTo(9);
    }

    @Test
    void fromEvmAddressWithPrefix() {
        String evmAddressString = "302a300506032b6570032100114e6abc371b82da";
        EvmAddress evmAddress = EvmAddress.fromString(evmAddressString);
        var id1 = AccountId.fromEvmAddress(evmAddress);
        var id2 = AccountId.fromEvmAddress("0x" + evmAddressString);
        assertThat(id2).isEqualTo(id1);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountInfoQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class AccountInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new AccountInfoQuery()
            .setAccountId(AccountId.fromString("0.0.5005"))
            .setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountInfoTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoGetInfoResponse;
import com.hedera.hashgraph.sdk.proto.KeyList;
import com.hedera.hashgraph.sdk.proto.LiveHash;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;

public class AccountInfoTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final byte[] hash = {0, 1, 2};
    private static final LiveHash liveHash = LiveHash.newBuilder().setAccountId(new AccountId(10).toProtobuf())
        .setDuration(DurationConverter.toProtobuf(Duration.ofDays(11)))
        .setHash(ByteString.copyFrom(hash))
        .setKeys(KeyList.newBuilder().addKeys(privateKey.getPublicKey().toProtobufKey()))
        .build();
    private static final CryptoGetInfoResponse.AccountInfo info = CryptoGetInfoResponse.AccountInfo.newBuilder()
        .setAccountID(new AccountId(1).toProtobuf())
        .setDeleted(true)
        .setProxyReceived(2)
        .setKey(privateKey.getPublicKey().toProtobufKey())
        .setBalance(3)
        .setGenerateSendRecordThreshold(4)
        .setGenerateReceiveRecordThreshold(5)
        .setReceiverSigRequired(true)
        .setExpirationTime(InstantConverter.toProtobuf(Instant.ofEpochMilli(6)))
        .setAutoRenewPeriod(DurationConverter.toProtobuf(Duration.ofDays(7)))
        .setProxyAccountID(new AccountId(8).toProtobuf())
        .addLiveHashes(liveHash)
        .setLedgerId(LedgerId.PREVIEWNET.toByteString())
        .setEthereumNonce(1001)
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobufWithOtherOptions() {
        SnapshotMatcher.expect(AccountInfo.fromProtobuf(info).toString())
            .toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(AccountInfo.fromBytes(info.toByteArray()).toString())
            .toMatchSnapshot();
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(AccountInfo.fromBytes(info.toByteArray()).toBytes())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(AccountInfo.fromProtobuf(info).toProtobuf().toString())
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountRecordsQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class AccountRecordsQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new AccountRecordsQuery()
            .setAccountId(AccountId.fromString("0.0.5005"))
            .setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountStakersQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class AccountStakersQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new AccountStakersQuery()
            .setAccountId(AccountId.fromString("0.0.5005"))
            .setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AccountUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class AccountUpdateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    AccountUpdateTransaction spawnTestTransaction() {
        return new AccountUpdateTransaction()
            .setKey(unusedPrivateKey)
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.2002"))
            .setProxyAccountId(AccountId.fromString("0.0.1001"))
            .setAutoRenewPeriod(Duration.ofHours(10))
            .setExpirationTime(Instant.ofEpochSecond(1554158543))
            .setReceiverSignatureRequired(false)
            .setMaxAutomaticTokenAssociations(100)
            .setAccountMemo("Some memo")
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setStakedAccountId(AccountId.fromString("0.0.3"))
            .freeze()
            .sign(unusedPrivateKey);
    }

    AccountUpdateTransaction spawnTestTransaction2() {
        return new AccountUpdateTransaction()
            .setKey(unusedPrivateKey)
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.2002"))
            .setProxyAccountId(AccountId.fromString("0.0.1001"))
            .setAutoRenewPeriod(Duration.ofHours(10))
            .setExpirationTime(Instant.ofEpochSecond(1554158543))
            .setReceiverSignatureRequired(false)
            .setMaxAutomaticTokenAssociations(100)
            .setAccountMemo("Some memo")
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setStakedNodeId(4L)
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = AccountUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldSerialize2() {
        SnapshotMatcher.expect(spawnTestTransaction2().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes2() throws Exception {
        var tx = spawnTestTransaction2();
        var tx2 = AccountUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setCryptoUpdateAccount(CryptoUpdateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(AccountUpdateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AddressBookQueryMockTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.mirror.NetworkServiceGrpc;
import io.grpc.Server;
import io.grpc.Status;
import io.grpc.inprocess.InProcessServerBuilder;
import io.grpc.stub.StreamObserver;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.time.Duration;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.List;
import java.util.Queue;

import static com.hedera.hashgraph.sdk.BaseNodeAddress.PORT_NODE_PLAIN;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatException;

class AddressBookQueryMockTest {

    private Client client;
    final private AddressBookQueryStub addressBookServiceStub = new AddressBookQueryStub();
    private Server server;
    private AddressBookQuery addressBookQuery;

    @BeforeEach
    void setup() throws Exception {
        client = Client.forNetwork(Collections.emptyMap());
        client.setMirrorNetwork(List.of("in-process:test"));
        server = InProcessServerBuilder.forName("test")
            .addService(addressBookServiceStub)
            .directExecutor()
            .build()
            .start();
        addressBookQuery = new AddressBookQuery();
        addressBookQuery.setFileId(FileId.ADDRESS_BOOK);
    }

    @AfterEach
    void teardown() throws Exception {
        addressBookServiceStub.verify();
        if (client != null) {
            client.close();
        }
        if (server != null) {
            server.shutdown();
            server.awaitTermination();
        }
    }

    @ParameterizedTest(name = "[{0}] AddressBookQuery works")
    @CsvSource({"sync", "async"})
    void addressBookQueryWorks(String executeVersion) throws Throwable {
        addressBookServiceStub.requests.add(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
                .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
                .setLimit(3)
                .build()
        );
        addressBookServiceStub.responses.add(
            new com.hedera.hashgraph.sdk.NodeAddress()
                .setAccountId(AccountId.fromString("0.0.3"))
                .toProtobuf()
        );

        addressBookQuery.setLimit(3);

        var nodes = executeVersion.equals("sync") ?
            addressBookQuery.execute(client) :
            addressBookQuery.executeAsync(client).get();
        assertThat(nodes.nodeAddresses).hasSize(1);
        assertThat(nodes.nodeAddresses.get(0).accountId).isEqualTo(AccountId.fromString("0.0.3"));
    }

    Endpoint spawnEndpoint() {
        return new Endpoint()
            .setAddress(new byte[] {0x00, 0x01, 0x02, 0x03})
            .setDomainName("unit.test.com")
            .setPort(PORT_NODE_PLAIN);
    }

    @Test
    void networkUpdatePeriodWorks() throws Throwable {
        addressBookServiceStub.requests.add(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
                .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
                .build()
        );
        addressBookServiceStub.responses.add(
            new com.hedera.hashgraph.sdk.NodeAddress()
                .setAccountId(AccountId.fromString("0.0.3"))
                .setAddresses(Collections.singletonList(spawnEndpoint()))
                .toProtobuf()
        );

        client.setNetworkUpdatePeriod(Duration.ofSeconds(1));
        Thread.sleep(1400);

        var clientNetwork = client.getNetwork();
        assertThat(clientNetwork).hasSize(1);
        assertThat(clientNetwork.values()).contains(AccountId.fromString("0.0.3"));
    }

    @ParameterizedTest(name = "[{0}] Retry recovers w/ status {1} and description {2}")
    @CsvSource({
        "sync, INTERNAL, internal RST_STREAM error",
        "sync, INTERNAL, rst stream",
        "sync, RESOURCE_EXHAUSTED, ",
        "sync, UNAVAILABLE, ",
        "async, INTERNAL, internal RST_STREAM error",
        "async, INTERNAL, rst stream",
        "async, RESOURCE_EXHAUSTED, ",
        "async, UNAVAILABLE, "
    })
    void addressBookQueryRetries(String executeVersion, Status.Code code, String description) throws Throwable {
        addressBookServiceStub.requests.add(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
                .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
                .build()
        );
        addressBookServiceStub.requests.add(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
                .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
                .build()
        );
        addressBookServiceStub.responses.add(code.toStatus().withDescription(description).asRuntimeException());
        addressBookServiceStub.responses.add(
            new com.hedera.hashgraph.sdk.NodeAddress()
                .setAccountId(AccountId.fromString("0.0.3"))
                .toProtobuf()
        );

        var nodes = executeVersion.equals("sync") ?
            addressBookQuery.execute(client) :
            addressBookQuery.executeAsync(client).get();
        assertThat(nodes.nodeAddresses).hasSize(1);
        assertThat(nodes.nodeAddresses.get(0).accountId).isEqualTo(AccountId.fromString("0.0.3"));
    }

    @ParameterizedTest(name = "No retry w/ status {0} and description {1}")
    @CsvSource({
        "sync, INTERNAL, internal first_stream error",
        "sync, INTERNAL, internal error",
        "sync, INTERNAL, ",
        "sync, INVALID_ARGUMENT, ",
        "async, INTERNAL, internal first_stream error",
        "async, INTERNAL, internal error",
        "async, INTERNAL, ",
        "async, INVALID_ARGUMENT, "
    })
    void addressBookQueryFails(String executeVersion, Status.Code code, String description) {
        addressBookServiceStub.requests.add(com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
            .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
            .build()
        );
        addressBookServiceStub.responses.add(code.toStatus().withDescription(description).asRuntimeException());

        assertThatException().isThrownBy(() -> {
            var result = executeVersion.equals("sync") ?
                addressBookQuery.execute(client) :
                addressBookQuery.executeAsync(client).get();
        });
    }

    @ParameterizedTest(name = "[{0}] address book query stops at max attempts w/ status {1} and description {2}")
    @CsvSource({
        "sync, INTERNAL, internal RST_STREAM error",
        "sync, INTERNAL, rst stream",
        "sync, RESOURCE_EXHAUSTED, ",
        "sync, UNAVAILABLE, ",
        "async, INTERNAL, internal RST_STREAM error",
        "async, INTERNAL, rst stream",
        "async, RESOURCE_EXHAUSTED, ",
        "async, UNAVAILABLE, "
    })
    void addressBookQueryStopsAtMaxAttempts(String executeVersion, Status.Code code, String description) throws Throwable {
        addressBookQuery.setMaxAttempts(2);

        addressBookServiceStub.requests.add(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
                .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
                .build()
        );
        addressBookServiceStub.requests.add(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery.newBuilder()
                .setFileId(FileId.ADDRESS_BOOK.toProtobuf())
                .build()
        );
        addressBookServiceStub.responses.add(code.toStatus().withDescription(description).asRuntimeException());
        addressBookServiceStub.responses.add(code.toStatus().withDescription(description).asRuntimeException());

        assertThatException().isThrownBy(() -> {
            var result = executeVersion.equals("sync") ?
                addressBookQuery.execute(client) :
                addressBookQuery.executeAsync(client).get();
        });
    }

    private static class AddressBookQueryStub extends NetworkServiceGrpc.NetworkServiceImplBase {

        private final Queue<com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery> requests = new ArrayDeque<>();
        private final Queue<Object> responses = new ArrayDeque<>();

        @Override
        public void getNodes(
            com.hedera.hashgraph.sdk.proto.mirror.AddressBookQuery addressBookQuery,
            StreamObserver<com.hedera.hashgraph.sdk.proto.NodeAddress> streamObserver
        ) {
            var request = requests.poll();
            assertThat(request).isNotNull();
            assertThat(addressBookQuery).isEqualTo(request);

            while (!responses.isEmpty()) {
                var response = responses.poll();
                assertThat(response).isNotNull();

                if (response instanceof Throwable) {
                    streamObserver.onError((Throwable) response);
                    return;
                }

                streamObserver.onNext((com.hedera.hashgraph.sdk.proto.NodeAddress) response);
            }
            streamObserver.onCompleted();
        }

        public void verify() {
            assertThat(requests).isEmpty();
            assertThat(responses).isEmpty();
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AllowancesTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

public class AllowancesTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    TokenAllowance spawnTokenAllowance() {
        return new TokenAllowance(
            TokenId.fromString("1.2.3"),
            AccountId.fromString("4.5.6"),
            AccountId.fromString("5.5.5"),
            777
        );
    }

    TokenNftAllowance spawnNftAllowance() {
        List<Long> serials = new ArrayList<>();
        serials.add(123L);
        serials.add(456L);
        return new TokenNftAllowance(
            TokenId.fromString("1.1.1"),
            AccountId.fromString("2.2.2"),
            AccountId.fromString("3.3.3"),
            null,
            serials,
            null
        );
    }

    TokenNftAllowance spawnAllNftAllowance() {
        return new TokenNftAllowance(
            TokenId.fromString("1.1.1"),
            AccountId.fromString("2.2.2"),
            AccountId.fromString("3.3.3"),
            null,
            Collections.emptyList(),
            true
        );
    }

    HbarAllowance spawnHbarAllowance() {
        return new HbarAllowance(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2"), new Hbar(3));
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(
            spawnHbarAllowance().toString(),
            spawnTokenAllowance().toString(),
            spawnNftAllowance().toString(),
            spawnAllNftAllowance().toString()
        ).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws InvalidProtocolBufferException {
        var hbar1 = spawnHbarAllowance();
        var token1 = spawnTokenAllowance();
        var nft1 = spawnNftAllowance();
        var allNft1 = spawnAllNftAllowance();
        var hbar2 = HbarAllowance.fromBytes(hbar1.toBytes());
        var token2 = TokenAllowance.fromBytes(token1.toBytes());
        var nft2 = TokenNftAllowance.fromBytes(nft1.toBytes());
        var allNft2 = TokenNftAllowance.fromBytes(allNft1.toBytes());
        assertThat(hbar2.toString()).isEqualTo(hbar1.toString());
        assertThat(token2.toString()).isEqualTo(token1.toString());
        assertThat(nft2.toString()).isEqualTo(nft1.toString());
        assertThat(allNft2.toString()).isEqualTo(allNft1.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/AssessedCustomFeeTest.java
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

public class AssessedCustomFeeTest {

    private static final int amount = 1;
    private static final TokenId tokenId = new TokenId(2, 3, 4);
    private static final AccountId feeCollector = new AccountId(5, 6, 7);
    private static final List<AccountId> payerAccountIds = List.of(
        new AccountId(8, 9, 10),
        new AccountId(11, 12, 13),
        new AccountId(14, 15, 16)
    );

    private final com.hedera.hashgraph.sdk.proto.AssessedCustomFee fee =
        com.hedera.hashgraph.sdk.proto.AssessedCustomFee.newBuilder()
            .setAmount(amount)
            .setTokenId(tokenId.toProtobuf())
            .setFeeCollectorAccountId(feeCollector.toProtobuf())
            .addAllEffectivePayerAccountId(payerAccountIds.stream().map(AccountId::toProtobuf).toList())
            .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    AssessedCustomFee spawnAssessedCustomFeeExample() {
        return new AssessedCustomFee(
            201,
            TokenId.fromString("1.2.3"),
            AccountId.fromString("4.5.6"),
            List.of(
                AccountId.fromString("0.0.1"),
                AccountId.fromString("0.0.2"),
                AccountId.fromString("0.0.3")
            )
        );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalAssessedCustomFee = spawnAssessedCustomFeeExample();
        byte[] assessedCustomFeeBytes = originalAssessedCustomFee.toBytes();
        var copyAssessedCustomFee = AssessedCustomFee.fromBytes(assessedCustomFeeBytes);
        assertThat(originalAssessedCustomFee.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(copyAssessedCustomFee.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalAssessedCustomFee.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(AssessedCustomFee.fromProtobuf(fee).toString()).toMatchSnapshot();
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(AssessedCustomFee.fromProtobuf(fee).toProtobuf().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws Exception {
        var assessedCustomFee = spawnAssessedCustomFeeExample();
        var tx2 = AssessedCustomFee.fromBytes(assessedCustomFee.toBytes());
        assertThat(tx2).hasToString(assessedCustomFee.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/BaseNodeAddressTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;

import static com.hedera.hashgraph.sdk.BaseNodeAddress.PORT_MIRROR_TLS;
import static com.hedera.hashgraph.sdk.BaseNodeAddress.PORT_NODE_PLAIN;
import static com.hedera.hashgraph.sdk.BaseNodeAddress.PORT_NODE_TLS;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class BaseNodeAddressTest {
    @Test
    void fromString() {
        var ipAddress = BaseNodeAddress.fromString("35.237.200.180:50211");
        assertThat(ipAddress.getName()).isNull();
        assertThat(ipAddress.getAddress()).isEqualTo("35.237.200.180");
        assertThat(ipAddress.getPort()).isEqualTo(PORT_NODE_PLAIN);
        assertThat(ipAddress).hasToString("35.237.200.180:50211");

        var ipAddressSecure = ipAddress.toSecure();
        assertThat(ipAddressSecure.getName()).isNull();
        assertThat(ipAddressSecure.getAddress()).isEqualTo("35.237.200.180");
        assertThat(ipAddressSecure.getPort()).isEqualTo(PORT_NODE_TLS);
        assertThat(ipAddressSecure).hasToString("35.237.200.180:50212");

        var ipAddressInsecure = ipAddressSecure.toInsecure();
        assertThat(ipAddressInsecure.getName()).isNull();
        assertThat(ipAddressInsecure.getAddress()).isEqualTo("35.237.200.180");
        assertThat(ipAddressInsecure.getPort()).isEqualTo(PORT_NODE_PLAIN);
        assertThat(ipAddressInsecure).hasToString("35.237.200.180:50211");

        var urlAddress = BaseNodeAddress.fromString("0.testnet.hedera.com:50211");
        assertThat(urlAddress.getName()).isNull();
        assertThat(urlAddress.getAddress()).isEqualTo("0.testnet.hedera.com");
        assertThat(urlAddress.getPort()).isEqualTo(PORT_NODE_PLAIN);
        assertThat(urlAddress).hasToString("0.testnet.hedera.com:50211");

        var urlAddressSecure = urlAddress.toSecure();
        assertThat(urlAddressSecure.getName()).isNull();
        assertThat(urlAddressSecure.getAddress()).isEqualTo("0.testnet.hedera.com");
        assertThat(urlAddressSecure.getPort()).isEqualTo(PORT_NODE_TLS);
        assertThat(urlAddressSecure).hasToString("0.testnet.hedera.com:50212");

        var urlAddressInsecure = urlAddressSecure.toInsecure();
        assertThat(urlAddressInsecure.getName()).isNull();
        assertThat(urlAddressInsecure.getAddress()).isEqualTo("0.testnet.hedera.com");
        assertThat(urlAddressInsecure.getPort()).isEqualTo(PORT_NODE_PLAIN);
        assertThat(urlAddressInsecure).hasToString("0.testnet.hedera.com:50211");

        var processAddress = BaseNodeAddress.fromString("in-process:testingProcess");
        assertThat(processAddress.getName()).isEqualTo("testingProcess");
        assertThat(processAddress.getAddress()).isNull();
        assertThat(processAddress.getPort()).isEqualTo(0);
        assertThat(processAddress).hasToString("testingProcess");

        var processAddressSecure = processAddress.toSecure();
        assertThat(processAddressSecure.getName()).isEqualTo("testingProcess");
        assertThat(processAddressSecure.getAddress()).isNull();
        assertThat(processAddressSecure.getPort()).isEqualTo(0);
        assertThat(processAddressSecure).hasToString("testingProcess");

        var processAddressInsecure = processAddressSecure.toInsecure();
        assertThat(processAddressInsecure.getName()).isEqualTo("testingProcess");
        assertThat(processAddressInsecure.getAddress()).isNull();
        assertThat(processAddressInsecure.getPort()).isEqualTo(0);
        assertThat(processAddressInsecure).hasToString("testingProcess");

        var mirrorNodeAddress = BaseNodeAddress.fromString("mainnet-public.mirrornode.hedera.com:443");
        assertThat(mirrorNodeAddress.getName()).isNull();
        assertThat(mirrorNodeAddress.getAddress()).isEqualTo("mainnet-public.mirrornode.hedera.com");
        assertThat(mirrorNodeAddress.getPort()).isEqualTo(PORT_MIRROR_TLS);
        assertThat(mirrorNodeAddress).hasToString("mainnet-public.mirrornode.hedera.com:443");

        var mirrorNodeAddressSecure = mirrorNodeAddress.toSecure();
        assertThat(mirrorNodeAddressSecure.getName()).isNull();
        assertThat(mirrorNodeAddressSecure.getAddress()).isEqualTo("mainnet-public.mirrornode.hedera.com");
        assertThat(mirrorNodeAddressSecure.getPort()).isEqualTo(PORT_MIRROR_TLS);
        assertThat(mirrorNodeAddressSecure).hasToString("mainnet-public.mirrornode.hedera.com:443");

        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> BaseNodeAddress.fromString("this is a random string with spaces:443"));
        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> BaseNodeAddress.fromString("mainnet-public.mirrornode.hedera.com:notarealport"));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ClientCloseTest.java
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.Collections;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class ClientCloseTest {
    @Test
    void closeHandlesNetworkTimeout() {
        var executor = Client.createExecutor();
        var network = mock(Network.class);
        when(network.awaitClose(any(), any())).thenReturn(new TimeoutException("network timeout"));
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, Collections.emptyList());
        var client = new Client(executor, network, mirrorNetwork, null, null);

        assertThatExceptionOfType(TimeoutException.class).isThrownBy(client::close).withMessage("network timeout");
        assertThat(mirrorNetwork.hasShutDownNow).isTrue();
    }

    @Test
    void closeHandlesNetworkInterrupted() {
        var interruptedException = new InterruptedException("network interrupted");
        var executor = Client.createExecutor();
        var network = mock(Network.class);
        when(network.awaitClose(any(), any())).thenReturn(interruptedException);
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, Collections.emptyList());
        var client = new Client(executor, network, mirrorNetwork, null, null);

        assertThatExceptionOfType(RuntimeException.class).isThrownBy(client::close).withCause(interruptedException);
        assertThat(mirrorNetwork.hasShutDownNow).isTrue();
    }

    @Test
    void closeHandlesMirrorNetworkTimeout() {
        var executor = Client.createExecutor();
        var network = Network.forNetwork(executor, Collections.emptyMap());
        var mirrorNetwork = mock(MirrorNetwork.class);
        when(mirrorNetwork.awaitClose(any(), any())).thenReturn(new TimeoutException("mirror timeout"));
        var client = new Client(executor, network, mirrorNetwork, null, null);

        assertThatExceptionOfType(TimeoutException.class).isThrownBy(client::close).withMessage("mirror timeout");
        assertThat(network.hasShutDownNow).isFalse();
    }

    @Test
    void closeHandlesMirrorNetworkInterrupted() {
        var interruptedException = new InterruptedException("network interrupted");
        var executor = Client.createExecutor();
        var network = Network.forNetwork(executor, Collections.emptyMap());
        var mirrorNetwork = mock(MirrorNetwork.class);
        when(mirrorNetwork.awaitClose(any(), any())).thenReturn(interruptedException);
        var client = new Client(executor, network, mirrorNetwork, null, null);

        assertThatExceptionOfType(RuntimeException.class).isThrownBy(client::close).withCause(interruptedException);
        assertThat(network.hasShutDownNow).isFalse();
    }

    @Test
    void closeHandlesExecutorShutdown() throws TimeoutException {
        var executor = Client.createExecutor();
        var network = Network.forNetwork(executor, Collections.emptyMap());
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, Collections.emptyList());
        var client = new Client(executor, network, mirrorNetwork, null, null);

        client.close();
        assertThat(executor.isShutdown()).isTrue();
    }

    @Test
    void closeHandlesExecutorTerminatingInTime() throws InterruptedException, TimeoutException {
        var duration = Duration.ofSeconds(30);
        var executor = mock(ThreadPoolExecutor.class);
        var network = Network.forNetwork(executor, Collections.emptyMap());
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, Collections.emptyList());
        var client = new Client(executor, network, mirrorNetwork, null, null);

        doReturn(true).when(executor).awaitTermination(30 / 2, TimeUnit.SECONDS);

        client.close(duration);
        verify(executor, times(0)).shutdownNow();
    }

    @Test
    void closeHandlesExecutorNotTerminatingInTime() throws InterruptedException, TimeoutException {
        var duration = Duration.ofSeconds(30);
        var executor = mock(ThreadPoolExecutor.class);
        var network = Network.forNetwork(executor, Collections.emptyMap());
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, Collections.emptyList());
        var client = new Client(executor, network, mirrorNetwork, null, null);

        doReturn(false).when(executor).awaitTermination(30 / 2, TimeUnit.SECONDS);

        client.close(duration);
        verify(executor, times(1)).shutdownNow();
    }

    @Test
    void closeHandlesExecutorWhenThreadIsInterrupted() throws InterruptedException, TimeoutException {
        var duration = Duration.ofSeconds(30);
        var executor = mock(ThreadPoolExecutor.class);
        var network = Network.forNetwork(executor, Collections.emptyMap());
        var mirrorNetwork = MirrorNetwork.forNetwork(executor, Collections.emptyList());
        var client = new Client(executor, network, mirrorNetwork, null, null);

        doThrow(new InterruptedException()).when(executor).awaitTermination(30 / 2, TimeUnit.SECONDS);

        client.close(duration);
        verify(executor, times(1)).shutdownNow();
    }

    @Test
    void noHealthyNodesNetwork() {
        var executor = Client.createExecutor();
        var network = Network.forNetwork(executor, Collections.emptyMap());

        assertThatExceptionOfType(IllegalStateException.class)
            .isThrownBy(network::getRandomNode)
            .withMessage("No healthy node was found");
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ClientTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.NullSource;
import org.junit.jupiter.params.provider.ValueSource;

import com.google.protobuf.ByteString;
import javax.annotation.Nullable;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.function.Function;

import static com.hedera.hashgraph.sdk.BaseNodeAddress.PORT_NODE_PLAIN;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

class ClientTest {

    @Test
    @DisplayName("Can construct mainnet client")
    void forMainnet() throws TimeoutException {
        Client.forMainnet().close();
    }

    @Test
    @DisplayName("Can construct mainnet client with executor")
    void forMainnetWithExecutor() throws TimeoutException {
        var executor = new ThreadPoolExecutor(2, 2,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(), new ThreadPoolExecutor.CallerRunsPolicy());

        Client.forMainnet(executor).close();
    }

    @Test
    @DisplayName("Can construct testnet client with executor")
    void forTestnetWithExecutor() throws TimeoutException {
        var executor = new ThreadPoolExecutor(2, 2,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(), new ThreadPoolExecutor.CallerRunsPolicy());

        Client.forTestnet(executor).close();
    }

    @Test
    @DisplayName("Can construct previewnet client with executor")
    void forPreviewnetWithWithExecutor() throws TimeoutException {
        var executor = new ThreadPoolExecutor(2, 2,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(), new ThreadPoolExecutor.CallerRunsPolicy());

        Client.forPreviewnet(executor).close();
    }

    @Test
    @DisplayName("Client.setMaxQueryPayment() negative")
    void setMaxQueryPaymentNegative() throws TimeoutException {
        var client = Client.forTestnet();
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            client.setMaxQueryPayment(Hbar.MIN);
        });
        client.close();
    }

    @ValueSource(ints = {-1, 0})
    @ParameterizedTest(name = "Invalid maxAttempts {0}")
    void setMaxAttempts(int maxAttempts) throws TimeoutException {
        var client = Client.forNetwork(Map.of());
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            client.setMaxAttempts(maxAttempts);
        });
        client.close();
    }

    @NullSource
    @ValueSource(longs = {-1, 0, 249})
    @ParameterizedTest(name = "Invalid maxBackoff {0}")
    @SuppressWarnings("NullAway")
    void setMaxBackoffInvalid(@Nullable Long maxBackoffMillis) throws TimeoutException {
        @Nullable Duration maxBackoff = maxBackoffMillis != null ? Duration.ofMillis(maxBackoffMillis) : null;
        var client = Client.forNetwork(Map.of());
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            client.setMaxBackoff(maxBackoff);
        });
        client.close();
    }

    @ValueSource(longs = {250, 8000})
    @ParameterizedTest(name = "Valid maxBackoff {0}")
    void setMaxBackoffValid(long maxBackoff) throws TimeoutException {
        Client.forNetwork(Map.of()).setMaxBackoff(Duration.ofMillis(maxBackoff)).close();
    }

    @NullSource
    @ValueSource(longs = {-1, 8001})
    @ParameterizedTest(name = "Invalid minBackoff {0}")
    @SuppressWarnings("NullAway")
    void setMinBackoffInvalid(@Nullable Long minBackoffMillis) throws TimeoutException {
        @Nullable Duration minBackoff = minBackoffMillis != null ? Duration.ofMillis(minBackoffMillis) : null;
        var client = Client.forNetwork(Map.of());
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            client.setMinBackoff(minBackoff);
        });
        client.close();
    }

    @ValueSource(longs = {0, 250, 8000})
    @ParameterizedTest(name = "Valid minBackoff {0}")
    void setMinBackoffValid(long minBackoff) throws TimeoutException {
        Client.forNetwork(Map.of()).setMinBackoff(Duration.ofMillis(minBackoff)).close();
    }

    @Test
    @DisplayName("Client.setMaxTransactionFee() negative")
    void setMaxTransactionFeeNegative() throws TimeoutException {
        var client = Client.forTestnet();
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            client.setDefaultMaxTransactionFee(Hbar.MIN);
        });
        client.close();
    }

    @Test
    @DisplayName("fromJsonFile() functions correctly")
    void fromJsonFile() throws Exception {
        Client.fromConfigFile(new File("./src/test/resources/client-config.json")).close();
        Client.fromConfigFile(new File("./src/test/resources/client-config-with-operator.json")).close();
        Client.fromConfigFile("./src/test/resources/client-config.json").close();
        Client.fromConfigFile("./src/test/resources/client-config-with-operator.json").close();
    }

    @Test
    @DisplayName("fromJson() functions correctly")
    void testFromJson() throws Exception {
        // Copied content of `client-config-with-operator.json`
        var client = Client.fromConfig("{\n" +
                "    \"network\":\"mainnet\",\n" +
                "    \"operator\": {\n" +
                "        \"accountId\": \"0.0.36\",\n" +
                "        \"privateKey\": \"302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10\"\n" +
                "    }\n" +
                "}\n");

        // put it in a file for nicer formatting
        InputStream clientConfig = ClientTest.class.getClassLoader()
                .getResourceAsStream("client-config.json");

        assertThat(clientConfig).isNotNull();

        Client.fromConfig(new InputStreamReader(clientConfig, StandardCharsets.UTF_8)).close();

        // put it in a file for nicer formatting
        InputStream clientConfigWithOperator = ClientTest.class.getClassLoader()
                .getResourceAsStream("client-config-with-operator.json");

        assertThat(clientConfigWithOperator).isNotNull();

        client.close();
    }

    @Test
    @DisplayName("setNetwork() functions correctly")
    void setNetworkWorks() throws Exception {
        var defaultNetwork = Map.of(
                "0.testnet.hedera.com:50211", new AccountId(3),
                "1.testnet.hedera.com:50211", new AccountId(4)
        );

        Client client = Client.forNetwork(defaultNetwork);
        assertThat(client.getNetwork()).containsExactlyInAnyOrderEntriesOf(defaultNetwork);

        client.setNetwork(defaultNetwork);
        assertThat(client.getNetwork()).containsExactlyInAnyOrderEntriesOf(defaultNetwork);

        var defaultNetworkWithExtraNode = Map.of(
                "0.testnet.hedera.com:50211", new AccountId(3),
                "1.testnet.hedera.com:50211", new AccountId(4),
                "2.testnet.hedera.com:50211", new AccountId(5)
        );

        client.setNetwork(defaultNetworkWithExtraNode);
        assertThat(client.getNetwork()).containsExactlyInAnyOrderEntriesOf(defaultNetworkWithExtraNode);

        var singleNodeNetwork = Map.of(
                "2.testnet.hedera.com:50211", new AccountId(5)
        );

        client.setNetwork(singleNodeNetwork);
        assertThat(client.getNetwork()).containsExactlyInAnyOrderEntriesOf(singleNodeNetwork);

        var singleNodeNetworkWithDifferentAccountId = Map.of(
                "2.testnet.hedera.com:50211", new AccountId(6)
        );

        client.setNetwork(singleNodeNetworkWithDifferentAccountId);
        assertThat(client.getNetwork()).containsExactlyInAnyOrderEntriesOf(singleNodeNetworkWithDifferentAccountId);

        var multiAddressNetwork = Map.of(
                "0.testnet.hedera.com:50211", new AccountId(3),
                "34.94.106.61:50211", new AccountId(3),
                "50.18.132.211:50211", new AccountId(3),
                "138.91.142.219:50211", new AccountId(3),

                "1.testnet.hedera.com:50211", new AccountId(4),
                "35.237.119.55:50211", new AccountId(4),
                "3.212.6.13:50211", new AccountId(4),
                "52.168.76.241:50211", new AccountId(4)
        );

        client.setNetwork(multiAddressNetwork);
        assertThat(client.getNetwork()).containsExactlyInAnyOrderEntriesOf(multiAddressNetwork);

        client.close();
    }

    @Test
    @DisplayName("setMirrorNetwork() functions correctly")
    void setMirrorNetworkWorks() throws Exception {
        var defaultNetwork = List.of("testnet.mirrornode.hedera.com:443");

        Client client = Client.forNetwork(new HashMap<>()).setMirrorNetwork(defaultNetwork);
        assertThat(client.getMirrorNetwork()).containsExactlyInAnyOrderElementsOf(defaultNetwork);

        client.setMirrorNetwork(defaultNetwork);
        assertThat(client.getMirrorNetwork()).containsExactlyInAnyOrderElementsOf(defaultNetwork);

        var defaultNetworkWithExtraNode = List.of(
                "testnet.mirrornode.hedera.com:443",
                "testnet1.mirrornode.hedera.com:443"
        );

        client.setMirrorNetwork(defaultNetworkWithExtraNode);
        assertThat(client.getMirrorNetwork()).containsExactlyInAnyOrderElementsOf(defaultNetworkWithExtraNode);

        var singleNodeNetwork = List.of("testnet1.mirrornode.hedera.com:443");

        client.setMirrorNetwork(singleNodeNetwork);
        assertThat(client.getMirrorNetwork()).containsExactlyInAnyOrderElementsOf(singleNodeNetwork);

        var singleNodeNetworkWithDifferentNode = List.of("testnet.mirrornode.hedera.com:443");

        client.setMirrorNetwork(singleNodeNetworkWithDifferentNode);
        assertThat(client.getMirrorNetwork()).containsExactlyInAnyOrderElementsOf(singleNodeNetworkWithDifferentNode);

        client.close();
    }

    @Test
    @DisplayName("setMirrorNetwork() throws exception if there is no time to remove the old nodes")
    void setMirrorNetworkFails() throws Exception {
        var defaultNetwork = List.of(
            "testnet.mirrornode.hedera.com:443",
            "testnet.mirrornode2.hedera.com:443"
        );

        Client client = Client.forNetwork(new HashMap<>()).setMirrorNetwork(defaultNetwork);
        assertThat(client.getMirrorNetwork()).containsExactlyInAnyOrderElementsOf(defaultNetwork);

        client.setCloseTimeout(Duration.ZERO);
        final List<String> updatedNetwork = List.of("testnet.mirrornode.hedera.com:443");

        assertThatThrownBy(() -> client.setMirrorNetwork(updatedNetwork))
            .hasMessageEndingWith("Failed to properly shutdown all channels");
    }

    @Test
    @DisplayName("forName() sets the correct network")
    void forNameReturnsCorrectNetwork() {
        Client mainnetClient = Client.forName("mainnet");
        assertThat(mainnetClient.getLedgerId()).isEqualTo(LedgerId.MAINNET);

        Client testnetClient = Client.forName("testnet");
        assertThat(testnetClient.getLedgerId()).isEqualTo(LedgerId.TESTNET);

        Client previewnetClient = Client.forName("previewnet");
        assertThat(previewnetClient.getLedgerId()).isEqualTo(LedgerId.PREVIEWNET);

        assertThatThrownBy(() -> Client.forName("unknown"))
            .hasMessageEndingWith("Name must be one-of `mainnet`, `testnet`, or `previewnet`");
    }

        @ParameterizedTest
    @CsvSource({
        "onClient",
        "onQuery"
    })
    void testExecuteAsyncTimeout(String timeoutSite) throws Exception {
        AccountId accountId = AccountId.fromString("0.0.1");
        Duration timeout = Duration.ofSeconds(5);

        Client client = Client.forNetwork(Map.of("1.1.1.1:50211", accountId))
            .setNodeMinBackoff(Duration.ofMillis(0))
            .setNodeMaxBackoff(Duration.ofMillis(0))
            .setMinNodeReadmitTime(Duration.ofMillis(0))
            .setMaxNodeReadmitTime(Duration.ofMillis(0));
        AccountBalanceQuery query = new AccountBalanceQuery()
                .setAccountId(accountId)
                .setMaxAttempts(3);
        Instant start = Instant.now();

        try {
            if (timeoutSite.equals("onClient")) {
                client.setRequestTimeout(timeout);
                query.executeAsync(client).get();
            } else {
                query.executeAsync(client, timeout).get();
            }
        } catch (ExecutionException e) {
            // fine...
        }
        long secondsTaken = java.time.Duration.between(start, Instant.now()).toSeconds();

        // 20 seconds would indicate we tried 2 times to connect
        assertThat(secondsTaken).isLessThan(7);

        client.close();
    }

    @ParameterizedTest
    @CsvSource({
        "onClient",
        "onQuery"
    })
    void testExecuteSyncTimeout(String timeoutSite) throws Exception {
        AccountId accountId = AccountId.fromString("0.0.1");
        // Executing requests in sync mode will require at most 10 seconds to connect
        // to a gRPC node. If we're not able to connect to a gRPC node within 10 seconds
        // we fail that request attempt. This means setting at timeout on a request
        // which hits non-connecting gRPC nodes will fail within ~10s of the set timeout
        // e.g. setting a timeout of 15 seconds, the request could fail within the range
        // of [5 seconds, 25 seconds]. The 10 second timeout for connecting to gRPC nodes
        // is not configurable.
        Duration timeout = Duration.ofSeconds(5);

        Client client = Client.forNetwork(Map.of("1.1.1.1:50211", accountId))
            .setNodeMinBackoff(Duration.ofMillis(0))
            .setNodeMaxBackoff(Duration.ofMillis(0))
            .setMinNodeReadmitTime(Duration.ofMillis(0))
            .setMaxNodeReadmitTime(Duration.ofMillis(0));

        AccountBalanceQuery query = new AccountBalanceQuery()
            .setAccountId(accountId)
            .setMaxAttempts(3)
            .setGrpcDeadline(Duration.ofSeconds(5));
        Instant start = Instant.now();

        try {
            if (timeoutSite.equals("onClient")) {
                client.setRequestTimeout(timeout);
                query.execute(client);
            } else {
                query.execute(client, timeout);
            }
        } catch (TimeoutException e) {
            // fine...
        }
        long secondsTaken = java.time.Duration.between(start, Instant.now()).toSeconds();

        // 20 seconds would indicate we tried 2 times to connect
        assertThat(secondsTaken).isLessThan(15);

        client.close();
    }

    com.hedera.hashgraph.sdk.proto.NodeAddress nodeAddress(long accountNum, String rsaPubKeyHex, byte[] certHash, byte[] ipv4) {
        com.hedera.hashgraph.sdk.proto.NodeAddress.Builder builder = com.hedera.hashgraph.sdk.proto.NodeAddress.newBuilder()
            .setNodeAccountId(com.hedera.hashgraph.sdk.proto.AccountID.newBuilder()
                .setAccountNum(accountNum)
                .build())
            .addServiceEndpoint(com.hedera.hashgraph.sdk.proto.ServiceEndpoint.newBuilder()
                .setIpAddressV4(ByteString.copyFrom(ipv4))
                .setPort(PORT_NODE_PLAIN)
                .build())
            .setRSAPubKey(rsaPubKeyHex);
        if (certHash != null) {
            builder.setNodeCertHash(ByteString.copyFrom(certHash));
        }
        return builder.build();
    }

    @Test
    @DisplayName("setNetworkFromAddressBook() updates security parameters in the client")
    void setNetworkFromAddressBook() throws Exception {
        try (Client client = Client.forNetwork(Map.of())) {
            Function<Integer, NodeAddress> nodeAddress = accountNum -> client.network.network.get(new AccountId(accountNum)).get(0).getAddressBookEntry();

            // reconfigure client network from addressbook (add new nodes)
            client.setNetworkFromAddressBook(NodeAddressBook.fromBytes(com.hedera.hashgraph.sdk.proto.NodeAddressBook.newBuilder()
                .addNodeAddress(nodeAddress(10001, "10001", new byte[] {1, 0, 1}, new byte[] {10, 0, 0, 1}))
                .addNodeAddress(nodeAddress(10002, "10002", new byte[] {1, 0, 2}, new byte[] {10, 0, 0, 2}))
                .build().toByteString()), true);

            // verify security parameters in client
            assertThat(nodeAddress.apply(10001).certHash).isEqualTo(ByteString.copyFrom(new byte[]{1, 0, 1}));
            assertThat(nodeAddress.apply(10001).publicKey).isEqualTo("10001");
            assertThat(nodeAddress.apply(10002).certHash).isEqualTo(ByteString.copyFrom(new byte[]{1, 0, 2}));
            assertThat(nodeAddress.apply(10002).publicKey).isEqualTo("10002");

            // reconfigure client network from addressbook without `certHash`
            client.setNetworkFromAddressBook(NodeAddressBook.fromBytes(com.hedera.hashgraph.sdk.proto.NodeAddressBook.newBuilder()
                .addNodeAddress(nodeAddress(10001, "10001", null, new byte[] {10, 0, 0, 1}))
                .addNodeAddress(nodeAddress(10002, "10002", null, new byte[] {10, 0, 0, 2}))
                .build().toByteString()), true);

            // verify security parameters in client (unchanged)
            assertThat(nodeAddress.apply(10001).certHash).isEqualTo(ByteString.copyFrom(new byte[]{1, 0, 1}));
            assertThat(nodeAddress.apply(10001).publicKey).isEqualTo("10001");
            assertThat(nodeAddress.apply(10002).certHash).isEqualTo(ByteString.copyFrom(new byte[]{1, 0, 2}));
            assertThat(nodeAddress.apply(10002).publicKey).isEqualTo("10002");

            // reconfigure client network from addressbook (update existing nodes)
            client.setNetworkFromAddressBook(NodeAddressBook.fromBytes(com.hedera.hashgraph.sdk.proto.NodeAddressBook.newBuilder()
                .addNodeAddress(nodeAddress(10001, "810001", new byte[] {8, 1, 0, 1}, new byte[] {10, 0, 0, 1}))
                .addNodeAddress(nodeAddress(10002, "810002", new byte[] {8, 1, 0, 2}, new byte[] {10, 0, 0, 2}))
                .build().toByteString()), true);

            // verify security parameters in client
            assertThat(nodeAddress.apply(10001).certHash).isEqualTo(ByteString.copyFrom(new byte[]{8, 1, 0, 1}));
            assertThat(nodeAddress.apply(10001).publicKey).isEqualTo("810001");
            assertThat(nodeAddress.apply(10002).certHash).isEqualTo(ByteString.copyFrom(new byte[]{8, 1, 0, 2}));
            assertThat(nodeAddress.apply(10002).publicKey).isEqualTo("810002");
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ConsumerHelperTest.java
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;

import java.util.concurrent.CompletableFuture;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

class ConsumerHelperTest {
    @Test
    void biConsumer() {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
        BiConsumer<String, Throwable> consumer = mock(BiConsumer.class);
        ConsumerHelper.biConsumer(future, consumer);
        future.join();
        verify(consumer, times(1)).accept(any(), any());
    }

    @Test
    void twoConsumersWithoutError() {
        var value = "Hello";
        CompletableFuture<String> future = CompletableFuture.completedFuture(value);

        Consumer<String> onSuccess = mock(Consumer.class);
        Consumer<Throwable> onFailure = mock(Consumer.class);

        ConsumerHelper.twoConsumers(future, onSuccess, onFailure);
        future.join();

        verify(onSuccess, times(1)).accept(value);
        verify(onFailure, times(0)).accept(any());
    }
    @Test
    void twoConsumersWithError() {
        var exception = new RuntimeException("Exception");
        CompletableFuture<String> future = CompletableFuture.failedFuture(exception);

        Consumer<String> onSuccess = mock(Consumer.class);
        Consumer<Throwable> onFailure = mock(Consumer.class);

        ConsumerHelper.twoConsumers(future, onSuccess, onFailure);
        assertThrows(RuntimeException.class, future::join);

        verify(onSuccess, times(0)).accept(any());
        verify(onFailure, times(1)).accept(exception);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractByteCodeQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class ContractByteCodeQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new ContractByteCodeQuery()
            .setContractId(ContractId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractCallQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;

public class ContractCallQueryTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new ContractCallQuery()
            .setContractId(ContractId.fromString("0.0.5005"))
            .setGas(1541)
            .setSenderAccountId(AccountId.fromString("1.2.3"))
            .setFunction("foo",
                new ContractFunctionParameters()
                    .addString("Hello")
                    .addString("world!"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void setFunctionParameters() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new ContractCallQuery()
            .setContractId(ContractId.fromString("0.0.5005"))
            .setGas(1541)
            .setSenderAccountId(AccountId.fromString("1.2.3"))
            .setFunctionParameters(
                new ContractFunctionParameters()
                    .addString("Hello")
                    .addString("world!")
                    .toBytes(null)
                    .toByteArray())
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ContractCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ContractCreateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    @Test
    void shouldSerialize2() {
        SnapshotMatcher.expect(spawnTestTransaction2()
            .toString()
        ).toMatchSnapshot();
    }

    private ContractCreateTransaction spawnTestTransaction() {
        return new ContractCreateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setBytecodeFileId(FileId.fromString("0.0.3003"))
            .setAdminKey(unusedPrivateKey)
            .setGas(0)
            .setInitialBalance(Hbar.fromTinybars(1000))
            .setStakedAccountId(AccountId.fromString("0.0.3"))
            .setMaxAutomaticTokenAssociations(101)
            .setAutoRenewPeriod(Duration.ofHours(10))
            .setConstructorParameters(new byte[]{10, 11, 12, 13, 25})
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setAutoRenewAccountId(new AccountId(30))
            .freeze()
            .sign(unusedPrivateKey);
    }

    private ContractCreateTransaction spawnTestTransaction2() {
        return new ContractCreateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setBytecode(Hex.decode("deadbeef"))
            .setAdminKey(unusedPrivateKey)
            .setGas(0)
            .setInitialBalance(Hbar.fromTinybars(1000))
            .setStakedNodeId(4L)
            .setMaxAutomaticTokenAssociations(101)
            .setAutoRenewPeriod(Duration.ofHours(10))
            .setConstructorParameters(new byte[]{10, 11, 12, 13, 25})
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setAutoRenewAccountId(new AccountId(30))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ContractCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytes2() throws Exception {
        var tx = spawnTestTransaction2();
        var tx2 = ContractCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx2.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setContractCreateInstance(ContractCreateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(ContractCreateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ContractDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ContractDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private ContractDeleteTransaction spawnTestTransaction() {
        return new ContractDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContractId(ContractId.fromString("0.0.5007"))
            .setTransferAccountId(new AccountId(9))
            .setTransferContractId(ContractId.fromString("0.0.5008"))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ContractDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setContractDeleteInstance(ContractDeleteTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(ContractDeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractExecuteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ContractCallTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ContractExecuteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private ContractExecuteTransaction spawnTestTransaction() {
        return new ContractExecuteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContractId(ContractId.fromString("0.0.5007"))
            .setGas(10)
            .setPayableAmount(Hbar.fromTinybars(1000))
            .setFunctionParameters(ByteString.copyFrom(new byte[]{24, 43, 11}))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ContractExecuteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setContractCall(ContractCallTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(ContractExecuteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractFunctionParametersTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.lang.reflect.Array;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ContractFunctionParametersTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @SuppressWarnings("unused")
    private static List<Arguments> int256Arguments() {
        return List.of(
            Arguments.of(0, "0000000000000000000000000000000000000000000000000000000000000000"),
            Arguments.of(2, "0000000000000000000000000000000000000000000000000000000000000002"),
            Arguments.of(255, "00000000000000000000000000000000000000000000000000000000000000ff"),
            Arguments.of(4095, "0000000000000000000000000000000000000000000000000000000000000fff"),
            Arguments.of(127 << 24, "000000000000000000000000000000000000000000000000000000007f000000"),
            Arguments.of(2047 << 20, "000000000000000000000000000000000000000000000000000000007ff00000"),
            // deadbeef as an integer literal is negative
            Arguments.of(0xdeadbeefL, "00000000000000000000000000000000000000000000000000000000deadbeef"),
            Arguments.of(-1, "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
            Arguments.of(-2, "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe"),
            Arguments.of(-256, "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00"),
            Arguments.of(-4096, "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000"),
            Arguments.of(255 << 24, "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000"),
            Arguments.of(4095 << 20, "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000"),
            Arguments.of(0xdeadbeef, "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffdeadbeef")
        );
    }

    @SuppressWarnings("unused")
    private static List<Arguments> uInt256Arguments() {
        return List.of(
            Arguments.of(0, "0000000000000000000000000000000000000000000000000000000000000000", 8),
            Arguments.of(2, "0000000000000000000000000000000000000000000000000000000000000002", 8),
            Arguments.of(255, "00000000000000000000000000000000000000000000000000000000000000ff", 8),
            Arguments.of(4095, "0000000000000000000000000000000000000000000000000000000000000fff", 32),
            Arguments.of(127 << 24, "000000000000000000000000000000000000000000000000000000007f000000", 32),
            Arguments.of(2047 << 20, "000000000000000000000000000000000000000000000000000000007ff00000", 32),
            // deadbeef as an integer literal is negative
            Arguments.of(0xdeadbeef, "00000000000000000000000000000000000000000000000000000000deadbeef", 32),
            Arguments.of(-1, "000000000000000000000000000000000000000000000000ffffffffffffffff", 64),
            Arguments.of(-2, "000000000000000000000000000000000000000000000000fffffffffffffffe", 64),
            Arguments.of(-256, "000000000000000000000000000000000000000000000000ffffffffffffff00", 64),
            Arguments.of(-4096, "000000000000000000000000000000000000000000000000fffffffffffff000", 64),
            Arguments.of(255 << 24, "000000000000000000000000000000000000000000000000ffffffffff000000", 64),
            Arguments.of(4095 << 20, "000000000000000000000000000000000000000000000000fffffffffff00000", 64),
            Arguments.of(0xdeadbeefL, "00000000000000000000000000000000000000000000000000000000deadbeef", 64)
        );
    }

    @Test
    @DisplayName("encodes int types correctly")
    void intTypes() {
        ContractFunctionParameters params = new ContractFunctionParameters()
            .addUint8((byte) 0x1)
            .addInt8((byte) -0x2)
            .addUint32(0x3)
            .addInt32(-0x4)
            .addUint64(0x4)
            .addInt64(-0x5)
            .addUint256(BigInteger.valueOf(0x6))
            .addInt256(BigInteger.valueOf(-0x7))
            .addUint8Array(new byte[]{(byte) 0x1, (byte) 0x2, (byte) 0x3, (byte) 0x4})
            .addInt8Array(new byte[]{(byte) -0x5, (byte) 0x6, (byte) 0x7, (byte) -0x8})
            .addUint32Array(new int[]{0x9, 0xA, 0xB, 0xC})
            .addInt32Array(new int[]{-0xD, 0xE, 0xF, -0x10})
            .addUint64Array(new long[]{0x11, 0x12, 0x13, 0x14})
            .addInt64Array(new long[]{-0x15, 0x16, 0x17, -0x18})
            .addUint256Array(new BigInteger[]{BigInteger.valueOf(0x19)})
            .addInt256Array(new BigInteger[]{BigInteger.valueOf(-0x1A)});

        assertThat(
            "11bcd903" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe" +
                "0000000000000000000000000000000000000000000000000000000000000003" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb" +
                "0000000000000000000000000000000000000000000000000000000000000006" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9" +
                "0000000000000000000000000000000000000000000000000000000000000200" +
                "00000000000000000000000000000000000000000000000000000000000002a0" +
                "0000000000000000000000000000000000000000000000000000000000000340" +
                "00000000000000000000000000000000000000000000000000000000000003e0" +
                "0000000000000000000000000000000000000000000000000000000000000480" +
                "0000000000000000000000000000000000000000000000000000000000000520" +
                "00000000000000000000000000000000000000000000000000000000000005c0" +
                "0000000000000000000000000000000000000000000000000000000000000600" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "0000000000000000000000000000000000000000000000000000000000000002" +
                "0000000000000000000000000000000000000000000000000000000000000003" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb" +
                "0000000000000000000000000000000000000000000000000000000000000006" +
                "0000000000000000000000000000000000000000000000000000000000000007" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "0000000000000000000000000000000000000000000000000000000000000009" +
                "000000000000000000000000000000000000000000000000000000000000000a" +
                "000000000000000000000000000000000000000000000000000000000000000b" +
                "000000000000000000000000000000000000000000000000000000000000000c" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3" +
                "000000000000000000000000000000000000000000000000000000000000000e" +
                "000000000000000000000000000000000000000000000000000000000000000f" +
                "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "0000000000000000000000000000000000000000000000000000000000000011" +
                "0000000000000000000000000000000000000000000000000000000000000012" +
                "0000000000000000000000000000000000000000000000000000000000000013" +
                "0000000000000000000000000000000000000000000000000000000000000014" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeb" +
                "0000000000000000000000000000000000000000000000000000000000000016" +
                "0000000000000000000000000000000000000000000000000000000000000017" +
                "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "0000000000000000000000000000000000000000000000000000000000000019" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("uint256 chops off sign bit if length is 256 bits")
    void uint256BitLength() {
        var params = new ContractFunctionParameters()
            .addUint256(BigInteger.valueOf(2).pow(255));

        assertThat(
            "2fbebd38" +
                "8000000000000000000000000000000000000000000000000000000000000000"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("uint256 errors if less than 0")
    void uint256Errors() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            new ContractFunctionParameters()
                .addUint256(BigInteger.valueOf(-0x1));
        });

        /*
        assertThrows(IllegalArgumentException.class, () -> {
            new ContractFunctionParameters()
                .addUint256(BigInteger.valueOf(2).pow(256));
        });
         */
    }

    @Test
    @DisplayName("encodes addresses correctly")
    void addresses() {
        var params = new ContractFunctionParameters()
            .addAddress("1122334455667788990011223344556677889900")
            .addAddress("0x1122334455667788990011223344556677889900")
            .addAddressArray(new String[]{"1122334455667788990011223344556677889900", "1122334455667788990011223344556677889900"});

        assertThat(
            "7d48c86d" +
                "0000000000000000000000001122334455667788990011223344556677889900" +
                "0000000000000000000000001122334455667788990011223344556677889900" +
                "0000000000000000000000000000000000000000000000000000000000000060" +
                "0000000000000000000000000000000000000000000000000000000000000002" +
                "0000000000000000000000001122334455667788990011223344556677889900" +
                "0000000000000000000000001122334455667788990011223344556677889900"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("encodes functions correctly")
    void addressesError() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            new ContractFunctionParameters()
                .addAddress("112233445566778899001122334455667788990011");
        });
    }

    @Test
    @DisplayName("encodes functions correctly")
    void functions() {
        var params = new ContractFunctionParameters()
            .addFunction("1122334455667788990011223344556677889900", new byte[]{1, 2, 3, 4})
            .addFunction("0x1122334455667788990011223344556677889900", new ContractFunctionSelector("randomFunction").addBool());

        assertThat(
            "c99c40cd" +
                "1122334455667788990011223344556677889900010203040000000000000000" +
                "112233445566778899001122334455667788990063441d820000000000000000"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("encodes functions correctly")
    void functionsError() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            new ContractFunctionParameters()
                .addFunction("112233445566778899001122334455667788990011", new byte[]{1, 2, 3, 4});
        });

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            new ContractFunctionParameters()
                .addFunction("1122334455667788990011223344556677889900", new byte[]{1, 2, 3, 4, 5});
        });
    }

    @Test
    @DisplayName("encodes bytes32 correctly")
    void bytes() {
        var params = new ContractFunctionParameters()
            .addBytes32(new byte[]{
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32
            });

        assertThat(
            "11e814c1" +
                "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("fails to encode bytes32 if length too long")
    void bytesError() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
                new ContractFunctionParameters()
                    .addBytes32(new byte[]{
                        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
                        33
                    });
            }
        );
    }

    @Test
    @DisplayName("encodes boolean correctly")
    void bool() {
        var params = new ContractFunctionParameters()
            .addBool(true)
            .addBool(false);

        assertThat(
            "b3cedfcf" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "0000000000000000000000000000000000000000000000000000000000000000"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("encodes dynamic params correctly")
    void dynamicParamsEncoding() {
        ByteString paramsStringArg = new ContractFunctionParameters()
            .addString("Hello, world!")
            .toBytes("set_message");

        ByteString paramsBytesArg = new ContractFunctionParameters()
            .addBytes("Hello, world!".getBytes(StandardCharsets.UTF_8))
            .toBytes("set_message");

        String paramsStringArgHex = Hex.toHexString(paramsStringArg.toByteArray());
        String paramsBytesArgHex = Hex.toHexString(paramsBytesArg.toByteArray());

        assertThat(
            "2e982602"
                + "0000000000000000000000000000000000000000000000000000000000000020"
                + "000000000000000000000000000000000000000000000000000000000000000d"
                + "48656c6c6f2c20776f726c642100000000000000000000000000000000000000"
        ).isEqualTo(paramsStringArgHex);

        // signature should encode differently but the contents are identical
        assertThat(
            "010473a7"
                + "0000000000000000000000000000000000000000000000000000000000000020"
                + "000000000000000000000000000000000000000000000000000000000000000d"
                + "48656c6c6f2c20776f726c642100000000000000000000000000000000000000"
        ).isEqualTo(paramsBytesArgHex);
    }

    @Test
    @DisplayName("encodes static params correctly")
    void staticParamsEncoding() {
        ContractFunctionParameters params = new ContractFunctionParameters()
            .addInt32(0x11223344)
            .addInt32(-65536)
            .addUint64(-65536)
            .addAddress("00112233445566778899aabbccddeeff00112233");

        String paramsHex = Hex.toHexString(params.toBytes(null).toByteArray());

        assertThat(
            "0000000000000000000000000000000000000000000000000000000011223344"
                // sign-extended
                + "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000"
                // zero-padded
                + "000000000000000000000000000000000000000000000000ffffffffffff0000"
                + "00000000000000000000000000112233445566778899aabbccddeeff00112233"
        ).isEqualTo(paramsHex);
    }

    @Test
    @DisplayName("encodes mixed static and dynamic params correctly")
    void mixedParamsEncoding() {
        ContractFunctionParameters params = new ContractFunctionParameters()
            .addInt256(BigInteger.valueOf(0xdeadbeef).shiftLeft(8))
            .addString("Hello, world!")
            .addBytes(new byte[]{-1, -18, 63, 127})
            .addBool(true)
            .addUint8Array(new byte[]{-1, 127});

        String paramsHex = Hex.toHexString(params.toBytes("foo").toByteArray());

        assertThat(
            "6a5bb8f2"
                + "ffffffffffffffffffffffffffffffffffffffffffffffffffffffdeadbeef00"
                + "00000000000000000000000000000000000000000000000000000000000000a0"
                + "00000000000000000000000000000000000000000000000000000000000000e0"
                + "0000000000000000000000000000000000000000000000000000000000000001"
                + "0000000000000000000000000000000000000000000000000000000000000120"
                + "000000000000000000000000000000000000000000000000000000000000000d"
                + "48656c6c6f2c20776f726c642100000000000000000000000000000000000000"
                + "0000000000000000000000000000000000000000000000000000000000000004"
                + "ffee3f7f00000000000000000000000000000000000000000000000000000000"
                + "0000000000000000000000000000000000000000000000000000000000000002"
                + "00000000000000000000000000000000000000000000000000000000000000ff"
                + "000000000000000000000000000000000000000000000000000000000000007f"
        ).isEqualTo(paramsHex);
    }

    @Test
    @DisplayName("encodes array types correctly")
    void arrayTypesEncoding() {
        ContractFunctionParameters params = new ContractFunctionParameters()
            .addStringArray(new String[]{"hello", ",", "world!"})
            .addInt32Array(new int[]{0x88, 0x99, 0xAA, 0xBB})
            .addInt256Array(new BigInteger[]{BigInteger.valueOf(0x1111)});

        assertThat(
            "025838fc" +
                "0000000000000000000000000000000000000000000000000000000000000060" +
                "00000000000000000000000000000000000000000000000000000000000001a0" +
                "0000000000000000000000000000000000000000000000000000000000000240" +
                "0000000000000000000000000000000000000000000000000000000000000003" +
                "0000000000000000000000000000000000000000000000000000000000000060" +
                "00000000000000000000000000000000000000000000000000000000000000a0" +
                "00000000000000000000000000000000000000000000000000000000000000e0" +
                "0000000000000000000000000000000000000000000000000000000000000005" +
                "68656c6c6f000000000000000000000000000000000000000000000000000000" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "2c00000000000000000000000000000000000000000000000000000000000000" +
                "0000000000000000000000000000000000000000000000000000000000000006" +
                "776f726c64210000000000000000000000000000000000000000000000000000" +
                "0000000000000000000000000000000000000000000000000000000000000004" +
                "0000000000000000000000000000000000000000000000000000000000000088" +
                "0000000000000000000000000000000000000000000000000000000000000099" +
                "00000000000000000000000000000000000000000000000000000000000000aa" +
                "00000000000000000000000000000000000000000000000000000000000000bb" +
                "0000000000000000000000000000000000000000000000000000000000000001" +
                "0000000000000000000000000000000000000000000000000000000000001111"
        ).isEqualTo(Hex.toHexString(params.toBytes("foo").toByteArray()));
    }

    @Test
    @DisplayName("bytes32[] encodes correctly")
    void fixedBytesArrayEncoding() {
        // each string should be padded to 32 bytes and have no length prefix

        ContractFunctionParameters params = new ContractFunctionParameters()
            .addBytes32Array(new byte[][]{
                "Hello".getBytes(StandardCharsets.UTF_8),
                ",".getBytes(StandardCharsets.UTF_8),
                "world!".getBytes(StandardCharsets.UTF_8)
            });

        assertThat(
            "0000000000000000000000000000000000000000000000000000000000000020" +
                "0000000000000000000000000000000000000000000000000000000000000003" + // length of array
                "48656c6c6f000000000000000000000000000000000000000000000000000000" + // "Hello" UTF-8 encoded
                "2c00000000000000000000000000000000000000000000000000000000000000" + // "," UTF-8 encoded
                "776f726c64210000000000000000000000000000000000000000000000000000" // "world!" UTF-8 encoded
        ).isEqualTo(Hex.toHexString(params.toBytes(null).toByteArray()));
    }

    @Test
    @DisplayName("bytes[] encodes correctly")
    void dynBytesArrayEncoding() {
        // result should be the exact same as the strings test below
        ContractFunctionParameters params = new ContractFunctionParameters()
            .addBytesArray(new byte[][]{
                "Hello".getBytes(StandardCharsets.UTF_8),
                ",".getBytes(StandardCharsets.UTF_8),
                "world!".getBytes(StandardCharsets.UTF_8)
            });

        assertThat(
            "0000000000000000000000000000000000000000000000000000000000000020" + // offset to array
                "0000000000000000000000000000000000000000000000000000000000000003" + // length of array
                "0000000000000000000000000000000000000000000000000000000000000060" + // first element offset, relative to beginning of this list (after length)
                "00000000000000000000000000000000000000000000000000000000000000a0" + // second element offset
                "00000000000000000000000000000000000000000000000000000000000000e0" + // third element offset
                "0000000000000000000000000000000000000000000000000000000000000005" + // "Hello".length
                "48656c6c6f000000000000000000000000000000000000000000000000000000" + // "Hello" UTF-8 encoded
                "0000000000000000000000000000000000000000000000000000000000000001" + // ",".length
                "2c00000000000000000000000000000000000000000000000000000000000000" + // "," UTF-8 encoded
                "0000000000000000000000000000000000000000000000000000000000000006" + // "world!".length
                "776f726c64210000000000000000000000000000000000000000000000000000" // "world!" UTF-8 encoded
        ).isEqualTo(Hex.toHexString(params.toBytes(null).toByteArray()));
    }

    @Test
    @DisplayName("issue 376: string[] encodes correctly")
    void stringArrayEncoding() {
        ContractFunctionParameters params = new ContractFunctionParameters()
            .addStringArray(new String[]{"Hello", ",", "world!"});

        assertThat(
            "0000000000000000000000000000000000000000000000000000000000000020" + // offset to array
                "0000000000000000000000000000000000000000000000000000000000000003" + // length of array
                "0000000000000000000000000000000000000000000000000000000000000060" + // first element offset, relative to beginning of this list (after length)
                "00000000000000000000000000000000000000000000000000000000000000a0" + // second element offset
                "00000000000000000000000000000000000000000000000000000000000000e0" + // third element offset
                "0000000000000000000000000000000000000000000000000000000000000005" + // "Hello".length
                "48656c6c6f000000000000000000000000000000000000000000000000000000" + // "Hello" UTF-8 encoded
                "0000000000000000000000000000000000000000000000000000000000000001" + // ",".length
                "2c00000000000000000000000000000000000000000000000000000000000000" + // "," UTF-8 encoded
                "0000000000000000000000000000000000000000000000000000000000000006" + // "world!".length
                "776f726c64210000000000000000000000000000000000000000000000000000" // "world!" UTF-8 encoded
        ).isEqualTo(Hex.toHexString(params.toBytes(null).toByteArray()));
    }

    @Test
    @Disabled
    @DisplayName("BigInteger checks")
    void bigIntChecks() {
        ContractFunctionParameters params = new ContractFunctionParameters();

        // allowed values for BigInteger
        params.addInt256(BigInteger.ONE.shiftLeft(254));
        params.addInt256(BigInteger.ONE.negate().shiftLeft(255));

        String rangeErr = "BigInteger out of range for Solidity integers";

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> params.addInt256(BigInteger.ONE.shiftLeft(255))
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo(rangeErr));

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> params.addInt256(BigInteger.ONE.negate().shiftLeft(256))
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo(rangeErr));
    }

    @Test
    @DisplayName("address param checks")
    void addressParamChecks() {
        ContractFunctionParameters params = new ContractFunctionParameters();

        String lenErr = "Solidity addresses must be 40 hex chars";

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> params.addAddress("")
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo(lenErr));

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> params.addAddress("aabbccdd")
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo(lenErr));

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> params.addAddress("00112233445566778899aabbccddeeff0011223344")
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo(lenErr));

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> params.addAddress("gghhii--__zz66778899aabbccddeeff00112233")
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo("failed to decode Solidity address as hex"));
    }

    @ParameterizedTest
    @DisplayName("int256() encodes correctly")
    @MethodSource("int256Arguments")
    void int256EncodesCorrectly(long val, String hexString) {
        assertThat(hexString).isEqualTo(
            Hex.toHexString(ContractFunctionParameters.int256(val, 64).toByteArray())
        );
    }

    @ParameterizedTest
    @DisplayName("uint256() encodes correctly")
    @MethodSource("uInt256Arguments")
    void uInt256EncodesCorrectly(long val, String hexString, int bitWidth) {
        assertThat(hexString).isEqualTo(
            Hex.toHexString(ContractFunctionParameters.uint256(val, bitWidth).toByteArray())
        );
    }

    @Test
    void intSizesEncodeCorrectly() throws Exception {
        List<String> snapshotStrings = new ArrayList<>();
        for (int n = 8; n <= 256; n+= 8) {
            var bitWidth = n;

            var argType = ((Supplier<Class<?>>)() -> {
                if (bitWidth == 8) {
                    return byte.class;
                } else if (bitWidth <= 32) {
                    return int.class;
                } else if (bitWidth <= 64) {
                    return long.class;
                } else {
                    return BigInteger.class;
                }
            }).get();

            var argVal = ((Supplier<Object>)() -> {
                if (bitWidth == 8) {
                    return (byte) (1 << (bitWidth - 1));
                } else if (bitWidth <= 32) {
                    return (int) (1 << (bitWidth - 1));
                } else if (bitWidth <= 64) {
                    return (long) (1L << (bitWidth - 1));
                } else {
                    return BigInteger.ONE.shiftLeft(bitWidth - 1);
                }
            }).get();

            var argArrayVal = Array.newInstance(argType, 2);
            Array.set(argArrayVal, 0, argVal);
            Array.set(argArrayVal, 1, argVal);
            var argArrayType = argArrayVal.getClass();

            var cl = ContractFunctionParameters.class;
            var addIntMethod = cl.getMethod("addInt" + n, argType);
            var addUintMethod = cl.getMethod("addUint" + n, argType);
            var addIntArrayMethod = cl.getMethod("addInt" + n + "Array", argArrayType);
            var addUintArrayMethod = cl.getMethod("addUint" + n + "Array", argArrayType);

            var params = new ContractFunctionParameters();
            addIntMethod.invoke(params, argVal);
            addUintMethod.invoke(params, argVal);
            addIntArrayMethod.invoke(params, argArrayVal);
            addUintArrayMethod.invoke(params, argArrayVal);

            snapshotStrings.add("bitWidth = " + bitWidth + ": " + Hex.toHexString(params.toBytes(null).toByteArray()));
        }
        SnapshotMatcher.expect(snapshotStrings.toArray()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractFunctionResultTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigInteger;

import static org.assertj.core.api.Assertions.assertThat;

public class ContractFunctionResultTest {
    static final String CALL_RESULT_HEX = "00000000000000000000000000000000000000000000000000000000ffffffff"
        + "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        + "00000000000000000000000011223344556677889900aabbccddeeff00112233"
        + "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        + "00000000000000000000000000000000000000000000000000000000000000c0"
        + "0000000000000000000000000000000000000000000000000000000000000100"
        + "000000000000000000000000000000000000000000000000000000000000000d"
        + "48656c6c6f2c20776f726c642100000000000000000000000000000000000000"
        + "0000000000000000000000000000000000000000000000000000000000000014"
        + "48656c6c6f2c20776f726c642c20616761696e21000000000000000000000000";

    private static final String STRING_ARRAY_RESULT_HEX = "0000000000000000000000000000000000000000000000000000000000000020"
        + "0000000000000000000000000000000000000000000000000000000000000002"
        + "0000000000000000000000000000000000000000000000000000000000000040"
        + "0000000000000000000000000000000000000000000000000000000000000080"
        + "000000000000000000000000000000000000000000000000000000000000000C"
        + "72616E646F6D2062797465730000000000000000000000000000000000000000"
        + "000000000000000000000000000000000000000000000000000000000000000C"
        + "72616E646F6D2062797465730000000000000000000000000000000000000000";

    private static final byte[] callResult = Hex.decode(CALL_RESULT_HEX);
    private static final byte[] stringArrayCallResult = Hex.decode(STRING_ARRAY_RESULT_HEX);

    @Test
    @DisplayName("provides results correctly")
    void providesResultsCorrectly() {
        var result = new ContractFunctionResult(
            com.hedera.hashgraph.sdk.proto.ContractFunctionResult.newBuilder()
                .setContractID(ContractId.fromString("1.2.3").toProtobuf())
                .setContractCallResult(ByteString.copyFrom(callResult))
                .setEvmAddress(BytesValue.newBuilder().setValue(ByteString.copyFrom(Hex.decode("98329e006610472e6B372C080833f6D79ED833cf"))).build())
                // .addStateChanges(
                //     new ContractStateChange(
                //         ContractId.fromString("1.2.3"),
                //         Collections.singletonList(
                //             new StorageChange(
                //                 BigInteger.valueOf(555),
                //                 BigInteger.valueOf(666),
                //                 BigInteger.valueOf(777)
                //             )
                //         )
                //     ).toProtobuf())
                .setSenderId(AccountId.fromString("1.2.3").toProtobuf())
                .addContractNonces(
                    new ContractNonceInfo(ContractId.fromString("1.2.3"), 10L)
                        .toProtobuf())
        );

        // interpretation varies based on width
        assertThat(result.getBool(0)).isTrue();
        assertThat(result.getInt32(0)).isEqualTo(-1);
        assertThat(result.getInt64(0)).isEqualTo((1L << 32) - 1);
        assertThat(result.getInt256(0)).isEqualTo(BigInteger.ONE.shiftLeft(32).subtract(BigInteger.ONE));

        assertThat(result.getInt256(1)).isEqualTo(BigInteger.ONE.shiftLeft(255).subtract(BigInteger.ONE));

        assertThat(result.getAddress(2)).isEqualTo("11223344556677889900aabbccddeeff00112233");

        // unsigned integers (where applicable)
        assertThat(result.getUint32(3)).isEqualTo(-1);
        assertThat(result.getUint64(3)).isEqualTo(-1L);
        // BigInteger can represent the full range and so should be 2^256 - 1
        assertThat(result.getUint256(3)).isEqualTo(BigInteger.ONE.shiftLeft(256).subtract(BigInteger.ONE));

        assertThat(result.getString(4)).isEqualTo("Hello, world!");
        assertThat(result.getString(5)).isEqualTo("Hello, world, again!");

        assertThat(result.senderAccountId).isEqualTo(AccountId.fromString("1.2.3"));

        assertThat(result.contractId).isEqualTo(ContractId.fromString("1.2.3"));
        assertThat(result.evmAddress).isEqualTo(ContractId.fromEvmAddress(1, 2, "98329e006610472e6B372C080833f6D79ED833cf"));
        // assertThat(result.stateChanges.size()).isEqualTo(1);
        // ContractStateChange resultStateChange = result.stateChanges.get(0);
        // assertThat(resultStateChange.contractId).isEqualTo(ContractId.fromString("1.2.3"));
        // assertThat(resultStateChange.storageChanges.size()).isEqualTo(1);
        // StorageChange resultStorageChange = resultStateChange.storageChanges.get(0);
        // assertThat(resultStorageChange.slot).isEqualTo(BigInteger.valueOf(555));
        // assertThat(resultStorageChange.valueRead).isEqualTo(BigInteger.valueOf(666));
        // assertThat(resultStorageChange.valueWritten).isEqualTo(BigInteger.valueOf(777));
        assertThat(result.contractNonces).containsOnly(new ContractNonceInfo(ContractId.fromString("1.2.3"), 10L));
    }

    @Test
    @DisplayName("can get string array result")
    void canGetStringArrayResult() {
        var result = new ContractFunctionResult(
            com.hedera.hashgraph.sdk.proto.ContractFunctionResult.newBuilder()
                .setContractCallResult(ByteString.copyFrom(stringArrayCallResult))
        );

        var strings = result.getStringArray(0);
        assertThat(strings.get(0)).isEqualTo("random bytes");
        assertThat(strings.get(1)).isEqualTo("random bytes");
    }

    @Test
    @DisplayName("Can to/from bytes with state changes")
    void canToFromBytesStateChanges() {

    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractFunctionSelectorTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.assertj.core.api.Assertions.assertThatNoException;

public class ContractFunctionSelectorTest {
    @Test
    @DisplayName("Can add all types")
    void selector() {
        var signature = new ContractFunctionSelector("testFunction")
            .addAddress()
            .addAddressArray()
            .addBool()
            .addBytes()
            .addBytes32()
            .addBytes32Array()
            .addBytesArray()
            .addFunction()
            .addInt8()
            .addInt8Array()
            .addInt32()
            .addInt32Array()
            .addInt64()
            .addInt64Array()
            .addInt256()
            .addInt256Array()
            .addUint8()
            .addUint8Array()
            .addUint32()
            .addUint32Array()
            .addUint64()
            .addUint64Array()
            .addUint256()
            .addUint256Array()
            .addString()
            .addStringArray()
            .finish();

        assertThat(Hex.toHexString(signature)).isEqualTo("4438e4ce");
    }

    @Test
    @DisplayName("Throws in adding after finished")
    void selectorError() {
        var signature = new ContractFunctionSelector("testFunction")
            .addAddress();
        signature.finish();

        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(signature::addStringArray);
        assertThatNoException().isThrownBy(signature::finish);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;


class ContractIdTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromString() {
        SnapshotMatcher.expect(ContractId.fromString("0.0.5005").toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddress() {
        SnapshotMatcher.expect(ContractId.fromSolidityAddress("000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddressWith0x() {
        SnapshotMatcher.expect(ContractId.fromSolidityAddress("0x000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void fromEvmAddress() {
        SnapshotMatcher.expect(ContractId.fromEvmAddress(1, 2, "98329e006610472e6B372C080833f6D79ED833cf").toString()).toMatchSnapshot();
    }

    @Test
    void fromEvmAddressWith0x() {
        SnapshotMatcher.expect(ContractId.fromEvmAddress(1, 2, "0x98329e006610472e6B372C080833f6D79ED833cf").toString()).toMatchSnapshot();
    }

    @Test
    void fromStringWithEvmAddress() {
        SnapshotMatcher.expect(ContractId.fromString("1.2.98329e006610472e6B372C080833f6D79ED833cf").toString()).toMatchSnapshot();
    }

    @Test
    void toFromBytes() throws InvalidProtocolBufferException {
        ContractId a = ContractId.fromString("1.2.3");
        assertThat(ContractId.fromBytes(a.toBytes())).isEqualTo(a);
        ContractId b = ContractId.fromEvmAddress(1, 2, "0x98329e006610472e6B372C080833f6D79ED833cf");
        assertThat(ContractId.fromBytes(b.toBytes())).isEqualTo(b);
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(Hex.toHexString(new ContractId(5005).toBytes())).toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(ContractId.fromBytes(new ContractId(5005).toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void toSolidityAddress() {
        SnapshotMatcher.expect(new ContractId(5005).toSolidityAddress()).toMatchSnapshot();
    }

    @Test
    void toSolidityAddress2() {
        SnapshotMatcher.expect(ContractId.fromEvmAddress(1, 2, "0x98329e006610472e6B372C080833f6D79ED833cf").toSolidityAddress()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractInfoQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class ContractInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new ContractInfoQuery()
            .setContractId(ContractId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractInfoTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractGetInfoResponse;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;


public class ContractInfoTest {
    private final ContractGetInfoResponse.ContractInfo info =
        ContractGetInfoResponse.ContractInfo.newBuilder()
            .setContractID(new ContractId(1).toProtobuf())
            .setAccountID(new AccountId(2).toProtobuf())
            .setContractAccountID("3")
            .setExpirationTime(InstantConverter.toProtobuf(Instant.ofEpochMilli(4)))
            .setAutoRenewPeriod(DurationConverter.toProtobuf(Duration.ofDays(5)))
            .setStorage(6)
            .setMemo("7")
            .setBalance(8)
            .setLedgerId(LedgerId.TESTNET.toByteString())
            .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(ContractInfo.fromProtobuf(info).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(ContractInfo.fromProtobuf(info).toProtobuf())
            .toMatchSnapshot();
    }

    @Test
    void toBytes() {
        SnapshotMatcher.expect(Hex.toHexString(ContractInfo.fromProtobuf(info).toBytes()))
            .toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(ContractInfo.fromBytes(info.toByteArray()).toString())
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractLogInfoTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ContractLoginfo;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;

public class ContractLogInfoTest {
    private static final ContractLoginfo info = ContractLoginfo.newBuilder()
        .setContractID(new ContractId(10).toProtobuf())
        .setBloom(ByteString.copyFrom("bloom", StandardCharsets.UTF_8))
        .addTopic(ByteString.copyFrom("bloom", StandardCharsets.UTF_8))
        .setData(ByteString.copyFrom("data", StandardCharsets.UTF_8))
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(ContractLogInfo.fromProtobuf(info).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(ContractLogInfo.fromProtobuf(info).toProtobuf().toString())
            .toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(ContractLogInfo.fromBytes(info.toByteArray()).toString())
            .toMatchSnapshot();
    }

    @Test
    void toBytes() {
        SnapshotMatcher.expect(Hex.toHexString(ContractLogInfo.fromProtobuf(info).toBytes()))
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractNonceInfoTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class ContractNonceInfoTest {
    private final com.hedera.hashgraph.sdk.proto.ContractNonceInfo info =
        com.hedera.hashgraph.sdk.proto.ContractNonceInfo.newBuilder()
            .setContractId(new ContractId(1).toProtobuf())
            .setNonce(2)
            .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(ContractNonceInfo.fromProtobuf(info).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(ContractNonceInfo.fromProtobuf(info).toProtobuf())
            .toMatchSnapshot();
    }

    @Test
    void toBytes() {
        SnapshotMatcher.expect(Hex.toHexString(ContractNonceInfo.fromProtobuf(info).toBytes()))
            .toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(ContractNonceInfo.fromBytes(info.toByteArray()).toString())
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ContractUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ContractUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ContractUpdateTransactionTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    @Test
    void shouldSerialize2() {
        SnapshotMatcher.expect(spawnTestTransaction2()
            .toString()
        ).toMatchSnapshot();
    }

    private ContractUpdateTransaction spawnTestTransaction() {
        return new ContractUpdateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContractId(ContractId.fromString("0.0.5007"))
            .setAdminKey(privateKey)
            .setMaxAutomaticTokenAssociations(101)
            .setAutoRenewPeriod(Duration.ofDays(1))
            .setContractMemo("3")
            .setStakedAccountId(AccountId.fromString("0.0.3"))
            .setExpirationTime(Instant.ofEpochMilli(4))
            .setProxyAccountId(new AccountId(4))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setAutoRenewAccountId(new AccountId(30))
            .freeze()
            .sign(privateKey);
    }

    private ContractUpdateTransaction spawnTestTransaction2() {
        return new ContractUpdateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContractId(ContractId.fromString("0.0.5007"))
            .setAdminKey(privateKey)
            .setMaxAutomaticTokenAssociations(101)
            .setAutoRenewPeriod(Duration.ofDays(1))
            .setContractMemo("3")
            .setStakedNodeId(4L)
            .setExpirationTime(Instant.ofEpochMilli(4))
            .setProxyAccountId(new AccountId(4))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setAutoRenewAccountId(new AccountId(30))
            .freeze()
            .sign(privateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ContractUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytes2() throws Exception {
        var tx = spawnTestTransaction2();
        var tx2 = ContractUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setContractUpdateInstance(ContractUpdateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(ContractUpdateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/CryptoTransferTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.CryptoTransferTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionList;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class CryptoTransferTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TransferTransaction spawnTestTransaction() {
        return new TransferTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .addHbarTransfer(AccountId.fromString("0.0.5008"), Hbar.fromTinybars(400))
            .addHbarTransfer(AccountId.fromString("0.0.5006"), Hbar.fromTinybars(800).negated())
            .addHbarTransfer(AccountId.fromString("0.0.5007"), Hbar.fromTinybars(400))
            .addTokenTransfer(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5008"), 400)
            .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5006"), -800, 3)
            .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5007"), 400, 3)
            .addTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5008"), 1)
            .addTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5006"), -1)
            .addNftTransfer(TokenId.fromString("0.0.3").nft(2), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5007"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(1), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5007"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(3), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5006"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(4), AccountId.fromString("0.0.5007"), AccountId.fromString("0.0.5006"))
            .addNftTransfer(TokenId.fromString("0.0.2").nft(4), AccountId.fromString("0.0.5007"), AccountId.fromString("0.0.5006"))
            .setHbarTransferApproval(AccountId.fromString("0.0.5007"), true)
            .setTokenTransferApproval(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5006"), true)
            .setNftTransferApproval(new NftId(TokenId.fromString("0.0.4"), 4), true)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    private TransferTransaction spawnModifiedTestTransaction() {
        return new TransferTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .addHbarTransfer(AccountId.fromString("0.0.5008"), Hbar.fromTinybars(400))
            .addHbarTransfer(AccountId.fromString("0.0.5006"), Hbar.fromTinybars(800).negated())
            .addHbarTransfer(AccountId.fromString("0.0.5007"), Hbar.fromTinybars(400))
            .addTokenTransfer(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5008"), 400)
            .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5006"), -800, 3)
            .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5007"), 400, 3)
            .addTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5008"), 1)
            .addTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5006"), -1)
            .addNftTransfer(TokenId.fromString("0.0.3").nft(2), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5007"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(1), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5007"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(3), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5006"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(4), AccountId.fromString("0.0.5007"), AccountId.fromString("0.0.5006"))
            .addNftTransfer(TokenId.fromString("0.0.2").nft(4), AccountId.fromString("0.0.5007"), AccountId.fromString("0.0.5006"))
            .setHbarTransferApproval(AccountId.fromString("0.0.5007"), true)
            // !!! .setTokenTransferApproval(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5006"), true) !!!
            .setNftTransferApproval(new NftId(TokenId.fromString("0.0.4"), 4), true)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TransferTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void decimalsMustBeConsistent() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            new TransferTransaction()
                .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.8"), 100, 2)
                .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.7"), -100, 3);
        });
    }

    @Test
    void canGetDecimals() {
        var tx = new TransferTransaction();
        assertThat(tx.getTokenIdDecimals().get(TokenId.fromString("0.0.5"))).isNull();
        tx.addTokenTransfer(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.8"), 100);
        assertThat(tx.getTokenIdDecimals().get(TokenId.fromString("0.0.5"))).isNull();
        tx.addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.7"), -100, 5);
        assertThat(tx.getTokenIdDecimals().get(TokenId.fromString("0.0.5"))).isEqualTo(5);
    }

    @Test
    void transactionBodiesMustMatch() throws InvalidProtocolBufferException {
        com.hedera.hashgraph.sdk.proto.Transaction tx1 = TransactionList.parseFrom(spawnTestTransaction().toBytes())
            .getTransactionList(0);
        com.hedera.hashgraph.sdk.proto.Transaction tx2 = TransactionList.parseFrom(spawnModifiedTestTransaction().toBytes())
            .getTransactionList(1);
        var brokenTxList = TransactionList.newBuilder()
            .addTransactionList(tx1)
            .addTransactionList(tx2);
        var brokenTxBytes = brokenTxList.build().toByteArray();
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            Transaction.fromBytes(brokenTxBytes);
        });
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setCryptoTransfer(CryptoTransferTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TransferTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/CustomFeeListTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

public class CustomFeeListTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    static private List<CustomFee> spawnCustomFeeListExample() {
        var returnList = new ArrayList<CustomFee>();
        returnList.add(new CustomFixedFee()
            .setFeeCollectorAccountId(new AccountId(4322))
            .setDenominatingTokenId(new TokenId(483902))
            .setAmount(10)
        );
        returnList.add(new CustomFractionalFee()
            .setFeeCollectorAccountId(new AccountId(389042))
            .setNumerator(3)
            .setDenominator(7)
            .setMin(3)
            .setMax(100)
        );
        returnList.add(new CustomRoyaltyFee()
            .setFeeCollectorAccountId(new AccountId(23423))
            .setNumerator(5)
            .setDenominator(8)
            .setFallbackFee(new CustomFixedFee()
                .setDenominatingTokenId(new TokenId(483902))
                .setAmount(10))
        );
        return returnList;
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalCustomFeeList = spawnCustomFeeListExample();
        byte[] customFee0Bytes = originalCustomFeeList.get(0).toBytes();
        byte[] customFee1Bytes = originalCustomFeeList.get(1).toBytes();
        byte[] customFee2Bytes = originalCustomFeeList.get(2).toBytes();
        var copyCustomFeeList = new ArrayList<CustomFee>();
        copyCustomFeeList.add(CustomFee.fromBytes(customFee0Bytes));
        copyCustomFeeList.add(CustomFee.fromBytes(customFee1Bytes));
        copyCustomFeeList.add(CustomFee.fromBytes(customFee2Bytes));
        assertThat(originalCustomFeeList.toString()).isEqualTo(copyCustomFeeList.toString());
        SnapshotMatcher.expect(originalCustomFeeList.toString()).toMatchSnapshot();
    }

    @Test
    void deepClone() throws Exception {
        var originalCustomFeeList = spawnCustomFeeListExample();
        var copyCustomFeeList = new ArrayList<CustomFee>();
        for (var fee : originalCustomFeeList) {
            copyCustomFeeList.add(fee.deepClone());
        }
        var originalCustomFeeListString = originalCustomFeeList.toString();
        assertThat(originalCustomFeeListString).isEqualTo(copyCustomFeeList.toString());

        // modifying clone doesn't affect original
        ((CustomFixedFee) copyCustomFeeList.get(0)).setDenominatingTokenId(new TokenId(89803));
        assertThat(originalCustomFeeListString).isEqualTo(originalCustomFeeList.toString());

        SnapshotMatcher.expect(originalCustomFeeList.toString()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/CustomFixedFeeTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FixedFee;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class CustomFixedFeeTest {
    private static final boolean allCollectorsAreExempt = true;
    private static final AccountId feeCollectorAccountId = new AccountId(1, 2, 3);
    private static final long amount = 4;
    private static final TokenId tokenId = new TokenId(5, 6, 7);

    private final FixedFee fee = FixedFee.newBuilder()
        .setAmount(amount)
        .setDenominatingTokenId(tokenId.toProtobuf())
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(CustomFixedFee.fromProtobuf(fee).toString()).toMatchSnapshot();
    }

    @Test
    void deepCloneSubclass() {
        var customFixedFee = new CustomFixedFee()
            .setFeeCollectorAccountId(feeCollectorAccountId)
            .setAllCollectorsAreExempt(allCollectorsAreExempt);
        var clonedCustomFixedFee = customFixedFee.deepCloneSubclass();

        assertThat(clonedCustomFixedFee.getFeeCollectorAccountId()).isEqualTo(feeCollectorAccountId);
        assertThat(clonedCustomFixedFee.getAllCollectorsAreExempt()).isEqualTo(allCollectorsAreExempt);
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(CustomFixedFee.fromProtobuf(fee).toProtobuf().toString()).toMatchSnapshot();
    }

    @Test
    void toFixedFeeProtobuf() {
        SnapshotMatcher.expect(CustomFixedFee.fromProtobuf(fee).toFixedFeeProtobuf().toString()).toMatchSnapshot();
    }

    @Test
    void getSetAmount() {
        final var customFixedFee1 = new CustomFixedFee().setAmount(amount);
        final var customFixedFee2 = new CustomFixedFee().setHbarAmount(Hbar.fromTinybars(amount));

        assertThat(customFixedFee1.getAmount()).isEqualTo(amount);
        assertThat(customFixedFee2.getHbarAmount().toTinybars()).isEqualTo(amount);
        assertThat(customFixedFee1.getHbarAmount().toTinybars()).isEqualTo(customFixedFee2.getAmount());
    }

    @Test
    void getSetDenominatingToken() {
        final var customFixedFee = new CustomFixedFee().setDenominatingTokenId(tokenId);
        assertThat(customFixedFee.getDenominatingTokenId()).isEqualTo(tokenId);
    }

    @Test
    void setSentinelValueToken() {
        final var customFixedFee = new CustomFixedFee().setDenominatingTokenToSameToken();
        assertThat(customFixedFee.getDenominatingTokenId()).isEqualTo(new TokenId(0, 0, 0));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/CustomFractionalFeeTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Fraction;
import com.hedera.hashgraph.sdk.proto.FractionalFee;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class CustomFractionalFeeTest {
    private static final boolean allCollectorsAreExempt = true;
    private static final AccountId feeCollectorAccountId = new AccountId(1, 2, 3);
    private static final int numerator = 4;
    private static final int denominator = 5;
    private static final int minAmount = 6;
    private static final int maxAmount = 7;
    private static final FeeAssessmentMethod feeAssessmentMethod = FeeAssessmentMethod.EXCLUSIVE;

    private final FractionalFee fee = FractionalFee.newBuilder()
        .setFractionalAmount(Fraction.newBuilder().setNumerator(numerator).setDenominator(denominator))
        .setMinimumAmount(minAmount)
        .setMaximumAmount(maxAmount)
        .setNetOfTransfers(true)
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(CustomFractionalFee.fromProtobuf(fee).toString()).toMatchSnapshot();
    }

    @Test
    void deepCloneSubclass() {
        var customFractionalFee = new CustomFractionalFee()
            .setFeeCollectorAccountId(feeCollectorAccountId)
            .setAllCollectorsAreExempt(allCollectorsAreExempt);
        var clonedCustomFractionalFee = customFractionalFee.deepCloneSubclass();

        assertThat(clonedCustomFractionalFee.getFeeCollectorAccountId()).isEqualTo(feeCollectorAccountId);
        assertThat(clonedCustomFractionalFee.getAllCollectorsAreExempt()).isEqualTo(allCollectorsAreExempt);
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(CustomFractionalFee.fromProtobuf(fee).toProtobuf().toString()).toMatchSnapshot();
    }

    @Test
    void getSetNumerator() {
        final var customFractionalFee = new CustomFractionalFee().setNumerator(numerator);
        assertThat(customFractionalFee.getNumerator()).isEqualTo(numerator);
    }

    @Test
    void getSetDenominator() {
        final var customFractionalFee = new CustomFractionalFee().setDenominator(denominator);
        assertThat(customFractionalFee.getDenominator()).isEqualTo(denominator);
    }

    @Test
    void getSetMinimumAmount() {
        final var customFractionalFee = new CustomFractionalFee().setMin(minAmount);
        assertThat(customFractionalFee.getMin()).isEqualTo(minAmount);
    }

    @Test
    void getSetMaximumAmount() {
        final var customFractionalFee = new CustomFractionalFee().setMax(maxAmount);
        assertThat(customFractionalFee.getMax()).isEqualTo(maxAmount);
    }

    @Test
    void getSetAssessmentMethod() {
        final var customFractionalFee = new CustomFractionalFee().setAssessmentMethod(feeAssessmentMethod);
        assertThat(customFractionalFee.getAssessmentMethod()).isEqualTo(feeAssessmentMethod);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/CustomRoyaltyFeeTest.java
/*-
 *
 * Hedera C++ SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FixedFee;
import com.hedera.hashgraph.sdk.proto.Fraction;
import com.hedera.hashgraph.sdk.proto.RoyaltyFee;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class CustomRoyaltyFeeTest {
    private static final boolean allCollectorsAreExempt = true;
    private static final AccountId feeCollectorAccountId = new AccountId(1, 2, 3);
    private static final int numerator = 4;
    private static final int denominator = 5;
    private static final CustomFixedFee fallbackFee = new CustomFixedFee().setAmount(6);

    private final RoyaltyFee fee = RoyaltyFee.newBuilder()
        .setExchangeValueFraction(Fraction.newBuilder().setNumerator(numerator).setDenominator(denominator))
        .setFallbackFee(FixedFee.newBuilder().setAmount(6).build())
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(CustomRoyaltyFee.fromProtobuf(fee).toString()).toMatchSnapshot();
    }

    @Test
    void deepCloneSubclass() {
        var customRoyaltyFee = new CustomRoyaltyFee()
            .setFeeCollectorAccountId(feeCollectorAccountId)
            .setAllCollectorsAreExempt(allCollectorsAreExempt);
        var clonedCustomRoyaltyFee = customRoyaltyFee.deepCloneSubclass();

        assertThat(clonedCustomRoyaltyFee.getFeeCollectorAccountId()).isEqualTo(feeCollectorAccountId);
        assertThat(clonedCustomRoyaltyFee.getAllCollectorsAreExempt()).isEqualTo(allCollectorsAreExempt);
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(CustomRoyaltyFee.fromProtobuf(fee).toProtobuf().toString()).toMatchSnapshot();
    }

    @Test
    void getSetNumerator() {
        final var customRoyaltyFee = new CustomRoyaltyFee().setNumerator(numerator);
        assertThat(customRoyaltyFee.getNumerator()).isEqualTo(numerator);
    }

    @Test
    void getSetDenominator() {
        final var customRoyaltyFee = new CustomRoyaltyFee().setDenominator(denominator);
        assertThat(customRoyaltyFee.getDenominator()).isEqualTo(denominator);
    }

    @Test
    void getSetFallbackFee() {
        final var customRoyaltyFee = new CustomRoyaltyFee().setFallbackFee(fallbackFee);
        assertThat(customRoyaltyFee.getFallbackFee()).isNotNull();
        assertThat(customRoyaltyFee.getFallbackFee().getAmount()).isEqualTo(fallbackFee.getAmount());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/DelegateContractIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

class DelegateContractIdTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromString() {
        SnapshotMatcher.expect(DelegateContractId.fromString("0.0.5005").toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddress() {
        SnapshotMatcher.expect(DelegateContractId.fromSolidityAddress("000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddressWith0x() {
        SnapshotMatcher.expect(DelegateContractId.fromSolidityAddress("0x000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(Hex.toHexString(new DelegateContractId(5005).toBytes())).toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(DelegateContractId.fromBytes(new DelegateContractId(5005).toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void toSolidityAddress() {
        SnapshotMatcher.expect(new DelegateContractId(5005).toSolidityAddress()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/DuplicateTransactionTest.java
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.HashSet;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class DuplicateTransactionTest {

    @Test
    @DisplayName("Should generate unique transaction ids")
    void generateTransactionIds() {
        TransactionId[] ids = new TransactionId[1000000];
        AccountId accountId = AccountId.fromString("0.0.1000");
        for (int i = 0; i < ids.length; ++i) {
            ids[i] = TransactionId.generate(accountId);
        }
        HashSet<TransactionId> set = new HashSet<>(ids.length);
        for (int i = 0; i < ids.length; ++i) {
            assertThat(set.add(ids[i])).as("ids[%d] is not unique", i).isTrue();
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ECDSAPrivateKeyTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.utils.Bip32Utils;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.io.IOException;

import static org.assertj.core.api.Assertions.assertThat;

public class ECDSAPrivateKeyTest {

    private static final String TEST_VECTOR_PEM_PASSPHRASE = "asdasd123";

    @Test
    @DisplayName("private key generates successfully")
    void keyGenerates() {
        PrivateKey key = PrivateKey.generateECDSA();

        assertThat(key).isNotNull();
        assertThat(key.toBytes()).isNotNull();
    }

    @Test
    @DisplayName("private key can be recovered from bytes")
    void keySerialization() {
        PrivateKey key1 = PrivateKey.generateECDSA();
        byte[] key1Bytes = key1.toBytes();
        PrivateKey key2 = PrivateKey.fromBytes(key1Bytes);
        byte[] key2Bytes = key2.toBytes();

        assertThat(key2Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("private key can be recovered from raw bytes")
    void keySerialization2() {
        PrivateKey key1 = PrivateKey.generateECDSA();
        byte[] key1Bytes = key1.toBytesRaw();
        PrivateKey key2 = PrivateKey.fromBytesECDSA(key1Bytes);
        byte[] key2Bytes = key2.toBytesRaw();
        // cannot use PrivateKey.fromBytes() to parse raw ECDSA bytes
        // because they're indistinguishable from ED25519 raw bytes

        assertThat(key2Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("private key can be recovered from DER bytes")
    void keySerialization3() {
        PrivateKey key1 = PrivateKey.generateECDSA();
        byte[] key1Bytes = key1.toBytesDER();
        PrivateKey key2 = PrivateKey.fromBytesDER(key1Bytes);
        byte[] key2Bytes = key2.toBytesDER();
        PrivateKey key3 = PrivateKey.fromBytes(key1Bytes);
        byte[] key3Bytes = key3.toBytesDER();

        assertThat(key2Bytes).containsExactly(key1Bytes);
        assertThat(key3Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("private key can be recovered from string")
    void keyStringification() {
        PrivateKey key1 = PrivateKey.generateECDSA();
        String key1String = key1.toString();
        PrivateKey key2 = PrivateKey.fromString(key1String);
        String key2String = key2.toString();

        assertThat(key2String).isEqualTo(key1String);
    }

    @Test
    @DisplayName("private key can be recovered from raw string")
    void keyStringification2() {
        PrivateKey key1 = PrivateKey.generateECDSA();
        String key1String = key1.toStringRaw();
        PrivateKey key2 = PrivateKey.fromStringECDSA(key1String);
        String key2String = key2.toStringRaw();
        // cannot use PrivateKey.fromString() to parse raw ECDSA string
        // because it's indistinguishable from ED25519 raw string

        assertThat(key2String).isEqualTo(key1String);
    }

    @Test
    @DisplayName("private key can be recovered from DER string")
    void keyStringification3() {
        PrivateKey key1 = PrivateKey.generateECDSA();
        String key1String = key1.toStringDER();
        PrivateKey key2 = PrivateKey.fromStringDER(key1String);
        String key2String = key2.toStringDER();
        PrivateKey key3 = PrivateKey.fromString(key1String);
        String key3String = key3.toStringDER();

        assertThat(key2String).isEqualTo(key1String);
        assertThat(key3String).isEqualTo(key1String);
    }

    @Test
    @DisplayName("private key is is ECDSA")
    void keyIsECDSA() {
        PrivateKey key = PrivateKey.generateECDSA();

        assertThat(key.isECDSA()).isTrue();
    }

    @Test
    @DisplayName("private key is is not Ed25519")
    void keyIsNotEd25519() {
        PrivateKey key = PrivateKey.generateECDSA();

        assertThat(key.isED25519()).isFalse();
    }

    // TODO: replace with HexFormat.of().parseHex when the required Java version is 17
    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }

    @Test
    @DisplayName("SLIP10 test vector 1")
    void slip10TestVector1() {
        // https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-1-for-secp256k1
        final String CHAIN_CODE1 = "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508";
        final String PRIVATE_KEY1 = "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35";
        final String PUBLIC_KEY1 = "0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2";

        final String CHAIN_CODE2 = "47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141";
        final String PRIVATE_KEY2 = "edb2e14f9ee77d26dd93b4ecede8d16ed408ce149b6cd80b0715a2d911a0afea";
        final String PUBLIC_KEY2 = "035a784662a4a20a65bf6aab9ae98a6c068a81c52e4b032c0fb5400c706cfccc56";

        final String CHAIN_CODE3 = "2a7857631386ba23dacac34180dd1983734e444fdbf774041578e9b6adb37c19";
        final String PRIVATE_KEY3 = "3c6cb8d0f6a264c91ea8b5030fadaa8e538b020f0a387421a12de9319dc93368";
        final String PUBLIC_KEY3 = "03501e454bf00751f24b1b489aa925215d66af2234e3891c3b21a52bedb3cd711c";

        final String CHAIN_CODE4 = "04466b9cc8e161e966409ca52986c584f07e9dc81f735db683c3ff6ec7b1503f";
        final String PRIVATE_KEY4 = "cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca";
        final String PUBLIC_KEY4 = "0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2";

        final String CHAIN_CODE5 = "cfb71883f01676f587d023cc53a35bc7f88f724b1f8c2892ac1275ac822a3edd";
        final String PRIVATE_KEY5 = "0f479245fb19a38a1954c5c7c0ebab2f9bdfd96a17563ef28a6a4b1a2a764ef4";
        final String PUBLIC_KEY5 = "02e8445082a72f29b75ca48748a914df60622a609cacfce8ed0e35804560741d29";

        final String CHAIN_CODE6 = "c783e67b921d2beb8f6b389cc646d7263b4145701dadd2161548a8b078e65e9e";
        final String PRIVATE_KEY6 = "471b76e389e528d6de6d816857e012c5455051cad6660850e58372a6c3e6e7c8";
        final String PUBLIC_KEY6 = "022a471424da5e657499d1ff51cb43c47481a03b1e77f951fe64cec9f5a48f7011";

        var seed = hexStringToByteArray("000102030405060708090a0b0c0d0e0f");

        // Chain m
        PrivateKey key1 = PrivateKey.fromSeedECDSAsecp256k1(seed);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/0'
        PrivateKey key2 = key1.derive(Bip32Utils.toHardenedIndex(0));
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/0'/1
        PrivateKey key3 = key2.derive(1);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/0'/1/2'
        PrivateKey key4 = key3.derive(Bip32Utils.toHardenedIndex(2));
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);

        // Chain m/0'/1/2'/2
        PrivateKey key5 = key4.derive(2);
        assertThat(Hex.toHexString(key5.getChainCode().getKey())).isEqualTo(CHAIN_CODE5);
        assertThat(key5.toStringRaw()).isEqualTo(PRIVATE_KEY5);
        assertThat(key5.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY5);

        // Chain m/0'/1/2'/2/1000000000
        PrivateKey key6 = key5.derive(1000000000);
        assertThat(Hex.toHexString(key6.getChainCode().getKey())).isEqualTo(CHAIN_CODE6);
        assertThat(key6.toStringRaw()).isEqualTo(PRIVATE_KEY6);
        assertThat(key6.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY6);
    }

    @Test
    @DisplayName("SLIP10 test vector 2")
    void slip10TestVector2() {
        // https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-2-for-secp256k1
        final String CHAIN_CODE1 = "60499f801b896d83179a4374aeb7822aaeaceaa0db1f85ee3e904c4defbd9689";
        final String PRIVATE_KEY1 = "4b03d6fc340455b363f51020ad3ecca4f0850280cf436c70c727923f6db46c3e";
        final String PUBLIC_KEY1 = "03cbcaa9c98c877a26977d00825c956a238e8dddfbd322cce4f74b0b5bd6ace4a7";

        final String CHAIN_CODE2 = "f0909affaa7ee7abe5dd4e100598d4dc53cd709d5a5c2cac40e7412f232f7c9c";
        final String PRIVATE_KEY2 = "abe74a98f6c7eabee0428f53798f0ab8aa1bd37873999041703c742f15ac7e1e";
        final String PUBLIC_KEY2 = "02fc9e5af0ac8d9b3cecfe2a888e2117ba3d089d8585886c9c826b6b22a98d12ea";

        final String CHAIN_CODE3 = "be17a268474a6bb9c61e1d720cf6215e2a88c5406c4aee7b38547f585c9a37d9";
        final String PRIVATE_KEY3 = "877c779ad9687164e9c2f4f0f4ff0340814392330693ce95a58fe18fd52e6e93";
        final String PUBLIC_KEY3 = "03c01e7425647bdefa82b12d9bad5e3e6865bee0502694b94ca58b666abc0a5c3b";

        final String CHAIN_CODE4 = "f366f48f1ea9f2d1d3fe958c95ca84ea18e4c4ddb9366c336c927eb246fb38cb";
        final String PRIVATE_KEY4 = "704addf544a06e5ee4bea37098463c23613da32020d604506da8c0518e1da4b7";
        final String PUBLIC_KEY4 = "03a7d1d856deb74c508e05031f9895dab54626251b3806e16b4bd12e781a7df5b9";

        final String CHAIN_CODE5 = "637807030d55d01f9a0cb3a7839515d796bd07706386a6eddf06cc29a65a0e29";
        final String PRIVATE_KEY5 = "f1c7c871a54a804afe328b4c83a1c33b8e5ff48f5087273f04efa83b247d6a2d";
        final String PUBLIC_KEY5 = "02d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0";

        final String CHAIN_CODE6 = "9452b549be8cea3ecb7a84bec10dcfd94afe4d129ebfd3b3cb58eedf394ed271";
        final String PRIVATE_KEY6 = "bb7d39bdb83ecf58f2fd82b6d918341cbef428661ef01ab97c28a4842125ac23";
        final String PUBLIC_KEY6 = "024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c";

        var seed = hexStringToByteArray("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542");

        // Chain m
        PrivateKey key1 = PrivateKey.fromSeedECDSAsecp256k1(seed);;
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/0
        PrivateKey key2 = key1.derive(0);
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/0/2147483647'
        PrivateKey key3 = key2.derive(Bip32Utils.toHardenedIndex(2147483647));
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/0/2147483647'/1
        PrivateKey key4 = key3.derive(1);
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);

        // Chain m/0/2147483647'/1/2147483646'
        PrivateKey key5 = key4.derive(Bip32Utils.toHardenedIndex(2147483646));
        assertThat(Hex.toHexString(key5.getChainCode().getKey())).isEqualTo(CHAIN_CODE5);
        assertThat(key5.toStringRaw()).isEqualTo(PRIVATE_KEY5);
        assertThat(key5.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY5);

        // Chain m/0/2147483647'/1/2147483646'/2
        PrivateKey key6 = key5.derive(2);
        assertThat(Hex.toHexString(key6.getChainCode().getKey())).isEqualTo(CHAIN_CODE6);
        assertThat(key6.toStringRaw()).isEqualTo(PRIVATE_KEY6);
        assertThat(key6.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY6);
    }

    @Test
    @DisplayName("PEM import test vectors")
    void PEMImportTestVectors() throws IOException {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PRIVATE_KEY_PEM1 = "-----BEGIN EC PRIVATE KEY-----\n" +
            "MHQCAQEEIG8I+jKi+iGVa7ttbfnlnML5AdvPugbgBWnseYjrle6qoAcGBSuBBAAK\n" +
            "oUQDQgAEqf5BmMeBzkU1Ra9UAbZJo3tytVOlb7erTc36LRLP20mOLU7+mFY+3Cfe\n" +
            "fAZgBtPXRAmDtRvYGODswAalW85GKA==\n" +
            "-----END EC PRIVATE KEY-----";
        var PRIVATE_KEY1 = "6f08fa32a2fa21956bbb6d6df9e59cc2f901dbcfba06e00569ec7988eb95eeaa";
        var PUBLIC_KEY1 = "02a9fe4198c781ce453545af5401b649a37b72b553a56fb7ab4dcdfa2d12cfdb49";

        var PRIVATE_KEY_PEM2 = "-----BEGIN EC PRIVATE KEY-----\n" +
            "MFQCAQEEIOHyhclwHbha3f281Kvd884rhBzltxGJxCZyaQCagH9joAcGBSuBBAAK\n" +
            "oSQDIgACREr6gFZa4K7hBP+bA25VdgQ+0ABFgM+g5RYw/W6T1Og=\n" +
            "-----END EC PRIVATE KEY-----";
        var PRIVATE_KEY2 = "e1f285c9701db85addfdbcd4abddf3ce2b841ce5b71189c4267269009a807f63";
        var PUBLIC_KEY2 = "02444afa80565ae0aee104ff9b036e5576043ed0004580cfa0e51630fd6e93d4e8";

        var PRIVATE_KEY_PEM3 = "-----BEGIN EC PRIVATE KEY-----\n" +
            "Proc-Type: 4,ENCRYPTED\n" +
            "DEK-Info: AES-128-CBC,0046A9EED8D16F0CAA66A197CE8BE8BD\n" +
            "\n" +
            "9VU9gReUmrn4XywjMx0F0A3oGzpHIksEXma72TCSdcxI7zHy0mtzuGq4Wd25O38s\n" +
            "H9c6kvhTPS1N/c6iNhx154B0HUoND8jvAvfxbGR/R87vpZJsOoKCmRxGqrxG8HER\n" +
            "FIHQ1jy16DrAbU95kDyLsiF1dy2vUY/HoqFZwxl/IVc=\n" +
            "-----END EC PRIVATE KEY-----";
        var PRIVATE_KEY3 = "cf49eb5206c1b0468854d6ea7b370590619625514f71ff93608a18465e4012ad";
        var PUBLIC_KEY3 = "025f0d14a7562d6319e5b8f91620d2ce9ad13d9abf21cfe9bd0a092c0f35bf1701";

        var PRIVATE_KEY_PEM4 = "-----BEGIN EC PRIVATE KEY-----\n" +
            "Proc-Type: 4,ENCRYPTED\n" +
            "DEK-Info: AES-128-CBC,4A9B3B987EC2EFFA405818327D14FFF7\n" +
            "\n" +
            "Wh756RkK5fn1Ke2denR1OYfqE9Kr4BXhgrEMTU/6o0SNhMULUhWGHrCWvmNeEQwp\n" +
            "ZVZYUxgYoTlJBeREzKAZithcvxIcTbQfLABo1NZbjA6YKqAqlGpM6owwL/f9e2ST\n" +
            "-----END EC PRIVATE KEY-----";
        var PRIVATE_KEY4 = "c0d3e16ba5a1abbeac4cd327a3c3c1cc10438431d0bac019054e573e67768bb5";
        var PUBLIC_KEY4 = "02065f736378134c53c7a2ee46f199fb93b9b32337be4e95660677046476995544";

        var ecdsaPrivateKey1 = PrivateKey.fromPem(PRIVATE_KEY_PEM1);
        assertThat(ecdsaPrivateKey1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(ecdsaPrivateKey1.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY1);

        var ecdsaPrivateKey2 = PrivateKey.fromPem(PRIVATE_KEY_PEM2);
        assertThat(ecdsaPrivateKey2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(ecdsaPrivateKey2.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY2);

        var ecdsaPrivateKey3 = PrivateKey.fromPem(PRIVATE_KEY_PEM3, TEST_VECTOR_PEM_PASSPHRASE);
        assertThat(ecdsaPrivateKey3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(ecdsaPrivateKey3.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY3);

        var ecdsaPrivateKey4 = PrivateKey.fromPem(PRIVATE_KEY_PEM4, TEST_VECTOR_PEM_PASSPHRASE);
        assertThat(ecdsaPrivateKey4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(ecdsaPrivateKey4.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY4);
    }

    @Test
    @DisplayName("DER import test vectors")
    void DERImportTestVectors() {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PRIVATE_KEY_DER1 = "3030020100300706052b8104000a042204208c2cdc9575fe67493443967d74958fd7808a3787fd3337e99cfeebbc7566b586";
        var PRIVATE_KEY1 = "8c2cdc9575fe67493443967d74958fd7808a3787fd3337e99cfeebbc7566b586";
        var PUBLIC_KEY1 = "028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd";

        var PRIVATE_KEY_DER2 = "30540201010420ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffda00706052b8104000aa124032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";
        var PRIVATE_KEY2 = "ac318ea8ff8d991ab2f16172b4738e74dc35a56681199cfb1c0cb2e7cb560ffd";
        var PUBLIC_KEY2 = "036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";

        var PRIVATE_KEY_DER3 = "307402010104208927647ad12b29646a1d051da8453462937bb2c813c6815cac6c0b720526ffc6a00706052b8104000aa14403420004aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a6597795f855ddcad2377e22259d1fcb4e0f1d35e8f2056300c15070bcbfce3759cc9d";
        var PRIVATE_KEY3 = "8927647ad12b29646a1d051da8453462937bb2c813c6815cac6c0b720526ffc6";
        var PUBLIC_KEY3 = "03aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a65977";

        var PRIVATE_KEY_DER4 = "302e0201010420a6170a6aa6389a5bd3a3a8f9375f57bd91aa7f7d8b8b46ce0b702e000a21a5fea00706052b8104000a";
        var PRIVATE_KEY4 = "a6170a6aa6389a5bd3a3a8f9375f57bd91aa7f7d8b8b46ce0b702e000a21a5fe";
        var PUBLIC_KEY4 = "03b69a75a5ddb1c0747e995d47555019e5d8a28003ab5202bd92f534361fb4ec8a";

        var ecdsaPrivateKey1 = PrivateKey.fromStringDER(PRIVATE_KEY_DER1);
        assertThat(ecdsaPrivateKey1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(ecdsaPrivateKey1.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY1);

        var ecdsaPrivateKey2 = PrivateKey.fromStringDER(PRIVATE_KEY_DER2);
        assertThat(ecdsaPrivateKey2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(ecdsaPrivateKey2.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY2);

        var ecdsaPrivateKey3 = PrivateKey.fromStringDER(PRIVATE_KEY_DER3);
        assertThat(ecdsaPrivateKey3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(ecdsaPrivateKey3.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY3);

        var ecdsaPrivateKey4 = PrivateKey.fromStringDER(PRIVATE_KEY_DER4);
        assertThat(ecdsaPrivateKey4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(ecdsaPrivateKey4.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY4);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ECDSAPublicKeyTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatNoException;

public class ECDSAPublicKeyTest {
    @Test
    void verifyTransaction() {
        var transaction = new TransferTransaction()
                .setNodeAccountIds(Collections.singletonList(new AccountId(3)))
                .setTransactionId(TransactionId.generate(new AccountId(4)))
                .freeze();

        var key = PrivateKey.fromStringECDSA("8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048");
        key.signTransaction(transaction);

        assertThat(key.getPublicKey().verifyTransaction(transaction)).isTrue();
    }

    @Test
    @DisplayName("public key can be recovered from bytes")
    void keyByteSerialization() {
        PublicKey key1 = PrivateKey.generateECDSA().getPublicKey();
        byte[] key1Bytes = key1.toBytes();
        PublicKey key2 = PublicKey.fromBytes(key1Bytes);
        byte[] key2Bytes = key2.toBytes();

        assertThat(key2Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("public key can be recovered from raw bytes")
    void keyByteSerialization2() {
        PublicKey key1 = PrivateKey.generateECDSA().getPublicKey();
        byte[] key1Bytes = key1.toBytesRaw();
        PublicKey key2 = PublicKey.fromBytesECDSA(key1Bytes);
        byte[] key2Bytes = key2.toBytesRaw();
        // cannot use PrivateKey.fromBytes() to parse raw ECDSA bytes
        // because they're indistinguishable from ED25519 raw bytes

        assertThat(key2Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("public key can be recovered from DER bytes")
    void keyByteSerialization3() {
        PublicKey key1 = PrivateKey.generateECDSA().getPublicKey();
        byte[] key1Bytes = key1.toBytesDER();
        PublicKey key2 = PublicKey.fromBytesDER(key1Bytes);
        byte[] key2Bytes = key2.toBytesDER();
        PublicKey key3 = PublicKey.fromBytes(key1Bytes);
        byte[] key3Bytes = key3.toBytesDER();

        assertThat(key2Bytes).containsExactly(key1Bytes);
        assertThat(key3Bytes).isEqualTo(key1Bytes);
    }

    @Test
    @DisplayName("public key can be recovered after transaction serialization")
    void keyByteSerializationThroughTransaction() {
        var senderAccount = AccountId.fromString("0.0.1337");
        var receiverAccount = AccountId.fromString("0.0.3");
        var transferAmount = Hbar.from(new BigDecimal("0.0001"), HbarUnit.HBAR);
        var privateKey = PrivateKey.generateECDSA();
        var client = Client.forTestnet()
            .setOperator(senderAccount, privateKey);
        var tx = new TransferTransaction()
            .addHbarTransfer(senderAccount, transferAmount.negated())
            .addHbarTransfer(receiverAccount, transferAmount);

        tx.freezeWith(client);
        tx.signWithOperator(client);

        var bytes = tx.toBytes();

        assertThatNoException().isThrownBy(() -> Transaction.fromBytes(bytes));
        assertThat(tx.getSignatures()).isNotEmpty();
    }

    @Test
    @DisplayName("public key can be recovered from string")
    void keyStringSerialization() {
        PublicKey key1 = PrivateKey.generateECDSA().getPublicKey();
        String key1Str = key1.toString();
        PublicKey key2 = PublicKey.fromString(key1Str);
        String key2Str = key2.toString();
        PublicKey key3 = PublicKey.fromString(key1Str);
        String key3Str = key3.toString();

        assertThat(key3.getClass()).isEqualTo(PublicKeyECDSA.class);
        assertThat(key2Str).isEqualTo(key1Str);
        assertThat(key3Str).isEqualTo(key1Str);
    }

    @Test
    @DisplayName("public key can be recovered from raw string")
    void keyStringSerialization2() {
        PublicKey key1 = PrivateKey.generateECDSA().getPublicKey();
        String key1Str = key1.toStringRaw();
        PublicKey key2 = PublicKey.fromStringECDSA(key1Str);
        String key2Str = key2.toStringRaw();
        PublicKey key3 = PublicKey.fromStringECDSA(key2Str);
        String key3Str = key3.toStringRaw();
        // cannot use PublicKey.fromString() to parse raw ECDSA string
        // because it's indistinguishable from ED25519 raw bytes

        assertThat(key3.getClass()).isEqualTo(PublicKeyECDSA.class);
        assertThat(key2Str).isEqualTo(key1Str);
        assertThat(key3Str).isEqualTo(key1Str);
    }

    @Test
    @DisplayName("public key can be recovered from DER string")
    void keyStringSerialization3() {
        PublicKey key1 = PrivateKey.generateECDSA().getPublicKey();
        String key1Str = key1.toStringDER();
        PublicKey key2 = PublicKey.fromStringDER(key1Str);
        String key2Str = key2.toStringDER();
        PublicKey key3 = PublicKey.fromString(key1Str);
        String key3Str = key3.toStringDER();

        assertThat(key3.getClass()).isEqualTo(PublicKeyECDSA.class);
        assertThat(key2Str).isEqualTo(key1Str);
        assertThat(key3Str).isEqualTo(key1Str);
    }

    @Test
    @DisplayName("public key is is ECDSA")
    void keyIsECDSA() {
        PublicKey key = PrivateKey.generateECDSA().getPublicKey();

        assertThat(key.isECDSA()).isTrue();
    }

    @Test
    @DisplayName("public key is is not Ed25519")
    void keyIsNotEd25519() {
        PublicKey key = PrivateKey.generateECDSA().getPublicKey();

        assertThat(key.isED25519()).isFalse();
    }

    @Test
    @DisplayName("to EVM address")
    void toEvmAddress() {
        // Generated by https://www.rfctools.com/ethereum-address-test-tool/
        String privateKeyString = "DEBAE3CA62AB3157110DBA79C8DE26540DC320EE9BE73A77D70BA175643A3500";
        String expectedEvmAddress = "d8eb8db03c699faa3f47adcdcd2ae91773b10f8b";

        PrivateKey privateKey = PrivateKey.fromStringECDSA(privateKeyString);
        PublicKey key = privateKey.getPublicKey();

        assertThat(key.toEvmAddress()).hasToString(expectedEvmAddress);
    }

    @Test
    @DisplayName("DER import test vectors")
    void DERImportTestVectors() {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PUBLIC_KEY_DER1 = "302d300706052b8104000a032200028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd";
        var PUBLIC_KEY1 = "028173079d2e996ef6b2d064fc82d5fc7094367211e28422bec50a2f75c365f5fd";

        var PUBLIC_KEY_DER2 = "3036301006072a8648ce3d020106052b8104000a032200036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";
        var PUBLIC_KEY2 = "036843f5cb338bbb4cdb21b0da4ea739d910951d6e8a5f703d313efe31afe788f4";

        var PUBLIC_KEY_DER3 = "3056301006072a8648ce3d020106052b8104000a03420004aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a6597795f855ddcad2377e22259d1fcb4e0f1d35e8f2056300c15070bcbfce3759cc9d";
        var PUBLIC_KEY3 = "03aaac1c3ac1bea0245b8e00ce1e2018f9eab61b6331fbef7266f2287750a65977";

        var ecdsaPublicKey1 = PublicKey.fromStringDER(PUBLIC_KEY_DER1);
        assertThat(ecdsaPublicKey1.toStringRaw()).isEqualTo(PUBLIC_KEY1);

        var ecdsaPublicKey2 = PublicKey.fromStringDER(PUBLIC_KEY_DER2);
        assertThat(ecdsaPublicKey2.toStringRaw()).isEqualTo(PUBLIC_KEY2);

        var ecdsaPublicKey3 = PublicKey.fromStringDER(PUBLIC_KEY_DER3);
        assertThat(ecdsaPublicKey3.toStringRaw()).isEqualTo(PUBLIC_KEY3);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/Ed25519PrivateKeyTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.bouncycastle.math.ec.rfc8032.Ed25519;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class Ed25519PrivateKeyTest {
    private static final String TEST_KEY_STR = "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";
    private static final String TEST_KEY_STR_RAW = "db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";
    private static final String TEST_KEY_PEM = "-----BEGIN PRIVATE KEY-----\n"
        + "MC4CAQAwBQYDK2VwBCIEINtIS4KOZLLY8SzjwKDpOguMznrxu485yXcyOUSCU44Q\n"
        + "-----END PRIVATE KEY-----\n";

    // generated by hedera-sdk-js, not used anywhere
    private static final String MNEMONIC_STRING = "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home";
    private static final String MNEMONIC_PRIVATE_KEY = "302e020100300506032b657004220420853f15aecd22706b105da1d709b4ac05b4906170c2b9c7495dff9af49e1391da";

    private static final String MNEMONIC_LEGACY_STRING = "jolly kidnap tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure";
    private static final String MNEMONIC_LEGACY_PRIVATE_KEY = "302e020100300506032b657004220420882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf";

    // backup phrase generated by the iOS wallet, not used anywhere
    private static final String IOS_MNEMONIC_STRING = "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle";

    // private key for "default account", should be index 0
    private static final String IOS_DEFAULT_PRIVATE_KEY = "5f66a51931e8c99089472e0d70516b6272b94dd772b967f8221e1077f966dbda2b60cf7ee8cf10ecd5a076bffad9a7c7b97df370ad758c0f1dd4ef738e04ceb6";

    // backup phrase generated by the Android wallet, also not used anywhere
    private static final String ANDROID_MNEMONIC_STRING = "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track";
    // private key for "default account", should be index 0
    private static final String ANDROID_DEFAULT_PRIVATE_KEY = "c284c25b3a1458b59423bc289e83703b125c8eefec4d5aa1b393c2beb9f2bae66188a344ba75c43918ab12fa2ea4a92960eca029a2320d8c6a1c3b94e06c9985";

    private static final String PEM_PASSPHRASE = "this is a passphrase";

    private static final String TEST_VECTOR_PEM_PASSPHRASE = "asdasd123";

    /*
        # enter passphrase "this is a passphrase"
        echo '302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10' \
        | xxd -r -p \
        | openssl pkey -inform der -aes-128-cbc
     */
    private static final String ENCRYPTED_PEM = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n"
        + "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAi8WY7Gy2tThQICCAAw\n"
        + "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEOq46NPss58chbjUn20NoK0EQG1x\n"
        + "R88hIXcWDOECttPTNlMXWJt7Wufm1YwBibrxmCq1QykIyTYhy1TZMyxyPxlYW6aV\n"
        + "9hlo4YEh3uEaCmfJzWM=\n"
        + "-----END ENCRYPTED PRIVATE KEY-----\n";
    private static final String MESSAGE_STR = "This is a message about the world.";
    private static final byte[] MESSAGE_BYTES = MESSAGE_STR.getBytes(StandardCharsets.UTF_8);
    private static final String SIG_STR = "73bea53f31ca9c42a422ecb7516ec08d0bbd1a6bfd630ccf10ec1872454814d29f4a8011129cd007eab544af01a75f508285b591e5bed24b68f927751e49e30e";

    @SuppressWarnings("unused")
    private static Stream<String> privKeyStrings() {
        return Stream.of(
            TEST_KEY_STR,
            // raw hex (concatenated private + public key)
            TEST_KEY_STR_RAW +
                "e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
            // raw hex (just private key)
            TEST_KEY_STR_RAW
        );
    }

    @Test
    @DisplayName("private key generates successfully")
    void keyGenerates() {
        PrivateKey key = PrivateKey.generateED25519();

        assertThat(key).isNotNull();
        assertThat(key.toBytes()).isNotNull();

        // we generate the chain code at the same time
        assertThat(key.isDerivable()).isTrue();
    }

    @Test
    @DisplayName("private key can be recovered from bytes")
    void keySerialization() {
        PrivateKey key1 = PrivateKey.generateED25519();
        byte[] key1Bytes = key1.toBytes();
        PrivateKey key2 = PrivateKey.fromBytes(key1Bytes);
        byte[] key2Bytes = key2.toBytes();

        assertThat(key2Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("private key can be recovered from raw bytes")
    void keySerialization2() {
        PrivateKey key1 = PrivateKey.generateED25519();
        byte[] key1Bytes = key1.toBytesRaw();
        PrivateKey key2 = PrivateKey.fromBytesED25519(key1Bytes);
        byte[] key2Bytes = key2.toBytesRaw();
        PrivateKey key3 = PrivateKey.fromBytes(key1Bytes);
        byte[] key3Bytes = key3.toBytesRaw();

        assertThat(key2Bytes).containsExactly(key1Bytes);
        assertThat(key3Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("private key can be recovered from DER bytes")
    void keySerialization3() {
        PrivateKey key1 = PrivateKey.generateED25519();
        byte[] key1Bytes = key1.toBytesDER();
        PrivateKey key2 = PrivateKey.fromBytesDER(key1Bytes);
        byte[] key2Bytes = key2.toBytesDER();
        PrivateKey key3 = PrivateKey.fromBytes(key1Bytes);
        byte[] key3Bytes = key3.toBytesDER();

        assertThat(key2Bytes).containsExactly(key1Bytes);
        assertThat(key3Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("private key can be recovered from string")
    void keyStringification() {
        PrivateKey key1 = PrivateKey.generateED25519();
        String key1String = key1.toString();
        PrivateKey key2 = PrivateKey.fromString(key1String);
        String key2String = key2.toString();

        assertThat(key2String).isEqualTo(key1String);
    }

    @Test
    @DisplayName("private key can be recovered from raw string")
    void keyStringification2() {
        PrivateKey key1 = PrivateKey.generateED25519();
        String key1String = key1.toStringRaw();
        PrivateKey key2 = PrivateKey.fromStringED25519(key1String);
        String key2String = key2.toStringRaw();
        PrivateKey key3 = PrivateKey.fromString(key1String);
        String key3String = key3.toStringRaw();

        assertThat(key2String).isEqualTo(key1String);
        assertThat(key3String).isEqualTo(key1String);
    }

    @Test
    @DisplayName("private key can be recovered from DER string")
    void keyStringification3() {
        PrivateKey key1 = PrivateKey.generateED25519();
        String key1String = key1.toStringDER();
        PrivateKey key2 = PrivateKey.fromStringDER(key1String);
        String key2String = key2.toStringDER();
        PrivateKey key3 = PrivateKey.fromString(key1String);
        String key3String = key3.toStringDER();

        assertThat(key2String).isEqualTo(key1String);
        assertThat(key3String).isEqualTo(key1String);
    }

    @ParameterizedTest
    @DisplayName("private key can be recovered from external string")
    @ValueSource(strings = {
        TEST_KEY_STR,
        // raw hex (concatenated private + public key)
        TEST_KEY_STR_RAW +
            "e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
        // raw hex (just private key)
        TEST_KEY_STR_RAW
    })
    void externalKeyDeserialize(String keyStr) {
        PrivateKey key = PrivateKey.fromString(keyStr);
        assertThat(key).isNotNull();
        // the above are all the same key
        assertThat(key.toString()).isEqualTo(TEST_KEY_STR);
        assertThat(key.toStringDER()).isEqualTo(TEST_KEY_STR);
        assertThat(key.toStringRaw()).isEqualTo(TEST_KEY_STR_RAW);
    }

    @Test
    @DisplayName("private key can be encoded to a string")
    void keyToString() {
        PrivateKey key = PrivateKey.fromString(TEST_KEY_STR);

        assertThat(key).isNotNull();
        assertThat(key.toString()).isEqualTo(TEST_KEY_STR);
    }

    @Test
    @DisplayName("private key can be decoded from a PEM file")
    void keyFromPem() throws IOException {
        StringReader stringReader = new StringReader(TEST_KEY_PEM);
        PrivateKey privateKey = PrivateKey.readPem(stringReader);

        assertThat(privateKey.toString()).isEqualTo(TEST_KEY_STR);
    }

    @Test
    @DisplayName("private key can be recovered from a mnemonic")
    void keyFromMnemonic() throws Exception {
        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_STRING);
        PrivateKey key = PrivateKey.fromMnemonic(mnemonic);
        PrivateKey key2 = PrivateKey.fromString(MNEMONIC_PRIVATE_KEY);
        assertThat(key2.toBytes()).containsExactly(key.toBytes());
    }

    @Test
    @DisplayName("validate 12 word generated mnemonic")
    void validateGenerated12() throws Exception {
        Mnemonic mnemonic = Mnemonic.generate12();
        Mnemonic.fromString(mnemonic.toString());
    }

    @Test
    @DisplayName("validate legacy mnemonic")
    void validateLegacyMnemonic() throws Exception {
        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_LEGACY_STRING);
        PrivateKey key = mnemonic.toLegacyPrivateKey();
        assertThat(key.legacyDerive(-1).toString()).isEqualTo(MNEMONIC_LEGACY_PRIVATE_KEY);
    }

    @Test
    @DisplayName("validate 24 word generated mnemonic")
    void validateGenerated24() throws Exception {
        Mnemonic mnemonic = Mnemonic.generate24();
        Mnemonic.fromString(mnemonic.toString());
    }

    @Test
    @DisplayName("derived key matches that of the mobile wallets")
    void deriveKeyIndex0() throws Exception {
        Mnemonic iosMnemonic = Mnemonic.fromString(IOS_MNEMONIC_STRING);
        PrivateKey iosKey = PrivateKey.fromMnemonic(iosMnemonic);

        PrivateKey iosDerivedKey = iosKey.derive(0);
        PrivateKey iosExpectedKey = PrivateKey.fromString(IOS_DEFAULT_PRIVATE_KEY);

        assertThat(iosDerivedKey.toBytes()).containsExactly(iosExpectedKey.toBytes());

        Mnemonic androidMnemonic = Mnemonic.fromString(ANDROID_MNEMONIC_STRING);
        PrivateKey androidKey = PrivateKey.fromMnemonic(androidMnemonic);

        PrivateKey androidDerivedKey = androidKey.derive(0);
        PrivateKey androidExpectedKey = PrivateKey.fromString(ANDROID_DEFAULT_PRIVATE_KEY);

        assertThat(androidDerivedKey.toBytes()).containsExactly(androidExpectedKey.toBytes());
    }

    @Test
    @DisplayName("generated mnemonic24 can be turned into a working private key")
    void keyFromGeneratedMnemonic24() {
        Mnemonic mnemonic = Mnemonic.generate24();
        PrivateKey privateKey = PrivateKey.fromMnemonic(mnemonic);

        byte[] messageToSign = "this is a test message".getBytes(StandardCharsets.UTF_8);

        byte[] signature = privateKey.sign(messageToSign);

        assertThat(Ed25519.verify(
            signature,
            0,
            privateKey.getPublicKey().toBytes(),
            0,
            messageToSign,
            0,
            messageToSign.length
        )).isTrue();
    }

    @Test
    @DisplayName("generated mnemonic12 can be turned into a working private key")
    void keyFromGeneratedMnemonic12() {
        Mnemonic mnemonic = Mnemonic.generate12();
        PrivateKey privateKey = PrivateKey.fromMnemonic(mnemonic);

        byte[] messageToSign = "this is a test message".getBytes(StandardCharsets.UTF_8);

        byte[] signature = privateKey.sign(messageToSign);

        assertThat(Ed25519.verify(
            signature,
            0,
            privateKey.getPublicKey().toBytes(),
            0,
            messageToSign,
            0,
            messageToSign.length
        )).isTrue();
    }

    @Test
    @DisplayName("fromPem() with passphrase produces same key")
    void keyFromEncryptedPem() throws IOException {
        PrivateKey privateKey = PrivateKey.fromPem(ENCRYPTED_PEM, PEM_PASSPHRASE);
        assertThat(privateKey.toString()).isEqualTo(TEST_KEY_STR);
    }

    @Test
    @DisplayName("fromPem() with encrypted key without a passphrase throws useful error")
    void errorKeyFromEncryptedPemNoPassphrase() {
        assertThatExceptionOfType(BadKeyException.class).isThrownBy(
            () -> PrivateKey.fromPem(ENCRYPTED_PEM)
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo(
            "PEM file contained an encrypted private key but no passphrase was given"
        ));
    }

    @ParameterizedTest
    @DisplayName("reproducible signature can be computed")
    @ValueSource(strings = {
        TEST_KEY_STR,
        // raw hex (concatenated private + public key)
        TEST_KEY_STR_RAW +
            "e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
        // raw hex (just private key)
        TEST_KEY_STR_RAW
    })
    void reproducibleSignature(String keyStr) {
        PrivateKey key = PrivateKey.fromString(keyStr);
        byte[] signature = key.sign(MESSAGE_BYTES);

        assertThat(Hex.toHexString(signature)).isEqualTo(SIG_STR);
    }
    @Test
    @DisplayName("private key is is ECDSA")
    void keyIsECDSA() {
        PrivateKey key = PrivateKey.generateED25519();

        assertThat(key.isED25519()).isTrue();
    }

    @Test
    @DisplayName("private key is is not Ed25519")
    void keyIsNotEd25519() {
        PrivateKey key = PrivateKey.generateED25519();

        assertThat(key.isECDSA()).isFalse();
    }

    // TODO: replace with HexFormat.of().parseHex when the required Java version is 17
    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }

    @Test
    @DisplayName("SLIP10 test vector 1")
    void slip10TestVector1() {
        // https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-1-for-ed25519
        final String CHAIN_CODE1 = "90046a93de5380a72b5e45010748567d5ea02bbf6522f979e05c0d8d8ca9fffb";
        final String PRIVATE_KEY1 = "2b4be7f19ee27bbf30c667b642d5f4aa69fd169872f8fc3059c08ebae2eb19e7";
        final String PUBLIC_KEY1 = "00a4b2856bfec510abab89753fac1ac0e1112364e7d250545963f135f2a33188ed";

        final String CHAIN_CODE2 = "8b59aa11380b624e81507a27fedda59fea6d0b779a778918a2fd3590e16e9c69";
        final String PRIVATE_KEY2 = "68e0fe46dfb67e368c75379acec591dad19df3cde26e63b93a8e704f1dade7a3";
        final String PUBLIC_KEY2 = "008c8a13df77a28f3445213a0f432fde644acaa215fc72dcdf300d5efaa85d350c";

        final String CHAIN_CODE3 = "a320425f77d1b5c2505a6b1b27382b37368ee640e3557c315416801243552f14";
        final String PRIVATE_KEY3 = "b1d0bad404bf35da785a64ca1ac54b2617211d2777696fbffaf208f746ae84f2";
        final String PUBLIC_KEY3 = "001932a5270f335bed617d5b935c80aedb1a35bd9fc1e31acafd5372c30f5c1187";

        final String CHAIN_CODE4 = "2e69929e00b5ab250f49c3fb1c12f252de4fed2c1db88387094a0f8c4c9ccd6c";
        final String PRIVATE_KEY4 = "92a5b23c0b8a99e37d07df3fb9966917f5d06e02ddbd909c7e184371463e9fc9";
        final String PUBLIC_KEY4 = "00ae98736566d30ed0e9d2f4486a64bc95740d89c7db33f52121f8ea8f76ff0fc1";

        final String CHAIN_CODE5 = "8f6d87f93d750e0efccda017d662a1b31a266e4a6f5993b15f5c1f07f74dd5cc";
        final String PRIVATE_KEY5 = "30d1dc7e5fc04c31219ab25a27ae00b50f6fd66622f6e9c913253d6511d1e662";
        final String PUBLIC_KEY5 = "008abae2d66361c879b900d204ad2cc4984fa2aa344dd7ddc46007329ac76c429c";

        final String CHAIN_CODE6 = "68789923a0cac2cd5a29172a475fe9e0fb14cd6adb5ad98a3fa70333e7afa230";
        final String PRIVATE_KEY6 = "8f94d394a8e8fd6b1bc2f3f49f5c47e385281d5c17e65324b0f62483e37e8793";
        final String PUBLIC_KEY6 = "003c24da049451555d51a7014a37337aa4e12d41e485abccfa46b47dfb2af54b7a";

        var seed = hexStringToByteArray("000102030405060708090a0b0c0d0e0f");

        // Chain m
        PrivateKey key1 = PrivateKey.fromSeedED25519(seed);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/0'
        PrivateKey key2 = key1.derive(0);
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/0'/1'
        PrivateKey key3 = key2.derive(1);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/0'/1'/2'
        PrivateKey key4 = key3.derive(2);
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);

        // Chain m/0'/1'/2'/2'
        PrivateKey key5 = key4.derive(2);
        assertThat(Hex.toHexString(key5.getChainCode().getKey())).isEqualTo(CHAIN_CODE5);
        assertThat(key5.toStringRaw()).isEqualTo(PRIVATE_KEY5);
        assertThat(key5.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY5);

        // Chain m/0'/1'/2'/2'/1000000000'
        PrivateKey key6 = key5.derive(1000000000);
        assertThat(Hex.toHexString(key6.getChainCode().getKey())).isEqualTo(CHAIN_CODE6);
        assertThat(key6.toStringRaw()).isEqualTo(PRIVATE_KEY6);
        assertThat(key6.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY6);
    }

    @Test
    @DisplayName("SLIP10 test vector 2")
    void slip10TestVector2() {
        // https://github.com/satoshilabs/slips/blob/master/slip-0010.md#test-vector-2-for-ed25519
        final String CHAIN_CODE1 = "ef70a74db9c3a5af931b5fe73ed8e1a53464133654fd55e7a66f8570b8e33c3b";
        final String PRIVATE_KEY1 = "171cb88b1b3c1db25add599712e36245d75bc65a1a5c9e18d76f9f2b1eab4012";
        final String PUBLIC_KEY1 = "008fe9693f8fa62a4305a140b9764c5ee01e455963744fe18204b4fb948249308a";

        final String CHAIN_CODE2 = "0b78a3226f915c082bf118f83618a618ab6dec793752624cbeb622acb562862d";
        final String PRIVATE_KEY2 = "1559eb2bbec5790b0c65d8693e4d0875b1747f4970ae8b650486ed7470845635";
        final String PUBLIC_KEY2 = "0086fab68dcb57aa196c77c5f264f215a112c22a912c10d123b0d03c3c28ef1037";

        final String CHAIN_CODE3 = "138f0b2551bcafeca6ff2aa88ba8ed0ed8de070841f0c4ef0165df8181eaad7f";
        final String PRIVATE_KEY3 = "ea4f5bfe8694d8bb74b7b59404632fd5968b774ed545e810de9c32a4fb4192f4";
        final String PUBLIC_KEY3 = "005ba3b9ac6e90e83effcd25ac4e58a1365a9e35a3d3ae5eb07b9e4d90bcf7506d";

        final String CHAIN_CODE4 = "73bd9fff1cfbde33a1b846c27085f711c0fe2d66fd32e139d3ebc28e5a4a6b90";
        final String PRIVATE_KEY4 = "3757c7577170179c7868353ada796c839135b3d30554bbb74a4b1e4a5a58505c";
        final String PUBLIC_KEY4 = "002e66aa57069c86cc18249aecf5cb5a9cebbfd6fadeab056254763874a9352b45";

        final String CHAIN_CODE5 = "0902fe8a29f9140480a00ef244bd183e8a13288e4412d8389d140aac1794825a";
        final String PRIVATE_KEY5 = "5837736c89570de861ebc173b1086da4f505d4adb387c6a1b1342d5e4ac9ec72";
        final String PUBLIC_KEY5 = "00e33c0f7d81d843c572275f287498e8d408654fdf0d1e065b84e2e6f157aab09b";

        final String CHAIN_CODE6 = "5d70af781f3a37b829f0d060924d5e960bdc02e85423494afc0b1a41bbe196d4";
        final String PRIVATE_KEY6 = "551d333177df541ad876a60ea71f00447931c0a9da16f227c11ea080d7391b8d";
        final String PUBLIC_KEY6 = "0047150c75db263559a70d5778bf36abbab30fb061ad69f69ece61a72b0cfa4fc0";

        var seed = hexStringToByteArray("fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542");

        // Chain m
        PrivateKey key1 = PrivateKey.fromSeedED25519(seed);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/0'
        PrivateKey key2 = key1.derive(0);
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/0'/2147483647'
        PrivateKey key3 = key2.derive(2147483647);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/0'/2147483647'/1'
        PrivateKey key4 = key3.derive(1);
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);

        // Chain m/0'/2147483647'/1'/2147483646'
        PrivateKey key5 = key4.derive(2147483646);
        assertThat(Hex.toHexString(key5.getChainCode().getKey())).isEqualTo(CHAIN_CODE5);
        assertThat(key5.toStringRaw()).isEqualTo(PRIVATE_KEY5);
        assertThat(key5.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY5);

        // Chain m/0'/2147483647'/1'/2147483646'/2'
        PrivateKey key6 = key5.derive(2);
        assertThat(Hex.toHexString(key6.getChainCode().getKey())).isEqualTo(CHAIN_CODE6);
        assertThat(key6.toStringRaw()).isEqualTo(PRIVATE_KEY6);
        assertThat(key6.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY6);
    }

    @Test
    @DisplayName("PEM import test vectors")
    void PEMImportTestVectors() throws IOException {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PRIVATE_KEY_PEM1 = "-----BEGIN PRIVATE KEY-----\n" +
            "MC4CAQAwBQYDK2VwBCIEIOgbjaHgEqF7PY0t2dUf2VU0u1MRoKii/fywDlze4lvl\n" +
            "-----END PRIVATE KEY-----";
        var PRIVATE_KEY1 = "e81b8da1e012a17b3d8d2dd9d51fd95534bb5311a0a8a2fdfcb00e5cdee25be5";
        var PUBLIC_KEY1 = "f7b9aa4a8e4eee94e4277dfe757d8d7cde027e7cd5349b7d8e6ee21c9b9395be";

        var PRIVATE_KEY_PEM2 = "-----BEGIN ENCRYPTED PRIVATE KEY-----\n" +
            "MIGbMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAiho4GvPxvL6wICCAAw\n" +
            "DAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEIdsubXR0QvxXGSprqDuDXwEQJZl\n" +
            "OBtwm2p2P7WrWE0OnjGxUe24fWwdrvJUuguFtH3FVWc8C5Jbxgbyxsuzbf+utNL6\n" +
            "0ey+WdbGL06Bw0HGqs8=\n" +
            "-----END ENCRYPTED PRIVATE KEY-----";
        var PRIVATE_KEY2 = "fa0857e963946d5f5e035684c40354d3cd3dcc80c0fb77beac2ef7c4b5271599";
        var PUBLIC_KEY2 = "202af61e141465d4bf2c356d37d18bd026c246bde4eb73258722ad11f790be4e";

        var ed25519PrivateKey1 = PrivateKey.fromPem(PRIVATE_KEY_PEM1);
        assertThat(ed25519PrivateKey1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(ed25519PrivateKey1.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY1);

        var ed25519PrivateKey2 = PrivateKey.fromPem(PRIVATE_KEY_PEM2, TEST_VECTOR_PEM_PASSPHRASE);
        assertThat(ed25519PrivateKey2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(ed25519PrivateKey2.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY2);
    }

    @Test
    @DisplayName("DER import test vectors")
    void DERImportTestVectors() {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PRIVATE_KEY_DER1 = "302e020100300506032b657004220420feb858a4a69600a5eef2d9c76f7fb84fc0b6627f29e0ab17e160f640c267d404";
        var PRIVATE_KEY1 = "feb858a4a69600a5eef2d9c76f7fb84fc0b6627f29e0ab17e160f640c267d404";
        var PUBLIC_KEY1 = "8ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d";

        var ed25519PrivateKey1 = PrivateKey.fromStringDER(PRIVATE_KEY_DER1);
        assertThat(ed25519PrivateKey1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(ed25519PrivateKey1.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY1);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/Ed25519PublicKeyTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.math.BigDecimal;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatNoException;

class Ed25519PublicKeyTest {
    private static final String TEST_KEY_STR = "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7";
    private static final String TEST_KEY_STR_RAW = "e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7";

    @Test
    void verifyTransaction() {
        var transaction = new TransferTransaction()
                .setNodeAccountIds(Collections.singletonList(new AccountId(3)))
                .setTransactionId(TransactionId.generate(new AccountId(4)))
                .freeze();

        var key = PrivateKey.fromStringED25519("8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048");
        key.signTransaction(transaction);

        assertThat(key.getPublicKey().verifyTransaction(transaction)).isTrue();
    }

    @Test
    @DisplayName("public key can be recovered from bytes")
    void keyByteSerialization() {
        PublicKey key1 = PrivateKey.generateED25519().getPublicKey();
        byte[] key1Bytes = key1.toBytes();
        PublicKey key2 = PublicKey.fromBytes(key1Bytes);
        byte[] key2Bytes = key2.toBytes();

        assertThat(key2Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("public key can be recovered from raw bytes")
    void keyByteSerialization2() {
        PublicKey key1 = PrivateKey.generateED25519().getPublicKey();
        byte[] key1Bytes = key1.toBytesRaw();
        PublicKey key2 = PublicKey.fromBytesED25519(key1Bytes);
        byte[] key2Bytes = key2.toBytesRaw();
        PublicKey key3 = PublicKey.fromBytes(key1Bytes);
        byte[] key3Bytes = key3.toBytesRaw();

        assertThat(key2Bytes).containsExactly(key1Bytes);
        assertThat(key3Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("public key can be recovered from DER bytes")
    void keyByteSerialization3() {
        PublicKey key1 = PrivateKey.generateED25519().getPublicKey();
        byte[] key1Bytes = key1.toBytesDER();
        PublicKey key2 = PublicKey.fromBytesDER(key1Bytes);
        byte[] key2Bytes = key2.toBytesDER();
        PublicKey key3 = PublicKey.fromBytes(key1Bytes);
        byte[] key3Bytes = key3.toBytesDER();

        assertThat(key2Bytes).containsExactly(key1Bytes);
        assertThat(key3Bytes).containsExactly(key1Bytes);
    }

    @Test
    @DisplayName("public key can be recovered after transaction serialization")
    void keyByteSerializationThroughTransaction() {
        var senderAccount = AccountId.fromString("0.0.1337");
        var receiverAccount = AccountId.fromString("0.0.3");
        var transferAmount = Hbar.from(new BigDecimal("0.0001"), HbarUnit.HBAR);
        var privateKey = PrivateKey.generateED25519();
        var client = Client.forTestnet()
            .setOperator(senderAccount, privateKey);
        var tx = new TransferTransaction()
            .addHbarTransfer(senderAccount, transferAmount.negated())
            .addHbarTransfer(receiverAccount, transferAmount);

        tx.freezeWith(client);
        tx.signWithOperator(client);

        var bytes = tx.toBytes();

        assertThatNoException().isThrownBy(() -> Transaction.fromBytes(bytes));
        assertThat(tx.getSignatures()).isNotEmpty();
    }

    @Test
    @DisplayName("public key can be recovered from string")
    void keyStringSerialization() {
        PublicKey key1 = PrivateKey.generateED25519().getPublicKey();
        String key1Str = key1.toString();
        PublicKey key2 = PublicKey.fromString(key1Str);
        String key2Str = key2.toString();
        PublicKey key3 = PublicKey.fromString(key1Str);
        String key3Str = key3.toString();

        assertThat(key3.getClass()).isEqualTo(PublicKeyED25519.class);
        assertThat(key2Str).isEqualTo(key1Str);
        assertThat(key3Str).isEqualTo(key1Str);
    }

    @Test
    @DisplayName("public key can be recovered from raw string")
    void keyStringSerialization2() {
        PublicKey key1 = PrivateKey.generateED25519().getPublicKey();
        String key1Str = key1.toStringRaw();
        PublicKey key2 = PublicKey.fromStringED25519(key1Str);
        String key2Str = key2.toStringRaw();
        PublicKey key3 = PublicKey.fromString(key1Str);
        String key3Str = key3.toStringRaw();

        assertThat(key3.getClass()).isEqualTo(PublicKeyED25519.class);
        assertThat(key2Str).isEqualTo(key1Str);
        assertThat(key3Str).isEqualTo(key1Str);
    }

    @Test
    @DisplayName("public key can be recovered from DER string")
    void keyStringSerialization3() {
        PublicKey key1 = PrivateKey.generateED25519().getPublicKey();
        String key1Str = key1.toStringDER();
        PublicKey key2 = PublicKey.fromStringDER(key1Str);
        String key2Str = key2.toStringDER();
        PublicKey key3 = PublicKey.fromString(key1Str);
        String key3Str = key3.toStringDER();

        assertThat(key3.getClass()).isEqualTo(PublicKeyED25519.class);
        assertThat(key2Str).isEqualTo(key1Str);
        assertThat(key3Str).isEqualTo(key1Str);
    }

    @ParameterizedTest
    @DisplayName("public key can be recovered from external string")
    @ValueSource(strings = {
        // ASN1 encoded hex
        "302a300506032b6570032100e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
        // raw hex
        "e0c8ec2758a5879ffac226a13c0c516b799e72e35141a0dd828f94d37988a4b7",
    })
    void externalKeyDeserialize(String keyStr) {
        PublicKey key = PublicKey.fromString(keyStr);
        assertThat(key).isNotNull();
        // the above are all the same key
        assertThat(key.toString()).isEqualTo(TEST_KEY_STR);
        assertThat(key.toStringDER()).isEqualTo(TEST_KEY_STR);
        assertThat(key.toStringRaw()).isEqualTo(TEST_KEY_STR_RAW);
    }

    @Test
    @DisplayName("public key can be encoded to a string")
    void keyToString() {
        PublicKey key = PublicKey.fromString(TEST_KEY_STR);

        assertThat(key).isNotNull();
        assertThat(key.toString()).isEqualTo(TEST_KEY_STR);
    }

    @Test
    @DisplayName("public key is is ED25519")
    void keyIsECDSA() {
        PublicKey key = PrivateKey.generateED25519().getPublicKey();

        assertThat(key.isED25519()).isTrue();
    }

    @Test
    @DisplayName("public key is is not ECDSA")
    void keyIsNotEd25519() {
        PublicKey key = PrivateKey.generateED25519().getPublicKey();

        assertThat(key.isECDSA()).isFalse();
    }

    @Test
    @DisplayName("DER import test vectors")
    void DERImportTestVectors() {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/93#issue-1665972122
        var PUBLIC_KEY_DER1 = "302a300506032b65700321008ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d";
        var PUBLIC_KEY1 = "8ccd31b53d1835b467aac795dab19b274dd3b37e3daf12fcec6bc02bac87b53d";

        var ed25519PublicKey1 = PublicKey.fromStringDER(PUBLIC_KEY_DER1);
        assertThat(ed25519PublicKey1.toStringRaw()).isEqualTo(PUBLIC_KEY1);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/EthereumFlowMockTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.FileID;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionGetReceiptResponse;
import com.hedera.hashgraph.sdk.proto.TransactionReceipt;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import static org.assertj.core.api.Assertions.assertThat;

class EthereumFlowMockTest {
    static ByteString ETHEREUM_DATA = ByteString.fromHex("f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792");

    static ByteString LONG_CALL_DATA = ByteString.fromHex("00".repeat(5121));

    @Test
    void dontTruncateEthereumDataUnnecessarily() throws PrecheckStatusException, TimeoutException, InterruptedException, ReceiptStatusException {
        List<Object> responses1 = List.of(
                (Function<Object, Object>) o -> {
                    var signedTransaction = SignedTransaction.parseFrom(((Transaction) o).getSignedTransactionBytes());
                    var transactionBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
                    assertThat(transactionBody.getDataCase()).isEqualByComparingTo(TransactionBody.DataCase.ETHEREUMTRANSACTION);
                    assertThat(transactionBody.hasEthereumTransaction()).isTrue();
                    assertThat(transactionBody.getEthereumTransaction().getEthereumData()).isEqualTo(ETHEREUM_DATA);
                    return TransactionResponse.newBuilder().setNodeTransactionPrecheckCodeValue(0).build();
                },
                Response.newBuilder()
                        .setTransactionGetReceipt(TransactionGetReceiptResponse.newBuilder()
                                .setReceipt(TransactionReceipt.newBuilder().setStatusValue(ResponseCodeEnum.SUCCESS_VALUE))
                        ).build()
        );

        var responses = List.of(responses1);

        try (var mocker = Mocker.withResponses(responses)) {
            new EthereumFlow()
                    .setEthereumData(ETHEREUM_DATA.toByteArray())
                    .execute(mocker.client)
                    .getReceipt(mocker.client);
        }
    }

    @ParameterizedTest(name = "[{0}] ContractCreateFlow functions")
    @CsvSource({
        "sync",
        "async"
    })
    void extractsCallData(String versionToTest) throws PrecheckStatusException, TimeoutException, InterruptedException, ReceiptStatusException, ExecutionException {
        List<Object> responses1 = List.of(
                (Function<Object, Object>) o -> {
                    var signedTransaction = SignedTransaction.parseFrom(((Transaction) o).getSignedTransactionBytes());
                    var transactionBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
                    assertThat(transactionBody.getDataCase()).isEqualByComparingTo(TransactionBody.DataCase.FILECREATE);
                    assertThat(transactionBody.hasFileCreate()).isTrue();
                    assertThat(transactionBody.getFileCreate().getContents().size()).isEqualTo(4096);
                    return TransactionResponse.newBuilder().setNodeTransactionPrecheckCodeValue(0).build();
                },
                Response.newBuilder()
                        .setTransactionGetReceipt(TransactionGetReceiptResponse.newBuilder()
                                .setReceipt(TransactionReceipt.newBuilder()
                                        .setStatusValue(ResponseCodeEnum.SUCCESS_VALUE)
                                        .setFileID(FileID.newBuilder().setFileNum(1)
                                        ))).build(),
                (Function<Object, Object>) o -> {
                    var signedTransaction = SignedTransaction.parseFrom(((Transaction) o).getSignedTransactionBytes());
                    var transactionBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
                    assertThat(transactionBody.getDataCase()).isEqualByComparingTo(TransactionBody.DataCase.FILEAPPEND);
                    assertThat(transactionBody.hasFileAppend()).isTrue();
                    assertThat(transactionBody.getFileAppend().hasFileID()).isTrue();
                    assertThat(transactionBody.getFileAppend().getFileID().getFileNum()).isEqualTo(1);
                    assertThat(transactionBody.getFileAppend().getContents()).isEqualTo(LONG_CALL_DATA.substring(4096));
                    return TransactionResponse.newBuilder().setNodeTransactionPrecheckCodeValue(0).build();
                },
                Response.newBuilder()
                        .setTransactionGetReceipt(TransactionGetReceiptResponse.newBuilder()
                                .setReceipt(TransactionReceipt.newBuilder().setStatusValue(ResponseCodeEnum.SUCCESS_VALUE))
                        ).build(),
                (Function<Object, Object>) o -> {
                    var signedTransaction = SignedTransaction.parseFrom(((Transaction) o).getSignedTransactionBytes());
                    var transactionBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
                    assertThat(transactionBody.getDataCase()).isEqualByComparingTo(TransactionBody.DataCase.ETHEREUMTRANSACTION);
                    assertThat(transactionBody.hasEthereumTransaction()).isTrue();
                    assertThat(EthereumTransactionData.fromBytes(transactionBody.getEthereumTransaction().getEthereumData().toByteArray()).callData).isEmpty();
                    return TransactionResponse.newBuilder().setNodeTransactionPrecheckCodeValue(0).build();
                },
                Response.newBuilder()
                        .setTransactionGetReceipt(TransactionGetReceiptResponse.newBuilder()
                                .setReceipt(TransactionReceipt.newBuilder().setStatusValue(ResponseCodeEnum.SUCCESS_VALUE))
                        ).build()
        );

        var responses = List.of(responses1);

        EthereumFlow ethereumFlow;
        try (var mocker = Mocker.withResponses(responses)) {
            var ethereumData = EthereumTransactionData.fromBytes(ETHEREUM_DATA.toByteArray());
            ethereumData.callData = LONG_CALL_DATA.toByteArray();

            if (versionToTest.equals("sync")) {
                ethereumFlow = new EthereumFlow()
                    .setMaxGasAllowance(Hbar.fromTinybars(25))
                    .setEthereumData(ethereumData.toBytes());

                ethereumFlow
                    .execute(mocker.client)
                    .getReceipt(mocker.client);
            } else {
                ethereumFlow = new EthereumFlow()
                    .setMaxGasAllowance(Hbar.fromTinybars(25))
                    .setEthereumData(ethereumData.toBytes());

                ethereumFlow
                    .executeAsync(mocker.client)
                    .thenCompose(response -> response.getReceiptAsync(mocker.client))
                    .get();
            }

            assertThat(ethereumFlow.getEthereumData()).isNotNull();
            assertThat(ethereumFlow.getMaxGasAllowance().toTinybars()).isEqualTo(25);
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/EthereumTransactionDataLegacyTest.java
package com.hedera.hashgraph.sdk;

import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class EthereumTransactionDataLegacyTest {
    // https://github.com/hashgraph/hedera-services/blob/1e01d9c6b8923639b41359c55413640b589c4ec7/hapi-utils/src/test/java/com/hedera/services/ethereum/EthTxDataTest.java#L49
    static final String RAW_TX_TYPE_0 =
        "f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792";
    static final String RAW_TX_TYPE_0_TRIMMED_LAST_BYTES =
        "f864012f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc18180827653820277a0f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2fa00c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290000";
    static final String RAW_TX_TYPE_2 =
        "02f87082012a022f2f83018000947e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181880de0b6b3a764000083123456c001a0df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479a01aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66";

    @Test
    public void legacyToFromBytes() {
        var data = (EthereumTransactionDataLegacy) EthereumTransactionData.fromBytes(Hex.decode(RAW_TX_TYPE_0));
        assertThat(RAW_TX_TYPE_0).isEqualTo(Hex.toHexString(data.toBytes()));

        // Chain ID is not part of the legacy ethereum transaction, so why are you calculating and checking it?
        // assertEquals("012a", Hex.toHexString(data.chainId()));

        assertThat(Hex.toHexString(data.nonce)).isEqualTo("01");
        assertThat(Hex.toHexString(data.gasPrice)).isEqualTo("2f");
        assertThat(Hex.toHexString(data.gasLimit)).isEqualTo("018000");
        assertThat(Hex.toHexString(data.to)).isEqualTo("7e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181");
        assertThat(Hex.toHexString(data.value)).isEqualTo("");
        assertThat(Hex.toHexString(data.callData)).isEqualTo("7653");
        assertThat(Hex.toHexString(data.v)).isEqualTo("0277");
        assertThat(Hex.toHexString(data.r)).isEqualTo("f9fbff985d374be4a55f296915002eec11ac96f1ce2df183adf992baa9390b2f");
        assertThat(Hex.toHexString(data.s)).isEqualTo("0c1e867cc960d9c74ec2e6a662b7908ec4c8cc9f3091e886bcefbeb2290fb792");

        // We don't currently support a way to get the ethereum has, but we probably should
        // assertEquals("9ffbd69c44cf643ed8d1e756b505e545e3b5dd3a6b5ef9da1d8eca6679706594",
        //    Hex.toHexString(data.getEthereumHash()));
    }

    @Test
    public void eip1559ToFromBytes() {
        var data = (EthereumTransactionDataEip1559) EthereumTransactionData.fromBytes(Hex.decode(RAW_TX_TYPE_2));
        assertThat(RAW_TX_TYPE_2).isEqualTo(Hex.toHexString(data.toBytes()));

        assertThat(Hex.toHexString(data.chainId)).isEqualTo("012a");
        assertThat(Hex.toHexString(data.nonce)).isEqualTo("02");
        assertThat(Hex.toHexString(data.maxPriorityGas)).isEqualTo("2f");
        assertThat(Hex.toHexString(data.maxGas)).isEqualTo("2f");
        assertThat(Hex.toHexString(data.gasLimit)).isEqualTo("018000");
        assertThat(Hex.toHexString(data.to)).isEqualTo("7e3a9eaf9bcc39e2ffa38eb30bf7a93feacbc181");
        assertThat(Hex.toHexString(data.value)).isEqualTo("0de0b6b3a7640000");
        assertThat(Hex.toHexString(data.callData)).isEqualTo("123456");
        assertThat(Hex.toHexString(data.accessList)).isEqualTo("");
        assertThat(Hex.toHexString(data.recoveryId)).isEqualTo("01");
        assertThat(Hex.toHexString(data.r)).isEqualTo("df48f2efd10421811de2bfb125ab75b2d3c44139c4642837fb1fccce911fd479");
        assertThat(Hex.toHexString(data.s)).isEqualTo("1aaf7ae92bee896651dfc9d99ae422a296bf5d9f1ca49b2d96d82b79eb112d66");
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/EthereumTransactionTest.java
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class EthereumTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    EthereumTransaction spawnTestTransaction() {
        return new EthereumTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setEthereumData(Hex.decode("deadbeef"))
            .setCallDataFileId(FileId.fromString("4.5.6"))
            .setMaxGasAllowanceHbar(Hbar.fromString("3"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    @Test
    void shouldBytesNft() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx2.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ExchangeRatesTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class ExchangeRatesTest {
    private static final String exchangeRateSetHex = "0a1008b0ea0110b6b4231a0608f0bade9006121008b0ea01108cef231a060880d7de9006";

    @Test
    void fromProtobuf() throws InvalidProtocolBufferException {
        byte[] exchangeRatesBytes = Hex.decode(exchangeRateSetHex);

        ExchangeRates exchangeRates = ExchangeRates.fromBytes(exchangeRatesBytes);

        assertThat(exchangeRates.currentRate.cents).isEqualTo(580150);
        assertThat(exchangeRates.currentRate.hbars).isEqualTo(30000);
        Instant currentExpirationTime = Instant.ofEpochSecond(1645714800);
        assertThat(exchangeRates.currentRate.expirationTime).isEqualTo(currentExpirationTime);
        assertThat(exchangeRates.currentRate.exchangeRateInCents).isEqualTo(19.338333333333335);

        assertThat(exchangeRates.nextRate.cents).isEqualTo(587660);
        assertThat(exchangeRates.nextRate.hbars).isEqualTo(30000);
        Instant nextExpirationTime = Instant.ofEpochSecond(1645718400);
        assertThat(exchangeRates.nextRate.expirationTime).isEqualTo(nextExpirationTime);
        assertThat(exchangeRates.nextRate.exchangeRateInCents).isEqualTo(19.588666666666665);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ExecutableTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.grpc.MethodDescriptor;
import io.grpc.StatusRuntimeException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.stubbing.Answer;

import javax.annotation.Nullable;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class ExecutableTest {
    Client client;
    Network network;
    Node node3, node4, node5;
    List<AccountId> nodeAccountIds;

    @BeforeEach
    void setup() {
        client = Client.forMainnet();
        network = mock(Network.class);
        client.network = network;
        client.setLogger(new Logger(LogLevel.WARN));

        node3 = mock(Node.class);
        node4 = mock(Node.class);
        node5 = mock(Node.class);

        when(node3.getAccountId()).thenReturn(new AccountId(3));
        when(node4.getAccountId()).thenReturn(new AccountId(4));
        when(node5.getAccountId()).thenReturn(new AccountId(5));
        when(network.getNodeProxies(new AccountId(3))).thenReturn(List.of(node3));
        when(network.getNodeProxies(new AccountId(4))).thenReturn(List.of(node4));
        when(network.getNodeProxies(new AccountId(5))).thenReturn(List.of(node5));

        nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
    }

    @Test
    void firstNodeHealthy() {
        when(node3.isHealthy()).thenReturn(true);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));

        var node = tx.getNodeForExecute(1);
        assertThat(node).isEqualTo(node3);
    }


    @Test
    void calloptionsShouldRespectGrpcDeadline() {
        when(node3.isHealthy()).thenReturn(true);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));
        tx.setGrpcDeadline(Duration.ofSeconds(10));

        var grpcRequest = tx.getGrpcRequest(1);

        var timeRemaining = grpcRequest.getCallOptions().getDeadline().timeRemaining(TimeUnit.MILLISECONDS);
        assertThat(timeRemaining).isLessThan(10000);
        assertThat(timeRemaining).isGreaterThan(9000);
    }

    @Test
    void executableShouldUseGrpcDeadline() throws InterruptedException, PrecheckStatusException, TimeoutException {
        when(node3.isHealthy()).thenReturn(true);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));
        tx.setMaxAttempts(10);

        var timeout = Duration.ofSeconds(5);
        var currentTimeRemaining = new AtomicLong(timeout.toMillis());
        final long minimumRetryDelayMs = 100;
        final long defaultDeadlineMs = timeout.toMillis() - (minimumRetryDelayMs * (tx.getMaxAttempts() / 2));

        // later on when the transaction is executed its grpc deadline should not be modified...
        tx.setGrpcDeadline(Duration.ofMillis(defaultDeadlineMs));

        tx.blockingUnaryCall = (grpcRequest) -> {
            var grpc = (Executable.GrpcRequest) grpcRequest;

            var grpcTimeRemaining = grpc.getCallOptions().getDeadline().timeRemaining(TimeUnit.MILLISECONDS);

            // the actual grpc deadline should be no larger than the smaller of the two values -
            // the default transaction level grpc deadline and the remaining timeout
            assertThat(grpcTimeRemaining).isLessThanOrEqualTo(defaultDeadlineMs);
            assertThat(grpcTimeRemaining).isLessThanOrEqualTo(currentTimeRemaining.get());

            assertThat(grpcTimeRemaining).isGreaterThan(0);

            // transaction's grpc deadline should keep its original value
            assertThat(tx.grpcDeadline().toMillis()).isEqualTo(defaultDeadlineMs);

            currentTimeRemaining.set(currentTimeRemaining.get() - minimumRetryDelayMs);

            if (currentTimeRemaining.get() > 0) {
                try {
                    Thread.sleep(minimumRetryDelayMs);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                // Status.UNAVAILABLE tells the Executable to retry the request
                throw new StatusRuntimeException(io.grpc.Status.UNAVAILABLE);
            }

            throw new StatusRuntimeException(io.grpc.Status.ABORTED);
        };

        assertThatExceptionOfType(MaxAttemptsExceededException.class).isThrownBy(() -> {
            tx.execute(client, timeout);
        });
    }

    @Test
    void multipleNodesUnhealthy() {
        when(node3.isHealthy()).thenReturn(false);
        when(node4.isHealthy()).thenReturn(true);

        when(node3.getRemainingTimeForBackoff()).thenReturn(1000L);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));

        var node = tx.getNodeForExecute(1);
        assertThat(node).isEqualTo(node4);
    }

    @Test
    void allNodesUnhealthy() {
        when(node3.isHealthy()).thenReturn(false);
        when(node4.isHealthy()).thenReturn(false);
        when(node5.isHealthy()).thenReturn(false);

        when(node3.getRemainingTimeForBackoff()).thenReturn(4000L);
        when(node4.getRemainingTimeForBackoff()).thenReturn(3000L);
        when(node5.getRemainingTimeForBackoff()).thenReturn(5000L);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));
        tx.nodeAccountIds.setIndex(1);

        var node = tx.getNodeForExecute(1);
        assertThat(node).isEqualTo(node4);
    }

    @Test
    void multipleRequestsWithSingleHealthyNode() {
        when(node3.isHealthy()).thenReturn(true);
        when(node4.isHealthy()).thenReturn(false);
        when(node5.isHealthy()).thenReturn(false);

        when(node4.getRemainingTimeForBackoff()).thenReturn(4000L);
        when(node5.getRemainingTimeForBackoff()).thenReturn(3000L);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));

        var node = tx.getNodeForExecute(1);
        assertThat(node).isEqualTo(node3);
        tx.nodeAccountIds.advance();
        tx.nodes.advance();

        node = tx.getNodeForExecute(2);
        assertThat(node).isEqualTo(node3);
        verify(node4).getRemainingTimeForBackoff();
        verify(node5).getRemainingTimeForBackoff();
    }

    @Test
    void multipleRequestsWithNoHealthyNodes() {
        AtomicInteger i = new AtomicInteger();

        when(node3.isHealthy()).thenReturn(false);
        when(node4.isHealthy()).thenReturn(false);
        when(node5.isHealthy()).thenReturn(false);

        long[] node3Times = {4000, 3000, 1000};
        long[] node4Times = {3000, 1000, 4000};
        long[] node5Times = {1000, 3000, 4000};

        when(node3.getRemainingTimeForBackoff()).thenAnswer((Answer<Long>) invocation -> node3Times[i.get()]);
        when(node4.getRemainingTimeForBackoff()).thenAnswer((Answer<Long>) invocation -> node4Times[i.get()]);
        when(node5.getRemainingTimeForBackoff()).thenAnswer((Answer<Long>) invocation -> node5Times[i.get()]);

        var tx = new DummyTransaction();
        tx.setNodeAccountIds(nodeAccountIds);
        tx.setNodesFromNodeAccountIds(client);
        tx.setMinBackoff(Duration.ofMillis(10));
        tx.setMaxBackoff(Duration.ofMillis(1000));

        var node = tx.getNodeForExecute(1);
        assertThat(node).isEqualTo(node5);
        i.incrementAndGet();

        node = tx.getNodeForExecute(2);
        assertThat(node).isEqualTo(node4);
        i.incrementAndGet();

        node = tx.getNodeForExecute(3);
        assertThat(node).isEqualTo(node3);
    }

    @Test
    void successfulExecute() throws PrecheckStatusException, TimeoutException {
        var now = java.time.Instant.now();
        var tx = new DummyTransaction() {
            @Nullable
            @Override
            TransactionResponse mapResponse(com.hedera.hashgraph.sdk.proto.TransactionResponse response,
                AccountId nodeId, com.hedera.hashgraph.sdk.proto.Transaction request) {
                return new TransactionResponse(
                    new AccountId(3),
                    TransactionId.withValidStart(new AccountId(3), now),
                    new byte[]{1, 2, 3},
                    null)
                    .setValidateStatus(true);
            }
        };

        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);

        var txResp =
            com.hedera.hashgraph.sdk.proto.TransactionResponse
                .newBuilder()
                .setNodeTransactionPrecheckCode(ResponseCodeEnum.OK)
                .build();

        tx.blockingUnaryCall = (grpcRequest) -> txResp;
        com.hedera.hashgraph.sdk.TransactionResponse resp = (com.hedera.hashgraph.sdk.TransactionResponse) tx.execute(
            client);

        assertThat(resp.nodeId).isEqualTo(new AccountId(3));
        assertThat(resp.getValidateStatus()).isTrue();
        assertThat(resp.toString()).isNotNull();
    }

    @Test
    void executeWithChannelFailure() throws PrecheckStatusException, TimeoutException {
        when(node3.isHealthy()).thenReturn(true);
        when(node4.isHealthy()).thenReturn(true);

        when(node3.channelFailedToConnect(any(Instant.class))).thenReturn(true);
        when(node4.channelFailedToConnect(any(Instant.class))).thenReturn(false);

        var now = java.time.Instant.now();
        var tx = new DummyTransaction() {
            @Nullable
            @Override
            TransactionResponse mapResponse(com.hedera.hashgraph.sdk.proto.TransactionResponse response,
                AccountId nodeId, com.hedera.hashgraph.sdk.proto.Transaction request) {
                return new TransactionResponse(
                    new AccountId(4),
                    TransactionId.withValidStart(new AccountId(4), now),
                    new byte[]{1, 2, 3},
                    null);
            }
        };

        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);

        var txResp =
            com.hedera.hashgraph.sdk.proto.TransactionResponse
                .newBuilder()
                .setNodeTransactionPrecheckCode(ResponseCodeEnum.OK)
                .build();

        tx.blockingUnaryCall = (grpcRequest) -> txResp;
        com.hedera.hashgraph.sdk.TransactionResponse resp = (com.hedera.hashgraph.sdk.TransactionResponse) tx.execute(
            client);

        verify(node3).channelFailedToConnect(any(Instant.class));
        verify(node4).channelFailedToConnect(any(Instant.class));
        assertThat(resp.nodeId).isEqualTo(new AccountId(4));
    }

    @Test
    void executeWithAllUnhealthyNodes() throws PrecheckStatusException, TimeoutException {
        AtomicInteger i = new AtomicInteger();

        // 1st round, pick node3, fail channel connect
        // 2nd round, pick node4, fail channel connect
        // 3rd round, pick node5, fail channel connect
        // 4th round, pick node 3, wait for delay, channel connect ok
        when(node3.isHealthy()).thenAnswer((Answer<Boolean>) inv -> i.get() == 0);
        when(node4.isHealthy()).thenAnswer((Answer<Boolean>) inv -> i.get() == 0);
        when(node5.isHealthy()).thenAnswer((Answer<Boolean>) inv -> i.get() == 0);

        when(node3.channelFailedToConnect(any(Instant.class))).thenAnswer((Answer<Boolean>) inv -> i.get() == 0);
        when(node4.channelFailedToConnect(any(Instant.class))).thenAnswer((Answer<Boolean>) inv -> i.get() == 0);
        when(node5.channelFailedToConnect(any(Instant.class))).thenAnswer(
            (Answer<Boolean>) inv -> i.getAndIncrement() == 0);

        when(node3.getRemainingTimeForBackoff()).thenReturn(500L);
        when(node4.getRemainingTimeForBackoff()).thenReturn(600L);
        when(node5.getRemainingTimeForBackoff()).thenReturn(700L);

        var now = java.time.Instant.now();
        var tx = new DummyTransaction() {
            @Nullable
            @Override
            TransactionResponse mapResponse(com.hedera.hashgraph.sdk.proto.TransactionResponse response,
                AccountId nodeId, com.hedera.hashgraph.sdk.proto.Transaction request) {
                return new TransactionResponse(
                    new AccountId(3),
                    TransactionId.withValidStart(new AccountId(3), now),
                    new byte[]{1, 2, 3},
                    null);
            }
        };

        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);

        var txResp =
            com.hedera.hashgraph.sdk.proto.TransactionResponse
                .newBuilder()
                .setNodeTransactionPrecheckCode(ResponseCodeEnum.OK)
                .build();

        tx.blockingUnaryCall = (grpcRequest) -> txResp;
        com.hedera.hashgraph.sdk.TransactionResponse resp = (com.hedera.hashgraph.sdk.TransactionResponse) tx.execute(
            client);

        verify(node3, times(2)).channelFailedToConnect(any(Instant.class));
        verify(node4).channelFailedToConnect(any(Instant.class));
        verify(node5).channelFailedToConnect(any(Instant.class));
        assertThat(resp.nodeId).isEqualTo(new AccountId(3));
    }

    @Test
    void executeExhaustRetries() {
        when(node3.isHealthy()).thenReturn(true);
        when(node4.isHealthy()).thenReturn(true);
        when(node5.isHealthy()).thenReturn(true);

        when(node3.channelFailedToConnect(any(Instant.class))).thenReturn(true);
        when(node4.channelFailedToConnect(any(Instant.class))).thenReturn(true);
        when(node5.channelFailedToConnect(any(Instant.class))).thenReturn(true);

        var tx = new DummyTransaction();
        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);
        assertThatExceptionOfType(MaxAttemptsExceededException.class).isThrownBy(() -> tx.execute(client));
    }

    @Test
    void executeRetriableErrorDuringCall() {
        AtomicInteger i = new AtomicInteger();

        when(node3.isHealthy()).thenReturn(true);
        when(node4.isHealthy()).thenReturn(true);

        when(node3.channelFailedToConnect(any(Instant.class))).thenReturn(false);
        when(node4.channelFailedToConnect(any(Instant.class))).thenReturn(false);

        var tx = new DummyTransaction();
        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);

        tx.blockingUnaryCall = (grpcRequest) -> {
            if (i.getAndIncrement() == 0) {
                throw new StatusRuntimeException(io.grpc.Status.UNAVAILABLE);
            } else {
                throw new StatusRuntimeException(io.grpc.Status.ABORTED);
            }
        };

        assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> tx.execute(client));

        verify(node3).channelFailedToConnect(any(Instant.class));
        verify(node4).channelFailedToConnect(any(Instant.class));
    }

    @Test
    void testChannelFailedToConnectTimeout() {
        TransactionResponse transactionResponse = new TransactionResponse(
            new AccountId(3),
            TransactionId.withValidStart(new AccountId(3), java.time.Instant.now()),
            new byte[]{1, 2, 3},
            null
        );
        var tx = new DummyTransaction();

        tx.blockingUnaryCall = (grpcRequest) -> {
            throw new StatusRuntimeException(io.grpc.Status.UNAVAILABLE);
        };

        when(node3.isHealthy()).thenReturn(true);
        when(node3.channelFailedToConnect(any(Instant.class))).thenReturn(true);

        assertThatExceptionOfType(MaxAttemptsExceededException.class).isThrownBy(
            () -> transactionResponse.getReceipt(client, Duration.ofSeconds(2)));
    }

    @Test
    void executeQueryDelay() throws PrecheckStatusException, TimeoutException {
        when(node3.isHealthy()).thenReturn(true);
        when(node4.isHealthy()).thenReturn(true);

        when(node3.channelFailedToConnect()).thenReturn(false);
        when(node4.channelFailedToConnect()).thenReturn(false);

        AtomicInteger i = new AtomicInteger();
        var tx = new DummyQuery() {
            @Override
            Status mapResponseStatus(com.hedera.hashgraph.sdk.proto.Response response) {
                return Status.RECEIPT_NOT_FOUND;
            }

            @Override
            ExecutionState getExecutionState(Status status, Response response) {
                return i.getAndIncrement() == 0 ? ExecutionState.RETRY : ExecutionState.SUCCESS;
            }
        };
        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);

        var receipt = com.hedera.hashgraph.sdk.proto.TransactionReceipt.newBuilder()
            .setStatus(ResponseCodeEnum.OK)
            .build();
        var receiptResp = com.hedera.hashgraph.sdk.proto.TransactionGetReceiptResponse.newBuilder()
            .setReceipt(receipt)
            .build();

        var resp = Response.newBuilder().setTransactionGetReceipt(receiptResp).build();
        tx.blockingUnaryCall = (grpcRequest) -> resp;
        tx.execute(client);

        verify(node3).channelFailedToConnect(any(Instant.class));
        verify(node4).channelFailedToConnect(any(Instant.class));
    }


    @Test
    void executeUserError() throws PrecheckStatusException, TimeoutException {
        when(node3.isHealthy()).thenReturn(true);
        when(node3.channelFailedToConnect()).thenReturn(false);

        var tx = new DummyTransaction() {
            @Override
            Status mapResponseStatus(com.hedera.hashgraph.sdk.proto.TransactionResponse response) {
                return Status.ACCOUNT_DELETED;
            }
        };
        var nodeAccountIds = Arrays.asList(
            new AccountId(3),
            new AccountId(4),
            new AccountId(5)
        );
        tx.setNodeAccountIds(nodeAccountIds);

        var txResp =
            com.hedera.hashgraph.sdk.proto.TransactionResponse
                .newBuilder()
                .setNodeTransactionPrecheckCode(ResponseCodeEnum.ACCOUNT_DELETED)
                .build();

        tx.blockingUnaryCall = (grpcRequest) -> txResp;
        assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> tx.execute(client));

        verify(node3).channelFailedToConnect(any(Instant.class));
    }

    @Test
    @SuppressFBWarnings(
        value = "NP_NONNULL_PARAM_VIOLATION",
        justification = "Cannot make TransactionResponse constructor public"
    )
    void shouldRetryReturnsCorrectStates() {
        var tx = new DummyTransaction();

        assertThat(tx.getExecutionState(Status.PLATFORM_TRANSACTION_NOT_CREATED, null)).isEqualTo(
            ExecutionState.SERVER_ERROR);
        assertThat(tx.getExecutionState(Status.PLATFORM_NOT_ACTIVE, null)).isEqualTo(ExecutionState.SERVER_ERROR);
        assertThat(tx.getExecutionState(Status.BUSY, null)).isEqualTo(ExecutionState.RETRY);
        assertThat(tx.getExecutionState(Status.OK, null)).isEqualTo(ExecutionState.SUCCESS);
        assertThat(tx.getExecutionState(Status.ACCOUNT_DELETED, null)).isEqualTo(ExecutionState.REQUEST_ERROR);
    }

    @Test
    void shouldSetMaxRetry() {
        var tx = new DummyTransaction();

        tx.setMaxRetry(1);

        assertThat(tx.getMaxRetry()).isEqualTo(1);

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> tx.setMaxRetry(0));
    }

    static class DummyTransaction<T extends Transaction<T>>
        extends
        Executable<T, com.hedera.hashgraph.sdk.proto.Transaction, com.hedera.hashgraph.sdk.proto.TransactionResponse, com.hedera.hashgraph.sdk.TransactionResponse> {

        @Override
        void onExecute(Client client) {
        }

        @Nullable
        @Override
        CompletableFuture<Void> onExecuteAsync(Client client) {
            return null;
        }

        @Nullable
        @Override
        com.hedera.hashgraph.sdk.proto.Transaction makeRequest() {
            return null;
        }

        @Nullable
        @Override
        TransactionResponse mapResponse(com.hedera.hashgraph.sdk.proto.TransactionResponse response, AccountId nodeId,
            com.hedera.hashgraph.sdk.proto.Transaction request) {
            return null;
        }

        @Override
        Status mapResponseStatus(com.hedera.hashgraph.sdk.proto.TransactionResponse response) {
            return Status.OK;
        }

        @Nullable
        @Override
        MethodDescriptor<com.hedera.hashgraph.sdk.proto.Transaction, com.hedera.hashgraph.sdk.proto.TransactionResponse> getMethodDescriptor() {
            return null;
        }

        @Nullable
        @Override
        TransactionId getTransactionIdInternal() {
            return null;
        }
    }

    static class DummyQuery extends Query<TransactionReceipt, TransactionReceiptQuery> {
        @Override
        void onExecute(Client client) {
        }

        @Override
        TransactionReceipt mapResponse(Response response, AccountId nodeId,
            com.hedera.hashgraph.sdk.proto.Query request) {
            return null;
        }

        @Override
        Status mapResponseStatus(com.hedera.hashgraph.sdk.proto.Response response) {
            return Status.OK;
        }

        @Override
        MethodDescriptor<com.hedera.hashgraph.sdk.proto.Query, Response> getMethodDescriptor() {
            return null;
        }

        @Override
        void onMakeRequest(com.hedera.hashgraph.sdk.proto.Query.Builder queryBuilder, QueryHeader header) {
        }

        @Override
        ResponseHeader mapResponseHeader(Response response) {
            return null;
        }

        @Override
        QueryHeader mapRequestHeader(com.hedera.hashgraph.sdk.proto.Query request) {
            return null;
        }

        @Override
        void validateChecksums(Client client) {
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FeeAssessmentMethodTest.java
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class FeeAssessmentMethodTest {
    @Test
    void feeAssessmentMethodToString() {
        assertThat(FeeAssessmentMethod.valueOf(true))
            .hasToString(FeeAssessmentMethod.EXCLUSIVE.toString());
        assertThat(FeeAssessmentMethod.valueOf(false))
            .hasToString(FeeAssessmentMethod.INCLUSIVE.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FeeSchedulesTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class FeeSchedulesTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    FeeSchedules spawnFeeSchedulesExample() {
        return new FeeSchedules()
            .setCurrent(new FeeSchedule()
                .setExpirationTime(Instant.ofEpochSecond(1554158542))
                .addTransactionFeeSchedule(new TransactionFeeSchedule()
                    .addFee(new FeeData()
                        .setNodeData(new FeeComponents())
                        .setNetworkData(new FeeComponents()
                            .setMin(2)
                            .setMax(5)
                        )
                        .setServiceData(new FeeComponents())
                    )
                )
            )
            .setNext(new FeeSchedule()
                .setExpirationTime(Instant.ofEpochSecond(1554158222))
                .addTransactionFeeSchedule(new TransactionFeeSchedule()
                    .addFee(new FeeData()
                        .setNodeData(new FeeComponents()
                            .setMin(1)
                            .setMax(2)
                        )
                        .setNetworkData(new FeeComponents())
                        .setServiceData(new FeeComponents())
                    )
                )
            );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalFeeSchedules = spawnFeeSchedulesExample();
        byte[] feeSchedulesBytes = originalFeeSchedules.toBytes();
        var copyFeeSchedules = FeeSchedules.fromBytes(feeSchedulesBytes);
        assertThat(copyFeeSchedules.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalFeeSchedules.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalFeeSchedules.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void shouldSerializeNull() throws Exception {
        var originalFeeSchedules = new FeeSchedules();
        byte[] feeSchedulesBytes = originalFeeSchedules.toBytes();
        var copyFeeSchedules = FeeSchedules.fromBytes(feeSchedulesBytes);
        assertThat(copyFeeSchedules.toString()).isEqualTo(originalFeeSchedules.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileAppendTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FileAppendTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class FileAppendTransactionTest {
    public static final String BIG_CONTENTS = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.\n" +
        "\n" +
        "Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.\n" +
        "\n" +
        "Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.\n" +
        "\n" +
        "Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.\n" +
        "\n" +
        "Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.\n" +
        "\n" +
        "Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.\n" +
        "\n" +
        "Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.\n" +
        "\n" +
        "Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.\n" +
        "\n" +
        "Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.\n" +
        "\n" +
        "In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.\n" +
        "\n" +
        "Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.\n" +
        "\n" +
        "Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.\n" +
        "\n" +
        "Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.\n" +
        "\n" +
        "Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.\n" +
        "\n" +
        "Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.\n" +
        "\n" +
        "Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.\n" +
        "\n" +
        "Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.\n" +
        "\n" +
        "Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.\n" +
        "\n" +
        "Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.\n" +
        "\n" +
        "Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.\n" +
        "\n" +
        "Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.\n" +
        "\n" +
        "In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\n" +
        "\n" +
        "Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.\n";
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final PrivateKey secondPrivateKey = PrivateKey.fromString(
        "302e020100300506032b65700422042099b8587e5abccf6999b0d42b88c581c45284290450487ce90095561c85af11e4"
    );
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction(Collections.singletonList(AccountId.fromString("0.0.5005")))
            .toString()
        ).toMatchSnapshot();
    }

    private FileAppendTransaction spawnTestTransaction(List<AccountId> accountIds) {
        return new FileAppendTransaction()
            .setNodeAccountIds(accountIds)
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(FileId.fromString("0.0.6006"))
            .setContents(new byte[]{1, 2, 3, 4})
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerializeBigContents() {
        var nodeAccountIds = new ArrayList<AccountId>();
        nodeAccountIds.add(AccountId.fromString("0.0.444"));
        nodeAccountIds.add(AccountId.fromString("0.0.555"));

        SnapshotMatcher.expect(spawnTestTransactionBigContents(nodeAccountIds)
            .toString()
        ).toMatchSnapshot();
    }

    private FileAppendTransaction spawnTestTransactionBigContents(ArrayList<AccountId> nodeAccountIds) {
        return new FileAppendTransaction()
            .setNodeAccountIds(nodeAccountIds)
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(FileId.fromString("0.0.6006"))
            .setContents(BIG_CONTENTS)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    String hashesToString(List<Map<AccountId, byte[]>> hashes) {
        var outString = new StringBuilder();
        outString.append("[");
        for (var tx : hashes) {
            outString.append("{");
            for (var entry : tx.entrySet()) {
                outString.append(entry.getKey().toString()).append("=").append(Hex.toHexString(entry.getValue())).append(", ");
            }
            outString.append("}, ");
        }
        return outString + "]";
    }

    @Test
    void shouldHash() {
        var nodeAccountIds = new ArrayList<AccountId>();
        nodeAccountIds.add(AccountId.fromString("0.0.444"));
        nodeAccountIds.add(AccountId.fromString("0.0.555"));

        SnapshotMatcher.expect(
            hashesToString(spawnTestTransactionBigContents(nodeAccountIds)
                .getAllTransactionHashesPerNode()
            )
        ).toMatchSnapshot();
    }

    String signaturesToString(Map<AccountId, Map<PublicKey, byte[]>> signatures) {
        var outString = new StringBuilder();
        outString.append("{");
        for (var nodeEntry : signatures.entrySet()) {
            outString.append(nodeEntry.getKey()).append("={");
            for (var sigEntry : nodeEntry.getValue().entrySet()) {
                outString.append(sigEntry.getKey()).append("=").append(Hex.toHexString(sigEntry.getValue())).append(", ");
            }
            outString.append("}, ");
        }
        return outString + "}";
    }

    String allSignaturesToString(List<Map<AccountId, Map<PublicKey, byte[]>>> allSignatures) {
        var outString = new StringBuilder();
        outString.append("[");
        for (var txEntry : allSignatures) {
            outString.append(signaturesToString(txEntry)).append(", ");
        }
        return outString + "]";
    }

    @Test
    void shouldGetSignatures() {
        var nodeAccountIds = new ArrayList<AccountId>();
        nodeAccountIds.add(AccountId.fromString("0.0.444"));
        nodeAccountIds.add(AccountId.fromString("0.0.555"));
        var signatures = spawnTestTransaction(nodeAccountIds)
            .sign(secondPrivateKey)
            .getSignatures();
        SnapshotMatcher.expect(signaturesToString(signatures)).toMatchSnapshot();
    }

    @Test
    void shouldGetAllSignatures() {
        var nodeAccountIds = new ArrayList<AccountId>();
        nodeAccountIds.add(AccountId.fromString("0.0.444"));
        nodeAccountIds.add(AccountId.fromString("0.0.555"));
        var signatures = spawnTestTransactionBigContents(nodeAccountIds)
            .sign(secondPrivateKey)
            .getAllSignatures();
        SnapshotMatcher.expect(allSignaturesToString(signatures)).toMatchSnapshot();
    }

    @Test
    void shouldBytes() throws Exception {
        var nodeAccountIds = new ArrayList<AccountId>();
        nodeAccountIds.add(AccountId.fromString("0.0.444"));
        nodeAccountIds.add(AccountId.fromString("0.0.555"));
        var tx = spawnTestTransactionBigContents(nodeAccountIds);
        var tx2 = FileAppendTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());

        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> tx2.getTransactionHash());
        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> tx2.getTransactionHashPerNode());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setFileAppend(FileAppendTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(FileAppendTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileContentsQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class FileContentsQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new FileContentsQuery()
            .setFileId(FileId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FileCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class FileCreateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private FileCreateTransaction spawnTestTransaction() {
        return new FileCreateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContents(new byte[]{1, 2, 3, 4})
            .setExpirationTime(Instant.ofEpochSecond(1554158728))
            .setKeys(unusedPrivateKey)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setFileMemo("Hello memo")
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = FileCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setFileCreate(FileCreateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(FileCreateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FileDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class FileDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private FileDeleteTransaction spawnTestTransaction() {
        return new FileDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(FileId.fromString("0.0.6006"))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = FileDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setFileDelete(FileDeleteTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(FileDeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

class FileIdTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFromString() {
        SnapshotMatcher.expect(FileId.fromString("0.0.5005").toString()).toMatchSnapshot();
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(Hex.toHexString(new FileId(5005).toBytes())).toMatchSnapshot();
    }


    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(FileId.fromBytes(new FileId(5005).toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddress() {
        SnapshotMatcher.expect(FileId.fromSolidityAddress("000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void toSolidityAddress() {
        SnapshotMatcher.expect(new FileId(5005).toSolidityAddress()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileInfoQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class FileInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new FileInfoQuery()
            .setFileId(FileId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileInfoTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.FileGetInfoResponse;
import com.hedera.hashgraph.sdk.proto.KeyList;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;


public class FileInfoTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final FileGetInfoResponse.FileInfo info = FileGetInfoResponse.FileInfo.newBuilder()
        .setFileID(new FileId(1).toProtobuf())
        .setSize(2)
        .setExpirationTime(InstantConverter.toProtobuf(Instant.ofEpochMilli(3)))
        .setDeleted(true)
        .setKeys(KeyList.newBuilder()
            .addKeys(privateKey.getPublicKey().toProtobufKey()))
        .setLedgerId(LedgerId.MAINNET.toByteString())
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(FileInfo.fromProtobuf(info).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(FileInfo.fromProtobuf(info).toProtobuf().toString())
            .toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(FileInfo.fromBytes(info.toByteArray()).toString())
            .toMatchSnapshot();
    }

    @Test
    void toBytes() {
        SnapshotMatcher.expect(Hex.toHexString(FileInfo.fromProtobuf(info).toBytes()))
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FileUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.FileUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class FileUpdateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private FileUpdateTransaction spawnTestTransaction() {
        return new FileUpdateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(FileId.fromString("0.0.6006"))
            .setExpirationTime(Instant.ofEpochSecond(1554158728))
            .setContents(new byte[]{1, 2, 3, 4, 5})
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setKeys(unusedPrivateKey)
            .setFileMemo("Hello memo")
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = FileUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setFileUpdate(FileUpdateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(FileUpdateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/FreezeTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.FreezeTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class FreezeTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final FileId testFileId = FileId.fromString("4.5.6");
    private static final byte[] testFileHash = Hex.decode("1723904587120938954702349857");
    private static final FreezeType testFreezeType = FreezeType.TELEMETRY_UPGRADE;

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private FreezeTransaction spawnTestTransaction() {
        return new FreezeTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(testFileId).setFileHash(testFileHash).setStartTime(validStart).setFreezeType(testFreezeType)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000)).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = FreezeTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setFreeze(FreezeTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(FreezeTransaction.class);
    }

    @Test
    void constructFreezeTransactionFromTransactionBodyProtobuf() {
        var transactionBody = FreezeTransactionBody.newBuilder().setUpdateFile(testFileId.toProtobuf())
            .setFileHash(ByteString.copyFrom(testFileHash))
            .setStartTime(Timestamp.newBuilder().setSeconds(validStart.getEpochSecond()))
            .setFreezeType(testFreezeType.code);

        var tx = TransactionBody.newBuilder().setFreeze(transactionBody).build();
        var freezeTransaction = new FreezeTransaction(tx);

        assertNotNull(freezeTransaction.getFileId());
        assertThat(freezeTransaction.getFileId()).isEqualTo(testFileId);
        assertThat(freezeTransaction.getFileHash()).isEqualTo(testFileHash);
        assertNotNull(freezeTransaction.getStartTime());
        assertThat(freezeTransaction.getStartTime().getEpochSecond()).isEqualTo(validStart.getEpochSecond());
        assertThat(freezeTransaction.getFreezeType()).isEqualTo(testFreezeType);
    }

    @Test
    void getSetFileId() {
        var freezeTransaction = new FreezeTransaction().setFileId(testFileId);
        assertNotNull(freezeTransaction.getFileId());
        assertThat(freezeTransaction.getFileId()).isEqualTo(testFileId);
    }

    @Test
    void getSetFileIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setFileId(testFileId));
    }

    @Test
    void getSetFileHash() {
        var freezeTransaction = new FreezeTransaction().setFileHash(testFileHash);
        assertNotNull(freezeTransaction.getFileHash());
        assertThat(freezeTransaction.getFileHash()).isEqualTo(testFileHash);
    }

    @Test
    void getSetFileHashFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setFileHash(testFileHash));
    }

    @Test
    void getSetStartTime() {
        var freezeTransaction = new FreezeTransaction().setStartTime(validStart);
        assertNotNull(freezeTransaction.getStartTime());
        assertThat(freezeTransaction.getStartTime().getEpochSecond()).isEqualTo(validStart.getEpochSecond());
    }

    @Test
    void getSetStartTimeFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setStartTime(validStart));
    }

    @Test
    void getSetFreezeType() {
        var freezeTransaction = new FreezeTransaction().setFreezeType(testFreezeType);
        assertThat(freezeTransaction.getFreezeType()).isEqualTo(testFreezeType);
    }

    @Test
    void getSetFreezeTypeFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setFreezeType(testFreezeType));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/Function.java
package com.hedera.hashgraph.sdk;

public interface Function<T, R> {
    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t) throws Throwable;
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/HbarTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.math.BigDecimal;
import java.util.Iterator;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class HbarTest {
    private static final long fiftyGTinybar = 5_000_000_000L;
    private final Hbar fiftyHbar = Hbar.fromTinybars(fiftyGTinybar);

    private final Hbar hundredHbar = new Hbar(100);

    private final Hbar negativeFiftyHbar = new Hbar(-50);

    static Iterator<Arguments> getValueConversions() {
        return List.of(
            Arguments.arguments(new BigDecimal(50_000_000), HbarUnit.MICROBAR),
            Arguments.arguments(new BigDecimal(50_000), HbarUnit.MILLIBAR),
            Arguments.arguments(new BigDecimal(50), HbarUnit.HBAR),
            Arguments.arguments(new BigDecimal("0.05"), HbarUnit.KILOBAR),
            Arguments.arguments(new BigDecimal("0.00005"), HbarUnit.MEGABAR),
            Arguments.arguments(new BigDecimal("0.00000005"), HbarUnit.GIGABAR)
        ).iterator();
    }

    @Test
    void shouldConstruct() {
        assertThat(fiftyHbar.toTinybars()).isEqualTo(fiftyGTinybar);
        assertThat(fiftyHbar.to(HbarUnit.HBAR)).isEqualTo(new BigDecimal(50));
        assertThat(new Hbar(50).toTinybars()).isEqualTo(fiftyGTinybar);
        assertThat(Hbar.fromTinybars(fiftyGTinybar).toTinybars()).isEqualTo(fiftyGTinybar);
    }

    @Test
    void shouldNotConstruct() {
        assertThatExceptionOfType(Exception.class).isThrownBy(() -> new Hbar(new BigDecimal("0.1"), HbarUnit.TINYBAR));
    }

    @Test
    void shouldDisplay() {
        assertThat(fiftyHbar.toString()).isEqualTo("50 ");
        assertThat(negativeFiftyHbar.toString()).isEqualTo("-50 ");
        assertThat(Hbar.fromTinybars(1).toString()).isEqualTo("1 t");
        assertThat(Hbar.fromTinybars(1).negated().toString()).isEqualTo("-1 t");
        assertThat(Hbar.fromTinybars(1000).toString()).isEqualTo("1000 t");
        assertThat(Hbar.fromTinybars(1000).negated().toString()).isEqualTo("-1000 t");
    }

    @ParameterizedTest
    @MethodSource("getValueConversions")
    void shouldConvert(BigDecimal value, HbarUnit unit) {
        assertThat(Hbar.from(value, unit)).isEqualTo(fiftyHbar);
        assertThat(fiftyHbar.to(unit)).isEqualTo(value);
    }

    @Test
    void shouldCompare() {
        assertThat(fiftyHbar).isEqualTo(fiftyHbar);
        assertThat(fiftyHbar).isNotEqualTo(hundredHbar);

        assertThat(fiftyHbar.compareTo(new Hbar(50))).isEqualTo(0);

        assertThat(fiftyHbar.compareTo(hundredHbar)).isLessThan(0);
        assertThat(hundredHbar.compareTo(fiftyHbar)).isGreaterThan(0);

        assertThat(fiftyHbar.compareTo(negativeFiftyHbar)).isGreaterThan(0);
    }

    @Test
    void constructorWorks() {
        new Hbar(1);
    }

    @Test
    void fromString() {
        assertThat(Hbar.fromString("1").toTinybars()).isEqualTo(100_000_000);
        assertThat(Hbar.fromString("1 ").toTinybars()).isEqualTo(100_000_000);
        assertThat(Hbar.fromString("1.5 m").toTinybars()).isEqualTo(150_000);
        assertThat(Hbar.fromString("+1.5 m").toTinybars()).isEqualTo(150_000);
        assertThat(Hbar.fromString("-1.5 m").toTinybars()).isEqualTo(-150_000);
        assertThat(Hbar.fromString("+3").toTinybars()).isEqualTo(300_000_000);
        assertThat(Hbar.fromString("-3").toTinybars()).isEqualTo(-300_000_000);
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            Hbar.fromString("1 h");
        });
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            Hbar.fromString("1");
        });
    }

    @Test
    void fromStringUnit() {
        assertThat(Hbar.fromString("1", HbarUnit.TINYBAR).toTinybars()).isEqualTo(1);
    }

    @Test
    void from() {
        assertThat(Hbar.from(1).toTinybars()).isEqualTo(100000000);
    }

    @Test
    void fromUnit() {
        assertThat(Hbar.from(1, HbarUnit.TINYBAR).toTinybars()).isEqualTo(1);
    }

    @Test
    void getValue() {
        assertThat(new Hbar(1).getValue()).isEqualTo(BigDecimal.valueOf(1));
    }

    @Test
    void hasHashCode() {
        assertThat(new Hbar(1).hashCode()).isEqualTo(100000031);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/HederaTrustManagerTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Map;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class HederaTrustManagerTest {
    public static final String PREVIEWNET_CERT_NODE_3_STRING = "-----BEGIN CERTIFICATE-----\n" +
        "MIICnzCCAiWgAwIBAgIUenyqJ4UaFBbwokatcUqAwW3o3rswCgYIKoZIzj0EAwMw\n" +
        "gYQxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJUWDETMBEGA1UEBwwKUmljaGFyZHNv\n" +
        "bjEPMA0GA1UECgwGSGVkZXJhMQ8wDQYDVQQLDAZIZWRlcmExEDAOBgNVBAMMBzAw\n" +
        "MDAwMDAxHzAdBgkqhkiG9w0BCQEWEGFkbWluQGhlZGVyYS5jb20wIBcNMjEwODIz\n" +
        "MjIyMTU4WhgPMjI5NTA2MDcyMjIxNThaMIGEMQswCQYDVQQGEwJVUzELMAkGA1UE\n" +
        "CAwCVFgxEzARBgNVBAcMClJpY2hhcmRzb24xDzANBgNVBAoMBkhlZGVyYTEPMA0G\n" +
        "A1UECwwGSGVkZXJhMRAwDgYDVQQDDAcwMDAwMDAwMR8wHQYJKoZIhvcNAQkBFhBh\n" +
        "ZG1pbkBoZWRlcmEuY29tMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEm5b1+oG9R0qt\n" +
        "zM7UZnS5l/xxUNHIHq5+NAvtlviCpJL19jrW9+/UOy00Qqc6vS6tS1hS+dNJmpiZ\n" +
        "FN0EHew4VDR7ACnL4LDJKmIHWjQ0iwvZo5kCpO0r9BtPN5FvaSxyo1QwUjAPBgNV\n" +
        "HREECDAGhwR/AAABMAsGA1UdDwQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAd\n" +
        "BgNVHQ4EFgQUeciBviJtjeuue0GPf1xllNw7qvYwCgYIKoZIzj0EAwMDaAAwZQIw\n" +
        "JeG0H2HdsI1VhOYmJmYlNeKCNgAk+LMorzPmsIInVBO2HK2IrKfpReWDS/m5j51V\n" +
        "AjEAxKBxDezJDqAZHTkTXCg+X9Q9V6J6M5yDy5IS90aCWEo+W8C1Hc6hkn2/NrvT\n" +
        "PhwK\n" +
        "-----END CERTIFICATE-----\n";

    public static final ByteArrayInputStream PREVIEWNET_CERT_NODE_3_BYTES = new ByteArrayInputStream(PREVIEWNET_CERT_NODE_3_STRING.getBytes(StandardCharsets.UTF_8));

    public static final CertificateFactory CERTIFICATE_FACTORY;

    static {
        try {
            CERTIFICATE_FACTORY = CertificateFactory.getInstance("X.509");
        } catch (CertificateException e) {
            throw new RuntimeException(e);
        }
    }

    public static final X509Certificate PREVIEWNET_CERT_NODE_3;

    static {
        try {
            PREVIEWNET_CERT_NODE_3 = (X509Certificate) CERTIFICATE_FACTORY.generateCertificate(PREVIEWNET_CERT_NODE_3_BYTES);
        } catch (CertificateException e) {
            throw new RuntimeException(e);
        }
    }

    static final X509Certificate[] CERTIFICATE_CHAIN = new X509Certificate[]{PREVIEWNET_CERT_NODE_3};

    @Test
    void skipsCheckIfVerificationIsDisabled() throws CertificateException {
        new HederaTrustManager(ByteString.EMPTY, false).checkServerTrusted(CERTIFICATE_CHAIN, "");
    }

    @Test
    void skipsCheckIfCertificateIsNotProvided() throws CertificateException {
        new HederaTrustManager(null, false).checkServerTrusted(CERTIFICATE_CHAIN, "");
    }

    @Test
    void throwsErrorIfCertificateIsNotProvidedButVerificationIsRequired() {
        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> new HederaTrustManager(null, true));
    }

    @Test
    void properlyChecksCertificateAgainstCurrentNetworkAddressBook() throws InterruptedException, CertificateException {
        var client = Client.forNetwork(Map.of("0.previewnet.hedera.com:50211", new AccountId(3)))
            .setTransportSecurity(true)
            .setVerifyCertificates(true)
            .setLedgerId(LedgerId.PREVIEWNET);

        var nodeAddress = Objects.requireNonNull(Objects.requireNonNull(client.network.addressBook).get(new AccountId(3)));
        new HederaTrustManager(nodeAddress.getCertHash(), client.isVerifyCertificates()).checkServerTrusted(CERTIFICATE_CHAIN, "");
    }

    @Test
    void certificateCheckFailWhenHashMismatches() throws InterruptedException, CertificateException {
        var client = Client.forNetwork(Map.of("0.previewnet.hedera.com:50211", new AccountId(3)))
            .setTransportSecurity(true)
            .setVerifyCertificates(true)
            .setLedgerId(LedgerId.PREVIEWNET);

        var nodeAddress = Objects.requireNonNull(Objects.requireNonNull(client.network.addressBook).get(new AccountId(4)));
        assertThatExceptionOfType(CertificateException.class).isThrownBy(() -> new HederaTrustManager(nodeAddress.getCertHash(), client.isVerifyCertificates()).checkServerTrusted(CERTIFICATE_CHAIN, ""));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/KeyListTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.Key;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class KeyListTest {

    private static final PublicKey mTestPublicKey1 = PrivateKey.fromStringED25519(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10")
        .getPublicKey();

    private static final PublicKey mTestPublicKey2 = PrivateKey.fromStringED25519(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11")
        .getPublicKey();

    private static final PublicKey mTestPublicKey3 = PrivateKey.fromStringED25519(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12")
        .getPublicKey();

    @Test
    @DisplayName("fromProtobuf")
    void fromProtobuf() {
        // Given
        var protoKey1 = Key.newBuilder().setEd25519(ByteString.copyFrom(mTestPublicKey1.toBytes())).build();
        var protoKey3 = Key.newBuilder().setEd25519(ByteString.copyFrom(mTestPublicKey2.toBytes())).build();
        var protoKey2 = Key.newBuilder().setEd25519(ByteString.copyFrom(mTestPublicKey3.toBytes())).build();
        var protoKeyList = com.hedera.hashgraph.sdk.proto.KeyList.newBuilder()
            .addAllKeys(List.of(protoKey1, protoKey2, protoKey3)).build();

        // When
        var keyList = KeyList.fromProtobuf(protoKeyList, 3);

        // Then
        assertTrue(keyList.contains(mTestPublicKey1));
        assertTrue(keyList.contains(mTestPublicKey2));
        assertTrue(keyList.contains(mTestPublicKey3));
    }

    @Test
    @DisplayName("ofKeys")
    void ofKeys() {
        // Given / When
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);

        // Then
        assertTrue(keyList.contains(mTestPublicKey1));
        assertTrue(keyList.contains(mTestPublicKey2));
        assertTrue(keyList.contains(mTestPublicKey3));
    }

    @Test
    @DisplayName("toProtobufKey")
    void toProtobufKey() {
        // Given
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);

        // When
        var protoKey = keyList.toProtobufKey();

        // Then
        assertThat(protoKey.getKeyList().getKeysCount()).isEqualTo(3);
        assertThat(protoKey.getKeyList().getKeys(0).getEd25519().toByteArray()).isEqualTo(mTestPublicKey1.toBytesRaw());
        assertThat(protoKey.getKeyList().getKeys(1).getEd25519().toByteArray()).isEqualTo(mTestPublicKey2.toBytesRaw());
        assertThat(protoKey.getKeyList().getKeys(2).getEd25519().toByteArray()).isEqualTo(mTestPublicKey3.toBytesRaw());
    }

    @Test
    @DisplayName("toProtobuf")
    void toProtobuf() {
        // Given
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);

        // When
        var protoKeyList = keyList.toProtobuf();

        // Then
        assertThat(protoKeyList.getKeysCount()).isEqualTo(3);
        assertThat(protoKeyList.getKeys(0).getEd25519().toByteArray()).isEqualTo(
            mTestPublicKey1.toBytesRaw());
        assertThat(protoKeyList.getKeys(1).getEd25519().toByteArray()).isEqualTo(
            mTestPublicKey2.toBytesRaw());
        assertThat(protoKeyList.getKeys(2).getEd25519().toByteArray()).isEqualTo(
            mTestPublicKey3.toBytesRaw());
    }

    @Test
    @DisplayName("size")
    void size() {
        // Given / When
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);
        var emptyKeyList = new KeyList();

        // Then
        assertThat(keyList).hasSize(3);
        assertThat(emptyKeyList).isEmpty();
    }

    @Test
    @DisplayName("contains")
    void contains() {
        // Given / When
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);
        var emptyKeyList = new KeyList();

        // Then
        assertTrue(keyList.contains(mTestPublicKey1));
        assertTrue(keyList.contains(mTestPublicKey2));
        assertTrue(keyList.contains(mTestPublicKey3));

        assertFalse(emptyKeyList.contains(mTestPublicKey1));
        assertFalse(emptyKeyList.contains(mTestPublicKey2));
        assertFalse(emptyKeyList.contains(mTestPublicKey3));
    }

    @Test
    @DisplayName("add")
    void add() {
        // Given
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2);

        // When
        keyList.add(mTestPublicKey3);

        // Then
        assertThat(keyList).hasSize(3);
        assertTrue(keyList.contains(mTestPublicKey3));
    }

    @Test
    @DisplayName("remove")
    void remove() {
        // Given
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);

        // When
        keyList.remove(mTestPublicKey1);

        // Then
        assertThat(keyList).hasSize(2);
        assertFalse(keyList.contains(mTestPublicKey1));
        assertTrue(keyList.contains(mTestPublicKey2));
        assertTrue(keyList.contains(mTestPublicKey3));
    }

    @Test
    @DisplayName("clear")
    void clear() {
        // Given
        var keyList = KeyList.of(mTestPublicKey1, mTestPublicKey2, mTestPublicKey3);

        // When
        keyList.clear();

        // Then
        assertTrue(keyList.isEmpty());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/KeyTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.Key;
import com.hedera.hashgraph.sdk.proto.KeyList;
import com.hedera.hashgraph.sdk.proto.ThresholdKey;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigInteger;
import java.util.List;

import static com.hedera.hashgraph.sdk.Key.fromBytes;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.assertj.core.api.Assertions.assertThatNoException;

class KeyTest {
    @Test
    @DisplayName("can sign and verify a message")
    void signatureVerified() {
        var message = "Hello, World".getBytes(UTF_8);
        var privateKey = PrivateKey.generateED25519();
        var publicKey = privateKey.getPublicKey();
        var signature = privateKey.sign(message);

        assertThat(signature.length).isEqualTo(64);
        assertThat(publicKey.verify(message, signature)).isTrue();
    }

    @Test
    @DisplayName("can sign and verify a message with ECDSA")
    void signatureVerifiedECDSA() {
        var message = "Hello, World".getBytes(UTF_8);
        var privateKey = PrivateKey.generateECDSA();
        var publicKey = privateKey.getPublicKey();
        var signature = privateKey.sign(message);
        assertThat(signature.length).isEqualTo(64);
        assertThat(publicKey.verify(message, signature)).isTrue();
        // muck with the signature a little and make sure it breaks
        signature[5] += 1;
        assertThat(publicKey.verify(message, signature)).isFalse();
    }

    @Test
    @DisplayName("Calculated recId is either 0 or 1 for ECDSA secp256k1 curve")
    void calculateRecoveryIdECDSA() {
        var message = "Hello, World".getBytes(UTF_8);
        var privateKey = PrivateKey.generateECDSA();
        var signature = privateKey.sign(message);
        // wrap in signature object
        final byte[] r = new byte[32];
        System.arraycopy(signature, 0, r, 0, 32);
        final byte[] s = new byte[32];
        System.arraycopy(signature, 32, s, 0, 32);
        var recId = ((PrivateKeyECDSA) privateKey).getRecoveryId(r,s,message);
        assertThat(recId).isBetween(0,1);
    }

    @Test
    @DisplayName("Fail to calculate recId for ECDSA with illegal inputs")
    void failToCalculateRecoveryIdWithIllegalInputDataECDSA() {
        // create signature
        var message = "Hello, World".getBytes(UTF_8);
        var privateKey = PrivateKey.generateECDSA();
        var signature = privateKey.sign(message);
        final byte[] r = new byte[32];
        System.arraycopy(signature, 0, r, 0, 32);
        final byte[] s = new byte[32];
        System.arraycopy(signature, 32, s, 0, 32);
        // recover public key with recId > 1
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> Crypto.recoverPublicKeyECDSAFromSignature(2, BigInteger.ONE, BigInteger.ONE, Crypto.calcKeccak256(message))
        );
        // recover public key with negative 'r' or 's'
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> Crypto.recoverPublicKeyECDSAFromSignature(0, BigInteger.valueOf(-1), BigInteger.ONE, Crypto.calcKeccak256(message))
        );
        // calculate recId with wrong message
        var wrongMessage = "Hello".getBytes(UTF_8);
        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(
            () -> ((PrivateKeyECDSA) privateKey).getRecoveryId(r,s,wrongMessage)
        );
    }

    @Test
    @DisplayName("can convert from protobuf ED25519 key to PublicKey")
    void fromProtoKeyEd25519() {
        var keyBytes = Hex.decode("0011223344556677889900112233445566778899001122334455667788990011");
        var protoKey = Key.newBuilder().setEd25519(ByteString.copyFrom(keyBytes)).build();

        var cut = PublicKey.fromProtobufKey(protoKey);

        assertThat(cut.getClass()).isEqualTo(PublicKeyED25519.class);
        assertThat(cut.toBytes()).containsExactly(keyBytes);
    }

    @Test
    @DisplayName("can convert from protobuf ECDSA key to PublicKey")
    void fromProtoKeyECDSA() throws InvalidProtocolBufferException {
        var keyProtobufBytes = Hex.decode("3a21034e0441201f2bf9c7d9873c2a9dc3fd451f64b7c05e17e4d781d916e3a11dfd99");
        var protoKey = Key.parseFrom(keyProtobufBytes);

        var cut = PublicKey.fromProtobufKey(protoKey);

        assertThat(cut.getClass()).isEqualTo(PublicKeyECDSA.class);
        assertThat(((PublicKey) cut).toProtobufKey().toByteArray()).containsExactly(keyProtobufBytes);
    }

    @Test
    @DisplayName("can convert from protobuf key list to PublicKey")
    void fromProtoKeyKeyList() {
        // given
        var keyBytes = new byte[][]{
            Hex.decode("0011223344556677889900112233445566778899001122334455667788990011"),
            Hex.decode("aa11223344556677889900112233445566778899001122334455667788990011")
        };

        var protoKeyList = KeyList.newBuilder();

        for (byte[] kb : keyBytes) {
            protoKeyList.addKeys(Key.newBuilder().setEd25519(ByteString.copyFrom(kb)));
        }

        var protoKey = Key.newBuilder().setKeyList(protoKeyList).build();

        // when
        var cut = com.hedera.hashgraph.sdk.Key.fromProtobufKey(protoKey);

        // then
        assertThat(cut.getClass()).isEqualTo(com.hedera.hashgraph.sdk.KeyList.class);

        var keyList = (com.hedera.hashgraph.sdk.KeyList) cut;
        var actual = keyList.toProtobufKey().getKeyList();

        assertThat(actual.getKeysCount()).isEqualTo(2);
        assertThat(actual.getKeys(0).getEd25519().toByteArray()).containsExactly(keyBytes[0]);
        assertThat(actual.getKeys(1).getEd25519().toByteArray()).containsExactly(keyBytes[1]);
    }

    @Test
    @DisplayName("can convert from protobuf threshold key to PublicKey")
    void fromProtoKeyThresholdKey() {
        // given
        var keyBytes = new byte[][]{
            Hex.decode("0011223344556677889900112233445566778899001122334455667788990011"),
            Hex.decode("aa11223344556677889900112233445566778899001122334455667788990011")
        };

        var protoKeyList = KeyList.newBuilder();

        for (byte[] kb : keyBytes) {
            protoKeyList.addKeys(Key.newBuilder().setEd25519(ByteString.copyFrom(kb)));
        }

        var protoThresholdKey = ThresholdKey.newBuilder().setThreshold(1).setKeys(protoKeyList);
        var protoKey = Key.newBuilder().setThresholdKey(protoThresholdKey).build();

        // when
        var cut = com.hedera.hashgraph.sdk.Key.fromProtobufKey(protoKey);

        // then
        assertThat(cut.getClass()).isEqualTo(com.hedera.hashgraph.sdk.KeyList.class);

        var thresholdKey = (com.hedera.hashgraph.sdk.KeyList) cut;
        var actual = thresholdKey.toProtobufKey().getThresholdKey();

        assertThat(actual.getThreshold()).isEqualTo(1);
        assertThat(actual.getKeys().getKeysCount()).isEqualTo(2);
        assertThat(actual.getKeys().getKeys(0).getEd25519().toByteArray()).containsExactly(keyBytes[0]);
        assertThat(actual.getKeys().getKeys(1).getEd25519().toByteArray()).containsExactly(keyBytes[1]);
    }

    @Test
    @DisplayName("Throws given unsupported key")
    void throwsUnsupportedKey() {
        byte[] keyBytes = {0, 1, 2};
        var protoKey = Key.newBuilder().setRSA3072(ByteString.copyFrom(keyBytes)).build();
        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(
            () -> com.hedera.hashgraph.sdk.Key.fromProtobufKey(protoKey)
        );
    }

    @Test
    @DisplayName("Key equals")
    void keyEquals() {
        var key1 = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

        var key2 = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

        assertThat(key2.toString()).isEqualTo(key1.toString());
        assertThat(key2.getPublicKey()).isEqualTo(key1.getPublicKey());
        assertThat(key1.getPublicKey()).isNotEqualTo("random string");
    }

    @Test
    @DisplayName("Key has hash")
    void keyHash() {
        var key = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

        assertThatNoException().isThrownBy(key::hashCode);
    }

    @Test
    @DisplayName("KeyList methods")
    void keyListMethods() {
        var key1 = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

        var key2 = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11");

        var key3 = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12");

        var keyList = com.hedera.hashgraph.sdk.KeyList.withThreshold(1);
        keyList.add(key1);
        keyList.addAll(List.of(key2, key3));

        assertThat(keyList.isEmpty()).isFalse();
        assertThat(keyList.size()).isEqualTo(3);
        assertThat(keyList).contains(key1);
        assertThat(keyList).contains(key2);
        assertThat(keyList).contains(key3);

        @Var var arr = keyList.toArray();
        assertThat(arr[0]).isEqualTo(key1);
        assertThat(arr[1]).isEqualTo(key2);
        assertThat(arr[2]).isEqualTo(key3);

        arr = new com.hedera.hashgraph.sdk.Key[]{null, null, null};
        keyList.toArray(arr);
        assertThat(arr[0]).isEqualTo(key1);
        assertThat(arr[1]).isEqualTo(key2);
        assertThat(arr[2]).isEqualTo(key3);

        keyList.remove(key2);
        assertThat(keyList.size()).isEqualTo(2);

        keyList.clear();

        keyList.addAll(List.of(key1, key2, key3));
        assertThat(keyList.size()).isEqualTo(3);

        keyList.retainAll(List.of(key2, key3));

        assertThat(keyList.size()).isEqualTo(2);
        assertThat(keyList).containsAll(List.of(key2, key3));

        keyList.removeAll(List.of(key2, key3));
        assertThat(keyList).isEmpty();
    }

    @Test
    @DisplayName("can convert from bytes ED25519 key to Key")
    void fromBytesEd25519() throws InvalidProtocolBufferException {
        var keyBytes = Hex.decode("0011223344556677889900112233445566778899001122334455667788990011");
        var protoKey = Key.newBuilder().setEd25519(ByteString.copyFrom(keyBytes)).build();
        var bytes = protoKey.toByteArray();

        var cut = fromBytes(bytes);

        assertThat(cut.getClass()).isEqualTo(PublicKeyED25519.class);
        assertThat(cut.toBytes()).containsExactly(keyBytes);
    }

    @Test
    @DisplayName("can convert from bytes ECDSA key to Key")
    void fromBytesECDSA() throws InvalidProtocolBufferException {
        var keyBytes = Hex.decode("3a21034e0441201f2bf9c7d9873c2a9dc3fd451f64b7c05e17e4d781d916e3a11dfd99");

        var cut = fromBytes(keyBytes);

        assertThat(cut.getClass()).isEqualTo(PublicKeyECDSA.class);
        assertThat(cut.toProtobufKey().toByteArray()).containsExactly(keyBytes);
    }

    @Test
    @DisplayName("can convert from bytes key list to Key")
    void fromBytesKeyList() throws InvalidProtocolBufferException {
        var keyBytes = new byte[][]{
            Hex.decode("0011223344556677889900112233445566778899001122334455667788990011"),
            Hex.decode("aa11223344556677889900112233445566778899001122334455667788990011")
        };

        var protoKeyList = KeyList.newBuilder();

        for (byte[] kb : keyBytes) {
            protoKeyList.addKeys(Key.newBuilder().setEd25519(ByteString.copyFrom(kb)));
        }

        var protoKey = Key.newBuilder().setKeyList(protoKeyList).build();
        var bytes = protoKey.toByteArray();

        var cut = fromBytes(bytes);

        assertThat(cut.getClass()).isEqualTo(com.hedera.hashgraph.sdk.KeyList.class);

        var keyList = (com.hedera.hashgraph.sdk.KeyList) cut;
        var actual = keyList.toProtobufKey().getKeyList();

        assertThat(actual.getKeysCount()).isEqualTo(2);
        assertThat(actual.getKeys(0).getEd25519().toByteArray()).containsExactly(keyBytes[0]);
        assertThat(actual.getKeys(1).getEd25519().toByteArray()).containsExactly(keyBytes[1]);
    }

    @Test
    @DisplayName("can convert from bytes threshold key to Key")
    void fromBytesThresholdKey() throws InvalidProtocolBufferException {
        var keyBytes = new byte[][]{
            Hex.decode("0011223344556677889900112233445566778899001122334455667788990011"),
            Hex.decode("aa11223344556677889900112233445566778899001122334455667788990011")
        };

        var protoKeyList = KeyList.newBuilder();

        for (byte[] kb : keyBytes) {
            protoKeyList.addKeys(Key.newBuilder().setEd25519(ByteString.copyFrom(kb)));
        }

        var protoThresholdKey = ThresholdKey.newBuilder().setThreshold(1).setKeys(protoKeyList);
        var protoKey = Key.newBuilder().setThresholdKey(protoThresholdKey).build();
        var bytes = protoKey.toByteArray();

        var cut = fromBytes(bytes);

        assertThat(cut.getClass()).isEqualTo(com.hedera.hashgraph.sdk.KeyList.class);

        var thresholdKey = (com.hedera.hashgraph.sdk.KeyList) cut;
        var actual = thresholdKey.toProtobufKey().getThresholdKey();

        assertThat(actual.getThreshold()).isEqualTo(1);
        assertThat(actual.getKeys().getKeysCount()).isEqualTo(2);
        assertThat(actual.getKeys().getKeys(0).getEd25519().toByteArray()).containsExactly(keyBytes[0]);
        assertThat(actual.getKeys().getKeys(1).getEd25519().toByteArray()).containsExactly(keyBytes[1]);
    }

    @Test
    @DisplayName("Throws given unsupported key")
    void throwsUnsupportedKeyFromBytes() {
        byte[] keyBytes = {0, 1, 2};
        var protoKey = Key.newBuilder().setRSA3072(ByteString.copyFrom(keyBytes)).build();
        var bytes = protoKey.toByteArray();

        assertThatExceptionOfType(IllegalStateException.class).isThrownBy(
            () -> fromBytes(bytes)
        );
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/KeystoreTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

import static org.assertj.core.api.Assertions.assertThat;

class KeystoreTest {
    private static final String TEST_KEY_STR = "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10";
    private static final String PASSPHRASE = "asdf1234";

    @Test
    @DisplayName("Keystore.fromStream returns correct key")
    void keystoreFromStream() throws IOException {
        // keystore file generated by hedera-sdk-js from `testKeyStr` and `passphrase`
        // NOT USED ANYWHERE
        InputStream inputStream = KeystoreTest.class.getResourceAsStream("/test-keystore.bin");
        Keystore keystore = Keystore.fromStream(inputStream, PASSPHRASE);

        PrivateKey privateKey = keystore.getEd25519();
        assertThat(privateKey.toString()).isEqualTo(TEST_KEY_STR);
    }

    @Test
    @DisplayName("Keystore.fromStream returns correct key v2")
    void keystoreFromStreamV2() throws IOException {
        // keystore file generated by hedera-sdk-js from `testKeyStr` and `passphrase`
        // NOT USED ANYWHERE
        InputStream inputStream = KeystoreTest.class.getResourceAsStream("/test-keystore2.bin");
        Keystore keystore = Keystore.fromStream(inputStream, PASSPHRASE);

        PrivateKey privateKey = keystore.getEd25519();
        assertThat(privateKey.toString()).isEqualTo(TEST_KEY_STR);
    }

    @Test
    @DisplayName("Keystore.toStream produces decodable value")
    void keystoreToStream() throws IOException {
        PrivateKey privateKey = PrivateKey.fromString(TEST_KEY_STR);
        Keystore keystore = new Keystore(privateKey);

        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        keystore.export(outputStream, PASSPHRASE);

        Keystore keystore2 = Keystore.fromStream(new ByteArrayInputStream(outputStream.toByteArray()), PASSPHRASE);
        PrivateKey privateKey2 = keystore2.getEd25519();

        assertThat(privateKey2.toString()).isEqualTo(TEST_KEY_STR);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ListInputTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Objects;

import static org.junit.jupiter.api.Assertions.assertEquals;

// A number of transactions take List<>s as inputs.
// If the list parameter is used directly/naively, it can break encapsulation.
// That is, if you call foo.setBar(bazList), later calling bazList.add(-1) will alter the list
// that would be returned by foo.getBar().

public class ListInputTest {
    @Test
    @DisplayName("TokenAssociateTransaction list input is insulated")
    void tokenAssociateListTest() {
        var tx = new TokenAssociateTransaction();
        var list = new ArrayList<TokenId>();
        list.add(TokenId.fromString("1.2.3"));
        tx.setTokenIds(list);
        var v1 = new ArrayList<>(tx.getTokenIds());
        list.add(TokenId.fromString("4.5.6"));
        var v2 = new ArrayList<>(tx.getTokenIds());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getTokenIds();
        list2.add(TokenId.fromString("7.8.9"));
        var v3 = tx.getTokenIds();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("nodeAccountIds list input is insulated")
    void nodeAccountIdsListTest() {
        var tx = new TokenAssociateTransaction();
        var list = new ArrayList<AccountId>();
        list.add(AccountId.fromString("1.2.3"));
        tx.setNodeAccountIds(list);
        var v1 = new ArrayList<>(Objects.requireNonNull(tx.getNodeAccountIds()));
        list.add(AccountId.fromString("4.5.6"));
        var v2 = new ArrayList<>(tx.getNodeAccountIds());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getNodeAccountIds();
        list2.add(AccountId.fromString("7.8.9"));
        var v3 = tx.getNodeAccountIds();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("TokenBurnTransaction list input is insulated")
    void tokenBurnListTest() {
        var tx = new TokenBurnTransaction();
        var list = new ArrayList<Long>();
        list.add(0L);
        tx.setSerials(list);
        var v1 = new ArrayList<>(tx.getSerials());
        list.add(1L);
        var v2 = new ArrayList<>(tx.getSerials());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getSerials();
        list2.add(2L);
        var v3 = tx.getSerials();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("TokenWipeTransaction list input is insulated")
    void tokenWipeListTest() {
        var tx = new TokenWipeTransaction();
        var list = new ArrayList<Long>();
        list.add(0L);
        tx.setSerials(list);
        var v1 = new ArrayList<>(tx.getSerials());
        list.add(1L);
        var v2 = new ArrayList<>(tx.getSerials());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getSerials();
        list2.add(2L);
        var v3 = tx.getSerials();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("TokenMintTransaction list input is insulated")
    void tokenMintListTest() {
        var tx = new TokenMintTransaction();
        var list = new ArrayList<byte[]>();
        list.add(new byte[]{0});
        tx.setMetadata(list);
        var v1 = new ArrayList<>(tx.getMetadata());
        list.add(new byte[]{1});
        var v2 = new ArrayList<>(tx.getMetadata());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getMetadata();
        list2.add(new byte[]{2});
        var v3 = tx.getMetadata();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("TokenDissociateTransaction list input is insulated")
    void tokenDissociateListTest() {
        var tx = new TokenDissociateTransaction();
        var list = new ArrayList<TokenId>();
        list.add(TokenId.fromString("1.2.3"));
        tx.setTokenIds(list);
        var v1 = new ArrayList<>(tx.getTokenIds());
        list.add(TokenId.fromString("4.5.6"));
        var v2 = new ArrayList<>(tx.getTokenIds());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getTokenIds();
        list2.add(TokenId.fromString("7.8.9"));
        var v3 = tx.getTokenIds();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("TokenCreateTransaction list input is insulated")
    void tokenCreateListTest() {
        var tx = new TokenCreateTransaction();
        var list = new ArrayList<CustomFee>();
        list.add(new CustomFixedFee().setAmount(1));
        tx.setCustomFees(list);
        var v1 = new ArrayList<>(Objects.requireNonNull(tx.getCustomFees()));
        list.add(new CustomFixedFee().setAmount(2));
        var v2 = new ArrayList<>(tx.getCustomFees());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getCustomFees();
        list2.add(new CustomFixedFee().setAmount(3));
        var v3 = tx.getCustomFees();
        assertEquals(v1.toString(), v3.toString());
    }

    @Test
    @DisplayName("TokenFeeScheduleUpdateTransaction list input is insulated")
    void tokenFeeScheduleUpdateListTest() {
        var tx = new TokenFeeScheduleUpdateTransaction();
        var list = new ArrayList<CustomFee>();
        list.add(new CustomFixedFee().setAmount(1));
        tx.setCustomFees(list);
        var v1 = new ArrayList<>(tx.getCustomFees());
        list.add(new CustomFixedFee().setAmount(2));
        var v2 = new ArrayList<>(tx.getCustomFees());
        assertEquals(v1.toString(), v2.toString());

        var list2 = tx.getCustomFees();
        list2.add(new CustomFixedFee().setAmount(3));
        var v3 = tx.getCustomFees();
        assertEquals(v1.toString(), v3.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/LiveHashAddTransactionTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

class LiveHashAddTransactionTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private LiveHashAddTransaction spawnTestTransaction() {
        return new LiveHashAddTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.100"))
            .setHash(ByteString.copyFrom("hash", StandardCharsets.UTF_8))
            .setKeys(privateKey)
            .setDuration(Duration.ofDays(30))
            .freeze()
            .sign(privateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = LiveHashAddTransaction.fromBytes(tx.toBytes());
        assertThat(tx2).hasToString(tx.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/LiveHashDeleteTransactionTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

class LiveHashDeleteTransactionTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private LiveHashDeleteTransaction spawnTestTransaction() {
        return new LiveHashDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.100"))
            .setHash(ByteString.copyFrom("hash", StandardCharsets.UTF_8))
            .freeze()
            .sign(privateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = LiveHashAddTransaction.fromBytes(tx.toBytes());
        assertThat(tx2).hasToString(tx.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/LiveHashQueryTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class LiveHashQueryTest {
    private static final byte[] hash = {0, 1, 2};

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new LiveHashQuery()
            .setAccountId(AccountId.fromString("0.0.100"))
            .setHash(hash)
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/MaxQueryPaymentExceededExceptionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class MaxQueryPaymentExceededExceptionTest {
    @Test
    void shouldHaveMessage() {
        var e = new MaxQueryPaymentExceededException(
            new AccountBalanceQuery(),
            new Hbar(30),
            new Hbar(15)
        );

        assertThat(e.getMessage()).isEqualTo(
            "cost for AccountBalanceQuery, of 30 , without explicit payment is greater than the maximum allowed payment of 15 "
        );
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/MessageSubmitTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ConsensusSubmitMessageTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class MessageSubmitTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = FreezeTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TopicMessageSubmitTransaction spawnTestTransaction() {
        return new TopicMessageSubmitTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTopicId(TopicId.fromString("0.0.5007"))
            .setMessage("hello")
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setConsensusSubmitMessage(ConsensusSubmitMessageTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TopicMessageSubmitTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/MnemonicTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.utils.Bip32Utils;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertThrowsExactly;

public class MnemonicTest {
    private static final String MNEMONIC_LEGACY_V1_STRING = "jolly kidnap tom lawn drunk chick optic lust mutter mole bride galley dense member sage neural widow decide curb aboard margin manure";
    private static final String MNEMONIC_LEGACY_V2_STRING = "obvious favorite remain caution remove laptop base vacant increase video erase pass sniff sausage knock grid argue salt romance way alone fever slush dune";
    private static final String MNEMONIC_24_WORD_STRING = "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home";
    private static final String MNEMONIC_12_WORD_STRING = "finish furnace tomorrow wine mass goose festival air palm easy region guilt";
    @Test
    @DisplayName("Mnemonic.generate() creates a valid mnemonic")
    void generateValidMnemonic() {
        Mnemonic.generate24();
        Mnemonic.generate12();
    }

    @ParameterizedTest
    @DisplayName("Mnemonic.validate() passes on known-good mnemonics")
    @ValueSource(strings = {
        "inmate flip alley wear offer often piece magnet surge toddler submit right radio absent pear floor belt raven price stove replace reduce plate home",
        "tiny denial casual grass skull spare awkward indoor ethics dash enough flavor good daughter early hard rug staff capable swallow raise flavor empty angle",
        "ramp april job flavor surround pyramid fish sea good know blame gate village viable include mixed term draft among monitor swear swing novel track",
        "evoke rich bicycle fire promote climb zero squeeze little spoil slight damage",
    })
    void knownGoodMnemonics(String mnemonicStr) throws Exception {
        Mnemonic.fromString(mnemonicStr);
    }

    @Test
    @DisplayName("Mnemonic.validate() throws on short word list")
    void shortWordList() {
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(
            () -> Mnemonic.fromWords(Arrays.asList("lorem", "ipsum", "dolor"))
        ).satisfies(
            error -> {
                assertThat(error.reason).isEqualTo(BadMnemonicReason.BadLength);
                assertThat(error.unknownWordIndices).isNull();
            }
        );
    }

    @Test
    @DisplayName("Mnemonic.validate() throws on long word list")
    void longWordList() {
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(
            () -> Mnemonic.fromWords(Arrays.asList(
                "lorem",
                "ipsum",
                "dolor",
                "ramp",
                "april",
                "job",
                "flavor",
                "surround",
                "pyramid",
                "fish",
                "sea",
                "good",
                "know",
                "blame",
                "gate",
                "village",
                "viable",
                "include",
                "mixed",
                "term",
                "draft",
                "among",
                "monitor",
                "swear",
                "swing",
                "novel",
                "track"
            ))
        ).satisfies(
            error -> {
                assertThat(error.reason).isEqualTo(BadMnemonicReason.BadLength);
                assertThat(error.unknownWordIndices).isNull();
            }
        );
    }

    @Test
    @DisplayName("Mnemonic.validate() throws on 12-24 words")
    void betweenWordList() {
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(
            () -> Mnemonic.fromWords(Arrays.asList("" +
                "lorem",
                "ipsum",
                "dolor",
                "ramp",
                "april",
                "job",
                "flavor",
                "surround",
                "pyramid",
                "fish",
                "sea",
                "good",
                "know",
                "blame"
            ))
        ).satisfies(
            error -> {
                assertThat(error.reason).isEqualTo(BadMnemonicReason.BadLength);
                assertThat(error.unknownWordIndices).isNull();
            }
        );
    }

    @Test
    @DisplayName("Mnemonic.validate() throws on unknown words")
    void unknownWords() {
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(
            () -> Mnemonic.fromWords(Arrays.asList(
                "abandon",
                "ability",
                "able",
                "about",
                "above",
                "absent",
                "adsorb", // typo from "absorb"
                "abstract",
                "absurd",
                "abuse",
                "access",
                "accident",
                "acount", // typo from "account"
                "accuse",
                "achieve",
                "acid",
                "acoustic",
                "acquired", // typo from "acquire"
                "across",
                "act",
                "action",
                "actor",
                "actress",
                "actual"
            ))
        ).satisfies(
            error -> {
                assertThat(error.reason).isEqualTo(BadMnemonicReason.UnknownWords);
                assertThat(error.unknownWordIndices).containsExactly(6, 12, 17);
            }
        );
    }

    @Test
    @DisplayName("Mnemonic.validate() throws on checksum mismatch, 24 words")
    void checksumMismatch() {
        // this mnemonic was just made up, the checksum should definitely not match
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(
            () -> Mnemonic.fromWords(Arrays.asList(
                "abandon",
                "ability",
                "able",
                "about",
                "above",
                "absent",
                "absorb",
                "abstract",
                "absurd",
                "abuse",
                "access",
                "accident",
                "account",
                "accuse",
                "achieve",
                "acid",
                "acoustic",
                "acquire",
                "across",
                "act",
                "action",
                "actor",
                "actress",
                "actual"
            ))
        ).satisfies(
            error -> {
                assertThat(error.reason).isEqualTo(BadMnemonicReason.ChecksumMismatch);
                assertThat(error.unknownWordIndices).isNull();
            }
        );
    }

    @Test
    @DisplayName("Mnemonic.validate() throws on checksum mismatch, 12 words")
    void checksumMismatch12() {
        // this mnemonic was just made up, the checksum should definitely not match
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(
            () -> Mnemonic.fromWords(Arrays.asList(
                "abandon",
                "ability",
                "able",
                "about",
                "above",
                "absent",
                "absorb",
                "abstract",
                "absurd",
                "abuse",
                "access",
                "accident"
            ))
        ).satisfies(
            error -> {
                assertThat(error.reason).isEqualTo(BadMnemonicReason.ChecksumMismatch);
                assertThat(error.unknownWordIndices).isNull();
            }
        );
    }

    @Test
    @DisplayName("Invalid Mnemonic can still be used to generate a private key")
    void invalidToPrivateKey() {
        assertThatExceptionOfType(BadMnemonicException.class).isThrownBy(() -> Mnemonic.fromWords(Arrays.asList(
            "abandon",
            "ability",
            "able",
            "about",
            "above",
            "absent",
            "absorb",
            "abstract",
            "absurd",
            "abuse",
            "access",
            "accident",
            "account",
            "accuse",
            "achieve",
            "acid",
            "acoustic",
            "acquire",
            "across",
            "act",
            "action",
            "actor",
            "actress",
            "actual"
        ))).satisfies(error -> assertThat(error.mnemonic).isNotNull());
    }

    @Test
    @DisplayName("Legacy V1 mnemonic test")
    void legacyV1MnemonicTest() throws Exception {
        // TODO: add link to reference test vectors
        final String PRIVATE_KEY1 = "00c2f59212cb3417f0ee0d38e7bd876810d04f2dd2cb5c2d8f26ff406573f2bd";
        final String PUBLIC_KEY1 = "0c5bb4624df6b64c2f07a8cb8753945dd42d4b9a2ed4c0bf98e87ef154f473e9";

        final String PRIVATE_KEY2 = "fae0002d2716ea3a60c9cd05ee3c4bb88723b196341b68a02d20975f9d049dc6";
        final String PUBLIC_KEY2 = "f40f9fdb1f161c31ed656794ada7af8025e8b5c70e538f38a4dfb46a0a6b0392";

        final String PRIVATE_KEY3 = "882a565ad8cb45643892b5366c1ee1c1ef4a730c5ce821a219ff49b6bf173ddf";
        final String PUBLIC_KEY3 = "53c6b451e695d6abc52168a269316a0d20deee2331f612d4fb8b2b379e5c6854";

        final String PRIVATE_KEY4 = "6890dc311754ce9d3fc36bdf83301aa1c8f2556e035a6d0d13c2cccdbbab1242";
        final String PUBLIC_KEY4 = "45f3a673984a0b4ee404a1f4404ed058475ecd177729daa042e437702f7791e9";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_LEGACY_V1_STRING);

        // Chain m
        PrivateKey key1 = mnemonic.toLegacyPrivateKey();
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY1);

        // Chain m/0
        PrivateKey key2 = key1.legacyDerive(0);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY2);

        // Chain m/-1
        PrivateKey key3 = key1.legacyDerive(-1);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY3);

        // Chain m/1099511627775
        PrivateKey key4 = key1.legacyDerive(1099511627775L);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY4);
    }

    @Test
    @DisplayName("Legacy V2 mnemonic test")
    void legacyV2MnemonicTest() throws Exception {
        // TODO: add link to reference test vectors
        final String PRIVATE_KEY1 = "98aa82d6125b5efa04bf8372be7931d05cd77f5ef3330b97d6ee7c006eaaf312";
        final String PUBLIC_KEY1 = "e0ce688d614f22f96d9d213ca513d58a7d03d954fe45790006e6e86b25456465";

        final String PRIVATE_KEY2 = "2b7345f302a10c2a6d55bf8b7af40f125ec41d780957826006d30776f0c441fb";
        final String PUBLIC_KEY2 = "0e19f99800b007cc7c82f9d85b73e0f6e48799469450caf43f253b48c4d0d91a";

        final String PRIVATE_KEY3 = "caffc03fdb9853e6a91a5b3c57a5c0031d164ce1c464dea88f3114786b5199e5";
        final String PUBLIC_KEY3 = "9fe11da3fcfba5d28a6645ecb611a9a43dbe6014b102279ba1d34506ea86974b";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_LEGACY_V2_STRING);

        // Chain m
        PrivateKey key1 = mnemonic.toLegacyPrivateKey();
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY1);

        // Chain m/0
        PrivateKey key2 = key1.legacyDerive(0);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY2);

        // Chain m/-1
        PrivateKey key3 = key1.legacyDerive(-1);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isEqualTo(PUBLIC_KEY3);
    }

    @Test
    @DisplayName("Mnemonic test")
    void mnemonicTest() throws Exception {
        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        PrivateKey key = mnemonic.toPrivateKey();
        assertThat(key).hasToString(
            "302e020100300506032b657004220420853f15aecd22706b105da1d709b4ac05b4906170c2b9c7495dff9af49e1391da"
        );
    }

    @Test
    @DisplayName("Mnemonic passphrase test")
    void mnemonicPassphraseTest() throws Exception {
        // Test if mnemonic passphrase is BIP-39 compliant which requires unicode phrases to be NFKD normalized.
        // Use unicode string as a passphrase. If it is properly normalized to NFKD,
        // it should generate the expectedPrivateKey bellow:
        String passphrase = "\u03B4\u03BF\u03BA\u03B9\u03BC\u03AE";
        String expectedPrivateKey = "302e020100300506032b6570042204203fefe1000db9485372851d542453b07e7970de4e2ecede7187d733ac037f4d2c";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        PrivateKey key = mnemonic.toPrivateKey(passphrase);
        assertThat(key.toString()).isEqualTo(expectedPrivateKey);
    }

    @Test
    @DisplayName("BIP39 test vector")
    void bip39() throws Exception {
        final String passphrase = "TREZOR";

        // The 18-word mnemonics are not supported by the SDK
        final String[] MNEMONIC_STRINGS = {
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
            "legal winner thank year wave sausage worth useful legal winner thank yellow",
            "letter advice cage absurd amount doctor acoustic avoid letter advice cage above",
            "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",
//            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon agent",
//            "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal will",
//            "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter always",
//            "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo when",
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art",
            "legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth useful legal winner thank year wave sausage worth title",
            "letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic avoid letter advice cage absurd amount doctor acoustic bless",
            "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote",
            "ozone drill grab fiber curtain grace pudding thank cruise elder eight picnic",
//            "gravity machine north sort system female filter attitude volume fold club stay feature office ecology stable narrow fog",
            "hamster diagram private dutch cause delay private meat slide toddler razor book happy fancy gospel tennis maple dilemma loan word shrug inflict delay length",
            "scheme spot photo card baby mountain device kick cradle pact join borrow",
//            "horn tenant knee talent sponsor spell gate clip pulse soap slush warm silver nephew swap uncle crack brave",
            "panda eyebrow bullet gorilla call smoke muffin taste mesh discover soft ostrich alcohol speed nation flash devote level hobby quick inner drive ghost inside",
            "cat swing flag economy stadium alone churn speed unique patch report train",
//            "light rule cinnamon wrap drastic word pride squirrel upgrade then income fatal apart sustain crack supply proud access",
            "all hour make first leader extend hole alien behind guard gospel lava path output census museum junior mass reopen famous sing advance salt reform",
            "vessel ladder alter error federal sibling chat ability sun glass valve picture",
//            "scissors invite lock maple supreme raw rapid void congress muscle digital elegant little brisk hair mango congress clump",
            "void come effort suffer camp survey warrior heavy shoot primary clutch crush open amazing screen patrol group space point ten exist slush involve unfold",
        };

        final String[] EXPECTED_SEEDS = {
            "c55257c360c07c72029aebc1b53c05ed0362ada38ead3e3e9efa3708e53495531f09a6987599d18264c1e1c92f2cf141630c7a3c4ab7c81b2f001698e7463b04",
            "2e8905819b8723fe2c1d161860e5ee1830318dbf49a83bd451cfb8440c28bd6fa457fe1296106559a3c80937a1c1069be3a3a5bd381ee6260e8d9739fce1f607",
            "d71de856f81a8acc65e6fc851a38d4d7ec216fd0796d0a6827a3ad6ed5511a30fa280f12eb2e47ed2ac03b5c462a0358d18d69fe4f985ec81778c1b370b652a8",
            "ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",
//            "035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
//            "035895f2f481b1b0f01fcf8c289c794660b289981a78f8106447707fdd9666ca06da5a9a565181599b79f53b844d8a71dd9f439c52a3d7b3e8a79c906ac845fa",
//            "107d7c02a5aa6f38c58083ff74f04c607c2d2c0ecc55501dadd72d025b751bc27fe913ffb796f841c49b1d33b610cf0e91d3aa239027f5e99fe4ce9e5088cd65",
//            "0cd6e5d827bb62eb8fc1e262254223817fd068a74b5b449cc2f667c3f1f985a76379b43348d952e2265b4cd129090758b3e3c2c49103b5051aac2eaeb890a528",
            "bda85446c68413707090a52022edd26a1c9462295029f2e60cd7c4f2bbd3097170af7a4d73245cafa9c3cca8d561a7c3de6f5d4a10be8ed2a5e608d68f92fcc8",
            "bc09fca1804f7e69da93c2f2028eb238c227f2e9dda30cd63699232578480a4021b146ad717fbb7e451ce9eb835f43620bf5c514db0f8add49f5d121449d3e87",
            "c0c519bd0e91a2ed54357d9d1ebef6f5af218a153624cf4f2da911a0ed8f7a09e2ef61af0aca007096df430022f7a2b6fb91661a9589097069720d015e4e982f",
            "dd48c104698c30cfe2b6142103248622fb7bb0ff692eebb00089b32d22484e1613912f0a5b694407be899ffd31ed3992c456cdf60f5d4564b8ba3f05a69890ad",
            "274ddc525802f7c828d8ef7ddbcdc5304e87ac3535913611fbbfa986d0c9e5476c91689f9c8a54fd55bd38606aa6a8595ad213d4c9c9f9aca3fb217069a41028",
//            "628c3827a8823298ee685db84f55caa34b5cc195a778e52d45f59bcf75aba68e4d7590e101dc414bc1bbd5737666fbbef35d1f1903953b66624f910feef245ac",
            "64c87cde7e12ecf6704ab95bb1408bef047c22db4cc7491c4271d170a1b213d20b385bc1588d9c7b38f1b39d415665b8a9030c9ec653d75e65f847d8fc1fc440",
            "ea725895aaae8d4c1cf682c1bfd2d358d52ed9f0f0591131b559e2724bb234fca05aa9c02c57407e04ee9dc3b454aa63fbff483a8b11de949624b9f1831a9612",
//            "fd579828af3da1d32544ce4db5c73d53fc8acc4ddb1e3b251a31179cdb71e853c56d2fcb11aed39898ce6c34b10b5382772db8796e52837b54468aeb312cfc3d",
            "72be8e052fc4919d2adf28d5306b5474b0069df35b02303de8c1729c9538dbb6fc2d731d5f832193cd9fb6aeecbc469594a70e3dd50811b5067f3b88b28c3e8d",
            "deb5f45449e615feff5640f2e49f933ff51895de3b4381832b3139941c57b59205a42480c52175b6efcffaa58a2503887c1e8b363a707256bdd2b587b46541f5",
//            "4cbdff1ca2db800fd61cae72a57475fdc6bab03e441fd63f96dabd1f183ef5b782925f00105f318309a7e9c3ea6967c7801e46c8a58082674c860a37b93eda02",
            "26e975ec644423f4a4c4f4215ef09b4bd7ef924e85d1d17c4cf3f136c2863cf6df0a475045652c57eb5fb41513ca2a2d67722b77e954b4b3fc11f7590449191d",
            "2aaa9242daafcee6aa9d7269f17d4efe271e1b9a529178d7dc139cd18747090bf9d60295d0ce74309a78852a9caadf0af48aae1c6253839624076224374bc63f",
//            "7b4a10be9d98e6cba265566db7f136718e1398c71cb581e1b2f464cac1ceedf4f3e274dc270003c670ad8d02c4558b2f8e39edea2775c9e232c7cb798b069e88",
            "01f5bced59dec48e362f2c45b5de68b9fd6c92c6634f44d6d40aab69056506f0e35524a518034ddc1192e1dacd32c1ed3eaa3c3b131c88ed8e7e54c49a5d0998",
        };

        for (int i = 0; i < MNEMONIC_STRINGS.length; i++) {
            byte[] seed = Mnemonic.fromString(MNEMONIC_STRINGS[i]).toSeed(passphrase);
            assertThat(Hex.toHexString(seed)).isEqualTo(EXPECTED_SEEDS[i]);
        }
    }

    @Test
    @DisplayName("Mnemonic.toStandardED25519PrivateKey() test vector")
    void toStandardED25519PrivateKey() throws BadMnemonicException {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1422330626
        final String CHAIN_CODE1 = "404914563637c92d688deb9d41f3f25cbe8d6659d859cc743712fcfac72d7eda";
        final String PRIVATE_KEY1 = "f8dcc99a1ced1cc59bc2fee161c26ca6d6af657da9aa654da724441343ecd16f";
        final String PUBLIC_KEY1 = "2e42c9f5a5cdbde64afa65ce3dbaf013d5f9ff8d177f6ef4eb89fbe8c084ec0d";

        final String CHAIN_CODE2 = "9c2b0073ac934696cd0b52c6c521b9bd1902aac134380a737282fdfe29014bf1";
        final String PRIVATE_KEY2 = "e978a6407b74a0730f7aeb722ad64ab449b308e56006c8bff9aad070b9b66ddf";
        final String PUBLIC_KEY2 = "c4b33dca1f83509f17b69b2686ee46b8556143f79f4b9df7fe7ed3864c0c64d0";

        final String CHAIN_CODE3 = "699344acc5e07c77eb63b154b4c5c3d33cab8bf85ee21bea4cc29ab7f0502259";
        final String PRIVATE_KEY3 = "abeca64d2337db386e289482a252334c68c7536daaefff55dc169ddb77fbae28";
        final String PUBLIC_KEY3 = "fd311925a7a04b38f7508931c6ae6a93e5dc4394d83dafda49b051c0017d3380";

        final String CHAIN_CODE4 = "e5af7c95043a912af57a6e031ddcad191677c265d75c39954152a2733c750a3b";
        final String PRIVATE_KEY4 = "9a601db3e24b199912cec6573e6a3d01ffd3600d50524f998b8169c105165ae5";
        final String PUBLIC_KEY4 = "cf525500706faa7752dca65a086c9381d30d72cc67f23bf334f330579074a890";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);

        // Chain m/44'/3030'/0'/0'/0'
        PrivateKey key1 = mnemonic.toStandardEd25519PrivateKey("", 0);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0'/2147483647'
        PrivateKey key2 = mnemonic.toStandardEd25519PrivateKey("", 2147483647);
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0'/0'; Passphrase: "some pass"
        PrivateKey key3 = mnemonic.toStandardEd25519PrivateKey("some pass", 0);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0'/2147483647'; Passphrase: "some pass"
        PrivateKey key4 = mnemonic.toStandardEd25519PrivateKey("some pass", 2147483647);
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);
    }

    @Test
    @DisplayName("Mnemonic.toStandardED25519PrivateKey() test vector 2")
    void toStandardED25519PrivateKey2() throws BadMnemonicException {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1424761224
        final String CHAIN_CODE1 = "48c89d67e9920e443f09d2b14525213ff83b245c8b98d63747ea0801e6d0ff3f";
        final String PRIVATE_KEY1 = "020487611f3167a68482b0f4aacdeb02cc30c52e53852af7b73779f67eeca3c5";
        final String PUBLIC_KEY1 = "2d047ff02a2091f860633f849ea2024b23e7803cfd628c9bdd635010cbd782d3";

        final String CHAIN_CODE2 = "c0bcdbd9df6d8a4f214f20f3e5c7856415b68be34a1f406398c04690818bea16";
        final String PRIVATE_KEY2 = "d0c4484480944db698dd51936b7ecc81b0b87e8eafc3d5563c76339338f9611a";
        final String PUBLIC_KEY2 = "a1a2573c2c45bd57b0fd054865b5b3d8f492a6e1572bf04b44471e07e2f589b2";

        final String CHAIN_CODE3 = "998a156855ab5398afcde06164b63c5523ff2c8900db53962cc2af191df59e1c";
        final String PRIVATE_KEY3 = "d06630d6e4c17942155819bbbe0db8306cd989ba7baf3c29985c8455fbefc37f";
        final String PUBLIC_KEY3 = "6bd0a51e0ca6fcc8b13cf25efd0b4814978bcaca7d1cf7dbedf538eb02969acb";

        final String CHAIN_CODE4 = "19d99506a5ce2dc0080092068d278fe29b85ffb8d9c26f8956bfca876307c79c";
        final String PRIVATE_KEY4 = "a095ef77ee88da28f373246e9ae143f76e5839f680746c3f921e90bf76c81b08";
        final String PUBLIC_KEY4 = "35be6a2a37ff6bbb142e9f4d9b558308f4f75d7c51d5632c6a084257455e1461";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_12_WORD_STRING);

        // Chain m/44'/3030'/0'/0'/0'
        PrivateKey key1 = mnemonic.toStandardEd25519PrivateKey("", 0);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0'/2147483647'
        PrivateKey key2 = mnemonic.toStandardEd25519PrivateKey("", 2147483647);
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0'/0'; Passphrase: "some pass"
        PrivateKey key3 = mnemonic.toStandardEd25519PrivateKey("some pass", 0);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0'/2147483647'; Passphrase: "some pass"
        PrivateKey key4 = mnemonic.toStandardEd25519PrivateKey("some pass", 2147483647);
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);
    }

    @Test
    @DisplayName("Mnemonic.toStandardED25519PrivateKey() should fail when index is pre-hardened")
    void toStandardED25519PrivateKeyShouldFailWhenIndexIsPreHardened() throws BadMnemonicException {
        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
        int hardenedIndex = Bip32Utils.toHardenedIndex(10);

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> mnemonic.toStandardEd25519PrivateKey("", hardenedIndex)
        ).satisfies(error -> assertThat(error.getMessage()).isEqualTo("the index should not be pre-hardened"));

    }

    @Test
    @DisplayName("Mnemonic.toStandardECDSAsecp256k1PrivateKey() test vector")
    void toStandardECDSAsecp256k1PrivateKey() throws BadMnemonicException {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1422330626
        final String CHAIN_CODE1 = "7717bc71194c257d4b233e16cf48c24adef630052f874a262d19aeb2b527620d";
        final String PRIVATE_KEY1 = "0fde7bfd57ae6ec310bdd8b95967d98e8762a2c02da6f694b152cf9860860ab8";
        final String PUBLIC_KEY1 = "03b1c064b4d04d52e51f6c8e8bb1bff75d62fa7b1446412d5901d424f6aedd6fd4";

        final String CHAIN_CODE2 = "e333da4bd9e21b5dbd2b0f6d88bad02f0fa24cf4b70b2fb613368d0364cdf8af";
        final String PRIVATE_KEY2 = "aab7d720a32c2d1ea6123f58b074c865bb07f6c621f14cb012f66c08e64996bb";
        final String PUBLIC_KEY2 = "03a0ea31bb3562f8a309b1436bc4b2f537301778e8a5e12b68cec26052f567a235";

        final String CHAIN_CODE3 = "0ff552587f6baef1f0818136bacac0bb37236473f6ecb5a8c1cc68a716726ed1";
        final String PRIVATE_KEY3 = "6df5ed217cf6d5586fdf9c69d39c843eb9d152ca19d3e41f7bab483e62f6ac25";
        final String PUBLIC_KEY3 = "0357d69bb36fee569838fe7b325c07ca511e8c1b222873cde93fc6bb541eb7ecea";

        final String CHAIN_CODE4 = "3a5048e93aad88f1c42907163ba4dce914d3aaf2eea87b4dd247ca7da7530f0b";
        final String PRIVATE_KEY4 = "80df01f79ee1b1f4e9ab80491c592c0ef912194ccca1e58346c3d35cb5b7c098";
        final String PUBLIC_KEY4 = "039ebe79f85573baa065af5883d0509a5634245f7864ddead76a008c9e42aa758d";

        final String CHAIN_CODE5 = "e54254940db58ef4913a377062ac6e411daebf435ad592d262d5a66d808a8b94";
        final String PRIVATE_KEY5 = "60cb2496a623e1201d4e0e7ce5da3833cd4ec7d6c2c06bce2bcbcbc9dfef22d6";
        final String PUBLIC_KEY5 = "02b59f348a6b69bd97afa80115e2d5331749b3c89c61297255430c487d6677f404";

        final String CHAIN_CODE6 = "cb23165e9d2d798c85effddc901a248a1a273fab2a56fe7976df97b016e7bb77";
        final String PRIVATE_KEY6 = "100477c333028c8849250035be2a0a166a347a5074a8a727bce1db1c65181a50";
        final String PUBLIC_KEY6 = "03d10ebfa2d8ff2cd34aa96e5ef59ca2e69316b4c0996e6d5f54b6932fe51be560";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);

        // Chain m/44'/3030'/0'/0/0
        PrivateKey key1 = mnemonic.toStandardECDSAsecp256k1PrivateKey("", 0);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0/0'
        PrivateKey key2 = mnemonic.toStandardECDSAsecp256k1PrivateKey("", Bip32Utils.toHardenedIndex(0));
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0/0; Passphrase "some pass"
        PrivateKey key3 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", 0);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0/0'; Passphrase "some pass"
        PrivateKey key4 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", Bip32Utils.toHardenedIndex(0));
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);

        // Chain m/44'/3030'/0'/0/2147483647; Passphrase "some pass"
        PrivateKey key5 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", 2147483647);
        assertThat(Hex.toHexString(key5.getChainCode().getKey())).isEqualTo(CHAIN_CODE5);
        assertThat(key5.toStringRaw()).isEqualTo(PRIVATE_KEY5);
        assertThat(key5.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY5);

        // Chain m/44'/3030'/0'/0/2147483647'; Passphrase "some pass"
        PrivateKey key6 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", Bip32Utils.toHardenedIndex(2147483647));
        assertThat(Hex.toHexString(key6.getChainCode().getKey())).isEqualTo(CHAIN_CODE6);
        assertThat(key6.toStringRaw()).isEqualTo(PRIVATE_KEY6);
        assertThat(key6.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY6);
    }

    @Test
    @DisplayName("Mnemonic.toStandardECDSAsecp256k1PrivateKey() test vector 2")
    void toStandardECDSAsecp256k1PrivateKey2() throws BadMnemonicException {
        // https://github.com/hashgraph/hedera-sdk-reference/issues/73#issuecomment-1424761224
        final String CHAIN_CODE1 = "e76e0480faf2790e62dc1a7bac9dce51db1b3571fd74d8e264abc0d240a55d09";
        final String PRIVATE_KEY1 = "f033824c20dd9949ad7a4440f67120ee02a826559ed5884077361d69b2ad51dd";
        final String PUBLIC_KEY1 = "0294bf84a54806989a74ca4b76291d386914610b40b610d303162b9e495bc06416";

        final String CHAIN_CODE2 = "60c39c6a77bd68c0aaabfe2f4711dc9c2247214c4f4dae15ad4cb76905f5f544";
        final String PRIVATE_KEY2 = "962f549dafe2d9c8091ac918cb4fc348ab0767353f37501067897efbc84e7651";
        final String PUBLIC_KEY2 = "027123855357fd41d28130fbc59053192b771800d28ef47319ef277a1a032af78f";

        final String CHAIN_CODE3 = "911a1095b64b01f7f3a06198df3d618654e5ed65862b211997c67515e3167892";
        final String PRIVATE_KEY3 = "c139ebb363d7f441ccbdd7f58883809ec0cc3ee7a122ef67974eec8534de65e8";
        final String PUBLIC_KEY3 = "0293bdb1507a26542ed9c1ec42afe959cf8b34f39daab4bf842cdac5fa36d50ef7";

        final String CHAIN_CODE4 = "64173f2dcb1d65e15e787ef882fa15f54db00209e2dab16fa1661244cd98e95c";
        final String PRIVATE_KEY4 = "87c1d8d4bb0cebb4e230852f2a6d16f6847881294b14eb1d6058b729604afea0";
        final String PUBLIC_KEY4 = "03358e7761a422ca1c577f145fe845c77563f164b2c93b5b34516a8fa13c2c0888";

        final String CHAIN_CODE5 = "a7250c2b07b368a054f5c91e6a3dbe6ca3bbe01eb0489fe8778304bd0a19c711";
        final String PRIVATE_KEY5 = "2583170ee745191d2bb83474b1de41a1621c47f6e23db3f2bf413a1acb5709e4";
        final String PUBLIC_KEY5 = "03f9eb27cc73f751e8e476dd1db79037a7df2c749fa75b6cc6951031370d2f95a5";

        final String CHAIN_CODE6 = "66a1175e7690e3714d53ffce16ee6bb4eb02065516be2c2ad6bf6c9df81ec394";
        final String PRIVATE_KEY6 = "f2d008cd7349bdab19ed85b523ba218048f35ca141a3ecbc66377ad50819e961";
        final String PUBLIC_KEY6 = "027b653d04958d4bf83dd913a9379b4f9a1a1e64025a691830a67383bc3157c044";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_12_WORD_STRING);

        // Chain m/44'/3030'/0'/0/0
        PrivateKey key1 = mnemonic.toStandardECDSAsecp256k1PrivateKey("", 0);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY1);

        // Chain m/44'/3030'/0'/0/0'
        PrivateKey key2 = mnemonic.toStandardECDSAsecp256k1PrivateKey("", Bip32Utils.toHardenedIndex(0));
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY2);

        // Chain m/44'/3030'/0'/0/0; Passphrase "some pass"
        PrivateKey key3 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", 0);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY3);

        // Chain m/44'/3030'/0'/0/0'; Passphrase "some pass"
        PrivateKey key4 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", Bip32Utils.toHardenedIndex(0));
        assertThat(Hex.toHexString(key4.getChainCode().getKey())).isEqualTo(CHAIN_CODE4);
        assertThat(key4.toStringRaw()).isEqualTo(PRIVATE_KEY4);
        assertThat(key4.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY4);

        // Chain m/44'/3030'/0'/0/2147483647; Passphrase "some pass"
        PrivateKey key5 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", 2147483647);
        assertThat(Hex.toHexString(key5.getChainCode().getKey())).isEqualTo(CHAIN_CODE5);
        assertThat(key5.toStringRaw()).isEqualTo(PRIVATE_KEY5);
        assertThat(key5.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY5);

        // Chain m/44'/3030'/0'/0/2147483647'; Passphrase "some pass"
        PrivateKey key6 = mnemonic.toStandardECDSAsecp256k1PrivateKey("some pass", Bip32Utils.toHardenedIndex(2147483647));
        assertThat(Hex.toHexString(key6.getChainCode().getKey())).isEqualTo(CHAIN_CODE6);
        assertThat(key6.toStringRaw()).isEqualTo(PRIVATE_KEY6);
        assertThat(key6.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY6);
    }

    @Test
    @DisplayName("Mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath() with custom derivation path invalid inputs vector")
    void toStandardECDSAsecp256k1PrivateKeyCustomDpathInvalidInputs() throws BadMnemonicException {
        final String DPATH_1 = "XYZ/44'/60'/0'/0/0"; // invalid derivation path
        final String PASSPHRASE_1 = "";
        final String CHAIN_CODE_1 = "58a9ee31eaf7499abc01952b44dbf0a2a5d6447512367f09d99381c9605bf9e8";
        final String PRIVATE_KEY_1 = "78f9545e40025cf7da9126a4d6a861ae34031d1c74c3404df06110c9fde371ad";
        final String PUBLIC_KEY_1 = "02a8f4c22eea66617d4f119e3a951b93f584949bbfee90bd555305402da6c4e569";

        final String DPATH_2 = ""; // null or empty derivation path
        final String PASSPHRASE_2 = "";
        final String CHAIN_CODE_2 = "6dcfc7a4914bd0e75b94a2f38afee8c247b34810202a2c64fe599ee1b88afdc9";
        final String PRIVATE_KEY_2 = "77ca263661ebdd5a8b33c224aeff5e7bf67eedacee68a1699d97ee8929d7b130";
        final String PUBLIC_KEY_2 = "03e84c9be9be53ad722038cc1943e79df27e5c1d31088adb4f0e62444f4dece683";

        final String DPATH_3 = "m/44'/60'/0'/0/6-7-8-9-0"; // invalid numeric value in derivation path
        final String PASSPHRASE_3 = "";
        final String CHAIN_CODE_3 = "c8c798d2b3696be1e7a29d1cea205507eedc2057006b9ef1cde1b4e346089e17";
        final String PRIVATE_KEY_3 = "31c24292eac951279b659c335e44a2e812d0f1a228b1d4d87034874d376e605a";
        final String PUBLIC_KEY_3 = "0207ff3faf4055c1aa7a5ad94d6ff561fac35b9ae695ef486706243667d2b4d10e";

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() ->{
            Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
            mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
                PASSPHRASE_1, DPATH_1);
        }).satisfies(
            (iae) -> {
                assertThat(iae.getMessage()).isEqualTo("Invalid derivation path format");
            }
        );

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() ->{
            Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
            mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
                PASSPHRASE_2, DPATH_2);
        }).satisfies(
            (iae) -> {
                assertThat(iae.getMessage()).isEqualTo("Derivation path cannot be null or empty");
            }
        );

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() ->{
            Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);
            mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(
                PASSPHRASE_3, DPATH_3);
        }).satisfies(
            (iae) -> {
                assertThat(iae.getMessage()).isEqualTo("Invalid derivation path format");
            }
        );
    }

    @Test
    @DisplayName("Mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath() with custom derivation path test vector")
    void toStandardECDSAsecp256k1PrivateKeyCustomDpath() throws BadMnemonicException {
        final String DPATH_1 = "m/44'/60'/0'/0/0";
        final String PASSPHRASE_1 = "";
        final String CHAIN_CODE_1 = "58a9ee31eaf7499abc01952b44dbf0a2a5d6447512367f09d99381c9605bf9e8";
        final String PRIVATE_KEY_1 = "78f9545e40025cf7da9126a4d6a861ae34031d1c74c3404df06110c9fde371ad";
        final String PUBLIC_KEY_1 = "02a8f4c22eea66617d4f119e3a951b93f584949bbfee90bd555305402da6c4e569";

        final String DPATH_2 = "m/44'/60'/0'/0/1";
        final String PASSPHRASE_2 = "";
        final String CHAIN_CODE_2 = "6dcfc7a4914bd0e75b94a2f38afee8c247b34810202a2c64fe599ee1b88afdc9";
        final String PRIVATE_KEY_2 = "77ca263661ebdd5a8b33c224aeff5e7bf67eedacee68a1699d97ee8929d7b130";
        final String PUBLIC_KEY_2 = "03e84c9be9be53ad722038cc1943e79df27e5c1d31088adb4f0e62444f4dece683";

        final String DPATH_3 = "m/44'/60'/0'/0/2";
        final String PASSPHRASE_3 = "";
        final String CHAIN_CODE_3 = "c8c798d2b3696be1e7a29d1cea205507eedc2057006b9ef1cde1b4e346089e17";
        final String PRIVATE_KEY_3 = "31c24292eac951279b659c335e44a2e812d0f1a228b1d4d87034874d376e605a";
        final String PUBLIC_KEY_3 = "0207ff3faf4055c1aa7a5ad94d6ff561fac35b9ae695ef486706243667d2b4d10e";

        Mnemonic mnemonic = Mnemonic.fromString(MNEMONIC_24_WORD_STRING);

        // m/44'/60'/0'/0/0
        PrivateKey key1 = mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(PASSPHRASE_1, DPATH_1);
        assertThat(Hex.toHexString(key1.getChainCode().getKey())).isEqualTo(CHAIN_CODE_1);
        assertThat(key1.toStringRaw()).isEqualTo(PRIVATE_KEY_1);
        assertThat(key1.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY_1);

        // m/44'/60'/0'/0/1
        PrivateKey key2 = mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(PASSPHRASE_2, DPATH_2);
        assertThat(Hex.toHexString(key2.getChainCode().getKey())).isEqualTo(CHAIN_CODE_2);
        assertThat(key2.toStringRaw()).isEqualTo(PRIVATE_KEY_2);
        assertThat(key2.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY_2);

        // m/44'/60'/0'/0/2
        PrivateKey key3 = mnemonic.toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(PASSPHRASE_3, DPATH_3);
        assertThat(Hex.toHexString(key3.getChainCode().getKey())).isEqualTo(CHAIN_CODE_3);
        assertThat(key3.toStringRaw()).isEqualTo(PRIVATE_KEY_3);
        assertThat(key3.getPublicKey().toStringRaw()).isSubstringOf(PUBLIC_KEY_3);
    }

}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/Mocker.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.logger.LogLevel;
import com.hedera.hashgraph.sdk.logger.Logger;
import com.hedera.hashgraph.sdk.proto.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import io.grpc.MethodDescriptor;
import io.grpc.Server;
import io.grpc.ServerMethodDefinition;
import io.grpc.ServerServiceDefinition;
import io.grpc.ServiceDescriptor;
import io.grpc.Status;
import io.grpc.inprocess.InProcessServerBuilder;
import io.grpc.stub.ServerCalls;

import java.io.IOException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

public class Mocker implements AutoCloseable {
    private static final PrivateKey PRIVATE_KEY = PrivateKey.fromString("302e020100300506032b657004220420d45e1557156908c967804615af59a000be88c7aa7058bfcbe0f46b16c28f887d");
    public final Client client;
    private final List<ServiceDescriptor> services = List.of(
        CryptoServiceGrpc.getServiceDescriptor(),
        FileServiceGrpc.getServiceDescriptor(),
        SmartContractServiceGrpc.getServiceDescriptor(),
        ConsensusServiceGrpc.getServiceDescriptor(),
        TokenServiceGrpc.getServiceDescriptor()
    );
    private final List<List<Object>> responses;
    private final List<Server> servers = new ArrayList<>();

    Mocker(List<List<Object>> responses) {
        this.responses = responses;

        var network = new HashMap<String, AccountId>(responses.size());

        for (var i = 0; i < responses.size(); i++) {
            var index = new AtomicInteger();
            var response = responses.get(i);
            var name = InProcessServerBuilder.generateName();
            var nodeAccountId = new AccountId(3 + i);
            var builder = InProcessServerBuilder.forName(name);

            network.put("in-process:" + name, nodeAccountId);

            for (var service : services) {
                var descriptor = ServerServiceDefinition.builder(service);

                for (MethodDescriptor<?, ?> method : service.getMethods()) {
                    var methodDefinition = ServerMethodDefinition.create((MethodDescriptor<Object, Object>) method,
                        ServerCalls.asyncUnaryCall((request, responseObserver) -> {
                            var responseIndex = index.getAndIncrement();

                            if (responseIndex >= response.size()) {
                                responseObserver.onError(Status.Code.ABORTED.toStatus().asRuntimeException());
                                return;
                            }

                            var r = response.get(responseIndex);

                            if (r instanceof Function<?, ?>) {
                                try {
                                    r = ((Function<Object, Object>) r).apply(request);
                                } catch (Throwable e) {
                                    r = Status.ABORTED.withDescription(e.getMessage()).asRuntimeException();
                                }
                            }

                            if (r instanceof Throwable) {
                                responseObserver.onError((Throwable) r);
                            } else {
                                responseObserver.onNext(r);
                                responseObserver.onCompleted();
                            }
                        })
                    );
                    descriptor.addMethod(methodDefinition);
                }

                builder.addService(descriptor.build());
            }

            try {
                this.servers.add(builder.directExecutor().build().start());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        this.client = Client.forNetwork(network)
            .setOperator(new AccountId(1800), PRIVATE_KEY)
            .setMinBackoff(Duration.ofMillis(0))
            .setMaxBackoff(Duration.ofMillis(0))
            .setNodeMinBackoff(Duration.ofMillis(0))
            .setNodeMaxBackoff(Duration.ofMillis(0))
            .setMinNodeReadmitTime(Duration.ofMillis(0))
            .setMaxNodeReadmitTime(Duration.ofMillis(0))
            .setLogger(new Logger(LogLevel.SILENT));
    }

    public static Mocker withResponses(List<List<Object>> responses) {
        return new Mocker(responses);
    }

    public void close() throws TimeoutException, InterruptedException {
        client.close();

        for (var server : servers) {
            server.shutdown();
            server.awaitTermination();
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/MockingTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.AccountID;
import com.hedera.hashgraph.sdk.proto.CryptoGetAccountBalanceResponse;
import com.hedera.hashgraph.sdk.proto.CryptoGetInfoResponse;
import com.hedera.hashgraph.sdk.proto.CryptoServiceGrpc;
import com.hedera.hashgraph.sdk.proto.FileServiceGrpc;
import com.hedera.hashgraph.sdk.proto.Query;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;
import com.hedera.hashgraph.sdk.proto.ResponseHeader;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.SmartContractServiceGrpc;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionGetReceiptResponse;
import com.hedera.hashgraph.sdk.proto.TransactionGetRecordResponse;
import com.hedera.hashgraph.sdk.proto.TransactionReceipt;
import com.hedera.hashgraph.sdk.proto.TransactionRecord;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.Status;
import io.grpc.stub.StreamObserver;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;

public class MockingTest {
    @Test
    void testSucceedsWithCorrectHbars() throws PrecheckStatusException, TimeoutException, InterruptedException {
        List<Object> responses1 = List.of(
            Status.Code.UNAVAILABLE.toStatus().asRuntimeException(),
            (Function<Object, Object>) o -> Status.Code.UNAVAILABLE.toStatus().asRuntimeException(),
            Response.newBuilder()
                .setCryptogetAccountBalance(
                    CryptoGetAccountBalanceResponse.newBuilder()
                        .setHeader(ResponseHeader.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.OK).build())
                        .setAccountID(AccountID.newBuilder().setAccountNum(10).build())
                        .setBalance(100)
                        .build()
                ).build()
        );

        var responses = List.of(responses1);

        try (var mocker = Mocker.withResponses(responses)) {
            var balance = new AccountBalanceQuery().setAccountId(new AccountId(10)).execute(mocker.client);

            Assertions.assertEquals(balance.hbars, Hbar.fromTinybars(100));
        }
    }

    String makeBigString(int size) {
        char[] chars = new char[size];
        Arrays.fill(chars, 'A');
        return new String(chars);
    }

    @ParameterizedTest(name = "[{0}] Executable retries on gRPC error with PLATFORM_NOT_ACTIVE when getting receipt")
    @CsvSource({"sync", "async"})
    void shouldRetryExceptionallyFunctionsCorrectlyForPlatformNotActiveGetReceipt(String sync) throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("getReceiptRetry" + sync, service);
        server.client.setMaxAttempts(3);

        service.buffer.enqueueResponse(TestResponse.transaction(com.hedera.hashgraph.sdk.Status.PLATFORM_NOT_ACTIVE));
        service.buffer.enqueueResponse(TestResponse.transactionOk());

        com.hedera.hashgraph.sdk.TransactionResponse transactionResponse;
        if (sync.equals("sync")) {
            transactionResponse = new AccountCreateTransaction().execute(server.client);
        } else {
            transactionResponse = new AccountCreateTransaction().executeAsync(server.client).get();
        }

        service.buffer
            .enqueueResponse(TestResponse.query(
                Response.newBuilder().setTransactionGetReceipt(
                    TransactionGetReceiptResponse.newBuilder()
                        .setHeader(ResponseHeader.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.PLATFORM_NOT_ACTIVE))
                        .setReceipt(TransactionReceipt.newBuilder().setStatus(ResponseCodeEnum.SUCCESS).build())
                        .build()
                ).build()
            ))
            .enqueueResponse(TestResponse.receipt(com.hedera.hashgraph.sdk.Status.PLATFORM_NOT_ACTIVE))
            .enqueueResponse(TestResponse.successfulReceipt());

        if (sync.equals("sync")) {
            transactionResponse.getReceipt(server.client);
        } else {
            transactionResponse.getReceiptAsync(server.client).get();
        }
    }

    @ParameterizedTest(name = "[{0}] Executable retries on gRPC error with PLATFORM_NOT_ACTIVE when getting record")
    @CsvSource({"sync", "async"})
    void shouldRetryExceptionallyFunctionsCorrectlyForPlatformNotActiveGetRecord(String sync) throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("getRecordRetry" + sync, service);
        server.client.setMaxAttempts(3);

        service.buffer.enqueueResponse(TestResponse.transaction(com.hedera.hashgraph.sdk.Status.PLATFORM_NOT_ACTIVE));
        service.buffer.enqueueResponse(TestResponse.transactionOk());

        com.hedera.hashgraph.sdk.TransactionResponse transactionResponse;
        if (sync.equals("sync")) {
            transactionResponse = new AccountCreateTransaction().execute(server.client);
        } else {
            transactionResponse = new AccountCreateTransaction().executeAsync(server.client).get();
        }

        service.buffer
            .enqueueResponse(TestResponse.successfulReceipt()) // for inner getReceipt
            .enqueueResponse(TestResponse.successfulReceipt()) // for inner getCost
            .enqueueResponse(TestResponse.query(
                Response.newBuilder().setTransactionGetRecord(
                    TransactionGetRecordResponse.newBuilder()
                        .setHeader(ResponseHeader.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.PLATFORM_NOT_ACTIVE).build())
                        .setTransactionRecord(TransactionRecord.newBuilder().setReceipt(
                            TransactionReceipt.newBuilder().setStatus(ResponseCodeEnum.SUCCESS).build()
                        ).build()
                    ).build()
                ).build()
            ))
            .enqueueResponse(TestResponse.query(
                Response.newBuilder().setTransactionGetRecord(
                    TransactionGetRecordResponse.newBuilder()
                        .setTransactionRecord(TransactionRecord.newBuilder().setReceipt(
                            TransactionReceipt.newBuilder().setStatus(ResponseCodeEnum.PLATFORM_NOT_ACTIVE).build()
                        ).build()
                    ).build()
                ).build()
            ))
            .enqueueResponse(TestResponse.query(
                Response.newBuilder().setTransactionGetRecord(
                    TransactionGetRecordResponse.newBuilder()
                        .setTransactionRecord(TransactionRecord.newBuilder().setReceipt(
                            TransactionReceipt.newBuilder().setStatus(ResponseCodeEnum.SUCCESS).build()
                        ).build()
                    ).build()
                ).build()
            ));

        if (sync.equals("sync")) {
            transactionResponse.getRecord(server.client);
        } else {
            transactionResponse.getRecordAsync(server.client).get();
        }
    }

    @ParameterizedTest(name = "[{0}, {1}] ContractCreateFlow functions")
    @CsvSource({
        "sync, stakedNode",
        "sync, stakedAccount",
        "async, stakedNode",
        "async, stakedAccount",
    })
    void contractCreateFlowFunctions(String versionToTest, String stakeType) throws Throwable {
        var BIG_BYTECODE = makeBigString(ContractCreateFlow.FILE_CREATE_MAX_BYTES + 1000);
        var adminKey = PrivateKey.generateED25519().getPublicKey();

        var cryptoService = new TestCryptoService();
        var fileService = new TestFileService();
        var contractService = new TestContractService();
        var server = new TestServer("contractCreateFlow" + versionToTest + stakeType, cryptoService, fileService, contractService);

        var fileId = FileId.fromString("1.2.3");
        var maxAutomaticTokenAssociations = 101;
        var stakedAccountId = AccountId.fromString("4.3.2");
        var stakedNode = 13L;
        var declineStakingReward = true;


        cryptoService.buffer.enqueueResponse(TestResponse.query(
            Response.newBuilder().setTransactionGetReceipt(
                TransactionGetReceiptResponse.newBuilder().setReceipt(
                    TransactionReceipt.newBuilder().setFileID(fileId.toProtobuf()).setStatus(ResponseCodeEnum.SUCCESS).build()
                ).build()
            ).build()
        )).enqueueResponse(TestResponse.successfulReceipt()).enqueueResponse(TestResponse.successfulReceipt());
        fileService.buffer
            .enqueueResponse(TestResponse.transactionOk())
            .enqueueResponse(TestResponse.transactionOk())
            .enqueueResponse(TestResponse.transactionOk());

        contractService.buffer.enqueueResponse(TestResponse.transactionOk());

        var flow = new ContractCreateFlow()
            .setBytecode(BIG_BYTECODE)
            .setContractMemo("memo goes here")
            .setConstructorParameters(new byte[]{1, 2, 3})
            .setAutoRenewPeriod(Duration.ofMinutes(1))
            .setAdminKey(adminKey)
            .setGas(100)
            .setInitialBalance(new Hbar(3))
            .setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations)
            .setDeclineStakingReward(declineStakingReward);

        if (stakeType.equals("stakedAccount")) {
            flow.setStakedAccountId(stakedAccountId);
        } else {
            flow.setStakedNodeId(stakedNode);
        }

        if (versionToTest.equals("sync")) {
            flow.execute(server.client);
        } else {
            flow.executeAsync(server.client).get();
        }

        Thread.sleep(1000);

        Assertions.assertEquals(3, cryptoService.buffer.queryRequestsReceived.size());
        Assertions.assertEquals(3, fileService.buffer.transactionRequestsReceived.size());
        Assertions.assertEquals(1, contractService.buffer.transactionRequestsReceived.size());
        var transactions = new ArrayList<com.hedera.hashgraph.sdk.Transaction<?>>();
        for (var request : fileService.buffer.transactionRequestsReceived) {
            transactions.add(com.hedera.hashgraph.sdk.Transaction.fromBytes(request.toByteArray()));
        }
        transactions.add(com.hedera.hashgraph.sdk.Transaction.fromBytes(
            contractService.buffer.transactionRequestsReceived.get(0).toByteArray()
        ));

        Assertions.assertInstanceOf(FileCreateTransaction.class, transactions.get(0));
        Assertions.assertEquals(
            ContractCreateFlow.FILE_CREATE_MAX_BYTES,
            ((FileCreateTransaction) transactions.get(0)).getContents().size()
        );

        Assertions.assertTrue(cryptoService.buffer.queryRequestsReceived.get(0).hasTransactionGetReceipt());

        Assertions.assertInstanceOf(FileAppendTransaction.class, transactions.get(1));
        var fileAppendTx = (FileAppendTransaction) transactions.get(1);
        Assertions.assertEquals(fileId, fileAppendTx.getFileId());
        Assertions.assertEquals(
            BIG_BYTECODE.length() - ContractCreateFlow.FILE_CREATE_MAX_BYTES,
            fileAppendTx.getContents().size()
        );

        Assertions.assertInstanceOf(ContractCreateTransaction.class, transactions.get(3));
        var contractCreateTx = (ContractCreateTransaction) transactions.get(3);
        Assertions.assertEquals("memo goes here", contractCreateTx.getContractMemo());
        Assertions.assertEquals(fileId, contractCreateTx.getBytecodeFileId());
        Assertions.assertEquals(ByteString.copyFrom(new byte[]{1, 2, 3}), contractCreateTx.getConstructorParameters());
        Assertions.assertEquals(Duration.ofMinutes(1), contractCreateTx.getAutoRenewPeriod());
        Assertions.assertEquals(adminKey, contractCreateTx.getAdminKey());
        Assertions.assertEquals(100, contractCreateTx.getGas());
        Assertions.assertEquals(new Hbar(3), contractCreateTx.getInitialBalance());
        Assertions.assertEquals(maxAutomaticTokenAssociations, contractCreateTx.getMaxAutomaticTokenAssociations());
        Assertions.assertEquals(declineStakingReward, contractCreateTx.getDeclineStakingReward());

        if (stakeType.equals("stakedAccount")) {
            Assertions.assertEquals(stakedAccountId, contractCreateTx.getStakedAccountId());
        } else {
            Assertions.assertEquals(stakedNode, contractCreateTx.getStakedNodeId());
        }

        Assertions.assertInstanceOf(FileDeleteTransaction.class, transactions.get(2));

        server.close();
    }


    @Test
    void accountInfoFlowFunctions() throws Throwable {
        var BIG_BYTES = makeBigString(1000).getBytes(StandardCharsets.UTF_8);
        var privateKey = PrivateKey.generateED25519();
        var otherPrivateKey = PrivateKey.generateED25519();
        var accountId = AccountId.fromString("1.2.3");
        var cost = Hbar.from(1);

        Supplier<TokenMintTransaction> makeTx = () -> new TokenMintTransaction()
            .setTokenId(TokenId.fromString("1.2.3"))
            .setAmount(5)
            .setTransactionId(TransactionId.generate(accountId))
            .setNodeAccountIds(List.of(AccountId.fromString("0.0.3")))
            .freeze();

        var properlySignedTx = makeTx.get().sign(privateKey);
        var improperlySignedTx = makeTx.get().sign(otherPrivateKey);
        var properBigBytesSignature = privateKey.sign(BIG_BYTES);
        var improperBigBytesSignature = otherPrivateKey.sign(BIG_BYTES);

        var cryptoService = new TestCryptoService();
        var server = new TestServer("accountInfoFlow", cryptoService);

        for (int i = 0; i < 8; i++) {
            cryptoService.buffer.enqueueResponse(
                TestResponse.query(
                    Response.newBuilder().setCryptoGetInfo(
                        CryptoGetInfoResponse.newBuilder()
                            .setHeader(
                                ResponseHeader.newBuilder()
                                    .setCost(cost.toTinybars())
                                    .build()
                            ).build()
                    ).build()
                )
            );
            cryptoService.buffer.enqueueResponse(
                TestResponse.query(
                    Response.newBuilder().setCryptoGetInfo(
                        CryptoGetInfoResponse.newBuilder()
                            .setAccountInfo(
                                CryptoGetInfoResponse.AccountInfo.newBuilder()
                                    .setKey(privateKey.getPublicKey().toProtobufKey())
                                    .build()
                            ).build()
                    ).build()
                )
            );
        }

        Assertions.assertTrue(
            AccountInfoFlow.verifyTransactionSignature(server.client, accountId, properlySignedTx)
        );
        Assertions.assertFalse(
            AccountInfoFlow.verifyTransactionSignature(server.client, accountId, improperlySignedTx)
        );
        Assertions.assertTrue(
            AccountInfoFlow.verifySignature(server.client, accountId, BIG_BYTES, properBigBytesSignature)
        );
        Assertions.assertFalse(
            AccountInfoFlow.verifySignature(server.client, accountId, BIG_BYTES, improperBigBytesSignature)
        );
        Assertions.assertTrue(
            AccountInfoFlow.verifyTransactionSignatureAsync(server.client, accountId, properlySignedTx).get()
        );
        Assertions.assertFalse(
            AccountInfoFlow.verifyTransactionSignatureAsync(server.client, accountId, improperlySignedTx).get()
        );
        Assertions.assertTrue(
            AccountInfoFlow.verifySignatureAsync(server.client, accountId, BIG_BYTES, properBigBytesSignature).get()
        );
        Assertions.assertFalse(
            AccountInfoFlow.verifySignatureAsync(server.client, accountId, BIG_BYTES, improperBigBytesSignature).get()
        );

        Assertions.assertEquals(16, cryptoService.buffer.queryRequestsReceived.size());
        for (int i = 0; i < 16; i += 2) {
            var costQueryRequest = cryptoService.buffer.queryRequestsReceived.get(i);
            var queryRequest = cryptoService.buffer.queryRequestsReceived.get(i + 1);

            Assertions.assertTrue(costQueryRequest.hasCryptoGetInfo());
            Assertions.assertTrue(costQueryRequest.getCryptoGetInfo().hasHeader());
            Assertions.assertTrue(costQueryRequest.getCryptoGetInfo().getHeader().hasPayment());

            Assertions.assertTrue(queryRequest.hasCryptoGetInfo());
            Assertions.assertTrue(queryRequest.getCryptoGetInfo().hasAccountID());
            Assertions.assertEquals(accountId, AccountId.fromProtobuf(queryRequest.getCryptoGetInfo().getAccountID()));
        }
        server.close();
    }

    @Test
    void exitOnAborted() throws PrecheckStatusException, TimeoutException, InterruptedException {
        List<Object> responses1 = List.of();

        var responses = List.of(responses1);

        try (var mocker = Mocker.withResponses(responses)) {
            Assertions.assertThrows(RuntimeException.class, () -> new AccountBalanceQuery().setAccountId(new AccountId(10)).execute(mocker.client));
        }
    }

    @ParameterizedTest(name = "[{2}] Executable retries on gRPC error with status {0} and description {1}")
    @CsvSource({
        "INTERNAL, internal RST_STREAM error, sync",
        "INTERNAL, rst stream, sync",
        "RESOURCE_EXHAUSTED, , sync",
        "UNAVAILABLE, , sync",
        "INTERNAL, internal RST_STREAM error, async",
        "INTERNAL, rst stream, async",
        "RESOURCE_EXHAUSTED, , async",
        "UNAVAILABLE, , async"
    })
    void shouldRetryExceptionallyFunctionsCorrectly(Status.Code code, String description, String sync) throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("executableRetry" + code + (description != null ? description.replace(" ", "") : "NULL") + sync, service);

        var exception = Status.fromCode(code)
            .withDescription(description)
            .asRuntimeException();

        service.buffer
            .enqueueResponse(TestResponse.error(exception))
            .enqueueResponse(TestResponse.transactionOk());

        if (sync.equals("sync")) {
            new AccountCreateTransaction()
                .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                .execute(server.client);
        } else {
            new AccountCreateTransaction()
                .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                .executeAsync(server.client)
                .get();
        }

        Assertions.assertEquals(2, service.buffer.transactionRequestsReceived.size());
        assertFirstTwoRequestsNotDirectedAtSameNode(service);

        server.close();
    }


    @ParameterizedTest(name = "[{2}] Executable should make max {1} attempts when there are {0} errors, and error")
    @CsvSource({
        "2, 2, sync",
        "2, 2, async"
    })
    void hitsTxMaxAttemptsCorrectly(Integer numberOfErrors, Integer maxAttempts, String sync) throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("executableMaxAttemptsSync" + numberOfErrors + maxAttempts + sync, service);

        var exception = Status.UNAVAILABLE.asRuntimeException();

        for (var i = 0; i < numberOfErrors; i++) {
            service.buffer.enqueueResponse(TestResponse.error(exception));
        }

        service.buffer.enqueueResponse(TestResponse.transactionOk());

        if (sync.equals("sync")) {
            Assertions.assertThrows(MaxAttemptsExceededException.class, () -> {
                new AccountCreateTransaction()
                    .setMaxAttempts(maxAttempts)
                    .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                    .execute(server.client);
            });
        } else {
            new AccountCreateTransaction()
                .setMaxAttempts(maxAttempts)
                .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                .executeAsync(server.client)
                .handle((response, error) -> {
                    Assertions.assertNotNull(error);
                    System.out.println(error);
                    Assertions.assertTrue(error.getCause() instanceof MaxAttemptsExceededException);

                    return null;
                })
                .get();
        }

        Assertions.assertEquals(2, service.buffer.transactionRequestsReceived.size());

        server.close();
    }

    @ParameterizedTest(name = "[{2}] Executable retries on {1} Hedera status error(s) {0}")
    @CsvSource({
        "BUSY, 1, sync",
        "PLATFORM_TRANSACTION_NOT_CREATED, 1, sync",
        "TRANSACTION_EXPIRED, 1, sync",
        "BUSY, 3, sync",
        "PLATFORM_TRANSACTION_NOT_CREATED, 3, sync",
        "TRANSACTION_EXPIRED, 3, sync",
        "BUSY, 1, async",
        "PLATFORM_TRANSACTION_NOT_CREATED, 1, async",
        "TRANSACTION_EXPIRED, 1, async",
        "BUSY, 3, async",
        "PLATFORM_TRANSACTION_NOT_CREATED, 3, async",
        "TRANSACTION_EXPIRED, 3, async"
    })
    void shouldRetryFunctionsCorrectly(com.hedera.hashgraph.sdk.Status status, int numberOfErrors, String sync) throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("shouldRetryFunctionsCorrectly" + status + numberOfErrors + sync, service);

        for (var i = 0; i < numberOfErrors; i++) {
            service.buffer.enqueueResponse(TestResponse.transaction(status));
        }

        service.buffer.enqueueResponse(TestResponse.transactionOk());

        server.client.setMaxAttempts(4);

        if (sync.equals("sync")) {
            new AccountCreateTransaction()
                .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                .execute(server.client);
        } else {
            new AccountCreateTransaction()
                .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                .executeAsync(server.client)
                .get();
        }

        Assertions.assertEquals(numberOfErrors + 1, service.buffer.transactionRequestsReceived.size());
        assertFirstTwoRequestsNotDirectedAtSameNode(service);

        server.close();
    }

    @ParameterizedTest(name = "[{2}] Executable retries on {1} Hedera status error(s) {0}")
    @CsvSource({
        "BUSY, sync",
        "PLATFORM_TRANSACTION_NOT_CREATED, sync",
        "PLATFORM_NOT_ACTIVE, sync",
        "BUSY, async",
        "PLATFORM_TRANSACTION_NOT_CREATED, async",
        "PLATFORM_NOT_ACTIVE, async",
    })
    void hitsClientMaxAttemptsCorrectly(com.hedera.hashgraph.sdk.Status status, String sync) throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("shouldRetryFunctionsCorrectly" + status + sync, service);

        for (var i = 0; i < 2; i++) {
            service.buffer.enqueueResponse(TestResponse.transaction(status));
        }

        server.client.setMaxAttempts(2);

        if (sync.equals("sync")) {
            Assertions.assertThrows(MaxAttemptsExceededException.class, () -> {
                new AccountCreateTransaction()
                    .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                    .execute(server.client);
            });
        } else {
            new AccountCreateTransaction()
                .setNodeAccountIds(List.of(AccountId.fromString("1.1.1"), AccountId.fromString("2.2.2")))
                .executeAsync(server.client)
                .handle((response, error) -> {
                    Assertions.assertNotNull(error);
                    Assertions.assertTrue(error.getCause() instanceof MaxAttemptsExceededException);

                    return null;
                })
                .get();
        }
        Assertions.assertEquals(2, service.buffer.transactionRequestsReceived.size());
        assertFirstTwoRequestsNotDirectedAtSameNode(service);

        server.close();
    }

    private static void assertFirstTwoRequestsNotDirectedAtSameNode(TestCryptoService service) throws InvalidProtocolBufferException {
        var requests = service.buffer.transactionRequestsReceived;
        var signedTx0 = SignedTransaction.parseFrom(requests.get(0).getSignedTransactionBytes());
        var signedTx1 = SignedTransaction.parseFrom(requests.get(1).getSignedTransactionBytes());
        var txBody0 = TransactionBody.parseFrom(signedTx0.getBodyBytes());
        var txBody1 = TransactionBody.parseFrom(signedTx1.getBodyBytes());
        Assertions.assertNotEquals(txBody0.getNodeAccountID(), txBody1.getNodeAccountID());
    }

    @Test
    @DisplayName("Client.setDefaultMaxTransactionFee() functions correctly")
    void defaultMaxTransactionFeeTest() throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("maxTransactionFee", service);

        service.buffer
            .enqueueResponse(TestResponse.transactionOk())
            .enqueueResponse(TestResponse.transactionOk())
            .enqueueResponse(TestResponse.transactionOk())
            .enqueueResponse(TestResponse.transactionOk());

        new AccountDeleteTransaction()
            .execute(server.client);

        new AccountDeleteTransaction()
            .setMaxTransactionFee(new Hbar(5))
            .execute(server.client);

        server.client.setDefaultMaxTransactionFee(new Hbar(1));

        new AccountDeleteTransaction()
            .execute(server.client);

        new AccountDeleteTransaction()
            .setMaxTransactionFee(new Hbar(3))
            .execute(server.client);

        Assertions.assertEquals(4, service.buffer.transactionRequestsReceived.size());
        var transactions = new ArrayList<com.hedera.hashgraph.sdk.Transaction<?>>();
        for (var request : service.buffer.transactionRequestsReceived) {
            transactions.add(com.hedera.hashgraph.sdk.Transaction.fromBytes(request.toByteArray()));
        }
        Assertions.assertEquals(new Hbar(2), transactions.get(0).getMaxTransactionFee());
        Assertions.assertEquals(new Hbar(5), transactions.get(1).getMaxTransactionFee());
        Assertions.assertEquals(new Hbar(1), transactions.get(2).getMaxTransactionFee());
        Assertions.assertEquals(new Hbar(3), transactions.get(3).getMaxTransactionFee());

        server.close();
    }

    @Disabled
    @Test
    @DisplayName("Client.setDefaultMaxQueryPayment() functions correctly")
    void defaultMaxQueryPaymentTest() throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("queryPayment", service);

        var response = Response.newBuilder()
            .setCryptogetAccountBalance(
                new AccountBalance(
                    new Hbar(0),
                    new HashMap<TokenId, Long>(),
                    new HashMap<TokenId, Integer>()
                ).toProtobuf()
            ).build();

        service.buffer
            .enqueueResponse(TestResponse.query(response))
            .enqueueResponse(TestResponse.query(response))
            .enqueueResponse(TestResponse.query(response));

        // TODO: this will take some work, since I have to contend with Query's getCost behavior
        // TODO: actually, because AccountBalanceQuery is free, I'll need some other query type to test this.
        //       Perhaps getAccountInfo?

        server.close();
    }

    @Test
    @DisplayName("Signer is prevented from signing twice")
    void signerDoesNotSignTwice() throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("signerDoesNotSignTwice", service);

        service.buffer.enqueueResponse(TestResponse.transactionOk());

        var aliceKey = PrivateKey.generateED25519();

        var transaction = new AccountCreateTransaction()
            .setTransactionId(TransactionId.generate(Objects.requireNonNull(server.client.getOperatorAccountId())))
            .setNodeAccountIds(server.client.network.getNodeAccountIdsForExecute())
            .freeze()
            .sign(aliceKey);

        // This will cause the SDK Transaction to populate the sigPairLists list
        transaction.getTransactionHashPerNode();

        // This will clear the outerTransactions list while keeping the sigPairLists list
        transaction.signWithOperator(server.client);

        // If Transaction.signTransaction() is not programmed correctly, it will add Alice's signature to the
        // sigPairList a second time here.
        transaction.execute(server.client);

        // Now we must go through the laborious process of digging info out of the response.  =(
        Assertions.assertEquals(1, service.buffer.transactionRequestsReceived.size());
        var request = service.buffer.transactionRequestsReceived.get(0);
        var sigPairList = SignedTransaction.parseFrom(request.getSignedTransactionBytes()).getSigMap().getSigPairList();
        Assertions.assertEquals(2, sigPairList.size());
        Assertions.assertNotEquals(
            sigPairList.get(0).getEd25519().toString(),
            sigPairList.get(1).getEd25519().toString());

        server.close();
    }

    @Test
    @DisplayName("Can cancel executeAsync()")
    void canCancelExecuteAsync() throws Exception {
        var service = new TestCryptoService();
        var server = new TestServer("canCancelExecuteAsync", service);

        server.client.setMaxBackoff(Duration.ofSeconds(8));
        server.client.setMinBackoff(Duration.ofSeconds(1));

        var noReceiptResponse = TestResponse.query(
            Response.newBuilder()
                .setTransactionGetReceipt(
                    TransactionGetReceiptResponse.newBuilder()
                        .setHeader(
                            ResponseHeader.newBuilder()
                                .setNodeTransactionPrecheckCode(com.hedera.hashgraph.sdk.Status.RECEIPT_NOT_FOUND.code)
                        )
                ).build()
        );

        service.buffer.enqueueResponse(noReceiptResponse);
        service.buffer.enqueueResponse(noReceiptResponse);
        service.buffer.enqueueResponse(noReceiptResponse);

        var future = new TransactionReceiptQuery().executeAsync(server.client);
        Thread.sleep(1500);
        future.cancel(true);
        Thread.sleep(5000);

        Assertions.assertEquals(2, service.buffer.queryRequestsReceived.size());

        server.close();
    }

    private static class TestCryptoService extends CryptoServiceGrpc.CryptoServiceImplBase implements TestService {
        public Buffer buffer = new Buffer();

        @Override
        public Buffer getBuffer() {
            return buffer;
        }

        @Override
        public void createAccount(Transaction request, StreamObserver<TransactionResponse> responseObserver) {
            respondToTransactionFromQueue(request, responseObserver);
        }

        @Override
        public void cryptoDelete(Transaction request, StreamObserver<TransactionResponse> responseObserver) {
            respondToTransactionFromQueue(request, responseObserver);
        }

        @Override
        public void cryptoGetBalance(Query request, StreamObserver<Response> responseObserver) {
            respondToQueryFromQueue(request, responseObserver);
        }

        @Override
        public void getTransactionReceipts(Query request, StreamObserver<Response> responseObserver) {
            respondToQueryFromQueue(request, responseObserver);
        }

        @Override
        public void getTxRecordByTxID(Query request, StreamObserver<Response> responseObserver) {
            respondToQueryFromQueue(request, responseObserver);
        }

        @Override
        public void getAccountInfo(Query request, StreamObserver<Response> responseObserver) {
            respondToQueryFromQueue(request, responseObserver);
        }
    }

    private static class TestFileService extends FileServiceGrpc.FileServiceImplBase implements TestService {
        public Buffer buffer = new Buffer();

        @Override
        public Buffer getBuffer() {
            return buffer;
        }

        @Override
        public void createFile(Transaction request, StreamObserver<TransactionResponse> responseObserver) {
            respondToTransactionFromQueue(request, responseObserver);
        }

        @Override
        public void appendContent(Transaction request, StreamObserver<TransactionResponse> responseObserver) {
            respondToTransactionFromQueue(request, responseObserver);
        }

        @Override
        public void deleteFile(Transaction request, StreamObserver<TransactionResponse> responseObserver) {
            respondToTransactionFromQueue(request, responseObserver);
        }
    }

    private static class TestContractService extends SmartContractServiceGrpc.SmartContractServiceImplBase implements TestService {
        public Buffer buffer = new Buffer();

        @Override
        public Buffer getBuffer() {
            return buffer;
        }

        @Override
        public void createContract(Transaction request, StreamObserver<TransactionResponse> responseObserver) {
            respondToTransactionFromQueue(request, responseObserver);
        }
    }
}

// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/NetworkVersionInfoQueryTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.QueryHeader;
import com.hedera.hashgraph.sdk.proto.Transaction;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class NetworkVersionInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new NetworkVersionInfoQuery()
            .setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(
                builder,
                QueryHeader
                    .newBuilder()
                    .setPayment(
                        Transaction.newBuilder()
                            .setSignedTransactionBytes(
                                ByteString.fromHex("deadbeef")
                            ).build()
                    ).build()
            );
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/NetworkVersionInfoTest.java
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class NetworkVersionInfoTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    NetworkVersionInfo spawnNetworkVerionInfoExample() {
        return new NetworkVersionInfo(
            new SemanticVersion(1, 2, 3),
            new SemanticVersion(4, 5, 6)
        );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalNetworkVersionInfo = spawnNetworkVerionInfoExample();
        byte[] networkVersionInfoBytes = originalNetworkVersionInfo.toBytes();
        var copyNetworkVersionInfo = NetworkVersionInfo.fromBytes(networkVersionInfoBytes);
        assertThat(originalNetworkVersionInfo.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(copyNetworkVersionInfo.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalNetworkVersionInfo.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/NftIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeoutException;

import static org.assertj.core.api.Assertions.assertThat;

class NftIdTest {

    static Client mainnetClient;
    static Client testnetClient;
    static Client previewnetClient;

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
        mainnetClient = Client.forMainnet();
        testnetClient = Client.forTestnet();
        previewnetClient = Client.forPreviewnet();
    }

    @AfterAll
    public static void afterAll() throws TimeoutException {
        mainnetClient.close();
        testnetClient.close();
        previewnetClient.close();
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromString() {
        SnapshotMatcher.expect(NftId.fromString("0.0.5005@1234").toString()).toMatchSnapshot();
    }

    @Test
    void fromString2() {
        SnapshotMatcher.expect(NftId.fromString("0.0.5005/1234").toString()).toMatchSnapshot();
    }

    @Test
    void toFromString() {
        var id1 = NftId.fromString("0.0.5005@1234");
        var id2 = NftId.fromString(id1.toString());
        assertThat(id2.toString()).isEqualTo(id1.toString());
    }

    @Test
    void fromStringWithChecksumOnMainnet() {
        SnapshotMatcher.expect(NftId.fromString("0.0.123-vfmkw/7584").toStringWithChecksum(mainnetClient)).toMatchSnapshot();
    }

    @Test
    void fromStringWithChecksumOnTestnet() {
        SnapshotMatcher.expect(NftId.fromString("0.0.123-esxsf@584903").toStringWithChecksum(testnetClient)).toMatchSnapshot();
    }

    @Test
    void fromStringWithChecksumOnPreviewnet() {
        SnapshotMatcher.expect(NftId.fromString("0.0.123-ogizo/487302").toStringWithChecksum(previewnetClient)).toMatchSnapshot();
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(Hex.toHexString(new TokenId(5005).nft(4920).toBytes())).toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(NftId.fromBytes(new TokenId(5005).nft(574489).toBytes()).toString()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/NodeCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.NodeCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class NodeCreateTransactionTest {

    private static final PrivateKey TEST_PRIVATE_KEY = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final AccountId TEST_ACCOUNT_ID = AccountId.fromString("0.6.9");

    private static final String TEST_DESCRIPTION = "Test description";

    private static final List<Endpoint> TEST_GOSSIP_ENDPOINTS = List.of(
        spawnTestEndpoint((byte) 0),
        spawnTestEndpoint((byte) 1),
        spawnTestEndpoint((byte) 2)
    );

    private static final List<Endpoint> TEST_SERVICE_ENDPOINTS = List.of(
        spawnTestEndpoint((byte) 3),
        spawnTestEndpoint((byte) 4),
        spawnTestEndpoint((byte) 5),
        spawnTestEndpoint((byte) 6)
    );

    private static final byte[] TEST_GOSSIP_CA_CERTIFICATE = new byte[]{0, 1, 2, 3, 4};

    private static final byte[] TEST_GRPC_CERTIFICATE_HASH = new byte[]{5, 6, 7, 8, 9};

    private static final PublicKey TEST_ADMIN_KEY = PrivateKey.fromString(
        "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b")
        .getPublicKey();

    final Instant TEST_VALID_START = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private static Endpoint spawnTestEndpoint(byte offset) {
        return new Endpoint()
            .setAddress(new byte[] {0x00, 0x01, 0x02, 0x03})
            .setDomainName(offset + "unit.test.com")
            .setPort(42 + offset);
    }

    private NodeCreateTransaction spawnTestTransaction() {
        return new NodeCreateTransaction()
            .setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), TEST_VALID_START))
            .setAccountId(TEST_ACCOUNT_ID)
            .setDescription(TEST_DESCRIPTION)
            .setGossipEndpoints(TEST_GOSSIP_ENDPOINTS)
            .setServiceEndpoints(TEST_SERVICE_ENDPOINTS)
            .setGossipCaCertificate(TEST_GOSSIP_CA_CERTIFICATE)
            .setGrpcCertificateHash(TEST_GRPC_CERTIFICATE_HASH)
            .setAdminKey(TEST_ADMIN_KEY)
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(TEST_PRIVATE_KEY);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = NodeCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setNodeCreate(NodeCreateTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(NodeCreateTransaction.class);
    }

    @Test
    void constructNodeCreateTransactionFromTransactionBodyProtobuf() {
        var transactionBodyBuilder = NodeCreateTransactionBody.newBuilder();

        transactionBodyBuilder.setAccountId(TEST_ACCOUNT_ID.toProtobuf());
        transactionBodyBuilder.setDescription(TEST_DESCRIPTION);

        for (Endpoint gossipEndpoint : TEST_GOSSIP_ENDPOINTS) {
            transactionBodyBuilder.addGossipEndpoint(gossipEndpoint.toProtobuf());
        }

        for (Endpoint serviceEndpoint : TEST_SERVICE_ENDPOINTS) {
            transactionBodyBuilder.addServiceEndpoint(serviceEndpoint.toProtobuf());
        }

        transactionBodyBuilder.setGossipCaCertificate(ByteString.copyFrom(TEST_GOSSIP_CA_CERTIFICATE));
        transactionBodyBuilder.setGrpcCertificateHash(ByteString.copyFrom(TEST_GRPC_CERTIFICATE_HASH));
        transactionBodyBuilder.setAdminKey(TEST_ADMIN_KEY.toProtobufKey());

        var tx = TransactionBody.newBuilder().setNodeCreate(transactionBodyBuilder.build()).build();
        var nodeCreateTransaction = new NodeCreateTransaction(tx);

        assertThat(nodeCreateTransaction.getAccountId()).isEqualTo(TEST_ACCOUNT_ID);
        assertThat(nodeCreateTransaction.getDescription()).isEqualTo(TEST_DESCRIPTION);
        assertThat(nodeCreateTransaction.getGossipEndpoints()).hasSize(TEST_GOSSIP_ENDPOINTS.size());
        assertThat(nodeCreateTransaction.getServiceEndpoints()).hasSize(TEST_SERVICE_ENDPOINTS.size());
        assertThat(nodeCreateTransaction.getGossipCaCertificate()).isEqualTo(TEST_GOSSIP_CA_CERTIFICATE);
        assertThat(nodeCreateTransaction.getGrpcCertificateHash()).isEqualTo(TEST_GRPC_CERTIFICATE_HASH);
        assertThat(nodeCreateTransaction.getAdminKey()).isEqualTo(TEST_ADMIN_KEY);
    }

    @Test
    void getSetAccountId() {
        var nodeCreateTransaction = new NodeCreateTransaction().setAccountId(TEST_ACCOUNT_ID);
        assertThat(nodeCreateTransaction.getAccountId()).isEqualTo(TEST_ACCOUNT_ID);
    }

    @Test
    void getSetAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAccountId(TEST_ACCOUNT_ID));
    }

    @Test
    void getSetDescription() {
        var nodeCreateTransaction = new NodeCreateTransaction().setDescription(TEST_DESCRIPTION);
        assertThat(nodeCreateTransaction.getDescription()).isEqualTo(TEST_DESCRIPTION);
    }

    @Test
    void getSetDescriptionFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setDescription(TEST_DESCRIPTION));
    }

    @Test
    void getSetGossipEndpoints() {
        var nodeCreateTransaction = new NodeCreateTransaction().setGossipEndpoints(TEST_GOSSIP_ENDPOINTS);
        assertThat(nodeCreateTransaction.getGossipEndpoints()).isEqualTo(TEST_GOSSIP_ENDPOINTS);
    }

    @Test
    void setTestGossipEndpointsFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setGossipEndpoints(TEST_GOSSIP_ENDPOINTS));
    }

    @Test
    void getSetServiceEndpoints() {
        var nodeCreateTransaction = new NodeCreateTransaction().setServiceEndpoints(TEST_SERVICE_ENDPOINTS);
        assertThat(nodeCreateTransaction.getServiceEndpoints()).isEqualTo(TEST_SERVICE_ENDPOINTS);
    }

    @Test
    void getSetServiceEndpointsFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setServiceEndpoints(TEST_SERVICE_ENDPOINTS));
    }

    @Test
    void getSetGossipCaCertificate() {
        var nodeCreateTransaction = new NodeCreateTransaction().setGossipCaCertificate(TEST_GOSSIP_CA_CERTIFICATE);
        assertThat(nodeCreateTransaction.getGossipCaCertificate()).isEqualTo(TEST_GOSSIP_CA_CERTIFICATE);
    }

    @Test
    void getSetGossipCaCertificateFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setGossipCaCertificate(TEST_GOSSIP_CA_CERTIFICATE));
    }

    @Test
    void getSetGrpcCertificateHash() {
        var nodeCreateTransaction = new NodeCreateTransaction().setGrpcCertificateHash(TEST_GRPC_CERTIFICATE_HASH);
        assertThat(nodeCreateTransaction.getGrpcCertificateHash()).isEqualTo(TEST_GRPC_CERTIFICATE_HASH);
    }

    @Test
    void getSetGrpcCertificateHashFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setGrpcCertificateHash(TEST_GRPC_CERTIFICATE_HASH));
    }

    @Test
    void getSetAdminKey() {
        var nodeCreateTransaction = new NodeCreateTransaction().setAdminKey(TEST_ADMIN_KEY);
        assertThat(nodeCreateTransaction.getAdminKey()).isEqualTo(TEST_ADMIN_KEY);
    }

    @Test
    void getSetAdminKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAdminKey(TEST_ADMIN_KEY));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/NodeDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.hedera.hashgraph.sdk.proto.NodeDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.Arrays;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class NodeDeleteTransactionTest {

    private static final PrivateKey TEST_PRIVATE_KEY = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final long TEST_NODE_ID = 420;

    final Instant TEST_VALID_START = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private NodeDeleteTransaction spawnTestTransaction() {
        return new NodeDeleteTransaction()
            .setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), TEST_VALID_START))
            .setNodeId(TEST_NODE_ID)
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(TEST_PRIVATE_KEY);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = NodeDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setNodeDelete(NodeDeleteTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(NodeDeleteTransaction.class);
    }

    @Test
    void constructNodeDeleteTransactionFromTransactionBodyProtobuf() {
        var transactionBodyBuilder = NodeDeleteTransactionBody.newBuilder();

        transactionBodyBuilder.setNodeId(TEST_NODE_ID);

        var tx = TransactionBody.newBuilder().setNodeDelete(transactionBodyBuilder.build()).build();
        var nodeDeleteTransaction = new NodeDeleteTransaction(tx);

        assertThat(nodeDeleteTransaction.getNodeId()).isEqualTo(TEST_NODE_ID);
    }

    @Test
    void getSetNodeId() {
        var nodeDeleteTransaction = new NodeDeleteTransaction().setNodeId(TEST_NODE_ID);
        assertThat(nodeDeleteTransaction.getNodeId()).isEqualTo(TEST_NODE_ID);
    }

    @Test
    void getSetNodeIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setNodeId(TEST_NODE_ID));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/NodeUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.NodeUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class NodeUpdateTransactionTest {

    private static final PrivateKey TEST_PRIVATE_KEY = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final long TEST_NODE_ID = 420;

    private static final AccountId TEST_ACCOUNT_ID = AccountId.fromString("0.6.9");

    private static final String TEST_DESCRIPTION = "Test description";

    private static final List<Endpoint> TEST_GOSSIP_ENDPOINTS = List.of(
        spawnTestEndpoint((byte) 0),
        spawnTestEndpoint((byte) 1),
        spawnTestEndpoint((byte) 2)
    );

    private static final List<Endpoint> TEST_SERVICE_ENDPOINTS = List.of(
        spawnTestEndpoint((byte) 3),
        spawnTestEndpoint((byte) 4),
        spawnTestEndpoint((byte) 5),
        spawnTestEndpoint((byte) 6)
    );

    private static final byte[] TEST_GOSSIP_CA_CERTIFICATE = new byte[]{0, 1, 2, 3, 4};

    private static final byte[] TEST_GRPC_CERTIFICATE_HASH = new byte[]{5, 6, 7, 8, 9};

    private static final PublicKey TEST_ADMIN_KEY = PrivateKey.fromString(
            "302e020100300506032b65700422042062c4b69e9f45a554e5424fb5a6fe5e6ac1f19ead31dc7718c2d980fd1f998d4b")
        .getPublicKey();

    final Instant TEST_VALID_START = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private static Endpoint spawnTestEndpoint(byte offset) {
        return new Endpoint()
            .setAddress(new byte[] {0x00, 0x01, 0x02, 0x03})
            .setDomainName(offset + "unit.test.com")
            .setPort(42 + offset);
    }

    private NodeUpdateTransaction spawnTestTransaction() {
        return new NodeUpdateTransaction()
            .setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), TEST_VALID_START))
            .setNodeId(TEST_NODE_ID)
            .setAccountId(TEST_ACCOUNT_ID)
            .setAccountId(TEST_ACCOUNT_ID)
            .setDescription(TEST_DESCRIPTION)
            .setGossipEndpoints(TEST_GOSSIP_ENDPOINTS)
            .setServiceEndpoints(TEST_SERVICE_ENDPOINTS)
            .setGossipCaCertificate(TEST_GOSSIP_CA_CERTIFICATE)
            .setGrpcCertificateHash(TEST_GRPC_CERTIFICATE_HASH)
            .setAdminKey(TEST_ADMIN_KEY)
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(TEST_PRIVATE_KEY);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = NodeUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setNodeUpdate(NodeUpdateTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(NodeUpdateTransaction.class);
    }

    @Test
    void constructNodeUpdateTransactionFromTransactionBodyProtobuf() {
        var transactionBodyBuilder = NodeUpdateTransactionBody.newBuilder();

        transactionBodyBuilder.setNodeId(TEST_NODE_ID);
        transactionBodyBuilder.setAccountId(TEST_ACCOUNT_ID.toProtobuf());
        transactionBodyBuilder.setDescription(StringValue.of(TEST_DESCRIPTION));

        for (Endpoint gossipEndpoint : TEST_GOSSIP_ENDPOINTS) {
            transactionBodyBuilder.addGossipEndpoint(gossipEndpoint.toProtobuf());
        }

        for (Endpoint serviceEndpoint : TEST_SERVICE_ENDPOINTS) {
            transactionBodyBuilder.addServiceEndpoint(serviceEndpoint.toProtobuf());
        }

        transactionBodyBuilder.setGossipCaCertificate(BytesValue.of(ByteString.copyFrom(TEST_GOSSIP_CA_CERTIFICATE)));
        transactionBodyBuilder.setGrpcCertificateHash(BytesValue.of(ByteString.copyFrom(TEST_GRPC_CERTIFICATE_HASH)));
        transactionBodyBuilder.setAdminKey(TEST_ADMIN_KEY.toProtobufKey());

        var tx = TransactionBody.newBuilder().setNodeUpdate(transactionBodyBuilder.build()).build();
        var nodeUpdateTransaction = new NodeUpdateTransaction(tx);

        assertThat(nodeUpdateTransaction.getNodeId()).isEqualTo(TEST_NODE_ID);
        assertThat(nodeUpdateTransaction.getAccountId()).isEqualTo(TEST_ACCOUNT_ID);
        assertThat(nodeUpdateTransaction.getDescription()).isEqualTo(TEST_DESCRIPTION);
        assertThat(nodeUpdateTransaction.getGossipEndpoints()).hasSize(TEST_GOSSIP_ENDPOINTS.size());
        assertThat(nodeUpdateTransaction.getServiceEndpoints()).hasSize(TEST_SERVICE_ENDPOINTS.size());
        assertThat(nodeUpdateTransaction.getGossipCaCertificate()).isEqualTo(TEST_GOSSIP_CA_CERTIFICATE);
        assertThat(nodeUpdateTransaction.getGrpcCertificateHash()).isEqualTo(TEST_GRPC_CERTIFICATE_HASH);
        assertThat(nodeUpdateTransaction.getAdminKey()).isEqualTo(TEST_ADMIN_KEY);
    }

    @Test
    void getSetNodeId() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setNodeId(TEST_NODE_ID);
        assertThat(nodeUpdateTransaction.getNodeId()).isEqualTo(TEST_NODE_ID);
    }

    @Test
    void getSetNodeIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setNodeId(TEST_NODE_ID));
    }

    @Test
    void getSetAccountId() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setAccountId(TEST_ACCOUNT_ID);
        assertThat(nodeUpdateTransaction.getAccountId()).isEqualTo(TEST_ACCOUNT_ID);
    }

    @Test
    void getSetAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAccountId(TEST_ACCOUNT_ID));
    }

    @Test
    void getSetDescription() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setDescription(TEST_DESCRIPTION);
        assertThat(nodeUpdateTransaction.getDescription()).isEqualTo(TEST_DESCRIPTION);
    }

    @Test
    void getSetDescriptionFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setDescription(TEST_DESCRIPTION));
    }

    @Test
    void getSetGossipEndpoints() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setGossipEndpoints(TEST_GOSSIP_ENDPOINTS);
        assertThat(nodeUpdateTransaction.getGossipEndpoints()).isEqualTo(TEST_GOSSIP_ENDPOINTS);
    }

    @Test
    void setTestGossipEndpointsFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setGossipEndpoints(TEST_GOSSIP_ENDPOINTS));
    }

    @Test
    void getSetServiceEndpoints() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setServiceEndpoints(TEST_SERVICE_ENDPOINTS);
        assertThat(nodeUpdateTransaction.getServiceEndpoints()).isEqualTo(TEST_SERVICE_ENDPOINTS);
    }

    @Test
    void getSetServiceEndpointsFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setServiceEndpoints(TEST_SERVICE_ENDPOINTS));
    }

    @Test
    void getSetGossipCaCertificate() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setGossipCaCertificate(TEST_GOSSIP_CA_CERTIFICATE);
        assertThat(nodeUpdateTransaction.getGossipCaCertificate()).isEqualTo(TEST_GOSSIP_CA_CERTIFICATE);
    }

    @Test
    void getSetGossipCaCertificateFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setGossipCaCertificate(TEST_GOSSIP_CA_CERTIFICATE));
    }

    @Test
    void getSetGrpcCertificateHash() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setGrpcCertificateHash(TEST_GRPC_CERTIFICATE_HASH);
        assertThat(nodeUpdateTransaction.getGrpcCertificateHash()).isEqualTo(TEST_GRPC_CERTIFICATE_HASH);
    }

    @Test
    void getSetGrpcCertificateHashFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setGrpcCertificateHash(TEST_GRPC_CERTIFICATE_HASH));
    }

    @Test
    void getSetAdminKey() {
        var nodeUpdateTransaction = new NodeUpdateTransaction().setAdminKey(TEST_ADMIN_KEY);
        assertThat(nodeUpdateTransaction.getAdminKey()).isEqualTo(TEST_ADMIN_KEY);
    }

    @Test
    void getSetAdminKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAdminKey(TEST_ADMIN_KEY));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/PendingAirdropIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.hedera.hashgraph.sdk;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class PendingAirdropIdTest {
    private AccountId sender;
    private AccountId receiver;
    private TokenId tokenId;
    private NftId nftId;

    @BeforeEach
    void setUp() {
        sender = new AccountId(1001);
        receiver = new AccountId(1002);
        tokenId = new TokenId(1003);
        nftId = new NftId(new TokenId(1004), 1);
    }

    @Test
    void testConstructorWithTokenId() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(sender, receiver, tokenId);

        assertEquals(sender, pendingAirdropId.getSender());
        assertEquals(receiver, pendingAirdropId.getReceiver());
        assertEquals(tokenId, pendingAirdropId.getTokenId());
        assertNull(pendingAirdropId.getNftId());
    }

    @Test
    void testConstructorWithNftId() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(sender, receiver, nftId);

        assertEquals(sender, pendingAirdropId.getSender());
        assertEquals(receiver, pendingAirdropId.getReceiver());
        assertEquals(nftId, pendingAirdropId.getNftId());
        assertNull(pendingAirdropId.getTokenId());
    }

    @Test
    void testSetSender() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId();
        pendingAirdropId.setSender(sender);

        assertEquals(sender, pendingAirdropId.getSender());
    }

    @Test
    void testSetReceiver() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId();
        pendingAirdropId.setReceiver(receiver);

        assertEquals(receiver, pendingAirdropId.getReceiver());
    }

    @Test
    void testSetTokenId() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId();
        pendingAirdropId.setTokenId(tokenId);

        assertEquals(tokenId, pendingAirdropId.getTokenId());
    }

    @Test
    void testSetNftId() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId();
        pendingAirdropId.setNftId(nftId);

        assertEquals(nftId, pendingAirdropId.getNftId());
    }

    @Test
    void testToProtobufWithTokenId() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(sender, receiver, tokenId);
        com.hedera.hashgraph.sdk.proto.PendingAirdropId proto = pendingAirdropId.toProtobuf();

        assertNotNull(proto);
        assertEquals(sender.toProtobuf(), proto.getSenderId());
        assertEquals(receiver.toProtobuf(), proto.getReceiverId());
        assertEquals(tokenId.toProtobuf(), proto.getFungibleTokenType());
    }

    @Test
    void testToProtobufWithNftId() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(sender, receiver, nftId);
        com.hedera.hashgraph.sdk.proto.PendingAirdropId proto = pendingAirdropId.toProtobuf();

        assertNotNull(proto);
        assertEquals(sender.toProtobuf(), proto.getSenderId());
        assertEquals(receiver.toProtobuf(), proto.getReceiverId());
        assertEquals(nftId.toProtobuf(), proto.getNonFungibleToken());
    }

    @Test
    void testFromProtobufWithTokenId() {
        com.hedera.hashgraph.sdk.proto.PendingAirdropId proto = com.hedera.hashgraph.sdk.proto.PendingAirdropId.newBuilder()
            .setSenderId(sender.toProtobuf())
            .setReceiverId(receiver.toProtobuf())
            .setFungibleTokenType(tokenId.toProtobuf())
            .build();

        PendingAirdropId pendingAirdropId = PendingAirdropId.fromProtobuf(proto);

        assertNotNull(pendingAirdropId);
        assertEquals(sender, pendingAirdropId.getSender());
        assertEquals(receiver, pendingAirdropId.getReceiver());
        assertEquals(tokenId, pendingAirdropId.getTokenId());
        assertNull(pendingAirdropId.getNftId());
    }

    @Test
    void testFromProtobufWithNftId() {
        com.hedera.hashgraph.sdk.proto.PendingAirdropId proto = com.hedera.hashgraph.sdk.proto.PendingAirdropId.newBuilder()
            .setSenderId(sender.toProtobuf())
            .setReceiverId(receiver.toProtobuf())
            .setNonFungibleToken(nftId.toProtobuf())
            .build();

        PendingAirdropId pendingAirdropId = PendingAirdropId.fromProtobuf(proto);

        assertNotNull(pendingAirdropId);
        assertEquals(sender, pendingAirdropId.getSender());
        assertEquals(receiver, pendingAirdropId.getReceiver());
        assertEquals(nftId, pendingAirdropId.getNftId());
        assertNull(pendingAirdropId.getTokenId());
    }

    @Test
    void testToString() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(sender, receiver, tokenId);
        String result = pendingAirdropId.toString();

        assertTrue(result.contains("sender"));
        assertTrue(result.contains("receiver"));
        assertTrue(result.contains("tokenId"));
        assertTrue(result.contains("nftId"));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/PrivateKeyTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;

public class PrivateKeyTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @Test
    void signTransactionWorks() throws InvalidProtocolBufferException {
        byte[] bytes = new AccountCreateTransaction()
            .setNodeAccountIds(Collections.singletonList(AccountId.fromString("0.0.5005")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setKey(unusedPrivateKey)
            .setInitialBalance(Hbar.fromTinybars(450))
            .setProxyAccountId(AccountId.fromString("0.0.1001"))
            .setReceiverSignatureRequired(true)
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .toBytes();

        AccountCreateTransaction transaction = (AccountCreateTransaction) Transaction.fromBytes(bytes);
        unusedPrivateKey.signTransaction(transaction);
    }

    @Test
    void ecdsa() {
        var message = "hello world".getBytes(StandardCharsets.UTF_8);
        var key = PrivateKey.fromStringECDSA("8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048");
        var signature = key.sign(message);

        assertThat(Hex.toHexString(signature)).isEqualTo("f3a13a555f1f8cd6532716b8f388bd4e9d8ed0b252743e923114c0c6cbfe414cf791c8e859afd3c12009ecf2cb20dacf01636d80823bcdbd9ec1ce59afe008f0");
    }

    @Test
    void supports0xPrefix() {
        PrivateKey.fromString("0x8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048");
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/PrngTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

public class PrngTransactionTest {

    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private PrngTransaction spawnTestTransaction() {
        return new PrngTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    private PrngTransaction spawnTestTransaction2() {
        return new PrngTransaction()
            .setRange(100)
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    @Test
    void shouldSerialize2() {
        SnapshotMatcher.expect(spawnTestTransaction2()
            .toString()
        ).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ProxyStakerTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ProxyStaker;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class ProxyStakerTest {
    private static final ProxyStaker proxyStaker = ProxyStaker.newBuilder()
        .setAccountID(new AccountId(100).toProtobuf())
        .setAmount(10)
        .build();

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(com.hedera.hashgraph.sdk.ProxyStaker.fromProtobuf(proxyStaker).toString())
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ReceiptStatusExceptionTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

class ReceiptStatusExceptionTest {

    @Test
    void shouldHaveMessage() {
        var validStart = Instant.ofEpochSecond(1554158542);
        var txId = new TransactionId(new AccountId(0, 0, 100), validStart);
        var txReceipt = TransactionReceipt.fromProtobuf(
            com.hedera.hashgraph.sdk.proto.TransactionReceipt
                .newBuilder()
                .setStatusValue(ResponseCodeEnum.INSUFFICIENT_TX_FEE_VALUE)
                .build());
        var e = new ReceiptStatusException(
            txId,
            txReceipt
        );

        assertThat(e.getMessage()).isEqualTo(
            "receipt for transaction 0.0.100@1554158542.000000000 raised status INSUFFICIENT_TX_FEE"
        );
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/RegenerateTransactionIdsTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.Status;
import org.junit.jupiter.api.Test;

import java.util.HashSet;
import java.util.List;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

public class RegenerateTransactionIdsTest {
    @Test
    void regeneratesTransactionIdsWhenTransactionExpiredIsReturned() throws PrecheckStatusException, TimeoutException, InterruptedException {
        var transactionIds = new HashSet<TransactionId>();
        AtomicInteger count = new AtomicInteger(0);

        var responses = List.of(
            TransactionResponse.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.TRANSACTION_EXPIRED).build(),
            TransactionResponse.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.TRANSACTION_EXPIRED).build(),
            TransactionResponse.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.TRANSACTION_EXPIRED).build(),
            TransactionResponse.newBuilder().setNodeTransactionPrecheckCode(ResponseCodeEnum.OK).build()
        );

        var call = (Function<Object, Object>) o -> {
            try {
                var transaction = (Transaction) o;
                var signedTransaction = SignedTransaction.parseFrom(transaction.getSignedTransactionBytes());
                var transactionBody = TransactionBody.parseFrom(signedTransaction.getBodyBytes());
                var transactionId = TransactionId.fromProtobuf(transactionBody.getTransactionID());

                if (transactionIds.contains(transactionId)) {
                    return Status.Code.ABORTED.toStatus().asRuntimeException();
                }

                transactionIds.add(transactionId);

                return responses.get(count.getAndIncrement());
            } catch (Throwable e) {
                return new RuntimeException(e);
            }
        };

        List<Object> responses1 = List.of(
            call, call, call, call
        );

        try (var mocker = Mocker.withResponses(List.of(responses1))) {
            new FileCreateTransaction().execute(mocker.client);
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/RequestTypeTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.HederaFunctionality;
import org.junit.jupiter.api.Test;

import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.assertj.core.api.Assertions.assertThat;

class RequestTypeTest {

    @Test
    void valueOf() {
        var codeValues = HederaFunctionality.values();
        var requestTypeValues = RequestType.values();
        var pair = IntStream.range(0, codeValues.length-1)
            .mapToObj(i -> Map.entry(codeValues[i], requestTypeValues[i]))
            .collect(Collectors.toList());

        pair.forEach((a) -> {
            var code = a.getKey();
            var requestType = a.getValue();
            assertThat(RequestType.valueOf(code)).hasToString(requestType.toString());
        });
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ScheduleCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ScheduleCreateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }


    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private ScheduleCreateTransaction spawnTestTransaction() {
        var transferTransaction = new TransferTransaction()
            .addHbarTransfer(AccountId.fromString("0.0.555"), new Hbar(-10))
            .addHbarTransfer(AccountId.fromString("0.0.333"), new Hbar(10));
        return transferTransaction.schedule()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAdminKey(unusedPrivateKey)
            .setPayerAccountId(AccountId.fromString("0.0.222"))
            .setScheduleMemo("hi")
            .setMaxTransactionFee(new Hbar(1))
            .setExpirationTime(validStart)
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ScheduleCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ScheduleDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.ScheduleDeleteTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ScheduleDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private ScheduleDeleteTransaction spawnTestTransaction() {
        return new ScheduleDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setScheduleId(ScheduleId.fromString("0.0.444"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ScheduleDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setScheduleDelete(ScheduleDeleteTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(ScheduleDeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ScheduleInfoQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class ScheduleInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new ScheduleInfoQuery()
            .setScheduleId(ScheduleId.fromString("0.0.5005"))
            .setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ScheduleInfoTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.CryptoDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class ScheduleInfoTest {
    private static final PublicKey unusedPublicKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10"
    ).getPublicKey();

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    ScheduleInfo spawnScheduleInfoExample() {
        return new ScheduleInfo(
            ScheduleId.fromString("1.2.3"),
            AccountId.fromString("4.5.6"),
            AccountId.fromString("2.3.4"),
            SchedulableTransactionBody.newBuilder()
                .setCryptoDelete(CryptoDeleteTransactionBody.newBuilder()
                    .setDeleteAccountID(AccountId.fromString("6.6.6").toProtobuf()).build()).build(),
            KeyList.of(unusedPublicKey),
            unusedPublicKey,
            TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart),
            "memo",
            validStart,
            validStart,
            null,
            LedgerId.TESTNET,
            true
        );
    }

    ScheduleInfo spawnScheduleInfoDeletedExample() {
        return new ScheduleInfo(
            ScheduleId.fromString("1.2.3"),
            AccountId.fromString("4.5.6"),
            AccountId.fromString("2.3.4"),
            SchedulableTransactionBody.newBuilder()
                .setCryptoDelete(CryptoDeleteTransactionBody.newBuilder()
                    .setDeleteAccountID(AccountId.fromString("6.6.6").toProtobuf()).build()).build(),
            KeyList.of(unusedPublicKey),
            unusedPublicKey,
            TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart),
            "memo",
            validStart,
            null,
            validStart,
            LedgerId.TESTNET,
            true
        );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalScheduleInfo = spawnScheduleInfoExample();
        byte[] scheduleInfoBytes = originalScheduleInfo.toBytes();
        var copyScheduleInfo = ScheduleInfo.fromBytes(scheduleInfoBytes);
        assertThat(copyScheduleInfo.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalScheduleInfo.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalScheduleInfo.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void shouldSerializeDeleted() throws Exception {
        var originalScheduleInfo = spawnScheduleInfoDeletedExample();
        byte[] scheduleInfoBytes = originalScheduleInfo.toBytes();
        var copyScheduleInfo = ScheduleInfo.fromBytes(scheduleInfoBytes);
        assertThat(copyScheduleInfo.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalScheduleInfo.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalScheduleInfo.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/ScheduleSignTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class ScheduleSignTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private ScheduleSignTransaction spawnTestTransaction() {
        return new ScheduleSignTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setScheduleId(ScheduleId.fromString("0.0.444"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = ScheduleSignTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/StakingInfoTest.java
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class StakingInfoTest {
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    StakingInfo spawnStakingInfoAccountExample() {
        return new StakingInfo(
            true,
            validStart,
            Hbar.from(5),
            Hbar.from(10),
            AccountId.fromString("1.2.3"),
            null
        );
    }

    StakingInfo spawnStakingInfoNodeExample() {
        return new StakingInfo(
            true,
            validStart,
            Hbar.from(5),
            Hbar.from(10),
            null,
            3L
        );
    }

    @Test
    void shouldSerializeAccount() throws Exception {
        var originalStakingInfo = spawnStakingInfoAccountExample();
        byte[] stakingInfoBytes = originalStakingInfo.toBytes();
        var copyStakingInfo = StakingInfo.fromBytes(stakingInfoBytes);
        assertThat(copyStakingInfo.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalStakingInfo.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalStakingInfo.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void shouldSerializeNode() throws Exception {
        var originalStakingInfo = spawnStakingInfoNodeExample();
        byte[] stakingInfoBytes = originalStakingInfo.toBytes();
        var copyStakingInfo = StakingInfo.fromBytes(stakingInfoBytes);
        assertThat(copyStakingInfo.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalStakingInfo.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalStakingInfo.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/StatusTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ResponseCodeEnum;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class StatusTest {
    @Test
    @DisplayName("Status can be constructed from any ResponseCode")
    void statusToResponseCode() {
        for (ResponseCodeEnum code : ResponseCodeEnum.values()) {
            // not an actual value we want to handle
            // this is what we're given if an unexpected value was decoded
            if (code == ResponseCodeEnum.UNRECOGNIZED) {
                continue;
            }

            Status status = Status.valueOf(code);

            assertThat(code.getNumber()).isEqualTo(status.code.getNumber());
        }
    }

    @Test
    @DisplayName("Status throws on Unrecognized")
    void statusUnrecognized() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> Status.valueOf(ResponseCodeEnum.UNRECOGNIZED)
        ).withMessage("network returned unrecognized response code; your SDK may be out of date");
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/SystemDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SystemDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.TimestampSeconds;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class SystemDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final FileId testFileId = FileId.fromString("4.2.0");
    private static final ContractId testContractId = ContractId.fromString("0.6.9");
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFile() {
        SnapshotMatcher.expect(spawnTestTransactionFile().toString()).toMatchSnapshot();
    }

    private SystemDeleteTransaction spawnTestTransactionFile() {
        return new SystemDeleteTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(FileId.fromString("0.0.444")).setExpirationTime(validStart).setMaxTransactionFee(new Hbar(1))
            .freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldSerializeContract() {
        SnapshotMatcher.expect(spawnTestTransactionContract().toString()).toMatchSnapshot();
    }

    private SystemDeleteTransaction spawnTestTransactionContract() {
        return new SystemDeleteTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContractId(ContractId.fromString("0.0.444")).setExpirationTime(validStart)
            .setMaxTransactionFee(new Hbar(1)).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldBytesContract() throws Exception {
        var tx = spawnTestTransactionContract();
        var tx2 = ScheduleDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytesFile() throws Exception {
        var tx = spawnTestTransactionFile();
        var tx2 = SystemDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setSystemDelete(SystemDeleteTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(SystemDeleteTransaction.class);
    }

    @Test
    void constructSystemDeleteTransactionFromTransactionBodyProtobuf() {
        var transactionBodyWithFileId = SystemDeleteTransactionBody.newBuilder().setFileID(testFileId.toProtobuf())
            .setExpirationTime(TimestampSeconds.newBuilder().setSeconds(validStart.getEpochSecond()));

        var transactionBodyWithContractId = SystemDeleteTransactionBody.newBuilder()
            .setContractID(testContractId.toProtobuf())
            .setExpirationTime(TimestampSeconds.newBuilder().setSeconds(validStart.getEpochSecond()));

        var txWithFileId = TransactionBody.newBuilder().setSystemDelete(transactionBodyWithFileId).build();
        var systemDeleteTransactionWithFileId = new SystemDeleteTransaction(txWithFileId);

        var txWithContractId = TransactionBody.newBuilder().setSystemDelete(transactionBodyWithContractId).build();
        var systemDeleteTransactionWithContractId = new SystemDeleteTransaction(txWithContractId);

        assertNotNull(systemDeleteTransactionWithFileId.getFileId());
        assertThat(systemDeleteTransactionWithFileId.getFileId()).isEqualTo(testFileId);
        assertNull(systemDeleteTransactionWithFileId.getContractId());
        assertThat(systemDeleteTransactionWithFileId.getExpirationTime().getEpochSecond()).isEqualTo(
            validStart.getEpochSecond());

        assertNull(systemDeleteTransactionWithContractId.getFileId());
        assertNotNull(systemDeleteTransactionWithContractId.getContractId());
        assertThat(systemDeleteTransactionWithContractId.getContractId()).isEqualTo(testContractId);
        assertThat(systemDeleteTransactionWithContractId.getExpirationTime().getEpochSecond()).isEqualTo(
            validStart.getEpochSecond());
    }

    @Test
    void getSetFileId() {
        var systemDeleteTransaction = new SystemDeleteTransaction().setFileId(testFileId);
        assertNotNull(systemDeleteTransaction.getFileId());
        assertThat(systemDeleteTransaction.getFileId()).isEqualTo(testFileId);
    }

    @Test
    void getSetFileIdFrozen() {
        var tx = spawnTestTransactionFile();
        assertThrows(IllegalStateException.class, () -> tx.setFileId(testFileId));
    }

    @Test
    void getSetContractId() {
        var systemDeleteTransaction = new SystemDeleteTransaction().setContractId(testContractId);
        assertNotNull(systemDeleteTransaction.getContractId());
        assertThat(systemDeleteTransaction.getContractId()).isEqualTo(testContractId);
    }

    @Test
    void getSetContractIdFrozen() {
        var tx = spawnTestTransactionContract();
        assertThrows(IllegalStateException.class, () -> tx.setContractId(testContractId));
    }

    @Test
    void getSetExpirationTime() {
        var systemDeleteTransaction = new SystemDeleteTransaction().setExpirationTime(validStart);
        assertNotNull(systemDeleteTransaction.getExpirationTime());
        assertThat(systemDeleteTransaction.getExpirationTime().getEpochSecond()).isEqualTo(validStart.getEpochSecond());
    }

    @Test
    void getSetExpirationTimeFrozen() {
        var tx = spawnTestTransactionFile();
        assertThrows(IllegalStateException.class, () -> tx.setExpirationTime(validStart));
    }

    // ported from C++ SDK, in Java it does not pass
    @Test
    @Disabled
    void resetFileId() {
        var systemDeleteTransaction = new SystemDeleteTransaction();
        systemDeleteTransaction.setFileId(testFileId);
        systemDeleteTransaction.setContractId(testContractId);

        assertNull(systemDeleteTransaction.getFileId());
        assertNotNull(systemDeleteTransaction.getContractId());
    }

    // ported from C++ SDK, in Java it does not pass
    @Test
    @Disabled
    void resetContractId() {
        var systemDeleteTransaction = new SystemDeleteTransaction();
        systemDeleteTransaction.setContractId(testContractId);
        systemDeleteTransaction.setFileId(testFileId);

        assertNull(systemDeleteTransaction.getContractId());
        assertNotNull(systemDeleteTransaction.getFileId());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/SystemUndeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.SystemUndeleteTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class SystemUndeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFile() {
        SnapshotMatcher.expect(spawnTestTransactionFile()
            .toString()
        ).toMatchSnapshot();
    }

    private SystemUndeleteTransaction spawnTestTransactionFile() {
        return new SystemUndeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFileId(FileId.fromString("0.0.444"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerializeContract() {
        SnapshotMatcher.expect(spawnTestTransactionContract()
            .toString()
        ).toMatchSnapshot();
    }

    private SystemUndeleteTransaction spawnTestTransactionContract() {
        return new SystemUndeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setContractId(ContractId.fromString("0.0.444"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytesContract() throws Exception {
        var tx = spawnTestTransactionContract();
        var tx2 = ScheduleDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytesFile() throws Exception {
        var tx = spawnTestTransactionFile();
        var tx2 = SystemUndeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setSystemUndelete(SystemUndeleteTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(SystemUndeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TestResponse.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.TransactionGetReceiptResponse;
import com.hedera.hashgraph.sdk.proto.TransactionReceipt;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.StatusRuntimeException;

import javax.annotation.Nullable;

public class TestResponse {
    @Nullable
    public final TransactionResponse transactionResponse;
    @Nullable
    public final Response queryResponse;
    @Nullable
    public final StatusRuntimeException errorResponse;

    private TestResponse(
        @Nullable TransactionResponse transactionResponse,
        @Nullable Response queryResponse,
        @Nullable StatusRuntimeException errorResponse
    ) {
        this.transactionResponse = transactionResponse;
        this.queryResponse = queryResponse;
        this.errorResponse = errorResponse;
    }

    public static TestResponse transaction(Status status, Hbar cost) {
        return new TestResponse(buildTransactionResponse(status, cost), null, null);
    }

    public static TestResponse transaction(Status status) {
        return transaction(status, new Hbar(1));
    }

    public static TestResponse transactionOk(Hbar cost) {
        return transaction(Status.OK, cost);
    }

    public static TestResponse transactionOk() {
        return transactionOk(new Hbar(1));
    }

    public static TestResponse query(Response queryResponse) {
        return new TestResponse(null, queryResponse, null);
    }

    public static TestResponse receipt(Status status) {
        var response = Response.newBuilder().setTransactionGetReceipt(
            TransactionGetReceiptResponse.newBuilder().setReceipt(
                TransactionReceipt.newBuilder().setStatus(status.code).build()
            ).build()
        ).build();
        return new TestResponse(null, response, null);
    }

    public static TestResponse successfulReceipt() {
        return receipt(Status.SUCCESS);
    }

    public static TestResponse error(StatusRuntimeException exception) {
        return new TestResponse(null, null, exception);
    }

    public static TransactionResponse buildTransactionResponse(Status status, Hbar cost) {
        return TransactionResponse.newBuilder()
            .setNodeTransactionPrecheckCode(status.code)
            .setCost(cost.toTinybars())
            .build();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TestServer.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import io.grpc.BindableService;
import io.grpc.Server;
import io.grpc.inprocess.InProcessServerBuilder;

import java.io.IOException;
import java.time.Duration;
import java.util.HashMap;
import java.util.concurrent.TimeoutException;

// TODO: we may want to refactor to separate TestClient from TestServer.
//       That way, we can have a client with a network of multiple test servers.
//       Maybe we can test load-balancing?

public class TestServer {
    public final Client client;
    private final Server[] grpcServers = new Server[2];

    public TestServer(String name, BindableService... services) throws IOException {
        for (int i = 0; i < 2; i++) {
            var serverBuilder = InProcessServerBuilder.forName(name + "[" + i + "]");
            for (var service : services) {
                serverBuilder.addService(service);
            }
            grpcServers[i] = serverBuilder.directExecutor().build().start();
        }

        var network = new HashMap<String, AccountId>();
        network.put("in-process:" + name + "[0]", AccountId.fromString("1.1.1"));
        network.put("in-process:" + name + "[1]", AccountId.fromString("2.2.2"));
        client = Client.forNetwork(network)
            .setNodeMinBackoff(Duration.ofMillis(500))
            .setNodeMaxBackoff(Duration.ofMillis(500))
            .setOperator(AccountId.fromString("2.2.2"), PrivateKey.generate());
    }

    public void close() throws TimeoutException, InterruptedException {
        client.close();
        for (var server : grpcServers) {
            server.shutdown();
            server.awaitTermination();
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TestService.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.Query;
import com.hedera.hashgraph.sdk.proto.Response;
import com.hedera.hashgraph.sdk.proto.Transaction;
import com.hedera.hashgraph.sdk.proto.TransactionResponse;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;

import javax.annotation.Nullable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

public interface TestService {

    private static <ResponseTypeT> void respond(
        StreamObserver<ResponseTypeT> streamObserver,
        @Nullable ResponseTypeT normalResponse,
        @Nullable StatusRuntimeException errorResponse,
        String exceptionString
    ) {
        if (normalResponse != null) {
            streamObserver.onNext(normalResponse);
            streamObserver.onCompleted();
        } else if (errorResponse != null) {
            streamObserver.onError(errorResponse);
        } else {
            throw new IllegalStateException(exceptionString);
        }
    }

    Buffer getBuffer();

    default void respondToTransaction(Transaction request, StreamObserver<TransactionResponse> streamObserver, TestResponse response) {
        getBuffer().transactionRequestsReceived.add(request);

        var exceptionString = "TestService tried to respond to transaction with query response";
        respond(streamObserver, response.transactionResponse, response.errorResponse, exceptionString);
    }

    default void respondToQuery(Query request, StreamObserver<Response> streamObserver, TestResponse response) {
        getBuffer().queryRequestsReceived.add(request);

        var exceptionString = "TestService tried to respond to query with transaction response";
        respond(streamObserver, response.queryResponse, response.errorResponse, exceptionString);
    }

    default void respondToTransactionFromQueue(Transaction request, StreamObserver<TransactionResponse> streamObserver) {
        respondToTransaction(request, streamObserver, getBuffer().responsesToSend.remove());
    }

    default void respondToQueryFromQueue(Query request, StreamObserver<Response> streamObserver) {
        respondToQuery(request, streamObserver, getBuffer().responsesToSend.remove());
    }

    class Buffer {
        public final List<Transaction> transactionRequestsReceived = new ArrayList<>();
        public final List<Query> queryRequestsReceived = new ArrayList<>();
        public final Queue<TestResponse> responsesToSend = new ArrayDeque<>();

        public Buffer enqueueResponse(TestResponse response) {
            responsesToSend.add(response);
            return this;
        }
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenAirdropTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenAirdropTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class TokenAirdropTransactionTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);
    private TokenAirdropTransaction transaction;

    @BeforeEach
    public void setUp() {
        transaction = new TokenAirdropTransaction();
    }

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenAirdropTransaction spawnTestTransaction() {
        return new TokenAirdropTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .addTokenTransfer(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5008"), 400)
            .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5006"), -800, 3)
            .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.5007"), 400, 3)
            .addTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5008"), 1)
            .addTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5006"), -1)
            .addNftTransfer(TokenId.fromString("0.0.3").nft(2), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5007"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(1), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5007"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(3), AccountId.fromString("0.0.5008"), AccountId.fromString("0.0.5006"))
            .addNftTransfer(TokenId.fromString("0.0.3").nft(4), AccountId.fromString("0.0.5007"), AccountId.fromString("0.0.5006"))
            .addNftTransfer(TokenId.fromString("0.0.2").nft(4), AccountId.fromString("0.0.5007"), AccountId.fromString("0.0.5006"))
            .addApprovedTokenTransfer(TokenId.fromString("0.0.4"), AccountId.fromString("0.0.5006"), 123)
            .addApprovedNftTransfer(new NftId(TokenId.fromString("0.0.4"), 4), AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006"))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(privateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenAirdropTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void decimalsMustBeConsistent() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            new TokenAirdropTransaction()
                .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.8"), 100, 2)
                .addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.7"), -100, 3);
        });
    }

    @Test
    void canGetDecimals() {
        var tx = new TokenAirdropTransaction();
        assertThat(tx.getTokenIdDecimals().get(TokenId.fromString("0.0.5"))).isNull();
        tx.addTokenTransfer(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.8"), 100);
        assertThat(tx.getTokenIdDecimals().get(TokenId.fromString("0.0.5"))).isNull();
        tx.addTokenTransferWithDecimals(TokenId.fromString("0.0.5"), AccountId.fromString("0.0.7"), -100, 5);
        assertThat(tx.getTokenIdDecimals().get(TokenId.fromString("0.0.5"))).isEqualTo(5);
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenAirdrop(TokenAirdropTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenAirdropTransaction.class);
    }

    @Test
    void testDefaultMaxTransactionFeeIsSet() {
        assertEquals(new Hbar(1), transaction.getDefaultMaxTransactionFee(), "Default max transaction fee should be 1 Hbar");
    }

    @Test
    void testAddTokenTransfer() {
        TokenId tokenId = new TokenId(0, 0, 123);
        AccountId accountId = new AccountId(0, 0, 456);
        long value = 1000L;

        transaction.addTokenTransfer(tokenId, accountId, value);

        Map<TokenId, Map<AccountId, Long>> tokenTransfers = transaction.getTokenTransfers();
        assertTrue(tokenTransfers.containsKey(tokenId));
        assertEquals(1, tokenTransfers.get(tokenId).size());
        assertEquals(value, tokenTransfers.get(tokenId).get(accountId));
    }

    @Test
    void testAddApprovedTokenTransfer() {
        TokenId tokenId = new TokenId(0, 0, 123);
        AccountId accountId = new AccountId(0, 0, 456);
        long value = 1000L;

        transaction.addApprovedTokenTransfer(tokenId, accountId, value);

        Map<TokenId, Map<AccountId, Long>> tokenTransfers = transaction.getTokenTransfers();
        assertTrue(tokenTransfers.containsKey(tokenId));
        assertEquals(1, tokenTransfers.get(tokenId).size());
        assertEquals(value, tokenTransfers.get(tokenId).get(accountId));
    }

    @Test
    void testAddNftTransfer() {
        NftId nftId = new NftId(new TokenId(0, 0, 123), 1);
        AccountId sender = new AccountId(0, 0, 456);
        AccountId receiver = new AccountId(0, 0, 789);

        transaction.addNftTransfer(nftId, sender, receiver);

        Map<TokenId, List<TokenNftTransfer>> nftTransfers = transaction.getTokenNftTransfers();
        assertTrue(nftTransfers.containsKey(nftId.tokenId));
        assertEquals(1, nftTransfers.get(nftId.tokenId).size());
        assertEquals(sender, nftTransfers.get(nftId.tokenId).get(0).sender);
        assertEquals(receiver, nftTransfers.get(nftId.tokenId).get(0).receiver);
    }

    @Test
    void testAddApprovedNftTransfer() {
        NftId nftId = new NftId(new TokenId(0, 0, 123), 1);
        AccountId sender = new AccountId(0, 0, 456);
        AccountId receiver = new AccountId(0, 0, 789);

        transaction.addApprovedNftTransfer(nftId, sender, receiver);

        Map<TokenId, List<TokenNftTransfer>> nftTransfers = transaction.getTokenNftTransfers();
        assertTrue(nftTransfers.containsKey(nftId.tokenId));
        assertEquals(1, nftTransfers.get(nftId.tokenId).size());
        assertEquals(sender, nftTransfers.get(nftId.tokenId).get(0).sender);
        assertEquals(receiver, nftTransfers.get(nftId.tokenId).get(0).receiver);
    }

    @Test
    void testGetTokenIdDecimals() {
        TokenId tokenId = new TokenId(0, 0, 123);
        AccountId accountId = new AccountId(0, 0, 456);
        long value = 1000L;
        int decimals = 8;

        transaction.addTokenTransferWithDecimals(tokenId, accountId, value, decimals);

        Map<TokenId, Integer> decimalsMap = transaction.getTokenIdDecimals();
        assertTrue(decimalsMap.containsKey(tokenId));
        assertEquals(decimals, decimalsMap.get(tokenId));
    }

    @Test
    void testBuildTransactionBody() {
        TokenAirdropTransactionBody.Builder builder = spawnTestTransaction().build();

        assertNotNull(builder);
    }

    @Test
    void testGetMethodDescriptor() {
        assertEquals(TokenServiceGrpc.getAirdropTokensMethod(), transaction.getMethodDescriptor());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenAllowanceTest.java
package com.hedera.hashgraph.sdk;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TokenAllowanceTest {

    private static final TokenId testTokenId = TokenId.fromString("0.6.9");
    private static final AccountId testOwnerAccountId = AccountId.fromString("8.8.8");
    private static final AccountId testSpenderAccountId = AccountId.fromString("7.7.7");
    private static final long testAmount = 4L;

    @Test
    void constructWithTokenIdOwnerSpenderAmount() {
        TokenAllowance tokenAllowance = new TokenAllowance(testTokenId, testOwnerAccountId, testSpenderAccountId,
            testAmount);

        assertThat(tokenAllowance.tokenId).isEqualTo(testTokenId);
        assertThat(tokenAllowance.ownerAccountId).isEqualTo(testOwnerAccountId);
        assertThat(tokenAllowance.spenderAccountId).isEqualTo(testSpenderAccountId);
        assertThat(tokenAllowance.amount).isEqualTo(testAmount);
    }

    @Test
    void fromProtobuf() {
        var tokenAllowanceProtobuf = new TokenAllowance(testTokenId, testOwnerAccountId, testSpenderAccountId,
            testAmount).toProtobuf();
        var tokenAllowance = TokenAllowance.fromProtobuf(tokenAllowanceProtobuf);

        assertThat(tokenAllowance.tokenId).isEqualTo(testTokenId);
        assertThat(tokenAllowance.ownerAccountId).isEqualTo(testOwnerAccountId);
        assertThat(tokenAllowance.spenderAccountId).isEqualTo(testSpenderAccountId);
        assertThat(tokenAllowance.amount).isEqualTo(testAmount);
    }

    @Test
    void toProtobuf() {
        var tokenAllowanceProtobuf = new TokenAllowance(testTokenId, testOwnerAccountId, testSpenderAccountId,
            testAmount).toProtobuf();

        assertTrue(tokenAllowanceProtobuf.hasTokenId());
        assertThat(TokenId.fromProtobuf(tokenAllowanceProtobuf.getTokenId())).isEqualTo(testTokenId);

        assertTrue(tokenAllowanceProtobuf.hasOwner());
        assertThat(AccountId.fromProtobuf(tokenAllowanceProtobuf.getOwner())).isEqualTo(testOwnerAccountId);

        assertTrue(tokenAllowanceProtobuf.hasSpender());
        assertThat(AccountId.fromProtobuf(tokenAllowanceProtobuf.getSpender())).isEqualTo(testSpenderAccountId);

    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenAssociateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenAssociateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenAssociateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final AccountId accountId = AccountId.fromString("1.2.3");
    private static final List<TokenId> tokenIds = List.of(TokenId.fromString("4.5.6"),
        TokenId.fromString("7.8.9"),
        TokenId.fromString("10.11.12"));
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenAssociateTransaction spawnTestTransaction() {
        return new TokenAssociateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.222"))
            .setTokenIds(Collections.singletonList(TokenId.fromString("0.0.666")))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenAssociateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenAssociate(TokenAssociateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenAssociateTransaction.class);
    }

    @Test
    void constructTokenDeleteTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenAssociateTransactionBody.newBuilder()
            .addAllTokens(tokenIds.stream().map(TokenId::toProtobuf).toList())
            .setAccount(accountId.toProtobuf()).build();
        var txBody = TransactionBody.newBuilder().setTokenAssociate(transactionBody).build();
        var tokenAssociateTransaction = new TokenAssociateTransaction(txBody);

        assertThat(tokenAssociateTransaction.getAccountId()).isEqualTo(accountId);
        assertThat(tokenAssociateTransaction.getTokenIds()).hasSize(tokenIds.size());
    }

    @Test
    void getSetAccountId() {
        var transaction = new TokenAssociateTransaction().setAccountId(accountId);
        assertThat(transaction.getAccountId()).isEqualTo(accountId);
    }

    @Test
    void getSetAccountIdFrozen() {
        var transaction = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> transaction.setAccountId(accountId));
    }

    @Test
    void getSetTokenIds() {
        var transaction = new TokenAssociateTransaction().setTokenIds(tokenIds);
        assertThat(transaction.getTokenIds()).isEqualTo(tokenIds);
    }

    @Test
    void getSetTokenIdFrozen() {
        var transaction = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> transaction.setTokenIds(tokenIds));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenAssociationTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;


public class TokenAssociationTest {
    private static final AccountId testAccountId = AccountId.fromString("4.2.0");
    private static final TokenId testTokenId = TokenId.fromString("0.6.9");

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    TokenAssociation spawnTokenAssociationExample() {
        return new TokenAssociation(
            TokenId.fromString("1.2.3"),
            AccountId.fromString("4.5.6")
        );
    }

    @Test
    void shouldSerializeAccount() throws Exception {
        var originalTokenAssociation = spawnTokenAssociationExample();
        byte[] tokenAssociationBytes = originalTokenAssociation.toBytes();
        var copyTokenAssociation = TokenAssociation.fromBytes(tokenAssociationBytes);
        assertThat(copyTokenAssociation.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalTokenAssociation.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalTokenAssociation.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void fromProtobuf() {
        var tokenAssociationProtobuf = new TokenAssociation(testTokenId, testAccountId).toProtobuf();
        var tokenAssociation = TokenAssociation.fromProtobuf(tokenAssociationProtobuf);

        assertThat(tokenAssociation.accountId).isEqualTo(testAccountId);
        assertThat(tokenAssociation.tokenId).isEqualTo(testTokenId);
    }

    @Test
    void toProtobuf() {
        var tokenAssociationProtobuf = new TokenAssociation(testTokenId, testAccountId).toProtobuf();

        assertTrue(tokenAssociationProtobuf.hasAccountId());
        assertThat(tokenAssociationProtobuf.getAccountId().getShardNum()).isEqualTo(testAccountId.shard);
        assertThat(tokenAssociationProtobuf.getAccountId().getRealmNum()).isEqualTo(testAccountId.realm);
        assertThat(tokenAssociationProtobuf.getAccountId().getAccountNum()).isEqualTo(testAccountId.num);
        assertTrue(tokenAssociationProtobuf.hasTokenId());
        assertThat(tokenAssociationProtobuf.getTokenId().getShardNum()).isEqualTo(
            testTokenId.shard);
        assertThat(tokenAssociationProtobuf.getTokenId().getRealmNum()).isEqualTo(
            testTokenId.realm);
        assertThat(tokenAssociationProtobuf.getTokenId().getTokenNum()).isEqualTo(
            testTokenId.num);
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        var tokenAssociationProtobuf = new TokenAssociation(testTokenId, testAccountId).toProtobuf();

        var tokenAssociation = TokenAssociation.fromBytes(tokenAssociationProtobuf.toByteArray());

        assertThat(tokenAssociation.accountId).isEqualTo(testAccountId);
        assertThat(tokenAssociation.tokenId).isEqualTo(testTokenId);
    }

    @Test
    void toBytes() {
        var tokenAssociation = new TokenAssociation(testTokenId, testAccountId);
        var bytes = tokenAssociation.toBytes();
        assertThat(bytes).isEqualTo(tokenAssociation.toProtobuf().toByteArray());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenBurnTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenBurnTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenBurnTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final long testAmount = 69L;
    private static final List<Long> testSerials = Collections.singletonList(420L);
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFungible() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenBurnTransaction spawnTestTransaction() {
        return new TokenBurnTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId).setAmount(testAmount).setMaxTransactionFee(new Hbar(1)).freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerializeNft() {
        SnapshotMatcher.expect(spawnTestTransactionNft().toString()).toMatchSnapshot();
    }

    private TokenBurnTransaction spawnTestTransactionNft() {
        return new TokenBurnTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId).setSerials(testSerials).setMaxTransactionFee(new Hbar(1)).freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytesFungible() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenBurnTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytesNft() throws Exception {
        var tx = spawnTestTransactionNft();
        var tx2 = TokenBurnTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenBurn(TokenBurnTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenBurnTransaction.class);
    }

    @Test
    void constructTokenBurnTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenBurnTransactionBody.newBuilder().setToken(testTokenId.toProtobuf())
            .setAmount(testAmount).addAllSerialNumbers(testSerials).build();

        var tx = TransactionBody.newBuilder().setTokenBurn(transactionBody).build();
        var tokenBurnTransaction = new TokenBurnTransaction(tx);

        assertThat(tokenBurnTransaction.getTokenId()).isEqualTo(testTokenId);
        assertThat(tokenBurnTransaction.getAmount()).isEqualTo(testAmount);
        assertThat(tokenBurnTransaction.getSerials()).isEqualTo(testSerials);
    }

    @Test
    void getSetTokenId() {
        var tokenBurnTransaction = new TokenBurnTransaction().setTokenId(testTokenId);
        assertThat(tokenBurnTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }

    @Test
    void getSetAmount() {
        var tokenBurnTransaction = new TokenBurnTransaction().setAmount(testAmount);
        assertThat(tokenBurnTransaction.getAmount()).isEqualTo(testAmount);
    }

    @Test
    void getSetAmountFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAmount(testAmount));
    }

    @Test
    void getSetSerials() {
        var tokenBurnTransaction = new TokenBurnTransaction().setSerials(testSerials);
        assertThat(tokenBurnTransaction.getSerials()).isEqualTo(testSerials);
    }

    @Test
    void getSetSerialsFrozen() {
        var tx = spawnTestTransactionNft();
        assertThrows(IllegalStateException.class, () -> tx.setSerials(testSerials));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenCancelAirdropTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenCancelAirdropTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class TokenCancelAirdropTransactionTest {

    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    final Instant validStart = Instant.ofEpochSecond(1554158542);
    private TokenCancelAirdropTransaction transaction;

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private TokenCancelAirdropTransaction spawnTestTransaction() {
        List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123)));
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new NftId(new TokenId(0, 0, 1234), 123)));

        return new TokenCancelAirdropTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setPendingAirdropIds(pendingAirdropIds)
            .freeze()
            .sign(privateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }


    @BeforeEach
    public void setUp() {
        transaction = new TokenCancelAirdropTransaction();
    }

    @Test
    void testConstructorSetsDefaultMaxTransactionFee() {
        Assertions.assertEquals(Hbar.from(1), transaction.getDefaultMaxTransactionFee());
    }

    @Test
    void testGetAndSetPendingAirdropIds() {
        List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123)));
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new NftId(new TokenId(0, 0, 1234), 123)));

        transaction.setPendingAirdropIds(pendingAirdropIds);

        Assertions.assertEquals(pendingAirdropIds, transaction.getPendingAirdropIds());
    }

    @Test
    void testSetPendingAirdropIdsNullThrowsException() {
        Assertions.assertThrows(NullPointerException.class, () -> transaction.setPendingAirdropIds(null));
    }

    @Test
    void testClearPendingAirdropIds() {
        List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();
        PendingAirdropId pendingAirdropId = new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123));
        pendingAirdropIds.add(pendingAirdropId);

        transaction.setPendingAirdropIds(pendingAirdropIds);
        transaction.clearPendingAirdropIds();

        Assertions.assertTrue(transaction.getPendingAirdropIds().isEmpty());
    }

    @Test
    void testAddAllPendingAirdrops() {
        PendingAirdropId pendingAirdropId1 = new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123));
        PendingAirdropId pendingAirdropId2 = new PendingAirdropId(new AccountId(0, 0, 458), new AccountId(0, 0, 459),
            new TokenId(0, 0, 123));

        transaction.addPendingAirdrop(pendingAirdropId1);
        transaction.addPendingAirdrop(pendingAirdropId2);

        Assertions.assertEquals(2, transaction.getPendingAirdropIds().size());
        Assertions.assertTrue(transaction.getPendingAirdropIds().contains(pendingAirdropId1));
        Assertions.assertTrue(transaction.getPendingAirdropIds().contains(pendingAirdropId2));
    }

    @Test
    void testAddAllPendingAirdropsNullThrowsException() {
        Assertions.assertThrows(NullPointerException.class, () -> transaction.addPendingAirdrop(null));
    }

    @Test
    void testBuildTransactionBody() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new NftId(new TokenId(0, 0, 1234), 123));
        transaction.addPendingAirdrop(pendingAirdropId);

        TokenCancelAirdropTransactionBody.Builder builder = transaction.build();
        Assertions.assertEquals(1, builder.getPendingAirdropsCount());
        Assertions.assertEquals(pendingAirdropId.toProtobuf(), builder.getPendingAirdrops(0));
    }

    @Test
    void testGetMethodDescriptor() {
        Assertions.assertEquals(TokenServiceGrpc.getCancelAirdropMethod(), transaction.getMethodDescriptor());
    }

    @Test
    void testOnFreeze() {
        var bodyBuilder = TransactionBody.newBuilder();
        transaction.onFreeze(bodyBuilder);

        Assertions.assertTrue(bodyBuilder.hasTokenCancelAirdrop());
    }

    @Test
    void testOnScheduled() {
        SchedulableTransactionBody.Builder scheduled = SchedulableTransactionBody.newBuilder();
        transaction.onScheduled(scheduled);

        Assertions.assertTrue(scheduled.hasTokenCancelAirdrop());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenClaimAirdropTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenClaimAirdropTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenServiceGrpc;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class TokenClaimAirdropTransactionTest {

    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    final Instant validStart = Instant.ofEpochSecond(1554158542);
    private TokenClaimAirdropTransaction transaction;

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private TokenClaimAirdropTransaction spawnTestTransaction() {
        List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123)));
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new NftId(new TokenId(0, 0, 1234), 123)));

        return new TokenClaimAirdropTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setPendingAirdropIds(pendingAirdropIds)
            .freeze()
            .sign(privateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }


    @BeforeEach
    public void setUp() {
        transaction = new TokenClaimAirdropTransaction();
    }

    @Test
    void testConstructorSetsDefaultMaxTransactionFee() {
        Assertions.assertEquals(Hbar.from(1), transaction.getDefaultMaxTransactionFee());
    }

    @Test
    void testGetAndSetPendingAirdropIds() {
        List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123)));
        pendingAirdropIds.add(new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new NftId(new TokenId(0, 0, 1234), 123)));

        transaction.setPendingAirdropIds(pendingAirdropIds);

        Assertions.assertEquals(pendingAirdropIds, transaction.getPendingAirdropIds());
    }

    @Test
    void testSetPendingAirdropIdsNullThrowsException() {
        Assertions.assertThrows(NullPointerException.class, () -> transaction.setPendingAirdropIds(null));
    }

    @Test
    void testClearPendingAirdropIds() {
        List<PendingAirdropId> pendingAirdropIds = new ArrayList<>();
        PendingAirdropId pendingAirdropId = new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123));
        pendingAirdropIds.add(pendingAirdropId);

        transaction.setPendingAirdropIds(pendingAirdropIds);
        transaction.clearPendingAirdropIds();

        Assertions.assertTrue(transaction.getPendingAirdropIds().isEmpty());
    }

    @Test
    void testAddAllPendingAirdrops() {
        PendingAirdropId pendingAirdropId1 = new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new TokenId(0, 0, 123));
        PendingAirdropId pendingAirdropId2 = new PendingAirdropId(new AccountId(0, 0, 458), new AccountId(0, 0, 459),
            new TokenId(0, 0, 123));

        transaction.addPendingAirdrop(pendingAirdropId1);
        transaction.addPendingAirdrop(pendingAirdropId2);

        Assertions.assertEquals(2, transaction.getPendingAirdropIds().size());
        Assertions.assertTrue(transaction.getPendingAirdropIds().contains(pendingAirdropId1));
        Assertions.assertTrue(transaction.getPendingAirdropIds().contains(pendingAirdropId2));
    }

    @Test
    void testAddAllPendingAirdropsNullThrowsException() {
        Assertions.assertThrows(NullPointerException.class, () -> transaction.addPendingAirdrop(null));
    }

    @Test
    void testBuildTransactionBody() {
        PendingAirdropId pendingAirdropId = new PendingAirdropId(new AccountId(0, 0, 457), new AccountId(0, 0, 456),
            new NftId(new TokenId(0, 0, 1234), 123));
        transaction.addPendingAirdrop(pendingAirdropId);

        TokenClaimAirdropTransactionBody.Builder builder = transaction.build();
        Assertions.assertEquals(1, builder.getPendingAirdropsCount());
        Assertions.assertEquals(pendingAirdropId.toProtobuf(), builder.getPendingAirdrops(0));
    }

    @Test
    void testGetMethodDescriptor() {
        Assertions.assertEquals(TokenServiceGrpc.getClaimAirdropMethod(), transaction.getMethodDescriptor());
    }

    @Test
    void testOnFreeze() {
        var bodyBuilder = TransactionBody.newBuilder();
        transaction.onFreeze(bodyBuilder);

        Assertions.assertTrue(bodyBuilder.hasTokenClaimAirdrop());
    }

    @Test
    void testOnScheduled() {
        SchedulableTransactionBody.Builder scheduled = SchedulableTransactionBody.newBuilder();
        transaction.onScheduled(scheduled);

        Assertions.assertTrue(scheduled.hasTokenClaimAirdrop());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.google.common.collect.Iterables;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TokenCreateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class TokenCreateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final PublicKey testAdminKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11")
        .getPublicKey();
    private static final PublicKey testKycKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12")
        .getPublicKey();
    private static final PublicKey testFreezeKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e13")
        .getPublicKey();
    private static final PublicKey testWipeKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e14")
        .getPublicKey();
    private static final PublicKey testSupplyKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e15")
        .getPublicKey();
    private static final PublicKey testFeeScheduleKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e16")
        .getPublicKey();
    private static final PublicKey testPauseKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e17")
        .getPublicKey();
    private static final PublicKey testMetadataKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e18")
        .getPublicKey();
    private static final AccountId testTreasuryAccountId = AccountId.fromString("7.7.7");
    private static final AccountId testAutoRenewAccountId = AccountId.fromString("8.8.8");
    private static final long testInitialSupply = 30;
    private static final long testMaxSupply = 500;
    private static final int testDecimals = 3;
    private static final boolean testFreezeDefault = true;
    private static final String testTokenName = "test name";
    private static final String testTokenSymbol = "test symbol";
    private static final String testTokenMemo = "test memo";
    private static final Duration testAutoRenewPeriod = Duration.ofHours(10);
    private static final Instant testExpirationTime = Instant.now();
    private static final List<CustomFee> testCustomFees = Collections.singletonList(
        new CustomFixedFee().setFeeCollectorAccountId(AccountId.fromString("0.0.543")).setAmount(3)
            .setDenominatingTokenId(TokenId.fromString("4.3.2")));
    private static final byte[] testMetadata = new byte[]{1, 2, 3, 4, 5};
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFungible() {
        SnapshotMatcher.expect(spawnTestTransactionFungible().toString()).toMatchSnapshot();
    }

    @Test
    void shouldSerializeNft() {
        SnapshotMatcher.expect(spawnTestTransactionNft().toString()).toMatchSnapshot();
    }

    private TokenCreateTransaction spawnTestTransactionFungible() {
        return new TokenCreateTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setInitialSupply(testInitialSupply).setFeeScheduleKey(testFeeScheduleKey).setSupplyKey(testSupplyKey)
            .setAdminKey(testAdminKey).setAutoRenewAccountId(testAutoRenewAccountId)
            .setAutoRenewPeriod(testAutoRenewPeriod).setDecimals(testDecimals).setFreezeDefault(testFreezeDefault)
            .setFreezeKey(testFreezeKey).setWipeKey(testWipeKey).setTokenSymbol(testTokenSymbol).setKycKey(testKycKey)
            .setPauseKey(testPauseKey).setMetadataKey(testMetadataKey).setExpirationTime(validStart)
            .setTreasuryAccountId(testTreasuryAccountId).setTokenName(testTokenName).setTokenMemo(testTokenMemo)
            .setCustomFees(testCustomFees).setMaxTransactionFee(new Hbar(1)).setTokenMetadata(testMetadata).freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytesFungible() throws Exception {
        var tx = spawnTestTransactionFungible();
        var tx2 = TokenCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    private TokenCreateTransaction spawnTestTransactionNft() {
        return new TokenCreateTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setFeeScheduleKey(testFeeScheduleKey).setSupplyKey(testSupplyKey).setMaxSupply(testMaxSupply)
            .setAdminKey(testAdminKey).setAutoRenewAccountId(testAutoRenewAccountId)
            .setAutoRenewPeriod(testAutoRenewPeriod).setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setSupplyType(TokenSupplyType.FINITE).setFreezeKey(testFreezeKey).setWipeKey(testWipeKey)
            .setTokenSymbol(testTokenSymbol).setKycKey(testKycKey).setPauseKey(testPauseKey)
            .setMetadataKey(testMetadataKey).setExpirationTime(validStart).setTreasuryAccountId(testTreasuryAccountId)
            .setTokenName(testTokenName).setTokenMemo(testTokenMemo).setMaxTransactionFee(new Hbar(1))
            .setTokenMetadata(testMetadata).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldBytesNft() throws Exception {
        var tx = spawnTestTransactionNft();
        var tx2 = TokenCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenCreation(TokenCreateTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenCreateTransaction.class);
    }

    @Test
    void constructTokenCreateTransactionFungibleFromTransactionBodyProtobuf() {
        var transactionBody = TokenCreateTransactionBody.newBuilder().setInitialSupply(testInitialSupply)
            .setFeeScheduleKey(testFeeScheduleKey.toProtobufKey()).setSupplyKey(testSupplyKey.toProtobufKey())
            .setAdminKey(testAdminKey.toProtobufKey()).setAutoRenewAccount(testAutoRenewAccountId.toProtobuf())
            .setAutoRenewPeriod(
                com.hedera.hashgraph.sdk.proto.Duration.newBuilder().setSeconds(testAutoRenewPeriod.toSeconds())
                    .build()).setExpiry(Timestamp.newBuilder().setSeconds(testExpirationTime.getEpochSecond()).build())
            .setDecimals(testDecimals).setFreezeDefault(testFreezeDefault).setFreezeKey(testFreezeKey.toProtobufKey())
            .setWipeKey(testWipeKey.toProtobufKey()).setSymbol(testTokenSymbol).setKycKey(testKycKey.toProtobufKey())
            .setPauseKey(testPauseKey.toProtobufKey()).setMetadataKey(testMetadataKey.toProtobufKey())
            .setExpiry(Timestamp.newBuilder().setSeconds(testExpirationTime.getEpochSecond()))
            .setTreasury(testTreasuryAccountId.toProtobuf()).setName(testTokenName).setMemo(testTokenMemo)
            .addCustomFees(Iterables.getLast(testCustomFees).toProtobuf())
            .setMetadata(ByteString.copyFrom(testMetadata)).build();

        var tx = TransactionBody.newBuilder().setTokenCreation(transactionBody).build();
        var tokenCreateTransaction = new TokenCreateTransaction(tx);

        assertThat(tokenCreateTransaction.getFeeScheduleKey()).isEqualTo(testFeeScheduleKey);
        assertThat(tokenCreateTransaction.getSupplyKey()).isEqualTo(testSupplyKey);
        assertThat(tokenCreateTransaction.getAdminKey()).isEqualTo(testAdminKey);
        assertThat(tokenCreateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
        assertThat(tokenCreateTransaction.getAutoRenewPeriod().toSeconds()).isEqualTo(testAutoRenewPeriod.toSeconds());
        assertThat(tokenCreateTransaction.getDecimals()).isEqualTo(testDecimals);
        assertThat(tokenCreateTransaction.getFreezeDefault()).isEqualTo(testFreezeDefault);
        assertThat(tokenCreateTransaction.getFreezeKey()).isEqualTo(testFreezeKey);
        assertThat(tokenCreateTransaction.getWipeKey()).isEqualTo(testWipeKey);
        assertThat(tokenCreateTransaction.getTokenSymbol()).isEqualTo(testTokenSymbol);
        assertThat(tokenCreateTransaction.getKycKey()).isEqualTo(testKycKey);
        assertThat(tokenCreateTransaction.getPauseKey()).isEqualTo(testPauseKey);
        assertThat(tokenCreateTransaction.getMetadataKey()).isEqualTo(testMetadataKey);
        assertThat(tokenCreateTransaction.getExpirationTime().getEpochSecond()).isEqualTo(
            testExpirationTime.getEpochSecond());
        assertThat(tokenCreateTransaction.getTreasuryAccountId()).isEqualTo(testTreasuryAccountId);
        assertThat(tokenCreateTransaction.getTokenName()).isEqualTo(testTokenName);
        assertThat(tokenCreateTransaction.getTokenMemo()).isEqualTo(testTokenMemo);
        assertThat(tokenCreateTransaction.getTokenType()).isEqualTo(TokenType.FUNGIBLE_COMMON);
        assertThat(Iterables.getLast(tokenCreateTransaction.getCustomFees()).toBytes()).isEqualTo(
            Iterables.getLast(testCustomFees).toBytes());
        assertThat(tokenCreateTransaction.getTokenMetadata()).isEqualTo(testMetadata);
    }

    @Test
    void constructTokenCreateTransactionNftFromTransactionBodyProtobuf() {
        var transactionBody = TokenCreateTransactionBody.newBuilder()
            .setFeeScheduleKey(testFeeScheduleKey.toProtobufKey()).setSupplyKey(testSupplyKey.toProtobufKey())
            .setMaxSupply(testMaxSupply).setAdminKey(testAdminKey.toProtobufKey())
            .setAutoRenewAccount(testAutoRenewAccountId.toProtobuf()).setAutoRenewPeriod(
                com.hedera.hashgraph.sdk.proto.Duration.newBuilder().setSeconds(testAutoRenewPeriod.toSeconds())
                    .build()).setExpiry(Timestamp.newBuilder().setSeconds(testExpirationTime.getEpochSecond()).build())
            .setTokenType(com.hedera.hashgraph.sdk.proto.TokenType.NON_FUNGIBLE_UNIQUE)
            .setSupplyType(com.hedera.hashgraph.sdk.proto.TokenSupplyType.FINITE)
            .setFreezeKey(testFreezeKey.toProtobufKey()).setWipeKey(testWipeKey.toProtobufKey())
            .setSymbol(testTokenSymbol).setKycKey(testKycKey.toProtobufKey()).setPauseKey(testPauseKey.toProtobufKey())
            .setMetadataKey(testMetadataKey.toProtobufKey())
            .setExpiry(Timestamp.newBuilder().setSeconds(testExpirationTime.getEpochSecond()))
            .setTreasury(testTreasuryAccountId.toProtobuf()).setName(testTokenName).setMemo(testTokenMemo).build();

        var tx = TransactionBody.newBuilder().setTokenCreation(transactionBody).build();
        var tokenCreateTransaction = new TokenCreateTransaction(tx);

        assertThat(tokenCreateTransaction.getFeeScheduleKey()).isEqualTo(testFeeScheduleKey);
        assertThat(tokenCreateTransaction.getSupplyKey()).isEqualTo(testSupplyKey);
        assertThat(tokenCreateTransaction.getMaxSupply()).isEqualTo(testMaxSupply);
        assertThat(tokenCreateTransaction.getAdminKey()).isEqualTo(testAdminKey);
        assertThat(tokenCreateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
        assertThat(tokenCreateTransaction.getAutoRenewPeriod().toSeconds()).isEqualTo(testAutoRenewPeriod.toSeconds());
        assertThat(tokenCreateTransaction.getTokenType()).isEqualTo(TokenType.NON_FUNGIBLE_UNIQUE);
        assertThat(tokenCreateTransaction.getSupplyType()).isEqualTo(TokenSupplyType.FINITE);
        assertThat(tokenCreateTransaction.getFreezeKey()).isEqualTo(testFreezeKey);
        assertThat(tokenCreateTransaction.getWipeKey()).isEqualTo(testWipeKey);
        assertThat(tokenCreateTransaction.getTokenSymbol()).isEqualTo(testTokenSymbol);
        assertThat(tokenCreateTransaction.getKycKey()).isEqualTo(testKycKey);
        assertThat(tokenCreateTransaction.getPauseKey()).isEqualTo(testPauseKey);
        assertThat(tokenCreateTransaction.getMetadataKey()).isEqualTo(testMetadataKey);
        assertThat(tokenCreateTransaction.getExpirationTime().getEpochSecond()).isEqualTo(
            testExpirationTime.getEpochSecond());
        assertThat(tokenCreateTransaction.getTreasuryAccountId()).isEqualTo(testTreasuryAccountId);
        assertThat(tokenCreateTransaction.getTokenName()).isEqualTo(testTokenName);
        assertThat(tokenCreateTransaction.getTokenMemo()).isEqualTo(testTokenMemo);
    }

    @Test
    void getSetName() {
        var tokenCreateTransaction = new TokenCreateTransaction().setTokenName(testTokenName);
        assertThat(tokenCreateTransaction.getTokenName()).isEqualTo(testTokenName);
    }

    @Test
    void getSetNameFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setTokenName(testTokenName));
    }

    @Test
    void getSetSymbol() {
        var tokenCreateTransaction = new TokenCreateTransaction().setTokenSymbol(testTokenSymbol);
        assertThat(tokenCreateTransaction.getTokenSymbol()).isEqualTo(testTokenSymbol);
    }

    @Test
    void getSetSymbolFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setTokenSymbol(testTokenSymbol));
    }

    @Test
    void getSetDecimals() {
        var tokenCreateTransaction = new TokenCreateTransaction().setDecimals(testDecimals);
        assertThat(tokenCreateTransaction.getDecimals()).isEqualTo(testDecimals);
    }

    @Test
    void getSetDecimalsFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setDecimals(testDecimals));
    }

    @Test
    void getSetInitialSupply() {
        var tokenCreateTransaction = new TokenCreateTransaction().setInitialSupply(testInitialSupply);
        assertThat(tokenCreateTransaction.getInitialSupply()).isEqualTo(testInitialSupply);
    }

    @Test
    void getSetInitialSupplyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setInitialSupply(testInitialSupply));
    }

    @Test
    void getSetTreasuryAccountId() {
        var tokenCreateTransaction = new TokenCreateTransaction().setTreasuryAccountId(testTreasuryAccountId);
        assertThat(tokenCreateTransaction.getTreasuryAccountId()).isEqualTo(testTreasuryAccountId);
    }

    @Test
    void getSetTreasuryAccountIdFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setTreasuryAccountId(testTreasuryAccountId));
    }

    @Test
    void getSetAdminKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setAdminKey(testAdminKey);
        assertThat(tokenCreateTransaction.getAdminKey()).isEqualTo(testAdminKey);
    }

    @Test
    void getSetAdminKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setAdminKey(testAdminKey));
    }

    @Test
    void getSetKycKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setKycKey(testKycKey);
        assertThat(tokenCreateTransaction.getKycKey()).isEqualTo(testKycKey);
    }

    @Test
    void getSetKycKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setKycKey(testKycKey));
    }

    @Test
    void getSetFreezeKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setFreezeKey(testFreezeKey);
        assertThat(tokenCreateTransaction.getFreezeKey()).isEqualTo(testFreezeKey);
    }

    @Test
    void getSetFreezeKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setFreezeKey(testFreezeKey));
    }

    @Test
    void getSetWipeKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setWipeKey(testWipeKey);
        assertThat(tokenCreateTransaction.getWipeKey()).isEqualTo(testWipeKey);
    }

    @Test
    void getSetWipeKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setWipeKey(testWipeKey));
    }

    @Test
    void getSetSupplyKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setSupplyKey(testSupplyKey);
        assertThat(tokenCreateTransaction.getSupplyKey()).isEqualTo(testSupplyKey);
    }

    @Test
    void getSetSupplyKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setSupplyKey(testSupplyKey));
    }

    @Test
    void getSetFeeScheduleKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setFeeScheduleKey(testFeeScheduleKey);
        assertThat(tokenCreateTransaction.getFeeScheduleKey()).isEqualTo(testFeeScheduleKey);
    }

    @Test
    void getSetFeeScheduleKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setFeeScheduleKey(testFeeScheduleKey));
    }

    @Test
    void getSetPauseKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setPauseKey(testPauseKey);
        assertThat(tokenCreateTransaction.getPauseKey()).isEqualTo(testPauseKey);
    }

    @Test
    void getSetPauseKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setPauseKey(testPauseKey));
    }

    @Test
    void getSetMetadataKey() {
        var tokenCreateTransaction = new TokenCreateTransaction().setMetadataKey(testMetadataKey);
        assertThat(tokenCreateTransaction.getMetadataKey()).isEqualTo(testMetadataKey);
    }

    @Test
    void getSetMetadataKeyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setMetadataKey(testMetadataKey));
    }

    @Test
    void getSetExpirationTime() {
        var tokenCreateTransaction = new TokenCreateTransaction().setExpirationTime(testExpirationTime);
        assertThat(tokenCreateTransaction.getExpirationTime()).isEqualTo(testExpirationTime);
    }

    @Test
    void getSetExpirationTimeFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setExpirationTime(testExpirationTime));
    }

    @Test
    void getSetAutoRenewAccountId() {
        var tokenCreateTransaction = new TokenCreateTransaction().setAutoRenewAccountId(testAutoRenewAccountId);
        assertThat(tokenCreateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
    }

    @Test
    void getSetAutoRenewAccountIdFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setAutoRenewAccountId(testAutoRenewAccountId));
    }

    @Test
    void getSetAutoRenewPeriod() {
        var tokenCreateTransaction = new TokenCreateTransaction().setAutoRenewPeriod(testAutoRenewPeriod);
        assertThat(tokenCreateTransaction.getAutoRenewPeriod()).isEqualTo(testAutoRenewPeriod);
    }

    @Test
    void getSetAutoRenewPeriodFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setAutoRenewPeriod(testAutoRenewPeriod));
    }

    @Test
    void getSetTokenMemo() {
        var tokenCreateTransaction = new TokenCreateTransaction().setTokenMemo(testTokenMemo);
        assertThat(tokenCreateTransaction.getTokenMemo()).isEqualTo(testTokenMemo);
    }

    @Test
    void getSetTokenMemoFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setTokenMemo(testTokenMemo));
    }

    @Test
    void getSetTokenType() {
        final TokenType testTokenType = TokenType.FUNGIBLE_COMMON;
        var tokenCreateTransaction = new TokenCreateTransaction().setTokenType(testTokenType);
        assertThat(tokenCreateTransaction.getTokenType()).isEqualTo(testTokenType);
    }

    @Test
    void getSetTokenTypeFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setTokenType(TokenType.FUNGIBLE_COMMON));
    }

    @Test
    void getSetSupplyType() {
        final TokenSupplyType testTokenType = TokenSupplyType.FINITE;
        var tokenCreateTransaction = new TokenCreateTransaction().setSupplyType(testTokenType);
        assertThat(tokenCreateTransaction.getSupplyType()).isEqualTo(testTokenType);
    }

    @Test
    void getSetSupplyTypeFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setSupplyType(TokenSupplyType.FINITE));
    }

    @Test
    void getSetMaxSupply() {
        var tokenCreateTransaction = new TokenCreateTransaction().setMaxSupply(testMaxSupply);
        assertThat(tokenCreateTransaction.getMaxSupply()).isEqualTo(testMaxSupply);
    }

    @Test
    void getSetMaxSupplyFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setMaxSupply(testMaxSupply));
    }

    @Test
    void getSetMetadata() {
        var tx = spawnTestTransactionFungible();
        assertThat(tx.getTokenMetadata()).isEqualTo(testMetadata);
    }

    @Test
    void getSetMetadataFrozen() {
        var tx = spawnTestTransactionFungible();
        assertThrows(IllegalStateException.class, () -> tx.setTokenMetadata(testMetadata));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenDeleteTransaction spawnTestTransaction() {
        return new TokenDeleteTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(TokenId.fromString("1.2.3")).setMaxTransactionFee(new Hbar(1)).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenDeletion(TokenDeleteTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenDeleteTransaction.class);
    }

    @Test
    void constructTokenDeleteTransaction() {
        var transaction = new TokenDeleteTransaction();

        assertThat(transaction.getTokenId()).isNull();
    }

    @Test
    void ConstructTokenDeleteTransactionFromTransactionBodyProtobuf() {
        var tokenId = TokenId.fromString("1.2.3");

        var transactionBody = TokenDeleteTransactionBody.newBuilder().setToken(tokenId.toProtobuf()).build();
        var txBody = TransactionBody.newBuilder().setTokenDeletion(transactionBody).build();
        var tokenDeleteTransaction = new TokenDeleteTransaction(txBody);

        assertThat(tokenDeleteTransaction.getTokenId()).isEqualTo(tokenId);
    }

    @Test
    void getSetTokenId() {
        var tokenId = TokenId.fromString("1.2.3");

        var transaction = new TokenDeleteTransaction().setTokenId(tokenId);

        assertThat(transaction.getTokenId()).isEqualTo(tokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tokenId = TokenId.fromString("1.2.3");

        var tx = spawnTestTransaction();

        assertThrows(IllegalStateException.class, () -> tx.setTokenId(tokenId));
    }

}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenDissociateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenDissociateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenDissociateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final AccountId testAccountId = AccountId.fromString("6.9.0");

    private static final List<TokenId> testTokenIds = Arrays.asList(TokenId.fromString("4.2.0"),
        TokenId.fromString("4.2.1"), TokenId.fromString("4.2.2"));

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenDissociateTransaction spawnTestTransaction() {
        return new TokenDissociateTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(testAccountId).setTokenIds(testTokenIds).setMaxTransactionFee(new Hbar(1)).freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenDissociateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenDissociate(TokenDissociateTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenDissociateTransaction.class);
    }

    @Test
    void constructTokenDissociateTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenDissociateTransactionBody.newBuilder().setAccount(testAccountId.toProtobuf())
            .addAllTokens(testTokenIds.stream().map(TokenId::toProtobuf).toList()).build();

        var tx = TransactionBody.newBuilder().setTokenDissociate(transactionBody).build();
        var tokenDissociateTransaction = new TokenDissociateTransaction(tx);

        assertThat(tokenDissociateTransaction.getAccountId()).isEqualTo(testAccountId);
        assertThat(tokenDissociateTransaction.getTokenIds().size()).isEqualTo(testTokenIds.size());
    }

    @Test
    void getSetAccountId() {
        var tokenDissociateTransaction = new TokenDissociateTransaction().setAccountId(testAccountId);
        assertThat(tokenDissociateTransaction.getAccountId()).isEqualTo(testAccountId);
    }

    @Test
    void getSetAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAccountId(testAccountId));
    }

    @Test
    void getSetTokenIds() {
        var tokenDissociateTransaction = new TokenDissociateTransaction().setTokenIds(testTokenIds);
        assertThat(tokenDissociateTransaction.getTokenIds()).isEqualTo(testTokenIds);
    }

    @Test
    void getSetTokenIdsFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenIds(testTokenIds));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenFeeScheduleUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenFeeScheduleUpdateTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenFeeScheduleUpdateTransactionTest {
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private TokenFeeScheduleUpdateTransaction spawnTestTransaction() {
        var customFees = new ArrayList<CustomFee>();
        customFees.add(new CustomFixedFee()
            .setFeeCollectorAccountId(new AccountId(4322))
            .setDenominatingTokenId(new TokenId(483902))
            .setAmount(10)
        );
        customFees.add(new CustomFractionalFee()
            .setFeeCollectorAccountId(new AccountId(389042))
            .setNumerator(3)
            .setDenominator(7)
            .setMin(3)
            .setMax(100)
            .setAssessmentMethod(FeeAssessmentMethod.EXCLUSIVE)
        );

        return new TokenFeeScheduleUpdateTransaction()
            .setTokenId(new TokenId(8798))
            .setCustomFees(customFees)
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .freeze();
    }

    @Test
    void shouldSerialize() throws InvalidProtocolBufferException {
        var originalUpdate = spawnTestTransaction();
        byte[] updateBytes = originalUpdate.toBytes();
        var copyUpdate = TokenFeeScheduleUpdateTransaction.fromBytes(updateBytes);
        assertThat(copyUpdate.toString()).isEqualTo(originalUpdate.toString());
        SnapshotMatcher.expect(originalUpdate.toString()).toMatchSnapshot();
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenFeeScheduleUpdate(TokenFeeScheduleUpdateTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenFeeScheduleUpdateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenFreezeTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenFreezeAccountTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenFreezeTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenFreezeTransaction spawnTestTransaction() {
        return new TokenFreezeTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.222"))
            .setTokenId(TokenId.fromString("6.5.4"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenFreezeTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenFreeze(TokenFreezeAccountTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenFreezeTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenGrantKycTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenGrantKycTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenGrantKycTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final AccountId testAccountId = AccountId.fromString("6.9.0");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenGrantKycTransaction spawnTestTransaction() {
        return new TokenGrantKycTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(testAccountId).setTokenId(testTokenId).setMaxTransactionFee(new Hbar(1)).freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenGrantKycTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenGrantKyc(TokenGrantKycTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenGrantKycTransaction.class);
    }

    @Test
    void constructTokenGrantKycTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenGrantKycTransactionBody.newBuilder().setAccount(testAccountId.toProtobuf())
            .setToken(testTokenId.toProtobuf()).build();

        var tx = TransactionBody.newBuilder().setTokenGrantKyc(transactionBody).build();
        var tokenGrantKycTransaction = new TokenGrantKycTransaction(tx);

        assertThat(tokenGrantKycTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetAccountId() {
        var tokenGrantKycTransaction = new TokenGrantKycTransaction().setAccountId(testAccountId);
        assertThat(tokenGrantKycTransaction.getAccountId()).isEqualTo(testAccountId);
    }

    @Test
    void getSetAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAccountId(testAccountId));
    }

    @Test
    void getSetTokenId() {
        var tokenGrantKycTransaction = new TokenGrantKycTransaction().setTokenId(testTokenId);
        assertThat(tokenGrantKycTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenInfoQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenInfoQueryTest {
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new TokenInfoQuery().setTokenId(testTokenId).setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void getSetTokenId() {
        var tokenInfoQuery = new TokenInfoQuery().setTokenId(testTokenId);
        assertThat(tokenInfoQuery.getTokenId()).isEqualTo(testTokenId);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenInfoTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

// TODO: update this, test deepClone()

public class TokenInfoTest {
    /*
     if we will init PrivateKey using method `PrivateKey.fromSeedECDSAsecp256k1(byte[] seed)` (like in C++ SDK, for example)
     => we will get public key each time we run tests on different machines
     => io.github.jsonSnapshot.SnapshotMatcher will fail tests
     => we need to init PrivateKey fromString to get the same key each time
     => `toProtobuf()` tests uses getEd25519() method to assert equality
     */
    private static final PublicKey testAdminKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11")
        .getPublicKey();
    private static final PublicKey testKycKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12")
        .getPublicKey();
    private static final PublicKey testFreezeKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e13")
        .getPublicKey();
    private static final PublicKey testWipeKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e14")
        .getPublicKey();
    private static final PublicKey testSupplyKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e15")
        .getPublicKey();
    private static final PublicKey testFeeScheduleKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e16")
        .getPublicKey();
    private static final PublicKey testPauseKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e17")
        .getPublicKey();
    private static final PublicKey testMetadataKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e18")
        .getPublicKey();
    private static final TokenId testTokenId = TokenId.fromString("0.6.9");
    private static final AccountId testTreasuryAccountId = AccountId.fromString("7.7.7");
    private static final AccountId testAutoRenewAccountId = AccountId.fromString("8.9.0");
    private static final String testTokenName = "test token name";
    private static final String testTokenSymbol = "TTN";
    private static final String testTokenMemo = "memo";
    private static final int testTokenDecimals = 3;
    private static final long testTokenTotalSupply = 1000L;
    private static final Boolean testTokenFreezeStatus = true;
    private static final Boolean testTokenKycStatus = true;
    private static final boolean testTokenIsDeleted = false;
    private static final List<CustomFee> testTokenCustomFees = Arrays.asList(
        new CustomFixedFee().setFeeCollectorAccountId(new AccountId(4322)).setDenominatingTokenId(new TokenId(483902))
            .setAmount(10),
        new CustomFractionalFee().setFeeCollectorAccountId(new AccountId(389042)).setNumerator(3).setDenominator(7)
            .setMin(3).setMax(100));
    private static final TokenType testTokenType = TokenType.FUNGIBLE_COMMON;
    private static final TokenSupplyType testTokenSupplyType = TokenSupplyType.FINITE;
    private static final long testTokenMaxSupply = 1000000L;
    private static final boolean testTokenPauseStatus = true;
    private static final LedgerId testTokenLedgerId = LedgerId.MAINNET;
    private static final Duration testAutoRenewPeriod = Duration.ofHours(10);
    private static final Instant testExpirationTime = Instant.ofEpochSecond(1554158542);
    private static final byte[] testMetadata = new byte[]{1, 2, 3, 4, 5};

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private static TokenInfo spawnTokenInfoExample() {
        return new TokenInfo(testTokenId, testTokenName, testTokenSymbol, testTokenDecimals, testTokenTotalSupply,
            testTreasuryAccountId, testAdminKey, testKycKey, testFreezeKey, testWipeKey, testSupplyKey,
            testFeeScheduleKey, testTokenFreezeStatus, testTokenKycStatus, testTokenIsDeleted, testAutoRenewAccountId,
            testAutoRenewPeriod, testExpirationTime, testTokenMemo, testTokenCustomFees, testTokenType,
            testTokenSupplyType, testTokenMaxSupply, testPauseKey, testTokenPauseStatus, testMetadata, testMetadataKey,
            testTokenLedgerId);
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalTokenInfo = spawnTokenInfoExample();
        byte[] tokenInfoBytes = originalTokenInfo.toBytes();
        var copyTokenInfo = TokenInfo.fromBytes(tokenInfoBytes);
        assertThat(copyTokenInfo.toString()).isEqualTo(originalTokenInfo.toString());
        SnapshotMatcher.expect(originalTokenInfo.toString()).toMatchSnapshot();
    }

    @Test
    void fromProtobuf() {
        var tokenInfoProto = spawnTokenInfoExample().toProtobuf();

        var tokenInfo = TokenInfo.fromProtobuf(tokenInfoProto);

        assertThat(tokenInfo.tokenId).isEqualTo(testTokenId);
        assertThat(tokenInfo.name).isEqualTo(testTokenName);
        assertThat(tokenInfo.symbol).isEqualTo(testTokenSymbol);
        assertThat(tokenInfo.decimals).isEqualTo(testTokenDecimals);
        assertThat(tokenInfo.totalSupply).isEqualTo(testTokenTotalSupply);
        assertThat(tokenInfo.treasuryAccountId).isEqualTo(testTreasuryAccountId);
        assertThat(tokenInfo.adminKey.toBytes()).isEqualTo(testAdminKey.toBytes());
        assertThat(tokenInfo.kycKey.toBytes()).isEqualTo(testKycKey.toBytes());
        assertThat(tokenInfo.freezeKey.toBytes()).isEqualTo(testFreezeKey.toBytes());
        assertThat(tokenInfo.wipeKey.toBytes()).isEqualTo(testWipeKey.toBytes());
        assertThat(tokenInfo.supplyKey.toBytes()).isEqualTo(testSupplyKey.toBytes());
        assertThat(tokenInfo.defaultFreezeStatus).isEqualTo(testTokenFreezeStatus);
        assertThat(tokenInfo.defaultKycStatus).isEqualTo(testTokenKycStatus);
        assertThat(tokenInfo.isDeleted).isEqualTo(testTokenIsDeleted);
        assertThat(tokenInfo.autoRenewAccount).isEqualTo(testAutoRenewAccountId);
        assertThat(tokenInfo.autoRenewPeriod).isEqualTo(testAutoRenewPeriod);
        assertThat(tokenInfo.expirationTime).isEqualTo(testExpirationTime);
        assertThat(tokenInfo.tokenMemo).isEqualTo(testTokenMemo);
        assertThat(tokenInfo.tokenType).isEqualTo(testTokenType);
        assertThat(tokenInfo.supplyType).isEqualTo(testTokenSupplyType);
        assertThat(tokenInfo.maxSupply).isEqualTo(testTokenMaxSupply);
        assertThat(tokenInfo.feeScheduleKey.toBytes()).isEqualTo(testFeeScheduleKey.toBytes());
        assertThat(tokenInfo.customFees).hasSize(testTokenCustomFees.size());
        assertThat(tokenInfo.pauseKey.toBytes()).isEqualTo(testPauseKey.toBytes());
        assertThat(tokenInfo.pauseStatus).isEqualTo(testTokenPauseStatus);
        assertThat(tokenInfo.metadata).isEqualTo(testMetadata);
        assertThat(tokenInfo.metadataKey.toBytes()).isEqualTo(testMetadataKey.toBytes());
        assertThat(tokenInfo.ledgerId).isEqualTo(testTokenLedgerId);
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        var tokenInfoProto = spawnTokenInfoExample().toProtobuf();

        var tokenInfo = TokenInfo.fromBytes(tokenInfoProto.toByteArray());

        assertThat(tokenInfo.tokenId).isEqualTo(testTokenId);
        assertThat(tokenInfo.name).isEqualTo(testTokenName);
        assertThat(tokenInfo.symbol).isEqualTo(testTokenSymbol);
        assertThat(tokenInfo.decimals).isEqualTo(testTokenDecimals);
        assertThat(tokenInfo.totalSupply).isEqualTo(testTokenTotalSupply);
        assertThat(tokenInfo.treasuryAccountId).isEqualTo(testTreasuryAccountId);
        assertThat(tokenInfo.adminKey.toBytes()).isEqualTo(testAdminKey.toBytes());
        assertThat(tokenInfo.kycKey.toBytes()).isEqualTo(testKycKey.toBytes());
        assertThat(tokenInfo.freezeKey.toBytes()).isEqualTo(testFreezeKey.toBytes());
        assertThat(tokenInfo.wipeKey.toBytes()).isEqualTo(testWipeKey.toBytes());
        assertThat(tokenInfo.supplyKey.toBytes()).isEqualTo(testSupplyKey.toBytes());
        assertThat(tokenInfo.defaultFreezeStatus).isEqualTo(testTokenFreezeStatus);
        assertThat(tokenInfo.defaultKycStatus).isEqualTo(testTokenKycStatus);
        assertThat(tokenInfo.isDeleted).isEqualTo(testTokenIsDeleted);
        assertThat(tokenInfo.autoRenewAccount).isEqualTo(testAutoRenewAccountId);
        assertThat(tokenInfo.autoRenewPeriod).isEqualTo(testAutoRenewPeriod);
        assertThat(tokenInfo.expirationTime).isEqualTo(testExpirationTime);
        assertThat(tokenInfo.tokenMemo).isEqualTo(testTokenMemo);
        assertThat(tokenInfo.tokenType).isEqualTo(testTokenType);
        assertThat(tokenInfo.supplyType).isEqualTo(testTokenSupplyType);
        assertThat(tokenInfo.maxSupply).isEqualTo(testTokenMaxSupply);
        assertThat(tokenInfo.feeScheduleKey.toBytes()).isEqualTo(testFeeScheduleKey.toBytes());
        assertThat(tokenInfo.customFees).hasSize(testTokenCustomFees.size());
        assertThat(tokenInfo.pauseKey.toBytes()).isEqualTo(testPauseKey.toBytes());
        assertThat(tokenInfo.pauseStatus).isEqualTo(testTokenPauseStatus);
        assertThat(tokenInfo.metadata).isEqualTo(testMetadata);
        assertThat(tokenInfo.metadataKey.toBytes()).isEqualTo(testMetadataKey.toBytes());
        assertThat(tokenInfo.ledgerId).isEqualTo(testTokenLedgerId);
    }

    @Test
    void toProtobuf() {
        var tokenInfoProto = spawnTokenInfoExample().toProtobuf();

        assertThat(tokenInfoProto.getTokenInfo().getTokenId().getShardNum()).isEqualTo(testTokenId.shard);
        assertThat(tokenInfoProto.getTokenInfo().getTokenId().getRealmNum()).isEqualTo(testTokenId.realm);
        assertThat(tokenInfoProto.getTokenInfo().getTokenId().getTokenNum()).isEqualTo(testTokenId.num);
        assertThat(tokenInfoProto.getTokenInfo().getName()).isEqualTo(testTokenName);
        assertThat(tokenInfoProto.getTokenInfo().getSymbol()).isEqualTo(testTokenSymbol);
        assertThat(tokenInfoProto.getTokenInfo().getDecimals()).isEqualTo(testTokenDecimals);
        assertThat(tokenInfoProto.getTokenInfo().getTotalSupply()).isEqualTo(testTokenTotalSupply);
        assertThat(tokenInfoProto.getTokenInfo().getTreasury().getShardNum()).isEqualTo(testTreasuryAccountId.shard);
        assertThat(tokenInfoProto.getTokenInfo().getTreasury().getRealmNum()).isEqualTo(testTreasuryAccountId.realm);
        assertThat(tokenInfoProto.getTokenInfo().getTreasury().getAccountNum()).isEqualTo(testTreasuryAccountId.num);
        assertThat(tokenInfoProto.getTokenInfo().getAdminKey().getEd25519().toByteArray()).isEqualTo(
            testAdminKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getKycKey().getEd25519().toByteArray()).isEqualTo(
            testKycKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getFreezeKey().getEd25519().toByteArray()).isEqualTo(
            testFreezeKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getWipeKey().getEd25519().toByteArray()).isEqualTo(
            testWipeKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getSupplyKey().getEd25519().toByteArray()).isEqualTo(
            testSupplyKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getDefaultFreezeStatus()).isEqualTo(
            TokenInfo.freezeStatusToProtobuf(testTokenFreezeStatus));
        assertThat(tokenInfoProto.getTokenInfo().getDefaultKycStatus()).isEqualTo(
            TokenInfo.kycStatusToProtobuf(testTokenKycStatus));
        assertThat(tokenInfoProto.getTokenInfo().getDeleted()).isEqualTo(testTokenIsDeleted);
        assertThat(tokenInfoProto.getTokenInfo().getAutoRenewAccount().getShardNum()).isEqualTo(
            testAutoRenewAccountId.shard);
        assertThat(tokenInfoProto.getTokenInfo().getAutoRenewAccount().getRealmNum()).isEqualTo(
            testAutoRenewAccountId.realm);
        assertThat(tokenInfoProto.getTokenInfo().getAutoRenewAccount().getAccountNum()).isEqualTo(
            testAutoRenewAccountId.num);
        assertThat(tokenInfoProto.getTokenInfo().getAutoRenewPeriod().getSeconds()).isEqualTo(
            testAutoRenewPeriod.toSeconds());
        assertThat(tokenInfoProto.getTokenInfo().getExpiry().getSeconds()).isEqualTo(
            testExpirationTime.getEpochSecond());
        assertThat(tokenInfoProto.getTokenInfo().getMemo()).isEqualTo(testTokenMemo);
        assertThat(tokenInfoProto.getTokenInfo().getTokenType()).isEqualTo(
            com.hedera.hashgraph.sdk.proto.TokenType.valueOf(testTokenType.name()));
        assertThat(tokenInfoProto.getTokenInfo().getSupplyType()).isEqualTo(
            com.hedera.hashgraph.sdk.proto.TokenSupplyType.valueOf(testTokenSupplyType.name()));
        assertThat(tokenInfoProto.getTokenInfo().getMaxSupply()).isEqualTo(testTokenMaxSupply);
        assertThat(tokenInfoProto.getTokenInfo().getFeeScheduleKey().getEd25519().toByteArray()).isEqualTo(
            testFeeScheduleKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getCustomFeesList()).hasSize(testTokenCustomFees.size());
        assertThat(tokenInfoProto.getTokenInfo().getPauseKey().getEd25519().toByteArray()).isEqualTo(
            testPauseKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getPauseStatus()).isEqualTo(
            TokenInfo.pauseStatusToProtobuf(testTokenPauseStatus));
        assertThat(tokenInfoProto.getTokenInfo().getMetadata().toByteArray()).isEqualTo(
            testMetadata);
        assertThat(tokenInfoProto.getTokenInfo().getMetadataKey().getEd25519().toByteArray()).isEqualTo(
            testMetadataKey.toBytesRaw());
        assertThat(tokenInfoProto.getTokenInfo().getLedgerId()).isEqualTo(testTokenLedgerId.toByteString());
    }

    @Test
    void toBytes() {
        var tokenInfo = spawnTokenInfoExample();
        var bytes = tokenInfo.toBytes();
        assertThat(bytes).isEqualTo(tokenInfo.toProtobuf().toByteArray());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenMintTransactionTest.java
package com.hedera.hashgraph.sdk;

import com.google.common.collect.Iterables;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenMintTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenMintTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final Long testAmount = 10L;
    private static final List<byte[]> testMetadataList = List.of(new byte[]{1, 2, 3, 4, 5});
    private static final ByteString testMetadataByteString = ByteString.copyFrom(new byte[]{1, 2, 3, 4, 5});
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    @Test
    void shouldSerializeMetadata() {
        SnapshotMatcher.expect(spawnMetadataTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenMintTransaction spawnTestTransaction() {
        return new TokenMintTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId)
            .setAmount(testAmount)
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    private TokenMintTransaction spawnMetadataTestTransaction() {
        return new TokenMintTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(TokenId.fromString("1.2.3"))
            .setMetadata(testMetadataList)
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytesMetadata() throws Exception {
        var tx = spawnMetadataTestTransaction();
        var tx2 = TokenUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenMint(TokenMintTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenMintTransaction.class);
    }

    @Test
    void constructTokenMintTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenMintTransactionBody.newBuilder()
            .setToken(testTokenId.toProtobuf())
            .setAmount(testAmount)
            .addMetadata(testMetadataByteString)
            .build();

        var tx = TransactionBody.newBuilder().setTokenMint(transactionBody).build();
        var tokenMintTransaction = new TokenMintTransaction(tx);

        assertThat(tokenMintTransaction.getTokenId()).isEqualTo(testTokenId);
        assertThat(tokenMintTransaction.getAmount()).isEqualTo(testAmount);
        assertThat(Iterables.getLast(tokenMintTransaction.getMetadata())).isEqualTo(
            testMetadataByteString.toByteArray());
    }

    @Test
    void getSetTokenId() {
        var tokenMintTransaction = new TokenMintTransaction().setTokenId(testTokenId);
        assertThat(tokenMintTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }

    @Test
    void getSetAmount() {
        var tokenMintTransaction = new TokenMintTransaction().setAmount(testAmount);
        assertThat(tokenMintTransaction.getAmount()).isEqualTo(testAmount);
    }

    @Test
    void getSetAmountFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAmount(testAmount));
    }

    @Test
    void getSetMetadata() {
        var tokenMintTransaction = new TokenMintTransaction().setMetadata(testMetadataList);
        assertThat(tokenMintTransaction.getMetadata()).isEqualTo(testMetadataList);
    }

    @Test
    void getSetMetadataFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setMetadata(testMetadataList));
    }

    @Test
    void addMetadata() {
        var tokenMintTransaction = new TokenMintTransaction().addMetadata(Iterables.getLast(testMetadataList));
        assertThat(Iterables.getLast(tokenMintTransaction.getMetadata())).isEqualTo(
            Iterables.getLast(testMetadataList));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenNftInfoQueryTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenNftInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new TokenNftInfoQuery()
            .setNftId(TokenId.fromString("0.0.5005").nft(101))
            .setMaxQueryPayment(Hbar.fromTinybars(100_000))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    @Test
    void propertiesTest() {
        var tokenId = TokenId.fromString("0.0.5005");
        var query = new TokenNftInfoQuery()
            .byAccountId(AccountId.fromString("0.0.123"))
            .byTokenId(tokenId)
            .setStart(5)
            .setEnd(8)
            .setNftId(tokenId.nft(101))
            .setMaxQueryPayment(Hbar.fromTinybars(100_000));

        assertThat(query.getNftId()).hasToString("0.0.5005/101");
        assertThat(query.getTokenId()).isEqualTo(tokenId);
        assertThat(query.getAccountId()).hasToString("0.0.123");
        assertThat(query.getStart()).isEqualTo(5);
        assertThat(query.getEnd()).isEqualTo(8);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenNftInfoTest.java
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import javax.annotation.Nullable;
import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenNftInfoTest {
    final static Instant creationTime = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private static TokenNftInfo spawnTokenNftInfoExample(@Nullable AccountId spenderAccountId) {
        return new TokenNftInfo(
            TokenId.fromString("1.2.3").nft(4),
            AccountId.fromString("5.6.7"),
            creationTime,
            Hex.decode("deadbeef"),
            LedgerId.MAINNET,
            spenderAccountId
        );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalTokenInfo = spawnTokenNftInfoExample(AccountId.fromString("8.9.10"));
        byte[] tokenInfoBytes = originalTokenInfo.toBytes();
        var copyTokenInfo = TokenNftInfo.fromBytes(tokenInfoBytes);
        assertThat(copyTokenInfo.toString()).isEqualTo(originalTokenInfo.toString());
        SnapshotMatcher.expect(originalTokenInfo.toString()).toMatchSnapshot();
    }

    @Test
    void shouldSerializeNullSpender() throws Exception {
        var originalTokenInfo = spawnTokenNftInfoExample(null);
        byte[] tokenInfoBytes = originalTokenInfo.toBytes();
        var copyTokenInfo = TokenNftInfo.fromBytes(tokenInfoBytes);
        assertThat(copyTokenInfo.toString()).isEqualTo(originalTokenInfo.toString());
        SnapshotMatcher.expect(originalTokenInfo.toString()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenPauseTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenPauseTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenPauseTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    TokenPauseTransaction spawnTestTransaction() {
        return new TokenPauseTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId).setMaxTransactionFee(new Hbar(1)).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytesNft() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenPause(TokenPauseTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenPauseTransaction.class);
    }

    @Test
    void constructTokenPauseTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenPauseTransactionBody.newBuilder().setToken(testTokenId.toProtobuf()).build();

        var tx = TransactionBody.newBuilder().setTokenPause(transactionBody).build();
        var tokenPauseTransaction = new TokenPauseTransaction(tx);

        assertThat(tokenPauseTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenId() {
        var tokenPauseTransaction = new TokenPauseTransaction().setTokenId(testTokenId);
        assertThat(tokenPauseTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }

}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenRejectTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenReference;
import com.hedera.hashgraph.sdk.proto.TokenRejectTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class TokenRejectTransactionTest {

    private static final PrivateKey TEST_PRIVATE_KEY = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final AccountId TEST_OWNER_ID = AccountId.fromString("0.6.9");

    private static final List<TokenId> TEST_TOKEN_IDS = List.of(
        TokenId.fromString("1.2.3"),
        TokenId.fromString("4.5.6"),
        TokenId.fromString("7.8.9"));

    private static final List<NftId> TEST_NFT_IDS = List.of(
        new NftId(TokenId.fromString("4.5.6"), 2),
        new NftId(TokenId.fromString("7.8.9"), 3));

    final Instant TEST_VALID_START = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenRejectTransaction spawnTestTransaction() {
        return new TokenRejectTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), TEST_VALID_START))
            .setOwnerId(TEST_OWNER_ID).setTokenIds(TEST_TOKEN_IDS).setNftIds(TEST_NFT_IDS)
            .setMaxTransactionFee(new Hbar(1)).freeze().sign(TEST_PRIVATE_KEY);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenUpdateNftsTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenReject(TokenRejectTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenRejectTransaction.class);
    }

    @Test
    void constructTokenRejectTransactionFromTransactionBodyProtobuf() {
        var transactionBodyBuilder = TokenRejectTransactionBody.newBuilder();

        transactionBodyBuilder.setOwner(TEST_OWNER_ID.toProtobuf());

        for (TokenId tokenId : TEST_TOKEN_IDS) {
            transactionBodyBuilder.addRejections(TokenReference.newBuilder().setFungibleToken(tokenId.toProtobuf()).build());
        }

        for (NftId nftId : TEST_NFT_IDS) {
            transactionBodyBuilder.addRejections(TokenReference.newBuilder().setNft(nftId.toProtobuf()).build());
        }

        var tx = TransactionBody.newBuilder().setTokenReject(transactionBodyBuilder.build()).build();
        var tokenRejectTransaction = new TokenRejectTransaction(tx);

        assertThat(tokenRejectTransaction.getOwnerId()).isEqualTo(TEST_OWNER_ID);
        assertThat(tokenRejectTransaction.getTokenIds()).hasSize(TEST_TOKEN_IDS.size());
        assertThat(tokenRejectTransaction.getNftIds()).hasSize(TEST_NFT_IDS.size());
    }


    @Test
    void getSetOwnerId() {
        var transaction = new TokenRejectTransaction().setOwnerId(TEST_OWNER_ID);
        assertThat(transaction.getOwnerId()).isEqualTo(TEST_OWNER_ID);
    }

    @Test
    void getSetOwnerIdFrozen() {
        var transaction = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> transaction.setOwnerId(TEST_OWNER_ID));
    }

    @Test
    void getSetTokenIds() {
        var transaction = new TokenRejectTransaction().setTokenIds(TEST_TOKEN_IDS);
        assertThat(transaction.getTokenIds()).isEqualTo(TEST_TOKEN_IDS);
    }

    @Test
    void getSetTokenIdFrozen() {
        var transaction = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> transaction.setTokenIds(TEST_TOKEN_IDS));
    }

    @Test
    void getSetNftIds() {
        var transaction = new TokenRejectTransaction().setNftIds(TEST_NFT_IDS);
        assertThat(transaction.getNftIds()).isEqualTo(TEST_NFT_IDS);
    }

    @Test
    void getSetNftIdFrozen() {
        var transaction = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> transaction.setNftIds(TEST_NFT_IDS));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenRelationshipTest.java
package com.hedera.hashgraph.sdk;

import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenRelationshipTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    TokenRelationship spawnTokenRelationshipExample() {
        return new TokenRelationship(
            TokenId.fromString("1.2.3"),
            "ABC",
            55,
            true,
            true,
            4,
            true
        );
    }

    @Test
    void shouldSerializeTokenRelationship() throws Exception {
        var originalTokenRelationship = spawnTokenRelationshipExample();
        byte[] tokenRelationshipBytes = originalTokenRelationship.toBytes();
        var copyTokenRelationship = TokenRelationship.fromBytes(tokenRelationshipBytes);
        assertThat(copyTokenRelationship.toString().replaceAll("@[A-Za-z0-9]+", ""))
            .isEqualTo(originalTokenRelationship.toString().replaceAll("@[A-Za-z0-9]+", ""));
        SnapshotMatcher.expect(originalTokenRelationship.toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenRevokeKycTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenRevokeKycTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenRevokeKycTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final AccountId testAccountId = AccountId.fromString("6.9.0");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenRevokeKycTransaction spawnTestTransaction() {
        return new TokenRevokeKycTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(testAccountId).setTokenId(testTokenId).setMaxTransactionFee(new Hbar(1)).freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenRevokeKycTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenRevokeKyc(TokenRevokeKycTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenRevokeKycTransaction.class);
    }

    @Test
    void constructTokenRevokeKycTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenRevokeKycTransactionBody.newBuilder().setAccount(testAccountId.toProtobuf())
            .setToken(testTokenId.toProtobuf()).build();

        var tx = TransactionBody.newBuilder().setTokenRevokeKyc(transactionBody).build();
        var tokenRevokeKycTransaction = new TokenRevokeKycTransaction(tx);

        assertThat(tokenRevokeKycTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetAccountId() {
        var tokenRevokeKycTransaction = new TokenRevokeKycTransaction().setAccountId(testAccountId);
        assertThat(tokenRevokeKycTransaction.getAccountId()).isEqualTo(testAccountId);
    }

    @Test
    void getSetAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAccountId(testAccountId));
    }

    @Test
    void getSetTokenId() {
        var tokenRevokeKycTransaction = new TokenRevokeKycTransaction().setTokenId(testTokenId);
        assertThat(tokenRevokeKycTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenSupplyTypeTest.java
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.TokenSupplyType;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenSupplyTypeTest {
    private final TokenSupplyType tokenSupplyTypeInfinite = TokenSupplyType.INFINITE;
    private final TokenSupplyType tokenSupplyTypeFinite = TokenSupplyType.FINITE;

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(
                com.hedera.hashgraph.sdk.TokenSupplyType.valueOf(tokenSupplyTypeInfinite).toString(),
                com.hedera.hashgraph.sdk.TokenSupplyType.valueOf(tokenSupplyTypeFinite).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(
                com.hedera.hashgraph.sdk.TokenSupplyType.valueOf(tokenSupplyTypeInfinite).toProtobuf(),
                com.hedera.hashgraph.sdk.TokenSupplyType.valueOf(tokenSupplyTypeFinite).toProtobuf())
            .toMatchSnapshot();
    }

    @Test
    void tokenSupplyTestToString() {
        assertThat(com.hedera.hashgraph.sdk.TokenSupplyType.INFINITE).hasToString("INFINITE");
        assertThat(com.hedera.hashgraph.sdk.TokenSupplyType.FINITE).hasToString("FINITE");
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenTypeTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.TokenType;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class TokenTypeTest {

    private final TokenType tokenTypeFungible = TokenType.FUNGIBLE_COMMON;
    private final TokenType tokenTypeNonFungible = TokenType.NON_FUNGIBLE_UNIQUE;

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() {
        SnapshotMatcher.expect(
                com.hedera.hashgraph.sdk.TokenType.valueOf(tokenTypeFungible).toString(),
                com.hedera.hashgraph.sdk.TokenType.valueOf(tokenTypeNonFungible).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() {
        SnapshotMatcher.expect(
                com.hedera.hashgraph.sdk.TokenType.valueOf(tokenTypeFungible).toProtobuf(),
                com.hedera.hashgraph.sdk.TokenType.valueOf(tokenTypeNonFungible).toProtobuf())
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenUnfreezeTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenUnfreezeAccountTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class TokenUnfreezeTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenUnfreezeTransaction spawnTestTransaction() {
        return new TokenUnfreezeTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setAccountId(AccountId.fromString("0.0.222"))
            .setTokenId(TokenId.fromString("6.5.4"))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenUnfreezeTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenUnfreeze(TokenUnfreezeAccountTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenUnfreezeTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenUnpauseTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenUnpauseTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TokenUnpauseTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    TokenUnpauseTransaction spawnTestTransaction() {
        return new TokenUnpauseTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId).setMaxTransactionFee(new Hbar(1)).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    @Test
    void shouldBytesNft() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenUnpause(TokenUnpauseTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenUnpauseTransaction.class);
    }

    @Test
    void constructTokenUnpauseTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenUnpauseTransactionBody.newBuilder().setToken(testTokenId.toProtobuf()).build();

        var tx = TransactionBody.newBuilder().setTokenUnpause(transactionBody).build();
        var tokenUnpauseTransaction = new TokenUnpauseTransaction(tx);

        assertThat(tokenUnpauseTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenId() {
        var tokenUnpauseTransaction = new TokenUnpauseTransaction().setTokenId(testTokenId);
        assertThat(tokenUnpauseTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenUpdateNftsTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenUpdateNftsTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class TokenUpdateNftsTransactionTest {
    private static final PrivateKey testMetadataKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final List<Long> testSerialNumbers = Arrays.asList(8L, 9L, 10L);
    private static final byte[] testMetadata = new byte[]{1, 2, 3, 4, 5};
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenUpdateNftsTransaction spawnTestTransaction() {
        return new TokenUpdateNftsTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId).setMetadata(testMetadata).setSerials(testSerialNumbers)
            .setMaxTransactionFee(new Hbar(1)).freeze().sign(testMetadataKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenUpdateNftsTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenUpdateNfts(TokenUpdateNftsTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenUpdateNftsTransaction.class);
    }

    @Test
    void constructTokenUpdateTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenUpdateNftsTransactionBody.newBuilder().setToken(testTokenId.toProtobuf())
            .setMetadata(BytesValue.of(ByteString.copyFrom(testMetadata))).addAllSerialNumbers(testSerialNumbers)
            .build();

        var tx = TransactionBody.newBuilder().setTokenUpdateNfts(transactionBody).build();
        var tokenUpdateNftsTransaction = new TokenUpdateNftsTransaction(tx);

        assertThat(tokenUpdateNftsTransaction.getTokenId()).isEqualTo(testTokenId);
        assertThat(tokenUpdateNftsTransaction.getMetadata()).isEqualTo(testMetadata);
        assertThat(tokenUpdateNftsTransaction.getSerials()).isEqualTo(testSerialNumbers);
    }

    @Test
    void getSetTokenId() {
        var tokenUpdateNftsTransaction = new TokenUpdateNftsTransaction().setTokenId(testTokenId);
        assertThat(tokenUpdateNftsTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }

    @Test
    void getSetMetadata() {
        var tx = spawnTestTransaction();
        assertThat(tx.getMetadata()).isEqualTo(testMetadata);
    }

    @Test
    void getSetMetadataFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setMetadata(testMetadata));
    }

    @Test
    void getSetSerialNumbers() {
        var tx = spawnTestTransaction();
        assertThat(tx.getSerials()).isEqualTo(testSerialNumbers);
    }

    @Test
    void getSetSerialNumbersFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setSerials(testSerialNumbers));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TokenUpdateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;


public class TokenUpdateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final PublicKey testAdminKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11")
        .getPublicKey();
    private static final PublicKey testKycKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12")
        .getPublicKey();
    private static final PublicKey testFreezeKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e13")
        .getPublicKey();
    private static final PublicKey testWipeKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e14")
        .getPublicKey();
    private static final PublicKey testSupplyKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e15")
        .getPublicKey();
    private static final PublicKey testFeeScheduleKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e16")
        .getPublicKey();
    private static final PublicKey testPauseKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e17")
        .getPublicKey();
    private static final PublicKey testMetadataKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e18")
        .getPublicKey();
    private static final AccountId testTreasuryAccountId = AccountId.fromString("7.7.7");
    private static final AccountId testAutoRenewAccountId = AccountId.fromString("8.8.8");
    private static final String testTokenName = "test name";
    private static final String testTokenSymbol = "test symbol";
    private static final String testTokenMemo = "test memo";
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final Duration testAutoRenewPeriod = Duration.ofHours(10);
    private static final Instant testExpirationTime = Instant.now();
    private static final byte[] testMetadata = new byte[]{1, 2, 3, 4, 5};
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TokenUpdateTransaction spawnTestTransaction() {
        return new TokenUpdateTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(testTokenId).setFeeScheduleKey(testFeeScheduleKey).setSupplyKey(testSupplyKey)
            .setAdminKey(testAdminKey).setAutoRenewAccountId(testAutoRenewAccountId)
            .setAutoRenewPeriod(testAutoRenewPeriod).setFreezeKey(testFreezeKey).setWipeKey(testWipeKey)
            .setTokenSymbol(testTokenSymbol).setKycKey(testKycKey).setPauseKey(testPauseKey)
            .setMetadataKey(testMetadataKey).setExpirationTime(validStart).setTreasuryAccountId(testTreasuryAccountId)
            .setTokenName(testTokenName).setTokenMemo(testTokenMemo).setMaxTransactionFee(new Hbar(1))
            .setTokenMetadata(testMetadata).setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenUpdate(TokenUpdateTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenUpdateTransaction.class);
    }

    @Test
    void constructTokenUpdateTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenUpdateTransactionBody.newBuilder().setToken(testTokenId.toProtobuf())
            .setName(testTokenName).setSymbol(testTokenSymbol).setTreasury(testTreasuryAccountId.toProtobuf())
            .setAdminKey(testAdminKey.toProtobufKey()).setKycKey(testKycKey.toProtobufKey())
            .setFreezeKey(testFreezeKey.toProtobufKey()).setWipeKey(testWipeKey.toProtobufKey())
            .setSupplyKey(testSupplyKey.toProtobufKey()).setAutoRenewAccount(testAutoRenewAccountId.toProtobuf())
            .setAutoRenewPeriod(
                com.hedera.hashgraph.sdk.proto.Duration.newBuilder().setSeconds(testAutoRenewPeriod.toSeconds())
                    .build()).setExpiry(Timestamp.newBuilder().setSeconds(testExpirationTime.getEpochSecond()).build())
            .setMemo(StringValue.newBuilder().setValue(testTokenMemo).build())
            .setFeeScheduleKey(testFeeScheduleKey.toProtobufKey()).setPauseKey(testPauseKey.toProtobufKey())
            .setMetadataKey(testMetadataKey.toProtobufKey())
            .setMetadata(BytesValue.of(ByteString.copyFrom(testMetadata)))
            .setKeyVerificationMode(com.hedera.hashgraph.sdk.proto.TokenKeyValidation.NO_VALIDATION).build();

        var tx = TransactionBody.newBuilder().setTokenUpdate(transactionBody).build();
        var tokenUpdateTransaction = new TokenUpdateTransaction(tx);

        assertThat(tokenUpdateTransaction.getTokenId()).isEqualTo(testTokenId);
        assertThat(tokenUpdateTransaction.getTokenName()).isEqualTo(testTokenName);
        assertThat(tokenUpdateTransaction.getTokenSymbol()).isEqualTo(testTokenSymbol);
        assertThat(tokenUpdateTransaction.getTreasuryAccountId()).isEqualTo(testTreasuryAccountId);
        assertThat(tokenUpdateTransaction.getAdminKey()).isEqualTo(testAdminKey);
        assertThat(tokenUpdateTransaction.getKycKey()).isEqualTo(testKycKey);
        assertThat(tokenUpdateTransaction.getFreezeKey()).isEqualTo(testFreezeKey);
        assertThat(tokenUpdateTransaction.getWipeKey()).isEqualTo(testWipeKey);
        assertThat(tokenUpdateTransaction.getSupplyKey()).isEqualTo(testSupplyKey);
        assertThat(tokenUpdateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
        assertThat(tokenUpdateTransaction.getAutoRenewPeriod().toSeconds()).isEqualTo(testAutoRenewPeriod.toSeconds());
        assertThat(tokenUpdateTransaction.getExpirationTime().getEpochSecond()).isEqualTo(
            testExpirationTime.getEpochSecond());
        assertThat(tokenUpdateTransaction.getTokenMemo()).isEqualTo(testTokenMemo);
        assertThat(tokenUpdateTransaction.getFeeScheduleKey()).isEqualTo(testFeeScheduleKey);
        assertThat(tokenUpdateTransaction.getPauseKey()).isEqualTo(testPauseKey);
        assertThat(tokenUpdateTransaction.getMetadataKey()).isEqualTo(testMetadataKey);
        assertThat(tokenUpdateTransaction.getTokenMetadata()).isEqualTo(testMetadata);
        assertThat(tokenUpdateTransaction.getKeyVerificationMode()).isEqualTo(TokenKeyValidation.NO_VALIDATION);
    }

    @Test
    void getSetTokenId() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setTokenId(testTokenId);
        assertThat(tokenUpdateTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }

    @Test
    void getSetName() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setTokenName(testTokenName);
        assertThat(tokenUpdateTransaction.getTokenName()).isEqualTo(testTokenName);
    }

    @Test
    void getSetNameFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenName(testTokenName));
    }

    @Test
    void getSetSymbol() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setTokenSymbol(testTokenSymbol);
        assertThat(tokenUpdateTransaction.getTokenSymbol()).isEqualTo(testTokenSymbol);
    }

    @Test
    void getSetSymbolFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenSymbol(testTokenSymbol));
    }

    @Test
    void getSetTreasuryAccountId() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setTreasuryAccountId(testTreasuryAccountId);
        assertThat(tokenUpdateTransaction.getTreasuryAccountId()).isEqualTo(testTreasuryAccountId);
    }

    @Test
    void getSetTreasuryAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTreasuryAccountId(testTreasuryAccountId));
    }

    @Test
    void getSetAdminKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setAdminKey(testAdminKey);
        assertThat(tokenUpdateTransaction.getAdminKey()).isEqualTo(testAdminKey);
    }

    @Test
    void getSetAdminKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAdminKey(testAdminKey));
    }

    @Test
    void getSetKycKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setKycKey(testKycKey);
        assertThat(tokenUpdateTransaction.getKycKey()).isEqualTo(testKycKey);
    }

    @Test
    void getSetKycKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setKycKey(testKycKey));
    }

    @Test
    void getSetFreezeKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setFreezeKey(testFreezeKey);
        assertThat(tokenUpdateTransaction.getFreezeKey()).isEqualTo(testFreezeKey);
    }

    @Test
    void getSetFreezeKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setFreezeKey(testFreezeKey));
    }

    @Test
    void getSetWipeKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setWipeKey(testWipeKey);
        assertThat(tokenUpdateTransaction.getWipeKey()).isEqualTo(testWipeKey);
    }

    @Test
    void getSetWipeKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setWipeKey(testWipeKey));
    }

    @Test
    void getSetSupplyKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setSupplyKey(testSupplyKey);
        assertThat(tokenUpdateTransaction.getSupplyKey()).isEqualTo(testSupplyKey);
    }

    @Test
    void getSetSupplyKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setSupplyKey(testSupplyKey));
    }

    @Test
    void getSetAutoRenewAccountId() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setAutoRenewAccountId(testAutoRenewAccountId);
        assertThat(tokenUpdateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
    }

    @Test
    void getSetAutoRenewAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAutoRenewAccountId(testAutoRenewAccountId));
    }

    @Test
    void getSetAutoRenewPeriod() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setAutoRenewPeriod(testAutoRenewPeriod);
        assertThat(tokenUpdateTransaction.getAutoRenewPeriod()).isEqualTo(testAutoRenewPeriod);
    }

    @Test
    void getSetAutoRenewPeriodFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAutoRenewPeriod(testAutoRenewPeriod));
    }

    @Test
    void getSetExpirationTime() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setExpirationTime(testExpirationTime);
        assertThat(tokenUpdateTransaction.getExpirationTime()).isEqualTo(testExpirationTime);
    }

    @Test
    void getSetExpirationTimeFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setExpirationTime(testExpirationTime));
    }

    @Test
    void getSetTokenMemo() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setTokenMemo(testTokenMemo);
        assertThat(tokenUpdateTransaction.getTokenMemo()).isEqualTo(testTokenMemo);
    }

    @Test
    void getSetTokenMemoFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenMemo(testTokenMemo));
    }

    @Test
    void getSetFeeScheduleKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setFeeScheduleKey(testFeeScheduleKey);
        assertThat(tokenUpdateTransaction.getFeeScheduleKey()).isEqualTo(testFeeScheduleKey);
    }

    @Test
    void getSetFeeScheduleKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setFeeScheduleKey(testFeeScheduleKey));
    }

    @Test
    void getSetPauseKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setPauseKey(testPauseKey);
        assertThat(tokenUpdateTransaction.getPauseKey()).isEqualTo(testPauseKey);
    }

    @Test
    void getSetPauseKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setPauseKey(testPauseKey));
    }

    @Test
    void getSetMetadataKey() {
        var tokenUpdateTransaction = new TokenUpdateTransaction().setMetadataKey(testMetadataKey);
        assertThat(tokenUpdateTransaction.getMetadataKey()).isEqualTo(testMetadataKey);
    }

    @Test
    void getSetMetadataKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setMetadataKey(testMetadataKey));
    }

    @Test
    void getSetMetadata() {
        var tx = spawnTestTransaction();
        assertThat(tx.getTokenMetadata()).isEqualTo(testMetadata);
    }

    @Test
    void getSetMetadataFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenMetadata(testMetadata));
    }

    @Test
    void getSetKeyVerificationMode() {
        var tx = spawnTestTransaction();
        assertThat(tx.getKeyVerificationMode()).isEqualTo(TokenKeyValidation.NO_VALIDATION);
    }

    @Test
    void getSetKeyVerificationModeFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TokenWipeTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TokenWipeAccountTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;


public class TokenWipeTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final AccountId testAccountId = AccountId.fromString("0.6.9");
    private static final TokenId testTokenId = TokenId.fromString("4.2.0");
    private static final long testAmount = 4L;
    private static final List<Long> testSerialNumbers = Arrays.asList(8L, 9L, 10L);
    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFungible() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenWipeTransaction spawnTestTransaction() {
        return new TokenWipeTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(TokenId.fromString("0.0.111"))
            .setAccountId(testAccountId)
            .setAmount(testAmount)
            .setSerials(testSerialNumbers)
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldSerializeNft() {
        SnapshotMatcher.expect(spawnTestTransactionNft()
            .toString()
        ).toMatchSnapshot();
    }

    private TokenWipeTransaction spawnTestTransactionNft() {
        return new TokenWipeTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTokenId(TokenId.fromString("0.0.111"))
            .setAccountId(testAccountId)
            .setSerials(Collections.singletonList(444L))
            .setMaxTransactionFee(new Hbar(1))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytesFungible() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TokenWipeTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void shouldBytesNft() throws Exception {
        var tx = spawnTestTransactionNft();
        var tx2 = TokenWipeTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setTokenWipe(TokenWipeAccountTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TokenWipeTransaction.class);
    }

    @Test
    void constructTokenWipeTransactionFromTransactionBodyProtobuf() {
        var transactionBody = TokenWipeAccountTransactionBody.newBuilder().setToken(testTokenId.toProtobuf())
            .setAccount(testAccountId.toProtobuf()).setAmount(testAmount).addAllSerialNumbers(testSerialNumbers)
            .build();

        var txBody = TransactionBody.newBuilder().setTokenWipe(transactionBody).build();
        var tokenWipeTransaction = new TokenWipeTransaction(txBody);

        assertThat(tokenWipeTransaction.getTokenId()).isEqualTo(testTokenId);
        assertThat(tokenWipeTransaction.getAccountId()).isEqualTo(testAccountId);
        assertThat(tokenWipeTransaction.getAmount()).isEqualTo(testAmount);
        assertThat(tokenWipeTransaction.getSerials()).isEqualTo(testSerialNumbers);
    }

    @Test
    void getSetTokenId() {
        var tokenWipeTransaction = new TokenWipeTransaction().setTokenId(testTokenId);
        assertThat(tokenWipeTransaction.getTokenId()).isEqualTo(testTokenId);
    }

    @Test
    void getSetTokenIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTokenId(testTokenId));
    }

    @Test
    void getSetAccountId() {
        var tx = spawnTestTransaction();
        assertThat(tx.getAccountId()).isEqualTo(testAccountId);
    }

    @Test
    void getSetAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAccountId(testAccountId));
    }

    @Test
    void getSetAmount() {
        var tx = spawnTestTransaction();
        assertThat(tx.getAmount()).isEqualTo(testAmount);
    }

    @Test
    void getSetAmountFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAmount(testAmount));
    }

    @Test
    void getSetSerialNumbers() {
        var tx = spawnTestTransaction();
        assertThat(tx.getSerials()).isEqualTo(testSerialNumbers);
    }

    @Test
    void getSetSerialNumbersFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setSerials(testSerialNumbers));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicCreateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ConsensusCreateTopicTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicCreateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TopicCreateTransaction spawnTestTransaction() {
        return new TopicCreateTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setSubmitKey(unusedPrivateKey)
            .setAdminKey(unusedPrivateKey)
            .setAutoRenewAccountId(AccountId.fromString("0.0.5007"))
            .setAutoRenewPeriod(Duration.ofHours(24))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .setTopicMemo("hello memo")
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TopicCreateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setConsensusCreateTopic(ConsensusCreateTopicTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TopicCreateTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicDeleteTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.ConsensusDeleteTopicTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicDeleteTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction()
            .toString()
        ).toMatchSnapshot();
    }

    private TopicDeleteTransaction spawnTestTransaction() {
        return new TopicDeleteTransaction()
            .setNodeAccountIds(Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTopicId(TopicId.fromString("0.0.5007"))
            .setMaxTransactionFee(Hbar.fromTinybars(100_000))
            .freeze()
            .sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TopicDeleteTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setConsensusDeleteTopic(ConsensusDeleteTopicTransactionBody.newBuilder().build())
            .build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TopicDeleteTransaction.class);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

class TopicIdTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerializeFromString() {
        SnapshotMatcher.expect(TopicId.fromString("0.0.5005").toString()).toMatchSnapshot();
    }

    @Test
    void toBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(Hex.toHexString(new TopicId(5005).toBytes())).toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(TopicId.fromBytes(new TopicId(5005).toBytes()).toString()).toMatchSnapshot();
    }

    @Test
    void fromSolidityAddress() {
        SnapshotMatcher.expect(TokenId.fromSolidityAddress("000000000000000000000000000000000000138D").toString()).toMatchSnapshot();
    }

    @Test
    void toSolidityAddress() {
        SnapshotMatcher.expect(new TokenId(5005).toSolidityAddress()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicInfoQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class TopicInfoQueryTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new TopicInfoQuery()
            .setTopicId(TopicId.fromString("0.0.5005"))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicInfoTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.ConsensusGetTopicInfoResponse;
import com.hedera.hashgraph.sdk.proto.ConsensusTopicInfo;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;


public class TopicInfoTest {
    private static final PrivateKey privateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    private static final byte[] hash = {2};

    private static final ConsensusGetTopicInfoResponse info = ConsensusGetTopicInfoResponse.newBuilder()
        .setTopicInfo(ConsensusTopicInfo.newBuilder()
            .setMemo("1")
            .setRunningHash(ByteString.copyFrom(hash))
            .setSequenceNumber(3)
            .setExpirationTime(InstantConverter.toProtobuf(Instant.ofEpochMilli(4)))
            .setAutoRenewPeriod(DurationConverter.toProtobuf(Duration.ofDays(5)))
            .setAdminKey(privateKey.getPublicKey().toProtobufKey())
            .setSubmitKey(privateKey.getPublicKey().toProtobufKey())
            .setAutoRenewAccount(new AccountId(4).toProtobuf())
            .setLedgerId(LedgerId.TESTNET.toByteString()))
        .build();


    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void fromProtobuf() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(TopicInfo.fromProtobuf(info).toString())
            .toMatchSnapshot();
    }

    @Test
    void toProtobuf() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(TopicInfo.fromProtobuf(info).toProtobuf().toString())
            .toMatchSnapshot();
    }

    @Test
    void fromBytes() throws InvalidProtocolBufferException {
        SnapshotMatcher.expect(TopicInfo.fromBytes(info.toByteArray()).toString())
            .toMatchSnapshot();
    }

    @Test
    void toBytes() {
        SnapshotMatcher.expect(Hex.toHexString(TopicInfo.fromProtobuf(info).toBytes()))
            .toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicMessageChunkTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ConsensusMessageChunkInfo;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicResponse;
import org.junit.jupiter.api.Test;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicMessageChunkTest {

    private static final Instant testTimestamp = Instant.ofEpochSecond(1554158542);
    private static final byte[] testContents = new byte[]{0x01, 0x02, 0x03};
    private static final byte[] testRunningHash = new byte[]{0x04, 0x05, 0x06};
    private static final long testSequenceNumber = 7L;
    private static final TransactionId testTransactionId = new TransactionId(new AccountId(1), testTimestamp);

    @Test
    void constructWithArgs() {
        var consensusTopicResponse = ConsensusTopicResponse.newBuilder()
            .setConsensusTimestamp(Timestamp.newBuilder().setSeconds(testTimestamp.getEpochSecond()))
            .setMessage(ByteString.copyFrom(testContents)).setRunningHash(ByteString.copyFrom(testRunningHash))
            .setSequenceNumber(testSequenceNumber).setChunkInfo(
                ConsensusMessageChunkInfo.newBuilder().setInitialTransactionID(testTransactionId.toProtobuf()).build())
            .build();

        TopicMessageChunk topicMessageChunk = new TopicMessageChunk(consensusTopicResponse);

        assertThat(topicMessageChunk.consensusTimestamp).isEqualTo(testTimestamp);
        assertThat(topicMessageChunk.contentSize).isEqualTo(testContents.length);
        assertThat(topicMessageChunk.runningHash).isEqualTo(testRunningHash);
        assertThat(topicMessageChunk.sequenceNumber).isEqualTo(testSequenceNumber);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicMessageQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.common.base.Stopwatch;
import com.google.common.primitives.Longs;
import com.google.common.util.concurrent.Uninterruptibles;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.AccountID;
import com.hedera.hashgraph.sdk.proto.ConsensusMessageChunkInfo;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TopicID;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusServiceGrpc;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicQuery;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicResponse;
import io.github.jsonSnapshot.SnapshotMatcher;
import io.grpc.Server;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.inprocess.InProcessServerBuilder;
import io.grpc.stub.StreamObserver;
import org.assertj.core.api.InstanceOfAssertFactories;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

class TopicMessageQueryTest {

    private static final Instant START_TIME = Instant.now();

    private Client client;
    final private AtomicBoolean complete = new AtomicBoolean(false);
    final private List<Throwable> errors = new ArrayList<>();
    final private List<TopicMessage> received = new ArrayList<>();
    final private ConsensusServiceStub consensusServiceStub = new ConsensusServiceStub();
    private Server server;
    private TopicMessageQuery topicMessageQuery;

    @BeforeAll
    static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @BeforeEach
    void setup() throws Exception {
        client = Client.forNetwork(Collections.emptyMap());
        client.setMirrorNetwork(List.of("in-process:test"));
        server = InProcessServerBuilder.forName("test")
            .addService(consensusServiceStub)
            .directExecutor()
            .build()
            .start();
        topicMessageQuery = new TopicMessageQuery();
        topicMessageQuery.setCompletionHandler(() -> complete.set(true));
        topicMessageQuery.setEndTime(START_TIME.plusSeconds(100L));
        topicMessageQuery.setErrorHandler((t, r) -> errors.add(t));
        topicMessageQuery.setMaxBackoff(Duration.ofMillis(500L));
        topicMessageQuery.setStartTime(START_TIME);
        topicMessageQuery.setTopicId(TopicId.fromString("0.0.1000"));
    }

    @AfterEach
    void teardown() throws Exception {
        consensusServiceStub.verify();
        if (client != null) {
            client.close();
        }
        if (server != null) {
            server.shutdown();
            server.awaitTermination();
        }
    }

    @Test
    @SuppressWarnings("NullAway")
    void setCompletionHandlerNull() {
        assertThatThrownBy(() -> topicMessageQuery.setCompletionHandler(null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("completionHandler must not be null");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setEndTimeNull() {
        assertThatThrownBy(() -> topicMessageQuery.setEndTime(null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("endTime must not be null");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setErrorHandlerNull() {
        assertThatThrownBy(() -> topicMessageQuery.setErrorHandler(null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("errorHandler must not be null");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setMaxAttemptsNegative() {
        assertThatThrownBy(() -> topicMessageQuery.setMaxAttempts(-1))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("maxAttempts must be positive");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setMaxBackoffNull() {
        assertThatThrownBy(() -> topicMessageQuery.setMaxBackoff(null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("maxBackoff must be at least 500 ms");
    }

    @Test
    void setMaxBackoffLow() {
        assertThatThrownBy(() -> topicMessageQuery.setMaxBackoff(Duration.ofMillis(499L)))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("maxBackoff must be at least 500 ms");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setRetryHandlerNull() {
        assertThatThrownBy(() -> topicMessageQuery.setRetryHandler(null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("retryHandler must not be null");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setStartTimeNull() {
        assertThatThrownBy(() -> topicMessageQuery.setStartTime(null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("startTime must not be null");
    }

    @Test
    @SuppressWarnings("NullAway")
    void setTopicIdNull() {
        assertThatThrownBy(() -> topicMessageQuery.setTopicId(null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("topicId must not be null");
    }

    @Test
    @Timeout(3)
    void subscribe() {
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(response(1L));
        consensusServiceStub.responses.add(response(2L));

        subscribeToMirror(received::add);

        assertThat(errors).isEmpty();
        assertThat(received).hasSize(2).extracting(t -> t.sequenceNumber).containsExactly(1L, 2L);
    }

    @Test
    @Timeout(3)
    void subscribeChunked() {
        ConsensusTopicResponse response1 = response(1L, 2);
        ConsensusTopicResponse response2 = response(2L, 2);
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(response1);
        consensusServiceStub.responses.add(response2);

        subscribeToMirror(received::add);

        var message = combine(response1.getMessage().toByteArray(), response2.getMessage().toByteArray());
        assertThat(errors).isEmpty();
        assertThat(received)
            .hasSize(1)
            .first()
            .returns(toInstant(response2.getConsensusTimestamp()), t -> t.consensusTimestamp)
            .returns(response2.getChunkInfo().getInitialTransactionID(), t -> Objects.requireNonNull(t.transactionId).toProtobuf())
            .returns(message, t -> t.contents)
            .returns(response2.getRunningHash().toByteArray(), t -> t.runningHash)
            .returns(response2.getSequenceNumber(), t -> t.sequenceNumber)
            .extracting(t -> t.chunks)
            .asInstanceOf(InstanceOfAssertFactories.ARRAY)
            .hasSize(2)
            .extracting(c -> ((TopicMessageChunk) c).sequenceNumber)
            .contains(1L, 2L);
    }

    @Test
    @Timeout(3)
    void subscribeNoResponse() {
        consensusServiceStub.requests.add(request().build());

        subscribeToMirror(received::add);

        assertThat(errors).isEmpty();
        assertThat(received).isEmpty();
    }

    @Test
    @Timeout(3)
    void errorDuringOnNext() {
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(response(1L));

        subscribeToMirror(t -> {
            throw new RuntimeException();
        });

        assertThat(errors).hasSize(1).first().isInstanceOf(RuntimeException.class);
        assertThat(received).isEmpty();
    }

    @ParameterizedTest(name = "Retry recovers w/ status {0} and description {1}")
    @CsvSource({
        "INTERNAL, internal RST_STREAM error",
        "INTERNAL, rst stream",
        "NOT_FOUND, ",
        "RESOURCE_EXHAUSTED, ",
        "UNAVAILABLE, "
    })
    @Timeout(3)
    void retryRecovers(Status.Code code, String description) {
        ConsensusTopicResponse response = response(1L);
        Instant nextTimestamp = toInstant(response.getConsensusTimestamp()).plusNanos(1L);
        ConsensusTopicQuery.Builder request = request();

        consensusServiceStub.requests.add(request.build());
        consensusServiceStub.requests.add(request.setConsensusStartTime(toTimestamp(nextTimestamp)).build());
        consensusServiceStub.responses.add(response);
        consensusServiceStub.responses.add(code.toStatus().withDescription(description).asRuntimeException());
        consensusServiceStub.responses.add(response(2L));

        subscribeToMirror(received::add);

        assertThat(received).hasSize(2).extracting(t -> t.sequenceNumber).containsExactly(1L, 2L);
        assertThat(errors).isEmpty();
    }

    @ParameterizedTest(name = "No retry w/ status {0} and description {1}")
    @CsvSource({
        "INTERNAL, internal first_stream error",
        "INTERNAL, internal error",
        "INTERNAL, ",
        "INVALID_ARGUMENT, "
    })
    @Timeout(3)
    void noRetry(Status.Code code, String description) {
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(code.toStatus().withDescription(description).asRuntimeException());

        subscribeToMirror(received::add);

        assertThat(received).isEmpty();
        assertThat(errors).hasSize(1)
            .first()
            .isInstanceOf(StatusRuntimeException.class)
            .extracting(t -> ((StatusRuntimeException) t).getStatus().getCode())
            .isEqualTo(code);
    }

    @Test
    @Timeout(3)
    void customRetry() {
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(Status.INVALID_ARGUMENT.asRuntimeException());
        consensusServiceStub.responses.add(response(1L));
        topicMessageQuery.setRetryHandler(t -> true);

        subscribeToMirror(received::add);

        assertThat(received).hasSize(1).extracting(t -> t.sequenceNumber).containsExactly(1L);
        assertThat(errors).isEmpty();
    }

    @Test
    @Timeout(3)
    void retryWithLimit() {
        ConsensusTopicResponse response = response(1L);
        Instant nextTimestamp = toInstant(response.getConsensusTimestamp()).plusNanos(1L);
        ConsensusTopicQuery.Builder request = request();
        topicMessageQuery.setLimit(2);

        consensusServiceStub.requests.add(request.setLimit(2L).build());
        consensusServiceStub.requests.add(request.setConsensusStartTime(toTimestamp(nextTimestamp)).setLimit(1L).build());
        consensusServiceStub.responses.add(response);
        consensusServiceStub.responses.add(Status.RESOURCE_EXHAUSTED.asRuntimeException());
        consensusServiceStub.responses.add(response(2L));

        subscribeToMirror(received::add);

        assertThat(received).hasSize(2).extracting(t -> t.sequenceNumber).containsExactly(1L, 2L);
        assertThat(errors).isEmpty();
    }

    @Test
    @Timeout(3)
    void retriesExhausted() {
        topicMessageQuery.setMaxAttempts(1);
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(Status.RESOURCE_EXHAUSTED.asRuntimeException());
        consensusServiceStub.responses.add(Status.RESOURCE_EXHAUSTED.asRuntimeException());

        subscribeToMirror(received::add);

        assertThat(received).isEmpty();
        assertThat(errors).hasSize(1)
            .first()
            .isInstanceOf(StatusRuntimeException.class)
            .extracting(t -> ((StatusRuntimeException) t).getStatus())
            .isEqualTo(Status.RESOURCE_EXHAUSTED);
    }

    @Test
    @Timeout(5)
    void errorWhenCallIsCancelled() {
        consensusServiceStub.requests.add(request().build());
        consensusServiceStub.responses.add(Status.CANCELLED.asRuntimeException());

        subscribeToMirror(received::add);

        assertThat(errors)
            .hasSize(1)
            .first()
            .isInstanceOf(StatusRuntimeException.class)
            .extracting(t -> ((StatusRuntimeException)t).getStatus())
            .isEqualTo(Status.CANCELLED);

        assertThat(received).isEmpty();
    }

    private void subscribeToMirror(Consumer<TopicMessage> onNext) {
        SubscriptionHandle subscriptionHandle = topicMessageQuery.subscribe(client, onNext);
        Stopwatch stopwatch = Stopwatch.createStarted();

        while (!complete.get() && errors.isEmpty() && stopwatch.elapsed(TimeUnit.SECONDS) < 3) {
            Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
        }

        subscriptionHandle.unsubscribe();
    }

    static private ConsensusTopicQuery.Builder request() {
        return ConsensusTopicQuery.newBuilder()
            .setConsensusEndTime(toTimestamp(START_TIME.plusSeconds(100L)))
            .setConsensusStartTime(toTimestamp(START_TIME))
            .setTopicID(TopicID.newBuilder().setTopicNum(1000).build());
    }

    static private ConsensusTopicResponse response(long sequenceNumber) {
        return response(sequenceNumber, 0);
    }

    static private ConsensusTopicResponse response(long sequenceNumber, int total) {
        ConsensusTopicResponse.Builder consensusTopicResponseBuilder = ConsensusTopicResponse.newBuilder();

        if (total > 0) {
            var chunkInfo = ConsensusMessageChunkInfo.newBuilder()
                .setInitialTransactionID(TransactionID.newBuilder()
                    .setAccountID(AccountID.newBuilder().setAccountNum(3).build())
                    .setTransactionValidStart(toTimestamp(START_TIME))
                    .build())
                .setNumber((int) sequenceNumber)
                .setTotal(total)
                .build();
            consensusTopicResponseBuilder.setChunkInfo(chunkInfo);
        }

        var message = ByteString.copyFrom(Longs.toByteArray(sequenceNumber));
        return consensusTopicResponseBuilder
            .setConsensusTimestamp(toTimestamp(START_TIME.plusSeconds(sequenceNumber)))
            .setSequenceNumber(sequenceNumber)
            .setMessage(message)
            .setRunningHash(message)
            .setRunningHashVersion(2L)
            .build();
    }

    static private Instant toInstant(Timestamp timestamp) {
        return Instant.ofEpochSecond(timestamp.getSeconds(), timestamp.getNanos());
    }

    static private Timestamp toTimestamp(Instant instant) {
        return Timestamp.newBuilder()
            .setSeconds(instant.getEpochSecond())
            .setNanos(instant.getNano())
            .build();
    }

    private static class ConsensusServiceStub extends ConsensusServiceGrpc.ConsensusServiceImplBase {

        private final Queue<ConsensusTopicQuery> requests = new ArrayDeque<>();
        private final Queue<Object> responses = new ArrayDeque<>();

        @Override
        public void subscribeTopic(ConsensusTopicQuery consensusTopicQuery,
                                   StreamObserver<ConsensusTopicResponse> streamObserver) {
            var request = requests.poll();
            assertThat(request).isNotNull();
            assertThat(consensusTopicQuery).isEqualTo(request);

            while (!responses.isEmpty()) {
                var response = responses.poll();
                assertThat(response).isNotNull();

                if (response instanceof Throwable) {
                    streamObserver.onError((Throwable) response);
                    return;
                }

                streamObserver.onNext((ConsensusTopicResponse) response);
            }

            streamObserver.onCompleted();
        }

        public void verify() {
            assertThat(requests).isEmpty();
            assertThat(responses).isEmpty();
        }
    }

    private byte[] combine(byte[] array1, byte[] array2) {
        byte[] joinedArray = new byte[array1.length + array2.length];
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicMessageSubmitTransactionTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ConsensusSubmitMessageTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TopicMessageSubmitTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final TopicId testTopicId = new TopicId(0, 6, 9);
    private static final byte[] testMessageBytes = {0x04, 0x05, 0x06};
    private static final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private TopicMessageSubmitTransaction spawnTestTransactionString() {
        return new TopicMessageSubmitTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTopicId(testTopicId).setMessage(new String(testMessageBytes)).freeze().sign(unusedPrivateKey);
    }

    private TopicMessageSubmitTransaction spawnTestTransactionBytes() {
        return new TopicMessageSubmitTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTopicId(testTopicId).setMessage(testMessageBytes).freeze().sign(unusedPrivateKey);
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setConsensusSubmitMessage(ConsensusSubmitMessageTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TopicMessageSubmitTransaction.class);
    }


    @Test
    void constructTopicMessageSubmitTransactionFromTransactionBodyProtobuf() {
        var transactionBody = ConsensusSubmitMessageTransactionBody.newBuilder().setTopicID(testTopicId.toProtobuf())
            .setMessage(ByteString.copyFrom(testMessageBytes)).build();

        var tx = TransactionBody.newBuilder().setConsensusSubmitMessage(transactionBody).build();

        var topicSubmitMessageTransaction = new TopicMessageSubmitTransaction(tx);
        assertThat(topicSubmitMessageTransaction.getTopicId()).isEqualTo(testTopicId);
    }

    @Test
    void getSetTopicId() {
        var topicSubmitMessageTransaction = new TopicMessageSubmitTransaction().setTopicId(testTopicId);
        assertThat(topicSubmitMessageTransaction.getTopicId()).isEqualTo(testTopicId);
    }

    @Test
    void getSetTopicIdFrozen() {
        var tx = spawnTestTransactionString();
        assertThrows(IllegalStateException.class, () -> tx.setTopicId(testTopicId));
    }

    @Test
    void getSetMessage() {
        var topicSubmitMessageTransactionString = new TopicMessageSubmitTransaction().setMessage(
            new String(testMessageBytes));
        var topicSubmitMessageTransactionBytes = new TopicMessageSubmitTransaction().setMessage(testMessageBytes);
        assertThat(topicSubmitMessageTransactionString.getMessage().toByteArray()).isEqualTo(testMessageBytes);
        assertThat(topicSubmitMessageTransactionBytes.getMessage().toByteArray()).isEqualTo(testMessageBytes);
    }

    @Test
    void getSetMessageFrozen() {
        var topicSubmitMessageTransactionString = spawnTestTransactionString();
        var topicSubmitMessageTransactionBytes = spawnTestTransactionBytes();
        assertThrows(IllegalStateException.class,
            () -> topicSubmitMessageTransactionString.setMessage(testMessageBytes));
        assertThrows(IllegalStateException.class,
            () -> topicSubmitMessageTransactionBytes.setMessage(testMessageBytes));
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicMessageTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.proto.ConsensusMessageChunkInfo;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.mirror.ConsensusTopicResponse;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicMessageTest {

    private static final Instant testTimestamp = Instant.ofEpochSecond(1554158542);
    private static final byte[] testContents = new byte[]{0x01, 0x02, 0x03};
    private static final byte[] testRunningHash = new byte[]{0x04, 0x05, 0x06};
    private static final long testSequenceNumber = 7L;
    private static final TransactionId testTransactionId = new TransactionId(new AccountId(1), testTimestamp);

    @Test
    void constructWithArgs() {
        TopicMessageChunk topicMessageChunk = new TopicMessageChunk(ConsensusTopicResponse.newBuilder()
            .setConsensusTimestamp(Timestamp.newBuilder().setSeconds(testTimestamp.getEpochSecond()))
            .setRunningHash(ByteString.copyFrom(testRunningHash)).setSequenceNumber(testSequenceNumber).build());

        TopicMessageChunk[] topicMessageChunkArr = {topicMessageChunk, topicMessageChunk, topicMessageChunk};

        TopicMessage topicMessage = new TopicMessage(testTimestamp, testContents, testRunningHash, testSequenceNumber,
            topicMessageChunkArr, testTransactionId);

        assertThat(topicMessage.consensusTimestamp).isEqualTo(testTimestamp);
        assertThat(topicMessage.contents).isEqualTo(testContents);
        assertThat(topicMessage.runningHash).isEqualTo(testRunningHash);
        assertThat(topicMessage.sequenceNumber).isEqualTo(testSequenceNumber);
        assertThat(topicMessage.chunks).hasSize(3);
        assertThat(topicMessage.transactionId).isEqualTo(testTransactionId);
    }

    @Test
    void ofSingle() {
        var consensusTopicResponse = ConsensusTopicResponse.newBuilder()
            .setConsensusTimestamp(Timestamp.newBuilder().setSeconds(testTimestamp.getEpochSecond()))
            .setMessage(ByteString.copyFrom(testContents)).setRunningHash(ByteString.copyFrom(testRunningHash))
            .setSequenceNumber(testSequenceNumber).setChunkInfo(
                ConsensusMessageChunkInfo.newBuilder().setInitialTransactionID(testTransactionId.toProtobuf()).build())
            .build();

        TopicMessage topicMessage = TopicMessage.ofSingle(consensusTopicResponse);

        assertThat(topicMessage.consensusTimestamp).isEqualTo(testTimestamp);
        assertThat(topicMessage.contents).isEqualTo(testContents);
        assertThat(topicMessage.runningHash).isEqualTo(testRunningHash);
        assertThat(topicMessage.sequenceNumber).isEqualTo(testSequenceNumber);
        assertThat(topicMessage.chunks).hasSize(1);
        assertThat(topicMessage.transactionId).isEqualTo(testTransactionId);
    }

    @Test
    void ofMany() {
        var consensusTopicResponse1 = ConsensusTopicResponse.newBuilder()
            .setConsensusTimestamp(Timestamp.newBuilder().setSeconds(testTimestamp.getEpochSecond()))
            .setMessage(ByteString.copyFrom(testContents)).setRunningHash(ByteString.copyFrom(testRunningHash))
            .setSequenceNumber(testSequenceNumber).setChunkInfo(
                ConsensusMessageChunkInfo.newBuilder().setInitialTransactionID(testTransactionId.toProtobuf())
                    .setNumber(1).setTotal(2).build()).build();

        var consensusTopicResponse2 = ConsensusTopicResponse.newBuilder()
            .setConsensusTimestamp(Timestamp.newBuilder().setSeconds(testTimestamp.getEpochSecond() + 1))
            .setMessage(ByteString.copyFrom(testContents)).setRunningHash(ByteString.copyFrom(testRunningHash))
            .setSequenceNumber(testSequenceNumber + 1L)
            .setChunkInfo(ConsensusMessageChunkInfo.newBuilder().setNumber(2).setTotal(2).build()).build();

        TopicMessage topicMessage = TopicMessage.ofMany(List.of(consensusTopicResponse1, consensusTopicResponse2));

        byte[] totalContents = new byte[testContents.length * 2];
        System.arraycopy(testContents, 0, totalContents, 0, testContents.length);
        System.arraycopy(testContents, 0, totalContents, testContents.length, testContents.length);
        assertThat(topicMessage.consensusTimestamp).isEqualTo(testTimestamp.plusSeconds(1));
        assertThat(topicMessage.contents).isEqualTo(totalContents);
        assertThat(topicMessage.runningHash).isEqualTo(testRunningHash);
        assertThat(topicMessage.sequenceNumber).isEqualTo(testSequenceNumber + 1L);
        assertThat(topicMessage.chunks).hasSize(2);
        assertThat(topicMessage.transactionId).isEqualTo(testTransactionId);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TopicUpdateTransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.StringValue;
import com.hedera.hashgraph.sdk.proto.ConsensusUpdateTopicTransactionBody;
import com.hedera.hashgraph.sdk.proto.CryptoDeleteTransactionBody;
import com.hedera.hashgraph.sdk.proto.SchedulableTransactionBody;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class TopicUpdateTransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final PublicKey testAdminKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e11")
        .getPublicKey();
    private static final PublicKey testSubmitKey = PrivateKey.fromString(
            "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e12")
        .getPublicKey();
    private static final TopicId testTopicId = TopicId.fromString("0.0.5007");
    private static final String testTopicMemo = "test memo";
    private static final Duration testAutoRenewPeriod = Duration.ofHours(10);
    private static final Instant testExpirationTime = Instant.now();
    private static final AccountId testAutoRenewAccountId = AccountId.fromString("8.8.8");
    private static final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void clearShouldSerialize() {
        SnapshotMatcher.expect(new TopicUpdateTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTopicId(testTopicId).clearAdminKey().clearAutoRenewAccountId().clearSubmitKey().clearTopicMemo()
            .freeze().sign(unusedPrivateKey).toString()).toMatchSnapshot();
    }

    @Test
    void setShouldSerialize() {
        SnapshotMatcher.expect(spawnTestTransaction().toString()).toMatchSnapshot();
    }

    private TopicUpdateTransaction spawnTestTransaction() {
        return new TopicUpdateTransaction().setNodeAccountIds(
                Arrays.asList(AccountId.fromString("0.0.5005"), AccountId.fromString("0.0.5006")))
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5006"), validStart))
            .setTopicId(testTopicId).setAdminKey(testAdminKey).setAutoRenewAccountId(testAutoRenewAccountId)
            .setAutoRenewPeriod(testAutoRenewPeriod).setSubmitKey(testSubmitKey).setTopicMemo(testTopicMemo)
            .setExpirationTime(validStart).freeze().sign(unusedPrivateKey);
    }

    @Test
    void shouldBytes() throws Exception {
        var tx = spawnTestTransaction();
        var tx2 = TopicUpdateTransaction.fromBytes(tx.toBytes());
        assertThat(tx2.toString()).isEqualTo(tx.toString());
    }

    @Test
    void fromScheduledTransaction() {
        var transactionBody = SchedulableTransactionBody.newBuilder()
            .setConsensusUpdateTopic(ConsensusUpdateTopicTransactionBody.newBuilder().build()).build();

        var tx = Transaction.fromScheduledTransaction(transactionBody);

        assertThat(tx).isInstanceOf(TopicUpdateTransaction.class);
    }

    @Test
    void constructTopicUpdateTransactionFromTransactionBodyProtobuf() {
        var transactionBody = ConsensusUpdateTopicTransactionBody.newBuilder().setTopicID(testTopicId.toProtobuf())
            .setMemo(StringValue.newBuilder().setValue(testTopicMemo).build())
            .setExpirationTime(Timestamp.newBuilder().setSeconds(testExpirationTime.getEpochSecond()).build())
            .setAdminKey(testAdminKey.toProtobufKey()).setSubmitKey(testSubmitKey.toProtobufKey()).setAutoRenewPeriod(
                com.hedera.hashgraph.sdk.proto.Duration.newBuilder().setSeconds(testAutoRenewPeriod.toSeconds())
                    .build()).setAutoRenewAccount(testAutoRenewAccountId.toProtobuf()).build();

        var tx = TransactionBody.newBuilder().setConsensusUpdateTopic(transactionBody).build();
        var topicUpdateTransaction = new TopicUpdateTransaction(tx);

        assertThat(topicUpdateTransaction.getTopicId()).isEqualTo(testTopicId);
        assertThat(topicUpdateTransaction.getTopicMemo()).isEqualTo(testTopicMemo);
        assertThat(topicUpdateTransaction.getExpirationTime().getEpochSecond()).isEqualTo(
            testExpirationTime.getEpochSecond());
        assertThat(topicUpdateTransaction.getAdminKey()).isEqualTo(testAdminKey);
        assertThat(topicUpdateTransaction.getSubmitKey()).isEqualTo(testSubmitKey);
        assertThat(topicUpdateTransaction.getAutoRenewPeriod().toSeconds()).isEqualTo(testAutoRenewPeriod.toSeconds());
        assertThat(topicUpdateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
    }

    // doesn't throw an exception as opposed to C++ sdk
    @Test
    void constructTopicUpdateTransactionFromWrongTransactionBodyProtobuf() {
        var transactionBody = CryptoDeleteTransactionBody.newBuilder().build();
        var tx = TransactionBody.newBuilder().setCryptoDelete(transactionBody).build();

        new TopicUpdateTransaction(tx);
    }

    @Test
    void getSetTopicId() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setTopicId(testTopicId);
        assertThat(topicUpdateTransaction.getTopicId()).isEqualTo(testTopicId);
    }

    @Test
    void getSetTopicIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTopicId(testTopicId));
    }

    @Test
    void getSetTopicMemo() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setTopicMemo(testTopicMemo);
        assertThat(topicUpdateTransaction.getTopicMemo()).isEqualTo(testTopicMemo);
    }

    @Test
    void getSetTopicMemoFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setTopicMemo(testTopicMemo));
    }

    @Test
    void clearTopicMemo() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setTopicMemo(testTopicMemo);
        topicUpdateTransaction.clearTopicMemo();
        assertThat(topicUpdateTransaction.getTopicMemo()).isEmpty();
    }

    @Test
    void clearTopicMemoFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.clearTopicMemo());
    }

    @Test
    void getSetExpirationTime() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setExpirationTime(testExpirationTime);
        assertThat(topicUpdateTransaction.getExpirationTime()).isEqualTo(testExpirationTime);
    }

    @Test
    void getSetExpirationTimeFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setExpirationTime(testExpirationTime));
    }

    @Test
    void getSetAdminKey() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setAdminKey(testAdminKey);
        assertThat(topicUpdateTransaction.getAdminKey()).isEqualTo(testAdminKey);
    }

    @Test
    void getSetAdminKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAdminKey(testAdminKey));
    }

    @Test
    void clearAdminKey() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setAdminKey(testAdminKey);
        topicUpdateTransaction.clearAdminKey();
        assertThat(topicUpdateTransaction.getAdminKey()).isEqualTo(new KeyList());
    }

    @Test
    void clearAdminKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.clearAdminKey());
    }

    @Test
    void getSetSubmitKey() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setSubmitKey(testSubmitKey);
        assertThat(topicUpdateTransaction.getSubmitKey()).isEqualTo(testSubmitKey);
    }

    @Test
    void getSetSubmitKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setSubmitKey(testSubmitKey));
    }

    @Test
    void clearSubmitKey() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setSubmitKey(testSubmitKey);
        topicUpdateTransaction.clearSubmitKey();
        assertThat(topicUpdateTransaction.getSubmitKey()).isEqualTo(new KeyList());
    }

    @Test
    void clearSubmitKeyFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.clearSubmitKey());
    }

    @Test
    void getSetAutoRenewPeriod() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setAutoRenewPeriod(testAutoRenewPeriod);
        assertThat(topicUpdateTransaction.getAutoRenewPeriod()).isEqualTo(testAutoRenewPeriod);
    }

    @Test
    void getSetAutoRenewPeriodFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAutoRenewPeriod(testAutoRenewPeriod));
    }

    @Test
    void getSetAutoRenewAccountId() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setAutoRenewAccountId(testAutoRenewAccountId);
        assertThat(topicUpdateTransaction.getAutoRenewAccountId()).isEqualTo(testAutoRenewAccountId);
    }

    @Test
    void getSetAutoRenewAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.setAutoRenewAccountId(testAutoRenewAccountId));
    }

    @Test
    void clearAutoRenewAccountId() {
        var topicUpdateTransaction = new TopicUpdateTransaction().setAutoRenewAccountId(testAutoRenewAccountId);
        topicUpdateTransaction.clearAutoRenewAccountId();
        assertThat(topicUpdateTransaction.getAutoRenewAccountId()).isEqualTo(new AccountId(0));
    }

    @Test
    void clearAutoRenewAccountIdFrozen() {
        var tx = spawnTestTransaction();
        assertThrows(IllegalStateException.class, () -> tx.clearAutoRenewAccountId());
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TransactionIdTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TransactionIdTest {
    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        SnapshotMatcher.expect(TransactionId.fromString("0.0.23847@1588539964.632521325").toString()).toMatchSnapshot();
    }

    @Test
    void shouldSerialize2() {
        SnapshotMatcher.expect(TransactionId.fromString("0.0.23847@1588539964.632521325?scheduled/3").toString()).toMatchSnapshot();
    }

    @Test
    void shouldToBytes() {
        var originalId = TransactionId.fromString("0.0.23847@1588539964.632521325");
        var copyId = TransactionId.fromProtobuf(originalId.toProtobuf());
        assertThat(copyId).hasToString(originalId.toString());
    }

    @Test
    void shouldToBytes2() {
        var originalId = TransactionId.fromString("0.0.23847@1588539964.632521325?scheduled/2");
        var copyId = TransactionId.fromProtobuf(originalId.toProtobuf());
        assertThat(copyId).hasToString(originalId.toString());
    }

    @Test
    void shouldFromBytes() throws InvalidProtocolBufferException {
        var originalId = TransactionId.fromString("0.0.23847@1588539964.632521325");
        var copyId = TransactionId.fromBytes(originalId.toProtobuf().toByteArray());
        assertThat(copyId).hasToString(originalId.toString());
    }

    @Test
    void shouldParse() {
        var transactionId = TransactionId.fromString("0.0.23847@1588539964.632521325");
        var accountId = Objects.requireNonNull(transactionId.accountId);
        var validStart = Objects.requireNonNull(transactionId.validStart);
        assertThat(accountId.shard).isEqualTo(0);
        assertThat(accountId.num).isEqualTo(23847);
        assertThat(validStart.getEpochSecond()).isEqualTo(1588539964);
        assertThat(validStart.getNano()).isEqualTo(632521325);
    }

    @Test
    void shouldParseScheduled() {
        var transactionId = TransactionId.fromString("0.0.23847@1588539964.632521325?scheduled");
        var accountId = Objects.requireNonNull(transactionId.accountId);
        var validStart = Objects.requireNonNull(transactionId.validStart);
        assertThat(accountId.shard).isEqualTo(0);
        assertThat(accountId.num).isEqualTo(23847);
        assertThat(validStart.getEpochSecond()).isEqualTo(1588539964);
        assertThat(validStart.getNano()).isEqualTo(632521325);
        assertThat(transactionId.getScheduled()).isTrue();
        assertThat(transactionId.getNonce()).isNull();

        assertThat(transactionId.toString()).isEqualTo("0.0.23847@1588539964.632521325?scheduled");
    }

    @Test
    void shouldParseNonce() {
        var transactionId = TransactionId.fromString("0.0.23847@1588539964.632521325/4");
        var accountId = Objects.requireNonNull(transactionId.accountId);
        var validStart = Objects.requireNonNull(transactionId.validStart);
        assertThat(accountId.shard).isEqualTo(0);
        assertThat(accountId.num).isEqualTo(23847);
        assertThat(validStart.getEpochSecond()).isEqualTo(1588539964);
        assertThat(validStart.getNano()).isEqualTo(632521325);
        assertThat(transactionId.getScheduled()).isFalse();
        assertThat(transactionId.getNonce()).isEqualTo(4);

        assertThat(transactionId.toString()).isEqualTo("0.0.23847@1588539964.632521325/4");
    }

    @Test
    void compare() {
        // Compare when only one of the txs is schedules
        var transactionId1 = TransactionId.fromString("0.0.23847@1588539964.632521325");
        var transactionId2 = TransactionId.fromString("0.0.23847@1588539964.632521325?scheduled");
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(-1);

        transactionId1 = TransactionId.fromString("0.0.23847@1588539964.632521325?scheduled");
        transactionId2 = TransactionId.fromString("0.0.23847@1588539964.632521325");
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(1);

        // Compare when only one of the txs has accountId
        transactionId1 = new TransactionId(null, Instant.ofEpochSecond(1588539964));
        transactionId2 = new TransactionId(AccountId.fromString("0.0.23847"), Instant.ofEpochSecond(1588539964));
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(-1);

        transactionId1 = new TransactionId(AccountId.fromString("0.0.23847"), Instant.ofEpochSecond(1588539964));
        transactionId2 = new TransactionId(null, Instant.ofEpochSecond(1588539964));
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(1);

        // Compare the AccountIds
        transactionId1 = TransactionId.fromString("0.0.23847@1588539964.632521325");
        transactionId2 = TransactionId.fromString("0.0.23847@1588539964.632521325");
        assertThat(transactionId1).isEqualByComparingTo(transactionId2);

        transactionId1 = TransactionId.fromString("0.0.23848@1588539964.632521325");
        transactionId2 = TransactionId.fromString("0.0.23847@1588539964.632521325");
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(1);

        transactionId1 = TransactionId.fromString("0.0.23847@1588539964.632521325");
        transactionId2 = TransactionId.fromString("0.0.23848@1588539964.632521325");
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(-1);

        // Compare when only one of the txs has valid start
        transactionId1 = new TransactionId(null, null);
        transactionId2 = new TransactionId(null, Instant.ofEpochSecond(1588539964));
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(-1);

        transactionId1 = new TransactionId(AccountId.fromString("0.0.23847"), Instant.ofEpochSecond(1588539964));
        transactionId2 = new TransactionId(null, null);
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(1);

        // Compare the validStarts
        transactionId1 = new TransactionId(null, Instant.ofEpochSecond(1588539965));
        transactionId2 = new TransactionId(null, Instant.ofEpochSecond(1588539964));
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(1);

        transactionId1 = new TransactionId(null, Instant.ofEpochSecond(1588539964));
        transactionId2 = new TransactionId(null, Instant.ofEpochSecond(1588539965));
        assertThat(transactionId1.compareTo(transactionId2)).isEqualTo(-1);


        transactionId1 = new TransactionId(null, null);
        transactionId2 = new TransactionId(null, null);
        assertThat(transactionId1).isEqualByComparingTo(transactionId2);
    }

    @Test
    void shouldFail() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> TransactionId.fromString("0.0.23847.1588539964.632521325/4")
        );

        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(
            () -> TransactionId.fromString("0.0.23847@1588539964/4")
        );
    }

    @Test
    void shouldAddTrailingZeroesToNanoseconds() {
        var txIdString = "0.0.4163533@1681876267.054802581";
        var txId = TransactionId.fromString(txIdString);
        assertThat(txId).hasToString(txIdString);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TransactionReceiptQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;

public class TransactionReceiptQueryTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        new TransactionReceiptQuery()
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5005"), validStart))
            .onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TransactionReceiptTest.java
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;


public class TransactionReceiptTest {
    final static Instant time = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    static TransactionReceipt spawnReceiptExample() {
        return new TransactionReceipt(
            null,
            Status.SCHEDULE_ALREADY_DELETED,
            new ExchangeRate(3, 4, time),
            AccountId.fromString("1.2.3"),
            FileId.fromString("4.5.6"),
            ContractId.fromString("3.2.1"),
            TopicId.fromString("9.8.7"),
            TokenId.fromString("6.5.4"),
            3L,
            ByteString.copyFrom("how now brown cow", StandardCharsets.UTF_8),
            30L,
            ScheduleId.fromString("1.1.1"),
            TransactionId.withValidStart(AccountId.fromString("3.3.3"), time),
            List.of(1L, 2L, 3L),
            1,
            new ArrayList<>(),
            new ArrayList<>()
        );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalTransactionReceipt = spawnReceiptExample();
        byte[] transactionReceiptBytes = originalTransactionReceipt.toBytes();
        var copyTransactionReceipt = TransactionReceipt.fromBytes(transactionReceiptBytes);
        assertThat(copyTransactionReceipt.toString()).isEqualTo(originalTransactionReceipt.toString());
        SnapshotMatcher.expect(originalTransactionReceipt.toString()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TransactionRecordQueryTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.hedera.hashgraph.sdk.proto.QueryHeader;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.time.Instant;

public class TransactionRecordQueryTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");

    final Instant validStart = Instant.ofEpochSecond(1554158542);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    @Test
    void shouldSerialize() {
        var builder = com.hedera.hashgraph.sdk.proto.Query.newBuilder();
        spawnQuery().onMakeRequest(builder, QueryHeader.newBuilder().build());
        SnapshotMatcher.expect(builder.build().toString().replaceAll("@[A-Za-z0-9]+", "")).toMatchSnapshot();
    }

    private TransactionRecordQuery spawnQuery() {
        return new TransactionRecordQuery()
            .setTransactionId(TransactionId.withValidStart(AccountId.fromString("0.0.5005"), validStart))
            .setIncludeChildren(true)
            .setIncludeDuplicates(true);
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TransactionRecordTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.ByteString;
import com.google.protobuf.BytesValue;
import io.github.jsonSnapshot.SnapshotMatcher;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import javax.annotation.Nullable;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static com.hedera.hashgraph.sdk.ContractFunctionResultTest.CALL_RESULT_HEX;
import static com.hedera.hashgraph.sdk.TransactionReceiptTest.spawnReceiptExample;
import static org.assertj.core.api.Assertions.assertThat;

public class TransactionRecordTest {
    final static Instant time = Instant.ofEpochSecond(1554158542);
    private static final byte[] callResult = Hex.decode(CALL_RESULT_HEX);

    @BeforeAll
    public static void beforeAll() {
        SnapshotMatcher.start();
    }

    @AfterAll
    public static void afterAll() {
        SnapshotMatcher.validateSnapshots();
    }

    private static TransactionRecord spawnRecordExample(@Nullable ByteString prngBytes, @Nullable Integer prngNumber) {
        return new TransactionRecord(
            spawnReceiptExample(),
            ByteString.copyFrom("hello", StandardCharsets.UTF_8),
            time,
            TransactionId.withValidStart(AccountId.fromString("3.3.3"), time),
            "memo",
            3000L,
            new ContractFunctionResult(
                com.hedera.hashgraph.sdk.proto.ContractFunctionResult.newBuilder()
                    .setContractID(ContractId.fromString("1.2.3").toProtobuf())
                    .setContractCallResult(ByteString.copyFrom(callResult))
                    .setEvmAddress(BytesValue.newBuilder().setValue(ByteString.copyFrom(Hex.decode("98329e006610472e6B372C080833f6D79ED833cf"))).build())
                    .setSenderId(AccountId.fromString("1.2.3").toProtobuf())
            ),
            List.of(new Transfer(AccountId.fromString("4.4.4"), Hbar.from(5))),
            Map.of(TokenId.fromString("6.6.6"), Map.of(AccountId.fromString("1.1.1"), 4L)),
            List.of(new TokenTransfer(TokenId.fromString("8.9.10"), AccountId.fromString("1.2.3"), 4L, 3, true)),
            Map.of(TokenId.fromString("4.4.4"), List.of(new TokenNftTransfer(TokenId.fromString("4.4.4"), AccountId.fromString("1.2.3"), AccountId.fromString("3.2.1"), 4L, true))),
            ScheduleId.fromString("3.3.3"),
            List.of(new AssessedCustomFee(4L, TokenId.fromString("4.5.6"), AccountId.fromString("8.6.5"), List.of(AccountId.fromString("3.3.3")))),
            List.of(new TokenAssociation(TokenId.fromString("5.4.3"), AccountId.fromString("8.7.6"))),
            PrivateKey.fromStringECDSA("8776c6b831a1b61ac10dac0304a2843de4716f54b1919bb91a2685d0fe3f3048").getPublicKey(),
            new ArrayList<>(),
            new ArrayList<>(),
            time,
            ByteString.copyFrom("Some hash", StandardCharsets.UTF_8),
            List.of(new Transfer(AccountId.fromString("1.2.3"), Hbar.from(8))),
            prngBytes,
            prngNumber,
            ByteString.copyFrom("0x00", StandardCharsets.UTF_8),
            List.of(
                new PendingAirdropRecord(new PendingAirdropId(AccountId.fromString("0.0.123"), AccountId.fromString("0.0.124"), NftId.fromString("0.0.5005/1234")), 123),
                new PendingAirdropRecord(new PendingAirdropId(AccountId.fromString("0.0.123"), AccountId.fromString("0.0.124"), TokenId.fromString("0.0.12345")), 123)
                )
        );
    }

    @Test
    void shouldSerialize() throws Exception {
        var originalRecord = spawnRecordExample(
            ByteString.copyFrom("very random bytes", StandardCharsets.UTF_8),
            null
        );
        byte[] recordBytes = originalRecord.toBytes();
        var copyRecord = TransactionRecord.fromBytes(recordBytes);
        assertThat(copyRecord.toString()).isEqualTo(originalRecord.toString());
        SnapshotMatcher.expect(originalRecord.toString()).toMatchSnapshot();
    }

    @Test
    void shouldSerialize2() throws Exception {
        var originalRecord = spawnRecordExample(
            null,
            4 /* chosen by fair dice roll.  Guaranteed to be random */
        );
        byte[] recordBytes = originalRecord.toBytes();
        var copyRecord = TransactionRecord.fromBytes(recordBytes);
        assertThat(copyRecord.toString()).isEqualTo(originalRecord.toString());
        SnapshotMatcher.expect(originalRecord.toString()).toMatchSnapshot();
    }
}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/TransactionTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.TokenAssociateTransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;

import static com.hedera.hashgraph.sdk.Transaction.fromBytes;
import static org.assertj.core.api.Assertions.assertThat;


public class TransactionTest {
    private static final PrivateKey unusedPrivateKey = PrivateKey.fromString(
        "302e020100300506032b657004220420db484b828e64b2d8f12ce3c0a0e93a0b8cce7af1bb8f39c97732394482538e10");
    private static final List<AccountId> testNodeAccountIds = Arrays.asList(AccountId.fromString("0.0.5005"),
        AccountId.fromString("0.0.5006"));
    private static final AccountId testAccountId = AccountId.fromString("0.0.5006");
    private static final Instant validStart = Instant.ofEpochSecond(1554158542);

    @Test
    void transactionFromBytesWorksWithProtobufTransactionBytes() throws InvalidProtocolBufferException {
        var bytes = Hex.decode(
            "1acc010a640a2046fe5013b6f6fc796c3e65ec10d2a10d03c07188fc3de13d46caad6b8ec4dfb81a4045f1186be5746c9783f68cb71d6a71becd3ffb024906b855ac1fa3a2601273d41b58446e5d6a0aaf421c229885f9e70417353fab2ce6e9d8e7b162e9944e19020a640a20f102e75ff7dc3d72c9b7075bb246fcc54e714c59714814011e8f4b922d2a6f0a1a40f2e5f061349ab03fa21075020c75cf876d80498ae4bac767f35941b8e3c393b0e0a886ede328e44c1df7028ea1474722f2dcd493812d04db339480909076a10122500a180a0c08a1cc98830610c092d09e0312080800100018e4881d120608001000180418b293072202087872240a220a0f0a080800100018e4881d10ff83af5f0a0f0a080800100018eb881d108084af5f");

        var transaction = (TransferTransaction) fromBytes(bytes);

        assertThat(transaction.getHbarTransfers()).containsEntry(new AccountId(476260), new Hbar(1).negated());
        assertThat(transaction.getHbarTransfers()).containsEntry(new AccountId(476267), new Hbar(1));
    }

    @Test
    void tokenAssociateTransactionFromTransactionBodyBytes() throws InvalidProtocolBufferException {
        var tokenAssociateTransactionBodyProto = TokenAssociateTransactionBody.newBuilder().build();
        var transactionBodyProto = TransactionBody.newBuilder().setTokenAssociate(tokenAssociateTransactionBodyProto)
            .build();

        TokenAssociateTransaction tokenAssociateTransaction = spawnTestTransaction(transactionBodyProto);

        var tokenAssociateTransactionFromBytes = Transaction.fromBytes(tokenAssociateTransaction.toBytes());

        assertThat(tokenAssociateTransactionFromBytes).isInstanceOf(TokenAssociateTransaction.class);
    }

    @Test
    void tokenAssociateTransactionFromSignedTransactionBytes() throws InvalidProtocolBufferException {
        var tokenAssociateTransactionBodyProto = TokenAssociateTransactionBody.newBuilder().build();
        var transactionBodyProto = TransactionBody.newBuilder().setTokenAssociate(tokenAssociateTransactionBodyProto)
            .build();

        var signedTransactionProto = SignedTransaction.newBuilder().setBodyBytes(transactionBodyProto.toByteString())
            .build();
        var signedTransactionBodyProto = TransactionBody.parseFrom(signedTransactionProto.getBodyBytes());

        TokenAssociateTransaction tokenAssociateTransaction = spawnTestTransaction(signedTransactionBodyProto);

        var tokenAssociateTransactionFromBytes = Transaction.fromBytes(tokenAssociateTransaction.toBytes());

        assertThat(tokenAssociateTransactionFromBytes).isInstanceOf(TokenAssociateTransaction.class);
    }

    @Test
    void tokenAssociateTransactionFromTransactionBytes() throws InvalidProtocolBufferException {
        var tokenAssociateTransactionBodyProto = TokenAssociateTransactionBody.newBuilder().build();
        var transactionBodyProto = TransactionBody.newBuilder().setTokenAssociate(tokenAssociateTransactionBodyProto)
            .build();

        var signedTransactionProto = SignedTransaction.newBuilder().setBodyBytes(transactionBodyProto.toByteString())
            .build();
        var signedTransactionBodyProto = TransactionBody.parseFrom(signedTransactionProto.getBodyBytes());

        var transactionSignedProto = com.hedera.hashgraph.sdk.proto.Transaction.newBuilder()
            .setSignedTransactionBytes(signedTransactionBodyProto.toByteString()).build();
        var transactionSignedBodyProto = TransactionBody.parseFrom(transactionSignedProto.getSignedTransactionBytes());

        TokenAssociateTransaction tokenAssociateTransaction = spawnTestTransaction(transactionSignedBodyProto);

        var tokenAssociateTransactionFromBytes = Transaction.fromBytes(tokenAssociateTransaction.toBytes());

        assertThat(tokenAssociateTransactionFromBytes).isInstanceOf(TokenAssociateTransaction.class);
    }

    private TokenAssociateTransaction spawnTestTransaction(TransactionBody txBody) {
        return new TokenAssociateTransaction(
            txBody).setNodeAccountIds(testNodeAccountIds)
            .setTransactionId(TransactionId.withValidStart(testAccountId, validStart)).freeze().sign(unusedPrivateKey);
    }

}
// Filename: sdk/src/test/java/com/hedera/hashgraph/sdk/logger/LoggerTest.java
package com.hedera.hashgraph.sdk.logger;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

class LoggerTest {

    private Logger logger;

    private org.slf4j.Logger internalLogger;

    @BeforeEach
    void setup() {
        internalLogger = mock(org.slf4j.Logger.class);
        logger = new Logger(LogLevel.TRACE);
        logger.setLogger(internalLogger);
    }

    @Test
    void logsTrace() {
        logger.trace("log");
        verify(internalLogger, times(1)).trace(any(), any(Object[].class));
    }

    @Test
    void doesNotLogTraceIfNotEnabled() {
        logger.setLevel(LogLevel.ERROR);
        logger.trace("log");
        verify(internalLogger, times(0)).trace(any(), any(Object[].class));
    }

    @Test
    void logsDebug() {
        logger.debug("log");
        verify(internalLogger, times(1)).debug(any(), any(Object[].class));
    }

    @Test
    void doesNotLogDebugIfNotEnabled() {
        logger.setLevel(LogLevel.ERROR);
        logger.debug("log");
        verify(internalLogger, times(0)).debug(any(), any(Object[].class));
    }

    @Test
    void logsInfo() {
        logger.info("log");
        verify(internalLogger, times(1)).info(any(), any(Object[].class));
    }

    @Test
    void doesNotLogInfoIfNotEnabled() {
        logger.setLevel(LogLevel.ERROR);
        logger.info("log");
        verify(internalLogger, times(0)).info(any(), any(Object[].class));
    }

    @Test
    void logsWarn() {
        logger.warn("log");
        verify(internalLogger, times(1)).warn(any(), any(Object[].class));
    }

    @Test
    void doesNotLogWarnIfNotEnabled() {
        logger.setLevel(LogLevel.ERROR);
        logger.warn("log");
        verify(internalLogger, times(0)).warn(any(), any(Object[].class));
    }

    @Test
    void logsError() {
        logger.error("log");
        verify(internalLogger, times(1)).error(any(), any(Object[].class));
    }

    @Test
    void doesNotLogErrorIfSilent() {
        logger.setSilent(true);
        logger.error("log");
        verify(internalLogger, times(0)).error(any(), any(Object[].class));
    }

    @Test
    void logsWhenUnsilenced() {
        logger.setSilent(true);
        logger.error("log");
        logger.setSilent(false);
        logger.warn("log");
        verify(internalLogger, times(0)).error(any(), any(Object[].class));
        verify(internalLogger, times(1)).warn(any(), any(Object[].class));
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountAllowanceIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountAllowanceApproveTransaction;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

public class AccountAllowanceIntegrationTest {
    @Test
    @DisplayName("Can spend hbar allowance")
    void canSpendHbarAllowance() throws Throwable {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var aliceKey = PrivateKey.generateED25519();
            var aliceId = new AccountCreateTransaction()
                .setKey(aliceKey)
                .setInitialBalance(new Hbar(10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var bobKey = PrivateKey.generateED25519();
            var bobId = new AccountCreateTransaction()
                .setKey(bobKey)
                .setInitialBalance(new Hbar(10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            Objects.requireNonNull(aliceId);
            Objects.requireNonNull(bobId);

            new AccountAllowanceApproveTransaction()
                .approveHbarAllowance(bobId, aliceId, new Hbar(10))
                .freezeWith(testEnv.client)
                .sign(bobKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var transferRecord = new TransferTransaction()
                .addHbarTransfer(testEnv.operatorId, new Hbar(5))
                .addApprovedHbarTransfer(bobId, new Hbar(5).negated())
                .setTransactionId(TransactionId.generate(aliceId))
                .freezeWith(testEnv.client)
                .sign(aliceKey)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            var transferFound = false;
            for (var transfer : transferRecord.transfers) {
                if (transfer.accountId.equals(testEnv.operatorId) && transfer.amount.equals(new Hbar(5))) {
                    transferFound = true;
                    break;
                }
            }
            assertThat(transferFound).isTrue();

            new AccountDeleteTransaction()
                .setAccountId(bobId)
                .setTransferAccountId(testEnv.operatorId)
                .freezeWith(testEnv.client)
                .sign(bobKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountBalanceIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountBalanceIntegrationTest {
    @Test
    @DisplayName("can connect to previewnwet with TLS")
    void canConnectToPreviewnetWithTLS() throws Exception {
        var client = Client.forPreviewnet()
            .setTransportSecurity(true);

        boolean succeededAtLeastOnce = false;

        for (var entry : client.getNetwork().entrySet()) {
            assertThat(entry.getKey().endsWith(":50212")).isTrue();

            try {
                new AccountBalanceQuery()
                    .setMaxAttempts(1)
                    .setNodeAccountIds(Collections.singletonList(entry.getValue()))
                    .setAccountId(entry.getValue())
                    .execute(client);
                System.out.println("succeeded for " + entry);
                succeededAtLeastOnce = true;
            } catch (Throwable error) {
                System.out.println("failed for " + entry);
            }
        }

        client.close();
        assertThat(succeededAtLeastOnce).isTrue();
    }

    @Test
    @DisplayName("can connect to testnet with TLS")
    void canConnectToTestnetWithTLS() throws Exception {
        var client = Client.forTestnet()
            .setTransportSecurity(true);

        boolean succeededAtLeastOnce = false;

        for (var entry : client.getNetwork().entrySet()) {
            assertThat(entry.getKey().endsWith(":50212")).isTrue();

            try {
                new AccountBalanceQuery()
                    .setMaxAttempts(1)
                    .setNodeAccountIds(Collections.singletonList(entry.getValue()))
                    .setAccountId(entry.getValue())
                    .execute(client);
                System.out.println("succeeded for " + entry);
                succeededAtLeastOnce = true;
            } catch (Throwable error) {
                System.out.println("failed for " + entry);
            }
        }

        client.close();
        assertThat(succeededAtLeastOnce).isTrue();
    }

    @Test
    @DisplayName("can connect to mainnet with TLS")
    void canConnectToMainnetWithTLS() throws Exception {
        var client = Client.forMainnet()
            .setTransportSecurity(true);

        boolean succeededAtLeastOnce = false;

        for (var entry : client.getNetwork().entrySet()) {
            assertThat(entry.getKey().endsWith(":50212")).isTrue();

            try {
                new AccountBalanceQuery()
                    .setMaxAttempts(1)
                    .setNodeAccountIds(Collections.singletonList(entry.getValue()))
                    .setAccountId(entry.getValue())
                    .execute(client);
                System.out.println("succeeded for " + entry);
                succeededAtLeastOnce = true;
            } catch (Throwable error) {
                System.out.println("failed for " + entry);
                System.out.println(error);
            }
        }

        client.close();
        assertThat(succeededAtLeastOnce).isTrue();
    }

    @Test
    @DisplayName("can connect to previewnet with certificate verification off")
    void cannotConnectToPreviewnetWhenNetworkNameIsNullAndCertificateVerificationIsEnabled() throws Exception {
        var client = Client.forPreviewnet()
            .setTransportSecurity(true)
            .setVerifyCertificates(true)
            .setNetworkName(null);

        assertThat(client.getNetwork().isEmpty()).isFalse();

        for (var entry : client.getNetwork().entrySet()) {
            assertThat(entry.getKey().endsWith(":50212")).isTrue();

            assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> {
                new AccountBalanceQuery()
                    .setNodeAccountIds(Collections.singletonList(entry.getValue()))
                    .setAccountId(entry.getValue())
                    .execute(client);
            });
        }

        client.close();
    }

    @Test
    @DisplayName("Can fetch balance for client operator")
    void canFetchBalanceForClientOperator() throws Exception {
        try (IntegrationTestEnv testEnv = new IntegrationTestEnv(1)) {

            var balance = new AccountBalanceQuery()
            .setAccountId(testEnv.operatorId)
            .execute(testEnv.client);

            assertThat(balance.hbars.toTinybars() > 0).isTrue();

        }
    }

    @Test
    @DisplayName("Can fetch cost for the query")
    void getCostBalanceForClientOperator() throws Exception {
        try (IntegrationTestEnv testEnv = new IntegrationTestEnv(1)) {

            var balance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(new Hbar(1));

            var cost = balance.getCost(testEnv.client);

            var accBalance = balance.setQueryPayment(cost).execute(testEnv.client);

            assertThat(accBalance.hbars.toTinybars() > 0).isTrue();
            assertThat(cost.toTinybars()).isEqualTo(0);

        }
    }

    @Test
    @DisplayName("Can fetch cost for the query, big max set")
    void getCostBigMaxBalanceForClientOperator() throws Exception {
        try (IntegrationTestEnv testEnv = new IntegrationTestEnv(1)) {

            var balance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(new Hbar(1000000));

            var cost = balance.getCost(testEnv.client);

            var accBalance = balance.setQueryPayment(cost).execute(testEnv.client);

            assertThat(accBalance.hbars.toTinybars() > 0).isTrue();

        }
    }

    @Test
    @DisplayName("Can fetch cost for the query, very small max set")
    void getCostSmallMaxBalanceForClientOperator() throws Exception {
        try (IntegrationTestEnv testEnv = new IntegrationTestEnv(1)) {

            var balance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            var cost = balance.getCost(testEnv.client);

            var accBalance = balance.setQueryPayment(cost).execute(testEnv.client);

            assertThat(accBalance.hbars.toTinybars() > 0).isTrue();

        }
    }

    @Test
    @DisplayName("Cannot fetch balance for invalid account ID")
    void canNotFetchBalanceForInvalidAccountId() throws Exception {
        try (IntegrationTestEnv testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new AccountBalanceQuery()
                    .setAccountId(AccountId.fromString("1.0.3"))
                    .execute(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Can fetch token balances for client operator")
    void canFetchTokenBalancesForClientOperator() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setInitialSupply(10000)
                .setDecimals(50)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var query = new AccountBalanceQuery();
            var balance = query
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(balance.tokens.get(tokenId)).isEqualTo(10000);
            assertThat(balance.tokenDecimals.get(tokenId)).isEqualTo(50);
            assertThat(query.toString()).isNotEmpty();
            assertThat(query.getPaymentTransactionId()).isNull();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountCreateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;
import java.time.Instant;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountCreateIntegrationTest {
    @Test
    @DisplayName("Can create account with only initial balance and key")
    void canCreateAccountWithOnlyInitialBalanceAndKey() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(accountId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key.toString()).isEqualTo(key.getPublicKey().toString());
            assertThat(info.balance).isEqualTo(new Hbar(1));
            assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

        }
    }

    @Test
    @DisplayName("Can create account with no initial balance")
    void canCreateAccountWithNoInitialBalance() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(accountId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key.toString()).isEqualTo(key.getPublicKey().toString());
            assertThat(info.balance).isEqualTo(new Hbar(0));
            assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

        }
    }

    @Test
    @DisplayName("Cannot create account with no key")
    void canNotCreateAccountWithNoKey() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> new AccountCreateTransaction()
                    .setInitialBalance(new Hbar(1))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)).withMessageContaining(Status.KEY_REQUIRED.toString());

        }
    }

    @Test
    @DisplayName("Can create account using aliasKey")
    void canCreateWithAliasKey() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var aliasId = key.toAccountId(0, 0);

            new TransferTransaction()
                .addHbarTransfer(testEnv.operatorId, new Hbar(10).negated())
                .addHbarTransfer(aliasId, new Hbar(10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var info = new AccountInfoQuery()
                .setAccountId(aliasId)
                .execute(testEnv.client);

            assertThat(key.getPublicKey()).isEqualTo(info.aliasKey);

        }  
    }

    @Test
    @DisplayName("Regenerates TransactionIds in response to expiration")
    void managesExpiration() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setTransactionId(new TransactionId(testEnv.operatorId, Instant.now().minusSeconds(40)))
                .setTransactionValidDuration(Duration.ofSeconds(30))
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(accountId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key.toString()).isEqualTo(key.getPublicKey().toString());
            assertThat(info.balance).isEqualTo(new Hbar(0));
            assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

        }
    }

    @Test
    @DisplayName("Can create account with alias from admin key")
    void createAccountWithAliasFromAdminKey() throws Exception {
        // Tests the third row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var evmAddress = adminKey.getPublicKey().toEvmAddress();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var accountId = new AccountCreateTransaction()
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            assertThat(accountId).isNotNull();

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isNotNull();
            assertThat(info.contractAccountId).hasToString(evmAddress.toString());
            assertThat(info.key).isEqualTo(adminKey.getPublicKey());

        }
    }

    @Test
    @DisplayName("Can create account with alias from admin key with receiver sig required")
    void createAccountWithAliasFromAdminKeyWithReceiverSigRequired() throws Exception {
        // Tests the fourth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var evmAddress = adminKey.getPublicKey().toEvmAddress();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var accountId = new AccountCreateTransaction()
                .setReceiverSignatureRequired(true)
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client).accountId;

            assertThat(accountId).isNotNull();

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isNotNull();
            assertThat(info.contractAccountId).hasToString(evmAddress.toString());
            assertThat(info.key).isEqualTo(adminKey.getPublicKey());

        }
    }

    @Test
    @DisplayName("Cannot create account with alias from admin key with receiver sig required without signature")
    void cannotCreateAccountWithAliasFromAdminKeyWithReceiverSigRequiredAndNoSignature() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var evmAddress = adminKey.getPublicKey().toEvmAddress();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> new AccountCreateTransaction()
                .setReceiverSignatureRequired(true)
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Can create account with alias different from admin key")
    void createAccountWithAlias() throws Exception {
        // Tests the fifth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateED25519();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var key = PrivateKey.generateECDSA();
            var evmAddress = key.getPublicKey().toEvmAddress();

            var accountId = new AccountCreateTransaction()
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client).accountId;

            assertThat(accountId).isNotNull();

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isNotNull();
            assertThat(info.contractAccountId).hasToString(evmAddress.toString());
            assertThat(info.key).isEqualTo(adminKey.getPublicKey());

        }
    }

    @Test
    @DisplayName("Cannot create account with alias different from admin key without signature")
    void cannotCreateAccountWithAliasWithoutSignature() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateED25519();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var key = PrivateKey.generateECDSA();
            var evmAddress = key.getPublicKey().toEvmAddress();

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> new AccountCreateTransaction()
                .setReceiverSignatureRequired(true)
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Can create account with alias different from admin key with receiver sig required")
    void createAccountWithAliasWithReceiverSigRequired() throws Exception {
        // Tests the sixth row of this table
        // https://github.com/hashgraph/hedera-improvement-proposal/blob/d39f740021d7da592524cffeaf1d749803798e9a/HIP/hip-583.md#signatures
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateED25519();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var key = PrivateKey.generateECDSA();
            var evmAddress = key.getPublicKey().toEvmAddress();

            var accountId = new AccountCreateTransaction()
                .setReceiverSignatureRequired(true)
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .sign(key)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client).accountId;

            assertThat(accountId).isNotNull();

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isNotNull();
            assertThat(info.contractAccountId).hasToString(evmAddress.toString());
            assertThat(info.key).isEqualTo(adminKey.getPublicKey());

        }
    }

    @Test
    @DisplayName("Cannot create account with alias different from admin key and receiver sig required without signature")
    void cannotCreateAccountWithAliasWithReceiverSigRequiredWithoutSignature() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateED25519();

            // Create the admin account
            new AccountCreateTransaction()
                .setKey(adminKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client);

            var key = PrivateKey.generateECDSA();
            var evmAddress = key.getPublicKey().toEvmAddress();

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> new AccountCreateTransaction()
                .setReceiverSignatureRequired(true)
                .setKey(adminKey)
                .setAlias(evmAddress)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountDeleteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.AccountInfoQuery;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountDeleteIntegrationTest {
    @Test
    @DisplayName("Can delete account")
    void canDeleteAccount() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(accountId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key.toString()).isEqualTo(key.getPublicKey().toString());
            assertThat(info.balance).isEqualTo(new Hbar(1));
            assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

        }
    }

    @Test
    @DisplayName("Cannot delete invalid account ID")
    void cannotCreateAccountWithNoKey() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new AccountDeleteTransaction()
                    .setTransferAccountId(testEnv.operatorId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.ACCOUNT_ID_DOES_NOT_EXIST.toString());

        }
    }

    @Test
    @DisplayName("Cannot delete account that has not signed transaction")
    void cannotDeleteAccountThatHasNotSignedTransaction() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new AccountDeleteTransaction()
                    .setAccountId(accountId)
                    .setTransferAccountId(testEnv.operatorId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountIdPopulationIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TransactionReceiptQuery;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class AccountIdPopulationIntegrationTest {
    @Test
    @DisplayName("Can populate AccountId num from mirror node (using sync method)")
    void canPopulateAccountIdNumSync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var privateKey = PrivateKey.generateECDSA();
            var publicKey = privateKey.getPublicKey();

            var evmAddress = publicKey.toEvmAddress();
            var evmAddressAccount = AccountId.fromEvmAddress(evmAddress);

            var tx = new TransferTransaction().addHbarTransfer(evmAddressAccount, new Hbar(1))
                .addHbarTransfer(testEnv.operatorId, new Hbar(-1)).execute(testEnv.client);

            var receipt = new TransactionReceiptQuery().setTransactionId(tx.transactionId).setIncludeChildren(true)
                .execute(testEnv.client);

            var newAccountId = receipt.children.get(0).accountId;

            var idMirror = AccountId.fromEvmAddress(evmAddress);
            Thread.sleep(5000);
            var accountId = idMirror.populateAccountNum(testEnv.client);

            assertThat(newAccountId.num).isEqualTo(accountId.num);
        }
    }

    @Test
    @DisplayName("Can populate AccountId num from mirror node (using async method)")
    void canPopulateAccountIdNumAsync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var privateKey = PrivateKey.generateECDSA();
            var publicKey = privateKey.getPublicKey();

            var evmAddress = publicKey.toEvmAddress();
            var evmAddressAccount = AccountId.fromEvmAddress(evmAddress);

            var tx = new TransferTransaction().addHbarTransfer(evmAddressAccount, new Hbar(1))
                .addHbarTransfer(testEnv.operatorId, new Hbar(-1)).execute(testEnv.client);

            var receipt = new TransactionReceiptQuery().setTransactionId(tx.transactionId).setIncludeChildren(true)
                .execute(testEnv.client);

            var newAccountId = receipt.children.get(0).accountId;

            var idMirror = AccountId.fromEvmAddress(evmAddress);
            Thread.sleep(5000);
            var accountId = idMirror.populateAccountNumAsync(testEnv.client).get();

            assertThat(newAccountId.num).isEqualTo(accountId.num);
    
            }
    }

    @Test
    @DisplayName("Can populate AccountId evm address from mirror node (using sync method)")
    void canPopulateAccountIdEvmAddressSync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var privateKey = PrivateKey.generateECDSA();
            var publicKey = privateKey.getPublicKey();

            var evmAddress = publicKey.toEvmAddress();
            var evmAddressAccount = AccountId.fromEvmAddress(evmAddress);

            var tx = new TransferTransaction().addHbarTransfer(evmAddressAccount, new Hbar(1))
                .addHbarTransfer(testEnv.operatorId, new Hbar(-1)).execute(testEnv.client);

            var receipt = new TransactionReceiptQuery().setTransactionId(tx.transactionId).setIncludeChildren(true)
                .execute(testEnv.client);

            var newAccountId = receipt.children.get(0).accountId;

            Thread.sleep(5000);
            var accountId = newAccountId.populateAccountEvmAddress(testEnv.client);

            assertThat(evmAddressAccount.evmAddress).isEqualTo(accountId.evmAddress);
        }
    }

    @Test
    @DisplayName("Can populate AccountId evm address from mirror node (using async method)")
    void canPopulateAccountIdEvmAddressAsync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var privateKey = PrivateKey.generateECDSA();
            var publicKey = privateKey.getPublicKey();

            var evmAddress = publicKey.toEvmAddress();
            var evmAddressAccount = AccountId.fromEvmAddress(evmAddress);

            var tx = new TransferTransaction().addHbarTransfer(evmAddressAccount, new Hbar(1))
                .addHbarTransfer(testEnv.operatorId, new Hbar(-1)).execute(testEnv.client);

            var receipt = new TransactionReceiptQuery().setTransactionId(tx.transactionId).setIncludeChildren(true)
                .execute(testEnv.client);

            var newAccountId = receipt.children.get(0).accountId;

            Thread.sleep(5000);
            var accountId = newAccountId.populateAccountEvmAddressAsync(testEnv.client).get();

            assertThat(evmAddressAccount.evmAddress).isEqualTo(accountId.evmAddress);
        }
    }

}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountInfoFlow;
import com.hedera.hashgraph.sdk.AccountInfoQuery;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.sdk.Transaction;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.as;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountInfoIntegrationTest {
    @Test
    @DisplayName("Can query account info for client operator")
    void canQueryAccountInfoForClientOperator() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var info = new AccountInfoQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(testEnv.operatorId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key).isEqualTo(testEnv.operatorKey);
            assertThat(info.balance.toTinybars()).isGreaterThan(0);
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

        }
    }

    @Test
    @DisplayName("Can get cost for account info query")
    void getCostAccountInfoForClientOperator() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var info = new AccountInfoQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(new Hbar(1));

            var cost = info.getCost(testEnv.client);

            var accInfo = info.setQueryPayment(cost).execute(testEnv.client);

            assertThat(accInfo.accountId).isEqualTo(testEnv.operatorId);

        }
    }

    @Test
    @DisplayName("Can get cost for account info query, with a bix max")
    void getCostBigMaxAccountInfoForClientOperator() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var info = new AccountInfoQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(Hbar.MAX);

            var cost = info.getCost(testEnv.client);

            var accInfo = info.setQueryPayment(cost).execute(testEnv.client);

            assertThat(accInfo.accountId).isEqualTo(testEnv.operatorId);

        }
    }

    @Test
    @Disabled
    @DisplayName("Can get cost for account info query, with a small max")
    void getCostSmallMaxAccountInfoForClientOperator() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var info = new AccountInfoQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            var cost = info.getCost(testEnv.client);

            assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {
                info.execute(testEnv.client);
            }).withMessage("com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException: cost for AccountInfoQuery, of " + cost.toString() + ", without explicit payment is greater than the maximum allowed payment of 1 t");

        }
    }

    @Test
    @DisplayName("Insufficient tx fee error.")
    void getCostInsufficientTxFeeAccountInfoForClientOperator() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var info = new AccountInfoQuery()
                .setAccountId(testEnv.operatorId)
                .setMaxQueryPayment(Hbar.fromTinybars(10000));

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                info.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

        }
    }

    @Test
    @DisplayName("AccountInfoFlow.verify functions")
    void accountInfoFlowVerifyFunctions() throws Throwable {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var newKey = PrivateKey.generateED25519();
            var newPublicKey = newKey.getPublicKey();

            Transaction<?> signedTx = new AccountCreateTransaction()
                .setKey(newPublicKey)
                .setInitialBalance(Hbar.fromTinybars(1000))
                .freezeWith(testEnv.client)
                .signWithOperator(testEnv.client);

            Transaction<?> unsignedTx = new AccountCreateTransaction()
                .setKey(newPublicKey)
                .setInitialBalance(Hbar.fromTinybars(1000))
                .freezeWith(testEnv.client);

            assertThat(AccountInfoFlow.verifyTransactionSignature(testEnv.client, testEnv.operatorId, signedTx)).isTrue();
            assertThat(AccountInfoFlow.verifyTransactionSignature(testEnv.client, testEnv.operatorId, unsignedTx)).isFalse();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountRecordsIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountRecordsQuery;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

class AccountRecordsIntegrationTest {
    @Test
    @DisplayName("Can query account records")
    void canQueryAccountRecords() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            new TransferTransaction()
                .addHbarTransfer(testEnv.operatorId, new Hbar(1).negated())
                .addHbarTransfer(accountId, new Hbar(1))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addHbarTransfer(testEnv.operatorId, new Hbar(1))
                .addHbarTransfer(accountId, new Hbar(1).negated())
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var records = new AccountRecordsQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(records.isEmpty()).isFalse();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountStakersIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountStakersQuery;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountStakersIntegrationTest {
    @Test
    @DisplayName("Cannot query account stakers since it is not supported")
    void cannotQueryAccountStakersSinceItIsNotSupported() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new AccountStakersQuery()
                    .setAccountId(testEnv.operatorId)
                    .setMaxQueryPayment(new Hbar(1))
                    .execute(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/AccountUpdateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountInfoQuery;
import com.hedera.hashgraph.sdk.AccountUpdateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class AccountUpdateIntegrationTest {
    @Test
    @DisplayName("Can update account with a new key")
    void canUpdateAccountWithNewKey() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key1 = PrivateKey.generateED25519();
            var key2 = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key1)
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            @Var var info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(accountId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key.toString()).isEqualTo(key1.getPublicKey().toString());
            assertThat(info.balance).isEqualTo(new Hbar(0));
            assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

            new AccountUpdateTransaction()
                .setAccountId(accountId)
                .setKey(key2.getPublicKey())
                .freezeWith(testEnv.client)
                .sign(key1)
                .sign(key2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(info.accountId).isEqualTo(accountId);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.key.toString()).isEqualTo(key2.getPublicKey().toString());
            assertThat(info.balance).isEqualTo(new Hbar(0));
            assertThat(info.autoRenewPeriod).isEqualTo(Duration.ofDays(90));
            assertThat(info.proxyAccountId).isNull();
            assertThat(info.proxyReceived).isEqualTo(Hbar.ZERO);

        }
    }

    @Test
    @DisplayName("Cannot update account when account ID is not set")
    void cannotUpdateAccountWhenAccountIdIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new AccountUpdateTransaction()
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.ACCOUNT_ID_DOES_NOT_EXIST.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ClientIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ClientIntegrationTest {
    @Test
    @DisplayName("setNetwork() functions correctly")
    void testReplaceNodes() throws Exception {
        @Var Map<String, AccountId> network = new HashMap<>();
        network.put("0.testnet.hedera.com:50211", new AccountId(3));
        network.put("1.testnet.hedera.com:50211", new AccountId(4));

        try(var testEnv = new IntegrationTestEnv(1)){

            testEnv.client
                .setMaxQueryPayment(new Hbar(2))
                .setRequestTimeout(Duration.ofMinutes(2))
                .setNetwork(network);

            assertThat(testEnv.operatorId).isNotNull();

            // Execute two simple queries so we create a channel for each network node.
            new AccountBalanceQuery()
                .setAccountId(new AccountId(3))
                .execute(testEnv.client);

            new AccountBalanceQuery()
                .setAccountId(new AccountId(3))
                .execute(testEnv.client);

            network = new HashMap<>();
            network.put("1.testnet.hedera.com:50211", new AccountId(4));
            network.put("2.testnet.hedera.com:50211", new AccountId(5));

            testEnv.client.setNetwork(network);

            network = new HashMap<>();
            network.put("35.186.191.247:50211", new AccountId(4));
            network.put("35.192.2.25:50211", new AccountId(5));

            testEnv.client.setNetwork(network);

        }
    }

    @Test
    void transactionIdNetworkIsVerified() {
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> {
            var client = Client.forPreviewnet();
            client.setAutoValidateChecksums(true);

            new AccountCreateTransaction()
                .setTransactionId(TransactionId.generate(AccountId.fromString("0.0.123-esxsf")))
                .execute(client);
            client.close();
        });
    }

    @Test
    @DisplayName("`setMaxNodesPerTransaction()`")
    void testMaxNodesPerTransaction() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            testEnv.client.setMaxNodesPerTransaction(1);

            var transaction = new AccountDeleteTransaction()
                .setAccountId(testEnv.operatorId)
                .freezeWith(testEnv.client);

            assertThat(transaction.getNodeAccountIds()).isNotNull();
            assertThat(transaction.getNodeAccountIds().size()).isEqualTo(1);

        }
    }

    @Test
    void ping() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var network = testEnv.client.getNetwork();
            var nodes = new ArrayList<>(network.values());

            assertThat(nodes.isEmpty()).isFalse();

            var node = nodes.get(0);

            testEnv.client.setMaxNodeAttempts(1);
            testEnv.client.ping(node);
        }
    }

    @Test
    void pingAll() throws Exception {
        try(var testEnv = new IntegrationTestEnv()){

            testEnv.client.setMaxNodeAttempts(1);
            testEnv.client.pingAll();

            var network = testEnv.client.getNetwork();
            var nodes = new ArrayList<>(network.values());

            assertThat(nodes.isEmpty()).isFalse();

            var node = nodes.get(0);

            new AccountBalanceQuery()
                .setAccountId(node)
                .execute(testEnv.client);

        }
    }

    @Test
    void pingAllBadNetwork() throws Exception {
        try(var testEnv = new IntegrationTestEnv(3)){

            // Skip if using local node.
            // Note: this check should be removed once the local node is supporting multiple nodes.
            testEnv.assumeNotLocalNode();

            testEnv.client.setMaxNodeAttempts(1);
            testEnv.client.setMaxAttempts(1);
            testEnv.client.setMaxNodesPerTransaction(2);

            var network = testEnv.client.getNetwork();

            var entries = new ArrayList<>(network.entrySet());
            assertThat(entries.size()).isGreaterThan(1);

            network.clear();
            network.put("in-process:name", entries.get(0).getValue());
            network.put(entries.get(1).getKey(), entries.get(1).getValue());

            testEnv.client.setNetwork(network);


            assertThatExceptionOfType(MaxAttemptsExceededException.class).isThrownBy(() -> {
                testEnv.client.pingAll();
            }).withMessageContaining("exceeded maximum attempts");

            var nodes = new ArrayList<>(testEnv.client.getNetwork().values());
            assertThat(nodes.isEmpty()).isFalse();

            var node = nodes.get(0);

            new AccountBalanceQuery()
                .setAccountId(node)
                .execute(testEnv.client);

            assertThat(testEnv.client.getNetwork().values().size()).isEqualTo(1);
        }
        
    }

    @Test
    void pingAsync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var network = testEnv.client.getNetwork();
            var nodes = new ArrayList<>(network.values());

            assertThat(nodes.isEmpty()).isFalse();

            var node = nodes.get(0);

            testEnv.client.setMaxNodeAttempts(1);
            testEnv.client.pingAsync(node).get();
        }
    }

    @Test
    void pingAllAsync() throws Exception {
        try(var testEnv = new IntegrationTestEnv()){

            testEnv.client.setMaxNodeAttempts(1);
            testEnv.client.pingAllAsync().get();

            var network = testEnv.client.getNetwork();
            var nodes = new ArrayList<>(network.values());

            assertThat(nodes.isEmpty()).isFalse();

            var node = nodes.get(0);

            new AccountBalanceQuery()
                .setAccountId(node)
                .execute(testEnv.client);
            
        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/Contents.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

public class Contents {
    private Contents() {
    }

    public static final String BIG_CONTENTS = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur aliquam augue sem, ut mattis dui laoreet a. Curabitur consequat est euismod, scelerisque metus et, tristique dui. Nulla commodo mauris ut faucibus ultricies. Quisque venenatis nisl nec augue tempus, at efficitur elit eleifend. Duis pharetra felis metus, sed dapibus urna vehicula id. Duis non venenatis turpis, sit amet ornare orci. Donec non interdum quam. Sed finibus nunc et risus finibus, non sagittis lorem cursus. Proin pellentesque tempor aliquam. Sed congue nisl in enim bibendum, condimentum vehicula nisi feugiat.\n" +
        "\n" +
        "Suspendisse non sodales arcu. Suspendisse sodales, lorem ac mollis blandit, ipsum neque porttitor nulla, et sodales arcu ante fermentum tellus. Integer sagittis dolor sed augue fringilla accumsan. Cras vitae finibus arcu, sit amet varius dolor. Etiam id finibus dolor, vitae luctus velit. Proin efficitur augue nec pharetra accumsan. Aliquam lobortis nisl diam, vel fermentum purus finibus id. Etiam at finibus orci, et tincidunt turpis. Aliquam imperdiet congue lacus vel facilisis. Phasellus id magna vitae enim dapibus vestibulum vitae quis augue. Morbi eu consequat enim. Maecenas neque nulla, pulvinar sit amet consequat sed, tempor sed magna. Mauris lacinia sem feugiat faucibus aliquet. Etiam congue non turpis at commodo. Nulla facilisi.\n" +
        "\n" +
        "Nunc velit turpis, cursus ornare fringilla eu, lacinia posuere leo. Mauris rutrum ultricies dui et suscipit. Curabitur in euismod ligula. Curabitur vitae faucibus orci. Phasellus volutpat vestibulum diam sit amet vestibulum. In vel purus leo. Nulla condimentum lectus vestibulum lectus faucibus, id lobortis eros consequat. Proin mollis libero elit, vel aliquet nisi imperdiet et. Morbi ornare est velit, in vehicula nunc malesuada quis. Donec vehicula convallis interdum.\n" +
        "\n" +
        "Integer pellentesque in nibh vitae aliquet. Ut at justo id libero dignissim hendrerit. Interdum et malesuada fames ac ante ipsum primis in faucibus. Praesent quis ornare lectus. Nam malesuada non diam quis cursus. Phasellus a libero ligula. Suspendisse ligula elit, congue et nisi sit amet, cursus euismod dolor. Morbi aliquam, nulla a posuere pellentesque, diam massa ornare risus, nec eleifend neque eros et elit.\n" +
        "\n" +
        "Pellentesque a sodales dui. Sed in efficitur ante. Duis eget volutpat elit, et ornare est. Nam felis dolor, placerat mattis diam id, maximus lobortis quam. Sed pellentesque lobortis sem sed placerat. Pellentesque augue odio, molestie sed lectus sit amet, congue volutpat massa. Quisque congue consequat nunc id fringilla. Duis semper nulla eget enim venenatis dapibus. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque varius turpis nibh, sit amet malesuada mauris malesuada quis. Vivamus dictum egestas placerat. Vivamus id augue elit.\n" +
        "\n" +
        "Cras fermentum volutpat eros, vitae euismod lorem viverra nec. Donec lectus augue, porta eleifend odio sit amet, condimentum rhoncus urna. Nunc sed odio velit. Morbi non cursus odio, eget imperdiet erat. Nunc rhoncus massa non neque volutpat, sit amet faucibus ante congue. Phasellus nec lorem vel leo accumsan lobortis. Maecenas id ligula bibendum purus suscipit posuere ac eget diam. Nam in quam pretium, semper erat auctor, iaculis odio. Maecenas placerat, nisi ac elementum tempor, felis nulla porttitor orci, ac rhoncus diam justo in elit. Etiam lobortis fermentum ligula in tincidunt. Donec quis vestibulum nunc. Sed eros diam, interdum in porta lobortis, gravida eu magna. Donec diam purus, finibus et sollicitudin quis, fringilla nec nisi. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur ultricies sagittis dapibus. Etiam ullamcorper aliquet libero, eu venenatis mauris suscipit id.\n" +
        "\n" +
        "Ut interdum eleifend sem, vel bibendum ipsum volutpat eget. Nunc ac dignissim augue. Aliquam ornare aliquet magna id dignissim. Vestibulum velit sem, lacinia eu rutrum in, rhoncus vitae mauris. Pellentesque scelerisque pulvinar mauris non cursus. Integer id dolor porta, bibendum sem vel, pretium tortor. Fusce a nisi convallis, interdum quam condimentum, suscipit dolor. Sed magna diam, efficitur non nunc in, tincidunt varius mi. Aliquam ullamcorper nulla eu fermentum bibendum. Vivamus a felis pretium, hendrerit enim vitae, hendrerit leo. Suspendisse lacinia lectus a diam consectetur suscipit. Aenean hendrerit nisl sed diam venenatis pellentesque. Nullam egestas lectus a consequat pharetra. Vivamus ornare tellus auctor, facilisis lacus id, feugiat dui. Nam id est ut est rhoncus varius.\n" +
        "\n" +
        "Aenean vel vehicula erat. Aenean gravida risus vitae purus sodales, quis dictum enim porta. Ut elit elit, fermentum sed posuere non, accumsan eu justo. Integer porta malesuada quam, et elementum massa suscipit nec. Donec in elit diam. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Duis suscipit vel ante volutpat vestibulum.\n" +
        "\n" +
        "Pellentesque ex arcu, euismod et sapien ut, vulputate suscipit enim. Donec mattis sagittis augue, et mattis lacus. Cras placerat consequat lorem sed luctus. Nam suscipit aliquam sem ac imperdiet. Mauris a semper augue, pulvinar fringilla magna. Integer pretium massa non risus commodo hendrerit. Sed dictum libero id erat sodales mattis. Etiam auctor dolor lectus, ut sagittis enim lobortis vitae. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur nec orci lobortis, cursus risus eget, sollicitudin massa. Integer vel tincidunt mi, id eleifend quam. Nullam facilisis nisl eu mauris congue, vitae euismod nisi malesuada. Vivamus sit amet urna et libero sagittis dictum.\n" +
        "\n" +
        "In hac habitasse platea dictumst. Aliquam erat volutpat. Ut dictum, mi a viverra venenatis, mi urna pulvinar nisi, nec gravida lectus diam eget urna. Ut dictum sit amet nisl ut dignissim. Sed sed mauris scelerisque, efficitur augue in, vulputate turpis. Proin dolor justo, bibendum et sollicitudin feugiat, imperdiet sed mi. Sed elementum vitae massa vel lobortis. Cras vitae massa sit amet libero dictum tempus.\n" +
        "\n" +
        "Vivamus ut mauris lectus. Curabitur placerat ornare scelerisque. Cras malesuada nunc quis tortor pretium bibendum vel sed dui. Cras lobortis nibh eu erat blandit, sit amet consequat neque fermentum. Phasellus imperdiet molestie tristique. Cras auctor purus erat, id mollis ligula porttitor eget. Mauris porta pharetra odio et finibus. Suspendisse eu est a ligula bibendum cursus. Mauris ac laoreet libero. Nullam volutpat sem quis rhoncus gravida.\n" +
        "\n" +
        "Donec malesuada lacus ac iaculis cursus. Sed sem orci, feugiat ac est ut, ultricies posuere nisi. Suspendisse potenti. Phasellus ut ultricies purus. Etiam sem tortor, fermentum quis aliquam eget, consequat ut nulla. Aliquam dictum metus in mi fringilla, vel gravida nulla accumsan. Cras aliquam eget leo vel posuere. Vivamus vitae malesuada nunc. Morbi placerat magna mi, id suscipit lacus auctor quis. Nam at lorem vel odio finibus fringilla ut ac velit. Donec laoreet at nibh quis vehicula.\n" +
        "\n" +
        "Fusce ac tristique nisi. Donec leo nisi, consectetur at tellus sit amet, consectetur ultrices dui. Quisque gravida mollis tempor. Maecenas semper, sapien ut dignissim feugiat, massa enim viverra dolor, non varius eros nulla nec felis. Nunc massa lacus, ornare et feugiat id, bibendum quis purus. Praesent viverra elit sit amet purus consectetur venenatis. Maecenas nibh risus, elementum sit amet enim sagittis, ultrices malesuada lectus. Vivamus non felis ante. Ut vulputate ex arcu. Aliquam porta gravida porta. Aliquam eros leo, malesuada quis eros non, maximus tristique neque. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Etiam ligula orci, mollis vel luctus nec, venenatis vitae est. Fusce rutrum convallis nisi.\n" +
        "\n" +
        "Nunc laoreet eget nibh in feugiat. Pellentesque nec arcu cursus, gravida dolor a, pellentesque nisi. Praesent vel justo blandit, placerat risus eget, consectetur orci. Sed maximus metus mi, ut euismod augue ultricies in. Nunc id risus hendrerit, aliquet lorem nec, congue justo. Vestibulum vel nunc ac est euismod mattis ac vitae nulla. Donec blandit luctus mauris, sit amet bibendum dui egestas et. Aenean nec lorem nec elit ornare rutrum nec eget ligula. Fusce a ipsum vitae neque elementum pharetra. Pellentesque ullamcorper ullamcorper libero, vitae porta sem sagittis vel. Interdum et malesuada fames ac ante ipsum primis in faucibus.\n" +
        "\n" +
        "Duis at massa sit amet risus pellentesque varius sit amet vitae eros. Cras tempor aliquet sapien, vehicula varius neque volutpat et. Donec purus nibh, pellentesque ut lobortis nec, ultricies ultricies nisl. Sed accumsan ut dui sit amet vulputate. Suspendisse eu facilisis massa, a hendrerit mauris. Nulla elementum molestie tincidunt. Donec mi justo, ornare vel tempor id, gravida et orci. Nam molestie erat nec nisi bibendum accumsan. Duis vitae tempor ante. Morbi congue mauris vel sagittis facilisis. Vivamus vehicula odio orci, a tempor nibh euismod in. Proin mattis, nibh at feugiat porta, purus velit posuere felis, quis volutpat sapien dui vel odio. Nam fermentum sem nec euismod aliquet. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aliquam erat volutpat.\n" +
        "\n" +
        "Mauris congue lacus tortor. Pellentesque arcu eros, accumsan imperdiet porttitor vitae, mattis nec justo. Nullam ac aliquam mauris. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Suspendisse potenti. Fusce accumsan tempus felis a sagittis. Maecenas et velit odio. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Aliquam eros lacus, volutpat non urna sed, tincidunt ullamcorper elit. Sed sit amet gravida libero. In varius mi vel diam sollicitudin mollis.\n" +
        "\n" +
        "Aenean varius, diam vitae hendrerit feugiat, libero augue ultrices odio, eget consequat sem tellus eu nisi. Nam dapibus enim et auctor sollicitudin. Nunc iaculis eros orci, ac accumsan eros malesuada ut. Ut semper augue felis, nec sodales lorem consectetur non. Cras gravida eleifend est, et sagittis eros imperdiet congue. Fusce id tellus dapibus nunc scelerisque tempus. Donec tempor placerat libero, in commodo nisi bibendum eu. Donec id eros non est sollicitudin luctus. Duis bibendum bibendum tellus nec viverra. Aliquam non faucibus ex, nec luctus dui. Curabitur efficitur varius urna non dignissim. Suspendisse elit elit, ultrices in elementum eu, tempor at magna.\n" +
        "\n" +
        "Nunc in purus sit amet mi laoreet pulvinar placerat eget sapien. Donec vel felis at dui ultricies euismod quis vel neque. Donec tincidunt urna non eros pretium blandit. Nullam congue tincidunt condimentum. Curabitur et libero nibh. Proin ultricies risus id imperdiet scelerisque. Suspendisse purus mi, viverra vitae risus ut, tempus tincidunt enim. Ut luctus lobortis nisl, eget venenatis tortor cursus non. Mauris finibus nisl quis gravida ultricies. Fusce elementum lacus sit amet nunc congue, in porta nulla tincidunt.\n" +
        "\n" +
        "Mauris ante risus, imperdiet blandit posuere in, blandit eu ipsum. Integer et auctor arcu. Integer quis elementum purus. Nunc in ultricies nisl, sed rutrum risus. Suspendisse venenatis eros nec lorem rhoncus, in scelerisque velit condimentum. Etiam condimentum quam felis, in elementum odio mattis et. In ut nibh porttitor, hendrerit tellus vel, luctus magna. Vestibulum et ligula et dolor pellentesque porta. Aenean efficitur porta massa et bibendum. Nulla vehicula sem in risus volutpat, a eleifend elit maximus.\n" +
        "\n" +
        "Proin orci lorem, auctor a felis eu, pretium lobortis nulla. Phasellus aliquam efficitur interdum. Sed sit amet velit rutrum est dictum facilisis. Duis cursus enim at nisl tincidunt, eu molestie elit vehicula. Cras pellentesque nisl id enim feugiat fringilla. In quis tincidunt neque. Nam eu consectetur dolor. Ut id interdum mauris. Mauris nunc tortor, placerat in tempor ut, vestibulum eu nisl. Integer vel dapibus ipsum. Nunc id erat pulvinar, tincidunt magna id, condimentum massa. Pellentesque consequat est eget odio placerat vehicula. Etiam augue neque, sagittis non leo eu, tristique scelerisque dui. Ut dui urna, blandit quis urna ac, tincidunt tristique turpis.\n" +
        "\n" +
        "Suspendisse venenatis rhoncus ligula ultrices condimentum. In id laoreet eros. Suspendisse suscipit fringilla leo id euismod. Sed in quam libero. Ut at ligula tellus. Sed tristique gravida dui, at egestas odio aliquam iaculis. Praesent imperdiet velit quis nibh consequat, quis pretium sem sagittis. Donec tortor ex, congue sit amet pulvinar ac, rutrum non est. Praesent ipsum magna, venenatis sit amet vulputate id, eleifend ac ipsum.\n" +
        "\n" +
        "In consequat, nisi iaculis laoreet elementum, massa mauris varius nisi, et porta nisi velit at urna. Maecenas sit amet aliquet eros, a rhoncus nisl. Maecenas convallis enim nunc. Morbi purus nisl, aliquam ac tincidunt sed, mattis in augue. Quisque et elementum quam, vitae maximus orci. Suspendisse hendrerit risus nec vehicula placerat. Nulla et lectus nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\n" +
        "\n" +
        "Etiam ut sodales ex. Nulla luctus, magna eu scelerisque sagittis, nibh quam consectetur neque, non rutrum dolor metus nec ex. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Sed egestas augue elit, sollicitudin accumsan massa lobortis ac. Curabitur placerat, dolor a aliquam maximus, velit ipsum laoreet ligula, id ullamcorper lacus nibh eget nisl. Donec eget lacus venenatis enim consequat auctor vel in.\n";
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractBytecodeIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractByteCodeQuery;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.as;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ContractBytecodeIntegrationTest {
	private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

	@Test
	@DisplayName("Can query contract bytecode")
	void canQueryContractBytecode() throws Exception {
		try (var testEnv = new IntegrationTestEnv(1)) {

			@Var var response = new FileCreateTransaction()
				.setKeys(testEnv.operatorKey)
				.setContents(SMART_CONTRACT_BYTECODE)
				.execute(testEnv.client);

			var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

			response = new ContractCreateTransaction()
				.setAdminKey(testEnv.operatorKey)
				.setGas(200000)
				.setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
				.setBytecodeFileId(fileId)
				.setContractMemo("[e2e::ContractCreateTransaction]")
				.execute(testEnv.client);

			var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

			var bytecode = new ContractByteCodeQuery()
				.setContractId(contractId)
				.execute(testEnv.client);

			assertThat(bytecode.size()).isEqualTo(798);

			new ContractDeleteTransaction()
				.setTransferAccountId(testEnv.operatorId)
				.setContractId(contractId)
				.execute(testEnv.client)
				.getReceipt(testEnv.client);

			new FileDeleteTransaction()
				.setFileId(fileId)
				.execute(testEnv.client)
				.getReceipt(testEnv.client);

		}
	}

	@Test
	@DisplayName("Can get cost, even with a big max")
	void getCostBigMaxQueryContractBytecode() throws Exception {
		try (var testEnv = new IntegrationTestEnv(1)) {

			@Var var response = new FileCreateTransaction()
				.setKeys(testEnv.operatorKey)
				.setContents(SMART_CONTRACT_BYTECODE)
				.execute(testEnv.client);

			var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

			response = new ContractCreateTransaction()
				.setAdminKey(testEnv.operatorKey)
				.setGas(200000)
				.setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
				.setBytecodeFileId(fileId)
				.setContractMemo("[e2e::ContractCreateTransaction]")
				.execute(testEnv.client);

			var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

			var bytecodeQuery = new ContractByteCodeQuery()
				.setContractId(contractId)
				.setMaxQueryPayment(new Hbar(1000));

			var cost = bytecodeQuery.getCost(testEnv.client);

			var bytecode = bytecodeQuery.setQueryPayment(cost).execute(testEnv.client);

			assertThat(bytecode.size()).isEqualTo(798);

			new ContractDeleteTransaction()
				.setTransferAccountId(testEnv.operatorId)
				.setContractId(contractId)
				.execute(testEnv.client)
				.getReceipt(testEnv.client);

			new FileDeleteTransaction()
				.setFileId(fileId)
				.execute(testEnv.client)
				.getReceipt(testEnv.client);

		}
	}

	@Test
	@DisplayName("Error, max is smaller than set payment.")
	void getCostSmallMaxQueryContractBytecode() throws Exception {
		try (var testEnv = new IntegrationTestEnv(1)) {

			@Var var response = new FileCreateTransaction()
					.setKeys(testEnv.operatorKey)
					.setContents(SMART_CONTRACT_BYTECODE)
					.execute(testEnv.client);

			var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

			response = new ContractCreateTransaction()
					.setAdminKey(testEnv.operatorKey)
					.setGas(200000)
					.setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
					.setBytecodeFileId(fileId)
					.setContractMemo("[e2e::ContractCreateTransaction]")
					.execute(testEnv.client);

			var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

			var bytecodeQuery = new ContractByteCodeQuery()
					.setContractId(contractId)
					.setMaxQueryPayment(Hbar.fromTinybars(1));

			assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
				bytecodeQuery.execute(testEnv.client);
			});

			new ContractDeleteTransaction()
					.setTransferAccountId(testEnv.operatorId)
					.setContractId(contractId)
					.execute(testEnv.client)
					.getReceipt(testEnv.client);

			new FileDeleteTransaction()
					.setFileId(fileId)
					.execute(testEnv.client)
					.getReceipt(testEnv.client);

		}
	}

	@Test
	@DisplayName("Insufficient tx fee error.")
	void getCostInsufficientTxFeeQueryContractBytecode() throws Exception {
		try (var testEnv = new IntegrationTestEnv(1)) {

			@Var var response = new FileCreateTransaction()
					.setKeys(testEnv.operatorKey)
					.setContents(SMART_CONTRACT_BYTECODE)
					.execute(testEnv.client);

			var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

			response = new ContractCreateTransaction()
					.setAdminKey(testEnv.operatorKey)
					.setGas(200000)
					.setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
					.setBytecodeFileId(fileId)
					.setContractMemo("[e2e::ContractCreateTransaction]")
					.execute(testEnv.client);

			var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

			var bytecodeQuery = new ContractByteCodeQuery()
					.setContractId(contractId)
					.setMaxQueryPayment(new Hbar(100));

			assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
				bytecodeQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
			}).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

			new ContractDeleteTransaction()
					.setTransferAccountId(testEnv.operatorId)
					.setContractId(contractId)
					.execute(testEnv.client)
					.getReceipt(testEnv.client);

			new FileDeleteTransaction()
					.setFileId(fileId)
					.execute(testEnv.client)
					.getReceipt(testEnv.client);

		}
	}

	@Test
	@DisplayName("Cannot query contract bytecode when contract ID is not set")
	void cannotQueryContractBytecodeWhenContractIDIsNotSet() throws Exception {
		try (var testEnv = new IntegrationTestEnv(1)) {

			assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
				new ContractByteCodeQuery()
						.execute(testEnv.client);
			}).withMessageContaining(Status.INVALID_CONTRACT_ID.toString());

		}
	}
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractCallIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCallQuery;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ContractCallIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Can call contract function")
    void canCallContractFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var
            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var callQuery = new ContractCallQuery()
                .setContractId(contractId)
                .setGas(200000)
                .setFunction("getMessage")
                .setQueryPayment(new Hbar(1));

            var result = callQuery
                    .execute(testEnv.client);

            assertThat(result.getString(0)).isEqualTo("Hello from Hedera.");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot call contract function when contract function is not set")
    void cannotCallContractFunctionWhenContractFunctionIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(
                    new ContractCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setGas(200000)
                        .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client)
                        .contractId
            );

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractCallQuery()
                    .setContractId(contractId)
                    .setGas(100000)
                    .execute(testEnv.client);
            }).withMessageContaining(Status.CONTRACT_REVERT_EXECUTED.toString());

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot call contract function when gas is not set")
    void cannotCallContractFunctionWhenGasIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(
                    new ContractCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setGas(200000)
                        .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client)
                        .contractId
                    );

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractCallQuery()
                    .setContractId(contractId)
                    .setFunction("getMessage")
                    .execute(testEnv.client);
            }).withMessageContaining(Status.INSUFFICIENT_GAS.toString());

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot call contract function when contract ID is not set")
    void cannotCallContractFunctionWhenContractIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(
                    new ContractCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setGas(200000)
                        .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client)
                        .contractId
                    );

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractCallQuery()
                    .setGas(100000)
                    .setFunction("getMessage")
                    .execute(testEnv.client);
            }).withMessageContaining(Status.INVALID_CONTRACT_ID.toString());

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get cost, even with a big max")
    void getCostBigMaxContractCallFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var callQuery = new ContractCallQuery()
                    .setContractId(contractId)
                    .setGas(100000)
                    .setFunction("getMessage")
                    .setQueryPayment(new Hbar(1));

            var result = callQuery
                    .execute(testEnv.client);

            assertThat(result.getString(0)).isEqualTo("Hello from Hedera.");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Error, max is smaller than set payment.")
    void getCostSmallMaxContractCallFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var callQuery = new ContractCallQuery()
                    .setContractId(contractId)
                    .setGas(100000)
                    .setFunction("getMessage")
                    .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
                callQuery.execute(testEnv.client);
            });

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Insufficient tx fee error.")
    void getCostInsufficientTxFeeContractCallFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var callQuery = new ContractCallQuery()
                    .setContractId(contractId)
                    .setGas(100000)
                    .setFunction("getMessage")
                    .setMaxQueryPayment(new Hbar(100));

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                callQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractCreateFlowIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2022 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

public class ContractCreateFlowIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Create contract with flow")
    void createContractWithFlow() throws Throwable {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new ContractCreateFlow()
                .setBytecode(SMART_CONTRACT_BYTECODE)
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setContractMemo("[e2e::ContractCreateFlow]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var receipt = new ContractExecuteTransaction()
                .setContractId(contractId)
                .setGas(100000)
                .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .setTransferAccountId(testEnv.operatorId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Create contract with flow without signing")
    void createContractWithFlowWithoutSigning() throws Throwable {
        try(var testEnv = new IntegrationTestEnv(1)){
            var adminKey = PrivateKey.generateED25519();

            assertThatThrownBy(() -> new ContractCreateFlow()
                .setBytecode(SMART_CONTRACT_BYTECODE)
                .setAdminKey(adminKey)
                .setGas(100000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setContractMemo("[e2e::ContractCreateFlow]")
                .execute(testEnv.client))
                .isInstanceOf(RuntimeException.class)
                .hasMessageEndingWith("raised status INVALID_SIGNATURE");

        }
    }

    @Test
    @DisplayName("Create contract with flow and sign with private key")
    void createContractWithFlowPrivateKeySign() throws Throwable {
        try(var testEnv = new IntegrationTestEnv(1)){
            var adminKey = PrivateKey.generateED25519();

            var response = new ContractCreateFlow()
                .setBytecode(SMART_CONTRACT_BYTECODE)
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setContractMemo("[e2e::ContractCreateFlow]")
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var receipt = new ContractExecuteTransaction()
                .setContractId(contractId)
                .setGas(100000)
                .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .setTransferAccountId(testEnv.operatorId)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Create contract with flow and sign with public key and transaction signer")
    void createContractWithFlowPublicKeySign() throws Throwable {
        try(var testEnv = new IntegrationTestEnv(1)){
            var adminKey = PrivateKey.generateED25519();

            var response = new ContractCreateFlow()
                .setBytecode(SMART_CONTRACT_BYTECODE)
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setContractMemo("[e2e::ContractCreateFlow]")
                .freezeWith(testEnv.client)
                .signWith(adminKey.getPublicKey(), adminKey::sign)
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var receipt = new ContractExecuteTransaction()
                .setContractId(contractId)
                .setGas(100000)
                .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .setTransferAccountId(testEnv.operatorId)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractCreateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractInfoQuery;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.as;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ContractCreateIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Can create contract")
    void canCreateContract() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(Objects.requireNonNull(contractId).toString());
            assertThat(info.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(info.adminKey).toString()).isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can create contract with no admin key")
    void canCreateContractWithNoAdminKey() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(Objects.requireNonNull(contractId).toString());
            assertThat(info.adminKey).isNotNull();
            // assertEquals(info.adminKey, contractId);
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

        }
    }

    @Test
    @DisplayName("Cannot create contract when gas is not set")
    void cannotCreateContractWhenGasIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                    .setBytecodeFileId(fileId)
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INSUFFICIENT_GAS.toString());

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }

    }

    @Test
    @DisplayName("Cannot create contract when constructor parameters are not set")
    void cannotCreateContractWhenConstructorParametersAreNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new ContractCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setGas(100000)
                    .setBytecodeFileId(fileId)
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.CONTRACT_REVERT_EXECUTED.toString());

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot create contract when bytecode file ID is not set")
    void cannotCreateContractWhenBytecodeFileIdIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new ContractCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setGas(100000)
                    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_FILE_ID.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractDeleteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractInfoQuery;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.as;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ContractDeleteIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Can delete contract with admin key")
    void canDeleteContractWithAdminKey() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var
            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(contractId.toString());
            assertThat(info.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(info.adminKey).toString())
                    .isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot delete contract which has no admin key")
    void cannotDeleteContractWhichHasNoAdminKey() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(new ContractCreateTransaction()
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .contractId
            );

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(contractId.toString());
            assertThat(info.adminKey).isNotNull();
            // assertEquals(info.adminKey, contractId);
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new ContractDeleteTransaction()
                    .setContractId(contractId)
                    .setTransferAccountId(testEnv.client.getOperatorAccountId())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.MODIFYING_IMMUTABLE_CONTRACT.toString());

        }
    }

    @Test
    @DisplayName("Cannot delete contract when contract ID is not set")
    void cannotDeleteContractWhenContractIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractDeleteTransaction()
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_CONTRACT_ID.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractExecuteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractExecuteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import java.util.Objects;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class ContractExecuteIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Can execute contract methods")
    void canExecuteContractMethods() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var receipt = new ContractExecuteTransaction()
                .setContractId(contractId)
                .setGas(100000)
                .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot execute contract when contract ID is not set")
    void cannotExecuteContractWhenContractIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractExecuteTransaction()
                    .setGas(100000)
                    .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_CONTRACT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot execute contract when contract function parameters are not set")
    void cannotExecuteContractWhenContractFunctionParametersAreNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(
                    new ContractCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setGas(200000)
                        .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client).contractId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new ContractExecuteTransaction()
                    .setContractId(contractId)
                    .setGas(100000)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.CONTRACT_REVERT_EXECUTED.toString());

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot execute contract when gas is not set")
    void cannotExecuteContractWhenGasIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(
                    new ContractCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setGas(200000)
                        .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client).contractId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractExecuteTransaction()
                    .setContractId(contractId)
                    .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INSUFFICIENT_GAS.toString());

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractFunctionParametersIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;

import com.esaulpaugh.headlong.abi.Address;
import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCallQuery;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractId;
import com.hedera.hashgraph.sdk.FileAppendTransaction;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileId;
import com.hedera.hashgraph.sdk.Hbar;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Objects;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class ContractFunctionParametersIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "60806040523480156200001157600080fd5b5060408051608081018252600491810191825263082d8caf60e31b6060820152818152600160208201529060009081906200004d908262000106565b5060208201518160010155905050620001d2565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200008c57607f821691505b602082108103620000ad57634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200010157600081815260208120601f850160051c81016020861015620000dc5750805b601f850160051c820191505b81811015620000fd57828155600101620000e8565b5050505b505050565b81516001600160401b0381111562000122576200012262000061565b6200013a8162000133845462000077565b84620000b3565b602080601f831160018114620001725760008415620001595750858301515b600019600386901b1c1916600185901b178555620000fd565b600085815260208120601f198616915b82811015620001a35788860151825594840194600190910190840162000182565b5085821015620001c25787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b615dfe80620001e26000396000f3fe608060405234801561001057600080fd5b50600436106108355760003560e01c80637f8082f711610437578063c5882dbb11610236578063e2a345291161013b578063f6e877f4116100c3578063fafc3b9911610092578063fafc3b9914611857578063fba1bc4c14611872578063febe099714611887578063ff5f54dd146118a2578063ffb80501146118bd57600080fd5b8063f6e877f4146117d9578063f8293f6e146117ff578063f914c4d214611821578063f962326a1461183c57600080fd5b8063eceda56a1161010a578063eceda56a1461174c578063ef65066114611767578063f0ebb92214611782578063f4e490f51461179d578063f680c24a146117be57600080fd5b8063e2a34529146116d8578063e4b90944146116f3578063e713cda81461170e578063ea945d301461173157600080fd5b8063d79d4d40116101be578063e05e91e01161018d578063e05e91e014611630578063e066de5014611656578063e0cddc551461167c578063e0f53e2414611697578063e1dbb318146116bd57600080fd5b8063d79d4d4014611592578063dade0c0b146115b8578063dbb04ed9146115da578063de9fb4841461160357600080fd5b8063cbd2e6a511610205578063cbd2e6a514611511578063cdb9e4e814611536578063cf7c3dfc1461155c578063d1b10ad714610ada578063d33c57501461157757600080fd5b8063c5882dbb1461148b578063c6c18a1c146114a6578063c7d8b87e146114d0578063cb47cdae146114f657600080fd5b8063a1bda1221161033c578063b5abe7df116102c4578063ba945bdb11610293578063ba945bdb146113dc578063bb6b524314611402578063bd90536a14611428578063be63d0b814611450578063c503772d1461146b57600080fd5b8063b5abe7df14611359578063b834bfe914611374578063b8da8d1614611395578063b989c7ee146113bb57600080fd5b8063aa016e681161030b578063aa016e68146112dc578063aa80ca2e14610c6b578063b2325c35146112f7578063b2db404a14611312578063b4e3e7b11461133357600080fd5b8063a1bda12214611259578063a401d60d1461127a578063a57ebf10146112a0578063a75761f1146112bb57600080fd5b80638f2805e0116103bf57806394cd7c801161038e57806394cd7c80146111b557806398508ba3146111d65780639b1794ae146111f7578063a08b9f671461121d578063a19962341461123e57600080fd5b80638f2805e0146111435780638ff4cfee1461115e578063909c5b2414611179578063923f5edf1461119457600080fd5b806386aba5a71161040657806386aba5a7146110ab578063881c8fb7146110c657806388b1dd37146110ec57806388b7e6f5146111075780638d7f60151461112857600080fd5b80637f8082f714610c6b578063817b24541461107557806381dbe13e14611090578063827147ce1461099a57600080fd5b806338fa6658116106435780635a8fd3b51161054857806370a5cb81116104d05780637ba844771161049f5780637ba8447714610fe25780637d0dc26214610ffd5780637d906c551461101e5780637e281630146110395780637ec32d841461105457600080fd5b806370a5cb8114610f5a57806372a06b4d14610f80578063737b801614610fa1578063796a27ea14610fbc57600080fd5b806369cbe0561161051757806369cbe05614610ecd5780636a54715c14610ee85780636a75c12f14610f095780636a9929db14610f245780636ee8f39c14610f3f57600080fd5b80635a8fd3b514610e4f578063628bc3ef14610e6a57806364e008c114610e8b57806368ef446614610eac57600080fd5b80634bbc9a67116105cb578063545e21131161059a578063545e211314610dd157806355f232a414610dfe57806357890ba914610e1957806357d9c08b14610e3457806359adb2df14610ada57600080fd5b80634bbc9a6714610d655780634e96247314610d80578063501297c214610d9b57806350370d8514610db657600080fd5b80633f396e67116106125780633f396e6714610ce3578063407b899b14610d0b578063435a33a814610d2c57806344e7b03714610af657806348d848d014610d4757600080fd5b806338fa665814610c6b5780633a73007714610c865780633b45e6e014610ca15780633e1a277114610cc257600080fd5b80631e9aa70f116107495780632ef16e8e116106d15780633135d681116106a05780633135d68114610beb57806333520ec314610c0657806333edb89614610c275780633729a2da14610c42578063382d087314610c5057600080fd5b80632ef16e8e14610b6d5780632f47a40d14610b8e5780632f6c1bb414610baf578063309f9ac914610bd057600080fd5b806322937ea91161071857806322937ea914610ada5780632421101f14610af657806324c3c3d214610b1c57806328a30eb714610b375780632a3082ce14610b5257600080fd5b80631e9aa70f14610a6e578063203ae83a14610a8957806321d1730b14610aa45780632234ea0214610abf57600080fd5b8063118b8415116107cc57806312b932a71161079b57806312b932a7146109db57806312cd95a1146109f657806315832ae414610a17578063189cea8e14610a325780631d11456214610a5357600080fd5b8063118b84151461095857806311ec6c9014610979578063126bc8151461099a578063129ed5da146109b557600080fd5b806306ac6fe11161080857806306ac6fe1146108ca57806308123e09146108f05780630a958dc81461091657806310d545531461093757600080fd5b8063017fa10b1461083a578063021d88ab14610868578063037454301461088e5780630577a846146108af575b600080fd5b61084b610848366004611a34565b90565b6040516001600160801b0390911681526020015b60405180910390f35b610876610848366004611a6d565b6040516001600160601b03909116815260200161085f565b61089c610848366004611a9a565b604051600c9190910b815260200161085f565b6108bd610848366004611b35565b60405161085f9190611bd1565b6108d8610848366004611c35565b6040516001600160781b03909116815260200161085f565b6108fe610848366004611c67565b60405166ffffffffffffff909116815260200161085f565b610924610848366004611c94565b60405160049190910b815260200161085f565b610945610848366004611cc1565b60405160119190910b815260200161085f565b610966610848366004611cee565b604051601e9190910b815260200161085f565b610987610848366004611d1b565b60405160139190910b815260200161085f565b6109a8610848366004611da5565b60405161085f9190611e27565b6109c3610848366004611e51565b6040516001600160981b03909116815260200161085f565b6109e9610848366004611e7e565b60405161085f9190611f0a565b610a04610848366004611f57565b60405160129190910b815260200161085f565b610a25610848366004611f83565b60405161085f919061200f565b610a4061084836600461205c565b60405160169190910b815260200161085f565b610a6161084836600461208f565b60405161085f919061211d565b610a7c610848366004612170565b60405161085f91906121fc565b610a97610848366004612237565b60405161085f91906122c3565b610ab261084836600461231b565b60405161085f91906123a7565b610acd6108483660046123fa565b60405161085f9190612486565b610ae86108483660046124c1565b60405190815260200161085f565b610b046108483660046124da565b6040516001600160a01b03909116815260200161085f565b610b2a61084836600461250e565b60405161085f919061259a565b610b456108483660046125db565b60405161085f9190612667565b610b606108483660046126b4565b60405161085f9190612740565b610b7b61084836600461278d565b604051601d9190910b815260200161085f565b610b9c6108483660046127a8565b604051600a9190910b815260200161085f565b610bbd6108483660046127d5565b60405160199190910b815260200161085f565b610bde610848366004612807565b60405161085f9190612893565b610bf96108483660046128eb565b60405161085f9190612977565b610c146108483660046129ca565b604051601a9190910b815260200161085f565b610c356108483660046129f7565b60405161085f9190612a83565b610a61610848366004612abe565b610c5e610848366004612b5e565b60405161085f9190612bea565b610c79610848366004612c25565b60405161085f9190612caa565b610c94610848366004612cfd565b60405161085f9190612d89565b610caf610848366004612de0565b60405160109190910b815260200161085f565b610cd0610848366004612e0d565b604051601c9190910b815260200161085f565b610cf1610848366004612e41565b60405168ffffffffffffffffff909116815260200161085f565b610d19610848366004612e6e565b60405160079190910b815260200161085f565b610d3a610848366004612e89565b60405161085f9190612f15565b610d55610848366004612f60565b604051901515815260200161085f565b610d73610848366004612f7b565b60405161085f9190613007565b610d8e610848366004613058565b60405161085f91906130e4565b610da9610848366004613137565b60405161085f91906131c3565b610dc4610848366004613215565b60405161085f91906132a1565b610de4610ddf3660046132f4565b6118e1565b60408051600093840b81529190920b60208201520161085f565b610e0c61084836600461330f565b60405161085f919061339b565b610e276108483660046133d6565b60405161085f9190613462565b610e426108483660046134b3565b60405161085f919061353f565b610e5d610848366004613593565b60405161085f919061361f565b610e7861084836600461366f565b60405160099190910b815260200161085f565b610e9961084836600461369c565b60405160179190910b815260200161085f565b610eba6108483660046136b7565b60405160149190910b815260200161085f565b610edb6108483660046136e4565b60405161085f9190613770565b610ef66108483660046137ab565b60405160069190910b815260200161085f565b610f176108483660046137d8565b60405161085f9190613864565b610f3261084836600461389f565b60405161085f919061392b565b610f4d610848366004613980565b60405161085f9190613a0c565b610f68610848366004613a67565b6040516001600160681b03909116815260200161085f565b610f8e6108483660046132f4565b60405160009190910b815260200161085f565b610faf610848366004613a99565b60405161085f9190613b25565b610fca610848366004613b66565b6040516001600160d81b03909116815260200161085f565b610ff0610848366004613b96565b60405161085f9190613c22565b61100b610848366004613c73565b604051601b9190910b815260200161085f565b61102c610848366004613ca1565b60405161085f9190613d2d565b611047610848366004613d7c565b60405161085f9190613e08565b611062610848366004613e56565b60405160029190910b815260200161085f565b611083610848366004613e88565b60405161085f9190613f14565b61109e610848366004613f55565b60405161085f9190614005565b6110b9610848366004614067565b60405161085f91906140f3565b6110d461084836600461414b565b6040516001600160b01b03909116815260200161085f565b6110fa610848366004614166565b60405161085f91906141f2565b61111561084836600461422d565b604051600f9190910b815260200161085f565b611136610848366004614248565b60405161085f91906142d4565b611151610848366004614326565b60405161085f91906143b2565b61116c6108483660046143f3565b60405161085f919061447f565b6111876108483660046144ba565b60405161085f919061455d565b6111a26108483660046145b2565b60405160159190910b815260200161085f565b6111c36108483660046145df565b60405160189190910b815260200161085f565b6111e46108483660046145fa565b604051600d9190910b815260200161085f565b61120561084836600461462c565b6040516001600160b81b03909116815260200161085f565b61122b610848366004614647565b604051600b9190910b815260200161085f565b61124c610848366004614662565b60405161085f91906146ee565b61126761084836600461472f565b60405160019190910b815260200161085f565b61128861084836600461474a565b6040516001600160f01b03909116815260200161085f565b6112ae610848366004614765565b60405161085f91906147f1565b6112c961084836600461482c565b60405161ffff909116815260200161085f565b6112ea610848366004614847565b60405161085f91906148d3565b611305610848366004614928565b60405161085f91906149b4565b611320610848366004614a01565b60405160059190910b815260200161085f565b611341610848366004614a1c565b6040516001600160701b03909116815260200161085f565b611367610848366004614a37565b60405161085f9190614ac3565b611382610848366004614b04565b604051600e9190910b815260200161085f565b6113a3610848366004614b1f565b6040516001600160a81b03909116815260200161085f565b6113c9610848366004614b3a565b60405160039190910b815260200161085f565b6113ea610848366004614b55565b6040516001600160881b03909116815260200161085f565b611410610848366004614b70565b6040516001600160c81b03909116815260200161085f565b61143b6114363660046124c1565b6118f9565b6040805192835260208301919091520161085f565b61145e610848366004614b8b565b60405161085f9190614c17565b611479610848366004614c52565b60405160ff909116815260200161085f565b611499610848366004614c6d565b60405161085f9190614cf9565b6114b4610848366004614d34565b6040516affffffffffffffffffffff909116815260200161085f565b6114de610848366004614d4f565b6040516001600160f81b03909116815260200161085f565b611504610848366004614d6a565b60405161085f9190614df6565b61151f610848366004614e31565b60405165ffffffffffff909116815260200161085f565b611544610848366004614e63565b6040516001600160e01b03909116815260200161085f565b61156a610848366004614e7e565b60405161085f9190614f0a565b611585610848366004614f45565b60405161085f9190614fd1565b6115a0610848366004615029565b6040516001600160d01b03909116815260200161085f565b6115cb6115c6366004615044565b611908565b60405161085f9392919061505f565b6115e8610848366004615096565b60405169ffffffffffffffffffff909116815260200161085f565b611616611611366004611c94565b611946565b60408051600493840b81529190920b60208201520161085f565b61163e6108483660046150b1565b6040516001600160401b03909116815260200161085f565b6116646108483660046150e3565b6040516001600160e81b03909116815260200161085f565b61168a6108483660046150fe565b60405161085f919061518a565b6116a56108483660046151c5565b6040516001600160c01b03909116815260200161085f565b6116cb6108483660046151f2565b60405161085f919061527e565b6116e66108483660046152b9565b60405161085f9190615345565b61170161084836600461538d565b60405161085f9190615419565b61171c610848366004615044565b60405163ffffffff909116815260200161085f565b61173f610848366004615454565b60405161085f91906154e0565b61175a61084836600461551b565b60405161085f91906155a7565b6117756108483660046155e2565b60405161085f919061566e565b6117906108483660046156af565b60405161085f919061573b565b6117ab610848366004615776565b60405160089190910b815260200161085f565b6117cc610848366004615791565b60405161085f919061581d565b6117e7610848366004615858565b6040516001600160901b03909116815260200161085f565b61180d610848366004615873565b60405162ffffff909116815260200161085f565b61182f61084836600461588e565b60405161085f919061591a565b61184a61084836600461595b565b60405161085f91906159e7565b611865610848366004615a28565b60405161085f9190615ab4565b61187a611955565b60405161085f9190615af5565b611895610848366004615b27565b60405161085f9190615bb3565b6118b0610848366004615bf4565b60405161085f9190615c80565b6118cb610848366004615cc1565b60405164ffffffffff909116815260200161085f565b600080826118f0816014615cf2565b91509150915091565b600080826118f0816001615d19565b600080606083611919600182615d41565b6040805180820190915260028152614f4b60f01b602082015291945063ffffffff16925090509193909250565b600080826118f0816001615d65565b604080518082019091526060815260006020820152600060405180604001604052908160008201805461198790615d8e565b80601f01602080910402602001604051908101604052809291908181526020018280546119b390615d8e565b8015611a005780601f106119d557610100808354040283529160200191611a00565b820191906000526020600020905b8154815290600101906020018083116119e357829003601f168201915b50505050508152602001600182015481525050905090565b80356001600160801b0381168114611a2f57600080fd5b919050565b600060208284031215611a4657600080fd5b611a4f82611a18565b9392505050565b80356001600160601b0381168114611a2f57600080fd5b600060208284031215611a7f57600080fd5b611a4f82611a56565b8035600c81900b8114611a2f57600080fd5b600060208284031215611aac57600080fd5b611a4f82611a88565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715611af357611af3611ab5565b604052919050565b60006001600160401b03821115611b1457611b14611ab5565b5060051b60200190565b80356001600160f01b0381168114611a2f57600080fd5b60006020808385031215611b4857600080fd5b82356001600160401b03811115611b5e57600080fd5b8301601f81018513611b6f57600080fd5b8035611b82611b7d82611afb565b611acb565b81815260059190911b82018301908381019087831115611ba157600080fd5b928401925b82841015611bc657611bb784611b1e565b82529284019290840190611ba6565b979650505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160f01b031683529284019291840191600101611bed565b50909695505050505050565b80356001600160781b0381168114611a2f57600080fd5b600060208284031215611c4757600080fd5b611a4f82611c1e565b803566ffffffffffffff81168114611a2f57600080fd5b600060208284031215611c7957600080fd5b611a4f82611c50565b8035600481900b8114611a2f57600080fd5b600060208284031215611ca657600080fd5b611a4f82611c82565b8035601181900b8114611a2f57600080fd5b600060208284031215611cd357600080fd5b611a4f82611caf565b8035601e81900b8114611a2f57600080fd5b600060208284031215611d0057600080fd5b611a4f82611cdc565b8035601381900b8114611a2f57600080fd5b600060208284031215611d2d57600080fd5b611a4f82611d09565b600082601f830112611d4757600080fd5b81356001600160401b03811115611d6057611d60611ab5565b611d73601f8201601f1916602001611acb565b818152846020838601011115611d8857600080fd5b816020850160208301376000918101602001919091529392505050565b600060208284031215611db757600080fd5b81356001600160401b03811115611dcd57600080fd5b611dd984828501611d36565b949350505050565b6000815180845260005b81811015611e0757602081850181015186830182015201611deb565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000611a4f6020830184611de1565b80356001600160981b0381168114611a2f57600080fd5b600060208284031215611e6357600080fd5b611a4f82611e3a565b8035600381900b8114611a2f57600080fd5b60006020808385031215611e9157600080fd5b82356001600160401b03811115611ea757600080fd5b8301601f81018513611eb857600080fd5b8035611ec6611b7d82611afb565b81815260059190911b82018301908381019087831115611ee557600080fd5b928401925b82841015611bc657611efb84611e6c565b82529284019290840190611eea565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160030b83529284019291840191600101611f26565b8035601281900b8114611a2f57600080fd5b600060208284031215611f6957600080fd5b611a4f82611f45565b803560ff81168114611a2f57600080fd5b60006020808385031215611f9657600080fd5b82356001600160401b03811115611fac57600080fd5b8301601f81018513611fbd57600080fd5b8035611fcb611b7d82611afb565b81815260059190911b82018301908381019087831115611fea57600080fd5b928401925b82841015611bc65761200084611f72565b82529284019290840190611fef565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160ff168352928401929184019160010161202b565b8035601681900b8114611a2f57600080fd5b60006020828403121561206e57600080fd5b611a4f8261204a565b6001600160a01b038116811461208c57600080fd5b50565b600060208083850312156120a257600080fd5b82356001600160401b038111156120b857600080fd5b8301601f810185136120c957600080fd5b80356120d7611b7d82611afb565b81815260059190911b820183019083810190878311156120f657600080fd5b928401925b82841015611bc657833561210e81612077565b825292840192908401906120fb565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160a01b031683529284019291840191600101612139565b8035601481900b8114611a2f57600080fd5b6000602080838503121561218357600080fd5b82356001600160401b0381111561219957600080fd5b8301601f810185136121aa57600080fd5b80356121b8611b7d82611afb565b81815260059190911b820183019083810190878311156121d757600080fd5b928401925b82841015611bc6576121ed8461215e565b825292840192908401906121dc565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160140b83529284019291840191600101612218565b6000602080838503121561224a57600080fd5b82356001600160401b0381111561226057600080fd5b8301601f8101851361227157600080fd5b803561227f611b7d82611afb565b81815260059190911b8201830190838101908783111561229e57600080fd5b928401925b82841015611bc6576122b484611c50565b825292840192908401906122a3565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835166ffffffffffffff16835292840192918401916001016122df565b80356001600160f81b0381168114611a2f57600080fd5b6000602080838503121561232e57600080fd5b82356001600160401b0381111561234457600080fd5b8301601f8101851361235557600080fd5b8035612363611b7d82611afb565b81815260059190911b8201830190838101908783111561238257600080fd5b928401925b82841015611bc65761239884612304565b82529284019290840190612387565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160f81b0316835292840192918401916001016123c3565b8035600a81900b8114611a2f57600080fd5b6000602080838503121561240d57600080fd5b82356001600160401b0381111561242357600080fd5b8301601f8101851361243457600080fd5b8035612442611b7d82611afb565b81815260059190911b8201830190838101908783111561246157600080fd5b928401925b82841015611bc657612477846123e8565b82529284019290840190612466565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600a0b835292840192918401916001016124a2565b6000602082840312156124d357600080fd5b5035919050565b6000602082840312156124ec57600080fd5b8135611a4f81612077565b80356001600160c81b0381168114611a2f57600080fd5b6000602080838503121561252157600080fd5b82356001600160401b0381111561253757600080fd5b8301601f8101851361254857600080fd5b8035612556611b7d82611afb565b81815260059190911b8201830190838101908783111561257557600080fd5b928401925b82841015611bc65761258b846124f7565b8252928401929084019061257a565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160c81b0316835292840192918401916001016125b6565b600060208083850312156125ee57600080fd5b82356001600160401b0381111561260457600080fd5b8301601f8101851361261557600080fd5b8035612623611b7d82611afb565b81815260059190911b8201830190838101908783111561264257600080fd5b928401925b82841015611bc65761265884611d09565b82529284019290840190612647565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160130b83529284019291840191600101612683565b8035600b81900b8114611a2f57600080fd5b600060208083850312156126c757600080fd5b82356001600160401b038111156126dd57600080fd5b8301601f810185136126ee57600080fd5b80356126fc611b7d82611afb565b81815260059190911b8201830190838101908783111561271b57600080fd5b928401925b82841015611bc657612731846126a2565b82529284019290840190612720565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600b0b8352928401929184019160010161275c565b8035601d81900b8114611a2f57600080fd5b60006020828403121561279f57600080fd5b611a4f8261277b565b6000602082840312156127ba57600080fd5b611a4f826123e8565b8035601981900b8114611a2f57600080fd5b6000602082840312156127e757600080fd5b611a4f826127c3565b80356001600160c01b0381168114611a2f57600080fd5b6000602080838503121561281a57600080fd5b82356001600160401b0381111561283057600080fd5b8301601f8101851361284157600080fd5b803561284f611b7d82611afb565b81815260059190911b8201830190838101908783111561286e57600080fd5b928401925b82841015611bc657612884846127f0565b82529284019290840190612873565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160c01b0316835292840192918401916001016128af565b80356001600160401b0381168114611a2f57600080fd5b600060208083850312156128fe57600080fd5b82356001600160401b0381111561291457600080fd5b8301601f8101851361292557600080fd5b8035612933611b7d82611afb565b81815260059190911b8201830190838101908783111561295257600080fd5b928401925b82841015611bc657612968846128d4565b82529284019290840190612957565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160401b031683529284019291840191600101612993565b8035601a81900b8114611a2f57600080fd5b6000602082840312156129dc57600080fd5b611a4f826129b8565b8035600d81900b8114611a2f57600080fd5b60006020808385031215612a0a57600080fd5b82356001600160401b03811115612a2057600080fd5b8301601f81018513612a3157600080fd5b8035612a3f611b7d82611afb565b81815260059190911b82018301908381019087831115612a5e57600080fd5b928401925b82841015611bc657612a74846129e5565b82529284019290840190612a63565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600d0b83529284019291840191600101612a9f565b60006020808385031215612ad157600080fd5b82356001600160401b03811115612ae757600080fd5b8301601f81018513612af857600080fd5b8035612b06611b7d82611afb565b81815260059190911b82018301908381019087831115612b2557600080fd5b928401925b82841015611bc6578335612b3d81612077565b82529284019290840190612b2a565b8035600181900b8114611a2f57600080fd5b60006020808385031215612b7157600080fd5b82356001600160401b03811115612b8757600080fd5b8301601f81018513612b9857600080fd5b8035612ba6611b7d82611afb565b81815260059190911b82018301908381019087831115612bc557600080fd5b928401925b82841015611bc657612bdb84612b4c565b82529284019290840190612bca565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600190810b8452938501939285019201612c06565b60006020808385031215612c3857600080fd5b82356001600160401b03811115612c4e57600080fd5b8301601f81018513612c5f57600080fd5b8035612c6d611b7d82611afb565b81815260059190911b82018301908381019087831115612c8c57600080fd5b928401925b82841015611bc657833582529284019290840190612c91565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835183529284019291840191600101612cc6565b80356affffffffffffffffffffff81168114611a2f57600080fd5b60006020808385031215612d1057600080fd5b82356001600160401b03811115612d2657600080fd5b8301601f81018513612d3757600080fd5b8035612d45611b7d82611afb565b81815260059190911b82018301908381019087831115612d6457600080fd5b928401925b82841015611bc657612d7a84612ce2565b82529284019290840190612d69565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516affffffffffffffffffffff1683529284019291840191600101612da5565b8035601081900b8114611a2f57600080fd5b600060208284031215612df257600080fd5b611a4f82612dce565b8035601c81900b8114611a2f57600080fd5b600060208284031215612e1f57600080fd5b611a4f82612dfb565b803568ffffffffffffffffff81168114611a2f57600080fd5b600060208284031215612e5357600080fd5b611a4f82612e28565b8035600781900b8114611a2f57600080fd5b600060208284031215612e8057600080fd5b611a4f82612e5c565b60006020808385031215612e9c57600080fd5b82356001600160401b03811115612eb257600080fd5b8301601f81018513612ec357600080fd5b8035612ed1611b7d82611afb565b81815260059190911b82018301908381019087831115612ef057600080fd5b928401925b82841015611bc657612f06846129b8565b82529284019290840190612ef5565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351601a0b83529284019291840191600101612f31565b80358015158114611a2f57600080fd5b600060208284031215612f7257600080fd5b611a4f82612f50565b60006020808385031215612f8e57600080fd5b82356001600160401b03811115612fa457600080fd5b8301601f81018513612fb557600080fd5b8035612fc3611b7d82611afb565b81815260059190911b82018301908381019087831115612fe257600080fd5b928401925b82841015611bc657612ff884612f50565b82529284019290840190612fe7565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351151583529284019291840191600101613023565b80356001600160d81b0381168114611a2f57600080fd5b6000602080838503121561306b57600080fd5b82356001600160401b0381111561308157600080fd5b8301601f8101851361309257600080fd5b80356130a0611b7d82611afb565b81815260059190911b820183019083810190878311156130bf57600080fd5b928401925b82841015611bc6576130d584613041565b825292840192908401906130c4565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160d81b031683529284019291840191600101613100565b8035601581900b8114611a2f57600080fd5b6000602080838503121561314a57600080fd5b82356001600160401b0381111561316057600080fd5b8301601f8101851361317157600080fd5b803561317f611b7d82611afb565b81815260059190911b8201830190838101908783111561319e57600080fd5b928401925b82841015611bc6576131b484613125565b825292840192908401906131a3565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160150b835292840192918401916001016131df565b80356001600160a81b0381168114611a2f57600080fd5b6000602080838503121561322857600080fd5b82356001600160401b0381111561323e57600080fd5b8301601f8101851361324f57600080fd5b803561325d611b7d82611afb565b81815260059190911b8201830190838101908783111561327c57600080fd5b928401925b82841015611bc657613292846131fe565b82529284019290840190613281565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160a81b0316835292840192918401916001016132bd565b8035600081900b8114611a2f57600080fd5b60006020828403121561330657600080fd5b611a4f826132e2565b6000602080838503121561332257600080fd5b82356001600160401b0381111561333857600080fd5b8301601f8101851361334957600080fd5b8035613357611b7d82611afb565b81815260059190911b8201830190838101908783111561337657600080fd5b928401925b82841015611bc65761338c84611caf565b8252928401929084019061337b565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160110b835292840192918401916001016133b7565b600060208083850312156133e957600080fd5b82356001600160401b038111156133ff57600080fd5b8301601f8101851361341057600080fd5b803561341e611b7d82611afb565b81815260059190911b8201830190838101908783111561343d57600080fd5b928401925b82841015611bc6576134538461204a565b82529284019290840190613442565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160160b8352928401929184019160010161347e565b803565ffffffffffff81168114611a2f57600080fd5b600060208083850312156134c657600080fd5b82356001600160401b038111156134dc57600080fd5b8301601f810185136134ed57600080fd5b80356134fb611b7d82611afb565b81815260059190911b8201830190838101908783111561351a57600080fd5b928401925b82841015611bc6576135308461349d565b8252928401929084019061351f565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835165ffffffffffff168352928401929184019160010161355b565b803563ffffffff81168114611a2f57600080fd5b600060208083850312156135a657600080fd5b82356001600160401b038111156135bc57600080fd5b8301601f810185136135cd57600080fd5b80356135db611b7d82611afb565b81815260059190911b820183019083810190878311156135fa57600080fd5b928401925b82841015611bc6576136108461357f565b825292840192908401906135ff565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835163ffffffff168352928401929184019160010161363b565b8035600981900b8114611a2f57600080fd5b60006020828403121561368157600080fd5b611a4f8261365d565b8035601781900b8114611a2f57600080fd5b6000602082840312156136ae57600080fd5b611a4f8261368a565b6000602082840312156136c957600080fd5b611a4f8261215e565b8035600681900b8114611a2f57600080fd5b600060208083850312156136f757600080fd5b82356001600160401b0381111561370d57600080fd5b8301601f8101851361371e57600080fd5b803561372c611b7d82611afb565b81815260059190911b8201830190838101908783111561374b57600080fd5b928401925b82841015611bc657613761846136d2565b82529284019290840190613750565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160060b8352928401929184019160010161378c565b6000602082840312156137bd57600080fd5b611a4f826136d2565b8035600f81900b8114611a2f57600080fd5b600060208083850312156137eb57600080fd5b82356001600160401b0381111561380157600080fd5b8301601f8101851361381257600080fd5b8035613820611b7d82611afb565b81815260059190911b8201830190838101908783111561383f57600080fd5b928401925b82841015611bc657613855846137c6565b82529284019290840190613844565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600f0b83529284019291840191600101613880565b600060208083850312156138b257600080fd5b82356001600160401b038111156138c857600080fd5b8301601f810185136138d957600080fd5b80356138e7611b7d82611afb565b81815260059190911b8201830190838101908783111561390657600080fd5b928401925b82841015611bc65761391c84611cdc565b8252928401929084019061390b565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351601e0b83529284019291840191600101613947565b803569ffffffffffffffffffff81168114611a2f57600080fd5b6000602080838503121561399357600080fd5b82356001600160401b038111156139a957600080fd5b8301601f810185136139ba57600080fd5b80356139c8611b7d82611afb565b81815260059190911b820183019083810190878311156139e757600080fd5b928401925b82841015611bc6576139fd84613966565b825292840192908401906139ec565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835169ffffffffffffffffffff1683529284019291840191600101613a28565b80356001600160681b0381168114611a2f57600080fd5b600060208284031215613a7957600080fd5b611a4f82613a50565b80356001600160701b0381168114611a2f57600080fd5b60006020808385031215613aac57600080fd5b82356001600160401b03811115613ac257600080fd5b8301601f81018513613ad357600080fd5b8035613ae1611b7d82611afb565b81815260059190911b82018301908381019087831115613b0057600080fd5b928401925b82841015611bc657613b1684613a82565b82529284019290840190613b05565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160701b031683529284019291840191600101613b41565b600060208284031215613b7857600080fd5b611a4f82613041565b803564ffffffffff81168114611a2f57600080fd5b60006020808385031215613ba957600080fd5b82356001600160401b03811115613bbf57600080fd5b8301601f81018513613bd057600080fd5b8035613bde611b7d82611afb565b81815260059190911b82018301908381019087831115613bfd57600080fd5b928401925b82841015611bc657613c1384613b81565b82529284019290840190613c02565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835164ffffffffff1683529284019291840191600101613c3e565b8035601b81900b8114611a2f57600080fd5b600060208284031215613c8557600080fd5b611a4f82613c61565b803562ffffff81168114611a2f57600080fd5b60006020808385031215613cb457600080fd5b82356001600160401b03811115613cca57600080fd5b8301601f81018513613cdb57600080fd5b8035613ce9611b7d82611afb565b81815260059190911b82018301908381019087831115613d0857600080fd5b928401925b82841015611bc657613d1e84613c8e565b82529284019290840190613d0d565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835162ffffff1683529284019291840191600101613d49565b803561ffff81168114611a2f57600080fd5b60006020808385031215613d8f57600080fd5b82356001600160401b03811115613da557600080fd5b8301601f81018513613db657600080fd5b8035613dc4611b7d82611afb565b81815260059190911b82018301908381019087831115613de357600080fd5b928401925b82841015611bc657613df984613d6a565b82529284019290840190613de8565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835161ffff1683529284019291840191600101613e24565b8035600281900b8114611a2f57600080fd5b600060208284031215613e6857600080fd5b611a4f82613e44565b80356001600160901b0381168114611a2f57600080fd5b60006020808385031215613e9b57600080fd5b82356001600160401b03811115613eb157600080fd5b8301601f81018513613ec257600080fd5b8035613ed0611b7d82611afb565b81815260059190911b82018301908381019087831115613eef57600080fd5b928401925b82841015611bc657613f0584613e71565b82529284019290840190613ef4565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160901b031683529284019291840191600101613f30565b60006020808385031215613f6857600080fd5b82356001600160401b0380821115613f7f57600080fd5b818501915085601f830112613f9357600080fd5b8135613fa1611b7d82611afb565b81815260059190911b83018401908481019088831115613fc057600080fd5b8585015b83811015613ff857803585811115613fdc5760008081fd5b613fea8b89838a0101611d36565b845250918601918601613fc4565b5098975050505050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561405a57603f19888603018452614048858351611de1565b9450928501929085019060010161402c565b5092979650505050505050565b6000602080838503121561407a57600080fd5b82356001600160401b0381111561409057600080fd5b8301601f810185136140a157600080fd5b80356140af611b7d82611afb565b81815260059190911b820183019083810190878311156140ce57600080fd5b928401925b82841015611bc6576140e484611e3a565b825292840192908401906140d3565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160981b03168352928401929184019160010161410f565b80356001600160b01b0381168114611a2f57600080fd5b60006020828403121561415d57600080fd5b611a4f82614134565b6000602080838503121561417957600080fd5b82356001600160401b0381111561418f57600080fd5b8301601f810185136141a057600080fd5b80356141ae611b7d82611afb565b81815260059190911b820183019083810190878311156141cd57600080fd5b928401925b82841015611bc6576141e384612dce565b825292840192908401906141d2565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160100b8352928401929184019160010161420e565b60006020828403121561423f57600080fd5b611a4f826137c6565b6000602080838503121561425b57600080fd5b82356001600160401b0381111561427157600080fd5b8301601f8101851361428257600080fd5b8035614290611b7d82611afb565b81815260059190911b820183019083810190878311156142af57600080fd5b928401925b82841015611bc6576142c5846127c3565b825292840192908401906142b4565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160190b835292840192918401916001016142f0565b80356001600160881b0381168114611a2f57600080fd5b6000602080838503121561433957600080fd5b82356001600160401b0381111561434f57600080fd5b8301601f8101851361436057600080fd5b803561436e611b7d82611afb565b81815260059190911b8201830190838101908783111561438d57600080fd5b928401925b82841015611bc6576143a38461430f565b82529284019290840190614392565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160881b0316835292840192918401916001016143ce565b6000602080838503121561440657600080fd5b82356001600160401b0381111561441c57600080fd5b8301601f8101851361442d57600080fd5b803561443b611b7d82611afb565b81815260059190911b8201830190838101908783111561445a57600080fd5b928401925b82841015611bc65761447084613c61565b8252928401929084019061445f565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351601b0b8352928401929184019160010161449b565b600060208083850312156144cd57600080fd5b82356001600160401b03808211156144e457600080fd5b818501915085601f8301126144f857600080fd5b8135614506611b7d82611afb565b81815260059190911b8301840190848101908883111561452557600080fd5b8585015b83811015613ff8578035858111156145415760008081fd5b61454f8b89838a0101611d36565b845250918601918601614529565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561405a57603f198886030184526145a0858351611de1565b94509285019290850190600101614584565b6000602082840312156145c457600080fd5b611a4f82613125565b8035601881900b8114611a2f57600080fd5b6000602082840312156145f157600080fd5b611a4f826145cd565b60006020828403121561460c57600080fd5b611a4f826129e5565b80356001600160b81b0381168114611a2f57600080fd5b60006020828403121561463e57600080fd5b611a4f82614615565b60006020828403121561465957600080fd5b611a4f826126a2565b6000602080838503121561467557600080fd5b82356001600160401b0381111561468b57600080fd5b8301601f8101851361469c57600080fd5b80356146aa611b7d82611afb565b81815260059190911b820183019083810190878311156146c957600080fd5b928401925b82841015611bc6576146df84614134565b825292840192908401906146ce565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160b01b03168352928401929184019160010161470a565b60006020828403121561474157600080fd5b611a4f82612b4c565b60006020828403121561475c57600080fd5b611a4f82611b1e565b6000602080838503121561477857600080fd5b82356001600160401b0381111561478e57600080fd5b8301601f8101851361479f57600080fd5b80356147ad611b7d82611afb565b81815260059190911b820183019083810190878311156147cc57600080fd5b928401925b82841015611bc6576147e284611a88565b825292840192908401906147d1565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600c0b8352928401929184019160010161480d565b60006020828403121561483e57600080fd5b611a4f82613d6a565b6000602080838503121561485a57600080fd5b82356001600160401b0381111561487057600080fd5b8301601f8101851361488157600080fd5b803561488f611b7d82611afb565b81815260059190911b820183019083810190878311156148ae57600080fd5b928401925b82841015611bc6576148c484612e28565b825292840192908401906148b3565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835168ffffffffffffffffff16835292840192918401916001016148ef565b8035600e81900b8114611a2f57600080fd5b6000602080838503121561493b57600080fd5b82356001600160401b0381111561495157600080fd5b8301601f8101851361496257600080fd5b8035614970611b7d82611afb565b81815260059190911b8201830190838101908783111561498f57600080fd5b928401925b82841015611bc6576149a584614916565b82529284019290840190614994565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351600e0b835292840192918401916001016149d0565b8035600581900b8114611a2f57600080fd5b600060208284031215614a1357600080fd5b611a4f826149ef565b600060208284031215614a2e57600080fd5b611a4f82613a82565b60006020808385031215614a4a57600080fd5b82356001600160401b03811115614a6057600080fd5b8301601f81018513614a7157600080fd5b8035614a7f611b7d82611afb565b81815260059190911b82018301908381019087831115614a9e57600080fd5b928401925b82841015611bc657614ab484613a50565b82529284019290840190614aa3565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160681b031683529284019291840191600101614adf565b600060208284031215614b1657600080fd5b611a4f82614916565b600060208284031215614b3157600080fd5b611a4f826131fe565b600060208284031215614b4c57600080fd5b611a4f82611e6c565b600060208284031215614b6757600080fd5b611a4f8261430f565b600060208284031215614b8257600080fd5b611a4f826124f7565b60006020808385031215614b9e57600080fd5b82356001600160401b03811115614bb457600080fd5b8301601f81018513614bc557600080fd5b8035614bd3611b7d82611afb565b81815260059190911b82018301908381019087831115614bf257600080fd5b928401925b82841015611bc657614c08846149ef565b82529284019290840190614bf7565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160050b83529284019291840191600101614c33565b600060208284031215614c6457600080fd5b611a4f82611f72565b60006020808385031215614c8057600080fd5b82356001600160401b03811115614c9657600080fd5b8301601f81018513614ca757600080fd5b8035614cb5611b7d82611afb565b81815260059190911b82018301908381019087831115614cd457600080fd5b928401925b82841015611bc657614cea84611f45565b82529284019290840190614cd9565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160120b83529284019291840191600101614d15565b600060208284031215614d4657600080fd5b611a4f82612ce2565b600060208284031215614d6157600080fd5b611a4f82612304565b60006020808385031215614d7d57600080fd5b82356001600160401b03811115614d9357600080fd5b8301601f81018513614da457600080fd5b8035614db2611b7d82611afb565b81815260059190911b82018301908381019087831115614dd157600080fd5b928401925b82841015611bc657614de7846145cd565b82529284019290840190614dd6565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160180b83529284019291840191600101614e12565b600060208284031215614e4357600080fd5b611a4f8261349d565b80356001600160e01b0381168114611a2f57600080fd5b600060208284031215614e7557600080fd5b611a4f82614e4c565b60006020808385031215614e9157600080fd5b82356001600160401b03811115614ea757600080fd5b8301601f81018513614eb857600080fd5b8035614ec6611b7d82611afb565b81815260059190911b82018301908381019087831115614ee557600080fd5b928401925b82841015611bc657614efb8461365d565b82529284019290840190614eea565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160090b83529284019291840191600101614f26565b60006020808385031215614f5857600080fd5b82356001600160401b03811115614f6e57600080fd5b8301601f81018513614f7f57600080fd5b8035614f8d611b7d82611afb565b81815260059190911b82018301908381019087831115614fac57600080fd5b928401925b82841015611bc657614fc284614e4c565b82529284019290840190614fb1565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160e01b031683529284019291840191600101614fed565b80356001600160d01b0381168114611a2f57600080fd5b60006020828403121561503b57600080fd5b611a4f82615012565b60006020828403121561505657600080fd5b611a4f8261357f565b63ffffffff841681526001600160401b038316602082015260606040820152600061508d6060830184611de1565b95945050505050565b6000602082840312156150a857600080fd5b611a4f82613966565b6000602082840312156150c357600080fd5b611a4f826128d4565b80356001600160e81b0381168114611a2f57600080fd5b6000602082840312156150f557600080fd5b611a4f826150cc565b6000602080838503121561511157600080fd5b82356001600160401b0381111561512757600080fd5b8301601f8101851361513857600080fd5b8035615146611b7d82611afb565b81815260059190911b8201830190838101908783111561516557600080fd5b928401925b82841015611bc65761517b84612dfb565b8252928401929084019061516a565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351601c0b835292840192918401916001016151a6565b6000602082840312156151d757600080fd5b611a4f826127f0565b8035600881900b8114611a2f57600080fd5b6000602080838503121561520557600080fd5b82356001600160401b0381111561521b57600080fd5b8301601f8101851361522c57600080fd5b803561523a611b7d82611afb565b81815260059190911b8201830190838101908783111561525957600080fd5b928401925b82841015611bc65761526f846151e0565b8252928401929084019061525e565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160080b8352928401929184019160010161529a565b600060208083850312156152cc57600080fd5b82356001600160401b038111156152e257600080fd5b8301601f810185136152f357600080fd5b8035615301611b7d82611afb565b81815260059190911b8201830190838101908783111561532057600080fd5b928401925b82841015611bc657615336846132e2565b82529284019290840190615325565b602080825282518282018190526000919084820190604085019084805b82811015615380578451820b84529385019392850192600101615362565b5091979650505050505050565b600060208083850312156153a057600080fd5b82356001600160401b038111156153b657600080fd5b8301601f810185136153c757600080fd5b80356153d5611b7d82611afb565b81815260059190911b820183019083810190878311156153f457600080fd5b928401925b82841015611bc65761540a8461277b565b825292840192908401906153f9565b6020808252825182820181905260009190848201906040850190845b81811015611c12578351601d0b83529284019291840191600101615435565b6000602080838503121561546757600080fd5b82356001600160401b0381111561547d57600080fd5b8301601f8101851361548e57600080fd5b803561549c611b7d82611afb565b81815260059190911b820183019083810190878311156154bb57600080fd5b928401925b82841015611bc6576154d184611c82565b825292840192908401906154c0565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160040b835292840192918401916001016154fc565b6000602080838503121561552e57600080fd5b82356001600160401b0381111561554457600080fd5b8301601f8101851361555557600080fd5b8035615563611b7d82611afb565b81815260059190911b8201830190838101908783111561558257600080fd5b928401925b82841015611bc65761559884613e44565b82529284019290840190615587565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160020b835292840192918401916001016155c3565b600060208083850312156155f557600080fd5b82356001600160401b0381111561560b57600080fd5b8301601f8101851361561c57600080fd5b803561562a611b7d82611afb565b81815260059190911b8201830190838101908783111561564957600080fd5b928401925b82841015611bc65761565f846150cc565b8252928401929084019061564e565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160e81b03168352928401929184019160010161568a565b600060208083850312156156c257600080fd5b82356001600160401b038111156156d857600080fd5b8301601f810185136156e957600080fd5b80356156f7611b7d82611afb565b81815260059190911b8201830190838101908783111561571657600080fd5b928401925b82841015611bc65761572c8461368a565b8252928401929084019061571b565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160170b83529284019291840191600101615757565b60006020828403121561578857600080fd5b611a4f826151e0565b600060208083850312156157a457600080fd5b82356001600160401b038111156157ba57600080fd5b8301601f810185136157cb57600080fd5b80356157d9611b7d82611afb565b81815260059190911b820183019083810190878311156157f857600080fd5b928401925b82841015611bc65761580e84612e5c565b825292840192908401906157fd565b6020808252825182820181905260009190848201906040850190845b81811015611c1257835160070b83529284019291840191600101615839565b60006020828403121561586a57600080fd5b611a4f82613e71565b60006020828403121561588557600080fd5b611a4f82613c8e565b600060208083850312156158a157600080fd5b82356001600160401b038111156158b757600080fd5b8301601f810185136158c857600080fd5b80356158d6611b7d82611afb565b81815260059190911b820183019083810190878311156158f557600080fd5b928401925b82841015611bc65761590b84611a18565b825292840192908401906158fa565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160801b031683529284019291840191600101615936565b6000602080838503121561596e57600080fd5b82356001600160401b0381111561598457600080fd5b8301601f8101851361599557600080fd5b80356159a3611b7d82611afb565b81815260059190911b820183019083810190878311156159c257600080fd5b928401925b82841015611bc6576159d884615012565b825292840192908401906159c7565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160d01b031683529284019291840191600101615a03565b60006020808385031215615a3b57600080fd5b82356001600160401b03811115615a5157600080fd5b8301601f81018513615a6257600080fd5b8035615a70611b7d82611afb565b81815260059190911b82018301908381019087831115615a8f57600080fd5b928401925b82841015611bc657615aa584614615565b82529284019290840190615a94565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160b81b031683529284019291840191600101615ad0565b602081526000825160406020840152615b116060840182611de1565b9050602084015160408401528091505092915050565b60006020808385031215615b3a57600080fd5b82356001600160401b03811115615b5057600080fd5b8301601f81018513615b6157600080fd5b8035615b6f611b7d82611afb565b81815260059190911b82018301908381019087831115615b8e57600080fd5b928401925b82841015611bc657615ba484611c1e565b82529284019290840190615b93565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160781b031683529284019291840191600101615bcf565b60006020808385031215615c0757600080fd5b82356001600160401b03811115615c1d57600080fd5b8301601f81018513615c2e57600080fd5b8035615c3c611b7d82611afb565b81815260059190911b82018301908381019087831115615c5b57600080fd5b928401925b82841015611bc657615c7184611a56565b82529284019290840190615c60565b6020808252825182820181905260009190848201906040850190845b81811015611c125783516001600160601b031683529284019291840191600101615c9c565b600060208284031215615cd357600080fd5b611a4f82613b81565b634e487b7160e01b600052601160045260246000fd5b600081810b9083900b01607f8113607f1982121715615d1357615d13615cdc565b92915050565b8082018281126000831280158216821582161715615d3957615d39615cdc565b505092915050565b63ffffffff828116828216039080821115615d5e57615d5e615cdc565b5092915050565b600481810b9083900b01647fffffffff8113647fffffffff1982121715615d1357615d13615cdc565b600181811c90821680615da257607f821691505b602082108103615dc257634e487b7160e01b600052602260045260246000fd5b5091905056fea2646970667358221220a5b87b6881e1a012e4a59d55c230cfcf3a2342b83efdbfb3c5f5cfa532fc854864736f6c63430008120033";
    private static IntegrationTestEnv testEnv;
    private static FileId fileId;
    private static ContractId contractId;

    @BeforeAll
    public static void beforeAll() throws Exception {
        testEnv = new IntegrationTestEnv(1);

        @Var var response = new FileCreateTransaction().setKeys(testEnv.operatorKey).execute(testEnv.client);

        fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

        new FileAppendTransaction().setFileId(fileId).setContents(SMART_CONTRACT_BYTECODE).setMaxChunks(31)
            .execute(testEnv.client);

        response = new ContractCreateTransaction().setAdminKey(testEnv.operatorKey).setGas(1500000)
            .setConstructorParameters(new ContractFunctionParameters()).setBytecodeFileId(fileId)
            .execute(testEnv.client);

        contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);
    }

    @AfterAll
    public static void afterAll() throws Exception {
        new ContractDeleteTransaction().setTransferAccountId(testEnv.operatorId).setContractId(contractId)
            .execute(testEnv.client).getReceipt(testEnv.client);

        new FileDeleteTransaction().setFileId(fileId).execute(testEnv.client).getReceipt(testEnv.client);

        testEnv.close();
    }

    // so we don't get "network is busy" error
    @AfterEach
    public void afterEach() throws InterruptedException {
        Thread.sleep(150);
    }

    @Test
    @DisplayName("Can receive uint8 min value from contract call")
    void canCallContractFunctionUint8Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint8", new ContractFunctionParameters().addUint8((byte) 0x0))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint8(0)).isEqualTo((byte) 0x0);
    }

    @Test
    @DisplayName("Can receive uint8 max value from contract call")
    void canCallContractFunctionUint8Max() throws Exception {
        int uint8Max = 255;
        byte uint8MaxByte = (byte) uint8Max;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint8", new ContractFunctionParameters().addUint8(uint8MaxByte))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint8MaxFromResponse = Byte.toUnsignedInt(response.getUint8(0));

        assertThat(uint8MaxFromResponse).isEqualTo(uint8Max);
    }

    @Test
    @DisplayName("Can receive uint8 array value from contract call")
    void canCallContractFunctionUint8Array() throws Exception {
        byte uint8MinByte = (byte) 0x0;
        int uint8Max = 255;
        byte uint8MaxByte = (byte) uint8Max;
        byte[] uint8Array = {uint8MinByte, uint8MaxByte};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint8Arr", new ContractFunctionParameters().addUint8Array(uint8Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(uint8[])").get(0);

        assertThat(responseResult[0]).isEqualTo(uint8MinByte);
        assertThat(responseResult[1]).isEqualTo(uint8Max);
    }

    @Test
    @DisplayName("Can receive uint16 min value from contract call")
    void canCallContractFunctionUint16Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint16", new ContractFunctionParameters().addUint16(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint32(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint16 max value from contract call")
    void canCallContractFunctionUint16Max() throws Exception {
        var uint16Max = "65535";
        int uint16MaxInt = Integer.parseUnsignedInt(uint16Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint16", new ContractFunctionParameters().addUint16(uint16MaxInt))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint16MaxIntFromResponse = Integer.toUnsignedString(response.getUint32(0));

        assertThat(uint16MaxIntFromResponse).isEqualTo(uint16Max);
    }

    @Test
    @DisplayName("Can receive uint16 array value from contract call")
    void canCallContractFunctionUint16Array() throws Exception {
        int uint16MinInt = 0;
        var uint16Max = "65535";
        int uint16MaxInt = Integer.parseUnsignedInt(uint16Max);
        int[] uint16Array = {uint16MinInt, uint16MaxInt};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint16Arr", new ContractFunctionParameters().addUint16Array(uint16Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(uint16[])").get(0);

        assertThat(responseResult).isEqualTo(uint16Array);
    }

    @Test
    @DisplayName("Can receive uint24 min value from contract call")
    void canCallContractFunctionUint24Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint24", new ContractFunctionParameters().addUint24(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint32(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint24 max value from contract call")
    void canCallContractFunctionUint24Max() throws Exception {
        var uint24Max = "16777215";
        int uint24MaxInt = Integer.parseUnsignedInt(uint24Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint24", new ContractFunctionParameters().addUint24(uint24MaxInt))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint24MaxIntFromResponse = Integer.toUnsignedString(response.getUint32(0));

        assertThat(uint24MaxIntFromResponse).isEqualTo(uint24Max);
    }

    @Test
    @DisplayName("Can receive uint24 array value from contract call")
    void canCallContractFunctionUint24Array() throws Exception {
        int uint24MinInt = 0;
        var uint24Max = "16777215";
        int uint24MaxInt = Integer.parseUnsignedInt(uint24Max);
        int[] uint24Array = {uint24MinInt, uint24MaxInt};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint24Arr", new ContractFunctionParameters().addUint24Array(uint24Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(uint24[])").get(0);

        assertThat(responseResult).isEqualTo(uint24Array);
    }

    @Test
    @DisplayName("Can receive uint32 min value from contract call")
    void canCallContractFunctionUint32Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint32", new ContractFunctionParameters().addUint32(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint32(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint32 max value from contract call")
    void canCallContractFunctionUint32Max() throws Exception {
        var uint32Max = "4294967295";
        int uint32MaxInt = Integer.parseUnsignedInt(uint32Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint32", new ContractFunctionParameters().addUint32(uint32MaxInt))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint32MaxIntFromResponse = Integer.toUnsignedString(response.getUint32(0));

        assertThat(uint32MaxIntFromResponse).isEqualTo(uint32Max);
    }

    @Test
    @DisplayName("Can receive uint32 array value from contract call")
    void canCallContractFunctionUint32Array() throws Exception {
        int uint32MinInt = 0;
        var uint32Max = "4294967295";
        int uint32MaxInt = Integer.parseUnsignedInt(uint32Max);
        int[] uint32Array = {uint32MinInt, uint32MaxInt};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint32Arr", new ContractFunctionParameters().addUint32Array(uint32Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(uint32[])").get(0);

        assertThat(responseResult[0]).isEqualTo(uint32MinInt);
        assertThat(responseResult[1]).isEqualTo(Long.parseUnsignedLong(uint32Max));
    }

    @Test
    @DisplayName("Can receive uint40 min value from contract call")
    void canCallContractFunctionUint40Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint40", new ContractFunctionParameters().addUint40(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint64(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint40 max value from contract call")
    void canCallContractFunctionUint40Max() throws Exception {
        var uint40Max = "109951162777";
        long uint40MaxLong = Long.parseUnsignedLong(uint40Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint40", new ContractFunctionParameters().addUint40(uint40MaxLong))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint64MaxLongFromResponse = Long.toUnsignedString(response.getUint64(0));

        assertThat(uint64MaxLongFromResponse).isEqualTo(uint40Max);
    }

    @Test
    @DisplayName("Can receive uint40 array value from contract call")
    void canCallContractFunctionUint40Array() throws Exception {
        long uint40MinLong = 0;
        var uint40Max = "109951162777";
        long uint40MaxLong = Long.parseUnsignedLong(uint40Max);
        long[] uint40Array = {uint40MinLong, uint40MaxLong};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint40Arr", new ContractFunctionParameters().addUint40Array(uint40Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(uint40[])").get(0);

        assertThat(responseResult).isEqualTo(uint40Array);
    }

    @Test
    @DisplayName("Can receive uint48 min value from contract call")
    void canCallContractFunctionUint48Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint48", new ContractFunctionParameters().addUint48(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint64(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint48 max value from contract call")
    void canCallContractFunctionUint48Max() throws Exception {
        var uint48Max = "281474976710655";
        long uint48MaxLong = Long.parseUnsignedLong(uint48Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint48", new ContractFunctionParameters().addUint48(uint48MaxLong))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint64MaxLongFromResponse = Long.toUnsignedString(response.getUint64(0));

        assertThat(uint64MaxLongFromResponse).isEqualTo(uint48Max);
    }

    @Test
    @DisplayName("Can receive uint48 array value from contract call")
    void canCallContractFunctionUint48Array() throws Exception {
        long uint48MinLong = 0;
        var uint48Max = "281474976710655";
        long uint48MaxLong = Long.parseUnsignedLong(uint48Max);
        long[] uint48Array = {uint48MinLong, uint48MaxLong};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint48Arr", new ContractFunctionParameters().addUint48Array(uint48Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(uint48[])").get(0);

        assertThat(responseResult).isEqualTo(uint48Array);
    }

    @Test
    @DisplayName("Can receive uint56 min value from contract call")
    void canCallContractFunctionUint56Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint56", new ContractFunctionParameters().addUint56(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint64(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint56 max value from contract call")
    void canCallContractFunctionUint56Max() throws Exception {
        var uint56Max = "72057594037927935";
        long uint56MaxLong = Long.parseUnsignedLong(uint56Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint56", new ContractFunctionParameters().addUint56(uint56MaxLong))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint64MaxLongFromResponse = Long.toUnsignedString(response.getUint64(0));

        assertThat(uint64MaxLongFromResponse).isEqualTo(uint56Max);
    }

    @Test
    @DisplayName("Can receive uint56 array value from contract call")
    void canCallContractFunctionUint56Array() throws Exception {
        long uint56MinLong = 0;
        var uint56Max = "72057594037927935";
        long uint56MaxLong = Long.parseUnsignedLong(uint56Max);
        long[] uint56Array = {uint56MinLong, uint56MaxLong};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint56Arr", new ContractFunctionParameters().addUint56Array(uint56Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(uint56[])").get(0);

        assertThat(responseResult).isEqualTo(uint56Array);
    }

    @Test
    @DisplayName("Can receive uint64 min value from contract call")
    void canCallContractFunctionUint64Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint64", new ContractFunctionParameters().addUint64(0)).setQueryPayment(new Hbar(10))
            .execute(testEnv.client);

        assertThat(response.getUint64(0)).isEqualTo(0);
    }

    @Test
    @DisplayName("Can receive uint64 max value from contract call")
    void canCallContractFunctionUint64Max() throws Exception {
        var uint64Max = "9223372036854775807";
        long uint64MaxLong = Long.parseUnsignedLong(uint64Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint64", new ContractFunctionParameters().addUint64(uint64MaxLong))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var uint64MaxLongFromResponse = Long.toUnsignedString(response.getUint64(0));

        assertThat(uint64MaxLongFromResponse).isEqualTo(uint64Max);
    }

    @Test
    @DisplayName("Can receive uint64 array value from contract call")
    void canCallContractFunctionUint64Array() throws Exception {
        long uint64MinLong = 0;
        var uint64Max = "9223372036854775807";
        long uint64MaxLong = Long.parseUnsignedLong(uint64Max);
        long[] uint64Array = {uint64MinLong, uint64MaxLong};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint64Arr", new ContractFunctionParameters().addUint64Array(uint64Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint64[])").get(0);

        assertThat(responseResult[0]).isEqualTo(uint64MinLong);
        assertThat(responseResult[1]).isEqualTo(Long.parseUnsignedLong(uint64Max));
    }

    @Test
    @DisplayName("Can receive uint72 min value from contract call")
    void canCallContractFunctionUint72Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint72", new ContractFunctionParameters().addUint72(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint72 max value from contract call")
    void canCallContractFunctionUint72Max() throws Exception {
        BigInteger uint72Max = new BigInteger("4722366482869645213695");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint72", new ContractFunctionParameters().addUint72(uint72Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint72Max);
    }

    @Test
    @DisplayName("Can receive uint72 array value from contract call")
    void canCallContractFunctionUint72Array() throws Exception {
        BigInteger uint72Min = BigInteger.ZERO;
        BigInteger uint72Max = new BigInteger("4722366482869645213695");
        BigInteger[] uint72Array = {uint72Min, uint72Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint72Arr", new ContractFunctionParameters().addUint72Array(uint72Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint72[])").get(0);

        assertThat(responseResult).isEqualTo(uint72Array);
    }

    @Test
    @DisplayName("Can receive uint80 min value from contract call")
    void canCallContractFunctionUint80Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint80", new ContractFunctionParameters().addUint80(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint80 max value from contract call")
    void canCallContractFunctionUint80Max() throws Exception {
        BigInteger uint80Max = new BigInteger("1208925819614629174706175");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint80", new ContractFunctionParameters().addUint80(uint80Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint80Max);
    }

    @Test
    @DisplayName("Can receive uint80 array value from contract call")
    void canCallContractFunctionUint80Array() throws Exception {
        BigInteger uint80Min = BigInteger.ZERO;
        BigInteger uint80Max = new BigInteger("1208925819614629174706175");
        BigInteger[] uint80Array = {uint80Min, uint80Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint80Arr", new ContractFunctionParameters().addUint80Array(uint80Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint80[])").get(0);

        assertThat(responseResult).isEqualTo(uint80Array);
    }

    @Test
    @DisplayName("Can receive uint88 min value from contract call")
    void canCallContractFunctionUint88Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint88", new ContractFunctionParameters().addUint88(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint88 max value from contract call")
    void canCallContractFunctionUint88Max() throws Exception {
        BigInteger uint88Max = new BigInteger("309485009821345068724781055");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint88", new ContractFunctionParameters().addUint88(uint88Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint88Max);
    }

    @Test
    @DisplayName("Can receive uint88 array value from contract call")
    void canCallContractFunctionUint88Array() throws Exception {
        BigInteger uint88Min = BigInteger.ZERO;
        BigInteger uint88Max = new BigInteger("309485009821345068724781055");
        BigInteger[] uint88Array = {uint88Min, uint88Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint88Arr", new ContractFunctionParameters().addUint88Array(uint88Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint88[])").get(0);

        assertThat(responseResult).isEqualTo(uint88Array);
    }

    @Test
    @DisplayName("Can receive uint96 min value from contract call")
    void canCallContractFunctionUint96Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint96", new ContractFunctionParameters().addUint96(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint96 max value from contract call")
    void canCallContractFunctionUint96Max() throws Exception {
        BigInteger uint96Max = new BigInteger("79228162514264337593543950335");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint96", new ContractFunctionParameters().addUint96(uint96Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint96Max);
    }

    @Test
    @DisplayName("Can receive uint96 array value from contract call")
    void canCallContractFunctionUint96Array() throws Exception {
        BigInteger uint96Min = BigInteger.ZERO;
        BigInteger uint96Max = new BigInteger("79228162514264337593543950335");
        BigInteger[] uint96Array = {uint96Min, uint96Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint96Arr", new ContractFunctionParameters().addUint96Array(uint96Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint96[])").get(0);

        assertThat(responseResult).isEqualTo(uint96Array);
    }

    @Test
    @DisplayName("Can receive uint104 min value from contract call")
    void canCallContractFunctionUint104Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint104", new ContractFunctionParameters().addUint104(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint104 max value from contract call")
    void canCallContractFunctionUint104Max() throws Exception {
        BigInteger uint104Max = new BigInteger("20282409603651670423947251286015");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint104", new ContractFunctionParameters().addUint104(uint104Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint104Max);
    }

    @Test
    @DisplayName("Can receive uint104 array value from contract call")
    void canCallContractFunctionUint104Array() throws Exception {
        BigInteger uint104Min = BigInteger.ZERO;
        BigInteger uint104Max = new BigInteger("20282409603651670423947251286015");
        BigInteger[] uint104Array = {uint104Min, uint104Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint104Arr", new ContractFunctionParameters().addUint104Array(uint104Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint104[])").get(0);

        assertThat(responseResult).isEqualTo(uint104Array);
    }

    @Test
    @DisplayName("Can receive uint112 min value from contract call")
    void canCallContractFunctionUint112Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint112", new ContractFunctionParameters().addUint112(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint112 max value from contract call")
    void canCallContractFunctionUint112Max() throws Exception {
        BigInteger uint112Max = new BigInteger("5192296858534827628530496329220095");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint112", new ContractFunctionParameters().addUint112(uint112Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint112Max);
    }

    @Test
    @DisplayName("Can receive uint112 array value from contract call")
    void canCallContractFunctionUint112Array() throws Exception {
        BigInteger uint112Min = BigInteger.ZERO;
        BigInteger uint112Max = new BigInteger("5192296858534827628530496329220095");
        BigInteger[] uint112Array = {uint112Min, uint112Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint112Arr", new ContractFunctionParameters().addUint112Array(uint112Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint112[])").get(0);

        assertThat(responseResult).isEqualTo(uint112Array);
    }

    @Test
    @DisplayName("Can receive uint120 min value from contract call")
    void canCallContractFunctionUint120Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint120", new ContractFunctionParameters().addUint120(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint120 max value from contract call")
    void canCallContractFunctionUint120Max() throws Exception {
        BigInteger uint120Max = new BigInteger("1329227995784915872903807060280344575");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint120", new ContractFunctionParameters().addUint120(uint120Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint120Max);
    }

    @Test
    @DisplayName("Can receive uint120 array value from contract call")
    void canCallContractFunctionUint120Array() throws Exception {
        BigInteger uint120Min = BigInteger.ZERO;
        BigInteger uint120Max = new BigInteger("1329227995784915872903807060280344575");
        BigInteger[] uint120Array = {uint120Min, uint120Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint120Arr", new ContractFunctionParameters().addUint120Array(uint120Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint120[])").get(0);

        assertThat(responseResult).isEqualTo(uint120Array);
    }

    @Test
    @DisplayName("Can receive uint128 min value from contract call")
    void canCallContractFunctionUint128Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint128", new ContractFunctionParameters().addUint128(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint128 max value from contract call")
    void canCallContractFunctionUint128Max() throws Exception {
        BigInteger uint128Max = new BigInteger("340282366920938463463374607431768211455");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint128", new ContractFunctionParameters().addUint128(uint128Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint128Max);
    }

    @Test
    @DisplayName("Can receive uint128 array value from contract call")
    void canCallContractFunctionUint128Array() throws Exception {
        BigInteger uint128Min = BigInteger.ZERO;
        BigInteger uint128Max = new BigInteger("340282366920938463463374607431768211455");
        BigInteger[] uint128Array = {uint128Min, uint128Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint128Arr", new ContractFunctionParameters().addUint128Array(uint128Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint128[])").get(0);

        assertThat(responseResult).isEqualTo(uint128Array);
    }

    @Test
    @DisplayName("Can receive uint136 min value from contract call")
    void canCallContractFunctionUint136Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint136", new ContractFunctionParameters().addUint136(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint136 max value from contract call")
    void canCallContractFunctionUint136Max() throws Exception {
        BigInteger uint136Max = new BigInteger("87112285931760246646623899502532662132735");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint136", new ContractFunctionParameters().addUint136(uint136Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint136Max);
    }

    @Test
    @DisplayName("Can receive uint136 array value from contract call")
    void canCallContractFunctionUint136Array() throws Exception {
        BigInteger uint136Min = BigInteger.ZERO;
        BigInteger uint136Max = new BigInteger("87112285931760246646623899502532662132735");
        BigInteger[] uint136Array = {uint136Min, uint136Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint136Arr", new ContractFunctionParameters().addUint136Array(uint136Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint136[])").get(0);

        assertThat(responseResult).isEqualTo(uint136Array);
    }

    @Test
    @DisplayName("Can receive uint144 min value from contract call")
    void canCallContractFunctionUint144Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint144", new ContractFunctionParameters().addUint144(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint144 max value from contract call")
    void canCallContractFunctionUint144Max() throws Exception {
        BigInteger uint144Max = new BigInteger("22300745198530623141535718272648361505980415");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint144", new ContractFunctionParameters().addUint144(uint144Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint144Max);
    }

    @Test
    @DisplayName("Can receive uint144 array value from contract call")
    void canCallContractFunctionUint144Array() throws Exception {
        BigInteger uint144Min = BigInteger.ZERO;
        BigInteger uint144Max = new BigInteger("22300745198530623141535718272648361505980415");
        BigInteger[] uint144Array = {uint144Min, uint144Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint144Arr", new ContractFunctionParameters().addUint144Array(uint144Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint144[])").get(0);

        assertThat(responseResult).isEqualTo(uint144Array);
    }

    @Test
    @DisplayName("Can receive uint152 min value from contract call")
    void canCallContractFunctionUint152Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint152", new ContractFunctionParameters().addUint152(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint152 max value from contract call")
    void canCallContractFunctionUint152Max() throws Exception {
        BigInteger uint152Max = new BigInteger("5708990770823839524233143877797980545530986495");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint152", new ContractFunctionParameters().addUint152(uint152Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint152Max);
    }

    @Test
    @DisplayName("Can receive uint152 array value from contract call")
    void canCallContractFunctionUint152Array() throws Exception {
        BigInteger uint152Min = BigInteger.ZERO;
        BigInteger uint152Max = new BigInteger("5708990770823839524233143877797980545530986495");
        BigInteger[] uint152Array = {uint152Min, uint152Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint152Arr", new ContractFunctionParameters().addUint152Array(uint152Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint152[])").get(0);

        assertThat(responseResult).isEqualTo(uint152Array);
    }

    @Test
    @DisplayName("Can receive uint160 min value from contract call")
    void canCallContractFunctionUint160Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint160", new ContractFunctionParameters().addUint160(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint160 max value from contract call")
    void canCallContractFunctionUint160Max() throws Exception {
        BigInteger uint160Max = new BigInteger("1461501637330902918203684832716283019655932542975");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint160", new ContractFunctionParameters().addUint160(uint160Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint160Max);
    }

    @Test
    @DisplayName("Can receive uint160 array value from contract call")
    void canCallContractFunctionUint160Array() throws Exception {
        BigInteger uint160Min = BigInteger.ZERO;
        BigInteger uint160Max = new BigInteger("1461501637330902918203684832716283019655932542975");
        BigInteger[] uint160Array = {uint160Min, uint160Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint160Arr", new ContractFunctionParameters().addUint160Array(uint160Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint160[])").get(0);

        assertThat(responseResult).isEqualTo(uint160Array);
    }

    @Test
    @DisplayName("Can receive uint168 min value from contract call")
    void canCallContractFunctionUint168Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint168", new ContractFunctionParameters().addUint168(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint168 max value from contract call")
    void canCallContractFunctionUint168Max() throws Exception {
        BigInteger uint168Max = new BigInteger("374144419156711147060143317175368453031918731001855");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint168", new ContractFunctionParameters().addUint168(uint168Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint168Max);
    }

    @Test
    @DisplayName("Can receive uint168 array value from contract call")
    void canCallContractFunctionUint168Array() throws Exception {
        BigInteger uint168Min = BigInteger.ZERO;
        BigInteger uint168Max = new BigInteger("374144419156711147060143317175368453031918731001855");
        BigInteger[] uint168Array = {uint168Min, uint168Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint168Arr", new ContractFunctionParameters().addUint168Array(uint168Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint168[])").get(0);

        assertThat(responseResult).isEqualTo(uint168Array);
    }

    @Test
    @DisplayName("Can receive uint176 min value from contract call")
    void canCallContractFunctionUint176Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint176", new ContractFunctionParameters().addUint176(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint176 max value from contract call")
    void canCallContractFunctionUint176Max() throws Exception {
        BigInteger uint176Max = new BigInteger("95780971304118053647396689196894323976171195136475135");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint176", new ContractFunctionParameters().addUint176(uint176Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint176Max);
    }

    @Test
    @DisplayName("Can receive uint176 array value from contract call")
    void canCallContractFunctionUint176Array() throws Exception {
        BigInteger uint176Min = BigInteger.ZERO;
        BigInteger uint176Max = new BigInteger("95780971304118053647396689196894323976171195136475135");
        BigInteger[] uint176Array = {uint176Min, uint176Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint176Arr", new ContractFunctionParameters().addUint176Array(uint176Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint176[])").get(0);

        assertThat(responseResult).isEqualTo(uint176Array);
    }

    @Test
    @DisplayName("Can receive uint184 min value from contract call")
    void canCallContractFunctionUint184Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint184", new ContractFunctionParameters().addUint184(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint184 max value from contract call")
    void canCallContractFunctionUint184Max() throws Exception {
        BigInteger uint184Max = new BigInteger("24519928653854221733733552434404946937899825954937634815");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint184", new ContractFunctionParameters().addUint184(uint184Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint184Max);
    }

    @Test
    @DisplayName("Can receive uint184 array value from contract call")
    void canCallContractFunctionUint184Array() throws Exception {
        BigInteger uint184Min = BigInteger.ZERO;
        BigInteger uint184Max = new BigInteger("24519928653854221733733552434404946937899825954937634815");
        BigInteger[] uint184Array = {uint184Min, uint184Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint184Arr", new ContractFunctionParameters().addUint184Array(uint184Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint184[])").get(0);

        assertThat(responseResult).isEqualTo(uint184Array);
    }

    @Test
    @DisplayName("Can receive uint192 min value from contract call")
    void canCallContractFunctionUint192Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint192", new ContractFunctionParameters().addUint192(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint192 max value from contract call")
    void canCallContractFunctionUint192Max() throws Exception {
        BigInteger uint192Max = new BigInteger("6277101735386680763835789423207666416102355444464034512895");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint192", new ContractFunctionParameters().addUint192(uint192Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint192Max);
    }

    @Test
    @DisplayName("Can receive uint192 array value from contract call")
    void canCallContractFunctionUint192Array() throws Exception {
        BigInteger uint192Min = BigInteger.ZERO;
        BigInteger uint192Max = new BigInteger("6277101735386680763835789423207666416102355444464034512895");
        BigInteger[] uint192Array = {uint192Min, uint192Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint192Arr", new ContractFunctionParameters().addUint192Array(uint192Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint192[])").get(0);

        assertThat(responseResult).isEqualTo(uint192Array);
    }

    @Test
    @DisplayName("Can receive uint200 min value from contract call")
    void canCallContractFunctionUint200Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint200", new ContractFunctionParameters().addUint200(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint200 max value from contract call")
    void canCallContractFunctionUint200Max() throws Exception {
        BigInteger uint200Max = new BigInteger("1606938044258990275541962092341162602522202993782792835301375");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint200", new ContractFunctionParameters().addUint200(uint200Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint200Max);
    }

    @Test
    @DisplayName("Can receive uint200 array value from contract call")
    void canCallContractFunctionUint200Array() throws Exception {
        BigInteger uint200Min = BigInteger.ZERO;
        BigInteger uint200Max = new BigInteger("1606938044258990275541962092341162602522202993782792835301375");
        BigInteger[] uint200Array = {uint200Min, uint200Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint200Arr", new ContractFunctionParameters().addUint200Array(uint200Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint200[])").get(0);

        assertThat(responseResult).isEqualTo(uint200Array);
    }

    @Test
    @DisplayName("Can receive uint208 min value from contract call")
    void canCallContractFunctionUint208Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint208", new ContractFunctionParameters().addUint208(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint208 max value from contract call")
    void canCallContractFunctionUint208Max() throws Exception {
        BigInteger uint208Max = new BigInteger("411376139330301510538742295639337626245683966408394965837152255");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint208", new ContractFunctionParameters().addUint208(uint208Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint208Max);
    }

    @Test
    @DisplayName("Can receive uint208 array value from contract call")
    void canCallContractFunctionUint208Array() throws Exception {
        BigInteger uint208Min = BigInteger.ZERO;
        BigInteger uint208Max = new BigInteger("411376139330301510538742295639337626245683966408394965837152255");
        BigInteger[] uint208Array = {uint208Min, uint208Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint208Arr", new ContractFunctionParameters().addUint208Array(uint208Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint208[])").get(0);

        assertThat(responseResult).isEqualTo(uint208Array);
    }

    @Test
    @DisplayName("Can receive uint216 min value from contract call")
    void canCallContractFunctionUint216Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint216", new ContractFunctionParameters().addUint216(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint216 max value from contract call")
    void canCallContractFunctionUint216Max() throws Exception {
        BigInteger uint216Max = new BigInteger("105312291668557186697918027683670432318895095400549111254310977535");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint216", new ContractFunctionParameters().addUint216(uint216Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint216Max);
    }

    @Test
    @DisplayName("Can receive uint216 array value from contract call")
    void canCallContractFunctionUint216Array() throws Exception {
        BigInteger uint216Min = BigInteger.ZERO;
        BigInteger uint216Max = new BigInteger("105312291668557186697918027683670432318895095400549111254310977535");
        BigInteger[] uint216Array = {uint216Min, uint216Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint216Arr", new ContractFunctionParameters().addUint216Array(uint216Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint216[])").get(0);

        assertThat(responseResult).isEqualTo(uint216Array);
    }

    @Test
    @DisplayName("Can receive uint224 min value from contract call")
    void canCallContractFunctionUint224Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint224", new ContractFunctionParameters().addUint224(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint224 max value from contract call")
    void canCallContractFunctionUint224Max() throws Exception {
        BigInteger uint224Max = new BigInteger("26959946667150639794667015087019630673637144422540572481103610249215");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint224", new ContractFunctionParameters().addUint224(uint224Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint224Max);
    }

    @Test
    @DisplayName("Can receive uint224 array value from contract call")
    void canCallContractFunctionUint224Array() throws Exception {
        BigInteger uint224Min = BigInteger.ZERO;
        BigInteger uint224Max = new BigInteger("26959946667150639794667015087019630673637144422540572481103610249215");
        BigInteger[] uint224Array = {uint224Min, uint224Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint224Arr", new ContractFunctionParameters().addUint224Array(uint224Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint224[])").get(0);

        assertThat(responseResult).isEqualTo(uint224Array);
    }

    @Test
    @DisplayName("Can receive uint232 min value from contract call")
    void canCallContractFunctionUint232Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint232", new ContractFunctionParameters().addUint232(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint232 max value from contract call")
    void canCallContractFunctionUint232Max() throws Exception {
        BigInteger uint232Max = new BigInteger(
            "6901746346790563787434755862277025452451108972170386555162524223799295");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint232", new ContractFunctionParameters().addUint232(uint232Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint232Max);
    }

    @Test
    @DisplayName("Can receive uint232 array value from contract call")
    void canCallContractFunctionUint232Array() throws Exception {
        BigInteger uint232Min = BigInteger.ZERO;
        BigInteger uint232Max = new BigInteger(
            "6901746346790563787434755862277025452451108972170386555162524223799295");
        BigInteger[] uint232Array = {uint232Min, uint232Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint232Arr", new ContractFunctionParameters().addUint232Array(uint232Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint232[])").get(0);

        assertThat(responseResult).isEqualTo(uint232Array);
    }

    @Test
    @DisplayName("Can receive uint240 min value from contract call")
    void canCallContractFunctionUint240Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint240", new ContractFunctionParameters().addUint240(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint240 max value from contract call")
    void canCallContractFunctionUint240Max() throws Exception {
        BigInteger uint240Max = new BigInteger(
            "1766847064778384329583297500742918515827483896875618958121606201292619775");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint240", new ContractFunctionParameters().addUint240(uint240Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint240Max);
    }

    @Test
    @DisplayName("Can receive uint240 array value from contract call")
    void canCallContractFunctionUint240Array() throws Exception {
        BigInteger uint240Min = BigInteger.ZERO;
        BigInteger uint240Max = new BigInteger(
            "1766847064778384329583297500742918515827483896875618958121606201292619775");
        BigInteger[] uint240Array = {uint240Min, uint240Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint240Arr", new ContractFunctionParameters().addUint240Array(uint240Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint240[])").get(0);

        assertThat(responseResult).isEqualTo(uint240Array);
    }

    @Test
    @DisplayName("Can receive uint248 min value from contract call")
    void canCallContractFunctionUint248Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint248", new ContractFunctionParameters().addUint248(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint248 max value from contract call")
    void canCallContractFunctionUint248Max() throws Exception {
        BigInteger uint248Max = new BigInteger(
            "452312848583266388373324160190187140051835877600158453279131187530910662655");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint248", new ContractFunctionParameters().addUint248(uint248Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint248Max);
    }

    @Test
    @DisplayName("Can receive uint248 array value from contract call")
    void canCallContractFunctionUint248Array() throws Exception {
        BigInteger uint248Min = BigInteger.ZERO;
        BigInteger uint248Max = new BigInteger(
            "452312848583266388373324160190187140051835877600158453279131187530910662655");
        BigInteger[] uint248Array = {uint248Min, uint248Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint248Arr", new ContractFunctionParameters().addUint248Array(uint248Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint248[])").get(0);

        assertThat(responseResult).isEqualTo(uint248Array);
    }

    @Test
    @DisplayName("Can receive uint256 min value from contract call")
    void canCallContractFunctionUint256Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint256", new ContractFunctionParameters().addUint256(BigInteger.ZERO))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(BigInteger.ZERO);
    }

    @Test
    @DisplayName("Can receive uint256 max value from contract call")
    void canCallContractFunctionUint256Max() throws Exception {
        BigInteger uint256Max = new BigInteger("2").pow(256).subtract(BigInteger.ONE);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint256", new ContractFunctionParameters().addUint256(uint256Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint256(0)).isEqualTo(uint256Max);
    }

    @Test
    @DisplayName("Can receive uint256 array value from contract call")
    void canCallContractFunctionUint256Array() throws Exception {
        BigInteger uint256Min = BigInteger.ZERO;
        BigInteger uint256Max = new BigInteger("2").pow(256).subtract(BigInteger.ONE);
        BigInteger[] uint256Array = {uint256Min, uint256Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint256Arr", new ContractFunctionParameters().addUint256Array(uint256Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(uint256[])").get(0);

        assertThat(responseResult).isEqualTo(uint256Array);
    }

    @Test
    @DisplayName("Can receive int8 min value from contract call")
    void canCallContractFunctionInt8Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt8", new ContractFunctionParameters().addInt8(Byte.MIN_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt8(0)).isEqualTo(Byte.MIN_VALUE);
    }

    @Test
    @DisplayName("Can receive int8 max value from contract call")
    void canCallContractFunctionInt8Max() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt8", new ContractFunctionParameters().addInt8(Byte.MAX_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt8(0)).isEqualTo(Byte.MAX_VALUE);
    }

    @Test
    @DisplayName("Can receive int8 array value from contract call")
    void canCallContractFunctionInt8Array() throws Exception {
        byte[] int8Array = {Byte.MIN_VALUE, Byte.MAX_VALUE};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt8Arr", new ContractFunctionParameters().addInt8Array(int8Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(int8[])").get(0);

        assertThat(responseResult[0]).isEqualTo(int8Array[0]);
        assertThat(responseResult[1]).isEqualTo(int8Array[1]);
    }

    @Test
    @DisplayName("Can receive int16 min value from contract call")
    void canCallContractFunctionInt16Min() throws Exception {
        int int16Min = -32768;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt16", new ContractFunctionParameters().addInt16(int16Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt32(0)).isEqualTo(int16Min);
    }

    @Test
    @DisplayName("Can receive int16 max value from contract call")
    void canCallContractFunctionInt16Max() throws Exception {
        int int16Max = 32767;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt16", new ContractFunctionParameters().addInt16(int16Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt32(0)).isEqualTo(int16Max);
    }

    @Test
    @DisplayName("Can receive int16 array value from contract call")
    void canCallContractFunctionInt16Array() throws Exception {
        int int16Min = -32768;
        int int16Max = 32767;
        int[] int16Array = {int16Min, int16Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt16Arr", new ContractFunctionParameters().addInt16Array(int16Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(int16[])").get(0);

        assertThat(responseResult).isEqualTo(int16Array);
    }

    @Test
    @DisplayName("Can receive int24 min value from contract call")
    void canCallContractFunctionInt24Min() throws Exception {
        int int24Min = -8388608;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt24", new ContractFunctionParameters().addInt24(int24Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt32(0)).isEqualTo(int24Min);
    }

    @Test
    @DisplayName("Can receive int24 max value from contract call")
    void canCallContractFunctionInt24Max() throws Exception {
        int int24Max = 8388607;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt24", new ContractFunctionParameters().addInt24(int24Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt32(0)).isEqualTo(int24Max);
    }

    @Test
    @DisplayName("Can receive int24 array value from contract call")
    void canCallContractFunctionInt24Array() throws Exception {
        int int24Min = -8388608;
        int int24Max = 8388607;
        int[] int24Array = {int24Min, int24Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt24Arr", new ContractFunctionParameters().addInt24Array(int24Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(int24[])").get(0);

        assertThat(responseResult).isEqualTo(int24Array);
    }

    @Test
    @DisplayName("Can receive int32 min value from contract call")
    void canCallContractFunctionInt32Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt32", new ContractFunctionParameters().addInt32(Integer.MIN_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt32(0)).isEqualTo(Integer.MIN_VALUE);
    }

    @Test
    @DisplayName("Can receive int32 max value from contract call")
    void canCallContractFunctionInt32Max() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt32", new ContractFunctionParameters().addInt32(Integer.MAX_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt32(0)).isEqualTo(Integer.MAX_VALUE);
    }

    @Test
    @DisplayName("Can receive int32 array value from contract call")
    void canCallContractFunctionInt32Array() throws Exception {
        int int32Min = Integer.MIN_VALUE;
        int int32Max = Integer.MAX_VALUE;
        int[] int32Array = {int32Min, int32Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt32Arr", new ContractFunctionParameters().addInt32Array(int32Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (int[]) response.getResult("(int32[])").get(0);

        assertThat(responseResult).isEqualTo(int32Array);
    }

    @Test
    @DisplayName("Can receive int40 min value from contract call")
    void canCallContractFunctionInt40Min() throws Exception {
        long int40Min = -549755813888L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt40", new ContractFunctionParameters().addInt40(int40Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int40Min);
    }

    @Test
    @DisplayName("Can receive int40 max value from contract call")
    void canCallContractFunctionInt40Max() throws Exception {
        long int40Max = 549755813887L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt40", new ContractFunctionParameters().addInt40(int40Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int40Max);
    }

    @Test
    @DisplayName("Can receive int40 array value from contract call")
    void canCallContractFunctionInt40Array() throws Exception {
        long int40Min = -549755813888L;
        long int40Max = 549755813887L;
        long[] int40Array = {int40Min, int40Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt40Arr", new ContractFunctionParameters().addInt40Array(int40Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(int40[])").get(0);

        assertThat(responseResult).isEqualTo(int40Array);
    }

    @Test
    @DisplayName("Can receive int48 min value from contract call")
    void canCallContractFunctionInt48Min() throws Exception {
        long int48Min = -140737488355328L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt48", new ContractFunctionParameters().addInt48(int48Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int48Min);
    }

    @Test
    @DisplayName("Can receive int48 max value from contract call")
    void canCallContractFunctionInt48Max() throws Exception {
        long int48Max = 140737488355327L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt48", new ContractFunctionParameters().addInt48(int48Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int48Max);
    }

    @Test
    @DisplayName("Can receive int48 array value from contract call")
    void canCallContractFunctionInt48Array() throws Exception {
        long int48Min = -140737488355328L;
        long int48Max = 140737488355327L;
        long[] int48Array = {int48Min, int48Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt48Arr", new ContractFunctionParameters().addInt48Array(int48Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(int48[])").get(0);

        assertThat(responseResult).isEqualTo(int48Array);
    }

    @Test
    @DisplayName("Can receive int56 min value from contract call")
    void canCallContractFunctionInt56Min() throws Exception {
        long int56Min = -36028797018963968L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt56", new ContractFunctionParameters().addInt56(int56Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int56Min);
    }

    @Test
    @DisplayName("Can receive int56 max value from contract call")
    void canCallContractFunctionInt56Max() throws Exception {
        long int56Max = 36028797018963967L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt56", new ContractFunctionParameters().addInt56(int56Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int56Max);
    }

    @Test
    @DisplayName("Can receive int56 array value from contract call")
    void canCallContractFunctionInt56Array() throws Exception {
        long int56Min = -36028797018963968L;
        long int56Max = 36028797018963967L;
        long[] int56Array = {int56Min, int56Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt56Arr", new ContractFunctionParameters().addInt56Array(int56Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(int56[])").get(0);

        assertThat(responseResult).isEqualTo(int56Array);
    }

    @Test
    @DisplayName("Can receive int64 min value from contract call")
    void canCallContractFunctionInt64Min() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt64", new ContractFunctionParameters().addInt64(Long.MIN_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint64(0)).isEqualTo(Long.MIN_VALUE);
    }

    @Test
    @DisplayName("Can receive int64 max value from contract call")
    void canCallContractFunctionInt64Max() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnUint64", new ContractFunctionParameters().addUint64(Long.MAX_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getUint64(0)).isEqualTo(Long.MAX_VALUE);
    }

    @Test
    @DisplayName("Can receive int64 array value from contract call")
    void canCallContractFunctionInt64Array() throws Exception {
        long int64Min = Long.MIN_VALUE;
        long int64Max = Long.MAX_VALUE;
        long[] int64Array = {int64Min, int64Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt64Arr", new ContractFunctionParameters().addInt64Array(int64Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (long[]) response.getResult("(int64[])").get(0);

        assertThat(responseResult).isEqualTo(int64Array);
    }

    @Test
    @DisplayName("Can receive int72 min value from contract call")
    void canCallContractFunctionInt72Min() throws Exception {
        BigInteger int72Min = new BigInteger("-2361183241434822606848");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt72", new ContractFunctionParameters().addInt72(int72Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int72Min);
    }

    @Test
    @DisplayName("Can receive int72 max value from contract call")
    void canCallContractFunctionInt72Max() throws Exception {
        BigInteger int72Max = new BigInteger("2361183241434822606847");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt72", new ContractFunctionParameters().addInt72(int72Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int72Max);
    }

    @Test
    @DisplayName("Can receive int72 array value from contract call")
    void canCallContractFunctionInt72Array() throws Exception {
        BigInteger int72Min = new BigInteger("-2361183241434822606848");
        BigInteger int72Max = new BigInteger("2361183241434822606847");
        BigInteger[] int72Array = {int72Min, int72Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt72Arr", new ContractFunctionParameters().addInt72Array(int72Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int72[])").get(0);

        assertThat(responseResult).isEqualTo(int72Array);
    }

    @Test
    @DisplayName("Can receive int80 min value from contract call")
    void canCallContractFunctionInt80Min() throws Exception {
        BigInteger int80Min = new BigInteger("-604462909807314587353088");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt80", new ContractFunctionParameters().addInt80(int80Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int80Min);
    }

    @Test
    @DisplayName("Can receive int80 max value from contract call")
    void canCallContractFunctionInt80Max() throws Exception {
        BigInteger int80Max = new BigInteger("604462909807314587353087");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt80", new ContractFunctionParameters().addInt80(int80Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int80Max);
    }

    @Test
    @DisplayName("Can receive int80 array value from contract call")
    void canCallContractFunctionInt80Array() throws Exception {
        BigInteger int80Min = new BigInteger("-604462909807314587353088");
        BigInteger int80Max = new BigInteger("604462909807314587353087");
        BigInteger[] int80Array = {int80Min, int80Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt80Arr", new ContractFunctionParameters().addInt80Array(int80Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int80[])").get(0);

        assertThat(responseResult).isEqualTo(int80Array);
    }

    @Test
    @DisplayName("Can receive int88 min value from contract call")
    void canCallContractFunctionInt88Min() throws Exception {
        BigInteger int88Min = new BigInteger("-154742504910672534362390528");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt88", new ContractFunctionParameters().addInt88(int88Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int88Min);
    }

    @Test
    @DisplayName("Can receive int88 max value from contract call")
    void canCallContractFunctionInt88Max() throws Exception {
        BigInteger int88Max = new BigInteger("154742504910672534362390527");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt88", new ContractFunctionParameters().addInt88(int88Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int88Max);
    }

    @Test
    @DisplayName("Can receive int88 array value from contract call")
    void canCallContractFunctionInt88Array() throws Exception {
        BigInteger int88Min = new BigInteger("-154742504910672534362390528");
        BigInteger int88Max = new BigInteger("154742504910672534362390527");
        BigInteger[] int88Array = {int88Min, int88Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt88Arr", new ContractFunctionParameters().addInt88Array(int88Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int88[])").get(0);

        assertThat(responseResult).isEqualTo(int88Array);
    }

    @Test
    @DisplayName("Can receive int96 min value from contract call")
    void canCallContractFunctionInt96Min() throws Exception {
        BigInteger int96Min = new BigInteger("-39614081257132168796771975168");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt96", new ContractFunctionParameters().addInt96(int96Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int96Min);
    }

    @Test
    @DisplayName("Can receive int96 max value from contract call")
    void canCallContractFunctionInt96Max() throws Exception {
        BigInteger int96Max = new BigInteger("39614081257132168796771975167");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt96", new ContractFunctionParameters().addInt96(int96Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int96Max);
    }

    @Test
    @DisplayName("Can receive int96 array value from contract call")
    void canCallContractFunctionInt96Array() throws Exception {
        BigInteger int96Min = new BigInteger("-39614081257132168796771975168");
        BigInteger int96Max = new BigInteger("39614081257132168796771975167");
        BigInteger[] int96Array = {int96Min, int96Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt96Arr", new ContractFunctionParameters().addInt96Array(int96Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int96[])").get(0);

        assertThat(responseResult).isEqualTo(int96Array);
    }

    @Test
    @DisplayName("Can receive int104 min value from contract call")
    void canCallContractFunctionInt104Min() throws Exception {
        BigInteger int104Min = new BigInteger("-10141204801825835211973625643008");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt104", new ContractFunctionParameters().addInt104(int104Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int104Min);
    }

    @Test
    @DisplayName("Can receive int104 max value from contract call")
    void canCallContractFunctionInt104Max() throws Exception {
        BigInteger int104Max = new BigInteger("10141204801825835211973625643007");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt104", new ContractFunctionParameters().addInt104(int104Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int104Max);
    }

    @Test
    @DisplayName("Can receive int104 array value from contract call")
    void canCallContractFunctionInt104Array() throws Exception {
        BigInteger int104Min = new BigInteger("-10141204801825835211973625643008");
        BigInteger int104Max = new BigInteger("10141204801825835211973625643007");
        BigInteger[] int104Array = {int104Min, int104Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt104Arr", new ContractFunctionParameters().addInt104Array(int104Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int104[])").get(0);

        assertThat(responseResult).isEqualTo(int104Array);
    }

    @Test
    @DisplayName("Can receive int112 min value from contract call")
    void canCallContractFunctionInt112Min() throws Exception {
        BigInteger int112Min = new BigInteger("-2596148429267413814265248164610048");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt112", new ContractFunctionParameters().addInt112(int112Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int112Min);
    }

    @Test
    @DisplayName("Can receive int112 max value from contract call")
    void canCallContractFunctionInt112Max() throws Exception {
        BigInteger int112Max = new BigInteger("2596148429267413814265248164610047");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt112", new ContractFunctionParameters().addInt112(int112Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int112Max);
    }

    @Test
    @DisplayName("Can receive int112 array value from contract call")
    void canCallContractFunctionInt112Array() throws Exception {
        BigInteger int112Min = new BigInteger("-2596148429267413814265248164610048");
        BigInteger int112Max = new BigInteger("2596148429267413814265248164610047");
        BigInteger[] int112Array = {int112Min, int112Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt112Arr", new ContractFunctionParameters().addInt112Array(int112Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int112[])").get(0);

        assertThat(responseResult).isEqualTo(int112Array);
    }

    @Test
    @DisplayName("Can receive int120 min value from contract call")
    void canCallContractFunctionInt120Min() throws Exception {
        BigInteger int120Min = new BigInteger("-664613997892457936451903530140172288");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt120", new ContractFunctionParameters().addInt120(int120Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int120Min);
    }

    @Test
    @DisplayName("Can receive int120 max value from contract call")
    void canCallContractFunctionInt120Max() throws Exception {
        BigInteger int120Max = new BigInteger("664613997892457936451903530140172287");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt120", new ContractFunctionParameters().addInt120(int120Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int120Max);
    }

    @Test
    @DisplayName("Can receive int120 array value from contract call")
    void canCallContractFunctionInt120Array() throws Exception {
        BigInteger int120Min = new BigInteger("-664613997892457936451903530140172288");
        BigInteger int120Max = new BigInteger("664613997892457936451903530140172287");
        BigInteger[] int120Array = {int120Min, int120Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt120Arr", new ContractFunctionParameters().addInt120Array(int120Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int120[])").get(0);

        assertThat(responseResult).isEqualTo(int120Array);
    }

    @Test
    @DisplayName("Can receive int128 min value from contract call")
    void canCallContractFunctionInt128Min() throws Exception {
        BigInteger int128Min = new BigInteger("-170141183460469231731687303715884105728");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt128", new ContractFunctionParameters().addInt128(int128Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int128Min);
    }

    @Test
    @DisplayName("Can receive int128 max value from contract call")
    void canCallContractFunctionInt128Max() throws Exception {
        BigInteger int128Max = new BigInteger("170141183460469231731687303715884105727");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt128", new ContractFunctionParameters().addInt128(int128Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int128Max);
    }

    @Test
    @DisplayName("Can receive int128 array value from contract call")
    void canCallContractFunctionInt128Array() throws Exception {
        BigInteger int128Min = new BigInteger("-170141183460469231731687303715884105728");
        BigInteger int128Max = new BigInteger("170141183460469231731687303715884105727");
        BigInteger[] int128Array = {int128Min, int128Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt128Arr", new ContractFunctionParameters().addInt128Array(int128Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int128[])").get(0);

        assertThat(responseResult).isEqualTo(int128Array);
    }

    @Test
    @DisplayName("Can receive int136 min value from contract call")
    void canCallContractFunctionInt136Min() throws Exception {
        BigInteger int136Min = new BigInteger("-43556142965880123323311949751266331066368");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt136", new ContractFunctionParameters().addInt136(int136Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int136Min);
    }

    @Test
    @DisplayName("Can receive int136 max value from contract call")
    void canCallContractFunctionInt136Max() throws Exception {
        BigInteger int136Max = new BigInteger("43556142965880123323311949751266331066367");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt136", new ContractFunctionParameters().addInt136(int136Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int136Max);
    }

    @Test
    @DisplayName("Can receive int136 array value from contract call")
    void canCallContractFunctionInt136Array() throws Exception {
        BigInteger int136Min = new BigInteger("-43556142965880123323311949751266331066368");
        BigInteger int136Max = new BigInteger("43556142965880123323311949751266331066367");
        BigInteger[] int136Array = {int136Min, int136Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt136Arr", new ContractFunctionParameters().addInt136Array(int136Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int136[])").get(0);

        assertThat(responseResult).isEqualTo(int136Array);
    }

    @Test
    @DisplayName("Can receive int144 min value from contract call")
    void canCallContractFunctionInt144Min() throws Exception {
        BigInteger int144Min = new BigInteger("-11150372599265311570767859136324180752990208");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt144", new ContractFunctionParameters().addInt144(int144Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int144Min);
    }

    @Test
    @DisplayName("Can receive int144 max value from contract call")
    void canCallContractFunctionInt144Max() throws Exception {
        BigInteger int144Max = new BigInteger("11150372599265311570767859136324180752990207");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt144", new ContractFunctionParameters().addInt144(int144Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int144Max);
    }

    @Test
    @DisplayName("Can receive int144 array value from contract call")
    void canCallContractFunctionInt144Array() throws Exception {
        BigInteger int144Min = new BigInteger("-11150372599265311570767859136324180752990208");
        BigInteger int144Max = new BigInteger("11150372599265311570767859136324180752990207");
        BigInteger[] int144Array = {int144Min, int144Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt144Arr", new ContractFunctionParameters().addInt144Array(int144Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int144[])").get(0);

        assertThat(responseResult).isEqualTo(int144Array);
    }

    @Test
    @DisplayName("Can receive int152 min value from contract call")
    void canCallContractFunctionInt152Min() throws Exception {
        BigInteger int152Min = new BigInteger("-2854495385411919762116571938898990272765493248");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt152", new ContractFunctionParameters().addInt152(int152Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int152Min);
    }

    @Test
    @DisplayName("Can receive int152 max value from contract call")
    void canCallContractFunctionInt152Max() throws Exception {
        BigInteger int152Max = new BigInteger("2854495385411919762116571938898990272765493247");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt152", new ContractFunctionParameters().addInt152(int152Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int152Max);
    }

    @Test
    @DisplayName("Can receive int152 array value from contract call")
    void canCallContractFunctionInt152Array() throws Exception {
        BigInteger int152Min = new BigInteger("-2854495385411919762116571938898990272765493248");
        BigInteger int152Max = new BigInteger("2854495385411919762116571938898990272765493247");
        BigInteger[] int152Array = {int152Min, int152Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt152Arr", new ContractFunctionParameters().addInt152Array(int152Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int152[])").get(0);

        assertThat(responseResult).isEqualTo(int152Array);
    }

    @Test
    @DisplayName("Can receive int160 min value from contract call")
    void canCallContractFunctionInt160Min() throws Exception {
        BigInteger int160Min = new BigInteger("-730750818665451459101842416358141509827966271488");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt160", new ContractFunctionParameters().addInt160(int160Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int160Min);
    }

    @Test
    @DisplayName("Can receive int160 max value from contract call")
    void canCallContractFunctionInt160Max() throws Exception {
        BigInteger int160Max = new BigInteger("730750818665451459101842416358141509827966271487");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt160", new ContractFunctionParameters().addInt160(int160Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int160Max);
    }

    @Test
    @DisplayName("Can receive int160 array value from contract call")
    void canCallContractFunctionInt160Array() throws Exception {
        BigInteger int160Min = new BigInteger("-730750818665451459101842416358141509827966271488");
        BigInteger int160Max = new BigInteger("730750818665451459101842416358141509827966271487");
        BigInteger[] int160Array = {int160Min, int160Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt160Arr", new ContractFunctionParameters().addInt160Array(int160Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int160[])").get(0);

        assertThat(responseResult).isEqualTo(int160Array);
    }

    @Test
    @DisplayName("Can receive int168 min value from contract call")
    void canCallContractFunctionInt168Min() throws Exception {
        BigInteger int168Min = new BigInteger("-187072209578355573530071658587684226515959365500928");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt168", new ContractFunctionParameters().addInt168(int168Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int168Min);
    }

    @Test
    @DisplayName("Can receive int168 max value from contract call")
    void canCallContractFunctionInt168Max() throws Exception {
        BigInteger int168Max = new BigInteger("187072209578355573530071658587684226515959365500927");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt168", new ContractFunctionParameters().addInt168(int168Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int168Max);
    }

    @Test
    @DisplayName("Can receive int168 array value from contract call")
    void canCallContractFunctionInt168Array() throws Exception {
        BigInteger int168Min = new BigInteger("-187072209578355573530071658587684226515959365500928");
        BigInteger int168Max = new BigInteger("187072209578355573530071658587684226515959365500927");
        BigInteger[] int168Array = {int168Min, int168Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt168Arr", new ContractFunctionParameters().addInt168Array(int168Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int168[])").get(0);

        assertThat(responseResult).isEqualTo(int168Array);
    }

    @Test
    @DisplayName("Can receive int176 min value from contract call")
    void canCallContractFunctionInt176Min() throws Exception {
        BigInteger int176Min = new BigInteger("-47890485652059026823698344598447161988085597568237568");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt176", new ContractFunctionParameters().addInt176(int176Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int176Min);
    }

    @Test
    @DisplayName("Can receive int176 max value from contract call")
    void canCallContractFunctionInt176Max() throws Exception {
        BigInteger int176Max = new BigInteger("47890485652059026823698344598447161988085597568237567");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt176", new ContractFunctionParameters().addInt176(int176Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int176Max);
    }

    @Test
    @DisplayName("Can receive int176 array value from contract call")
    void canCallContractFunctionInt176Array() throws Exception {
        BigInteger int176Min = new BigInteger("-47890485652059026823698344598447161988085597568237568");
        BigInteger int176Max = new BigInteger("47890485652059026823698344598447161988085597568237567");
        BigInteger[] int176Array = {int176Min, int176Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt176Arr", new ContractFunctionParameters().addInt176Array(int176Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int176[])").get(0);

        assertThat(responseResult).isEqualTo(int176Array);
    }

    @Test
    @DisplayName("Can receive int184 min value from contract call")
    void canCallContractFunctionInt184Min() throws Exception {
        BigInteger int184Min = new BigInteger("-12259964326927110866866776217202473468949912977468817408");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt184", new ContractFunctionParameters().addInt184(int184Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int184Min);
    }

    @Test
    @DisplayName("Can receive int184 max value from contract call")
    void canCallContractFunctionInt184Max() throws Exception {
        BigInteger int184Max = new BigInteger("12259964326927110866866776217202473468949912977468817407");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt184", new ContractFunctionParameters().addInt184(int184Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int184Max);
    }

    @Test
    @DisplayName("Can receive int184 array value from contract call")
    void canCallContractFunctionInt184Array() throws Exception {
        BigInteger int184Min = new BigInteger("-12259964326927110866866776217202473468949912977468817408");
        BigInteger int184Max = new BigInteger("12259964326927110866866776217202473468949912977468817407");
        BigInteger[] int184Array = {int184Min, int184Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt184Arr", new ContractFunctionParameters().addInt184Array(int184Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int184[])").get(0);

        assertThat(responseResult).isEqualTo(int184Array);
    }

    @Test
    @DisplayName("Can receive int192 min value from contract call")
    void canCallContractFunctionInt192Min() throws Exception {
        BigInteger int192Min = new BigInteger("-3138550867693340381917894711603833208051177722232017256448");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt192", new ContractFunctionParameters().addInt192(int192Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int192Min);
    }

    @Test
    @DisplayName("Can receive int192 max value from contract call")
    void canCallContractFunctionInt192Max() throws Exception {
        BigInteger int192Max = new BigInteger("3138550867693340381917894711603833208051177722232017256447");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt192", new ContractFunctionParameters().addInt192(int192Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int192Max);
    }

    @Test
    @DisplayName("Can receive int192 array value from contract call")
    void canCallContractFunctionInt192Array() throws Exception {
        BigInteger int192Min = new BigInteger("-3138550867693340381917894711603833208051177722232017256448");
        BigInteger int192Max = new BigInteger("3138550867693340381917894711603833208051177722232017256447");
        BigInteger[] int192Array = {int192Min, int192Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt192Arr", new ContractFunctionParameters().addInt192Array(int192Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int192[])").get(0);

        assertThat(responseResult).isEqualTo(int192Array);
    }

    @Test
    @DisplayName("Can receive int200 min value from contract call")
    void canCallContractFunctionInt200Min() throws Exception {
        BigInteger int200Min = new BigInteger("-803469022129495137770981046170581301261101496891396417650688");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt200", new ContractFunctionParameters().addInt200(int200Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int200Min);
    }

    @Test
    @DisplayName("Can receive int200 max value from contract call")
    void canCallContractFunctionInt200Max() throws Exception {
        BigInteger int200Max = new BigInteger("803469022129495137770981046170581301261101496891396417650687");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt200", new ContractFunctionParameters().addInt200(int200Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int200Max);
    }

    @Test
    @DisplayName("Can receive int200 array value from contract call")
    void canCallContractFunctionInt200Array() throws Exception {
        BigInteger int200Min = new BigInteger("-803469022129495137770981046170581301261101496891396417650688");
        BigInteger int200Max = new BigInteger("803469022129495137770981046170581301261101496891396417650687");
        BigInteger[] int200Array = {int200Min, int200Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt200Arr", new ContractFunctionParameters().addInt200Array(int200Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int200[])").get(0);

        assertThat(responseResult).isEqualTo(int200Array);
    }

    @Test
    @DisplayName("Can receive int208 min value from contract call")
    void canCallContractFunctionInt208Min() throws Exception {
        BigInteger int208Min = new BigInteger("-205688069665150755269371147819668813122841983204197482918576128");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt208", new ContractFunctionParameters().addInt208(int208Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int208Min);
    }

    @Test
    @DisplayName("Can receive int208 max value from contract call")
    void canCallContractFunctionInt208Max() throws Exception {
        BigInteger int208Max = new BigInteger("205688069665150755269371147819668813122841983204197482918576127");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt208", new ContractFunctionParameters().addInt208(int208Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int208Max);
    }

    @Test
    @DisplayName("Can receive int208 array value from contract call")
    void canCallContractFunctionInt208Array() throws Exception {
        BigInteger int208Min = new BigInteger("-205688069665150755269371147819668813122841983204197482918576128");
        BigInteger int208Max = new BigInteger("205688069665150755269371147819668813122841983204197482918576127");
        BigInteger[] int208Array = {int208Min, int208Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt208Arr", new ContractFunctionParameters().addInt208Array(int208Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int208[])").get(0);

        assertThat(responseResult).isEqualTo(int208Array);
    }

    @Test
    @DisplayName("Can receive int216 min value from contract call")
    void canCallContractFunctionInt216Min() throws Exception {
        BigInteger int216Min = new BigInteger("-52656145834278593348959013841835216159447547700274555627155488768");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt216", new ContractFunctionParameters().addInt216(int216Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int216Min);
    }

    @Test
    @DisplayName("Can receive int216 max value from contract call")
    void canCallContractFunctionInt216Max() throws Exception {
        BigInteger int216Max = new BigInteger("52656145834278593348959013841835216159447547700274555627155488767");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt216", new ContractFunctionParameters().addInt216(int216Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int216Max);
    }

    @Test
    @DisplayName("Can receive int216 array value from contract call")
    void canCallContractFunctionInt216Array() throws Exception {
        BigInteger int216Min = new BigInteger("-52656145834278593348959013841835216159447547700274555627155488768");
        BigInteger int216Max = new BigInteger("52656145834278593348959013841835216159447547700274555627155488767");
        BigInteger[] int216Array = {int216Min, int216Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt216Arr", new ContractFunctionParameters().addInt216Array(int216Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int216[])").get(0);

        assertThat(responseResult).isEqualTo(int216Array);
    }

    @Test
    @DisplayName("Can receive int224 min value from contract call")
    void canCallContractFunctionInt224Min() throws Exception {
        BigInteger int224Min = new BigInteger("-13479973333575319897333507543509815336818572211270286240551805124608");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt224", new ContractFunctionParameters().addInt224(int224Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int224Min);
    }

    @Test
    @DisplayName("Can receive int224 max value from contract call")
    void canCallContractFunctionInt224Max() throws Exception {
        BigInteger int224Max = new BigInteger("13479973333575319897333507543509815336818572211270286240551805124607");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt224", new ContractFunctionParameters().addInt224(int224Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int224Max);
    }

    @Test
    @DisplayName("Can receive int224 array value from contract call")
    void canCallContractFunctionInt224Array() throws Exception {
        BigInteger int224Min = new BigInteger("-13479973333575319897333507543509815336818572211270286240551805124608");
        BigInteger int224Max = new BigInteger("13479973333575319897333507543509815336818572211270286240551805124607");
        BigInteger[] int224Array = {int224Min, int224Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt224Arr", new ContractFunctionParameters().addInt224Array(int224Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int224[])").get(0);

        assertThat(responseResult).isEqualTo(int224Array);
    }

    @Test
    @DisplayName("Can receive int232 min value from contract call")
    void canCallContractFunctionInt232Min() throws Exception {
        BigInteger int232Min = new BigInteger(
            "-3450873173395281893717377931138512726225554486085193277581262111899648");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt232", new ContractFunctionParameters().addInt232(int232Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int232Min);
    }

    @Test
    @DisplayName("Can receive int232 max value from contract call")
    void canCallContractFunctionInt232Max() throws Exception {
        BigInteger int232Max = new BigInteger("3450873173395281893717377931138512726225554486085193277581262111899647");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt232", new ContractFunctionParameters().addInt232(int232Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int232Max);
    }

    @Test
    @DisplayName("Can receive int232 array value from contract call")
    void canCallContractFunctionInt232Array() throws Exception {
        BigInteger int232Min = new BigInteger(
            "-3450873173395281893717377931138512726225554486085193277581262111899648");
        BigInteger int232Max = new BigInteger("3450873173395281893717377931138512726225554486085193277581262111899647");
        BigInteger[] int232Array = {int232Min, int232Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt232Arr", new ContractFunctionParameters().addInt232Array(int232Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int232[])").get(0);

        assertThat(responseResult).isEqualTo(int232Array);
    }

    @Test
    @DisplayName("Can receive int240 min value from contract call")
    void canCallContractFunctionInt240Min() throws Exception {
        BigInteger int240Min = new BigInteger(
            "-883423532389192164791648750371459257913741948437809479060803100646309888");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt240", new ContractFunctionParameters().addInt240(int240Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int240Min);
    }

    @Test
    @DisplayName("Can receive int240 max value from contract call")
    void canCallContractFunctionInt240Max() throws Exception {
        BigInteger int240Max = new BigInteger(
            "883423532389192164791648750371459257913741948437809479060803100646309887");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt240", new ContractFunctionParameters().addInt240(int240Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int240Max);
    }

    @Test
    @DisplayName("Can receive int240 array value from contract call")
    void canCallContractFunctionInt240Array() throws Exception {
        BigInteger int240Min = new BigInteger(
            "-883423532389192164791648750371459257913741948437809479060803100646309888");
        BigInteger int240Max = new BigInteger(
            "883423532389192164791648750371459257913741948437809479060803100646309887");
        BigInteger[] int240Array = {int240Min, int240Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt240Arr", new ContractFunctionParameters().addInt240Array(int240Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int240[])").get(0);

        assertThat(responseResult).isEqualTo(int240Array);
    }

    @Test
    @DisplayName("Can receive int248 min value from contract call")
    void canCallContractFunctionInt248Min() throws Exception {
        BigInteger int248Min = new BigInteger(
            "-226156424291633194186662080095093570025917938800079226639565593765455331328");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt248", new ContractFunctionParameters().addInt248(int248Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int248Min);
    }

    @Test
    @DisplayName("Can receive int248 max value from contract call")
    void canCallContractFunctionInt248Max() throws Exception {
        BigInteger int248Max = new BigInteger(
            "226156424291633194186662080095093570025917938800079226639565593765455331327");

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt248", new ContractFunctionParameters().addInt248(int248Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int248Max);
    }

    @Test
    @DisplayName("Can receive int248 array value from contract call")
    void canCallContractFunctionInt248Array() throws Exception {
        BigInteger int248Min = new BigInteger(
            "-226156424291633194186662080095093570025917938800079226639565593765455331328");
        BigInteger int248Max = new BigInteger(
            "226156424291633194186662080095093570025917938800079226639565593765455331327");
        BigInteger[] int248Array = {int248Min, int248Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt248Arr", new ContractFunctionParameters().addInt248Array(int248Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int248[])").get(0);

        assertThat(responseResult).isEqualTo(int248Array);
    }

    @Test
    @DisplayName("Can receive int256 min value from contract call")
    void canCallContractFunctionInt256Min() throws Exception {
        BigInteger int256Min = new BigInteger("2").pow(256).divide(BigInteger.TWO).negate();

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt256", new ContractFunctionParameters().addInt256(int256Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int256Min);
    }

    @Test
    @DisplayName("Can receive int256 max value from contract call")
    void canCallContractFunctionInt256Max() throws Exception {
        BigInteger int256Max = new BigInteger("2").pow(256).subtract(BigInteger.ONE).divide(BigInteger.TWO);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt256", new ContractFunctionParameters().addInt256(int256Max))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int256Max);
    }

    @Test
    @DisplayName("Can receive int256 array value from contract call")
    void canCallContractFunctionInt256Array() throws Exception {
        BigInteger int256Min = new BigInteger("2").pow(256).divide(BigInteger.TWO).negate();
        BigInteger int256Max = new BigInteger("2").pow(256).subtract(BigInteger.ONE).divide(BigInteger.TWO);
        BigInteger[] int256Array = {int256Min, int256Max};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt256Arr", new ContractFunctionParameters().addInt256Array(int256Array))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (BigInteger[]) response.getResult("(int256[])").get(0);

        assertThat(responseResult).isEqualTo(int256Array);
    }

    @Test
    @DisplayName("Can receive multiple int8 values from contract call")
    void canCallContractFunctionMultipleInt8() throws Exception {
        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnInt8Multiple", new ContractFunctionParameters().addInt8(Byte.MIN_VALUE))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt8(0)).isEqualTo(Byte.MIN_VALUE);
        assertThat(response.getInt8(1)).isEqualTo((byte) -108);
    }

    @Test
    @DisplayName("Can receive multiple int40 values from contract call")
    void canCallContractFunctionMultipleInt40() throws Exception {
        long int40 = 549755813885L;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnMultipleInt40", new ContractFunctionParameters().addInt40(int40))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt64(0)).isEqualTo(int40);
        assertThat(response.getInt64(1)).isEqualTo(int40 + 1);
    }

    @Test
    @DisplayName("Can receive multiple int256 values from contract call")
    void canCallContractFunctionMultipleInt256() throws Exception {
        BigInteger int256Min = new BigInteger("2").pow(256).divide(BigInteger.TWO).negate();

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnMultipleInt256", new ContractFunctionParameters().addInt256(int256Min))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getInt256(0)).isEqualTo(int256Min);
        assertThat(response.getInt256(1)).isEqualTo(int256Min.add(BigInteger.ONE));
    }

    @Test
    @DisplayName("Can receive multiple types of values from contract call")
    void canCallContractFunctionMultipleTypes() throws Exception {
        var uint32Max = "4294967295";
        int uint32MaxInt = Integer.parseUnsignedInt(uint32Max);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnMultipleTypeParams", new ContractFunctionParameters().addUint32(uint32MaxInt))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(Integer.toUnsignedString(response.getUint32(0))).isEqualTo(uint32Max);
        assertThat(response.getUint64(1)).isEqualTo(Long.parseUnsignedLong(uint32Max) - 1);
        assertThat(response.getString(2)).isEqualTo("OK");
    }

    @Test
    @DisplayName("Can receive string value from contract call")
    void canCallContractFunctionStringType() throws Exception {
        var testString = "test";

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnString", new ContractFunctionParameters().addString(testString))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getString(0)).isEqualTo(testString);
    }

    @Test
    @DisplayName("Can receive string array value from contract call")
    void canCallContractFunctionStringArrayType() throws Exception {
        var testStringArray = new String[]{"Test1", "Test2"};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnStringArr", new ContractFunctionParameters().addStringArray(testStringArray))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getStringArray(0).get(0)).isEqualTo(testStringArray[0]);
        assertThat(response.getStringArray(0).get(1)).isEqualTo(testStringArray[1]);
    }

    @Test
    @DisplayName("Can receive string array value from contract call with getResult function")
    void canCallContractFunctionStringArrayType_getResult() throws Exception {
        var testStringArray = new String[]{"Test1", "Test2"};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnStringArr", new ContractFunctionParameters().addStringArray(testStringArray))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (String[]) response.getResult("(string[])").get(0);
        assertThat(responseResult).isEqualTo(testStringArray);
    }

    @Test
    @DisplayName("Can receive address value from contract call")
    void canCallContractFunctionAddressType() throws Exception {
        var testAddress = "1234567890123456789012345678901234567890";

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnAddress", new ContractFunctionParameters().addAddress(testAddress))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getAddress(0)).isEqualTo(testAddress);
    }

    @Test
    @DisplayName("Can receive address array value from contract call")
    void canCallContractFunctionAddressArrayType() throws Exception {
        var testAddressArray = new String[]{"1234567890123456789012345678901234567890",
            "1234567890123456789012345678901234567891"};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnAddressArr", new ContractFunctionParameters().addAddressArray(testAddressArray))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (Address[]) response.getResult("(address[])").get(0);

        Address[] testAddressArray_Address = Arrays.stream(testAddressArray).map(addressStr -> "0x" + addressStr)
            .map(Address::wrap).toArray(Address[]::new);

        assertThat(responseResult).isEqualTo(testAddressArray_Address);
    }

    @Test
    @DisplayName("Can receive boolean value from contract call")
    void canCallContractFunctionBooleanType() throws Exception {
        var testBoolean = true;

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnBoolean", new ContractFunctionParameters().addBool(testBoolean))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getBool(0)).isEqualTo(testBoolean);
    }

    @Test
    @DisplayName("Can receive boolean array value from contract call")
    void canCallContractFunctionBooleanArrayType() throws Exception {
        var testBooleanArray = new boolean[]{true, false};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnBooleanArr", new ContractFunctionParameters().addBoolArray(testBooleanArray))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (boolean[]) response.getResult("(bool[])").get(0);

        assertThat(responseResult).isEqualTo(testBooleanArray);
    }

    @Test
    @DisplayName("Can receive bytes value from contract call")
    void canCallContractFunctionBytesType() throws Exception {
        var testBytes = "Test".getBytes();

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnBytes", new ContractFunctionParameters().addBytes(testBytes))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getBytes(0)).isEqualTo(testBytes);
    }

    @Test
    @DisplayName("Can receive bytes array value from contract call")
    void canCallContractFunctionBytesArrayType() throws Exception {
        byte[][] testBytes = new byte[][]{"Test1".getBytes(), "Test2".getBytes()};

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnBytesArr", new ContractFunctionParameters().addBytesArray(testBytes))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (byte[][]) response.getResult("(bytes[])").get(0);

        assertThat(responseResult).isEqualTo(testBytes);
    }

    @Test
    @DisplayName("Can receive bytes32 value from contract call")
    void canCallContractFunctionBytes32Type() throws Exception {
        byte[] testBytes = "Test".getBytes();
        byte[] testBytesLen32 = new byte[32];
        System.arraycopy(testBytes, 0, testBytesLen32, 0, testBytes.length);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnBytes32", new ContractFunctionParameters().addBytes32(testBytesLen32))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        assertThat(response.getBytes32(0)).isEqualTo(testBytesLen32);
    }

    @Test
    @DisplayName("Can receive bytes32 array value from contract call")
    void canCallContractFunctionBytes32ArrayType() throws Exception {
        byte[] testBytes = "Test".getBytes();
        byte[] testBytes2 = "Test2".getBytes();
        byte[][] testBytesLen32 = new byte[2][32];
        System.arraycopy(testBytes, 0, testBytesLen32[0], 0, testBytes.length);
        System.arraycopy(testBytes2, 0, testBytesLen32[1], 0, testBytes2.length);

        var response = new ContractCallQuery().setContractId(contractId).setGas(1500000)
            .setFunction("returnBytes32Arr", new ContractFunctionParameters().addBytes32Array(testBytesLen32))
            .setQueryPayment(new Hbar(10)).execute(testEnv.client);

        var responseResult = (byte[][]) response.getResult("(bytes32[])").get(0);

        assertThat(responseResult).isEqualTo(testBytesLen32);
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractIdPopulationIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;

import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractId;
import com.hedera.hashgraph.sdk.ContractInfoQuery;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import java.util.Objects;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class ContractIdPopulationIntegrationTest {
    @Test
    @DisplayName("Can populate ContractId num from mirror node (using sync method)")
    void canPopulateContractIdNumSync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var testContractByteCode = "608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029";

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(testContractByteCode)
                .execute(testEnv.client);

            var receipt = response.setValidateStatus(true).getReceipt(testEnv.client);
            var fileId = Objects.requireNonNull(receipt.fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(100000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::canPopulateContractIdNum]")
                .execute(testEnv.client);

            receipt = response.setValidateStatus(true).getReceipt(testEnv.client);

            var contractId = Objects.requireNonNull(receipt.contractId);

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            var idMirror = ContractId.fromEvmAddress(0, 0, info.contractAccountId);
            Thread.sleep(5000);

            var newContractId = idMirror.populateContractNum(testEnv.client);

            assertThat(contractId.num).isEqualTo(newContractId.num);
        }
    }

    @Test
    @DisplayName("Can populate ContractId num from mirror node (using async method)")
    void canPopulateContractIdNumAsync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var testContractByteCode = "608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506101cb806100606000396000f3fe608060405260043610610046576000357c01000000000000000000000000000000000000000000000000000000009004806341c0e1b51461004b578063cfae321714610062575b600080fd5b34801561005757600080fd5b506100606100f2565b005b34801561006e57600080fd5b50610077610162565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100b757808201518184015260208101905061009c565b50505050905090810190601f1680156100e45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415610160573373ffffffffffffffffffffffffffffffffffffffff16ff5b565b60606040805190810160405280600d81526020017f48656c6c6f2c20776f726c64210000000000000000000000000000000000000081525090509056fea165627a7a72305820ae96fb3af7cde9c0abfe365272441894ab717f816f07f41f07b1cbede54e256e0029";

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(testContractByteCode)
                .execute(testEnv.client);

            var receipt = response.setValidateStatus(true).getReceipt(testEnv.client);
            var fileId = Objects.requireNonNull(receipt.fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(100000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::canPopulateContractIdNum]")
                .execute(testEnv.client);

            receipt = response.setValidateStatus(true).getReceipt(testEnv.client);

            var contractId = Objects.requireNonNull(receipt.contractId);

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            var idMirror = ContractId.fromEvmAddress(0, 0, info.contractAccountId);
            Thread.sleep(5000);

            var newContractId = idMirror.populateContractNumAsync(testEnv.client).get();

            assertThat(contractId.num).isEqualTo(newContractId.num);
    
        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.*;

public class ContractInfoIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Can query contract info")
    void canQueryContractInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            assertThat(contractId.hashCode()).isGreaterThan(0);
            assertThat(contractId.compareTo(ContractId.fromBytes(contractId.toBytes()))).isZero();

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(contractId.toString());
            assertThat(info.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(info.adminKey).toString()).isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can query contract info when admin key is null")
    void canQueryContractInfoWhenAdminKeyIsNull() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(contractId.toString());
            assertThat(info.adminKey).isNotNull();
            // TODO: Fix this when we know it's correct
            // assertEquals(info.adminKey, contractId);
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

        }
    }

    @Test
    @DisplayName("Cannot query contract info when contract ID is not set")
    void cannotQueryContractInfoWhenContractIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractInfoQuery()
                        .execute(testEnv.client);
            }).withMessageContaining(Status.INVALID_CONTRACT_ID.toString());

        }
    }

    @Test
    @DisplayName("Can get cost, even with a big max")
    @SuppressWarnings("UnusedVariable")
    void getCostBigMaxContractInfoFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var infoQuery = new ContractInfoQuery()
                .setContractId(contractId)
                .setMaxQueryPayment(new Hbar(10000));

            var cost = infoQuery.getCost(testEnv.client);

            var result = infoQuery
                    .execute(testEnv.client);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Error, max is smaller than set payment.")
    void getCostSmallMaxContractInfoFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var infoQuery = new ContractInfoQuery()
                .setContractId(contractId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
                infoQuery.execute(testEnv.client);
            });

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Insufficient tx fee error.")
    void getCostInsufficientTxFeeContractInfoFunction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            var infoQuery = new ContractInfoQuery()
                .setContractId(contractId)
                .setMaxQueryPayment(new Hbar(100));

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                infoQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractNonceInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractId;
import com.hedera.hashgraph.sdk.ContractNonceInfo;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import java.util.Objects;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class ContractNonceInfoIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "6080604052348015600f57600080fd5b50604051601a90603b565b604051809103906000f0801580156035573d6000803e3d6000fd5b50506047565b605c8061009483390190565b603f806100556000396000f3fe6080604052600080fdfea2646970667358221220a20122cbad3457fedcc0600363d6e895f17048f5caa4afdab9e655123737567d64736f6c634300081200336080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea264697066735822122053dfd8835e3dc6fedfb8b4806460b9b7163f8a7248bac510c6d6808d9da9d6d364736f6c63430008120033";

    @Test
    @DisplayName("Contract Create of A nonce, which deploys contract B in CONSTRUCTOR")
    void canIncrementNonceThroughContractConstructor() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(100000)
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractADeploysContractBInConstructor]")
                .execute(testEnv.client);

            var contractFunctionResult = response.getRecord(testEnv.client).contractFunctionResult;

            ContractId contractA = contractFunctionResult.contractId;
            ContractId contractB = contractFunctionResult.contractNonces.stream()
                    .filter(contractNonce -> !contractNonce.contractId.equals(contractA)).findFirst().get().contractId;

            ContractNonceInfo contractANonceInfo = contractFunctionResult.contractNonces.stream()
                    .filter(contractNonce -> contractNonce.contractId.equals(contractA)).findFirst().get();
            ContractNonceInfo contractBNonceInfo = contractFunctionResult.contractNonces.stream()
                    .filter(contractNonce -> contractNonce.contractId.equals(contractB)).findFirst().get();

            // A.nonce = 2
            assertThat(contractANonceInfo.nonce).isEqualTo(2);
            // B.nonce = 1
            assertThat(contractBNonceInfo.nonce).isEqualTo(1);
            // validate HIP-844 case - signer nonce should be set only for Ethereum transactions
            assertThat(contractFunctionResult.signerNonce).isEqualTo(0);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ContractUpdateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractInfoQuery;
import com.hedera.hashgraph.sdk.ContractUpdateTransaction;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class ContractUpdateIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("Can update contract")
    void canUpdateContract() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            @Var var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            response = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(response.getReceipt(testEnv.client).contractId);

            @Var var info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(contractId.toString());
            assertThat(info.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(info.adminKey).toString()).isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractCreateTransaction]");

            new ContractUpdateTransaction()
                .setContractId(contractId)
                .setContractMemo("[e2e::ContractUpdateTransaction]")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(info.contractId).isEqualTo(contractId);
            assertThat(info.accountId).isNotNull();
            assertThat(Objects.requireNonNull(info.accountId).toString()).isEqualTo(contractId.toString());
            assertThat(info.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(info.adminKey).toString()).isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(info.storage).isEqualTo(128);
            assertThat(info.contractMemo).isEqualTo("[e2e::ContractUpdateTransaction]");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot update contract when contract ID is not set")
    void cannotUpdateContractWhenContractIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new ContractUpdateTransaction()
                    .setContractMemo("[e2e::ContractUpdateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_CONTRACT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot update contract that is immutable")
    void cannotUpdateContractThatIsImmutable() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contractId = Objects.requireNonNull(
                    new ContractCreateTransaction()
                        .setGas(200000)
                        .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                        .setBytecodeFileId(fileId)
                        .setContractMemo("[e2e::ContractCreateTransaction]")
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client)
                        .contractId
                );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new ContractUpdateTransaction()
                    .setContractId(contractId)
                    .setContractMemo("[e2e::ContractUpdateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.MODIFYING_IMMUTABLE_CONTRACT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/EntityHelper.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.ContractCreateFlow;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.ContractId;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.Key;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenId;
import com.hedera.hashgraph.sdk.TokenSupplyType;
import com.hedera.hashgraph.sdk.TokenType;
import java.util.concurrent.TimeoutException;

/**
 * The EntityCreator class provides static methods for creating different entities in a Hedera network, such as token, account, and contract.
 */
public final class EntityHelper {

    private EntityHelper() {}

    public static int fungibleInitialBalance = 1_000_000;
    public static int mitedNfts = 10;

    /**
     * Create a non-fungible unique token.
     *
     * @param testEnv The integration test environment.
     * @return The token ID of the created token.
     * @throws PrecheckStatusException
     * @throws TimeoutException
     * @throws ReceiptStatusException
     */
    public static TokenId createNft(IntegrationTestEnv testEnv)
        throws PrecheckStatusException, TimeoutException, ReceiptStatusException {
        return new TokenCreateTransaction()
            .setTokenName("Test NFT")
            .setTokenSymbol("TNFT")
            .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
            .setTreasuryAccountId(testEnv.operatorId)
            .setSupplyType(TokenSupplyType.FINITE)
            .setMaxSupply(10)
            .setAdminKey(testEnv.operatorKey)
            .setFreezeKey(testEnv.operatorKey)
            .setSupplyKey(testEnv.operatorKey)
            .setMetadataKey(testEnv.operatorKey)
            .setWipeKey(testEnv.operatorKey)
            .setPauseKey(testEnv.operatorKey)
            .execute(testEnv.client)
            .getReceipt(testEnv.client)
            .tokenId;
    }

    /**
     * Creates a fungible token.
     *
     * @param testEnv  The integration test environment.
     * @param decimals The number of decimal places for the token.
     * @return The token ID of the created token.
     * @throws PrecheckStatusException   If the transaction fails pre-check.
     * @throws TimeoutException          If the transaction times out.
     * @throws ReceiptStatusException    If the receipt status is not success.
     */
    public static TokenId createFungibleToken(IntegrationTestEnv testEnv, int decimals)
        throws PrecheckStatusException, TimeoutException, ReceiptStatusException {
        return new TokenCreateTransaction()
            .setTokenName("Test Fungible Token")
            .setTokenSymbol("TFT")
            .setTokenMemo("I was created for integration tests")
            .setDecimals(decimals)
            .setInitialSupply(fungibleInitialBalance)
            .setMaxSupply(fungibleInitialBalance)
            .setTreasuryAccountId(testEnv.operatorId)
            .setSupplyType(TokenSupplyType.FINITE)
            .setAdminKey(testEnv.operatorKey)
            .setFreezeKey(testEnv.operatorKey)
            .setSupplyKey(testEnv.operatorKey)
            .setMetadataKey(testEnv.operatorKey)
            .setPauseKey(testEnv.operatorKey)
            .execute(testEnv.client)
            .getReceipt(testEnv.client)
            .tokenId;
    }

    /**
     * Creates a new account with the specified account key and maximum automatic token associations.
     *
     * @param testEnv                      The integration test environment.
     * @param accountKey                   The account key.
     * @param maxAutomaticTokenAssociations The maximum number of automatic token associations allowed.
     * @return The account ID of the newly created account.
     * @throws PrecheckStatusException   If the transaction fails pre-check.
     * @throws TimeoutException          If the transaction times out.
     * @throws ReceiptStatusException    If the receipt status is not success.
     */
    public static AccountId createAccount(IntegrationTestEnv testEnv, Key accountKey, int maxAutomaticTokenAssociations)
        throws PrecheckStatusException, TimeoutException, ReceiptStatusException {
        return new AccountCreateTransaction()
            .setKey(accountKey)
            .setInitialBalance(new Hbar(10))
            .setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations)
            .execute(testEnv.client)
            .getReceipt(testEnv.client)
            .accountId;
    }

    /**
     * Creates a contract with the specified contract key.
     *
     * @param testEnv The integration test environment.
     * @param contractKey The contract key.
     * @return The contract ID of the created contract.
     * @throws PrecheckStatusException if the transaction fails pre-check.
     * @throws TimeoutException if the transaction times out.
     * @throws ReceiptStatusException if the receipt status is not success.
     */
    public static ContractId createContract(IntegrationTestEnv testEnv, Key contractKey)
        throws PrecheckStatusException, TimeoutException, ReceiptStatusException {
        final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

        return new ContractCreateFlow()
            .setAdminKey(contractKey)
            .setGas(200_000)
            .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
            .setBytecode(SMART_CONTRACT_BYTECODE)
            .setContractMemo("[e2e::ContractMemo]")
            .execute(testEnv.client)
            .getReceipt(testEnv.client)
            .contractId;
    }
}

// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/EthereumTransactionIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;

import com.esaulpaugh.headlong.rlp.RLPEncoder;
import com.esaulpaugh.headlong.util.Integers;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractExecuteTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.EthereumTransaction;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PrivateKeyECDSA;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.math.BigInteger;
import java.util.List;
import java.util.Objects;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class EthereumTransactionIntegrationTest {

    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    /**
     * @notice E2E-HIP-844
     * @url https://hips.hedera.com/hip/hip-844
     */
    @Test
    @DisplayName("Signer nonce changed on Ethereum transaction")
    void signerNonceChangedOnEthereumTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var privateKey = PrivateKey.generateECDSA();
            var newAccountAliasId = privateKey.toAccountId(0, 0);

            new TransferTransaction()
                .addHbarTransfer(testEnv.operatorId, new Hbar(1).negated())
                .addHbarTransfer(newAccountAliasId, new Hbar(1))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var fileCreateTransactionResponse = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents(SMART_CONTRACT_BYTECODE)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(fileCreateTransactionResponse.getReceipt(testEnv.client).fileId);

            var contractCreateTransactionResponse = new ContractCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setGas(200000)
                .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                .setBytecodeFileId(fileId)
                .setContractMemo("[e2e::ContractCreateTransaction]")
                .execute(testEnv.client);

            var contractId = Objects.requireNonNull(
                    contractCreateTransactionResponse.getReceipt(testEnv.client).contractId);

            int nonce = 0;
            byte[] chainId = Hex.decode("012a");
            byte[] maxPriorityGas = Hex.decode("00");
            byte[] maxGas = Hex.decode("d1385c7bf0");
            byte[] to = Hex.decode(contractId.toSolidityAddress());
            byte[] callData = new ContractExecuteTransaction()
                .setFunction("setMessage", new ContractFunctionParameters().addString("new message"))
                .getFunctionParameters()
                .toByteArray();

            var sequence = RLPEncoder.sequence(Integers.toBytes(2), new Object[]{
                chainId,
                Integers.toBytes(nonce), // nonce
                maxPriorityGas,
                maxGas,
                Integers.toBytes(150000), // gasLimit
                to,
                Integers.toBytesUnsigned(BigInteger.ZERO), // value
                callData,
                new Object[0]
            });

            byte[] signedBytes = privateKey.sign(sequence);

            // wrap in signature object
            final byte[] r = new byte[32];
            System.arraycopy(signedBytes, 0, r, 0, 32);
            final byte[] s = new byte[32];
            System.arraycopy(signedBytes, 32, s, 0, 32);

            final int recId = ((PrivateKeyECDSA) privateKey).getRecoveryId(r, s, sequence);

            byte[] ethereumData = RLPEncoder.sequence(
                Integers.toBytes(0x02),
                List.of(
                    chainId,
                    Integers.toBytes(nonce), // nonce
                    maxPriorityGas,
                    maxGas,
                    Integers.toBytes(150000), // gasLimit
                    to,
                    Integers.toBytesUnsigned(BigInteger.ZERO), // value
                    callData,
                    List.of(/*accessList*/),
                    Integers.toBytes(recId), // recId
                    r,
                    s));

            EthereumTransaction ethereumTransaction = new EthereumTransaction()
                    .setEthereumData(ethereumData);
            var ethereumTransactionResponse = ethereumTransaction.execute(testEnv.client);
            var ethereumTransactionRecord = ethereumTransactionResponse.getRecord(testEnv.client);

            assertThat(ethereumTransactionRecord.contractFunctionResult.signerNonce).isEqualTo(1);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FeeSchedulesTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.FeeSchedules;
import com.hedera.hashgraph.sdk.FileContentsQuery;
import com.hedera.hashgraph.sdk.FileId;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class FeeSchedulesTest {
    @Test
    @DisplayName("FeeSchedules (CurrentAndNextFeeSchedule) is fetched and parsed from file 0.0.111")
    void canFetchFeeSchedules() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            ByteString feeSchedulesBytes = new FileContentsQuery()
                .setFileId(new FileId(0, 0, 111))
                .execute(testEnv.client);

            FeeSchedules feeSchedules = FeeSchedules.fromBytes(feeSchedulesBytes.toByteArray());

            /*
            * Test whether the file 0.0.111 actually contains stuff
            */
            assertThat(feeSchedules.getCurrent()).isNotNull();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FileAppendIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.FileAppendTransaction;
import com.hedera.hashgraph.sdk.FileContentsQuery;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileInfoQuery;
import com.hedera.hashgraph.sdk.KeyList;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

public class FileAppendIntegrationTest {
    @Test
    @DisplayName("Can append to file")
    void canAppendToFile() throws Exception {
        // There are potential bugs in FileAppendTransaction which require more than one node to trigger.
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            @Var var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileAppendTransaction()
                .setFileId(fileId)
                .setContents("[e2e::FileAppendTransaction]")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(56);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can append large contents to file")
    void canAppendLargeContentsToFile() throws Exception {
        // There are potential bugs in FileAppendTransaction which require more than one node to trigger.
        try(var testEnv = new IntegrationTestEnv(2)){

            // Skip if using local node.
            // Note: this check should be removed once the local node is supporting multiple nodes.
            testEnv.assumeNotLocalNode();

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            Thread.sleep(5000);

            @Var var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileAppendTransaction()
                .setFileId(fileId)
                .setContents(Contents.BIG_CONTENTS)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var contents = new FileContentsQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(contents.toStringUtf8()).isEqualTo("[e2e::FileCreateTransaction]" + Contents.BIG_CONTENTS);

            info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(13522);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can append large contents to file despite TRANSACTION_EXPIRATION response codes")
    void canAppendLargeContentsToFileDespiteExpiration() throws Exception {
        // There are potential bugs in FileAppendTransaction which require more than one node to trigger.
        try(var testEnv = new IntegrationTestEnv(2)){

            // Skip if using local node.
            // Note: this check should be removed once the local node is supporting multiple nodes.
            testEnv.assumeNotLocalNode();

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            Thread.sleep(5000);

            @Var var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            var appendTx = new FileAppendTransaction()
                .setFileId(fileId)
                .setContents(Contents.BIG_CONTENTS)
                .setTransactionValidDuration(Duration.ofSeconds(25))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var contents = new FileContentsQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(contents.toStringUtf8()).isEqualTo("[e2e::FileCreateTransaction]" + Contents.BIG_CONTENTS);

            info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(13522);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FileContentsIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.FileContentsQuery;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class FileContentsIntegrationTest {

    @Test
    @DisplayName("Can query file contents")
    void canQueryFileContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contents = new FileContentsQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(contents.toStringUtf8()).isEqualTo("[e2e::FileCreateTransaction]");

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can query empty file contents")
    void canQueryEmptyFileContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contents = new FileContentsQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(contents.size()).isEqualTo(0);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot query file contents when file ID is not set")
    void cannotQueryFileContentsWhenFileIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new FileContentsQuery()
                    .execute(testEnv.client);
            }).withMessageContaining(Status.INVALID_FILE_ID.toString());

        }
    }

    @Test
    @DisplayName("Can get cost, even with a big max")
    void getCostBigMaxQueryFileContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contentsQuery = new FileContentsQuery()
                .setFileId(fileId)
                .setMaxQueryPayment(new Hbar(1000));

            var contents = contentsQuery.execute(testEnv.client);

            assertThat(contents.toStringUtf8()).isEqualTo("[e2e::FileCreateTransaction]");

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Error, max is smaller than set payment.")
    void getCostSmallMaxQueryFileContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contentsQuery = new FileContentsQuery()
                .setFileId(fileId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
                contentsQuery.execute(testEnv.client);
            });

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Insufficient tx fee error.")
    void getCostInsufficientTxFeeQueryFileContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var contentsQuery = new FileContentsQuery()
                .setFileId(fileId)
                .setMaxQueryPayment(new Hbar(100));

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                contentsQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FileCreateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileInfoQuery;
import com.hedera.hashgraph.sdk.KeyList;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

public class FileCreateIntegrationTest {
    @Test
    @DisplayName("Can create file")
    void canCreateFile() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can create file with no contents")
    void canCreateFileWithNoContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(0);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can create file with no keys")
    void canCreateFileWithNoKeys() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(0);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNull();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FileDeleteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileInfoQuery;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class FileDeleteIntegrationTest {
    @Test
    @DisplayName("Can delete file")
    void canDeleteFile() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot delete immutable file")
    void cannotDeleteImmutableFile() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNull();

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new FileDeleteTransaction()
                    .setFileId(fileId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.UNAUTHORIZED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FileInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileInfoQuery;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class FileInfoIntegrationTest {
    @Test
    @DisplayName("Can query file info")
    void canQueryFileInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can query file info with no admin key or contents")
    void canQueryFileInfoWithNoAdminKeyOrContents() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(0);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNull();

        }
    }

    @Test
    @DisplayName("Can get cost, even with a big max")
    @SuppressWarnings("UnusedVariable")
    void getCostBigMaxQueryFileInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var infoQuery = new FileInfoQuery()
                .setFileId(fileId)
                .setMaxQueryPayment(new Hbar(1000));

            var cost = infoQuery.getCost(testEnv.client);

            var info = infoQuery.setQueryPayment(cost).execute(testEnv.client);

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Error, max is smaller than set payment.")
    void getCostSmallMaxQueryFileInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var infoQuery = new FileInfoQuery()
                .setFileId(fileId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
                infoQuery.execute(testEnv.client);
            });

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Insufficient tx fee error.")
    void getCostInsufficientTxFeeQueryFileInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var infoQuery = new FileInfoQuery()
                .setFileId(fileId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                infoQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/FileUpdateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileId;
import com.hedera.hashgraph.sdk.FileInfoQuery;
import com.hedera.hashgraph.sdk.FileUpdateTransaction;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class FileUpdateIntegrationTest {
    @Test
    @DisplayName("Can update file")
    void canUpdateFile() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setKeys(testEnv.operatorKey)
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            @Var var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileUpdateTransaction()
                .setFileId(fileId)
                .setContents("[e2e::FileUpdateTransaction]")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                .setFileId(fileId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot update immutable file")
    void cannotUpdateImmutableFile() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var response = new FileCreateTransaction()
                .setContents("[e2e::FileCreateTransaction]")
                .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            var info = new FileInfoQuery()
                .setFileId(fileId)
                .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNull();

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new FileUpdateTransaction()
                    .setFileId(fileId)
                    .setContents("[e2e::FileUpdateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.UNAUTHORIZED.toString());

        }
    }

    @Test
    @DisplayName("Cannot update file when file ID is not set")
    void cannotUpdateFileWhenFileIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new FileUpdateTransaction()
                    .setContents("[e2e::FileUpdateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_FILE_ID.toString());

        }
    }

    @Test
    @DisplayName("Can update fee schedule file")
    void canUpdateFeeScheduleFile() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            testEnv.client.setOperator(new AccountId(0, 0, 2), PrivateKey.fromString(
                "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137"));

            var fileId = new FileId(0, 0, 111);
            var receipt = new FileUpdateTransaction()
                .setFileId(fileId)
                .setContents("[e2e::FileUpdateTransaction]")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.FEE_SCHEDULE_FILE_PART_UPLOADED);
        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/IntegrationTestEnv.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.sdk.TokenId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;
import org.junit.jupiter.api.Assumptions;

public class IntegrationTestEnv implements AutoCloseable {
    static final String LOCAL_CONSENSUS_NODE_ENDPOINT = "127.0.0.1:50211";
    static final String LOCAL_MIRROR_NODE_GRPC_ENDPOINT = "127.0.0.1:5600";
    static final AccountId LOCAL_CONSENSUS_NODE_ACCOUNT_ID = new AccountId(3);
    private final Client originalClient;
    public Client client;
    public PublicKey operatorKey;
    public AccountId operatorId;
    public boolean isLocalNode = false;

    public IntegrationTestEnv() throws Exception {
        this(0);
    }

    @SuppressWarnings("EmptyCatch")
    public IntegrationTestEnv(int maxNodesPerTransaction) throws Exception {
        client = createTestEnvClient();

        if (maxNodesPerTransaction == 0) {
            maxNodesPerTransaction = client.getNetwork().size();
        }

        client.setMaxNodesPerTransaction(maxNodesPerTransaction);
        originalClient = client;

        try {
            var operatorPrivateKey = PrivateKey.fromString(System.getProperty("OPERATOR_KEY"));
            operatorId = AccountId.fromString(System.getProperty("OPERATOR_ID"));
            operatorKey = operatorPrivateKey.getPublicKey();

            client.setOperator(operatorId, operatorPrivateKey);
        } catch (RuntimeException ignored) {
        }

        operatorKey = client.getOperatorPublicKey();
        operatorId = client.getOperatorAccountId();

        assertThat(client.getOperatorAccountId()).isNotNull();
        assertThat(client.getOperatorPublicKey()).isNotNull();

        if (client.getNetwork().size() > 0 && (client.getNetwork().containsKey(LOCAL_CONSENSUS_NODE_ENDPOINT))) {
            isLocalNode = true;
        }

        var nodeGetter = new TestEnvNodeGetter(client);
        var network = new HashMap<String, AccountId>();

        var nodeCount = Math.min(client.getNetwork().size(), maxNodesPerTransaction);
        for (@Var int i = 0; i < nodeCount; i++) {
            nodeGetter.nextNode(network);
        }
        client.setNetwork(network);
    }

    @SuppressWarnings("EmptyCatch")
    private static Client createTestEnvClient() throws Exception {
        if (System.getProperty("HEDERA_NETWORK").equals("previewnet")) {
            return Client.forPreviewnet();
        } else if (System.getProperty("HEDERA_NETWORK").equals("testnet")) {
            return Client.forTestnet();
        } else if (System.getProperty("HEDERA_NETWORK").equals("localhost")) {
            var network = new HashMap<String, AccountId>();
            network.put(LOCAL_CONSENSUS_NODE_ENDPOINT, LOCAL_CONSENSUS_NODE_ACCOUNT_ID);

            return Client
                .forNetwork(network)
                .setMirrorNetwork(List.of(LOCAL_MIRROR_NODE_GRPC_ENDPOINT));
        } else if (!System.getProperty("CONFIG_FILE").equals("")) {
            try {
                return Client.fromConfigFile(System.getProperty("CONFIG_FILE"));
            } catch (Exception configFileException) {
                configFileException.printStackTrace();
            }
        }
        throw new IllegalStateException("Failed to construct client for IntegrationTestEnv");
    }

    public IntegrationTestEnv useThrowawayAccount(Hbar initialBalance) throws Exception {
        var key = PrivateKey.generateED25519();
        operatorKey = key.getPublicKey();
        operatorId = new AccountCreateTransaction()
            .setInitialBalance(initialBalance)
            .setKey(key)
            .execute(client)
            .getReceipt(client)
            .accountId;

        client = Client.forNetwork(originalClient.getNetwork());
        client.setMirrorNetwork(originalClient.getMirrorNetwork());
        client.setOperator(Objects.requireNonNull(operatorId), key);
        client.setLedgerId(originalClient.getLedgerId());
        return this;
    }

    public IntegrationTestEnv useThrowawayAccount() throws Exception {
        return useThrowawayAccount(new Hbar(50));
    }

    // Note: this is a temporary workaround.
    // The assumption should be removed once the local node is supporting multiple nodes.
    public void assumeNotLocalNode() throws Exception {
        // first clean up the current IntegrationTestEnv...
        if (isLocalNode) {
            close();
        }

        // then skip the current test
        Assumptions.assumeFalse(isLocalNode);
    }

    @Override
    public void close() throws Exception {
        if (!operatorId.equals(originalClient.getOperatorAccountId())) {
            var hbarsBalance = new AccountBalanceQuery()
                .setAccountId(operatorId)
                .execute(originalClient)
                .hbars;
            new TransferTransaction()
                .addHbarTransfer(operatorId, hbarsBalance.negated())
                .addHbarTransfer(Objects.requireNonNull(originalClient.getOperatorAccountId()), hbarsBalance)
                .freezeWith(originalClient)
                .signWithOperator(client)
                .execute(originalClient);
            client.close();
        }

        originalClient.close();
    }

    private static class TestEnvNodeGetter {
        private final Client client;
        private final List<Map.Entry<String, AccountId>> nodes;
        @Var
        private int index = 0;

        public TestEnvNodeGetter(Client client) {
            this.client = client;
            nodes = new ArrayList<>(client.getNetwork().entrySet());
            Collections.shuffle(nodes);
        }

        public void nextNode(Map<String, AccountId> outMap) throws Exception {
            if (nodes.isEmpty()) {
                throw new IllegalStateException(
                    "IntegrationTestEnv needs another node, but there aren't enough nodes in client network");
            }
            for (; index < nodes.size(); index++) {
                var node = nodes.get(index);
                try {
                    new TransferTransaction()
                        .setNodeAccountIds(Collections.singletonList(node.getValue()))
                        .setMaxAttempts(1)
                        .addHbarTransfer(client.getOperatorAccountId(), Hbar.fromTinybars(1).negated())
                        .addHbarTransfer(AccountId.fromString("0.0.3"), Hbar.fromTinybars(1))
                        .execute(client)
                        .getReceipt(client);
                    nodes.remove(index);
                    outMap.put(node.getKey(), node.getValue());
                    return;
                } catch (Throwable err) {
                    System.err.println(err);
                }
            }
            throw new Exception("Failed to find working node in " + nodes + " for IntegrationTestEnv");
        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/LiveHashAddIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.LiveHashAddTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.Status;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class LiveHashAddIntegrationTest {
    private static final byte[] HASH = Hex.decode("100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002");

    @Test
    @DisplayName("Cannot create live hash because it's not supported")
    void cannotCreateLiveHashBecauseItsNotSupported() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new LiveHashAddTransaction()
                    .setAccountId(accountId)
                    .setDuration(Duration.ofDays(30))
                    .setHash(HASH)
                    .setKeys(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/LiveHashDeleteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.LiveHashDeleteTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.Status;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class LiveHashDeleteIntegrationTest {
    private static final byte[] HASH = Hex.decode("100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002");

    @Test
    @DisplayName("Cannot delete live hash because it's not supported")
    void cannotDeleteLiveHashBecauseItsNotSupported() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new LiveHashDeleteTransaction()
                    .setAccountId(accountId)
                    .setHash(HASH)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/LoadIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.hedera.hashgraph.sdk.test.integration;

import static org.junit.jupiter.api.Assertions.fail;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.PrivateKey;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class LoadIntegrationTest {

    @Test
    @DisplayName("Load test with multiple clients and single executor")
    void loadTest() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var operatorPrivateKey = PrivateKey.fromString(System.getProperty("OPERATOR_KEY"));
            var operatorId = AccountId.fromString(System.getProperty("OPERATOR_ID"));

            int nThreads = 10;
            var clientExecutor = Executors.newFixedThreadPool(16);

            var threadPoolExecutor = (ThreadPoolExecutor) Executors.newFixedThreadPool(nThreads);

            long startTime = System.currentTimeMillis();

            System.out.println("Finished executing tasks:");
            for (int i = 0; i < nThreads; i++) {
                int finalI = i;
                threadPoolExecutor.submit(() -> {
                    var client = Client.forNetwork(testEnv.client.getNetwork(), clientExecutor);
                    client.setOperator(operatorId, operatorPrivateKey);
                    client.setMaxAttempts(10);
                    try {
                        new AccountCreateTransaction()
                            .setKey(PrivateKey.generateED25519())
                            .execute(client)
                            .getReceipt(client);
                        System.out.println(finalI);
                    } catch (Exception e) {
                        fail("AccountCreateTransaction failed, " + e);
                    } finally {
                        try {
                            client.closeChannels();
                        } catch (TimeoutException e) {
                            throw new RuntimeException(e);
                        }
                    }
                });
            }

            threadPoolExecutor.shutdown();

            // Wait for all tasks to finish
            try {
                if (!threadPoolExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                    System.out.println();
                    System.out.println("Forcing shutdown");
                    threadPoolExecutor.shutdownNow();
                }
            } catch (InterruptedException e) {
                threadPoolExecutor.shutdownNow();
            }

            long endTime = System.currentTimeMillis();
            long executionTime = endTime - startTime;
            System.out.println();
            System.out.println("All tasks have finished execution in " + executionTime + "ms");
            clientExecutor.shutdownNow();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/NetworkVersionInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.NetworkVersionInfoQuery;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class NetworkVersionInfoIntegrationTest {
    @Test
    @DisplayName("Cannot query network version info")
    void cannotQueryNetworkVersionInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            new NetworkVersionInfoQuery()
                .execute(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/NftAllowancesIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.hedera.hashgraph.sdk.AccountAllowanceApproveTransaction;
import com.hedera.hashgraph.sdk.AccountAllowanceDeleteTransaction;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.NftId;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenId;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenNftInfoQuery;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.nio.charset.StandardCharsets;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class NftAllowancesIntegrationTest {
    @Test
    @DisplayName("Cannot transfer on behalf of `spender` account without allowance approval")
    void cannotTransferWithoutAllowanceApproval() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var spenderKey = PrivateKey.generateED25519();
            var spenderAccountId = new AccountCreateTransaction()
                .setKey(spenderKey)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var receiverKey = PrivateKey.generateED25519();
            var receiverAccountId = new AccountCreateTransaction()
                .setKey(receiverKey)
                .setMaxAutomaticTokenAssociations(10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            TokenId nftTokenId = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            new TokenAssociateTransaction()
                .setAccountId(spenderAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client);

            var serials = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .addMetadata("asd".getBytes(StandardCharsets.UTF_8))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .serials;

            var nft1 = new NftId(nftTokenId, serials.get(0));

            var onBehalfOfTransactionId = TransactionId.generate(spenderAccountId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> new TransferTransaction()
                .addApprovedNftTransfer(nft1, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)).withMessageContaining(Status.SPENDER_DOES_NOT_HAVE_ALLOWANCE.toString());

        }
    }

    @Test
    @DisplayName("Cannot transfer on behalf of `spender` account after removing the allowance approval")
    void cannotTransferAfterAllowanceRemove() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var spenderKey = PrivateKey.generateED25519();
            var spenderAccountId = new AccountCreateTransaction()
                .setKey(spenderKey)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var receiverKey = PrivateKey.generateED25519();
            var receiverAccountId = new AccountCreateTransaction()
                .setKey(receiverKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            TokenId nftTokenId = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            new TokenAssociateTransaction()
                .setAccountId(spenderAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverKey)
                .execute(testEnv.client);

            var serials = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .addMetadata("asd1".getBytes(StandardCharsets.UTF_8))
                .addMetadata("asd2".getBytes(StandardCharsets.UTF_8))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .serials;

            var nft1 = new NftId(nftTokenId, serials.get(0));
            var nft2 = new NftId(nftTokenId, serials.get(1));

            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowance(nft1, testEnv.operatorId, spenderAccountId)
                .approveTokenNftAllowance(nft2, testEnv.operatorId, spenderAccountId)
                .execute(testEnv.client);

            new AccountAllowanceDeleteTransaction()
                .deleteAllTokenNftAllowances(nft2, testEnv.operatorId)
                .execute(testEnv.client);

            var onBehalfOfTransactionId = TransactionId.generate(spenderAccountId);

            new TransferTransaction()
                .addApprovedNftTransfer(nft1, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var info = new TokenNftInfoQuery()
                .setNftId(nft1)
                .execute(testEnv.client);
            assertThat(info.get(0).accountId).isEqualTo(receiverAccountId);

            var onBehalfOfTransactionId2 = TransactionId.generate(spenderAccountId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> new TransferTransaction()
                .addApprovedNftTransfer(nft2, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId2)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)).withMessageContaining(Status.SPENDER_DOES_NOT_HAVE_ALLOWANCE.toString());

        }
    }

    @Test
    @DisplayName("Cannot remove single serial number allowance when the allowance is given for all serials at once")
    void cannotRemoveSingleSerialWhenAllowanceIsGivenForAll() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var spenderKey = PrivateKey.generateED25519();
            var spenderAccountId = new AccountCreateTransaction()
                .setKey(spenderKey)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var receiverKey = PrivateKey.generateED25519();
            var receiverAccountId = new AccountCreateTransaction()
                .setKey(receiverKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            TokenId nftTokenId = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            new TokenAssociateTransaction()
                .setAccountId(spenderAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverKey)
                .execute(testEnv.client);

            var serials = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .addMetadata("asd1".getBytes(StandardCharsets.UTF_8))
                .addMetadata("asd2".getBytes(StandardCharsets.UTF_8))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .serials;

            var nft1 = new NftId(nftTokenId, serials.get(0));
            var nft2 = new NftId(nftTokenId, serials.get(1));

            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowanceAllSerials(nftTokenId, testEnv.operatorId, spenderAccountId)
                .execute(testEnv.client);

            var onBehalfOfTransactionId = TransactionId.generate(spenderAccountId);

            new TransferTransaction()
                .addApprovedNftTransfer(nft1, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // hopefully in the future this should end up with a precheck error provided from services
            new AccountAllowanceDeleteTransaction()
                .deleteAllTokenNftAllowances(nft2, testEnv.operatorId)
                .execute(testEnv.client);

            var onBehalfOfTransactionId2 = TransactionId.generate(spenderAccountId);

            new TransferTransaction()
                .addApprovedNftTransfer(nft2, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId2)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var infoNft1 = new TokenNftInfoQuery()
                .setNftId(nft1)
                .execute(testEnv.client);

            var infoNft2 = new TokenNftInfoQuery()
                .setNftId(nft2)
                .execute(testEnv.client);

            assertThat(infoNft1.get(0).accountId).isEqualTo(receiverAccountId);
            assertThat(infoNft2.get(0).accountId).isEqualTo(receiverAccountId);
        }
    }

    @Test
    @DisplayName("Account, which given the allowance for all serials at once, should be able to give allowances for single serial numbers to other accounts")
    void accountGivenAllowanceForAllShouldBeAbleToGiveAllowanceForSingle() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var delegatingSpenderKey = PrivateKey.generateED25519();
            var delegatingSpenderAccountId = new AccountCreateTransaction()
                .setKey(delegatingSpenderKey)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var spenderKey = PrivateKey.generateED25519();
            var spenderAccountId = new AccountCreateTransaction()
                .setKey(spenderKey)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var receiverKey = PrivateKey.generateED25519();
            var receiverAccountId = new AccountCreateTransaction()
                .setKey(receiverKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            TokenId nftTokenId = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            new TokenAssociateTransaction()
                .setAccountId(delegatingSpenderAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(List.of(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverKey)
                .execute(testEnv.client);

            var serials = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .addMetadata("asd1".getBytes(StandardCharsets.UTF_8))
                .addMetadata("asd2".getBytes(StandardCharsets.UTF_8))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .serials;

            var nft1 = new NftId(nftTokenId, serials.get(0));
            var nft2 = new NftId(nftTokenId, serials.get(1));

            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowanceAllSerials(nftTokenId, testEnv.operatorId, delegatingSpenderAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowance(nft1, testEnv.operatorId, spenderAccountId, delegatingSpenderAccountId)
                .freezeWith(testEnv.client)
                .sign(delegatingSpenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var onBehalfOfTransactionId = TransactionId.generate(spenderAccountId);

            new TransferTransaction()
                .addApprovedNftTransfer(nft1, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var onBehalfOfTransactionId2 = TransactionId.generate(spenderAccountId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> new TransferTransaction()
                .addApprovedNftTransfer(nft2, testEnv.operatorId, receiverAccountId)
                .setTransactionId(onBehalfOfTransactionId2)
                .freezeWith(testEnv.client)
                .sign(spenderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)).withMessageContaining(Status.SPENDER_DOES_NOT_HAVE_ALLOWANCE.toString());

            var infoNft1 = new TokenNftInfoQuery()
                .setNftId(nft1)
                .execute(testEnv.client);

            var infoNft2 = new TokenNftInfoQuery()
                .setNftId(nft2)
                .execute(testEnv.client);

            assertThat(infoNft1.get(0).accountId).isEqualTo(receiverAccountId);
            assertThat(infoNft2.get(0).accountId).isEqualTo(testEnv.operatorId);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/NftMetadataGenerator.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class NftMetadataGenerator {
    private NftMetadataGenerator() {
    }

    public static List<byte[]> generate(byte metadataCount) {
        List<byte[]> metadatas = new ArrayList<>();
        for (byte i = 0; i < metadataCount; i++) {
            byte[] md = {i};
            metadatas.add(md);
        }
        return metadatas;
    }

    public static List<byte[]> generate(byte[] metadata, int count) {
        return IntStream.range(0, count)
            .mapToObj(i -> metadata.clone())
            .collect(Collectors.toList());
    }

    public static List<byte[]> generateOneLarge() {
        return Collections.singletonList(new byte[101]);
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ReceiptQueryIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TransactionReceiptQuery;
import com.hedera.hashgraph.sdk.TransactionRecordQuery;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ReceiptQueryIntegrationTest {
    @Test
    @DisplayName("Can get Receipt")
    void canGetTransactionReceipt() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            var receipt = new TransactionReceiptQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get Record")
    void canGetTransactionRecord() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            new TransactionReceiptQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

            new TransactionRecordQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get Record cost")
    @SuppressWarnings("UnusedVariable")
    void getCostTransactionRecord() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            new TransactionReceiptQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

            var recordQuery = new TransactionRecordQuery()
                .setTransactionId(response.transactionId);

            recordQuery.getCost(testEnv.client);
            recordQuery.execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get Record cost with big max set")
    @SuppressWarnings("UnusedVariable")
    void getCostBigMaxTransactionRecord() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            new TransactionReceiptQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

            var recordQuery = new TransactionRecordQuery()
                .setTransactionId(response.transactionId)
                .setMaxQueryPayment(new Hbar(1000));

            recordQuery.getCost(testEnv.client);

            recordQuery.execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("Error at very small max, getRecord")
    void getCostSmallMaxTransactionRecord() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            var receipt = new TransactionReceiptQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

            var recordQuery = new TransactionRecordQuery()
                .setTransactionId(response.transactionId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            var cost = recordQuery.getCost(testEnv.client);

            assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {
                recordQuery.execute(testEnv.client);
            }).withMessage("cost for TransactionRecordQuery, of " + cost.toString() + ", without explicit payment is greater than the maximum allowed payment of 1 t");

        }
    }

    @Test
    @DisplayName("Insufficient transaction fee error for transaction record query")
    void getCostInsufficientTxFeeTransactionRecord() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            var receipt = new TransactionReceiptQuery()
                .setTransactionId(response.transactionId)
                .execute(testEnv.client);

            var recordQuery = new TransactionRecordQuery()
                .setTransactionId(response.transactionId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                recordQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/ScheduleCreateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.ScheduleCreateTransaction;
import com.hedera.hashgraph.sdk.ScheduleId;
import com.hedera.hashgraph.sdk.ScheduleInfo;
import com.hedera.hashgraph.sdk.ScheduleInfoQuery;
import com.hedera.hashgraph.sdk.ScheduleSignTransaction;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicMessageSubmitTransaction;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransactionReceipt;
import com.hedera.hashgraph.sdk.TransactionResponse;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Instant;

import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class ScheduleCreateIntegrationTest {
    @Test
    @Disabled
    @DisplayName("Can create schedule")
    void canCreateSchedule() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var key = PrivateKey.generateED25519();

            var transaction = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(10));

            var response = new ScheduleCreateTransaction()
                .setScheduledTransaction(transaction)
                .setAdminKey(testEnv.operatorKey)
                .setPayerAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            var scheduleId = Objects.requireNonNull(response.getReceipt(testEnv.client).scheduleId);

            var info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info.executedAt).isNotNull();

        }
    }

    @Test
    @Disabled
    @DisplayName("Can get Transaction")
    void canGetTransactionSchedule() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var key = PrivateKey.generateED25519();

            var transaction = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(10));

            var response = new ScheduleCreateTransaction()
                .setScheduledTransaction(transaction)
                .setAdminKey(testEnv.operatorKey)
                .setPayerAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            var scheduleId = Objects.requireNonNull(response.getReceipt(testEnv.client).scheduleId);

            var info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info.executedAt).isNotNull();
            assertThat(info.getScheduledTransaction()).isNotNull();

        }
    }

    @Test
    @Disabled
    @DisplayName("Can create schedule with schedule()")
    void canCreateWithSchedule() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var key = PrivateKey.generateED25519();

            var transaction = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(10));

            var tx = transaction.schedule();

            var response = tx
                .setAdminKey(testEnv.operatorKey)
                .setPayerAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            var scheduleId = Objects.requireNonNull(response.getReceipt(testEnv.client).scheduleId);

            var info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info.executedAt).isNotNull();
            assertThat(info.getScheduledTransaction()).isNotNull();

        }
    }

    @Test
    @DisplayName("Can sign schedule")
    void canSignSchedule2() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            PrivateKey key1 = PrivateKey.generateED25519();
            PrivateKey key2 = PrivateKey.generateED25519();
            PrivateKey key3 = PrivateKey.generateED25519();

            KeyList keyList = new KeyList();

            keyList.add(key1.getPublicKey());
            keyList.add(key2.getPublicKey());
            keyList.add(key3.getPublicKey());

            // Creat the account with the `KeyList`
            TransactionResponse response = new AccountCreateTransaction()
                .setKey(keyList)
                .setInitialBalance(new Hbar(10))
                .execute(testEnv.client);

            // This will wait for the receipt to become available
            @Var TransactionReceipt receipt = response.getReceipt(testEnv.client);

            AccountId accountId = Objects.requireNonNull(receipt.accountId);

            // Generate a `TransactionId`. This id is used to query the inner scheduled transaction
            // after we expect it to have been executed
            TransactionId transactionId = TransactionId.generate(testEnv.operatorId);

            // Create a transfer transaction with 2/3 signatures.
            TransferTransaction transfer = new TransferTransaction()
                .setTransactionId(transactionId)
                .addHbarTransfer(accountId, new Hbar(1).negated())
                .addHbarTransfer(testEnv.operatorId, new Hbar(1));

            // Schedule the transactoin
            ScheduleCreateTransaction scheduled = transfer.schedule();

            receipt = scheduled.execute(testEnv.client).getReceipt(testEnv.client);

            // Get the schedule ID from the receipt
            ScheduleId scheduleId = Objects.requireNonNull(receipt.scheduleId);

            // Get the schedule info to see if `signatories` is populated with 2/3 signatures
            @Var ScheduleInfo info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info.executedAt).isNull();

            // Finally send this last signature to Hedera. This last signature _should_ mean the transaction executes
            // since all 3 signatures have been provided.
            ScheduleSignTransaction signTransaction = new ScheduleSignTransaction()
                .setScheduleId(scheduleId)
                .freezeWith(testEnv.client);

            signTransaction.sign(key1).sign(key2).sign(key3).execute(testEnv.client).getReceipt(testEnv.client);

            info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info.executedAt).isNotNull();

            assertThat(scheduleId.getChecksum()).isNull();
            assertThat(scheduleId.hashCode()).isNotZero();
            assertThat(scheduleId.compareTo(ScheduleId.fromBytes(scheduleId.toBytes()))).isZero();

            new AccountDeleteTransaction()
                .setAccountId(accountId)
                .setTransferAccountId(testEnv.operatorId)
                .freezeWith(testEnv.client)
                .sign(key1).sign(key2).sign(key3)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can schedule token transfer")
    void canScheduleTokenTransfer() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            PrivateKey key = PrivateKey.generateED25519();

            var accountId = new AccountCreateTransaction()
                .setReceiverSignatureRequired(true)
                .setKey(key)
                .setInitialBalance(new Hbar(10))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            Objects.requireNonNull(accountId);

            var tokenId = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setInitialSupply(100)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            Objects.requireNonNull(tokenId);

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var scheduleId = new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, accountId, 10)
                .schedule()
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .scheduleId;

            Objects.requireNonNull(scheduleId);

            var balanceQuery1 = new AccountBalanceQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(balanceQuery1.tokens.get(tokenId)).isEqualTo(0);

            new ScheduleSignTransaction()
                .setScheduleId(scheduleId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var balanceQuery2 = new AccountBalanceQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(balanceQuery2.tokens.get(tokenId)).isEqualTo(10);

        }
    }

    @Test
    @DisplayName("Cannot schedule two identical transactions")
    void cannotScheduleTwoTransactions() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();
            var accountId = new AccountCreateTransaction()
                .setInitialBalance(new Hbar(10))
                .setKey(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var transferTx = new TransferTransaction()
                .addHbarTransfer(testEnv.operatorId, new Hbar(-10))
                .addHbarTransfer(accountId, new Hbar(10));

            var scheduleId1 = transferTx.schedule()
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .scheduleId;

            var info1 = new ScheduleInfoQuery()
                .setScheduleId(scheduleId1)
                .execute(testEnv.client);

            assertThat(info1.executedAt).isNotNull();

            var transferTxFromInfo = info1.getScheduledTransaction();

            var scheduleCreateTx1 = transferTx.schedule();
            var scheduleCreateTx2 = transferTxFromInfo.schedule();

            assertThat(scheduleCreateTx2.toString()).isEqualTo(scheduleCreateTx1.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                transferTxFromInfo.schedule()
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("IDENTICAL_SCHEDULE_ALREADY_CREATED");

        }
    }

    @Test
    @DisplayName("Can schedule topic message")
    void canScheduleTopicMessage() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            // Generate 3 random keys
            var key1 = PrivateKey.generateED25519();

            // This is the submit key
            var key2 = PrivateKey.generateED25519();

            var key3 = PrivateKey.generateED25519();

            var keyList = new KeyList();

            keyList.add(key1.getPublicKey());
            keyList.add(key2.getPublicKey());
            keyList.add(key3.getPublicKey());

            var response = new AccountCreateTransaction()
                    .setInitialBalance(new Hbar(100))
                    .setKey(keyList)
                    .execute(testEnv.client);

            assertThat(response.getReceipt(testEnv.client).accountId).isNotNull();

            var topicId = Objects.requireNonNull(new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setAutoRenewAccountId(testEnv.operatorId)
                .setTopicMemo("HCS Topic_")
                .setSubmitKey(key2.getPublicKey())
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .topicId
            );

            var transaction = new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage("scheduled hcs message".getBytes(StandardCharsets.UTF_8));

            // create schedule
            var scheduledTx = transaction.schedule()
                .setAdminKey(testEnv.operatorKey)
                .setPayerAccountId(testEnv.operatorId)
                .setScheduleMemo("mirror scheduled E2E signature on create and sign_" + Instant.now());

            var scheduled = scheduledTx.freezeWith(testEnv.client);

            var scheduleId = Objects.requireNonNull(scheduled
                .execute(testEnv.client)
                .getReceipt(testEnv.client).scheduleId);

            // verify schedule has been created and has 1 of 2 signatures
            @Var var info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info).isNotNull();
            assertThat(info.scheduleId).isEqualTo(scheduleId);

            var infoTransaction = (TopicMessageSubmitTransaction) info.getScheduledTransaction();

            assertThat(transaction.getTopicId()).isEqualTo(infoTransaction.getTopicId());
            assertThat(transaction.getNodeAccountIds()).isEqualTo(infoTransaction.getNodeAccountIds());

            var scheduleSign = new ScheduleSignTransaction()
                .setScheduleId(scheduleId)
                .freezeWith(testEnv.client);

            scheduleSign
                .sign(key2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new ScheduleInfoQuery()
                .setScheduleId(scheduleId)
                .execute(testEnv.client);

            assertThat(info.executedAt).isNotNull();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/SystemIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.ContractCreateTransaction;
import com.hedera.hashgraph.sdk.ContractFunctionParameters;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.SystemDeleteTransaction;
import com.hedera.hashgraph.sdk.SystemUndeleteTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Instant;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class SystemIntegrationTest {
    private static final String SMART_CONTRACT_BYTECODE = "608060405234801561001057600080fd5b506040516104d73803806104d78339818101604052602081101561003357600080fd5b810190808051604051939291908464010000000082111561005357600080fd5b90830190602082018581111561006857600080fd5b825164010000000081118282018810171561008257600080fd5b82525081516020918201929091019080838360005b838110156100af578181015183820152602001610097565b50505050905090810190601f1680156100dc5780820380516001836020036101000a031916815260200191505b506040525050600080546001600160a01b0319163317905550805161010890600190602084019061010f565b50506101aa565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061015057805160ff191683800117855561017d565b8280016001018555821561017d579182015b8281111561017d578251825591602001919060010190610162565b5061018992915061018d565b5090565b6101a791905b808211156101895760008155600101610193565b90565b61031e806101b96000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063368b87721461004657806341c0e1b5146100ee578063ce6d41de146100f6575b600080fd5b6100ec6004803603602081101561005c57600080fd5b81019060208101813564010000000081111561007757600080fd5b82018360208201111561008957600080fd5b803590602001918460018302840111640100000000831117156100ab57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550610173945050505050565b005b6100ec6101a2565b6100fe6101ba565b6040805160208082528351818301528351919283929083019185019080838360005b83811015610138578181015183820152602001610120565b50505050905090810190601f1680156101655780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6000546001600160a01b0316331461018a5761019f565b805161019d906001906020840190610250565b505b50565b6000546001600160a01b03163314156101b85733ff5b565b60018054604080516020601f600260001961010087891615020190951694909404938401819004810282018101909252828152606093909290918301828280156102455780601f1061021a57610100808354040283529160200191610245565b820191906000526020600020905b81548152906001019060200180831161022857829003601f168201915b505050505090505b90565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061029157805160ff19168380011785556102be565b828001600101855582156102be579182015b828111156102be5782518255916020019190600101906102a3565b506102ca9291506102ce565b5090565b61024d91905b808211156102ca57600081556001016102d456fea264697066735822122084964d4c3f6bc912a9d20e14e449721012d625aa3c8a12de41ae5519752fc89064736f6c63430006000033";

    @Test
    @DisplayName("All system transactions are not supported")
    void allSystemTransactionsAreNotSupported() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var fileId = Objects.requireNonNull(
                new FileCreateTransaction()
                    .setContents(SMART_CONTRACT_BYTECODE)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .fileId);

            var contractId = Objects.requireNonNull(
                new ContractCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setGas(200000)
                    .setConstructorParameters(new ContractFunctionParameters().addString("Hello from Hedera."))
                    .setBytecodeFileId(fileId)
                    .setContractMemo("[e2e::ContractCreateTransaction]")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .contractId
            );

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new SystemDeleteTransaction()
                    .setContractId(contractId)
                    .setExpirationTime(Instant.now())
                    .execute(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new SystemDeleteTransaction()
                    .setFileId(fileId)
                    .setExpirationTime(Instant.now())
                    .execute(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new SystemUndeleteTransaction()
                    .setContractId(contractId)
                    .execute(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new SystemUndeleteTransaction()
                    .setFileId(fileId)
                    .execute(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenAirdropCancelIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static com.hedera.hashgraph.sdk.test.integration.EntityHelper.fungibleInitialBalance;
import static com.hedera.hashgraph.sdk.test.integration.EntityHelper.mitedNfts;
import static org.assertj.core.api.AssertionsForClassTypes.assertThatExceptionOfType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.PendingAirdropId;
import com.hedera.hashgraph.sdk.PendingAirdropRecord;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCancelAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenFreezeTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenPauseTransaction;
import com.hedera.hashgraph.sdk.TransactionId;
import java.util.ArrayList;
import java.util.Collections;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TokenAirdropCancelIntegrationTest {

    private final int amount = 100;

    @Test
    @DisplayName("Cancels the tokens when they are in pending state")
    void canCancelTokens() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // sender cancels the tokens
            record = new TokenCancelAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .addPendingAirdrop(record.pendingAirdropRecords.get(1).getPendingAirdropId())
                .addPendingAirdrop(record.pendingAirdropRecords.get(2).getPendingAirdropId())
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
            assertEquals(0, record.pendingAirdropRecords.size());

            // verify the receiver does not hold the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertNull(receiverAccountBalance.tokens.get(tokenID));
            assertNull(receiverAccountBalance.tokens.get(nftID));

            // verify the operator does hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Cancels the tokens when token is frozen")
    void canCancelTokensWhenTokenIsFrozen() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // associate
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(tokenID))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // freeze the token
            new TokenFreezeTransaction()
                .setAccountId(receiverAccountId)
                .setTokenId(tokenID)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // cancel
            new TokenCancelAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .execute(testEnv.client)
                .getRecord(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cancels the tokens when token is paused")
    void canCancelTokensWhenTokenIsPaused() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // pause the token
            new TokenPauseTransaction().setTokenId(tokenID).execute(testEnv.client).getReceipt(testEnv.client);

            // cancel
            new TokenCancelAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .execute(testEnv.client)
                .getRecord(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cancels the tokens when token is deleted")
    void canCancelTokensWhenTokenIsDeleted() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // delete the token
            new TokenDeleteTransaction().setTokenId(tokenID).execute(testEnv.client).getReceipt(testEnv.client);

            // cancel
            new TokenCancelAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .execute(testEnv.client)
                .getRecord(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cancels the tokens when they are in pending state to multiple receivers")
    void canCancelTokensToMultipleReceivers() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver1 with 0 auto associations
            var receiver1AccountKey = PrivateKey.generateED25519();
            var receiver1AccountId = EntityHelper.createAccount(testEnv, receiver1AccountKey, 0);

            // create receiver2 with 0 auto associations
            var receiver2AccountKey = PrivateKey.generateED25519();
            var receiver2AccountId = EntityHelper.createAccount(testEnv, receiver2AccountKey, 0);

            // airdrop the tokens to both
            var record = new TokenAirdropTransaction()
                    .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiver1AccountId)
                    .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiver1AccountId)
                    .addTokenTransfer(tokenID, receiver1AccountId, amount)
                    .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                    .addNftTransfer(nftID.nft(nftSerials.get(2)), testEnv.operatorId, receiver2AccountId)
                    .addNftTransfer(nftID.nft(nftSerials.get(3)), testEnv.operatorId, receiver2AccountId)
                    .addTokenTransfer(tokenID, receiver2AccountId, amount)
                    .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);

            // verify the txn record
            assertEquals(6, record.pendingAirdropRecords.size());

            // cancel the tokens signing with receiver1 and receiver2
            var pendingAirdropIDs = record.pendingAirdropRecords.stream().map(PendingAirdropRecord::getPendingAirdropId)
                    .toList();
            record = new TokenCancelAirdropTransaction()
                    .setPendingAirdropIds(pendingAirdropIDs)
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);

            // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
            assertEquals(0, record.pendingAirdropRecords.size());

            // verify receiver1 does not hold the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                    .setAccountId(receiver1AccountId)
                    .execute(testEnv.client);
            assertNull(receiverAccountBalance.tokens.get(tokenID));
            assertNull(receiverAccountBalance.tokens.get(nftID));

            // verify receiver2 does not hold the tokens via query
            var receiver2AccountBalance = new AccountBalanceQuery()
                    .setAccountId(receiver1AccountId)
                    .execute(testEnv.client);
            assertNull(receiver2AccountBalance.tokens.get(tokenID));
            assertNull(receiver2AccountBalance.tokens.get(nftID));

            // verify the operator does hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                    .setAccountId(testEnv.operatorId)
                    .execute(testEnv.client);
            assertEquals(fungibleInitialBalance, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Cancels the tokens when they are in pending state from multiple airdrop transactions")
    void canCancelTokensFromMultipleAirdropTxns() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop some of the tokens to the receiver
            var record1 = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getRecord(testEnv.client);
            // airdrop some of the tokens to the receiver
            var record2 = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getRecord(testEnv.client);
            // airdrop some of the tokens to the receiver
            var record3 = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // get the PendingIds from the records
            var pendingAirdropIDs = new ArrayList<PendingAirdropId>();
            pendingAirdropIDs.add(record1.pendingAirdropRecords.get(0).getPendingAirdropId());
            pendingAirdropIDs.add(record2.pendingAirdropRecords.get(0).getPendingAirdropId());
            pendingAirdropIDs.add(record3.pendingAirdropRecords.get(0).getPendingAirdropId());

            // cancel the all the tokens with the receiver
            var record = new TokenCancelAirdropTransaction()
                .setPendingAirdropIds(pendingAirdropIDs)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
            assertEquals(0, record.pendingAirdropRecords.size());

            // verify the receiver does not hold the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertNull(receiverAccountBalance.tokens.get(tokenID));
            assertNull(receiverAccountBalance.tokens.get(nftID));

            // verify the operator does hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Cannot cancel the tokens when they are not airdropped")
    void cannotCancelTokensForNonExistingAirdrop() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // create receiver with 0 auto associations
            var randomAccountKey = PrivateKey.generateED25519();
            var randomAccount = EntityHelper.createAccount(testEnv, randomAccountKey, 0);

            // cancel the tokens with the random account which has not created pending airdrops
            // fails with INVALID_SIGNATURE
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenCancelAirdropTransaction()
                    .setTransactionId(TransactionId.generate(randomAccount))
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Cannot cancel the tokens when they are already canceled")
    void canonCancelTokensForAlreadyCanceledAirdrop() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // cancel the tokens with the receiver
            new TokenCancelAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // cancel the tokens with the receiver again
            // fails with INVALID_PENDING_AIRDROP_ID
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCancelAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.INVALID_PENDING_AIRDROP_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot cancel the tokens with empty list")
    void canonCancelWithEmptyPendingAirdropsList() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // cancel the tokens with the receiver without setting pendingAirdropIds
            // fails with EMPTY_PENDING_AIRDROP_ID_LIST
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenCancelAirdropTransaction()
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.EMPTY_PENDING_AIRDROP_ID_LIST.toString());

        }
    }

    @Test
    @DisplayName("Cannot cancel the tokens with duplicate entries")
    void cannotCancelTokensWithDuplicateEntries() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // cancel the tokens with duplicate pending airdrop token ids
            // fails with PENDING_AIRDROP_ID_REPEATED
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenCancelAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.PENDING_AIRDROP_ID_REPEATED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenAirdropClaimIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static com.hedera.hashgraph.sdk.test.integration.EntityHelper.fungibleInitialBalance;
import static com.hedera.hashgraph.sdk.test.integration.EntityHelper.mitedNfts;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.PendingAirdropId;
import com.hedera.hashgraph.sdk.PendingAirdropRecord;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenClaimAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenFreezeTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenPauseTransaction;
import java.util.ArrayList;
import java.util.Collections;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TokenAirdropClaimIntegrationTest {

    private final int amount = 100;

    @Test
    @DisplayName("Claims the tokens when they are in pending state")
    void canClaimTokens() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify the txn record
            assertEquals(3, record.pendingAirdropRecords.size());

            assertEquals(100, record.pendingAirdropRecords.get(0).getPendingAirdropAmount());
            assertEquals(tokenID, record.pendingAirdropRecords.get(0).getPendingAirdropId().getTokenId());
            assertNull(record.pendingAirdropRecords.get(0).getPendingAirdropId().getNftId());

            assertEquals(0, record.pendingAirdropRecords.get(1).getPendingAirdropAmount());
            assertEquals(nftID.nft(1), record.pendingAirdropRecords.get(1).getPendingAirdropId().getNftId());
            assertNull(record.pendingAirdropRecords.get(1).getPendingAirdropId().getTokenId());

            assertEquals(0, record.pendingAirdropRecords.get(2).getPendingAirdropAmount());
            assertEquals(nftID.nft(2), record.pendingAirdropRecords.get(2).getPendingAirdropId().getNftId());
            assertNull(record.pendingAirdropRecords.get(2).getPendingAirdropId().getTokenId());

            // claim the tokens with the receiver
            record = new TokenClaimAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .addPendingAirdrop(record.pendingAirdropRecords.get(1).getPendingAirdropId())
                .addPendingAirdrop(record.pendingAirdropRecords.get(2).getPendingAirdropId())
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
            assertEquals(0, record.pendingAirdropRecords.size());

            // verify the receiver holds the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiverAccountBalance.tokens.get(tokenID));
            assertEquals(2, receiverAccountBalance.tokens.get(nftID));

            // verify the operator does not hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance - amount, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts - 2, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Claims the tokens when they are in pending state to multiple receivers")
    void canClaimTokensToMultipleReceivers() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver1 with 0 auto associations
            var receiver1AccountKey = PrivateKey.generateED25519();
            var receiver1AccountId = EntityHelper.createAccount(testEnv, receiver1AccountKey, 0);

            // create receiver2 with 0 auto associations
            var receiver2AccountKey = PrivateKey.generateED25519();
            var receiver2AccountId = EntityHelper.createAccount(testEnv, receiver2AccountKey, 0);

            // airdrop the tokens to both
            var record = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiver1AccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiver1AccountId)
                .addTokenTransfer(tokenID, receiver1AccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .addNftTransfer(nftID.nft(nftSerials.get(2)), testEnv.operatorId, receiver2AccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(3)), testEnv.operatorId, receiver2AccountId)
                .addTokenTransfer(tokenID, receiver2AccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify the txn record
            assertEquals(6, record.pendingAirdropRecords.size());

            // claim the tokens signing with receiver1 and receiver2
            var pendingAirdropIDs = record.pendingAirdropRecords.stream().map(PendingAirdropRecord::getPendingAirdropId)
                    .toList();
            record = new TokenClaimAirdropTransaction()
                .setPendingAirdropIds(pendingAirdropIDs)
                .freezeWith(testEnv.client)
                .sign(receiver1AccountKey)
                .sign(receiver2AccountKey)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
            assertEquals(0, record.pendingAirdropRecords.size());
            // verify receiver1 holds the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiver1AccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiverAccountBalance.tokens.get(tokenID));
            assertEquals(2, receiverAccountBalance.tokens.get(nftID));

            // verify receiver2 holds the tokens via query
            var receiver2AccountBalance = new AccountBalanceQuery()
                .setAccountId(receiver1AccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiver2AccountBalance.tokens.get(tokenID));
            assertEquals(2, receiver2AccountBalance.tokens.get(nftID));

            // verify the operator does not hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance - amount * 2, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts - 4, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Claims the tokens when they are in pending state from multiple airdrop transactions")
    void canClaimTokensFromMultipleAirdropTxns() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop some of the tokens to the receiver
            var record1 = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getRecord(testEnv.client);
            // airdrop some of the tokens to the receiver
            var record2 = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getRecord(testEnv.client);
            // airdrop some of the tokens to the receiver
            var record3 = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // get the PendingIds from the records
            var pendingAirdropIDs = new ArrayList<PendingAirdropId>();
            pendingAirdropIDs.add(record1.pendingAirdropRecords.get(0).getPendingAirdropId());
            pendingAirdropIDs.add(record2.pendingAirdropRecords.get(0).getPendingAirdropId());
            pendingAirdropIDs.add(record3.pendingAirdropRecords.get(0).getPendingAirdropId());

            // claim the all the tokens with the receiver
            var record = new TokenClaimAirdropTransaction()
                .setPendingAirdropIds(pendingAirdropIDs)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // verify in the transaction record the pending airdrop ids for nft and ft - should no longer exist
            assertEquals(0, record.pendingAirdropRecords.size());

            // verify the receiver holds the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiverAccountBalance.tokens.get(tokenID));
            assertEquals(2, receiverAccountBalance.tokens.get(nftID));

            // verify the operator does not hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance - amount, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts - 2, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens when they are not airdropped")
    void cannotClaimTokensForNonExistingAirdrop() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // claim the tokens with the operator which does not have pending airdrops
            // fails with INVALID_SIGNATURE
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens when they are already claimed")
    void cannotClaimTokensForAlreadyClaimedAirdrop() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // claim the tokens with the receiver
            new TokenClaimAirdropTransaction()
                .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // claim the tokens with the receiver again
            // fails with INVALID_PENDING_AIRDROP_ID
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.INVALID_PENDING_AIRDROP_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens with empty list")
    void cannotClaimWithEmptyPendingAirdropsList() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // claim the tokens with the receiver without setting pendingAirdropIds
            // fails with EMPTY_PENDING_AIRDROP_ID_LIST
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.EMPTY_PENDING_AIRDROP_ID_LIST.toString());

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens with duplicate entries")
    void cannotClaimTokensWithDuplicateEntries() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // claim the tokens with duplicate pending airdrop token ids
            // fails with PENDING_AIRDROP_ID_REPEATED
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.PENDING_AIRDROP_ID_REPEATED.toString());

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens when token is paused")
    void cannotClaimTokensWhenTokenIsPaused() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // pause the token
            new TokenPauseTransaction().setTokenId(tokenID).execute(testEnv.client).getReceipt(testEnv.client);

            // claim the tokens with receiver
            // fails with TOKEN_IS_PAUSED
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_PAUSED.toString());

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens when token is deleted")
    void cannotClaimTokensWhenTokenIsDeleted() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // delete the token
            new TokenDeleteTransaction().setTokenId(tokenID).execute(testEnv.client).getReceipt(testEnv.client);

            // claim the tokens with receiver
            // fails with TOKEN_IS_DELETED
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.TOKEN_WAS_DELETED.toString());

        }
    }

    @Test
    @DisplayName("Cannot claim the tokens when token is frozen")
    void cannotClaimTokensWhenTokenIsFrozen() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with 0 auto associations
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var record = new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            // associate
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(tokenID))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // freeze the token
            new TokenFreezeTransaction()
                .setAccountId(receiverAccountId)
                .setTokenId(tokenID)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // claim the tokens with receiver
            // fails with ACCOUNT_FROZEN_FOR_TOKEN
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenClaimAirdropTransaction()
                    .addPendingAirdrop(record.pendingAirdropRecords.get(0).getPendingAirdropId())
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getRecord(testEnv.client);
            }).withMessageContaining(Status.ACCOUNT_FROZEN_FOR_TOKEN.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenAirdropTransactionIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static com.hedera.hashgraph.sdk.test.integration.EntityHelper.fungibleInitialBalance;
import static com.hedera.hashgraph.sdk.test.integration.EntityHelper.mitedNfts;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;

import com.hedera.hashgraph.sdk.AccountAllowanceApproveTransaction;
import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.CustomFixedFee;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAirdropTransaction;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenSupplyType;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.Collections;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TokenAirdropTransactionIntegrationTest {

    private final int amount = 100;

    @Test
    @DisplayName("Transfers tokens when the account is associated")
    void canAirdropAssociatedTokens() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with unlimited auto associations and receiverSig = false
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, -1);

            // airdrop the tokens
            new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the receiver holds the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiverAccountBalance.tokens.get(tokenID));
            assertEquals(2, receiverAccountBalance.tokens.get(nftID));

            // verify the operator does not hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance - amount, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts - 2, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Tokens are in pending state when the account is not associated")
    void canAirdropNonAssociatedTokens() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with 0 auto associations and receiverSig = false
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // airdrop the tokens
            var txn = new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client);
            txn.setValidateStatus(true).getReceipt(testEnv.client);
            var record = txn.getRecord(testEnv.client);

            // verify in the transaction record the pending airdrops
            assertThat(record.pendingAirdropRecords).isNotNull();
            assertFalse(record.pendingAirdropRecords.isEmpty());

            // verify the receiver does not hold the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertNull(receiverAccountBalance.tokens.get(tokenID));
            assertNull(receiverAccountBalance.tokens.get(nftID));

            // verify the operator does hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Airdrop creates a hollow account and transfers the tokens")
    void canAirdropToAlias() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible and nf token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // airdrop the tokens to an alias
            PrivateKey privateKey = PrivateKey.generateED25519();
            PublicKey publicKey = privateKey.getPublicKey();

            AccountId aliasAccountId = publicKey.toAccountId(0, 0);

            // should lazy-create and transfer the tokens
            new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, aliasAccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, aliasAccountId)
                .addTokenTransfer(tokenID, aliasAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the receiver holds the tokens via query
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(aliasAccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiverAccountBalance.tokens.get(tokenID));
            assertEquals(2, receiverAccountBalance.tokens.get(nftID));

            // verify the operator does not hold the tokens
            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance - amount, operatorBalance.tokens.get(tokenID));
            assertEquals(mitedNfts - 2, operatorBalance.tokens.get(nftID));

        }
    }

    @Test
    @DisplayName("Can airdrop with custom fees")
    void canAirdropWithCustomFee() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create receiver unlimited auto associations and receiverSig = false
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, -1);

            // create fungible token with custom fee another token
            var customFeeTokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // make the custom fee to be paid by the sender and the fee collector to be the operator account
            CustomFixedFee fee = new CustomFixedFee()
                .setFeeCollectorAccountId(testEnv.operatorId)
                .setDenominatingTokenId(customFeeTokenID)
                .setAmount(1)
                .setAllCollectorsAreExempt(true);

            var tokenID = new TokenCreateTransaction()
                .setTokenName("Test Fungible Token")
                .setTokenSymbol("TFT")
                .setTokenMemo("I was created for integration tests")
                .setDecimals(3)
                .setInitialSupply(fungibleInitialBalance)
                .setMaxSupply(fungibleInitialBalance)
                .setTreasuryAccountId(testEnv.operatorId)
                .setSupplyType(TokenSupplyType.FINITE)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setMetadataKey(testEnv.operatorKey)
                .setPauseKey(testEnv.operatorKey)
                .setCustomFees(Collections.singletonList(fee))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            // create sender account with unlimited associations and send some tokens to it
            var senderKey = PrivateKey.generateED25519();
            var senderAccountID = EntityHelper.createAccount(testEnv, senderKey, -1);

            // associate the token to the sender
            new TokenAssociateTransaction()
                .setAccountId(senderAccountID)
                .setTokenIds(Collections.singletonList(customFeeTokenID))
                .freezeWith(testEnv.client)
                .sign(senderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // send tokens to the sender
            new TransferTransaction()
                .addTokenTransfer(customFeeTokenID, testEnv.operatorId, -amount)
                .addTokenTransfer(customFeeTokenID, senderAccountID, amount)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .addTokenTransfer(tokenID, senderAccountID, amount)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // airdrop the tokens from the sender to the receiver
            new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, senderAccountID, -amount)
                .freezeWith(testEnv.client)
                .sign(senderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the custom fee has been paid by the sender to the collector
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertEquals(amount, receiverAccountBalance.tokens.get(tokenID));

            var senderAccountBalance = new AccountBalanceQuery()
                .setAccountId(senderAccountID)
                .execute(testEnv.client);
            assertEquals(0, senderAccountBalance.tokens.get(tokenID));
            assertEquals(amount - 1, senderAccountBalance.tokens.get(customFeeTokenID));

            var operatorBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);
            assertEquals(fungibleInitialBalance - amount + 1, operatorBalance.tokens.get(customFeeTokenID));
            assertEquals(fungibleInitialBalance - amount, operatorBalance.tokens.get(tokenID));

        }
    }

    @Test
    @DisplayName("Can airdrop ft with receiverSig=true")
    void canAirdropTokensWithReceiverSigRequiredFungible() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create receiver with unlimited auto associations and receiverSig = true
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = new AccountCreateTransaction()
                .setKey(receiverAccountKey)
                .setInitialBalance(new Hbar(1))
                .setReceiverSignatureRequired(true)
                .setMaxAutomaticTokenAssociations(-1)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            // airdrop the tokens
            new TokenAirdropTransaction()
                .addTokenTransfer(tokenID, receiverAccountId, amount)
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can airdrop nft with receiverSig=true")
    void canAirdropTokensWithReceiverSigRequiredNFT() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create nft
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create receiver with unlimited auto associations and receiverSig = true
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = new AccountCreateTransaction()
                .setKey(receiverAccountKey)
                .setInitialBalance(new Hbar(1))
                .setReceiverSignatureRequired(true)
                .setMaxAutomaticTokenAssociations(-1)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            // airdrop the tokens
            new TokenAirdropTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot airdrop ft with no balance")
    void cannotAirdropTokensWithAllowanceAndWithoutBalanceFungible() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // create spender and approve to it some tokens
            var spenderKey = PrivateKey.generateED25519();
            var spenderAccountID = EntityHelper.createAccount(testEnv, spenderKey, -1);

            // create sender
            var senderKey = PrivateKey.generateED25519();
            var senderAccountID = EntityHelper.createAccount(testEnv, senderKey, -1);

            // transfer ft to sender
            new TransferTransaction()
                .addTokenTransfer(tokenID, testEnv.operatorId, -amount)
                .addTokenTransfer(tokenID, senderAccountID, amount)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // approve allowance to the spender
            new AccountAllowanceApproveTransaction()
                .approveTokenAllowance(tokenID, senderAccountID, spenderAccountID, amount)
                .freezeWith(testEnv.client)
                .sign(senderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // airdrop the tokens from the sender to the spender via approval
            // fails with NOT_SUPPORTED
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenAirdropTransaction()
                    .addTokenTransfer(tokenID, spenderAccountID, amount)
                    .addApprovedTokenTransfer(tokenID, spenderAccountID, -amount)
                    .setTransactionId(TransactionId.generate(spenderAccountID))
                    .freezeWith(testEnv.client)
                    .sign(spenderKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

        }
    }

    @Test
    @DisplayName("Cannot airdrop nft with no balance")
    void cannotAirdropTokensWithAllowanceAndWithoutBalanceNFT() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // create nft
            var nftID = EntityHelper.createNft(testEnv);
            // mint some NFTs
            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftID)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            var nftSerials = mintReceipt.serials;

            // create spender and approve to it some tokens
            var spenderKey = PrivateKey.generateED25519();
            var spenderAccountID = EntityHelper.createAccount(testEnv, spenderKey, -1);

            // create sender
            var senderKey = PrivateKey.generateED25519();
            var senderAccountID = EntityHelper.createAccount(testEnv, senderKey, -1);

            // transfer ft to sender
            new TransferTransaction()
                .addNftTransfer(nftID.nft(nftSerials.get(0)), testEnv.operatorId, senderAccountID)
                .addNftTransfer(nftID.nft(nftSerials.get(1)), testEnv.operatorId, senderAccountID)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // approve allowance to the spender
            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowance(nftID.nft(nftSerials.get(0)), senderAccountID, spenderAccountID)
                .approveTokenNftAllowance(nftID.nft(nftSerials.get(1)), senderAccountID, spenderAccountID)
                .freezeWith(testEnv.client)
                .sign(senderKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // airdrop the tokens from the sender to the spender via approval
            // fails with NOT_SUPPORTED
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenAirdropTransaction()
                    .addApprovedNftTransfer(nftID.nft(nftSerials.get(0)), senderAccountID, spenderAccountID)
                    .addApprovedNftTransfer(nftID.nft(nftSerials.get(1)), senderAccountID, spenderAccountID)
                    .setTransactionId(TransactionId.generate(spenderAccountID))
                    .freezeWith(testEnv.client)
                    .sign(spenderKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.NOT_SUPPORTED.toString());

        }
    }

    @Test
    @DisplayName("Cannot airdrop with invalid body")
    void cannotAirdropTokensWithInvalidBody() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            // airdrop with no tokenID or NftID
            // fails with EMPTY_TOKEN_TRANSFER_BODY
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenAirdropTransaction()
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.EMPTY_TOKEN_TRANSFER_BODY.toString());

            // create fungible token
            var tokenID = EntityHelper.createFungibleToken(testEnv, 3);

            // airdrop with invalid transfers
            // fails with INVALID_TRANSACTION_BODY
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenAirdropTransaction()
                    .addTokenTransfer(tokenID, testEnv.operatorId, 100)
                    .addTokenTransfer(tokenID, testEnv.operatorId, 100)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TRANSACTION_BODY.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenAutomaticAssociationIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountAllowanceApproveTransaction;
import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountInfoQuery;
import com.hedera.hashgraph.sdk.AccountUpdateTransaction;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.ArrayList;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class TokenAutomaticAssociationIntegrationTest {

    @Test
    @DisplayName("Can transfer Fungible Tokens to accounts with Limited Max Auto Associations")
    void canTransferFungibleTokensToAccountsWithLimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createFungibleToken(testEnv, 0);
            var tokenId2 = EntityHelper.createFungibleToken(testEnv, 0);
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 1;
            var receiverAccountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            var accountInfoBeforeTokenAssociation = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertThat(accountInfoBeforeTokenAssociation.maxAutomaticTokenAssociations).isEqualTo(1);
            assertThat(accountInfoBeforeTokenAssociation.tokenRelationships.size()).isEqualTo(0);


            var transferRecord = new TransferTransaction()
                .addTokenTransfer(tokenId1, testEnv.operatorId, -1)
                .addTokenTransfer(tokenId1, receiverAccountId, 1)
                .execute(testEnv.client)
                .getRecord(testEnv.client);
            assertThat(transferRecord.automaticTokenAssociations.size()).isEqualTo(1);
            assertThat(transferRecord.automaticTokenAssociations.get(0).accountId).isEqualTo(receiverAccountId);
            assertThat(transferRecord.automaticTokenAssociations.get(0).tokenId).isEqualTo(tokenId1);

            var accountInfoAfterTokenAssociation = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertThat(accountInfoAfterTokenAssociation.tokenRelationships.size()).isEqualTo(1);
            assertThat(accountInfoAfterTokenAssociation.tokenRelationships.get(tokenId1).automaticAssociation).isTrue();

            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addTokenTransfer(tokenId2, testEnv.operatorId, -1)
                    .addTokenTransfer(tokenId2, receiverAccountId, 1)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("NO_REMAINING_AUTOMATIC_ASSOCIATIONS");

            new AccountUpdateTransaction()
                .setAccountId(receiverAccountId)
                .setMaxAutomaticTokenAssociations(2)
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountInfoAfterMaxAssocUpdate = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertThat(accountInfoAfterMaxAssocUpdate.maxAutomaticTokenAssociations).isEqualTo(2);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can transfer Nfts to accounts with Limited Max Auto Associations")
    void canTransferNftsToAccountsWithLimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createNft(testEnv);
            var tokenId2 = EntityHelper.createNft(testEnv);
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 1;
            var receiverAccountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            var mintReceiptToken1 = new TokenMintTransaction()
                .setTokenId(tokenId1)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var mintReceiptToken2 = new TokenMintTransaction()
                .setTokenId(tokenId2)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountInfoBeforeTokenAssociation = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertThat(accountInfoBeforeTokenAssociation.maxAutomaticTokenAssociations).isEqualTo(1);
            assertThat(accountInfoBeforeTokenAssociation.tokenRelationships.size()).isEqualTo(0);


            var serialsToTransfer = new ArrayList<>(mintReceiptToken2.serials);
            var nftTransferTransaction = new TransferTransaction();
            for (var serial : serialsToTransfer) {
                nftTransferTransaction.addNftTransfer(tokenId1.nft(serial), testEnv.operatorId, receiverAccountId);
            }
            var transferRecord = nftTransferTransaction
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            assertThat(transferRecord.automaticTokenAssociations.size()).isEqualTo(1);
            assertThat(transferRecord.automaticTokenAssociations.get(0).accountId).isEqualTo(receiverAccountId);
            assertThat(transferRecord.automaticTokenAssociations.get(0).tokenId).isEqualTo(tokenId1);

            var accountInfoAfterTokenAssociation = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertThat(accountInfoAfterTokenAssociation.tokenRelationships.size()).isEqualTo(1);
            assertThat(accountInfoAfterTokenAssociation.tokenRelationships.get(tokenId1).automaticAssociation).isTrue();

            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                var serial = mintReceiptToken2.serials.get(0);
                new TransferTransaction()
                    .addNftTransfer(tokenId2.nft(serial), testEnv.operatorId, receiverAccountId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("NO_REMAINING_AUTOMATIC_ASSOCIATIONS");

            new AccountUpdateTransaction()
                .setAccountId(receiverAccountId)
                .setMaxAutomaticTokenAssociations(2)
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountInfoAfterMaxAssocUpdate = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);
            assertThat(accountInfoAfterMaxAssocUpdate.maxAutomaticTokenAssociations).isEqualTo(2);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Can set unlimited max auto associations for Account")
    void canSetUnlimitedMaxAutoAssociationsForAccount() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = -1;
            var accountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            new AccountUpdateTransaction()
                .setAccountId(accountId)
                .setMaxAutomaticTokenAssociations(accountMaxAutomaticTokenAssociations)
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountInfoBeforeTokenAssociation = new AccountInfoQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);
            assertThat(accountInfoBeforeTokenAssociation.maxAutomaticTokenAssociations).isEqualTo(-1);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Can transfer Fungible Tokens to accounts with Unlimited Max Auto Associations")
    void canTransferFungibleTokensToAccountsWithUnlimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createFungibleToken(testEnv, 3);
            var tokenId2 = EntityHelper.createFungibleToken(testEnv, 3);
            var accountKey = PrivateKey.generateED25519();
            var accountId1 = EntityHelper.createAccount(testEnv, accountKey, -1);
            var accountId2 = EntityHelper.createAccount(testEnv, accountKey, 100);

            new AccountUpdateTransaction()
                .setAccountId(accountId2)
                .setMaxAutomaticTokenAssociations(-1)
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer to both receivers some token1 tokens
            new TransferTransaction()
                .addTokenTransfer(tokenId1, testEnv.operatorId, -1000)
                .addTokenTransfer(tokenId1, accountId1, 1000)
                .addTokenTransfer(tokenId1, testEnv.operatorId, -1000)
                .addTokenTransfer(tokenId1, accountId2, 1000)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer to both receivers some token2 tokens
            new TransferTransaction()
                .addTokenTransfer(tokenId2, testEnv.operatorId, -1000)
                .addTokenTransfer(tokenId2, accountId1, 1000)
                .addTokenTransfer(tokenId2, testEnv.operatorId, -1000)
                .addTokenTransfer(tokenId2, accountId2, 1000)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance of the receivers is 1000
            var accountId1Balance = new AccountBalanceQuery()
                .setAccountId(accountId1)
                .execute(testEnv.client);

            assertThat(accountId1Balance.tokens.get(tokenId1)).isEqualTo(1000);
            assertThat(accountId1Balance.tokens.get(tokenId2)).isEqualTo(1000);

            var accountId2Balance = new AccountBalanceQuery()
                .setAccountId(accountId2)
                .execute(testEnv.client);

            assertThat(accountId2Balance.tokens.get(tokenId1)).isEqualTo(1000);
            assertThat(accountId2Balance.tokens.get(tokenId2)).isEqualTo(1000);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Can transfer Fungible Tokens (With Decimals) to accounts with Unlimited Max Auto Associations")
    void canTransferFungibleTokensWithDecimalsToAccountsWithUnlimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenDecimals = 10;
            var tokenId1 = EntityHelper.createFungibleToken(testEnv, tokenDecimals);
            var tokenId2 = EntityHelper.createFungibleToken(testEnv, tokenDecimals);
            var accountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, accountKey, -1);

            new TransferTransaction()
                .addTokenTransferWithDecimals(tokenId1, testEnv.operatorId, -1000, tokenDecimals)
                .addTokenTransferWithDecimals(tokenId1, receiverAccountId, 1000, tokenDecimals)
                .addTokenTransferWithDecimals(tokenId2, testEnv.operatorId, -1000, tokenDecimals)
                .addTokenTransferWithDecimals(tokenId2, receiverAccountId, 1000, tokenDecimals)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(receiverAccountBalance.tokens.get(tokenId1)).isEqualTo(1000);
            assertThat(receiverAccountBalance.tokens.get(tokenId2)).isEqualTo(1000);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Can transfer Fungible Tokens on Behalf Of Owner to account with Unlimited Max Auto Associations")
    void canTransferFungibleTokensOnBehalfOfOwnerToAccountWithUnlimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createFungibleToken(testEnv, 3);
            var tokenId2 = EntityHelper.createFungibleToken(testEnv, 3);
            var accountKey = PrivateKey.generateED25519();
            var accountId = EntityHelper.createAccount(testEnv, accountKey, -1);
            var spenderAccountKey = PrivateKey.generateED25519();
            var spenderAccountId = EntityHelper.createAccount(testEnv, spenderAccountKey, -1);

            new AccountAllowanceApproveTransaction()
                .approveTokenAllowance(tokenId1, testEnv.operatorId, spenderAccountId, 2000)
                .approveTokenAllowance(tokenId2, testEnv.operatorId, spenderAccountId, 2000)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var record = new TransferTransaction()
                .addApprovedTokenTransfer(tokenId1, testEnv.operatorId, -1000)
                .addTokenTransfer(tokenId1, accountId, 1000)
                .addApprovedTokenTransfer(tokenId2, testEnv.operatorId, -1000)
                .addTokenTransfer(tokenId2, accountId, 1000)
                .setTransactionId(TransactionId.generate(spenderAccountId))
                .freezeWith(testEnv.client)
                .sign(spenderAccountKey)
                .execute(testEnv.client)
                .getRecord(testEnv.client);

            var accountBalance = new AccountBalanceQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(accountBalance.tokens.get(tokenId1)).isEqualTo(1000);
            assertThat(accountBalance.tokens.get(tokenId2)).isEqualTo(1000);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Can transfer Nfts to accounts with Unlimited Max Auto Associations")
    void canTransferNftsToAccountsWithUnlimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createNft(testEnv);
            var tokenId2 = EntityHelper.createNft(testEnv);
            var accountKey = PrivateKey.generateED25519();
            var accountId1 = EntityHelper.createAccount(testEnv, accountKey, -1);
            var accountId2 = EntityHelper.createAccount(testEnv, accountKey, 100);

            var mintReceiptToken1 = new TokenMintTransaction()
                .setTokenId(tokenId1)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var mintReceiptToken2 = new TokenMintTransaction()
                .setTokenId(tokenId2)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptToken2.serials;

            new AccountUpdateTransaction()
                .setAccountId(accountId2)
                .setMaxAutomaticTokenAssociations(-1)
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer nft1 to both receivers, 2 for each
            new TransferTransaction()
                .addNftTransfer(tokenId1.nft(nftSerials.get(0)), testEnv.operatorId, accountId1)
                .addNftTransfer(tokenId1.nft(nftSerials.get(1)), testEnv.operatorId, accountId1)
                .addNftTransfer(tokenId1.nft(nftSerials.get(2)), testEnv.operatorId, accountId2)
                .addNftTransfer(tokenId1.nft(nftSerials.get(3)), testEnv.operatorId, accountId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer nft2 to both receivers, 2 for each
            new TransferTransaction()
                .addNftTransfer(tokenId2.nft(nftSerials.get(0)), testEnv.operatorId, accountId1)
                .addNftTransfer(tokenId2.nft(nftSerials.get(1)), testEnv.operatorId, accountId1)
                .addNftTransfer(tokenId2.nft(nftSerials.get(2)), testEnv.operatorId, accountId2)
                .addNftTransfer(tokenId2.nft(nftSerials.get(3)), testEnv.operatorId, accountId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance of the receivers is 2
            var accountId1Balance = new AccountBalanceQuery()
                .setAccountId(accountId1)
                .execute(testEnv.client);

            assertThat(accountId1Balance.tokens.get(tokenId1)).isEqualTo(2);
            assertThat(accountId1Balance.tokens.get(tokenId2)).isEqualTo(2);

            var accountId2Balance = new AccountBalanceQuery()
                .setAccountId(accountId2)
                .execute(testEnv.client);

            assertThat(accountId2Balance.tokens.get(tokenId1)).isEqualTo(2);
            assertThat(accountId2Balance.tokens.get(tokenId2)).isEqualTo(2);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Can transfer Nfts on Behalf Of Owner to account with Unlimited Max Auto Associations")
    void canTransferNftsOnBehalfOfOwnerToAccountWithUnlimitedMaxAutoAssociations() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createNft(testEnv);
            var tokenId2 = EntityHelper.createNft(testEnv);
            var accountKey = PrivateKey.generateED25519();
            var accountId = EntityHelper.createAccount(testEnv, accountKey, -1);
            var spenderAccountKey = PrivateKey.generateED25519();
            var spenderAccountId = EntityHelper.createAccount(testEnv, spenderAccountKey, -1);

            var mintReceiptToken1 = new TokenMintTransaction()
                .setTokenId(tokenId1)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var mintReceiptToken2 = new TokenMintTransaction()
                .setTokenId(tokenId2)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptToken2.serials;

            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowanceAllSerials(tokenId1, testEnv.operatorId, spenderAccountId)
                .approveTokenNftAllowanceAllSerials(tokenId2, testEnv.operatorId, spenderAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addApprovedNftTransfer(tokenId1.nft(nftSerials.get(0)), testEnv.operatorId, accountId)
                .addApprovedNftTransfer(tokenId1.nft(nftSerials.get(1)), testEnv.operatorId, accountId)
                .addApprovedNftTransfer(tokenId2.nft(nftSerials.get(0)), testEnv.operatorId, accountId)
                .addApprovedNftTransfer(tokenId2.nft(nftSerials.get(1)), testEnv.operatorId, accountId)
                .setTransactionId(TransactionId.generate(spenderAccountId))
                .freezeWith(testEnv.client)
                .sign(spenderAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountBalance = new AccountBalanceQuery()
                .setAccountId(accountId)
                .execute(testEnv.client);

            assertThat(accountBalance.tokens.get(tokenId1)).isEqualTo(2);
            assertThat(accountBalance.tokens.get(tokenId2)).isEqualTo(2);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-904
     * @url https://hips.hedera.com/hip/hip-904
     */
    @Test
    @DisplayName("Cannot Set Invalid Max Auto Associations Values")
    void cannotSetInvalidMaxAutoAssociationsValues() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var accountKey = PrivateKey.generateED25519();

            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
            new AccountCreateTransaction()
                .setKey(accountKey)
                .setMaxAutomaticTokenAssociations(-2)
                .execute(testEnv.client);
            }).withMessageContaining("INVALID_MAX_AUTO_ASSOCIATIONS");

            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new AccountCreateTransaction()
                    .setKey(accountKey)
                    .setMaxAutomaticTokenAssociations(-1000)
                    .execute(testEnv.client);
            }).withMessageContaining("INVALID_MAX_AUTO_ASSOCIATIONS");

            var accountId = EntityHelper.createAccount(testEnv, accountKey, 100);

            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new AccountUpdateTransaction()
                    .setAccountId(accountId)
                    .setMaxAutomaticTokenAssociations(-2)
                    .freezeWith(testEnv.client)
                    .sign(accountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("INVALID_MAX_AUTO_ASSOCIATIONS");

            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new AccountUpdateTransaction()
                    .setAccountId(accountId)
                    .setMaxAutomaticTokenAssociations(-1000)
                    .freezeWith(testEnv.client)
                    .sign(accountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("INVALID_MAX_AUTO_ASSOCIATIONS");
        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenBurnIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenBurnTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenBurnIntegrationTest {
    @Test
    @DisplayName("Can burn tokens")
    void canBurnTokens() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var receipt = new TokenBurnTransaction()
                .setAmount(10)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.totalSupply).isEqualTo(1000000 - 10);

        }
    }

    @Test
    @DisplayName("Cannot burn tokens when token ID is not set")
    void cannotBurnTokensWhenTokenIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenBurnTransaction()
                    .setAmount(10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }

    @Test
    @DisplayName("Can burn tokens when amount is not set")
    void canBurnTokensWhenAmountIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var receipt = new TokenBurnTransaction()
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

        }
    }

    @Test
    @DisplayName("Cannot burn tokens when supply key does not sign transaction")
    void cannotBurnTokensWhenSupplyKeyDoesNotSignTransaction() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(PrivateKey.generate())
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenBurnTransaction()
                    .setTokenId(tokenId)
                    .setAmount(10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Can burn NFTs")
    void canBurnNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenBurnTransaction()
                .setSerials(mintReceipt.serials.subList(0, 4))
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot burn NFTs when NFT is not owned by treasury")
    void cannotBurnNftsWhenNftIsNotOwned() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            var serials = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 1))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .serials;

            var key = PrivateKey.generateED25519();

            var accountId = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .signWithOperator(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addNftTransfer(tokenId.nft(serials.get(0)), testEnv.operatorId, accountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenBurnTransaction()
                    .setSerials(serials)
                    .setTokenId(tokenId)
                    .execute(testEnv.client)
                        .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TREASURY_MUST_OWN_BURNED_NFT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenCreateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.CustomFee;
import com.hedera.hashgraph.sdk.CustomFixedFee;
import com.hedera.hashgraph.sdk.CustomFractionalFee;
import com.hedera.hashgraph.sdk.CustomRoyaltyFee;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TokenCreateIntegrationTest {
    private static List<CustomFee> createFixedFeeList(int count, AccountId feeCollector) {
        var feeList = new ArrayList<CustomFee>();
        for (int i = 0; i < count; i++) {
            feeList.add(new CustomFixedFee()
                .setAmount(10)
                .setFeeCollectorAccountId(feeCollector));
        }
        return feeList;
    }

    private static List<CustomFee> createFractionalFeeList(int count, AccountId feeCollector) {
        var feeList = new ArrayList<CustomFee>();
        for (int i = 0; i < count; i++) {
            feeList.add(new CustomFractionalFee()
                .setNumerator(1)
                .setDenominator(20)
                .setMin(1)
                .setMax(10)
                .setFeeCollectorAccountId(feeCollector));
        }
        return feeList;
    }

    @Test
    @DisplayName("Can create token with operator as all keys")
    void canCreateTokenWithOperatorAsAllKeys() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFeeScheduleKey(testEnv.operatorKey)
                .setPauseKey(testEnv.operatorKey)
                .setMetadataKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            Objects.requireNonNull(response.getReceipt(testEnv.client));

        }
    }

    @Test
    @DisplayName("Can create token with minimal properties set")
    @SuppressWarnings("UnusedVariable")
    void canCreateTokenWithMinimalPropertiesSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot create token when token name is not set")
    void cannotCreateTokenWhenTokenNameIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(testEnv.operatorId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            }).withMessageContaining(Status.MISSING_TOKEN_NAME.toString());

        }
    }

    @Test
    @DisplayName("Cannot create token when token symbol is not set")
    void cannotCreateTokenWhenTokenSymbolIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTreasuryAccountId(testEnv.operatorId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            }).withMessageContaining(Status.MISSING_TOKEN_SYMBOL.toString());

        }
    }

    @Test
    @DisplayName("Cannot create token when token treasury account ID is not set")
    void cannotCreateTokenWhenTokenTreasuryAccountIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            }).withMessageContaining(Status.INVALID_TREASURY_ACCOUNT_FOR_TOKEN.toString());

        }
    }

    @Test
    @DisplayName("Cannot create token when token treasury account ID does not sign transaction")
    void cannotCreateTokenWhenTokenTreasuryAccountIDDoesNotSignTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(AccountId.fromString("0.0.3"))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Cannot create token when admin key does not sign transaction")
    void cannotCreateTokenWhenAdminKeyDoesNotSignTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var key = PrivateKey.generateED25519();

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Can create token with custom fees")
    void canCreateTokenWithCustomFees() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var customFees = new ArrayList<CustomFee>();
            customFees.add(new CustomFixedFee()
                .setAmount(10)
                .setFeeCollectorAccountId(testEnv.operatorId)
            );
            customFees.add(new CustomFractionalFee()
                .setNumerator(1)
                .setDenominator(20)
                .setMin(1)
                .setMax(10)
                .setFeeCollectorAccountId(testEnv.operatorId)
            );

            new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setCustomFees(customFees)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
        }
    }

    @Test
    @DisplayName("Cannot create custom fee list with > 10 entries")
    void cannotCreateMoreThanTenCustomFees() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setAdminKey(testEnv.operatorKey)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setCustomFees(createFixedFeeList(11, testEnv.operatorId))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.CUSTOM_FEES_LIST_TOO_LONG.toString());

        }
    }

    @Test
    @DisplayName("Can create custom fee list with 10 fixed fees")
    void canCreateTenFixedFees() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setCustomFees(createFixedFeeList(10, testEnv.operatorId))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can create custom fee list with 10 fractional fees")
    void canCreateTenFractionalFees() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

        new TokenCreateTransaction()
            .setTokenName("ffff")
            .setTokenSymbol("F")
            .setAdminKey(testEnv.operatorKey)
            .setTreasuryAccountId(testEnv.operatorId)
            .setCustomFees(createFractionalFeeList(10, testEnv.operatorId))
            .execute(testEnv.client)
            .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot create a token with a custom fee where min > max")
    void cannotCreateMinGreaterThanMax() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setCustomFees(Collections.singletonList(new CustomFractionalFee()
                        .setNumerator(1)
                        .setDenominator(3)
                        .setMin(3)
                        .setMax(2)
                        .setFeeCollectorAccountId(testEnv.operatorId)))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT.toString());

        }
    }

    @Test
    @DisplayName("Cannot create a token with invalid fee collector account ID")
    void cannotCreateInvalidFeeCollector() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setAdminKey(testEnv.operatorKey)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setCustomFees(Collections.singletonList(new CustomFixedFee()
                        .setAmount(1)))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_CUSTOM_FEE_COLLECTOR.toString());

        }
    }

    @Test
    @DisplayName("Cannot create a token with a negative custom fee")
    void cannotCreateNegativeFee() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setAdminKey(testEnv.operatorKey)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setCustomFees(Collections.singletonList(new CustomFixedFee()
                        .setAmount(-1)
                        .setFeeCollectorAccountId(testEnv.operatorId)))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.CUSTOM_FEE_MUST_BE_POSITIVE.toString());

        }
    }

    @Test
    @DisplayName("Cannot create custom fee with 0 denominator")
    void cannotCreateZeroDenominator() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setCustomFees(Collections.singletonList(new CustomFractionalFee()
                        .setNumerator(1)
                        .setDenominator(0)
                        .setMin(1)
                        .setMax(10)
                        .setFeeCollectorAccountId(testEnv.operatorId)))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.FRACTION_DIVIDES_BY_ZERO.toString());

        }
    }

    @Test
    @DisplayName("Can create NFT")
    void canCreateNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

        }
    }

    @Test
    @DisplayName("Can create NFT with royalty fee")
    void canCreateRoyaltyFee() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setSupplyKey(testEnv.operatorKey)
                .setAdminKey(testEnv.operatorKey)
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setCustomFees(Collections.singletonList(new CustomRoyaltyFee()
                    .setNumerator(1)
                    .setDenominator(10)
                    .setFallbackFee(new CustomFixedFee().setHbarAmount(new Hbar(1)))
                    .setFeeCollectorAccountId(testEnv.operatorId)))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenDeleteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenDeleteIntegrationTest {
    @Test
    @DisplayName("Can delete token")
    void canDeleteToken() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            new TokenDeleteTransaction()
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can delete token with only admin key set")
    void canDeleteTokenWithOnlyAdminKeySet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .execute(testEnv.client);

            Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

        }
    }

    @Test
    @DisplayName("Cannot delete token when admin key does not sign transaction")
    void cannotDeleteTokenWhenAdminKeyDoesNotSignTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var key = PrivateKey.generateED25519();

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(key)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenDeleteTransaction()
                    .setTokenId(tokenId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            new TokenDeleteTransaction()
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot delete token when token ID is not set")
    void cannotDeleteTokenWhenTokenIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenDeleteTransaction()
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenDissociateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenDissociateTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenDissociateIntegrationTest {
    @Test
    @DisplayName("Can dissociate account with token")
    void canAssociateAccountWithToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDissociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute token dissociate transaction even when token IDs are not set")
    void canExecuteTokenDissociateTransactionEvenWhenTokenIDsAreNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            new TokenDissociateTransaction()
                .setAccountId(accountId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot dissociate account with tokens when account ID is not set")
    void cannotDissociateAccountWithTokensWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenDissociateTransaction()
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot dissociate account with tokens when account does not sign transaction")
    void cannotDissociateAccountWhenAccountDoesNotSignTransaction() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenDissociateTransaction()
                    .setAccountId(accountId)
                    .setTokenIds(Collections.singletonList(tokenId))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Cannot dissociate account from token when account was not associated with")
    void cannotDissociateAccountFromTokenWhenAccountWasNotAssociatedWith() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenDissociateTransaction()
                    .setAccountId(accountId)
                    .setTokenIds(Collections.singletonList(tokenId))
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenFeeScheduleUpdateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.CustomFee;
import com.hedera.hashgraph.sdk.CustomFixedFee;
import com.hedera.hashgraph.sdk.CustomFractionalFee;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenFeeScheduleUpdateTransaction;
import com.hedera.hashgraph.sdk.TokenInfoQuery;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Objects;

import static org.assertj.core.api.Assertions.as;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenFeeScheduleUpdateIntegrationTest {
    @Test
    @DisplayName("Can update token fees")
    void canUpdateToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFeeScheduleKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            @Var var info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("ffff");
            assertThat(info.symbol).isEqualTo("F");
            assertThat(info.decimals).isEqualTo(3);
            assertThat(testEnv.operatorId).isEqualTo(info.treasuryAccountId);
            assertThat(info.adminKey).isNotNull();
            assertThat(info.freezeKey).isNotNull();
            assertThat(info.wipeKey).isNotNull();
            assertThat(info.kycKey).isNotNull();
            assertThat(info.supplyKey).isNotNull();
            assertThat(info.adminKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.freezeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.wipeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.kycKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.supplyKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.feeScheduleKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.defaultFreezeStatus).isNotNull();
            assertThat(info.defaultFreezeStatus).isFalse();
            assertThat(info.defaultKycStatus).isNotNull();
            assertThat(info.defaultKycStatus).isFalse();
            assertThat(info.customFees.size()).isEqualTo(0);

            var customFees = new ArrayList<CustomFee>();
            customFees.add(new CustomFixedFee()
                .setAmount(10)
                .setFeeCollectorAccountId(testEnv.operatorId)
            );
            customFees.add(new CustomFractionalFee()
                .setNumerator(1)
                .setDenominator(20)
                .setMin(1)
                .setMax(10)
                .setFeeCollectorAccountId(testEnv.operatorId)
            );

            new TokenFeeScheduleUpdateTransaction()
                .setTokenId(tokenId)
                .setCustomFees(customFees)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("ffff");
            assertThat(info.symbol).isEqualTo("F");
            assertThat(info.decimals).isEqualTo(3);
            assertThat(info.treasuryAccountId).isEqualTo(testEnv.operatorId);
            assertThat(info.adminKey).isNotNull();
            assertThat(info.freezeKey).isNotNull();
            assertThat(info.wipeKey).isNotNull();
            assertThat(info.kycKey).isNotNull();
            assertThat(info.supplyKey).isNotNull();
            assertThat(info.adminKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.freezeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.wipeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.kycKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.supplyKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.feeScheduleKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.defaultFreezeStatus).isNotNull();
            assertThat(info.defaultFreezeStatus).isFalse();
            assertThat(info.defaultKycStatus).isNotNull();
            assertThat(info.defaultKycStatus).isFalse();

            var fees = info.customFees;
            assertThat(fees.size()).isEqualTo(2);
            @Var int fixedCount = 0;
            @Var int fractionalCount = 0;
            for (var fee : fees) {
                if (fee instanceof CustomFixedFee) {
                    fixedCount++;
                    var fixed = (CustomFixedFee) fee;
                    assertThat(fixed.getAmount()).isEqualTo(10);
                    assertThat(fixed.getFeeCollectorAccountId()).isEqualTo(testEnv.operatorId);
                    assertThat(fixed.getDenominatingTokenId()).isNull();
                } else if (fee instanceof CustomFractionalFee) {
                    fractionalCount++;
                    var fractional = (CustomFractionalFee) fee;
                    assertThat(fractional.getNumerator()).isEqualTo(1);
                    assertThat(fractional.getDenominator()).isEqualTo(20);
                    assertThat(fractional.getMin()).isEqualTo(1);
                    assertThat(fractional.getMax()).isEqualTo(10);
                    assertThat(fractional.getFeeCollectorAccountId()).isEqualTo(testEnv.operatorId);
                }
            }
            assertThat(fixedCount).isEqualTo(1);
            assertThat(fractionalCount).isEqualTo(1);

        }
    }

    @Test
    @DisplayName("Cannot update fee schedule with any key other than fee schedule key")
    void cannotUpdateWithAnyOtherKey() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFeeScheduleKey(PrivateKey.generate())
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var customFees = new ArrayList<CustomFee>();
            customFees.add(new CustomFixedFee()
                .setAmount(10)
                .setFeeCollectorAccountId(testEnv.operatorId)
            );
            customFees.add(new CustomFractionalFee()
                .setNumerator(1)
                .setDenominator(20)
                .setMin(1)
                .setMax(10)
                .setFeeCollectorAccountId(testEnv.operatorId)
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenFeeScheduleUpdateTransaction()
                    .setTokenId(tokenId)
                    .setCustomFees(customFees)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenFreezeIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenFreezeTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenFreezeIntegrationTest {
    @Test
    @DisplayName("Can freeze account with token")
    void canFreezeAccountWithToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenFreezeTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot freeze account on token when token ID is not set")
    void cannotFreezeAccountOnTokenWhenTokenIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenFreezeTransaction()
                    .setAccountId(accountId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }  
    }

    @Test
    @DisplayName("Cannot freeze account on token when account ID is not set")
    void cannotFreezeAccountOnTokenWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenFreezeTransaction()
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot freeze account on token when account was not associated with")
    void cannotFreezeAccountOnTokenWhenAccountWasNotAssociatedWith() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenFreezeTransaction()
                    .setAccountId(accountId)
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenGrantKycIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenGrantKycTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenGrantKycIntegrationTest {
    @Test
    @DisplayName("Can grant kyc to account with token")
    void canGrantKycAccountWithToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot grant kyc to account on token when token ID is not set")
    void cannotGrantKycToAccountOnTokenWhenTokenIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenGrantKycTransaction()
                    .setAccountId(accountId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot grant kyc to account on token when account ID is not set")
    void cannotGrantKycToAccountOnTokenWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenGrantKycTransaction()
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot grant kyc to account on token when account was not associated with")
    void cannotGrantKycToAccountOnTokenWhenAccountWasNotAssociatedWith() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenGrantKycTransaction()
                    .setAccountId(accountId)
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenInfoQuery;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenSupplyType;
import com.hedera.hashgraph.sdk.TokenType;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenInfoIntegrationTest {

    @Test
    @DisplayName("Can query token info when all keys are different")
    void canQueryTokenInfoWhenAllKeysAreDifferent() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var key1 = PrivateKey.generateED25519();
            var key2 = PrivateKey.generateED25519();
            var key3 = PrivateKey.generateED25519();
            var key4 = PrivateKey.generateED25519();
            var key5 = PrivateKey.generateED25519();
            var key6 = PrivateKey.generateED25519();
            var key7 = PrivateKey.generateED25519();

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(key1)
                .setFreezeKey(key2)
                .setWipeKey(key3)
                .setKycKey(key4)
                .setSupplyKey(key5)
                .setPauseKey(key6)
                .setMetadataKey(key7)
                .setFreezeDefault(false)
                .freezeWith(testEnv.client)
                .sign(key1)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("ffff");
            assertThat(info.symbol).isEqualTo("F");
            assertThat(info.decimals).isEqualTo(3);
            assertThat(info.treasuryAccountId).isEqualTo(testEnv.operatorId);
            assertThat(info.adminKey).isNotNull();
            assertThat(info.freezeKey).isNotNull();
            assertThat(info.wipeKey).isNotNull();
            assertThat(info.kycKey).isNotNull();
            assertThat(info.supplyKey).isNotNull();
            assertThat(info.pauseKey).isNotNull();
            assertThat(info.metadataKey).isNotNull();
            assertThat(info.adminKey.toString()).isEqualTo(key1.getPublicKey().toString());
            assertThat(info.freezeKey.toString()).isEqualTo(key2.getPublicKey().toString());
            assertThat(info.wipeKey.toString()).isEqualTo(key3.getPublicKey().toString());
            assertThat(info.kycKey.toString()).isEqualTo(key4.getPublicKey().toString());
            assertThat(info.supplyKey.toString()).isEqualTo(key5.getPublicKey().toString());
            assertThat(info.pauseKey.toString()).isEqualTo(key6.getPublicKey().toString());
            assertThat(info.metadataKey.toString()).isEqualTo(key7.getPublicKey().toString());
            assertThat(info.defaultFreezeStatus).isNotNull();
            assertThat(info.defaultFreezeStatus).isFalse();
            assertThat(info.defaultKycStatus).isNotNull();
            assertThat(info.defaultKycStatus).isFalse();
            assertThat(info.tokenType).isEqualTo(TokenType.FUNGIBLE_COMMON);
            assertThat(info.supplyType).isEqualTo(TokenSupplyType.INFINITE);

            new TokenDeleteTransaction()
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(key1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can query token with minimal properties")
    void canQueryTokenInfoWhenTokenIsCreatedWithMinimalProperties() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("ffff");
            assertThat(info.symbol).isEqualTo("F");
            assertThat(info.decimals).isEqualTo(0);
            assertThat(info.totalSupply).isEqualTo(0);
            assertThat(info.treasuryAccountId).isEqualTo(testEnv.operatorId);
            assertThat(info.adminKey).isNull();
            assertThat(info.freezeKey).isNull();
            assertThat(info.wipeKey).isNull();
            assertThat(info.kycKey).isNull();
            assertThat(info.supplyKey).isNull();
            assertThat(info.pauseKey).isNull();
            assertThat(info.metadataKey).isNull();
            assertThat(info.defaultFreezeStatus).isNull();
            assertThat(info.defaultKycStatus).isNull();
            assertThat(info.tokenType).isEqualTo(TokenType.FUNGIBLE_COMMON);
            assertThat(info.supplyType).isEqualTo(TokenSupplyType.INFINITE);

        }
    }

    @Test
    @DisplayName("Can query NFT")
    void canQueryNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setSupplyType(TokenSupplyType.FINITE)
                .setMaxSupply(5000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(mintReceipt.serials.size()).isEqualTo(10);

            var info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("ffff");
            assertThat(info.symbol).isEqualTo("F");
            assertThat(info.decimals).isEqualTo(0);
            assertThat(info.totalSupply).isEqualTo(10);
            assertThat(testEnv.operatorId).isEqualTo(info.treasuryAccountId);
            assertThat(info.adminKey).isNotNull();
            assertThat(info.freezeKey).isNull();
            assertThat(info.wipeKey).isNull();
            assertThat(info.kycKey).isNull();
            assertThat(info.supplyKey).isNotNull();
            assertThat(info.pauseKey).isNull();
            assertThat(info.metadataKey).isNull();
            assertThat(info.defaultFreezeStatus).isNull();
            assertThat(info.defaultKycStatus).isNull();
            assertThat(info.tokenType).isEqualTo(TokenType.NON_FUNGIBLE_UNIQUE);
            assertThat(info.supplyType).isEqualTo(TokenSupplyType.FINITE);
            assertThat(info.maxSupply).isEqualTo(5000);

        }
    }

    @Test
    @DisplayName("Get cost of token info query")
    void getCostQueryTokenInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var infoQuery = new TokenInfoQuery()
                    .setTokenId(tokenId);

            var cost = infoQuery.getCost(testEnv.client);

            infoQuery.setQueryPayment(cost).execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("Get cost of token info query, with big max")
    void getCostBigMaxQueryTokenInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var infoQuery = new TokenInfoQuery()
                .setTokenId(tokenId)
                .setMaxQueryPayment(new Hbar(1000));

            var cost = infoQuery.getCost(testEnv.client);

            infoQuery.setQueryPayment(cost).execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can query token info when all keys are different")
    void getCostSmallMaxTokenInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var infoQuery = new TokenInfoQuery()
                .setTokenId(tokenId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
                infoQuery.execute(testEnv.client);
            });

        }
    }

    @Test
    @DisplayName("Throws insufficient transaction fee error")
    void getCostInsufficientTxFeeQueryTokenInfo() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            var infoQuery = new TokenInfoQuery()
                .setTokenId(tokenId)
                .setMaxQueryPayment(new Hbar(1000));

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                infoQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenManualAssociationIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.AccountInfoQuery;
import com.hedera.hashgraph.sdk.ContractDeleteTransaction;
import com.hedera.hashgraph.sdk.ContractInfoQuery;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.ArrayList;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenManualAssociationIntegrationTest {

    @Test
    @DisplayName("Can Manually associate Account with a Fungible Token")
    void canManuallyAssociateAccountWithFungibleToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenDecimals = 3;
            var tokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 0;
            var receiverAccountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountInfo = new AccountInfoQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(accountInfo.tokenRelationships.get(tokenId).decimals).isEqualTo(tokenDecimals);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var accountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(accountBalance.tokens.get(tokenId)).isEqualTo(10);

        }
    }

    @Test
    @DisplayName("Can Manually associate Account with Nft")
    void canManuallyAssociateAccountWithNft() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId = EntityHelper.createNft(testEnv);
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 0;
            var receiverAccountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            var mintReceiptToken = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var serialsToTransfer = new ArrayList<>(mintReceiptToken.serials);
            var nftTransferTransaction = new TransferTransaction();
            for (var serial : serialsToTransfer) {
                nftTransferTransaction.addNftTransfer(tokenId.nft(serial), testEnv.operatorId, receiverAccountId);
            }
            nftTransferTransaction
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can Manually associate Contract with a Fungible Token")
    void canManuallyAssociateContractWithFungibleToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var tokenDecimals = 3;
            var tokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var contractId = EntityHelper.createContract(testEnv, testEnv.operatorKey);

            new TokenAssociateTransaction()
                .setAccountId(new AccountId(contractId.num))
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var contractInfo = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(contractInfo.contractId).isEqualTo(contractId);
            assertThat(contractInfo.accountId).isNotNull();
            assertThat(Objects.requireNonNull(contractInfo.accountId).toString()).isEqualTo(Objects.requireNonNull(contractId).toString());
            assertThat(contractInfo.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(contractInfo.adminKey).toString()).isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(contractInfo.storage).isEqualTo(128);
            assertThat(contractInfo.contractMemo).isEqualTo("[e2e::ContractMemo]");
            assertThat(contractInfo.tokenRelationships.get(tokenId).decimals).isEqualTo(tokenDecimals);

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can Manually associate contract with Nft")
    void canManuallyAssociateContractWithNft() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1)){
            var tokenId = EntityHelper.createNft(testEnv);
            var contractId = EntityHelper.createContract(testEnv, testEnv.operatorKey);

            new TokenAssociateTransaction()
                .setAccountId(new AccountId(contractId.num))
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var contractInfo = new ContractInfoQuery()
                .setContractId(contractId)
                .execute(testEnv.client);

            assertThat(contractInfo.contractId).isEqualTo(contractId);
            assertThat(contractInfo.accountId).isNotNull();
            assertThat(Objects.requireNonNull(contractInfo.accountId).toString()).isEqualTo(Objects.requireNonNull(contractId).toString());
            assertThat(contractInfo.adminKey).isNotNull();
            assertThat(Objects.requireNonNull(contractInfo.adminKey).toString()).isEqualTo(Objects.requireNonNull(testEnv.operatorKey).toString());
            assertThat(contractInfo.storage).isEqualTo(128);
            assertThat(contractInfo.contractMemo).isEqualTo("[e2e::ContractMemo]");

            new ContractDeleteTransaction()
                .setTransferAccountId(testEnv.operatorId)
                .setContractId(contractId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute token associate transaction even when token IDs are not set")
    void canExecuteTokenAssociateTransactionEvenWhenTokenIDsAreNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
        
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 0;
            var accountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .freezeWith(testEnv.client)
                .sign(accountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot Manually associate Account with a Token when Account ID is not set")
    void cannotAssociateAccountWithTokensWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
        
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 0;
            var accountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenAssociateTransaction()
                    .freezeWith(testEnv.client)
                    .sign(accountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot Manually Associate Account with a Token when Account Does Not sign transaction")
    void cannotAssociateAccountWhenAccountDoesNotSignTransaction() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenDecimals = 3;
            var tokenId = EntityHelper.createFungibleToken(testEnv, tokenDecimals);
            var accountKey = PrivateKey.generateED25519();
            var accountMaxAutomaticTokenAssociations = 0;
            var accountId = EntityHelper.createAccount(testEnv, accountKey, accountMaxAutomaticTokenAssociations);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenAssociateTransaction()
                    .setAccountId(accountId)
                    .setTokenIds(Collections.singletonList(tokenId))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenMintIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenSupplyType;
import com.hedera.hashgraph.sdk.TokenType;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenMintIntegrationTest {
    @Test
    @DisplayName("Can mint tokens")
    void canMintTokens() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
                );

            var receipt = new TokenMintTransaction()
                .setAmount(10)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.totalSupply).isEqualTo(1000000 + 10);

        }
    }

    @Test
    @DisplayName("Cannot mint more tokens than max supply")
    void cannotMintMoreThanMaxSupply() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                        .setTokenName("ffff")
                        .setTokenSymbol("F")
                        .setSupplyType(TokenSupplyType.FINITE)
                        .setMaxSupply(5)
                        .setTreasuryAccountId(testEnv.operatorId)
                        .setAdminKey(testEnv.operatorKey)
                        .setSupplyKey(testEnv.operatorKey)
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client)
                        .tokenId
                    );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenMintTransaction()
                    .setTokenId(tokenId)
                    .setAmount(6)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_MAX_SUPPLY_REACHED.toString());

        }
    }

    @Test
    @DisplayName("Cannot mint tokens when token ID is not set")
    void cannotMintTokensWhenTokenIDIsNotSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenMintTransaction()
                    .setAmount(10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }

    @Test
    @DisplayName("Can mint tokens when amount is not set")
    void canMintTokensWhenAmountIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
                );

            var receipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

        }
    }

    @Test
    @DisplayName("Cannot mint tokens when supply key does not sign transaction")
    void cannotMintTokensWhenSupplyKeyDoesNotSignTransaction() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(key)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenMintTransaction()
                    .setTokenId(tokenId)
                    .setAmount(10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Can mint NFTs")
    void canMintNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var receipt = new TokenMintTransaction()
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.serials.size()).isEqualTo(10);

        }
    }

    @Test
    @DisplayName("Cannot mint NFTs if metadata too big")
    void cannotMintNftsIfMetadataTooBig() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenMintTransaction()
                    .setMetadata(NftMetadataGenerator.generateOneLarge())
                    .setTokenId(tokenId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.METADATA_TOO_LONG.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenNftInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2021 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.NftId;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenNftInfoQuery;
import com.hedera.hashgraph.sdk.TokenType;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenNftInfoIntegrationTest {

    @Test
    @DisplayName("Can query NFT info by NftId")
    void canQueryNftInfoByNftId() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            byte[] metadata = {50};

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .addMetadata(metadata)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftId = tokenId.nft(mintReceipt.serials.get(0));

            var nftInfos = new TokenNftInfoQuery()
                .setNftId(nftId)
                .execute(testEnv.client);

            assertThat(nftInfos.size()).isEqualTo(1);
            assertThat(nftInfos.get(0).nftId).isEqualTo(nftId);
            assertThat(nftInfos.get(0).accountId).isEqualTo(testEnv.operatorId);
            assertThat(nftInfos.get(0).metadata[0]).isEqualTo((byte) 50);

        }
    }

    @Test
    @DisplayName("Cannot query NFT info by invalid NftId")
    void cannotQueryNftInfoByInvalidNftId() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            byte[] metadata = {50};

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .addMetadata(metadata)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftId = tokenId.nft(mintReceipt.serials.get(0));
            var invalidNftId = new NftId(nftId.tokenId, nftId.serial + 1);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenNftInfoQuery()
                    .setNftId(invalidNftId)
                    .execute(testEnv.client);
            }).withMessageContaining(Status.INVALID_NFT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot query NFT info by invalid NftId Serial Number")
    void cannotQueryNftInfoByInvalidSerialNumber() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            byte[] metadata = {50};

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .addMetadata(metadata)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftId = tokenId.nft(mintReceipt.serials.get(0));
            var invalidNftId = new NftId(nftId.tokenId, -1L);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenNftInfoQuery()
                    .byNftId(invalidNftId)
                    .execute(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_NFT_SERIAL_NUMBER.toString());

        }
    }

    @Disabled
    @Test
    @DisplayName("Can query NFT info by AccountId")
    void canQueryNftInfoByAccountId() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            List<byte[]> metadatas = NftMetadataGenerator.generate((byte) 10);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(metadatas)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftInfos = new TokenNftInfoQuery()
                .byAccountId(testEnv.operatorId)
                .setEnd(10)
                .execute(testEnv.client);

            assertThat(nftInfos.size()).isEqualTo(10);

            var serials = new ArrayList<Long>(mintReceipt.serials);

            for (var info : nftInfos) {
                assertThat(info.nftId.tokenId).isEqualTo(tokenId);
                assertThat(serials.remove(info.nftId.serial)).isTrue();
                assertThat(info.accountId).isEqualTo(testEnv.operatorId);
            }

        }
    }

    @Disabled
    @Test
    @DisplayName("Can query NFT info by TokenId")
    void canQueryNftInfoByTokenId() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var createReceipt = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenId = Objects.requireNonNull(createReceipt.tokenId);

            List<byte[]> metadatas = NftMetadataGenerator.generate((byte) 10);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(metadatas)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftInfos = new TokenNftInfoQuery()
                .byTokenId(tokenId)
                .setEnd(10)
                .execute(testEnv.client);

            assertThat(nftInfos.size()).isEqualTo(10);

            var serials = new ArrayList<Long>(mintReceipt.serials);

            for (var info : nftInfos) {
                assertThat(info.nftId.tokenId).isEqualTo(tokenId);
                assertThat(serials.remove(info.nftId.serial)).isTrue();
                assertThat(info.accountId).isEqualTo(testEnv.operatorId);
            }

        }
    }
}



// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenNftTransferIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenGrantKycTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TokenWipeTransaction;
import com.hedera.hashgraph.sdk.TransactionResponse;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenNftTransferIntegrationTest {
    @Test
    @DisplayName("Can transfer NFTs")
    void canTransferNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            @Var TransactionResponse response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = response.getReceipt(testEnv.client).accountId;
            assertThat(accountId).isNotNull();

            response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = response.getReceipt(testEnv.client).tokenId;
            assertThat(tokenId).isNotNull();

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .signWithOperator(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var serialsToTransfer = new ArrayList<Long>(mintReceipt.serials.subList(0, 4));
            var transfer = new TransferTransaction();
            for (var serial : serialsToTransfer) {
                transfer.addNftTransfer(tokenId.nft(serial), testEnv.operatorId, accountId);
            }
            transfer.execute(testEnv.client).getReceipt(testEnv.client);

            new TokenWipeTransaction()
                .setTokenId(tokenId)
                .setAccountId(accountId)
                .setSerials(serialsToTransfer)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot transfer NFTs you don't own")
    void cannotTransferUnownedNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            @Var TransactionResponse response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = response.getReceipt(testEnv.client).accountId;
            assertThat(accountId).isNotNull();

            response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = response.getReceipt(testEnv.client).tokenId;
            assertThat(tokenId).isNotNull();

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .signWithOperator(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var serialsToTransfer = new ArrayList<Long>(mintReceipt.serials.subList(0, 4));
            var transfer = new TransferTransaction();
            for (var serial : serialsToTransfer) {
                // Try to transfer in wrong direction
                transfer.addNftTransfer(tokenId.nft(serial), accountId, testEnv.operatorId);
            }
            transfer.freezeWith(testEnv.client).sign(key);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                transfer.execute(testEnv.client).getReceipt(testEnv.client);
            }).withMessageContaining(Status.SENDER_DOES_NOT_OWN_NFT_SERIAL_NO.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenPauseIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.junit.jupiter.api.Assertions.assertThrows;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenPauseTransaction;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.Collections;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class TokenPauseIntegrationTest {

    @Test
    @DisplayName("Can execute token pause transaction")
    void canExecuteTokenPauseTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var accountKey = PrivateKey.generateED25519();
            var testTokenAmount = 10;
            var accountId = new AccountCreateTransaction().setKey(accountKey).setInitialBalance(new Hbar(2))
                .execute(testEnv.client).getReceipt(testEnv.client)
                .accountId;

            var tokenId = new TokenCreateTransaction().setTokenName("ffff").setTokenSymbol("F").setInitialSupply(1000000)
                .setDecimals(3).setTreasuryAccountId(testEnv.operatorId).setAdminKey(testEnv.operatorKey)
                .setPauseKey(testEnv.operatorKey).setFreezeDefault(false).execute(testEnv.client)
                .getReceipt(testEnv.client).tokenId;

            new TokenAssociateTransaction().setAccountId(accountId).setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client).sign(accountKey).execute(testEnv.client).getReceipt(testEnv.client);

            new TransferTransaction().addTokenTransfer(tokenId, accountId, testTokenAmount)
                .addTokenTransfer(tokenId, testEnv.operatorId, -testTokenAmount).execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenPauseTransaction().setTokenId(tokenId).freezeWith(testEnv.client).execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThrows(ReceiptStatusException.class, () -> {
                new TransferTransaction().addTokenTransfer(tokenId, accountId, testTokenAmount)
                    .addTokenTransfer(tokenId, testEnv.operatorId, -testTokenAmount).freezeWith(testEnv.client)
                    .sign(accountKey).execute(testEnv.client).getReceipt(testEnv.client);
            });

        }
    }

    @Test
    @DisplayName("Cannot pause with no token ID")
    void cannotPauseWithNoTokenId() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThrows(PrecheckStatusException.class, () -> {
                new TokenPauseTransaction().execute(testEnv.client).getReceipt(testEnv.client);
            });

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenRejectFlowIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenNftInfoQuery;
import com.hedera.hashgraph.sdk.TokenRejectFlow;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.Collections;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class TokenRejectFlowIntegrationTest {

    @Test
    @DisplayName("Can execute TokenReject flow for Fungible Token")
    void canExecuteTokenRejectFlowForFungibleToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // manually associate ft
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(ftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // execute the token reject flow
            new TokenRejectFlow()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftTokenId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the tokens are transferred back to the treasury
            var treasuryAccountBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(treasuryAccountBalance.tokens.get(ftTokenId)).isEqualTo(1_000_000);

            // verify the allowance - should be 0, because TokenRejectFlow dissociates
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                    .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_NOT_ASSOCIATED_TO_ACCOUNT");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute TokenReject flow for Fungible Token (Async)")
    void canExecuteTokenRejectFlowForFungibleTokenAsync() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            // manually associate ft
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(ftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // execute the token reject flow
            new TokenRejectFlow()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftTokenId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .executeAsync(testEnv.client).get()
                .getReceipt(testEnv.client);

            // verify the tokens are transferred back to the treasury
            var treasuryAccountBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(treasuryAccountBalance.tokens.get(ftTokenId)).isEqualTo(1_000_000);

            // verify the tokens are not associated with the receiver
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                    .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_NOT_ASSOCIATED_TO_ACCOUNT");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute TokenReject flow for NFT")
    void canExecuteTokenRejectFlowForNft() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
        var nftTokenId = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            var mintReceiptToken = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptToken.serials;

            // manually associate bft
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // execute the token reject flow
            new TokenRejectFlow()
                .setOwnerId(receiverAccountId)
                .setNftIds(List.of(nftTokenId.nft(nftSerials.get(0)), nftTokenId.nft(nftSerials.get(1))))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the token is transferred back to the treasury
            var nftTokenIdNftInfo = new TokenNftInfoQuery()
                .setNftId(nftTokenId.nft(nftSerials.get(1)))
                .execute(testEnv.client);

            assertThat(nftTokenIdNftInfo.get(0).accountId).isEqualTo(testEnv.operatorId);

            // verify the tokens are not associated with the receiver
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_NOT_ASSOCIATED_TO_ACCOUNT");

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot execute TokenReject flow for NFT when rejecting Only Part Of Owned NFTs")
    void canExecuteTokenRejectFlowForNftWhenRejectingOnlyPartOfOwnedNFTs() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var nftTokenId1 = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 0);

            var mintReceiptToken = new TokenMintTransaction()
                .setTokenId(nftTokenId1)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptToken.serials;

            // manually associate bft
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(nftTokenId1))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId1.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId1.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // execute the token reject flow
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectFlow()
                    .setOwnerId(receiverAccountId)
                    .addNftId(nftTokenId1.nft(nftSerials.get(1)))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_STILL_OWNS_NFTS");

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenRejectIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.hedera.hashgraph.sdk.AccountAllowanceApproveTransaction;
import com.hedera.hashgraph.sdk.AccountBalanceQuery;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenFreezeTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenNftInfoQuery;
import com.hedera.hashgraph.sdk.TokenPauseTransaction;
import com.hedera.hashgraph.sdk.TokenRejectTransaction;
import com.hedera.hashgraph.sdk.TokenSupplyType;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class TokenRejectIntegrationTest {

    @Test
    @DisplayName("Can execute TokenReject transaction for Fungible Token")
    void canExecuteTokenRejectTransactionForFungibleToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createFungibleToken(testEnv, 3);
            var tokenId2 = EntityHelper.createFungibleToken(testEnv, 3);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(tokenId1, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId1, receiverAccountId, 10)
                .addTokenTransfer(tokenId2, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId2, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .setTokenIds(List.of(tokenId1, tokenId2))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance of the receiver is 0
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(receiverAccountBalance.tokens.get(tokenId1)).isEqualTo(0);
            assertThat(receiverAccountBalance.tokens.get(tokenId2)).isEqualTo(0);

            // verify the tokens are transferred back to the treasury
            var treasuryAccountBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(treasuryAccountBalance.tokens.get(tokenId1)).isEqualTo(1_000_000);
            assertThat(treasuryAccountBalance.tokens.get(tokenId2)).isEqualTo(1_000_000);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute TokenReject transaction for NFT")
    void canExecuteTokenRejectTransactionForNft() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var tokenId1 = EntityHelper.createNft(testEnv);
            var tokenId2 = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            var mintReceiptToken1 = new TokenMintTransaction()
                .setTokenId(tokenId1)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var mintReceiptToken2 = new TokenMintTransaction()
                .setTokenId(tokenId2)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptToken2.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(tokenId1.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(tokenId1.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(tokenId2.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(tokenId2.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject one of the nfts
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .setNftIds(List.of(tokenId1.nft(nftSerials.get(1)), tokenId2.nft(nftSerials.get(1))))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance is decremented by 1
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(receiverAccountBalance.tokens.get(tokenId1)).isEqualTo(1);
            assertThat(receiverAccountBalance.tokens.get(tokenId2)).isEqualTo(1);

            // verify the token is transferred back to the treasury
            var tokenId1NftInfo = new TokenNftInfoQuery()
                .setNftId(tokenId1.nft(nftSerials.get(1)))
                .execute(testEnv.client);

            assertThat(tokenId1NftInfo.get(0).accountId).isEqualTo(testEnv.operatorId);

            var tokenId2NftInfo = new TokenNftInfoQuery()
                .setNftId(tokenId2.nft(nftSerials.get(1)))
                .execute(testEnv.client);

            assertThat(tokenId2NftInfo.get(0).accountId).isEqualTo(testEnv.operatorId);

            new TokenDeleteTransaction()
                .setTokenId(tokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(tokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute TokenReject transaction for FT and NFT in One Tx")
    void canExecuteTokenRejectTransactionForFtAndNftInOneTx() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId1 = EntityHelper.createFungibleToken(testEnv, 3);
            var ftTokenId2 = EntityHelper.createFungibleToken(testEnv, 3);
            var nftTokenId1 = EntityHelper.createNft(testEnv);
            var nftTokenId2 = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            var mintReceiptNftToken1 = new TokenMintTransaction()
                .setTokenId(nftTokenId1)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var mintReceiptNftToken2 = new TokenMintTransaction()
                .setTokenId(nftTokenId2)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptNftToken2.serials;

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId1, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId1, receiverAccountId, 10)
                .addTokenTransfer(ftTokenId2, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId2, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId1.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId1.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId2.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId2.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .setTokenIds(List.of(ftTokenId1, ftTokenId2))
                .setNftIds(List.of(nftTokenId1.nft(nftSerials.get(1)), nftTokenId2.nft(nftSerials.get(1))))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance of the receiver is 0
            var receiverAccountBalance = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(receiverAccountBalance.tokens.get(ftTokenId1)).isEqualTo(0);
            assertThat(receiverAccountBalance.tokens.get(ftTokenId2)).isEqualTo(0);
            assertThat(receiverAccountBalance.tokens.get(nftTokenId1)).isEqualTo(1);
            assertThat(receiverAccountBalance.tokens.get(nftTokenId2)).isEqualTo(1);

            // verify the tokens are transferred back to the treasury
            var treasuryAccountBalance = new AccountBalanceQuery()
                .setAccountId(testEnv.operatorId)
                .execute(testEnv.client);

            assertThat(treasuryAccountBalance.tokens.get(ftTokenId1)).isEqualTo(1_000_000);
            assertThat(treasuryAccountBalance.tokens.get(ftTokenId2)).isEqualTo(1_000_000);

            var tokenId1NftInfo = new TokenNftInfoQuery()
                .setNftId(nftTokenId1.nft(nftSerials.get(1)))
                .execute(testEnv.client);

            assertThat(tokenId1NftInfo.get(0).accountId).isEqualTo(testEnv.operatorId);

            var tokenId2NftInfo = new TokenNftInfoQuery()
                .setNftId(nftTokenId2.nft(nftSerials.get(1)))
                .execute(testEnv.client);

            assertThat(tokenId2NftInfo.get(0).accountId).isEqualTo(testEnv.operatorId);

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can execute TokenReject transaction for FT and NFT when Treasury receiverSigRequired is Enabled")
    void canExecuteTokenRejectTransactionForFtAndNftWhenTreasuryReceiverSigRequiredIsEnabled() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            var treasuryAccountKey = PrivateKey.generateED25519();
            var treasuryAccountId = new AccountCreateTransaction()
                .setKey(treasuryAccountKey)
                .setInitialBalance(new Hbar(0))
                .setReceiverSignatureRequired(true)
                .setMaxAutomaticTokenAssociations(100)
                .freezeWith(testEnv.client)
                .sign(treasuryAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var ftTokenId = new TokenCreateTransaction()
                .setTokenName("Test Fungible Token")
                .setTokenSymbol("TFT")
                .setTokenMemo("I was created for integration tests")
                .setDecimals(18)
                .setInitialSupply(1_000_000)
                .setMaxSupply(1_000_000)
                .setTreasuryAccountId(treasuryAccountId)
                .setSupplyType(TokenSupplyType.FINITE)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setMetadataKey(testEnv.operatorKey)
                .freezeWith(testEnv.client)
                .sign(treasuryAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, treasuryAccountId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .freezeWith(testEnv.client)
                .sign(treasuryAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftTokenId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance of the receiver is 0
            var receiverAccountBalanceFt = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(receiverAccountBalanceFt.tokens.get(ftTokenId)).isEqualTo(0);

            // verify the tokens are transferred back to the treasury
            var treasuryAccountBalance = new AccountBalanceQuery()
                .setAccountId(treasuryAccountId)
                .execute(testEnv.client);

            assertThat(treasuryAccountBalance.tokens.get(ftTokenId)).isEqualTo(1_000_000);

            // same test for nft

            var nftTokenId = new TokenCreateTransaction()
                .setTokenName("Test NFT")
                .setTokenSymbol("TNFT")
                .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                .setTreasuryAccountId(treasuryAccountId)
                .setSupplyType(TokenSupplyType.FINITE)
                .setMaxSupply(10)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setMetadataKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .freezeWith(testEnv.client)
                .sign(treasuryAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            var mintReceiptNftToken = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptNftToken.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), treasuryAccountId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), treasuryAccountId, receiverAccountId)
                .freezeWith(testEnv.client)
                .sign(treasuryAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addNftId(nftTokenId.nft(nftSerials.get(1)))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the balance is decremented by 1
            var receiverAccountBalanceNft = new AccountBalanceQuery()
                .setAccountId(receiverAccountId)
                .execute(testEnv.client);

            assertThat(receiverAccountBalanceNft.tokens.get(nftTokenId)).isEqualTo(1);

            // verify the token is transferred back to the treasury
            var nftTokenIdInfo = new TokenNftInfoQuery()
                .setNftId(nftTokenId.nft(nftSerials.get(1)))
                .execute(testEnv.client);

            assertThat(nftTokenIdInfo.get(0).accountId).isEqualTo(treasuryAccountId);

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot execute TokenReject transaction for FT and NFT when Token is Frozen")
    void canExecuteTokenRejectTransactionForFtAndNftWhenTokenIsFrozen() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 18);
            var nftTokenId = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // freeze ft
            new TokenFreezeTransaction()
                .setTokenId(ftTokenId)
                .setAccountId(receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token - should fail with ACCOUNT_FROZEN_FOR_TOKEN
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftTokenId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_FROZEN_FOR_TOKEN");

            // same test for nft

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // freeze nft
            new TokenFreezeTransaction()
                .setTokenId(nftTokenId)
                .setAccountId(receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token - should fail with ACCOUNT_FROZEN_FOR_TOKEN
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .addNftId(nftTokenId.nft(nftSerials.get(1)))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_FROZEN_FOR_TOKEN");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot execute TokenReject transaction for FT and NFT when Token is Paused")
    void canExecuteTokenRejectTransactionForFtAndNftWhenTokenIsPaused() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 18);
            var nftTokenId = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // pause ft
            new TokenPauseTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token - should fail with TOKEN_IS_PAUSED
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .addTokenId(ftTokenId)
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_IS_PAUSED");

            // same test for nft

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // pause nft
            new TokenPauseTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token - should fail with TOKEN_IS_PAUSED
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .addNftId(nftTokenId.nft(nftSerials.get(1)))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_IS_PAUSED");

        }
    }

    @Test
    @Disabled // temp disabled till issue re nfts will be resolved on services side
    @DisplayName("Can remove allowance when executing TokenReject transaction for FT and NFT")
    void canRemoveAllowanceWhenExecutingTokenRejectForFtAndNft() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, -1);
            var spenderAccountKey = PrivateKey.generateED25519();
            var spenderAccountId = EntityHelper.createAccount(testEnv, spenderAccountKey, -1);

            // transfer ft to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // approve allowance to the spender
            new AccountAllowanceApproveTransaction()
                .approveTokenAllowance(ftTokenId, receiverAccountId, spenderAccountId, 10)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the spender has allowance
            new TransferTransaction()
                .addApprovedTokenTransfer(ftTokenId, receiverAccountId, -5)
                .addTokenTransfer(ftTokenId, spenderAccountId, 5)
                .setTransactionId(TransactionId.generate(spenderAccountId))
                .freezeWith(testEnv.client)
                .sign(spenderAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftTokenId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the allowance - should be 0 , because the receiver is no longer the owner
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addApprovedTokenTransfer(ftTokenId, receiverAccountId, -5)
                    .addTokenTransfer(ftTokenId, spenderAccountId, 5)
                    .setTransactionId(TransactionId.generate(spenderAccountId))
                    .freezeWith(testEnv.client)
                    .sign(spenderAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("SPENDER_DOES_NOT_HAVE_ALLOWANCE");

            // same test for nft

            var nftTokenId = EntityHelper.createNft(testEnv);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(2)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(3)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // approve allowance to the spender
            new AccountAllowanceApproveTransaction()
                .approveTokenNftAllowance(nftTokenId.nft(nftSerials.get(0)), receiverAccountId, spenderAccountId)
                .approveTokenNftAllowance(nftTokenId.nft(nftSerials.get(1)), receiverAccountId, spenderAccountId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the spender has allowance
            new TransferTransaction()
                .addApprovedNftTransfer(nftTokenId.nft(nftSerials.get(0)), receiverAccountId, spenderAccountId)
                .setTransactionId(TransactionId.generate(spenderAccountId))
                .freezeWith(testEnv.client)
                .sign(spenderAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .setNftIds(List.of(nftTokenId.nft(nftSerials.get(1)), nftTokenId.nft(nftSerials.get(2))))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // verify the allowance - should be 0 , because the receiver is no longer the owner
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addApprovedNftTransfer(nftTokenId.nft(nftSerials.get(1)), receiverAccountId, spenderAccountId)
                    .addApprovedNftTransfer(nftTokenId.nft(nftSerials.get(2)), receiverAccountId, spenderAccountId)
                    .setTransactionId(TransactionId.generate(spenderAccountId))
                    .freezeWith(testEnv.client)
                    .sign(spenderAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("SPENDER_DOES_NOT_HAVE_ALLOWANCE");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot reject NFT when executing TokenReject with Add or Set TokenId")
    void cannotRejectNftWhenUsingAddOrSetTokenId() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var nftTokenId = EntityHelper.createNft(testEnv);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            var mintReceiptNftToken = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceiptNftToken.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(2)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the whole collection (addTokenId) - should fail
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addTokenId(nftTokenId)
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON");

            // reject the whole collection (setTokenIds) - should fail
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .setTokenIds(List.of(nftTokenId))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON");

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot Reject a Token when executing TokenReject and Duplicating Token Reference")
    void cannotRejectTokenWhenExecutingTokenRejectAndDuplicatingTokenReference() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token with duplicate token id - should fail with TOKEN_REFERENCE_REPEATED
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .setTokenIds(List.of(ftTokenId, ftTokenId))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_REFERENCE_REPEATED");

            // same test for nft

            var nftTokenId = EntityHelper.createNft(testEnv);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // transfer nfts to the receiver
            new TransferTransaction()
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the nft with duplicate nft id - should fail with TOKEN_REFERENCE_REPEATED
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .setNftIds(List.of(nftTokenId.nft(nftSerials.get(0)), nftTokenId.nft(nftSerials.get(0))))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_REFERENCE_REPEATED");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot Reject a Token when Owner Has Empty Balance")
    void cannotRejectTokenWhenOwnerHasEmptyBalance() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            // skip the transfer
            // associate the receiver
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(ftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token - should fail with INSUFFICIENT_TOKEN_BALANCE
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .addTokenId(ftTokenId)
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("INSUFFICIENT_TOKEN_BALANCE");

            // same test for nft

            var nftTokenId = EntityHelper.createNft(testEnv);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // skip the transfer
            // associate the receiver
            new TokenAssociateTransaction()
                .setAccountId(receiverAccountId)
                .setTokenIds(Collections.singletonList(nftTokenId))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the nft - should fail with INVALID_OWNER_ID
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .addNftId(nftTokenId.nft(nftSerials.get(0)))
                    .freezeWith(testEnv.client)
                    .sign(receiverAccountKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("INVALID_OWNER_ID");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot Reject a Token when Treasury Rejects itself")
    void cannotRejectTokenWhenTreasuryRejects() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);

            // skip the transfer
            // reject the token with the treasury - should fail with ACCOUNT_IS_TREASURY
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(testEnv.operatorId)
                    .addTokenId(ftTokenId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_IS_TREASURY");

            // same test for nft

            var nftTokenId = EntityHelper.createNft(testEnv);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // skip the transfer
            // reject the nft with the treasury - should fail with ACCOUNT_IS_TREASURY
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(testEnv.operatorId)
                    .addNftId(nftTokenId.nft(nftSerials.get(0)))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("ACCOUNT_IS_TREASURY");

        }
    }

    @Test
    @DisplayName("Cannot Reject a Token with Invalid Signature")
    void cannotRejectTokenWithInvalidSignature() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 3);
            var randomKey = PrivateKey.generateED25519();
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, 100);

            // transfer fts to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token with different key - should fail with INVALID_SIGNATURE
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(receiverAccountId)
                    .addTokenId(ftTokenId)
                    .freezeWith(testEnv.client)
                    .sign(randomKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("INVALID_SIGNATURE");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot Reject a Token when Token Or NFT ID is not set")
    void cannotRejectTokenWhenTokenOrNFTIdIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // reject the token with invalid token - should fail with EMPTY_TOKEN_REFERENCE_LIST
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
                new TokenRejectTransaction()
                    .setOwnerId(testEnv.operatorId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining("EMPTY_TOKEN_REFERENCE_LIST");
        
        }
    }

    @Test
    @DisplayName("Cannot Reject a Token when executing TokenReject and Token Reference List Size Exceeded")
    void cannotRejectTokenWhenTokenReferenceListSizeExceeded() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var ftTokenId = EntityHelper.createFungibleToken(testEnv, 18);
            var receiverAccountKey = PrivateKey.generateED25519();
            var receiverAccountId = EntityHelper.createAccount(testEnv, receiverAccountKey, -1);
            var nftTokenId = EntityHelper.createNft(testEnv);

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(nftTokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = mintReceipt.serials;

            // transfer the tokens to the receiver
            new TransferTransaction()
                .addTokenTransfer(ftTokenId, testEnv.operatorId, -10)
                .addTokenTransfer(ftTokenId, receiverAccountId, 10)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(0)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(1)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(2)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(3)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(4)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(5)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(6)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(7)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(8)), testEnv.operatorId, receiverAccountId)
                .addNftTransfer(nftTokenId.nft(nftSerials.get(9)), testEnv.operatorId, receiverAccountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // reject the token with 11 token references - should fail with TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED
            assertThatExceptionOfType(Exception.class).isThrownBy(() -> {
            new TokenRejectTransaction()
                .setOwnerId(receiverAccountId)
                .addTokenId(ftTokenId)
                .setNftIds(List.of(
                    nftTokenId.nft(nftSerials.get(0)),
                    nftTokenId.nft(nftSerials.get(1)),
                    nftTokenId.nft(nftSerials.get(2)),
                    nftTokenId.nft(nftSerials.get(3)),
                    nftTokenId.nft(nftSerials.get(4)),
                    nftTokenId.nft(nftSerials.get(5)),
                    nftTokenId.nft(nftSerials.get(6)),
                    nftTokenId.nft(nftSerials.get(7)),
                    nftTokenId.nft(nftSerials.get(8)),
                    nftTokenId.nft(nftSerials.get(9))
                ))
                .freezeWith(testEnv.client)
                .sign(receiverAccountKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);
            }).withMessageContaining("TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED");

            new TokenDeleteTransaction()
                .setTokenId(ftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenDeleteTransaction()
                .setTokenId(nftTokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenRevokeKycIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenRevokeKycTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenRevokeKycIntegrationTest {
    @Test
    @DisplayName("Can revoke kyc to account with token")
    void canRevokeKycAccountWithToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenRevokeKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot revoke kyc to account on token when token ID is not set")
    void cannotRevokeKycToAccountOnTokenWhenTokenIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenRevokeKycTransaction()
                    .setAccountId(accountId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot revoke kyc to account on token when account ID is not set")
    void cannotRevokeKycToAccountOnTokenWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenRevokeKycTransaction()
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot revoke kyc to account on token when account was not associated with")
    void cannotRevokeKycToAccountOnTokenWhenAccountWasNotAssociatedWith() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenRevokeKycTransaction()
                    .setAccountId(accountId)
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenTransferIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.CustomFixedFee;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenGrantKycTransaction;
import com.hedera.hashgraph.sdk.TransactionResponse;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenTransferIntegrationTest {
    @Test
    @DisplayName("Can transfer tokens")
    void tokenTransferTest() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            @Var TransactionResponse response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = response.getReceipt(testEnv.client).accountId;
            assertThat(accountId).isNotNull();

            response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = response.getReceipt(testEnv.client).tokenId;
            assertThat(tokenId).isNotNull();

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .signWithOperator(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, accountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot transfer tokens if balance is insufficient to pay fee")
    void insufficientBalanceForFee() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            PrivateKey key1 = PrivateKey.generateED25519();
            PrivateKey key2 = PrivateKey.generateED25519();
            var accountId1 = new AccountCreateTransaction()
                .setKey(key1)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;
            var accountId2 = new AccountCreateTransaction()
                .setKey(key2)
                .setInitialBalance(new Hbar(2))
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .accountId;

            var tokenId = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setInitialSupply(1)
                .setCustomFees(Collections.singletonList(new CustomFixedFee()
                    .setAmount(5000_000_000L)
                    .setFeeCollectorAccountId(testEnv.operatorId)))
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFeeScheduleKey(testEnv.operatorKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client)
                .tokenId;

            new TokenAssociateTransaction()
                .setAccountId(accountId1)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(accountId2)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key2)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -1)
                .addTokenTransfer(tokenId, accountId1, 1)
                .freezeWith(testEnv.client)
                .sign(key1)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TransferTransaction()
                    .addTokenTransfer(tokenId, accountId1, -1)
                    .addTokenTransfer(tokenId, accountId2, 1)
                    .freezeWith(testEnv.client)
                    .sign(key1)
                    .sign(key2)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).satisfies(error -> assertThat(error.getMessage()).containsAnyOf(
                    Status.INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE.toString(),
                    Status.INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE.toString()
                ));
        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenUnfreezeIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenUnfreezeTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenUnfreezeIntegrationTest {
    @Test
    @DisplayName("Can unfreeze account with token")
    void canUnfreezeAccountWithToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenUnfreezeTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot unfreeze account on token when token ID is not set")
    void cannotUnfreezeAccountOnTokenWhenTokenIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUnfreezeTransaction()
                    .setAccountId(accountId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot unfreeze account on token when account ID is not set")
    void cannotUnfreezeAccountOnTokenWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUnfreezeTransaction()
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot unfreeze account on token when account was not associated with")
    void cannotUnfreezeAccountOnTokenWhenAccountWasNotAssociatedWith() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUnfreezeTransaction()
                    .setAccountId(accountId)
                    .setTokenId(tokenId)
                    .freezeWith(testEnv.client)
                    .sign(key)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenUnpauseIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2023 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.junit.jupiter.api.Assertions.assertThrows;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenDeleteTransaction;
import com.hedera.hashgraph.sdk.TokenUnpauseTransaction;
import com.hedera.hashgraph.sdk.TokenWipeTransaction;
import com.hedera.hashgraph.sdk.TransferTransaction;
import java.util.Collections;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class TokenUnpauseIntegrationTest {

    @Test
    @DisplayName("Can execute token unpause transaction")
    void canExecuteTokenUnpauseTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var accountKey = PrivateKey.generateED25519();
            var testTokenAmount = 10;
            var accountId = new AccountCreateTransaction().setKey(accountKey).setInitialBalance(new Hbar(2))
                .execute(testEnv.client).getReceipt(testEnv.client).accountId;

            var tokenId = new TokenCreateTransaction().setTokenName("ffff").setTokenSymbol("F").setInitialSupply(1000000)
                .setDecimals(3).setTreasuryAccountId(testEnv.operatorId).setAdminKey(testEnv.operatorKey)
                .setPauseKey(testEnv.operatorKey).setWipeKey(testEnv.operatorKey).setFreezeDefault(false)
                .execute(testEnv.client).getReceipt(testEnv.client).tokenId;

            new TokenAssociateTransaction().setAccountId(accountId).setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client).sign(accountKey).execute(testEnv.client).getReceipt(testEnv.client);

            new TokenUnpauseTransaction().setTokenId(tokenId).freezeWith(testEnv.client).execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction().addTokenTransfer(tokenId, accountId, testTokenAmount)
                .addTokenTransfer(tokenId, testEnv.operatorId, -testTokenAmount).execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenWipeTransaction().setTokenId(tokenId).setAccountId(accountId).setAmount(testTokenAmount)
                .execute(testEnv.client).getReceipt(testEnv.client);

            new TokenDeleteTransaction().setTokenId(tokenId).execute(testEnv.client).getReceipt(testEnv.client);

            new AccountDeleteTransaction().setTransferAccountId(testEnv.operatorId).setAccountId(accountId)
                .freezeWith(testEnv.client).sign(accountKey).execute(testEnv.client).getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot unpause with no token ID")
    void cannotUnpauseWithNoTokenId() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            assertThrows(PrecheckStatusException.class, () -> {
                new TokenUnpauseTransaction().execute(testEnv.client).getReceipt(testEnv.client);
            });

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenUpdateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenInfoQuery;
import com.hedera.hashgraph.sdk.TokenKeyValidation;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TokenUpdateTransaction;
import java.util.Objects;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TokenUpdateIntegrationTest {

    @Test
    @DisplayName("Can update token")
    void canUpdateToken() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setDecimals(3)
                .setInitialSupply(1000000)
                .setTreasuryAccountId(testEnv.operatorId)
                .setAdminKey(testEnv.operatorKey)
                .setFreezeKey(testEnv.operatorKey)
                .setWipeKey(testEnv.operatorKey)
                .setKycKey(testEnv.operatorKey)
                .setSupplyKey(testEnv.operatorKey)
                .setPauseKey(testEnv.operatorKey)
                .setMetadataKey(testEnv.operatorKey)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            @Var var info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("ffff");
            assertThat(info.symbol).isEqualTo("F");
            assertThat(info.decimals).isEqualTo(3);
            assertThat(info.treasuryAccountId).isEqualTo(testEnv.operatorId);
            assertThat(info.adminKey).isNotNull();
            assertThat(info.freezeKey).isNotNull();
            assertThat(info.wipeKey).isNotNull();
            assertThat(info.kycKey).isNotNull();
            assertThat(info.supplyKey).isNotNull();
            assertThat(info.adminKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.freezeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.wipeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.kycKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.supplyKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.pauseKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.metadataKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.defaultFreezeStatus).isNotNull().isFalse();
            assertThat(info.defaultKycStatus).isNotNull().isFalse();

            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenName("aaaa")
                .setTokenSymbol("A")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            info = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(info.tokenId).isEqualTo(tokenId);
            assertThat(info.name).isEqualTo("aaaa");
            assertThat(info.symbol).isEqualTo("A");
            assertThat(info.decimals).isEqualTo(3);
            assertThat(info.treasuryAccountId).isEqualTo(testEnv.operatorId);
            assertThat(info.adminKey).isNotNull();
            assertThat(info.freezeKey).isNotNull();
            assertThat(info.wipeKey).isNotNull();
            assertThat(info.kycKey).isNotNull();
            assertThat(info.supplyKey).isNotNull();
            assertThat(info.adminKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.freezeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.wipeKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.kycKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.supplyKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.pauseKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.metadataKey.toString()).isEqualTo(testEnv.operatorKey.toString());
            assertThat(info.defaultFreezeStatus).isNotNull();
            assertThat(info.defaultFreezeStatus).isFalse();
            assertThat(info.defaultKycStatus).isNotNull();
            assertThat(info.defaultKycStatus).isFalse();

        }
    }

    @Test
    @DisplayName("Cannot update immutable token")
    void cannotUpdateImmutableToken() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var response = new TokenCreateTransaction()
                .setTokenName("ffff")
                .setTokenSymbol("F")
                .setTreasuryAccountId(testEnv.operatorId)
                .setFreezeDefault(false)
                .execute(testEnv.client);

            var tokenId = Objects.requireNonNull(response.getReceipt(testEnv.client).tokenId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setTokenName("aaaa")
                    .setTokenSymbol("A")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

        }
    }

    /**
     * @notice E2E-HIP-646
     * @url https://hips.hedera.com/hip/hip-646
     */
    @Test
    @DisplayName("Can update a fungible token's metadata")
    void canUpdateFungibleTokenMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};

            // create a fungible token with metadata
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.FUNGIBLE_COMMON)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);

            // update token's metadata
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMetadata(updatedTokenMetadata)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterMetadataUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterMetadataUpdate.metadata).isEqualTo(updatedTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-765
     * @url https://hips.hedera.com/hip/hip-765
     */
    @Test
    @DisplayName("Can update a non fungible token's metadata")
    void canUpdateNonFungibleTokenMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};

            // create a non fungible token with metadata
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
                );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);

            // update token's metadata
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMetadata(updatedTokenMetadata)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterMetadataUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterMetadataUpdate.metadata).isEqualTo(updatedTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-646
     * @url https://hips.hedera.com/hip/hip-646
     */
    @Test
    @DisplayName("Can update an immutable fungible token's metadata")
    void canUpdateImmutableFungibleTokenMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};
            var metadataKey = PrivateKey.generateED25519();

            // create a fungible token with metadata and metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.FUNGIBLE_COMMON)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setMetadataKey(metadataKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
                );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);
            assertThat(tokenInfoAfterCreation.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // update token's metadata
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMetadata(updatedTokenMetadata)
                .freezeWith(testEnv.client)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterMetadataUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterMetadataUpdate.metadata).isEqualTo(updatedTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-765
     * @url https://hips.hedera.com/hip/hip-765
     */
    @Test
    @DisplayName("Can update an immutable non fungible token's metadata")
    void canUpdateImmutableNonFungibleTokenMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};
            var metadataKey = PrivateKey.generateED25519();

            // create a non fungible token with metadata and metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setSupplyKey(testEnv.operatorKey)
                    .setMetadataKey(metadataKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
                );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);
            assertThat(tokenInfoAfterCreation.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // update token's metadata
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMetadata(updatedTokenMetadata)
                .freezeWith(testEnv.client)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterMetadataUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterMetadataUpdate.metadata).isEqualTo(updatedTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-646
     * @url https://hips.hedera.com/hip/hip-646
     */
    @Test
    @DisplayName("Cannot update a fungible token with metadata when it is not set")
    void cannotUpdateFungibleTokenMetadataWhenItsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};

            // create a fungible token with metadata
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.FUNGIBLE_COMMON)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);

            // update token, but don't update metadata
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMemo("abc")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterMemoUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterMemoUpdate.metadata).isEqualTo(initialTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-765
     * @url https://hips.hedera.com/hip/hip-765
     */
    @Test
    @DisplayName("Cannot update a non fungible token with metadata when it is not set")
    void cannotUpdateNonFungibleTokenMetadataWhenItsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};

            // create a non fungible token with metadata
            var tokenId = Objects.requireNonNull(
            new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);

            // update token, but don't update metadata
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMemo("abc")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterMemoUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterMemoUpdate.metadata).isEqualTo(initialTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-646
     * @url https://hips.hedera.com/hip/hip-646
     */
    @Test
    @DisplayName("Can erase fungible token metadata")
    void canEraseFungibleTokenMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var emptyTokenMetadata = new byte[]{};

            // create a fungible token with metadata
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.FUNGIBLE_COMMON)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);

            // erase token metadata (update token with empty metadata)
            new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setTokenMetadata(emptyTokenMetadata)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            var tokenInfoAfterSettingEmptyMetadata = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterSettingEmptyMetadata.metadata).isEqualTo(emptyTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-765
     * @url https://hips.hedera.com/hip/hip-765
     */
    @Test
    @DisplayName("Can erase non fungible token metadata")
    void canEraseNonFungibleTokenMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var emptyTokenMetadata = new byte[]{};

            // create a non fungible token with metadata
            var tokenId = Objects.requireNonNull(
            new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoAfterCreation = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterCreation.metadata).isEqualTo(initialTokenMetadata);

            // erase token metadata (update token with empty metadata)
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setTokenMetadata(emptyTokenMetadata)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterSettingEmptyMetadata = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterSettingEmptyMetadata.metadata).isEqualTo(emptyTokenMetadata);

        }
    }

    /**
     * @notice E2E-HIP-646
     * @url https://hips.hedera.com/hip/hip-646
     */
    @Test
    @DisplayName("Cannot update a fungible token with metadata when transaction is not signed with an admin or a metadata key")
    void cannotUpdateFungibleTokenMetadataWhenTransactionIsNotSignedWithMetadataKey() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()) {

            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};
            var adminKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // create a fungible token with metadata and metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.FUNGIBLE_COMMON)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setAdminKey(adminKey)
                    .setMetadataKey(metadataKey)
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setTokenMetadata(updatedTokenMetadata)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-765
     * @url https://hips.hedera.com/hip/hip-765
     */
    @Test
    @DisplayName("Cannot update a non fungible token with metadata when transaction is not signed with an admin or a metadata key")
    void cannotUpdateNonFungibleTokenMetadataWhenTransactionIsNotSignedWithMetadataKey() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};
            var adminKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // create a non fungible token with metadata and metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setMetadataKey(metadataKey)
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setTokenMetadata(updatedTokenMetadata)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-646
     * @url https://hips.hedera.com/hip/hip-646
     */
    @Test
    @DisplayName("Cannot update a fungible token with metadata when admin and metadata keys are not set")
    void cannotUpdateFungibleTokenMetadataWhenMetadataKeyNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};

            // create a fungible token with metadata and without a metadata key and admin key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.FUNGIBLE_COMMON)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setTokenMetadata(updatedTokenMetadata)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

        }
    }

    /**
     * @notice E2E-HIP-765
     * @url https://hips.hedera.com/hip/hip-765
     */
    @Test
    @DisplayName("Cannot update a non fungible token with metadata when admin and metadata keys are not set")
    void cannotUpdateNonFungibleTokenMetadataWhenMetadataKeyNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){
            var initialTokenMetadata = new byte[]{1, 1, 1, 1, 1};
            var updatedTokenMetadata = new byte[]{2, 2, 2, 2, 2};

            // create a non fungible token with metadata and without a metadata key and admin key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenMetadata(initialTokenMetadata)
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setSupplyKey(testEnv.operatorKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setTokenMetadata(updatedTokenMetadata)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can make a token immutable when updating keys to an empty KeyList, signing with an Admin Key, and setting the key verification mode to NO_VALIDATION")
    void canMakeTokenImmutableWhenUpdatingKeysToEmptyKeyListSigningWithAdminKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var adminKey = PrivateKey.generateED25519();
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            var emptyKeyList = new KeyList();

            // Make a token immutable by removing all of its keys when updating them to an empty KeyList,
            // signing with an Admin Key, and setting the key verification mode to NO_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(emptyKeyList)
                .setKycKey(emptyKeyList)
                .setFreezeKey(emptyKeyList)
                .setPauseKey(emptyKeyList)
                .setSupplyKey(emptyKeyList)
                .setFeeScheduleKey(emptyKeyList)
                .setMetadataKey(emptyKeyList)
                .setAdminKey(emptyKeyList)
                .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.adminKey).isNull();
            assertThat(tokenInfoAfterUpdate.wipeKey).isNull();
            assertThat(tokenInfoAfterUpdate.kycKey).isNull();
            assertThat(tokenInfoAfterUpdate.freezeKey).isNull();
            assertThat(tokenInfoAfterUpdate.pauseKey).isNull();
            assertThat(tokenInfoAfterUpdate.supplyKey).isNull();
            assertThat(tokenInfoAfterUpdate.feeScheduleKey).isNull();
            assertThat(tokenInfoAfterUpdate.metadataKey).isNull();

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can remove all of tokens lower-privilege keys when updating keys to an empty KeyList, signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION")
    void canRemoveAllLowerPrivilegeKeysWhenUpdatingKeysToEmptyKeyListSigningWithAdminKeyWithKeyVerificationSetToFullValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var adminKey = PrivateKey.generateED25519();
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            var emptyKeyList = new KeyList();

            // Remove all of tokens lower-privilege keys when updating them to an empty KeyList,
            // signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(emptyKeyList)
                .setKycKey(emptyKeyList)
                .setFreezeKey(emptyKeyList)
                .setPauseKey(emptyKeyList)
                .setSupplyKey(emptyKeyList)
                .setFeeScheduleKey(emptyKeyList)
                .setMetadataKey(emptyKeyList)
                .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.wipeKey).isNull();
            assertThat(tokenInfoAfterUpdate.kycKey).isNull();
            assertThat(tokenInfoAfterUpdate.freezeKey).isNull();
            assertThat(tokenInfoAfterUpdate.pauseKey).isNull();
            assertThat(tokenInfoAfterUpdate.supplyKey).isNull();
            assertThat(tokenInfoAfterUpdate.feeScheduleKey).isNull();
            assertThat(tokenInfoAfterUpdate.metadataKey).isNull();

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key), when signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION, and then revert previous keys")
    void canUpdateAllLowerPrivilegeKeysToUnusableKeyWhenSigningWithAdminKeyWithKeyVerificationSetToFullValidationAndThenRevertPreviousKeys() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var adminKey = PrivateKey.generateED25519();
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key),
            // signing with an Admin Key, and setting the key verification mode to FULL_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(PublicKey.unusableKey())
                .setKycKey(PublicKey.unusableKey())
                .setFreezeKey(PublicKey.unusableKey())
                .setPauseKey(PublicKey.unusableKey())
                .setSupplyKey(PublicKey.unusableKey())
                .setFeeScheduleKey(PublicKey.unusableKey())
                .setMetadataKey(PublicKey.unusableKey())
                .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.wipeKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.kycKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.freezeKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.pauseKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.supplyKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.feeScheduleKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.metadataKey.toString()).isEqualTo(PublicKey.unusableKey().toString());

            // Set all lower-privilege keys back by signing with an Admin Key,
            // and setting key verification mode to NO_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(wipeKey.getPublicKey())
                .setKycKey(kycKey.getPublicKey())
                .setFreezeKey(freezeKey.getPublicKey())
                .setPauseKey(pauseKey.getPublicKey())
                .setSupplyKey(supplyKey.getPublicKey())
                .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                .setMetadataKey(metadataKey.getPublicKey())
                .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterRevert = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterRevert.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoAfterRevert.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can update all of tokens lower-privilege keys when signing with an Admin Key and new respective lower-privilege key, and setting key verification mode to FULL_VALIDATION")
    void canUpdateAllLowerPrivilegeKeysWhenSigningWithAdminKeyAndNewLowerPrivilegeKeyWithKeyVerificationSetToFullValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var adminKey = PrivateKey.generateED25519();
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // New Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var newWipeKey = PrivateKey.generateED25519();
            var newKycKey = PrivateKey.generateED25519();
            var newFreezeKey = PrivateKey.generateED25519();
            var newPauseKey = PrivateKey.generateED25519();
            var newSupplyKey = PrivateKey.generateED25519();
            var newFeeScheduleKey = PrivateKey.generateED25519();
            var newMetadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys when signing with an Admin Key and new respective lower-privilege key,
            // and setting key verification mode to FULL_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(newWipeKey.getPublicKey())
                .setKycKey(newKycKey.getPublicKey())
                .setFreezeKey(newFreezeKey.getPublicKey())
                .setPauseKey(newPauseKey.getPublicKey())
                .setSupplyKey(newSupplyKey.getPublicKey())
                .setFeeScheduleKey(newFeeScheduleKey.getPublicKey())
                .setMetadataKey(newMetadataKey.getPublicKey())
                .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(adminKey)
                .sign(newWipeKey)
                .sign(newKycKey)
                .sign(newFreezeKey)
                .sign(newPauseKey)
                .sign(newSupplyKey)
                .sign(newFeeScheduleKey)
                .sign(newMetadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.wipeKey.toString()).isEqualTo(newWipeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.kycKey.toString()).isEqualTo(newKycKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.freezeKey.toString()).isEqualTo(newFreezeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.pauseKey.toString()).isEqualTo(newPauseKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.supplyKey.toString()).isEqualTo(newSupplyKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.feeScheduleKey.toString()).isEqualTo(newFeeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.metadataKey.toString()).isEqualTo(newMetadataKey.getPublicKey().toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot make a token immutable when updating keys to an empty KeyList, signing with a key that is different from an Admin Key, and setting the key verification mode to NO_VALIDATION")
    void cannotMakeTokenImmutableWhenUpdatingKeysToEmptyKeyListSigningWithDifferentKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var adminKey = PrivateKey.generateED25519();
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            var emptyKeyList = new KeyList();

            // Make the token immutable when updating all of its keys to an empty KeyList
            // (trying to remove keys one by one to check all errors),
            // signing with a key that is different from an Admin Key (implicitly with an operator key),
            // and setting the key verification mode to NO_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setAdminKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot make a token immutable when updating keys to an unusable key (i.e. all-zeros key), signing with a key that is different from an Admin Key, and setting the key verification mode to NO_VALIDATION")
    void cannotMakeTokenImmutableWhenUpdatingKeysToUnusableKeySigningWithDifferentKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin, Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var adminKey = PrivateKey.generateED25519();
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Make the token immutable when updating all of its keys to an unusable key (i.e. all-zeros key)
            // (trying to remove keys one by one to check all errors),
            // signing with a key that is different from an Admin Key (implicitly with an operator key),
            // and setting the key verification mode to NO_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setAdminKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot update the Admin Key to an unusable key (i.e. all-zeros key), signing with an Admin Key, and setting the key verification mode to NO_VALIDATION")
    void cannotUpdateAdminKeyToUnusableKeySigningWithAdminKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Admin and supply keys
            var adminKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(adminKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.adminKey.toString()).isEqualTo(adminKey.getPublicKey().toString());

            // Update the Admin Key to an unusable key (i.e., all-zeros key),
            // signing with an Admin Key, and setting the key verification mode to NO_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setAdminKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key), when signing with a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION")
    void canUpdateAllLowerPrivilegeKeysToUnusableKeyWhenSigningWithRespectiveLowerPrivilegeKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key),
            // when signing with a respective lower-privilege key,
            // and setting the key verification mode to NO_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(PublicKey.unusableKey())
                .setKycKey(PublicKey.unusableKey())
                .setFreezeKey(PublicKey.unusableKey())
                .setPauseKey(PublicKey.unusableKey())
                .setSupplyKey(PublicKey.unusableKey())
                .setFeeScheduleKey(PublicKey.unusableKey())
                .setMetadataKey(PublicKey.unusableKey())
                .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(wipeKey)
                .sign(kycKey)
                .sign(freezeKey)
                .sign(pauseKey)
                .sign(supplyKey)
                .sign(feeScheduleKey)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.wipeKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.kycKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.freezeKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.pauseKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.supplyKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.feeScheduleKey.toString()).isEqualTo(PublicKey.unusableKey().toString());
            assertThat(tokenInfoAfterUpdate.metadataKey.toString()).isEqualTo(PublicKey.unusableKey().toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can update all of tokens lower-privilege keys when signing with an old lower-privilege key and with a new lower-privilege key, and setting key verification mode to FULL_VALIDATION")
    void canUpdateAllLowerPrivilegeKeysWhenSigningWithOldLowerPrivilegeKeyAndNewLowerPrivilegeKeyWithKeyVerificationSetToFulValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // New Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var newWipeKey = PrivateKey.generateED25519();
            var newKycKey = PrivateKey.generateED25519();
            var newFreezeKey = PrivateKey.generateED25519();
            var newPauseKey = PrivateKey.generateED25519();
            var newSupplyKey = PrivateKey.generateED25519();
            var newFeeScheduleKey = PrivateKey.generateED25519();
            var newMetadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys when signing with an old respective lower-privilege key,
            // and setting key verification mode to NO_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(newWipeKey.getPublicKey())
                .setKycKey(newKycKey.getPublicKey())
                .setFreezeKey(newFreezeKey.getPublicKey())
                .setPauseKey(newPauseKey.getPublicKey())
                .setSupplyKey(newSupplyKey.getPublicKey())
                .setFeeScheduleKey(newFeeScheduleKey.getPublicKey())
                .setMetadataKey(newMetadataKey.getPublicKey())
                .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(wipeKey)
                .sign(newWipeKey)
                .sign(kycKey)
                .sign(newKycKey)
                .sign(freezeKey)
                .sign(newFreezeKey)
                .sign(pauseKey)
                .sign(newPauseKey)
                .sign(supplyKey)
                .sign(newSupplyKey)
                .sign(feeScheduleKey)
                .sign(newFeeScheduleKey)
                .sign(metadataKey)
                .sign(newMetadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.wipeKey.toString()).isEqualTo(newWipeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.kycKey.toString()).isEqualTo(newKycKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.freezeKey.toString()).isEqualTo(newFreezeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.pauseKey.toString()).isEqualTo(newPauseKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.supplyKey.toString()).isEqualTo(newSupplyKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.feeScheduleKey.toString()).isEqualTo(newFeeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.metadataKey.toString()).isEqualTo(newMetadataKey.getPublicKey().toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Can update all of tokens lower-privilege keys when signing ONLY with an old lower-privilege key, and setting key verification mode to NO_VALIDATION")
    void canUpdateAllLowerPrivilegeKeysWhenSigningOnlyWithOldLowerPrivilegeKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // New Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var newWipeKey = PrivateKey.generateED25519();
            var newKycKey = PrivateKey.generateED25519();
            var newFreezeKey = PrivateKey.generateED25519();
            var newPauseKey = PrivateKey.generateED25519();
            var newSupplyKey = PrivateKey.generateED25519();
            var newFeeScheduleKey = PrivateKey.generateED25519();
            var newMetadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys when signing with an old respective lower-privilege key,
            // and setting key verification mode to NO_VALIDATION
            new TokenUpdateTransaction()
                .setTokenId(tokenId)
                .setWipeKey(newWipeKey.getPublicKey())
                .setKycKey(newKycKey.getPublicKey())
                .setFreezeKey(newFreezeKey.getPublicKey())
                .setPauseKey(newPauseKey.getPublicKey())
                .setSupplyKey(newSupplyKey.getPublicKey())
                .setFeeScheduleKey(newFeeScheduleKey.getPublicKey())
                .setMetadataKey(newMetadataKey.getPublicKey())
                .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                .freezeWith(testEnv.client)
                .sign(wipeKey)
                .sign(kycKey)
                .sign(freezeKey)
                .sign(pauseKey)
                .sign(supplyKey)
                .sign(feeScheduleKey)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var tokenInfoAfterUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoAfterUpdate.wipeKey.toString()).isEqualTo(newWipeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.kycKey.toString()).isEqualTo(newKycKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.freezeKey.toString()).isEqualTo(newFreezeKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.pauseKey.toString()).isEqualTo(newPauseKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.supplyKey.toString()).isEqualTo(newSupplyKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.feeScheduleKey.toString()).isEqualTo(newFeeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoAfterUpdate.metadataKey.toString()).isEqualTo(newMetadataKey.getPublicKey().toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot remove all of tokens lower-privilege keys when updating them to an empty KeyList, signing with a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION")
    void cannotRemoveAllLowerPrivilegeKeysWhenUpdatingKeysToEmptyKeyListSigningWithRespectiveLowerPrivilegeKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            var emptyKeyList = new KeyList();

            // Remove all of tokens lower-privilege keys
            // when updating them to an empty KeyList (trying to remove keys one by one to check all errors),
            // signing with a respective lower-privilege key,
            // and setting the key verification mode to NO_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(wipeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(kycKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(freezeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(pauseKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(supplyKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(feeScheduleKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(emptyKeyList)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.TOKEN_IS_IMMUTABLE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key), when signing with a key that is different from a respective lower-privilege key, and setting the key verification mode to NO_VALIDATION")
    void cannotUpdateAllLowerPrivilegeKeysToUnusableKeyWhenSigningWithDifferentKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key)
            // (trying to remove keys one by one to check all errors),
            // signing with a key that is different from a respective lower-privilege key (implicitly with an operator key),
            // and setting the key verification mode to NO_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key), when signing ONLY with an old respective lower-privilege key, and setting the key verification mode to FULL_VALIDATION")
    void cannotUpdateAllLowerPrivilegeKeysToUnusableKeyWhenSigningOnlyWithOldRespectiveLowerPrivilegeKeyWithKeyVerificationSetToFullValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key)
            // (trying to remove keys one by one to check all errors),
            // signing ONLY with an old respective lower-privilege key,
            // and setting the key verification mode to FULL_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(wipeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(kycKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(freezeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(pauseKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(supplyKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(feeScheduleKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot update all of tokens lower-privilege keys to an unusable key (i.e. all-zeros key), when signing with an old respective lower-privilege key and new respective lower-privilege key, and setting the key verification mode to FULL_VALIDATION")
    void cannotUpdateAllLowerPrivilegeKeysToUnusableKeyWhenSigningWithOldRespectiveLowerPrivilegeKeyAndNewRespectiveLowerPrivilegeKeyWithKeyVerificationSetToFullValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // New Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var newWipeKey = PrivateKey.generateED25519();
            var newKycKey = PrivateKey.generateED25519();
            var newFreezeKey = PrivateKey.generateED25519();
            var newPauseKey = PrivateKey.generateED25519();
            var newSupplyKey = PrivateKey.generateED25519();
            var newFeeScheduleKey = PrivateKey.generateED25519();
            var newMetadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys to an unusable key (i.e., all-zeros key)
            // (trying to remove keys one by one to check all errors),
            // signing with an old respective lower-privilege key and new respective lower-privilege key,
            // and setting the key verification mode to FULL_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(wipeKey)
                    .sign(newWipeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(kycKey)
                    .sign(newKycKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(freezeKey)
                    .sign(newFreezeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(pauseKey)
                    .sign(newPauseKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(supplyKey)
                    .sign(newSupplyKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(feeScheduleKey)
                    .sign(newFeeScheduleKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(PublicKey.unusableKey())
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(metadataKey)
                    .sign(newMetadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot update all of tokens lower-privilege keys, when signing ONLY with an old respective lower-privilege key, and setting the key verification mode to FULL_VALIDATION")
    void cannotUpdateAllLowerPrivilegeKeysWhenSigningOnlyWithOldRespectiveLowerPrivilegeKeyWithKeyVerificationSetToFullValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // New Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var newWipeKey = PrivateKey.generateED25519();
            var newKycKey = PrivateKey.generateED25519();
            var newFreezeKey = PrivateKey.generateED25519();
            var newPauseKey = PrivateKey.generateED25519();
            var newSupplyKey = PrivateKey.generateED25519();
            var newFeeScheduleKey = PrivateKey.generateED25519();
            var newMetadataKey = PrivateKey.generateED25519();

            // Create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // Update all of tokens lower-privilege keys
            // (trying to update keys one by one to check all errors),
            // signing ONLY with an old respective lower-privilege key,
            // and setting the key verification mode to FULL_VALIDATION
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(newWipeKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(wipeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(newKycKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(kycKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(newFreezeKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(freezeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(newPauseKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(pauseKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(newSupplyKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(supplyKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(newFeeScheduleKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(feeScheduleKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(newMetadataKey)
                    .setKeyVerificationMode(TokenKeyValidation.FULL_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * @notice E2E-HIP-540
     * @url https://hips.hedera.com/hip/hip-540
     */
    @Test
    @DisplayName("Cannot update all of tokens lower-privilege keys when updating them to a keys with an invalid structure and signing with an old respective lower-privilege and setting key verification mode to NO_VALIDATION")
    void cannotUpdateAllLowerPrivilegeKeysWhenUpdatingKeysToStructurallyInvalidKeysSigningOnlyWithOldRespectiveLowerPrivilegeKeyWithKeyVerificationSetToNoValidation() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            // Wipe, KYC, Freeze, Pause, Supply, Fee Schedule, Metadata keys
            var wipeKey = PrivateKey.generateED25519();
            var kycKey = PrivateKey.generateED25519();
            var freezeKey = PrivateKey.generateED25519();
            var pauseKey = PrivateKey.generateED25519();
            var supplyKey = PrivateKey.generateED25519();
            var feeScheduleKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();

            // create a non-fungible token
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("Test NFT")
                    .setTokenSymbol("TNFT")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setWipeKey(wipeKey.getPublicKey())
                    .setKycKey(kycKey.getPublicKey())
                    .setFreezeKey(freezeKey.getPublicKey())
                    .setPauseKey(pauseKey.getPublicKey())
                    .setSupplyKey(supplyKey.getPublicKey())
                    .setFeeScheduleKey(feeScheduleKey.getPublicKey())
                    .setMetadataKey(metadataKey.getPublicKey())
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfoBeforeUpdate = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfoBeforeUpdate.wipeKey.toString()).isEqualTo(wipeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.kycKey.toString()).isEqualTo(kycKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.freezeKey.toString()).isEqualTo(freezeKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.pauseKey.toString()).isEqualTo(pauseKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.supplyKey.toString()).isEqualTo(supplyKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.feeScheduleKey.toString()).isEqualTo(feeScheduleKey.getPublicKey().toString());
            assertThat(tokenInfoBeforeUpdate.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // This key is truly invalid, as all Ed25519 public keys must be 32 bytes long
            var structurallyInvalidKey = PublicKey.fromString("000000000000000000000000000000000000000000000000000000000000000000");

            // update all of tokens lower-privilege keys
            // to a structurally invalid key (trying to update keys one by one to check all errors),
            // signing with an old respective lower-privilege
            // and setting key verification mode to NO_VALIDATION
            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setWipeKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(wipeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_WIPE_KEY.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setKycKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(kycKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_KYC_KEY.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFreezeKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(freezeKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_FREEZE_KEY.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setPauseKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(pauseKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_PAUSE_KEY.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setSupplyKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(supplyKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SUPPLY_KEY.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setFeeScheduleKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(feeScheduleKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_CUSTOM_FEE_SCHEDULE_KEY.toString());

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenUpdateTransaction()
                    .setTokenId(tokenId)
                    .setMetadataKey(structurallyInvalidKey)
                    .setKeyVerificationMode(TokenKeyValidation.NO_VALIDATION)
                    .freezeWith(testEnv.client)
                    .sign(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_METADATA_KEY.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenUpdateNftsIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.NftId;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenId;
import com.hedera.hashgraph.sdk.TokenInfoQuery;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenNftInfoQuery;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TokenUpdateNftsTransaction;
import java.util.List;
import java.util.Objects;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * @notice E2E-HIP-657
 * @url https://hips.hedera.com/hip/hip-657
 */
public class TokenUpdateNftsIntegrationTest {

    @Test
    @DisplayName("Can update the metadata of the entire NFT collection")
    void canUpdateNFTMetadataOfEntireCollection() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var metadataKey = PrivateKey.generateED25519();
            var nftCount = 4;
            var initialMetadataList = NftMetadataGenerator.generate(new byte[]{4, 2, 0}, nftCount);
            var updatedMetadata = new byte[]{6, 9};
            var updatedMetadataList = NftMetadataGenerator.generate(updatedMetadata, nftCount);

            // create a token with metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setMetadataKey(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            // mint tokens
            var tokenMintTransactionReceipt = new TokenMintTransaction()
                .setMetadata(initialMetadataList)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check that metadata was set correctly
            var nftSerials = tokenMintTransactionReceipt.serials;
            List<byte[]> metadataListAfterMint = getMetadataList(testEnv.client, tokenId, nftSerials);

            assertThat(metadataListAfterMint.toArray()).isEqualTo(initialMetadataList.toArray());

            // update metadata all minted NFTs
            new TokenUpdateNftsTransaction()
                .setTokenId(tokenId)
                .setSerials(nftSerials)
                .setMetadata(updatedMetadata)
                .freezeWith(testEnv.client)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check updated NFTs' metadata
            List<byte[]> metadataListAfterUpdate = getMetadataList(testEnv.client, tokenId, nftSerials);
            assertThat(metadataListAfterUpdate.toArray()).isEqualTo(updatedMetadataList.toArray());

        }
    }

    @Test
    @DisplayName("Can update the metadata of a part of the NFT collection")
    void canUpdateNFTMetadataOfPartOfCollection() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var metadataKey = PrivateKey.generateED25519();
            var nftCount = 4;
            var initialMetadataList = NftMetadataGenerator.generate(new byte[]{4, 2, 0}, nftCount);
            var updatedMetadata = new byte[]{6, 9};
            var updatedMetadataList = NftMetadataGenerator.generate(updatedMetadata, nftCount / 2);

            // create a token with metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setMetadataKey(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            // mint tokens
            var tokenMintTransactionReceipt = new TokenMintTransaction()
                .setMetadata(initialMetadataList)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check that metadata was set correctly
            var nftSerials = tokenMintTransactionReceipt.serials;
            List<byte[]> metadataListAfterMint = getMetadataList(testEnv.client, tokenId, nftSerials);

            assertThat(metadataListAfterMint.toArray()).isEqualTo(initialMetadataList.toArray());

            // update metadata of the first two minted NFTs
            var nftSerialsToUpdate = nftSerials.subList(0, nftCount / 2);

            new TokenUpdateNftsTransaction()
                .setTokenId(tokenId)
                .setSerials(nftSerialsToUpdate)
                .setMetadata(updatedMetadata)
                .freezeWith(testEnv.client)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check updated NFTs' metadata
            List<byte[]> metadataListAfterUpdate = getMetadataList(testEnv.client, tokenId, nftSerialsToUpdate);

            assertThat(metadataListAfterUpdate.toArray()).isEqualTo(updatedMetadataList.toArray());

            // check that remaining NFTs were not updated
            var nftSerialsSame = nftSerials.subList(nftCount / 2, nftCount);
            List<byte[]> metadataList = getMetadataList(testEnv.client, tokenId, nftSerialsSame);

            assertThat(metadataList.toArray()).isEqualTo(initialMetadataList.subList(nftCount / 2, nftCount).toArray());

        }
    }

    @Test
    @DisplayName("Cannot update NFTs metadata when it is not set")
    void cannotUpdateNFTMetadataWhenItsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var metadataKey = PrivateKey.generateED25519();
            var nftCount = 4;
            var initialMetadataList = NftMetadataGenerator.generate(new byte[]{4, 2, 0}, nftCount);

            // create a token with metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setMetadataKey(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            // mint tokens
            var tokenMintTransactionReceipt = new TokenMintTransaction()
                .setMetadata(initialMetadataList)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check that metadata was set correctly
            var nftSerials = tokenMintTransactionReceipt.serials;
            List<byte[]> metadataListAfterMint = getMetadataList(testEnv.client, tokenId, nftSerials);

            assertThat(metadataListAfterMint.toArray()).isEqualTo(initialMetadataList.toArray());

            // run `TokenUpdateNftsTransaction` without `setMetadata`
            new TokenUpdateNftsTransaction()
                .setTokenId(tokenId)
                .setSerials(nftSerials)
                .freezeWith(testEnv.client)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check that NFTs' metadata was not updated
            List<byte[]> metadataListAfterUpdate = getMetadataList(testEnv.client, tokenId, nftSerials);
            assertThat(metadataListAfterUpdate.toArray()).isEqualTo(initialMetadataList.toArray());

        }
    }

    @Test
    @DisplayName("Can erase NFTs metadata")
    void canEraseNFTsMetadata() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var metadataKey = PrivateKey.generateED25519();
            var nftCount = 4;
            var initialMetadataList = NftMetadataGenerator.generate(new byte[]{4, 2, 0}, nftCount);
            var emptyMetadata = new byte[]{};
            var emptyMetadataList = NftMetadataGenerator.generate(emptyMetadata, nftCount);

            // create a token with metadata key
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setMetadataKey(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            // mint tokens
            var tokenMintTransactionReceipt = new TokenMintTransaction()
                .setMetadata(initialMetadataList)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check that metadata was set correctly
            var nftSerials = tokenMintTransactionReceipt.serials;
            List<byte[]> metadataListAfterMint = getMetadataList(testEnv.client, tokenId, nftSerials);

            assertThat(metadataListAfterMint.toArray()).isEqualTo(initialMetadataList.toArray());

            // erase metadata all minted NFTs (update to an empty byte array)
            new TokenUpdateNftsTransaction()
                .setTokenId(tokenId)
                .setSerials(nftSerials)
                .setMetadata(emptyMetadata)
                .freezeWith(testEnv.client)
                .sign(metadataKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            // check that NFTs' metadata was erased
            List<byte[]> metadataListAfterUpdate = getMetadataList(testEnv.client, tokenId, nftSerials);
            assertThat(metadataListAfterUpdate.toArray()).isEqualTo(emptyMetadataList.toArray());

        }
    }

    @Test
    @DisplayName("Cannot update NFT metadata when transaction is not signed with metadata key")
    void cannotUpdateNFTMetadataWhenTransactionIsNotSignedWithMetadataKey() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var supplyKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();
            var nftCount = 4;
            var initialMetadataList = NftMetadataGenerator.generate(new byte[]{4, 2, 0}, nftCount);
            var updatedMetadata = new byte[]{6, 9};

            // create a token with a metadata key and check it
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(supplyKey)
                    .setMetadataKey(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfo = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfo.metadataKey.toString()).isEqualTo(metadataKey.getPublicKey().toString());

            // mint tokens
            var tokenMintTransactionReceipt = new TokenMintTransaction()
                .setMetadata(initialMetadataList)
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(supplyKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = tokenMintTransactionReceipt.serials;

            // update nfts without signing
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateNftsTransaction()
                    .setTokenId(tokenId)
                    .setSerials(nftSerials)
                    .setMetadata(updatedMetadata)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    @Test
    @DisplayName("Cannot update NFT metadata when metadata key is not set")
    void cannotUpdateNFTMetadataWhenMetadataKeyNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var supplyKey = PrivateKey.generateED25519();
            var metadataKey = PrivateKey.generateED25519();
            var nftCount = 4;
            var initialMetadataList = NftMetadataGenerator.generate(new byte[]{4, 2, 0}, nftCount);
            var updatedMetadata = new byte[]{6, 9};

            // create a token without a metadata key and check it
            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setSupplyKey(supplyKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var tokenInfo = new TokenInfoQuery()
                .setTokenId(tokenId)
                .execute(testEnv.client);

            assertThat(tokenInfo.metadataKey).isNull();

            // mint tokens
            var tokenMintTransactionReceipt = new TokenMintTransaction()
                .setMetadata(initialMetadataList)
                .setTokenId(tokenId)
                .freezeWith(testEnv.client)
                .sign(supplyKey)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var nftSerials = tokenMintTransactionReceipt.serials;

            // check NFTs' metadata can't be updated when a metadata key is not set
            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenUpdateNftsTransaction()
                    .setTokenId(tokenId)
                    .setSerials(nftSerials)
                    .setMetadata(updatedMetadata)
                    .freezeWith(testEnv.client)
                    .sign(metadataKey)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_SIGNATURE.toString());

        }
    }

    /**
     * Retrieves the metadata information for a given list of NFT serials associated with a token.
     *
     * @param client The Hedera client used for executing the query.
     * @param tokenId The ID of the token.
     * @param nftSerials The list of serial numbers of the NFTs.
     * @return A list of byte arrays representing the metadata information for the NFTs.
     */
    private List<byte[]> getMetadataList(Client client, TokenId tokenId, List<Long> nftSerials) {
        return nftSerials.stream()
            .map(serial -> new NftId(tokenId, serial))
            .flatMap(nftId -> {
                try {
                    return new TokenNftInfoQuery()
                        .setNftId(nftId)
                        .execute(client).stream();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            })
            .map(tokenNftInfo -> tokenNftInfo.metadata)
            .toList();
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TokenWipeIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TokenAssociateTransaction;
import com.hedera.hashgraph.sdk.TokenCreateTransaction;
import com.hedera.hashgraph.sdk.TokenGrantKycTransaction;
import com.hedera.hashgraph.sdk.TokenMintTransaction;
import com.hedera.hashgraph.sdk.TokenType;
import com.hedera.hashgraph.sdk.TokenWipeTransaction;
import com.hedera.hashgraph.sdk.TransferTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collections;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class TokenWipeIntegrationTest {
    @Test
    @DisplayName("Can wipe accounts balance")
    void canWipeAccountsBalance() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, accountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenWipeTransaction()
                .setTokenId(tokenId)
                .setAccountId(accountId)
                .setAmount(10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }


    @Test
    @DisplayName("Can wipe accounts NFTs")
    void canWipeAccountsNfts() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var serialsToTransfer = mintReceipt.serials.subList(0, 4);
            var transfer = new TransferTransaction();
            for (var serial : serialsToTransfer) {
                transfer.addNftTransfer(tokenId.nft(serial), testEnv.operatorId, accountId);
            }
            transfer.execute(testEnv.client).getReceipt(testEnv.client);

            new TokenWipeTransaction()
                .setTokenId(tokenId)
                .setAccountId(accountId)
                .setSerials(serialsToTransfer)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }


    @Test
    @DisplayName("Cannot wipe accounts NFTs if the account doesn't own them")
    void cannotWipeAccountsNftsIfNotOwned() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setTokenType(TokenType.NON_FUNGIBLE_UNIQUE)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            var mintReceipt = new TokenMintTransaction()
                .setTokenId(tokenId)
                .setMetadata(NftMetadataGenerator.generate((byte) 10))
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var serialsToTransfer = mintReceipt.serials.subList(0, 4);
            // don't transfer them

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TokenWipeTransaction()
                    .setTokenId(tokenId)
                    .setAccountId(accountId)
                    .setSerials(serialsToTransfer)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.ACCOUNT_DOES_NOT_OWN_WIPED_NFT.toString());

        }
    }

    @Test
    @DisplayName("Cannot wipe accounts balance when account ID is not set")
    void cannotWipeAccountsBalanceWhenAccountIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, accountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenWipeTransaction()
                    .setTokenId(tokenId)
                    .setAmount(10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_ACCOUNT_ID.toString());

        }
    }

    @Test
    @DisplayName("Cannot wipe accounts balance when token ID is not set")
    void cannotWipeAccountsBalanceWhenTokenIDIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, accountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                new TokenWipeTransaction()
                    .setAccountId(accountId)
                    .setAmount(10)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.INVALID_TOKEN_ID.toString());

        }
    }

    @Test
    @DisplayName("Can wipe accounts balance when amount is not set")
    void canWipeAccountsBalanceWhenAmountIsNotSet() throws Exception {
        try(var testEnv = new IntegrationTestEnv(1).useThrowawayAccount()){

            var key = PrivateKey.generateED25519();

            var response = new AccountCreateTransaction()
                .setKey(key)
                .setInitialBalance(new Hbar(1))
                .execute(testEnv.client);

            var accountId = Objects.requireNonNull(response.getReceipt(testEnv.client).accountId);

            var tokenId = Objects.requireNonNull(
                new TokenCreateTransaction()
                    .setTokenName("ffff")
                    .setTokenSymbol("F")
                    .setDecimals(3)
                    .setInitialSupply(1000000)
                    .setTreasuryAccountId(testEnv.operatorId)
                    .setAdminKey(testEnv.operatorKey)
                    .setFreezeKey(testEnv.operatorKey)
                    .setWipeKey(testEnv.operatorKey)
                    .setKycKey(testEnv.operatorKey)
                    .setSupplyKey(testEnv.operatorKey)
                    .setFreezeDefault(false)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client)
                    .tokenId
            );

            new TokenAssociateTransaction()
                .setAccountId(accountId)
                .setTokenIds(Collections.singletonList(tokenId))
                .freezeWith(testEnv.client)
                .sign(key)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TokenGrantKycTransaction()
                .setAccountId(accountId)
                .setTokenId(tokenId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            new TransferTransaction()
                .addTokenTransfer(tokenId, testEnv.operatorId, -10)
                .addTokenTransfer(tokenId, accountId, 10)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);


            var receipt = new TokenWipeTransaction()
                .setTokenId(tokenId)
                .setAccountId(accountId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            assertThat(receipt.status).isEqualTo(Status.SUCCESS);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TopicCreateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicDeleteTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicCreateIntegrationTest {
    @Test
    @DisplayName("Can create topic")
    void canCreateTopic() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can create topic with no field set")
    void canCreateTopicWithNoFieldsSet() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .execute(testEnv.client);
            assertThat(response.getReceipt(testEnv.client).topicId).isNotNull();

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TopicDeleteIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicDeleteTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class TopicDeleteIntegrationTest {
    @Test
    @DisplayName("Can delete topic")
    void canDeleteTopic() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Cannot delete immutable topic")
    void cannotDeleteImmutableTopic() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            assertThatExceptionOfType(ReceiptStatusException.class).isThrownBy(() -> {
                new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);
            }).withMessageContaining(Status.UNAUTHORIZED.toString());

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TopicInfoIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.MaxQueryPaymentExceededException;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicDeleteTransaction;
import com.hedera.hashgraph.sdk.TopicInfoQuery;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

public class TopicInfoIntegrationTest {

    @Test
    @DisplayName("Can query topic info")
    void canQueryTopicInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            var info = new TopicInfoQuery()
                .setTopicId(topicId)
                .execute(testEnv.client);

            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get cost for topic info query")
    void getCostQueryTopicInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            var infoQuery = new TopicInfoQuery()
                .setTopicId(topicId);

            var cost = infoQuery.getCost(testEnv.client);

                assertThat(cost).isNotNull();

            var info = infoQuery.execute(testEnv.client);

            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");

                new TopicDeleteTransaction()
                        .setTopicId(topicId)
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get cost for topic info query")
    void getCostBigMaxQueryTopicInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            var infoQuery = new TopicInfoQuery()
                .setTopicId(topicId)
                .setMaxQueryPayment(new Hbar(1000));

            var cost = infoQuery.getCost(testEnv.client);

            assertThat(cost).isNotNull();

            var info = infoQuery.execute(testEnv.client);

                assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");

                new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get cost for topic info query")
    void getCostSmallMaxQueryTopicInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            var infoQuery = new TopicInfoQuery()
                .setTopicId(topicId)
                .setMaxQueryPayment(Hbar.fromTinybars(1));

            assertThatExceptionOfType(MaxQueryPaymentExceededException.class).isThrownBy(() -> {
                infoQuery.execute(testEnv.client);
            });

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can get cost for topic info query")
    void getCostInsufficientTxFeeQueryTopicInfo() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            var infoQuery = new TopicInfoQuery()
                .setTopicId(topicId);

            var cost = infoQuery.getCost(testEnv.client);

            assertThat(cost).isNotNull();

            assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                infoQuery.setQueryPayment(Hbar.fromTinybars(1)).execute(testEnv.client);
            }).satisfies(error -> assertThat(error.status.toString()).isEqualTo("INSUFFICIENT_TX_FEE"));

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TopicMessageIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.*;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import java.time.Duration;
import java.time.Instant;

import java.nio.charset.StandardCharsets;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicMessageIntegrationTest {
    @Test
    @DisplayName("Can receive a topic message")
    void canReceiveATopicMessage() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            var info = new TopicInfoQuery()
                .setTopicId(topicId)
                .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(0);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            Thread.sleep(3000);

            var receivedMessage = new boolean[]{false};
            var start = Instant.now();

            var handle = new TopicMessageQuery()
                .setTopicId(topicId)
                .setStartTime(Instant.EPOCH)
                .subscribe(testEnv.client, (message) -> {
                    receivedMessage[0] = new String(message.contents, StandardCharsets.UTF_8).equals("Hello, from HCS!");
                });

            Thread.sleep(3000);

            new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage("Hello, from HCS!")
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            while (!receivedMessage[0]) {
                if (Duration.between(start, Instant.now()).compareTo(Duration.ofSeconds(60)) > 0) {
                    throw new Exception("TopicMessage was not received in 60 seconds or less");
                }

                Thread.sleep(2000);
            }

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can receive a large topic message")
    void canReceiveALargeTopicMessage() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            // Skip if using local node.
            // Note: this check should be removed once the local node is supporting multiple nodes.
            testEnv.assumeNotLocalNode();

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            Thread.sleep(5000);

            var info = new TopicInfoQuery()
                .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(0);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            var receivedMessage = new boolean[]{false};
            var start = Instant.now();

            var handle = new TopicMessageQuery()
                .setTopicId(topicId)
                .setStartTime(Instant.EPOCH)
                .subscribe(testEnv.client, (message) -> {
                    receivedMessage[0] = new String(message.contents, StandardCharsets.UTF_8).equals(Contents.BIG_CONTENTS);
                });

            new TopicMessageSubmitTransaction()
                .setTopicId(topicId)
                .setMessage(Contents.BIG_CONTENTS)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            while (!receivedMessage[0]) {
                if (Duration.between(start, Instant.now()).compareTo(Duration.ofSeconds(60)) > 0) {
                    throw new Exception("TopicMessage was not received in 60 seconds or less");
                }

                Thread.sleep(1000);
            }

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TopicMessageSubmitIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicDeleteTransaction;
import com.hedera.hashgraph.sdk.TopicInfoQuery;
import com.hedera.hashgraph.sdk.TopicMessageSubmitTransaction;
import com.hedera.hashgraph.sdk.Transaction;
import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.assertj.core.api.Assertions.assertThatNoException;

public class TopicMessageSubmitIntegrationTest {
    @Test
    @DisplayName("Can submit a topic message")
    void canSubmitATopicMessage() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setTopicMemo("[e2e::TopicCreateTransaction]")
                    .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            @Var var info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(0);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            new TopicMessageSubmitTransaction()
                    .setTopicId(topicId)
                    .setMessage("Hello, from HCS!")
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(1);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    @Test
    @DisplayName("Can submit a large topic message")
    void canSubmitALargeTopicMessage() {
        // Skip if using PreviewNet
        Assumptions.assumeTrue(!System.getProperty("HEDERA_NETWORK").equals("previewnet"));

        assertThatNoException().isThrownBy(() -> {
            try (var testEnv = new IntegrationTestEnv(1)) {

                var response = new TopicCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setTopicMemo("[e2e::TopicCreateTransaction]")
                        .execute(testEnv.client);

                var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

                Thread.sleep(5000);

                @Var var info = new TopicInfoQuery()
                        .setTopicId(topicId)
                        .execute(testEnv.client);

                assertThat(info.topicId).isEqualTo(topicId);
                assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
                assertThat(info.sequenceNumber).isEqualTo(0);
                assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

                var responses = new TopicMessageSubmitTransaction()
                        .setTopicId(topicId)
                        .setMaxChunks(15)
                        .setMessage(Contents.BIG_CONTENTS)
                        .executeAll(testEnv.client);

                for (var resp : responses) {
                    resp.getReceipt(testEnv.client);
                }

                info = new TopicInfoQuery()
                        .setTopicId(topicId)
                        .execute(testEnv.client);

                assertThat(info.topicId).isEqualTo(topicId);
                assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
                assertThat(info.sequenceNumber).isEqualTo(14);
                assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

                new TopicDeleteTransaction()
                        .setTopicId(topicId)
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client);

            }
        });
    }

    @Test
    @DisplayName("Cannot submit message when topic ID is not set")
    void cannotSubmitMessageWhenTopicIDIsNotSet() {
        // Skip if using PreviewNet
        Assumptions.assumeTrue(!System.getProperty("HEDERA_NETWORK").equals("previewnet"));

        assertThatNoException().isThrownBy(() -> {
            try (var testEnv = new IntegrationTestEnv(1)) {

                var response = new TopicCreateTransaction()
                        .setAdminKey(testEnv.operatorKey)
                        .setTopicMemo("[e2e::TopicCreateTransaction]")
                        .execute(testEnv.client);

                var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

                assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                    new TopicMessageSubmitTransaction()
                            .setMessage(Contents.BIG_CONTENTS)
                            .setMaxChunks(15)
                            .execute(testEnv.client)
                            .getReceipt(testEnv.client);
                }).withMessageContaining(Status.INVALID_TOPIC_ID.toString());

                new TopicDeleteTransaction()
                        .setTopicId(topicId)
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client);

            }
        });
    }

    @Test
    @DisplayName("Cannot submit message when message is not set")
    void cannotSubmitMessageWhenMessageIsNotSet() {
        // Skip if using PreviewNet
        Assumptions.assumeTrue(!System.getProperty("HEDERA_NETWORK").equals("previewnet"));

        assertThatNoException().isThrownBy(() -> {
            try (var testEnv = new IntegrationTestEnv(1)) {

                var response = new TopicCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setTopicMemo("[e2e::TopicCreateTransaction]")
                    .execute(testEnv.client);

                var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

                assertThatExceptionOfType(PrecheckStatusException.class).isThrownBy(() -> {
                    new TopicMessageSubmitTransaction()
                        .setTopicId(topicId)
                        .execute(testEnv.client)
                        .getReceipt(testEnv.client);
                }).withMessageContaining(Status.INVALID_TOPIC_MESSAGE.toString());

                new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            }
        });
    }

    @Test
    @DisplayName("Hex Decode Regression Test")
    @SuppressWarnings("UnusedVariable")
    void decodeHexRegressionTest() throws Exception {
        String binaryHex = "2ac2010a580a130a0b08d38f8f880610a09be91512041899e11c120218041880c2d72f22020878da01330a0418a5a1201210303030303030313632373633373731351a190a130a0b08d38f8f880610a09be91512041899e11c1001180112660a640a20603edaec5d1c974c92cb5bee7b011310c3b84b13dc048424cd6ef146d6a0d4a41a40b6a08f310ee29923e5868aac074468b2bde05da95a806e2f4a4f452177f129ca0abae7831e595b5beaa1c947e2cb71201642bab33fece5184b04547afc40850a";
        byte[] transactionBytes = Hex.decode(binaryHex);

        var transaction = Objects.requireNonNull(Transaction.fromBytes(transactionBytes));

        String idString = Objects.requireNonNull(transaction.getTransactionId()).toString();
        String transactionString = transaction.toString();
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TopicUpdateIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2021 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicDeleteTransaction;
import com.hedera.hashgraph.sdk.TopicInfoQuery;
import com.hedera.hashgraph.sdk.TopicUpdateTransaction;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;

public class TopicUpdateIntegrationTest {
    @Test
    @DisplayName("Can update topic")
    void canUpdateTopic() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                .setAdminKey(testEnv.operatorKey)
                .setAutoRenewAccountId(testEnv.operatorId)
                .setTopicMemo("[e2e::TopicCreateTransaction]")
                .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            new TopicUpdateTransaction()
                .clearAutoRenewAccountId()
                .setTopicMemo("hello")
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

            var topicInfo = new TopicInfoQuery()
                .setTopicId(topicId)
                .execute(testEnv.client);

            assertThat(topicInfo.topicMemo).isEqualTo("hello");
            assertThat(topicInfo.autoRenewAccountId).isNull();

            new TopicDeleteTransaction()
                .setTopicId(topicId)
                .execute(testEnv.client)
                .getReceipt(testEnv.client);

        }
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TransactionIntegrationTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.google.errorprone.annotations.Var;
import com.google.protobuf.ByteString;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.FileAppendTransaction;
import com.hedera.hashgraph.sdk.FileContentsQuery;
import com.hedera.hashgraph.sdk.FileCreateTransaction;
import com.hedera.hashgraph.sdk.FileDeleteTransaction;
import com.hedera.hashgraph.sdk.FileInfoQuery;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.TopicCreateTransaction;
import com.hedera.hashgraph.sdk.TopicDeleteTransaction;
import com.hedera.hashgraph.sdk.TopicInfoQuery;
import com.hedera.hashgraph.sdk.TopicMessageSubmitTransaction;
import com.hedera.hashgraph.sdk.Transaction;
import com.hedera.hashgraph.sdk.TransactionId;
import com.hedera.hashgraph.sdk.TransferTransaction;
import com.hedera.hashgraph.sdk.proto.AccountAmount;
import com.hedera.hashgraph.sdk.proto.AccountID;
import com.hedera.hashgraph.sdk.proto.CryptoTransferTransactionBody;
import com.hedera.hashgraph.sdk.proto.Duration;
import com.hedera.hashgraph.sdk.proto.SignatureMap;
import com.hedera.hashgraph.sdk.proto.SignaturePair;
import com.hedera.hashgraph.sdk.proto.SignedTransaction;
import com.hedera.hashgraph.sdk.proto.Timestamp;
import com.hedera.hashgraph.sdk.proto.TransactionBody;
import com.hedera.hashgraph.sdk.proto.TransactionID;
import com.hedera.hashgraph.sdk.proto.TransactionList;
import com.hedera.hashgraph.sdk.proto.TransferList;
import java.util.Objects;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Arrays;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
import static org.assertj.core.api.Assertions.assertThatNoException;

public class TransactionIntegrationTest {

    @Test
    @DisplayName("transaction hash in transaction record is equal to the derived transaction hash")
    void transactionHashInTransactionRecordIsEqualToTheDerivedTransactionHash() throws Exception {

        try (var testEnv = new IntegrationTestEnv(1)) {
            var key = PrivateKey.generateED25519();

            var transaction = new AccountCreateTransaction()
                .setKey(key)
                .freezeWith(testEnv.client)
                .signWithOperator(testEnv.client);

            var expectedHash = transaction.getTransactionHashPerNode();

            var response = transaction.execute(testEnv.client);

            var record = response.getRecord(testEnv.client);

            assertThat(expectedHash.get(response.nodeId)).containsExactly(record.transactionHash.toByteArray());

            var accountId = record.receipt.accountId;
            assertThat(accountId).isNotNull();

            var transactionId = transaction.getTransactionId();
            assertThat(transactionId.getReceipt(testEnv.client)).isNotNull();
            assertThat(transactionId.getReceiptAsync(testEnv.client).get()).isNotNull();
            assertThat(transactionId.getRecord(testEnv.client)).isNotNull();
            assertThat(transactionId.getRecordAsync(testEnv.client).get()).isNotNull();
        }

    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete transaction can be serialized into bytes, deserialized and be equal to the original one")
    void canSerializeDeserializeCompareFields() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setKey(publicKey)
                    .setInitialBalance(new Hbar(1L));

            var expectedNodeAccountIds = accountCreateTransaction.getNodeAccountIds();
            var expectedBalance = new Hbar(1L);

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            assertThat(expectedNodeAccountIds).isEqualTo(accountCreateTransactionDeserialized.getNodeAccountIds());
            assertThat(expectedBalance).isEqualTo(accountCreateTransactionDeserialized.getInitialBalance());
            assertThatExceptionOfType(IllegalStateException.class).isThrownBy(
                    accountCreateTransactionDeserialized::getTransactionId);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete transaction with node account ids can be serialized into bytes, deserialized and be equal to the original one")
    void canSerializeWithNodeAccountIdsDeserializeCompareFields() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var nodeAccountIds = testEnv.client.getNetwork().values().stream().toList();

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setNodeAccountIds(nodeAccountIds)
                    .setKey(publicKey)
                    .setInitialBalance(new Hbar(1L));

            var expectedNodeAccountIds = accountCreateTransaction.getNodeAccountIds();
            var expectedBalance = new Hbar(1L);

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            assertThat(expectedNodeAccountIds.size())
                    .isEqualTo(accountCreateTransactionDeserialized.getNodeAccountIds().size());
            assertThat(expectedBalance).isEqualTo(accountCreateTransactionDeserialized.getInitialBalance());
            assertThatExceptionOfType(IllegalStateException.class).isThrownBy(
                    accountCreateTransactionDeserialized::getTransactionId);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete transaction can be serialized into bytes, deserialized and executed")
    void canSerializeDeserializeAndExecuteIncompleteTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setKey(publicKey)
                    .setInitialBalance(new Hbar(1L));

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(
                            transactionBytesSerialized);

            var txReceipt = accountCreateTransactionDeserialized
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            new AccountDeleteTransaction()
                    .setAccountId(txReceipt.accountId)
                    .setTransferAccountId(testEnv.client.getOperatorAccountId())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete transaction with node account ids can be serialized into bytes, deserialized and executed")
    void canSerializeDeserializeAndExecuteIncompleteTransactionWithNodeAccountIds() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var nodeAccountIds = testEnv.client.getNetwork().values().stream().toList();

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setNodeAccountIds(nodeAccountIds)
                    .setKey(publicKey)
                    .setInitialBalance(new Hbar(1L));

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(
                            transactionBytesSerialized);

            var txReceipt = accountCreateTransactionDeserialized
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            new AccountDeleteTransaction()
                    .setAccountId(txReceipt.accountId)
                    .setTransferAccountId(testEnv.client.getOperatorAccountId())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete transaction can be serialized into bytes, deserialized, edited and executed")
    void canSerializeDeserializeEditExecuteCompareFields() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setKey(publicKey);

            var expectedBalance = new Hbar(1L);
            var nodeAccountIds = testEnv.client.getNetwork().values().stream().toList();

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var txReceipt = accountCreateTransactionDeserialized
                    .setInitialBalance(new Hbar(1L))
                    .setNodeAccountIds(nodeAccountIds)
                    .setTransactionId(TransactionId.generate(testEnv.client.getOperatorAccountId()))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            assertThat(expectedBalance).isEqualTo(accountCreateTransactionDeserialized.getInitialBalance());

            new AccountDeleteTransaction()
                    .setAccountId(txReceipt.accountId)
                    .setTransferAccountId(testEnv.client.getOperatorAccountId())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete transaction with node account ids can be serialized into bytes, deserialized, edited and executed")
    void canSerializeDeserializeEditExecuteCompareFieldsIncompleteTransactionWithNodeAccountIds() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var nodeAccountIds = testEnv.client.getNetwork().values().stream().toList();

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setNodeAccountIds(nodeAccountIds)
                    .setKey(publicKey);

            var expectedBalance = new Hbar(1L);

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var txReceipt = accountCreateTransactionDeserialized
                    .setInitialBalance(new Hbar(1L))
                    .setTransactionId(TransactionId.generate(testEnv.client.getOperatorAccountId()))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            assertThat(expectedBalance).isEqualTo(accountCreateTransactionDeserialized.getInitialBalance());

            new AccountDeleteTransaction()
                    .setAccountId(txReceipt.accountId)
                    .setTransferAccountId(testEnv.client.getOperatorAccountId())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("complete frozen and signed transaction can be serialized into bytes, deserialized (x2) and executed")
    void canFreezeSignSerializeDeserializeReserializeAndExecute() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var adminKey = PrivateKey.generateECDSA();
            var publicKey = adminKey.getPublicKey();

            var evmAddress = publicKey.toEvmAddress();
            var initialBalance = new Hbar(1L);
            var autoRenewPeriod = java.time.Duration.ofSeconds(2592000);
            var memo = "test account memo";
            var maxAutomaticTokenAssociations = 4;

            var accountCreateTransaction = new AccountCreateTransaction()
                    .setKey(publicKey)
                    .setInitialBalance(initialBalance)
                    .setReceiverSignatureRequired(true)
                    .setAutoRenewPeriod(autoRenewPeriod)
                    .setAccountMemo(memo)
                    .setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociations)
                    .setDeclineStakingReward(true)
                    .setAlias(evmAddress)
                    .freezeWith(testEnv.client)
                    .sign(adminKey);

            var transactionBytesSerialized = accountCreateTransaction.toBytes();
            AccountCreateTransaction accountCreateTransactionDeserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var transactionBytesReserialized = accountCreateTransactionDeserialized.toBytes();
            assertThat(transactionBytesSerialized).isEqualTo(transactionBytesReserialized);

            AccountCreateTransaction accountCreateTransactionReserialized = (AccountCreateTransaction) Transaction
                    .fromBytes(transactionBytesReserialized);

            var txResponse = accountCreateTransactionReserialized.execute(testEnv.client);

            var accountId = txResponse.getReceipt(testEnv.client).accountId;

            new AccountDeleteTransaction()
                    .setAccountId(accountId)
                    .setTransferAccountId(testEnv.client.getOperatorAccountId())
                    .freezeWith(testEnv.client)
                    .sign(adminKey)
                    .execute(testEnv.client);

        }
    }

    @Test
    @DisplayName("complete frozen transaction can be serialized into bytes, deserialized, signature added and executed")
    void canFreezeSerializeDeserializeAddSignatureAndExecute() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var key = PrivateKey.generateED25519();

            var transaction = new AccountCreateTransaction()
                    .setKey(key)
                    .freezeWith(testEnv.client)
                    .signWithOperator(testEnv.client);

            var expectedHash = transaction.getTransactionHashPerNode();

            @Var
            var response = transaction.execute(testEnv.client);

            var record = response.getRecord(testEnv.client);

            assertThat(expectedHash.get(response.nodeId)).containsExactly(record.transactionHash.toByteArray());

            var accountId = record.receipt.accountId;
            assertThat(accountId).isNotNull();

            var deleteTransaction = new AccountDeleteTransaction()
                    .setAccountId(accountId)
                    .setTransferAccountId(testEnv.operatorId)
                    .freezeWith(testEnv.client);

            var updateBytes = deleteTransaction.toBytes();

            var sig1 = key.signTransaction(deleteTransaction);

            var deleteTransaction2 = Transaction.fromBytes(updateBytes);

            deleteTransaction2
                    .addSignature(key.getPublicKey(), sig1)
                    .execute(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("file append chunked transaction can be frozen, signed, serialized into bytes, deserialized and be equal to the original one")
    void canFreezeSignSerializeDeserializeAndCompareFileAppendChunkedTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var privateKey = PrivateKey.generateED25519();

            var response = new FileCreateTransaction()
                    .setKeys(testEnv.operatorKey)
                    .setContents("[e2e::FileCreateTransaction]")
                    .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            Thread.sleep(5000);

            @Var
            var info = new FileInfoQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            var fileAppendTransaction = new FileAppendTransaction()
                    .setFileId(fileId)
                    .setContents(Contents.BIG_CONTENTS)
                    .freezeWith(testEnv.client)
                    .sign(privateKey);

            var transactionBytesSerialized = fileAppendTransaction.toBytes();
            FileAppendTransaction fileAppendTransactionDeserialized = (FileAppendTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var transactionBytesReserialized = fileAppendTransactionDeserialized.toBytes();
            assertThat(transactionBytesSerialized).isEqualTo(transactionBytesReserialized);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete file append chunked transaction can be serialized into bytes, deserialized, edited and executed")
    void canSerializeDeserializeExecuteFileAppendChunkedTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new FileCreateTransaction()
                    .setKeys(testEnv.operatorKey)
                    .setContents("[e2e::FileCreateTransaction]")
                    .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            Thread.sleep(5000);

            @Var
            var info = new FileInfoQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            var fileAppendTransaction = new FileAppendTransaction()
                    .setFileId(fileId)
                    .setContents(Contents.BIG_CONTENTS);

            var transactionBytesSerialized = fileAppendTransaction.toBytes();
            FileAppendTransaction fileAppendTransactionDeserialized = (FileAppendTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            fileAppendTransactionDeserialized
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            var contents = new FileContentsQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(contents.toStringUtf8()).isEqualTo("[e2e::FileCreateTransaction]" + Contents.BIG_CONTENTS);

            info = new FileInfoQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(13522);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                    .setFileId(fileId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete file append chunked transaction with node account ids can be serialized into bytes, deserialized, edited and executed")
    void canSerializeDeserializeExecuteIncompleteFileAppendChunkedTransactionWithNodeAccountIds() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var nodeAccountIds = testEnv.client.getNetwork().values().stream().toList();

            var response = new FileCreateTransaction()
                    .setKeys(testEnv.operatorKey)
                    .setContents("[e2e::FileCreateTransaction]")
                    .execute(testEnv.client);

            var fileId = Objects.requireNonNull(response.getReceipt(testEnv.client).fileId);

            Thread.sleep(5000);

            @Var
            var info = new FileInfoQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(28);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            var fileAppendTransaction = new FileAppendTransaction()
                    .setNodeAccountIds(nodeAccountIds)
                    .setFileId(fileId)
                    .setContents(Contents.BIG_CONTENTS);

            var transactionBytesSerialized = fileAppendTransaction.toBytes();
            FileAppendTransaction fileAppendTransactionDeserialized = (FileAppendTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            fileAppendTransactionDeserialized
                    .setTransactionId(TransactionId.generate(testEnv.client.getOperatorAccountId()))
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

            var contents = new FileContentsQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(contents.toStringUtf8()).isEqualTo("[e2e::FileCreateTransaction]" + Contents.BIG_CONTENTS);

            info = new FileInfoQuery()
                    .setFileId(fileId)
                    .execute(testEnv.client);

            assertThat(info.fileId).isEqualTo(fileId);
            assertThat(info.size).isEqualTo(13522);
            assertThat(info.isDeleted).isFalse();
            assertThat(info.keys).isNotNull();
            assertThat(info.keys.getThreshold()).isNull();
            assertThat(info.keys).isEqualTo(KeyList.of(testEnv.operatorKey));

            new FileDeleteTransaction()
                    .setFileId(fileId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("topic message submit chunked transaction can be frozen, signed, serialized into bytes, deserialized and be equal to the original one")
    void canFreezeSignSerializeDeserializeAndCompareTopicMessageSubmitChunkedTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var privateKey = PrivateKey.generateED25519();

            var response = new TopicCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setTopicMemo("[e2e::TopicCreateTransaction]")
                    .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            Thread.sleep(5000);

            @Var
            var info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(0);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            var topicMessageSubmitTransaction = new TopicMessageSubmitTransaction()
                    .setTopicId(topicId)
                    .setMaxChunks(15)
                    .setMessage(Contents.BIG_CONTENTS)
                    .freezeWith(testEnv.client)
                    .sign(privateKey);

            var transactionBytesSerialized = topicMessageSubmitTransaction.toBytes();
            TopicMessageSubmitTransaction fileAppendTransactionDeserialized = (TopicMessageSubmitTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var transactionBytesReserialized = fileAppendTransactionDeserialized.toBytes();
            assertThat(transactionBytesSerialized).isEqualTo(transactionBytesReserialized);

            new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete topic message submit chunked transaction can be serialized into bytes, deserialized, edited and executed")
    void canSerializeDeserializeExecuteIncompleteTopicMessageSubmitChunkedTransaction() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var response = new TopicCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setTopicMemo("[e2e::TopicCreateTransaction]")
                    .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            Thread.sleep(5000);

            @Var
            var info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(0);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            var topicMessageSubmitTransaction = new TopicMessageSubmitTransaction()
                    .setTopicId(topicId)
                    .setMaxChunks(15)
                    .setMessage(Contents.BIG_CONTENTS);

            var transactionBytesSerialized = topicMessageSubmitTransaction.toBytes();
            TopicMessageSubmitTransaction topicMessageSubmitTransactionDeserialized = (TopicMessageSubmitTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var responses = topicMessageSubmitTransactionDeserialized.executeAll(testEnv.client);

            for (var resp : responses) {
                resp.getReceipt(testEnv.client);
            }

            info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(14);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    /**
     * @notice E2E-HIP-745
     * @url https://hips.hedera.com/hip/hip-745
     */
    @Test
    @DisplayName("incomplete topic message submit chunked transaction with node account ids can be serialized into bytes, deserialized, edited and executed")
    void canSerializeDeserializeExecuteIncompleteTopicMessageSubmitChunkedTransactionWithNodeAccountIds()
            throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var nodeAccountIds = testEnv.client.getNetwork().values().stream().toList();

            var response = new TopicCreateTransaction()
                    .setAdminKey(testEnv.operatorKey)
                    .setTopicMemo("[e2e::TopicCreateTransaction]")
                    .execute(testEnv.client);

            var topicId = Objects.requireNonNull(response.getReceipt(testEnv.client).topicId);

            Thread.sleep(5000);

            @Var
            var info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(0);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            var topicMessageSubmitTransaction = new TopicMessageSubmitTransaction()
                    .setNodeAccountIds(nodeAccountIds)
                    .setTopicId(topicId)
                    .setMaxChunks(15)
                    .setMessage(Contents.BIG_CONTENTS);

            var transactionBytesSerialized = topicMessageSubmitTransaction.toBytes();
            TopicMessageSubmitTransaction topicMessageSubmitTransactionDeserialized = (TopicMessageSubmitTransaction) Transaction
                    .fromBytes(transactionBytesSerialized);

            var responses = topicMessageSubmitTransactionDeserialized.executeAll(testEnv.client);

            for (var resp : responses) {
                resp.getReceipt(testEnv.client);
            }

            info = new TopicInfoQuery()
                    .setTopicId(topicId)
                    .execute(testEnv.client);

            assertThat(info.topicId).isEqualTo(topicId);
            assertThat(info.topicMemo).isEqualTo("[e2e::TopicCreateTransaction]");
            assertThat(info.sequenceNumber).isEqualTo(14);
            assertThat(info.adminKey).isEqualTo(testEnv.operatorKey);

            new TopicDeleteTransaction()
                    .setTopicId(topicId)
                    .execute(testEnv.client)
                    .getReceipt(testEnv.client);

        }
    }

    // TODO: this test has a bunch of things hard-coded into it, which is kinda
    // dumb, but it's a good idea for a test.
    // Any way to fix it and bring it back?
    @Disabled
    @Test
    @DisplayName("transaction can be serialized into bytes, deserialized, signature added and executed")
    void transactionFromToBytes2() {
        assertThatNoException().isThrownBy(() -> {
            var id = TransactionId.generate(new AccountId(542348));

            var transactionBodyBuilder = TransactionBody.newBuilder();
            transactionBodyBuilder
                    .setTransactionID(TransactionID.newBuilder()
                            .setTransactionValidStart(Timestamp.newBuilder()
                                    .setNanos(id.validStart.getNano())
                                    .setSeconds(id.validStart.getEpochSecond())
                                    .build())
                            .setAccountID(AccountID.newBuilder()
                                    .setAccountNum(542348)
                                    .setRealmNum(0)
                                    .setShardNum(0)
                                    .build())
                            .build())
                    .setNodeAccountID(AccountID.newBuilder()
                            .setAccountNum(3)
                            .setRealmNum(0)
                            .setShardNum(0)
                            .build())
                    .setTransactionFee(200_000_000)
                    .setTransactionValidDuration(
                            Duration.newBuilder()
                                    .setSeconds(120)
                                    .build())
                    .setGenerateRecord(false)
                    .setMemo("")
                    .setCryptoTransfer(
                            CryptoTransferTransactionBody.newBuilder()
                                    .setTransfers(TransferList.newBuilder()
                                            .addAccountAmounts(AccountAmount.newBuilder()
                                                    .setAccountID(AccountID.newBuilder()
                                                            .setAccountNum(47439)
                                                            .setRealmNum(0)
                                                            .setShardNum(0)
                                                            .build())
                                                    .setAmount(10)
                                                    .build())
                                            .addAccountAmounts(AccountAmount.newBuilder()
                                                    .setAccountID(AccountID.newBuilder()
                                                            .setAccountNum(542348)
                                                            .setRealmNum(0)
                                                            .setShardNum(0)
                                                            .build())
                                                    .setAmount(-10)
                                                    .build())
                                            .build())
                                    .build());
            var bodyBytes = transactionBodyBuilder.build().toByteString();

            var key1 = PrivateKey.fromString(
                    "302e020100300506032b6570042204203e7fda6dde63c3cdb3cb5ecf5264324c5faad7c9847b6db093c088838b35a110");
            var key2 = PrivateKey.fromString(
                    "302e020100300506032b65700422042032d3d5a32e9d06776976b39c09a31fbda4a4a0208223da761c26a2ae560c1755");
            var key3 = PrivateKey.fromString(
                    "302e020100300506032b657004220420195a919056d1d698f632c228dbf248bbbc3955adf8a80347032076832b8299f9");
            var key4 = PrivateKey.fromString(
                    "302e020100300506032b657004220420b9962f17f94ffce73a23649718a11638cac4b47095a7a6520e88c7563865be62");
            var key5 = PrivateKey.fromString(
                    "302e020100300506032b657004220420fef68591819080cd9d48b0cbaa10f65f919752abb50ffb3e7411ac66ab22692e");

            var publicKey1 = key1.getPublicKey();
            var publicKey2 = key2.getPublicKey();
            var publicKey3 = key3.getPublicKey();
            var publicKey4 = key4.getPublicKey();
            var publicKey5 = key5.getPublicKey();

            var signature1 = key1.sign(bodyBytes.toByteArray());
            var signature2 = key2.sign(bodyBytes.toByteArray());
            var signature3 = key3.sign(bodyBytes.toByteArray());
            var signature4 = key4.sign(bodyBytes.toByteArray());
            var signature5 = key5.sign(bodyBytes.toByteArray());

            var signedBuilder = SignedTransaction.newBuilder();
            signedBuilder
                    .setBodyBytes(bodyBytes)
                    .setSigMap(SignatureMap.newBuilder()
                            .addSigPair(SignaturePair.newBuilder()
                                    .setEd25519(ByteString.copyFrom(signature1))
                                    .setPubKeyPrefix(ByteString.copyFrom(publicKey1.toBytes()))
                                    .build())
                            .addSigPair(SignaturePair.newBuilder()
                                    .setEd25519(ByteString.copyFrom(signature2))
                                    .setPubKeyPrefix(ByteString.copyFrom(publicKey2.toBytes()))
                                    .build())
                            .addSigPair(SignaturePair.newBuilder()
                                    .setEd25519(ByteString.copyFrom(signature3))
                                    .setPubKeyPrefix(ByteString.copyFrom(publicKey3.toBytes()))
                                    .build())
                            .addSigPair(SignaturePair.newBuilder()
                                    .setEd25519(ByteString.copyFrom(signature4))
                                    .setPubKeyPrefix(ByteString.copyFrom(publicKey4.toBytes()))
                                    .build())
                            .addSigPair(SignaturePair.newBuilder()
                                    .setEd25519(ByteString.copyFrom(signature5))
                                    .setPubKeyPrefix(ByteString.copyFrom(publicKey5.toBytes()))
                                    .build()));
            @Var
            var byts = signedBuilder.build().toByteString();

            byts = TransactionList.newBuilder()
                    .addTransactionList(com.hedera.hashgraph.sdk.proto.Transaction.newBuilder()
                            .setSignedTransactionBytes(byts)
                            .build())
                    .build().toByteString();

            var tx = (TransferTransaction) Transaction.fromBytes(byts.toByteArray());

            try (var testEnv = new IntegrationTestEnv(1)) {

                assertThat(tx.getHbarTransfers().get(new AccountId(542348)).toTinybars()).isEqualTo(-10);
                assertThat(tx.getHbarTransfers().get(new AccountId(47439)).toTinybars()).isEqualTo(10);

                assertThat(tx.getNodeAccountIds()).isNotNull();
                assertThat(tx.getNodeAccountIds().size()).isEqualTo(1);
                assertThat(tx.getNodeAccountIds().get(0)).isEqualTo(new AccountId(3));

                var signatures = tx.getSignatures();
                assertThat(Arrays.toString(signatures.get(new AccountId(3)).get(publicKey1)))
                        .isEqualTo(Arrays.toString(signature1));
                assertThat(Arrays.toString(signatures.get(new AccountId(3)).get(publicKey2)))
                        .isEqualTo(Arrays.toString(signature2));
                assertThat(Arrays.toString(signatures.get(new AccountId(3)).get(publicKey3)))
                        .isEqualTo(Arrays.toString(signature3));
                assertThat(Arrays.toString(signatures.get(new AccountId(3)).get(publicKey4)))
                        .isEqualTo(Arrays.toString(signature4));
                assertThat(Arrays.toString(signatures.get(new AccountId(3)).get(publicKey5)))
                        .isEqualTo(Arrays.toString(signature5));

                var resp = tx.execute(testEnv.client);

                resp.getReceipt(testEnv.client);

            }
        });
    }
}
// Filename: sdk/src/testIntegration/java/com/hedera/hashgraph/sdk/test/integration/TransactionResponseTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2020 - 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.sdk.test.integration;

import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.PrivateKey;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class TransactionResponseTest {
    @Test
    @DisplayName("transaction hash in transaction record is equal to the transaction response transaction hash")
    void transactionHashInTransactionRecordIsEqualToTheTransactionResponseTransactionHash() throws Exception {
        try (var testEnv = new IntegrationTestEnv(1)) {

            var key = PrivateKey.generateED25519();

            var transaction = new AccountCreateTransaction()
                .setKey(key)
                .execute(testEnv.client);

            var record = transaction.getRecord(testEnv.client);

            assertThat(record.transactionHash.toByteArray()).containsExactly(transaction.transactionHash);

            var accountId = record.receipt.accountId;
            assertThat(accountId).isNotNull();

        }
    }
}

// Filename: sdk/src/testIntegration/java/module-info.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

open module com.hedera.hashgraph.sdk.test.integration {
    requires com.hedera.hashgraph.sdk;
    requires headlong;
    requires org.assertj.core;
    requires org.bouncycastle.provider;
    requires org.junit.jupiter.api;

    requires static com.google.errorprone.annotations;
    requires static java.annotation;
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/TckServer.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TckServer {
    public static void main(String[] args) {
        SpringApplication.run(TckServer.class, args);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/annotation/JSONRPC2Controller.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * Marks classes as HTTP handlers.
 * In the context of this application these handlers
 * should support the JSON-RPC spec
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Controller
@ResponseBody
public @interface JSONRPC2Controller {}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/annotation/JSONRPC2Method.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marks methods as JSON-RPC methods.
 * Methods marked with this annotation will be registered
 * as handlers for JSON-RPC requests with the specified method name.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface JSONRPC2Method {
    /**
     * Specifies the name of the JSON-RPC method.
     * the params need to be of instance JSONRPC2Param because if not - will blow up at runtime
     * @return The name of the JSON-RPC method.
     */
    String value();
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/annotation/JSONRPC2Service.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.stereotype.Component;

/**
 * Marks classes as JSON-RPC services.
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface JSONRPC2Service {}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/config/BeanConfig.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.config;

import com.thetransactioncompany.jsonrpc2.server.Dispatcher;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BeanConfig {
    @Bean
    public Dispatcher dispatcher() {
        return new Dispatcher();
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/config/WebConfig.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.config;

import com.hedera.hashgraph.tck.controller.JRPCInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new JRPCInterceptor());
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/controller/JRPCController.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.controller;

import static com.hedera.hashgraph.tck.util.JSONRPC2ServiceScanner.registerServices;

import com.hedera.hashgraph.tck.annotation.JSONRPC2Controller;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.server.Dispatcher;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.web.bind.annotation.PostMapping;

@JSONRPC2Controller
public class JRPCController {
    private final Logger logger = LoggerFactory.getLogger(JRPCController.class);
    private final Dispatcher dispatcher;

    public JRPCController(final Dispatcher dispatcher, final ApplicationContext applicationContext) {
        this.dispatcher = dispatcher;
        registerServices(dispatcher, applicationContext);
    }

    /**
     * Endpoint to handle all incoming JSON-RPC requests
     */
    @PostMapping("/")
    public String handleJSONRPC2Request(final HttpServletRequest request) {
        var req = (JSONRPC2Request) request.getAttribute("jsonrpcRequest");
        var resp = dispatcher.process(req, null);

        if (resp.getError() != null) {
            String errorMessage = String.format(
                    "Error occurred processing JSON-RPC request: %s, Response error: %s",
                    req.toJSONString(), resp.getError().toString());
            logger.info(errorMessage);
        }

        return resp.toJSONString();
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/controller/JRPCInterceptor.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.controller;

import com.thetransactioncompany.jsonrpc2.JSONRPC2ParseException;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.IOException;
import org.springframework.web.servlet.HandlerInterceptor;

/**
 * Interceptor class to map HttpServletRequest body to {@link JSONRPC2Request}
 * before the request reaches the controller
 */
public class JRPCInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(final HttpServletRequest request, final HttpServletResponse response, final Object handler)
            throws Exception {
        // Map HTTP Servlet Request to JSON-RPC Request
        var jsonrpcRequest = mapToJSONRPC2Request(request);

        // Store the JSON-RPC request in request attribute for further processing
        request.setAttribute("jsonrpcRequest", jsonrpcRequest);

        // Continue processing the request
        return true;
    }

    JSONRPC2Request mapToJSONRPC2Request(final HttpServletRequest httpRequest)
            throws IOException, JSONRPC2ParseException {
        // Read the JSON-RPC request from the HTTP request body
        BufferedReader reader = httpRequest.getReader();
        StringBuilder requestBody = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            requestBody.append(line);
        }
        reader.close();

        // Parse the JSON-RPC request
        return JSONRPC2Request.parse(requestBody.toString());
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/exception/InvalidJSONRPC2ParamsException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.exception;

/**
 * Thrown when the server cannot parse the given parameters.
 * This error should be thrown from the param parser
 */
public class InvalidJSONRPC2ParamsException extends Exception {

    public InvalidJSONRPC2ParamsException() {
        super();
    }

    public InvalidJSONRPC2ParamsException(String message) {
        super(message);
    }

    public InvalidJSONRPC2ParamsException(String message, Throwable cause) {
        super(message, cause);
    }

    public InvalidJSONRPC2ParamsException(Throwable cause) {
        super(cause);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/exception/InvalidJSONRPC2RequestException.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.exception;

/**
 * Thrown when the server cannot process the request
 */
public class InvalidJSONRPC2RequestException extends Exception {

    public InvalidJSONRPC2RequestException(String message) {
        super(message);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/AbstractJSONRPC2Service.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods;

import static com.hedera.hashgraph.tck.methods.JSONRPC2Error.HEDERA_ERROR;

import com.hedera.hashgraph.sdk.PrecheckStatusException;
import com.hedera.hashgraph.sdk.ReceiptStatusException;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Method;
import com.hedera.hashgraph.tck.exception.InvalidJSONRPC2ParamsException;
import com.hedera.hashgraph.tck.exception.InvalidJSONRPC2RequestException;
import com.hedera.hashgraph.tck.methods.JSONRPC2Error.ErrorData;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Error;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Response;
import com.thetransactioncompany.jsonrpc2.server.MessageContext;
import com.thetransactioncompany.jsonrpc2.server.RequestHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import net.minidev.json.JSONObject;

/**
 * Implements RequestHandler and overrides some of the Dispatcher logic,
 * enhancing the usability of the process method.
 *
 * Keeps track of the {@link JSONRPC2Method} annotated methods in a map,
 * converts the JSON-RPC params to the needed args in the called method
 * and invokes it.
 */
public abstract class AbstractJSONRPC2Service implements RequestHandler {

    // this is shared state to all requests so there could be race conditions
    // although the tck driver would not call these methods in such way
    private final Map<String, Method> methodMap;

    protected AbstractJSONRPC2Service() {
        methodMap = new HashMap<>();
        registerMethods();
    }

    /**
     * Register JSONRPCMethods
     */
    private void registerMethods() {
        Method[] methods = getClass().getDeclaredMethods();
        for (Method method : methods) {
            if (method.isAnnotationPresent(JSONRPC2Method.class)) {
                JSONRPC2Method annotation = method.getAnnotation(JSONRPC2Method.class);
                methodMap.put(annotation.value(), method);
            }
        }
    }

    @Override
    public String[] handledRequests() {
        return methodMap.keySet().toArray(new String[0]);
    }

    /**
     *
     * @param req JSON-RPC request
     * @param messageContext
     * @return JSONRPC2Response - result returned from the JSONRPCMethod or if error is thrown - JSONRPC2Error
     */
    @SuppressWarnings("java:S1874")
    @Override
    public JSONRPC2Response process(final JSONRPC2Request req, final MessageContext messageContext) {
        try {
            Method method = methodMap.get(req.getMethod());
            if (method != null) {
                Object[] args = getArguments(method, req.getNamedParams());
                Object result = method.invoke(this, args);
                return new JSONRPC2Response(result, req.getID());
            } else {
                return new JSONRPC2Response(JSONRPC2Error.METHOD_NOT_FOUND, req.getID());
            }
        } catch (InvalidJSONRPC2ParamsException e) {
            return new JSONRPC2Response(JSONRPC2Error.INVALID_PARAMS, req.getID());
        } catch (InvocationTargetException e) {
            // target exception can be anything
            // if its precheck, receipt - we handle it by setting error object
            // and returning custom HEDERA_STATUS_CODE -32001
            // if not - return server error or invalid request error codes
            var targetException = e.getTargetException();

            ErrorData errorData;

            if (targetException instanceof PrecheckStatusException precheckStatusException) {
                errorData = new ErrorData(precheckStatusException.status, precheckStatusException.getMessage());
            } else if (targetException instanceof ReceiptStatusException receiptStatusException) {
                errorData = new ErrorData(receiptStatusException.receipt.status, receiptStatusException.getMessage());
            } else if (targetException instanceof InvalidJSONRPC2RequestException) {
                return new JSONRPC2Response(JSONRPC2Error.INVALID_REQUEST, req.getID());
            } else {
                return new JSONRPC2Response(JSONRPC2Error.INTERNAL_ERROR, req.getID());
            }
            JSONObject errorJsonObject = new JSONObject();
            errorJsonObject.put("status", errorData.status().toString());
            errorJsonObject.put("message", errorData.message());

            var hederaError = HEDERA_ERROR.setData(errorJsonObject);
            return new JSONRPC2Response(hederaError, req.getID());
        } catch (Exception e) {
            // other exceptions
            return new JSONRPC2Response(JSONRPC2Error.INTERNAL_ERROR, req.getID());
        }
    }

    /**
     *
     * @param method the method that is being called
     * @param jrpcParams
     * @return parsed arguments for the method being called using reflection
     */
    private Object[] getArguments(final Method method, final Map<String, Object> jrpcParams)
            throws InvalidJSONRPC2ParamsException {
        Class<?>[] paramTypes = method.getParameterTypes();
        Object[] args = new Object[paramTypes.length];
        for (int i = 0; i < paramTypes.length; i++) {
            try {
                var paramInstance = paramTypes[i].newInstance();
                if (paramInstance instanceof JSONRPC2Param jsonRpcParam) {
                    args[i] = jsonRpcParam.parse(jrpcParams);
                }
            } catch (Exception e) {
                throw new InvalidJSONRPC2ParamsException("Invalid parameters for method %s with args: %s"
                        .formatted(method.getName(), Arrays.toString(args)));
            }
        }
        return args;
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/JSONRPC2Error.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods;

import com.hedera.hashgraph.sdk.Status;

/**
 * Custom JSON-RPC error definitions
 */
public class JSONRPC2Error {
    private JSONRPC2Error() {
        // static utility class
    }

    public static final int HEDERA_STATUS_CODE = -32001;
    public static final com.thetransactioncompany.jsonrpc2.JSONRPC2Error HEDERA_ERROR =
            new com.thetransactioncompany.jsonrpc2.JSONRPC2Error(HEDERA_STATUS_CODE, "Hedera error");

    public record ErrorData(Status status, String message) {}
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/JSONRPC2Param.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods;

import java.util.Map;

/**
 * Abstract base class for JSON-RPC parameters. Every parameter POJO should extend this class
 * and implement the {@link #parse} method. This method assists JSON-RPC services in creating
 * parameters for their JSON-RPC methods from the request.
 *
 * IMPORTANT:
 * all inheriting classes should include the following Lombok annotations:
 * {@code @Getter}, {@code @AllArgsConstructor}, and {@code @NoArgsConstructor}.
 * These annotations are needed for the instance creation via reflection.
 *
 */
public abstract class JSONRPC2Param {
    public abstract JSONRPC2Param parse(final Map<String, Object> jrpcParams) throws Exception;
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/AccountService.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.AccountCreateTransaction;
import com.hedera.hashgraph.sdk.AccountDeleteTransaction;
import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.AccountUpdateTransaction;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.HbarUnit;
import com.hedera.hashgraph.sdk.Status;
import com.hedera.hashgraph.sdk.TransactionReceipt;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Method;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Service;
import com.hedera.hashgraph.tck.methods.AbstractJSONRPC2Service;
import com.hedera.hashgraph.tck.methods.sdk.param.AccountCreateParams;
import com.hedera.hashgraph.tck.methods.sdk.param.AccountDeleteParams;
import com.hedera.hashgraph.tck.methods.sdk.param.AccountUpdateParams;
import com.hedera.hashgraph.tck.methods.sdk.response.AccountResponse;
import com.hedera.hashgraph.tck.util.KeyUtils;
import java.time.Duration;
import java.time.Instant;

/**
 * AccountCreateService for account related methods
 */
@JSONRPC2Service
public class AccountService extends AbstractJSONRPC2Service {
    private final SdkService sdkService;

    public AccountService(SdkService sdkService) {
        this.sdkService = sdkService;
    }

    @JSONRPC2Method("createAccount")
    public AccountResponse createAccount(final AccountCreateParams params) throws Exception {
        AccountCreateTransaction accountCreateTransaction = new AccountCreateTransaction();
        params.getKey().ifPresent(key -> {
            try {
                accountCreateTransaction.setKey(KeyUtils.getKeyFromString(key));
            } catch (InvalidProtocolBufferException e) {
                throw new IllegalArgumentException(e);
            }
        });

        params.getInitialBalance()
                .ifPresent(initialBalanceTinybars -> accountCreateTransaction.setInitialBalance(
                        Hbar.from(initialBalanceTinybars, HbarUnit.TINYBAR)));

        params.getReceiverSignatureRequired().ifPresent(accountCreateTransaction::setReceiverSignatureRequired);

        params.getAutoRenewPeriod()
                .ifPresent(autoRenewPeriodSeconds ->
                        accountCreateTransaction.setAutoRenewPeriod(Duration.ofSeconds(autoRenewPeriodSeconds)));

        params.getMemo().ifPresent(accountCreateTransaction::setAccountMemo);

        params.getMaxAutoTokenAssociations()
                .ifPresent(autoAssociations ->
                        accountCreateTransaction.setMaxAutomaticTokenAssociations(autoAssociations.intValue()));

        params.getStakedAccountId()
                .ifPresent(stakedAccountId ->
                        accountCreateTransaction.setStakedAccountId(AccountId.fromString(stakedAccountId)));

        params.getStakedNodeId().ifPresent(accountCreateTransaction::setStakedNodeId);

        params.getDeclineStakingReward().ifPresent(accountCreateTransaction::setDeclineStakingReward);

        params.getAlias().ifPresent(accountCreateTransaction::setAlias);

        params.getCommonTransactionParams()
                .ifPresent(commonTransactionParams ->
                        commonTransactionParams.fillOutTransaction(accountCreateTransaction, sdkService.getClient()));

        TransactionReceipt transactionReceipt =
                accountCreateTransaction.execute(sdkService.getClient()).getReceipt(sdkService.getClient());

        String stringAccountId = "";
        if (transactionReceipt.status == Status.SUCCESS) {
            stringAccountId = transactionReceipt.accountId.toString();
        }

        return new AccountResponse(stringAccountId, transactionReceipt.status);
    }

    @JSONRPC2Method("updateAccount")
    public AccountResponse updateAccount(final AccountUpdateParams params) throws Exception {
        AccountUpdateTransaction accountUpdateTransaction = new AccountUpdateTransaction();

        params.getAccountId()
                .ifPresent(accountId -> accountUpdateTransaction.setAccountId(AccountId.fromString(accountId)));

        params.getKey().ifPresent(key -> {
            try {
                accountUpdateTransaction.setKey(KeyUtils.getKeyFromString(key));
            } catch (InvalidProtocolBufferException e) {
                throw new IllegalArgumentException(e);
            }
        });

        params.getReceiverSignatureRequired().ifPresent(accountUpdateTransaction::setReceiverSignatureRequired);

        params.getAutoRenewPeriod()
                .ifPresent(autoRenewPeriodSeconds ->
                        accountUpdateTransaction.setAutoRenewPeriod(Duration.ofSeconds(autoRenewPeriodSeconds)));

        params.getMemo().ifPresent(accountUpdateTransaction::setAccountMemo);

        params.getExpirationTime()
                .ifPresent(expirationTime ->
                        accountUpdateTransaction.setExpirationTime(Instant.ofEpochSecond(expirationTime)));

        params.getMaxAutoTokenAssociations()
                .ifPresent(autoAssociations ->
                        accountUpdateTransaction.setMaxAutomaticTokenAssociations(autoAssociations.intValue()));

        params.getStakedAccountId()
                .ifPresent(stakedAccountId ->
                        accountUpdateTransaction.setStakedAccountId(AccountId.fromString(stakedAccountId)));

        params.getStakedNodeId().ifPresent(accountUpdateTransaction::setStakedNodeId);

        params.getDeclineStakingReward().ifPresent(accountUpdateTransaction::setDeclineStakingReward);

        params.getCommonTransactionParams()
                .ifPresent(commonTransactionParams ->
                        commonTransactionParams.fillOutTransaction(accountUpdateTransaction, sdkService.getClient()));

        TransactionReceipt transactionReceipt =
                accountUpdateTransaction.execute(sdkService.getClient()).getReceipt(sdkService.getClient());

        return new AccountResponse(null, transactionReceipt.status);
    }

    @JSONRPC2Method("deleteAccount")
    public AccountResponse deleteAccount(final AccountDeleteParams params) throws Exception {
        AccountDeleteTransaction accountDeleteTransaction = new AccountDeleteTransaction();

        params.getDeleteAccountId()
                .ifPresent(accountId -> accountDeleteTransaction.setAccountId(AccountId.fromString(accountId)));

        params.getTransferAccountId()
                .ifPresent(accountId -> accountDeleteTransaction.setTransferAccountId(AccountId.fromString(accountId)));

        params.getCommonTransactionParams()
                .ifPresent(commonTransactionParams ->
                        commonTransactionParams.fillOutTransaction(accountDeleteTransaction, sdkService.getClient()));

        TransactionReceipt transactionReceipt =
                accountDeleteTransaction.execute(sdkService.getClient()).getReceipt(sdkService.getClient());

        return new AccountResponse(null, transactionReceipt.status);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/KeyService.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk;

import static com.hedera.hashgraph.tck.util.KeyUtils.KeyType.*;
import static com.hedera.hashgraph.tck.util.KeyUtils.getKeyFromString;

import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.Key;
import com.hedera.hashgraph.sdk.KeyList;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Method;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Service;
import com.hedera.hashgraph.tck.exception.InvalidJSONRPC2RequestException;
import com.hedera.hashgraph.tck.methods.AbstractJSONRPC2Service;
import com.hedera.hashgraph.tck.methods.sdk.param.GenerateKeyParams;
import com.hedera.hashgraph.tck.methods.sdk.response.GenerateKeyResponse;
import org.bouncycastle.util.encoders.Hex;

@JSONRPC2Service
public class KeyService extends AbstractJSONRPC2Service {

    @JSONRPC2Method("generateKey")
    public GenerateKeyResponse generateKey(final GenerateKeyParams params) throws Exception {
        // Make sure getFromKey() is only provided for ED25519_PUBLIC_KEY, ECDSA_SECP256k1_PUBLIC_KEY, or
        // EVM_ADDRESS_KEY
        if (params.getFromKey().isPresent()
                && !params.getType().equals(ED25519_PUBLIC_KEY)
                && !params.getType().equals(ECDSA_SECP256K1_PUBLIC_KEY)
                && !params.getType().equals(EVM_ADDRESS_KEY)) {
            throw new InvalidJSONRPC2RequestException(
                    "invalid parameters: fromKey should only be provided for ed25519PublicKey, ecdsaSecp256k1PublicKey, or evmAddress types.");
        }

        // Make sure threshold is only provided for THRESHOLD_KEY_TYPE.
        if (params.getThreshold().isPresent() && !params.getType().equals(THRESHOLD_KEY)) {
            throw new InvalidJSONRPC2RequestException(
                    "invalid parameters: threshold should only be provided for thresholdKey types.");
        }

        // Make sure keys is only provided for LIST_KEY_TYPE or THRESHOLD_KEY_TYPE
        if (params.getKeys().isPresent()
                && !params.getType().equals(LIST_KEY)
                && !params.getType().equals(THRESHOLD_KEY)) {
            throw new InvalidJSONRPC2RequestException(
                    "invalid parameters: keys should only be provided for keyList or thresholdKey types.");
        }

        if ((params.getType().equals(THRESHOLD_KEY) || params.getType().equals(LIST_KEY))
                && params.getKeys().isEmpty()) {
            throw new InvalidJSONRPC2RequestException(
                    "invalid request: keys list is required for generating a KeyList type.");
        }

        if (params.getType().equals(THRESHOLD_KEY) && params.getThreshold().isEmpty()) {
            throw new InvalidJSONRPC2RequestException(
                    "invalid request: threshold is required for generating a ThresholdKey type.");
        }

        GenerateKeyResponse response = new GenerateKeyResponse();
        response.setKey(processKeyRecursively(params, response, false));
        return response;
    }

    private String processKeyRecursively(
            final GenerateKeyParams params, final GenerateKeyResponse response, boolean isList)
            throws InvalidJSONRPC2RequestException, InvalidProtocolBufferException {
        String privateKeyString;
        PrivateKey privateKey;
        switch (params.getType()) {
            case ED25519_PRIVATE_KEY, ECDSA_SECP256K1_PRIVATE_KEY:
                privateKeyString = params.getType().equals(ED25519_PRIVATE_KEY)
                        ? PrivateKey.generateED25519().toStringDER()
                        : PrivateKey.generateECDSA().toStringDER();
                if (isList) {
                    response.getPrivateKeys().add(privateKeyString);
                }

                return privateKeyString;

            case ED25519_PUBLIC_KEY, ECDSA_SECP256K1_PUBLIC_KEY:
                if (params.getFromKey().isPresent()) {
                    return PrivateKey.fromString(params.getFromKey().get())
                            .getPublicKey()
                            .toStringDER();
                }
                privateKey = params.getType().equals(ED25519_PUBLIC_KEY)
                        ? PrivateKey.generateED25519()
                        : PrivateKey.generateECDSA();
                if (isList) {
                    response.getPrivateKeys().add(privateKey.toStringDER());
                }

                return privateKey.getPublicKey().toStringDER();

            case LIST_KEY, THRESHOLD_KEY:
                KeyList keyList = new KeyList();
                params.getKeys().get().forEach(keyParams -> {
                    try {
                        keyList.add(getKeyFromString(processKeyRecursively(keyParams, response, true)));
                    } catch (Exception e) {
                        throw new IllegalArgumentException(e);
                    }
                });

                if (params.getType().equals(THRESHOLD_KEY)) {
                    keyList.setThreshold(params.getThreshold().get().intValue());
                }

                return Hex.toHexString(keyList.toBytes());

            case EVM_ADDRESS_KEY:
                if (params.getFromKey().isPresent()) {
                    Key hederaKey = getKeyFromString(params.getFromKey().get());
                    if (hederaKey instanceof PrivateKey pk) {
                        return pk.getPublicKey().toEvmAddress().toString();
                    } else if (hederaKey instanceof PublicKey pk) {
                        return pk.toEvmAddress().toString();
                    } else {
                        throw new InvalidJSONRPC2RequestException(
                                "invalid parameters: fromKey for evmAddress is not ECDSAsecp256k1.");
                    }
                }
                return PrivateKey.generateECDSA().getPublicKey().toEvmAddress().toString();

            default:
                throw new InvalidJSONRPC2RequestException("invalid request: key type not recognized.");
        }
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/SdkService.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk;

import com.hedera.hashgraph.sdk.AccountId;
import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Method;
import com.hedera.hashgraph.tck.annotation.JSONRPC2Service;
import com.hedera.hashgraph.tck.methods.AbstractJSONRPC2Service;
import com.hedera.hashgraph.tck.methods.sdk.param.SetupParams;
import com.hedera.hashgraph.tck.methods.sdk.response.SetupResponse;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * SdkService for managing the {@link Client} setup and reset
 */
@JSONRPC2Service
public class SdkService extends AbstractJSONRPC2Service {
    // this is shared state to all requests so there could be race conditions
    // although the tck driver would not call these methods in such way
    private Client client;

    @JSONRPC2Method("setup")
    public SetupResponse setup(final SetupParams params) throws Exception {
        String clientType;
        if (params.getNodeIp().isPresent()
                && params.getNodeAccountId().isPresent()
                && params.getMirrorNetworkIp().isPresent()) {
            // Custom client setup
            Map<String, AccountId> node = new HashMap<>();
            var nodeId = AccountId.fromString(params.getNodeAccountId().get());
            node.put(params.getNodeIp().get(), nodeId);
            client = Client.forNetwork(node);
            clientType = "custom";
            client.setMirrorNetwork(List.of(params.getMirrorNetworkIp().get()));
        } else {
            // Default to testnet
            client = Client.forTestnet();
            clientType = "testnet";
        }

        client.setOperator(
                AccountId.fromString(params.getOperatorAccountId()),
                PrivateKey.fromString(params.getOperatorPrivateKey()));
        return new SetupResponse("Successfully setup " + clientType + " client.");
    }

    @JSONRPC2Method("reset")
    public SetupResponse reset() {
        client = null;
        return new SetupResponse("");
    }

    public Client getClient() {
        return this.client;
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/param/AccountCreateParams.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import com.hedera.hashgraph.tck.methods.JSONRPC2Param;
import java.util.Map;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.minidev.json.JSONObject;

/**
 * AccountCreateParams for account create method
 */
@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class AccountCreateParams extends JSONRPC2Param {
    private Optional<String> key;
    private Optional<Long> initialBalance;
    private Optional<Boolean> receiverSignatureRequired;
    private Optional<Long> autoRenewPeriod;
    private Optional<String> memo;
    private Optional<Long> maxAutoTokenAssociations;
    private Optional<String> stakedAccountId;
    private Optional<Long> stakedNodeId;
    private Optional<Boolean> declineStakingReward;
    private Optional<String> alias;
    private Optional<CommonTransactionParams> commonTransactionParams;

    @Override
    public AccountCreateParams parse(Map<String, Object> jrpcParams) throws ClassCastException {
        var parsedKey = Optional.ofNullable((String) jrpcParams.get("key"));
        var parsedInitialBalance = Optional.ofNullable((Long) jrpcParams.get("initialBalance"));
        var parsedReceiverSignatureRequired =
                Optional.ofNullable((Boolean) jrpcParams.get("receiverSignatureRequired"));
        var parsedAutoRenewPeriod = Optional.ofNullable((Long) jrpcParams.get("autoRenewPeriod"));
        var parsedMemo = Optional.ofNullable((String) jrpcParams.get("memo"));
        var parsedMaxAutoTokenAssociations = Optional.ofNullable((Long) jrpcParams.get("maxAutoTokenAssociations"));
        var parsedStakedAccountId = Optional.ofNullable((String) jrpcParams.get("stakedAccountId"));
        var parsedStakedNodeId = Optional.ofNullable((Long) jrpcParams.get("stakedNodeId"));
        var parsedDeclineStakingReward = Optional.ofNullable((Boolean) jrpcParams.get("declineStakingReward"));
        var parsedAlias = Optional.ofNullable((String) jrpcParams.get("alias"));
        Optional<CommonTransactionParams> parsedCommonTransactionParams = Optional.empty();
        if (jrpcParams.containsKey("commonTransactionParams")) {
            JSONObject jsonObject = (JSONObject) jrpcParams.get("commonTransactionParams");
            parsedCommonTransactionParams = Optional.of(CommonTransactionParams.parse(jsonObject));
        }

        return new AccountCreateParams(
                parsedKey,
                parsedInitialBalance,
                parsedReceiverSignatureRequired,
                parsedAutoRenewPeriod,
                parsedMemo,
                parsedMaxAutoTokenAssociations,
                parsedStakedAccountId,
                parsedStakedNodeId,
                parsedDeclineStakingReward,
                parsedAlias,
                parsedCommonTransactionParams);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/param/AccountDeleteParams.java
package com.hedera.hashgraph.tck.methods.sdk.param;

import com.hedera.hashgraph.tck.methods.JSONRPC2Param;
import java.util.Map;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.minidev.json.JSONObject;

/**
 * AccountDeleteParams for account delete method
 */
@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class AccountDeleteParams extends JSONRPC2Param {
    private Optional<String> deleteAccountId;
    private Optional<String> transferAccountId;
    private Optional<CommonTransactionParams> commonTransactionParams;

    @Override
    public AccountDeleteParams parse(Map<String, Object> jrpcParams) throws ClassCastException {
        var parsedDeleteAccountId = Optional.ofNullable((String) jrpcParams.get("deleteAccountId"));
        var parsedTransferAccountId = Optional.ofNullable((String) jrpcParams.get("transferAccountId"));

        Optional<CommonTransactionParams> parsedCommonTransactionParams = Optional.empty();
        if (jrpcParams.containsKey("commonTransactionParams")) {
            JSONObject jsonObject = (JSONObject) jrpcParams.get("commonTransactionParams");
            parsedCommonTransactionParams = Optional.of(CommonTransactionParams.parse(jsonObject));
        }

        return new AccountDeleteParams(parsedDeleteAccountId, parsedTransferAccountId, parsedCommonTransactionParams);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/param/AccountUpdateParams.java
package com.hedera.hashgraph.tck.methods.sdk.param;

import com.hedera.hashgraph.tck.methods.JSONRPC2Param;
import java.util.Map;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.minidev.json.JSONObject;

/**
 * AccountUpdateParams for account update method
 */
@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class AccountUpdateParams extends JSONRPC2Param {
    private Optional<String> key;
    private Optional<Boolean> receiverSignatureRequired;
    private Optional<Long> autoRenewPeriod;
    private Optional<String> memo;
    private Optional<Long> expirationTime;
    private Optional<Long> maxAutoTokenAssociations;
    private Optional<String> stakedAccountId;
    private Optional<String> accountId;
    private Optional<Long> stakedNodeId;
    private Optional<Boolean> declineStakingReward;
    private Optional<CommonTransactionParams> commonTransactionParams;

    @Override
    public AccountUpdateParams parse(Map<String, Object> jrpcParams) throws ClassCastException {
        var parsedKey = Optional.ofNullable((String) jrpcParams.get("key"));
        var parsedReceiverSignatureRequired =
                Optional.ofNullable((Boolean) jrpcParams.get("receiverSignatureRequired"));
        var parsedAutoRenewPeriod = Optional.ofNullable((Long) jrpcParams.get("autoRenewPeriod"));
        var parsedMemo = Optional.ofNullable((String) jrpcParams.get("memo"));
        var parsedMaxAutoTokenAssociations = Optional.ofNullable((Long) jrpcParams.get("maxAutoTokenAssociations"));
        var parsedStakedAccountId = Optional.ofNullable((String) jrpcParams.get("stakedAccountId"));
        var parsedAccountId = Optional.ofNullable((String) jrpcParams.get("accountId"));
        var parsedStakedNodeId = Optional.ofNullable((Long) jrpcParams.get("stakedNodeId"));
        var parsedExpirationTime = Optional.ofNullable((Long) jrpcParams.get("expirationTime"));
        var parsedDeclineStakingReward = Optional.ofNullable((Boolean) jrpcParams.get("declineStakingReward"));
        Optional<CommonTransactionParams> parsedCommonTransactionParams = Optional.empty();
        if (jrpcParams.containsKey("commonTransactionParams")) {
            JSONObject jsonObject = (JSONObject) jrpcParams.get("commonTransactionParams");
            parsedCommonTransactionParams = Optional.of(CommonTransactionParams.parse(jsonObject));
        }

        return new AccountUpdateParams(
                parsedKey,
                parsedReceiverSignatureRequired,
                parsedAutoRenewPeriod,
                parsedMemo,
                parsedExpirationTime,
                parsedMaxAutoTokenAssociations,
                parsedStakedAccountId,
                parsedAccountId,
                parsedStakedNodeId,
                parsedDeclineStakingReward,
                parsedCommonTransactionParams);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/param/CommonTransactionParams.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import com.hedera.hashgraph.sdk.Client;
import com.hedera.hashgraph.sdk.Hbar;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.Transaction;
import com.hedera.hashgraph.sdk.TransactionId;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.minidev.json.JSONArray;

/**
 * CommonTransactionParams
 */
@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class CommonTransactionParams {
    private Optional<String> transactionId;
    private Optional<Long> maxTransactionFee;
    private Optional<Long> validTransactionDuration;
    private Optional<String> memo;
    private Optional<Boolean> regenerateTransactionId;
    private Optional<List<String>> signers;

    public static CommonTransactionParams parse(Map<String, Object> jrpcParams) throws ClassCastException {
        var parsedTransactionId = Optional.ofNullable((String) jrpcParams.get("transactionId"));
        var parsedMaxTransactionFee = Optional.ofNullable((Long) jrpcParams.get("maxTransactionFee"));
        var parsedValidTransactionDuration = Optional.ofNullable((Long) jrpcParams.get("validTransactionDuration"));
        var parsedMemo = Optional.ofNullable((String) jrpcParams.get("memo"));
        var parsedRegenerateTransactionId = Optional.ofNullable((Boolean) jrpcParams.get("regenerateTransactionId"));

        Optional<List<String>> signers = Optional.empty();
        if (jrpcParams.containsKey("signers")) {
            JSONArray jsonArray = (JSONArray) jrpcParams.get("signers");
            List<String> signersList = jsonArray.stream().map(Objects::toString).toList();
            signers = Optional.of(signersList);
        }

        return new CommonTransactionParams(
                parsedTransactionId,
                parsedMaxTransactionFee,
                parsedValidTransactionDuration,
                parsedMemo,
                parsedRegenerateTransactionId,
                signers);
    }

    public void fillOutTransaction(final Transaction<?> transaction, final Client client) {
        transactionId.ifPresent(txId -> transaction.setTransactionId(TransactionId.fromString(txId)));
        maxTransactionFee.ifPresent(maxFee -> transaction.setMaxTransactionFee(Hbar.fromTinybars(maxFee)));
        validTransactionDuration.ifPresent(
                validDuration -> transaction.setTransactionValidDuration(Duration.ofSeconds(validDuration)));
        memo.ifPresent(transaction::setTransactionMemo);
        regenerateTransactionId.ifPresent(transaction::setRegenerateTransactionId);
        signers.ifPresent(s -> {
            transaction.freezeWith(client);
            s.forEach(signer -> {
                var pk = PrivateKey.fromString(signer);
                transaction.sign(pk);
            });
        });
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/param/GenerateKeyParams.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import com.hedera.hashgraph.tck.methods.JSONRPC2Param;
import com.hedera.hashgraph.tck.util.KeyUtils.KeyType;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;

@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class GenerateKeyParams extends JSONRPC2Param {
    private KeyType type;
    private Optional<String> fromKey;
    private Optional<Long> threshold;
    private Optional<List<GenerateKeyParams>> keys;

    @Override
    public GenerateKeyParams parse(Map<String, Object> jrpcParams) throws Exception {
        var parsedType = (String) jrpcParams.get("type");
        var parsedFromKey = Optional.ofNullable((String) jrpcParams.get("fromKey"));
        var parsedThreshold = Optional.ofNullable((Long) jrpcParams.get("threshold"));

        Optional<List<GenerateKeyParams>> parsedKeys = Optional.empty();
        if (jrpcParams.containsKey("keys")) {
            JSONArray jsonArray = (JSONArray) jrpcParams.get("keys");
            List<GenerateKeyParams> keyList = new ArrayList<>();
            for (Object o : jsonArray) {
                JSONObject jsonObject = (JSONObject) o;
                GenerateKeyParams keyParam = new GenerateKeyParams().parse(jsonObject);
                keyList.add(keyParam);
            }
            parsedKeys = Optional.of(keyList);
        }

        return new GenerateKeyParams(KeyType.fromString(parsedType), parsedFromKey, parsedThreshold, parsedKeys);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/param/SetupParams.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import com.hedera.hashgraph.tck.methods.JSONRPC2Param;
import java.util.Map;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

/**
 * SetupParams for SDK client
 */
@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class SetupParams extends JSONRPC2Param {
    private String operatorAccountId;
    private String operatorPrivateKey;
    private Optional<String> nodeIp;
    private Optional<String> nodeAccountId;
    private Optional<String> mirrorNetworkIp;

    @Override
    public SetupParams parse(Map<String, Object> jrpcParams) throws ClassCastException {
        var parsedOperatorAccountId = (String) jrpcParams.get("operatorAccountId");
        var parsedOperatorPrivateKey = (String) jrpcParams.get("operatorPrivateKey");
        var parsedNodeIp = Optional.ofNullable((String) jrpcParams.get("nodeIp"));
        var parsedNodeAccountId = Optional.ofNullable((String) jrpcParams.get("nodeAccountId"));
        var parsedMirrorNetworkIp = Optional.ofNullable((String) jrpcParams.get("mirrorNetworkIp"));

        return new SetupParams(
                parsedOperatorAccountId,
                parsedOperatorPrivateKey,
                parsedNodeIp,
                parsedNodeAccountId,
                parsedMirrorNetworkIp);
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/response/AccountResponse.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.response;

import com.hedera.hashgraph.sdk.Status;
import lombok.Data;

@Data
public class AccountResponse {
    private final String accountId;
    private final Status status;
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/response/GenerateKeyResponse.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.response;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;

@Data
public class GenerateKeyResponse {
    private String key;
    private List<String> privateKeys = new ArrayList<>();
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/methods/sdk/response/SetupResponse.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.response;

import lombok.Data;

@Data
public class SetupResponse {
    private String message = "";
    private String status = "";

    public SetupResponse(String message) {
        if (message != null && !message.isEmpty()) {
            this.message = message;
        }
        this.status = "SUCCESS";
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/util/JSONRPC2ServiceScanner.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.util;

import com.hedera.hashgraph.tck.annotation.JSONRPC2Service;
import com.thetransactioncompany.jsonrpc2.server.*;
import org.springframework.context.ApplicationContext;

/**
 * Utility class to register all {@link JSONRPC2Service} annotated classes
 * to the JSON-RPC dispatcher
 */
public class JSONRPC2ServiceScanner {
    private JSONRPC2ServiceScanner() {
        // private constructor for utility class
    }

    public static void registerServices(Dispatcher dispatcher, ApplicationContext context) {
        String[] serviceNames = context.getBeanNamesForAnnotation(JSONRPC2Service.class);
        if (serviceNames != null) { // NOSONAR
            for (String serviceName : serviceNames) {
                Object service = context.getBean(serviceName);
                dispatcher.register((RequestHandler) service);
            }
        }
    }
}
// Filename: tck/src/main/java/com/hedera/hashgraph/tck/util/KeyUtils.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.util;

import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import com.hedera.hashgraph.sdk.Key;
import com.hedera.hashgraph.sdk.PrivateKey;
import com.hedera.hashgraph.sdk.PublicKey;

public final class KeyUtils {

    public enum KeyType {
        ED25519_PRIVATE_KEY("ed25519PrivateKey"),
        ED25519_PUBLIC_KEY("ed25519PublicKey"),
        ECDSA_SECP256K1_PRIVATE_KEY("ecdsaSecp256k1PrivateKey"),
        ECDSA_SECP256K1_PUBLIC_KEY("ecdsaSecp256k1PublicKey"),
        LIST_KEY("keyList"),
        THRESHOLD_KEY("thresholdKey"),
        EVM_ADDRESS_KEY("evmAddress");

        private final String keyString;

        KeyType(String keyString) {
            this.keyString = keyString;
        }

        public static KeyType fromString(String keyString) {
            for (KeyType type : KeyType.values()) {
                if (type.keyString.equals(keyString)) {
                    return type;
                }
            }
            throw new IllegalArgumentException("Unknown key type: " + keyString);
        }
    }

    public static Key getKeyFromString(String keyString) throws InvalidProtocolBufferException {
        try {
            return PublicKey.fromStringDER(keyString);
        } catch (Exception e) {
            try {
                return PrivateKey.fromStringDER(keyString);
            } catch (Exception ex) {
                return Key.fromBytes(ByteString.fromHex(keyString).toByteArray());
            }
        }
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/controller/JRPCControllerTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.controller;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.thetransactioncompany.jsonrpc2.JSONRPC2Error;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Response;
import com.thetransactioncompany.jsonrpc2.server.Dispatcher;
import jakarta.servlet.http.HttpServletRequest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.ApplicationContext;

@ExtendWith(MockitoExtension.class)
class JRPCControllerTest {

    @Mock
    Dispatcher dispatcher;

    @Mock
    HttpServletRequest request;

    @Mock
    JSONRPC2Request jsonrpcRequest;

    @Test
    void handleJSONRPC2RequestValidRequestReturnsExpectedResponse() {
        // given
        JRPCController controller = new JRPCController(dispatcher, mock(ApplicationContext.class));
        JSONRPC2Response expectedResponse = new JSONRPC2Response("result", 1L);
        when(request.getAttribute("jsonrpcRequest")).thenReturn(jsonrpcRequest);
        when(dispatcher.process(jsonrpcRequest, null)).thenReturn(expectedResponse);

        // when
        String response = controller.handleJSONRPC2Request(request);

        // then
        verify(dispatcher).process(jsonrpcRequest, null);
        assertEquals(expectedResponse.toJSONString(), response);
    }

    @Test
    void handleJSONRPC2RequestResponseWithErrorLogsErrorMessage() {
        // given
        JRPCController controller = new JRPCController(dispatcher, mock(ApplicationContext.class));
        JSONRPC2Response errorResponse = new JSONRPC2Response(JSONRPC2Error.METHOD_NOT_FOUND, 1L);
        when(request.getAttribute("jsonrpcRequest")).thenReturn(jsonrpcRequest);
        when(dispatcher.process(jsonrpcRequest, null)).thenReturn(errorResponse);

        // when
        controller.handleJSONRPC2Request(request);

        // then
        verify(dispatcher).process(jsonrpcRequest, null);
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/controller/JRPCInterceptorTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.controller;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.io.StringReader;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class JRPCInterceptorTest {

    @Mock
    HttpServletRequest request;

    @Mock
    HttpServletResponse response;

    @Test
    void testMapToJSONRPC2Request() throws Exception {
        // given
        String requestBody =
                "{\"jsonrpc\": \"2.0\", \"method\": \"testMethod\", \"params\": {\"param1\": \"value1\"}, \"id\": 1}";
        BufferedReader reader = new BufferedReader(new StringReader(requestBody));
        when(request.getReader()).thenReturn(reader);

        JRPCInterceptor interceptor = new JRPCInterceptor();

        // when
        JSONRPC2Request jsonrpcRequest = interceptor.mapToJSONRPC2Request(request);

        // then
        assertNotNull(jsonrpcRequest);
        assertEquals("testMethod", jsonrpcRequest.getMethod());
        assertEquals(1L, jsonrpcRequest.getID());
    }

    @Test
    void testPreHandle() throws Exception {
        // given
        String requestBody =
                "{\"jsonrpc\": \"2.0\", \"method\": \"testMethod\", \"params\": {\"param1\": \"value1\"}, \"id\": 1}";
        BufferedReader reader = new BufferedReader(new StringReader(requestBody));
        when(request.getReader()).thenReturn(reader);

        JRPCInterceptor interceptor = new JRPCInterceptor();

        // when
        boolean result = interceptor.preHandle(request, response, null);

        // then
        assertTrue(result);
        verify(request).setAttribute(eq("jsonrpcRequest"), any(JSONRPC2Request.class));
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/KeyServiceTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk;

import static com.hedera.hashgraph.tck.util.KeyUtils.KeyType.*;
import static org.junit.jupiter.api.Assertions.*;

import com.hedera.hashgraph.tck.exception.InvalidJSONRPC2RequestException;
import com.hedera.hashgraph.tck.methods.sdk.param.GenerateKeyParams;
import com.hedera.hashgraph.tck.methods.sdk.response.GenerateKeyResponse;
import java.util.Collections;
import java.util.Optional;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

class KeyServiceTest {

    private final KeyService keyService = new KeyService();

    @Test
    void testGenerateKeyWithInvalidFromKey() {
        GenerateKeyParams params =
                new GenerateKeyParams(ED25519_PRIVATE_KEY, Optional.of("someKey"), Optional.empty(), Optional.empty());

        Executable executable = () -> keyService.generateKey(params);

        assertThrows(
                InvalidJSONRPC2RequestException.class,
                executable,
                "invalid parameters: fromKey should only be provided for ed25519PublicKey, ecdsaSecp256k1PublicKey, or evmAddress types.");
    }

    @Test
    void testGenerateKeyWithInvalidThreshold() {
        GenerateKeyParams params =
                new GenerateKeyParams(ED25519_PUBLIC_KEY, Optional.empty(), Optional.of(1L), Optional.empty());

        Executable executable = () -> keyService.generateKey(params);

        assertThrows(
                InvalidJSONRPC2RequestException.class,
                executable,
                "invalid parameters: threshold should only be provided for thresholdKey types.");
    }

    @Test
    void testGenerateKeyWithInvalidKeys() {
        GenerateKeyParams params = new GenerateKeyParams(
                ED25519_PUBLIC_KEY, Optional.empty(), Optional.empty(), Optional.of(Collections.emptyList()));

        Executable executable = () -> keyService.generateKey(params);

        assertThrows(
                InvalidJSONRPC2RequestException.class,
                executable,
                "invalid parameters: keys should only be provided for keyList or thresholdKey types.");
    }

    @Test
    void testGenerateKeyWithMissingKeysForKeyList() {
        GenerateKeyParams params =
                new GenerateKeyParams(LIST_KEY, Optional.empty(), Optional.empty(), Optional.empty());

        Executable executable = () -> keyService.generateKey(params);

        assertThrows(
                InvalidJSONRPC2RequestException.class,
                executable,
                "invalid request: keys list is required for generating a KeyList type.");
    }

    @Test
    void testGenerateKeyWithMissingThresholdForThresholdKey() {
        GenerateKeyParams params = new GenerateKeyParams(
                THRESHOLD_KEY, Optional.empty(), Optional.empty(), Optional.of(Collections.emptyList()));

        Executable executable = () -> keyService.generateKey(params);

        assertThrows(
                InvalidJSONRPC2RequestException.class,
                executable,
                "invalid request: threshold is required for generating a ThresholdKey type.");
    }

    @Test
    void testGenerateKeyWithValidEd25519PrivateKey() throws Exception {
        GenerateKeyParams params =
                new GenerateKeyParams(ED25519_PRIVATE_KEY, Optional.empty(), Optional.empty(), Optional.empty());

        GenerateKeyResponse response = keyService.generateKey(params);

        assertNotNull(response.getKey());
        assertTrue(response.getKey().contains("302e020100300506032b657004220420"));
    }

    @Test
    void testGenerateKeyWithValidEd25519PublicKey() throws Exception {
        GenerateKeyParams params =
                new GenerateKeyParams(ED25519_PUBLIC_KEY, Optional.empty(), Optional.empty(), Optional.empty());

        GenerateKeyResponse response = keyService.generateKey(params);

        assertNotNull(response.getKey());
        assertTrue(response.getKey().contains("302a300506032b6570032100"));
    }

    @Test
    void testGenerateKeyWithValidThresholdKey() throws Exception {
        GenerateKeyParams params = new GenerateKeyParams(
                THRESHOLD_KEY,
                Optional.empty(),
                Optional.of(2L),
                Optional.of(Collections.singletonList(new GenerateKeyParams(
                        ED25519_PUBLIC_KEY, Optional.empty(), Optional.empty(), Optional.empty()))));

        GenerateKeyResponse response = keyService.generateKey(params);

        assertNotNull(response.getKey());
        assertFalse(response.getPrivateKeys().isEmpty());
    }

    @Test
    void testGenerateKeyWithValidListKey() throws Exception {
        GenerateKeyParams params = new GenerateKeyParams(
                LIST_KEY,
                Optional.empty(),
                Optional.empty(),
                Optional.of(Collections.singletonList(new GenerateKeyParams(
                        ED25519_PUBLIC_KEY, Optional.empty(), Optional.empty(), Optional.empty()))));

        GenerateKeyResponse response = keyService.generateKey(params);

        assertNotNull(response.getKey());
        assertFalse(response.getPrivateKeys().isEmpty());
    }

    @Test
    void testGenerateKeyWithValidEvmAddressKey() throws Exception {
        GenerateKeyParams params = new GenerateKeyParams(
                EVM_ADDRESS_KEY,
                Optional.of(
                        "3054020101042056b071002a75ab207a44bb2c18320286062bc26969fcb98240301e4afbe9ee2ea00706052b8104000aa124032200038ef0b62d60b1415f8cfb460303c498fbf09cb2ef2d2ff19fad33982228ef86fd"),
                Optional.empty(),
                Optional.empty());

        GenerateKeyResponse response = keyService.generateKey(params);

        assertNotNull(response.getKey());
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/SdkServiceTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

import com.hedera.hashgraph.tck.methods.sdk.param.SetupParams;
import com.hedera.hashgraph.tck.methods.sdk.response.SetupResponse;
import java.util.Optional;
import java.util.concurrent.TimeoutException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SdkServiceTest {

    private SdkService sdkService = new SdkService();

    @Test
    void testSetup() throws Exception {
        // Given
        SetupParams params = new SetupParams(
                "0.0.2",
                "302e020100300506032b65700422042091132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137",
                Optional.of("127.0.0.1:50211"),
                Optional.of("0.0.3"),
                Optional.of("http://127.0.0.1:5551"));

        // When
        SetupResponse response = sdkService.setup(params);

        // Then
        assertEquals("Successfully setup custom client.", response.getMessage());
    }

    @Test
    void testSetupFail() {
        // Given
        SetupParams params = new SetupParams(
                "operatorAccountId",
                "operatorPrivateKey",
                Optional.of("nodeIp"),
                Optional.of("3asdf"),
                Optional.of("127.0.0.1:50211"));

        // then
        assertThrows(Exception.class, () -> sdkService.setup(params));
    }

    @Test
    void testReset() throws TimeoutException {
        // When
        SetupResponse response = sdkService.reset();

        // Then
        assertEquals("", response.getMessage());
        assertNull(sdkService.getClient());
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/param/AccountCreateParamsTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import static org.junit.jupiter.api.Assertions.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;
import org.junit.jupiter.api.Test;

class AccountCreateParamsTest {

    @Test
    void testParseWithAllFields() {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("key", "someKey");
        jrpcParams.put("initialBalance", 1000L);
        jrpcParams.put("receiverSignatureRequired", true);
        jrpcParams.put("autoRenewPeriod", 7890000L);
        jrpcParams.put("memo", "test memo");
        jrpcParams.put("maxAutoTokenAssociations", 10L);
        jrpcParams.put("stakedAccountId", "stakedAccountId");
        jrpcParams.put("stakedNodeId", 5L);
        jrpcParams.put("declineStakingReward", true);
        jrpcParams.put("alias", "alias");

        JSONObject commonParamsJson = new JSONObject();
        commonParamsJson.put("transactionId", "txId");
        commonParamsJson.put("maxTransactionFee", 100L);
        commonParamsJson.put("validTransactionDuration", 120L);
        commonParamsJson.put("memo", "commonMemo");
        commonParamsJson.put("regenerateTransactionId", true);
        JSONArray signersArray = new JSONArray();
        signersArray.add(
                "302e020100300506032b657004220420c1ed50ed4b024f5df25992d1fc4b8c5b4e3c3db63a5ff5fa05857f5b4b90f3bc");
        signersArray.add("test");
        commonParamsJson.put("signers", signersArray);

        jrpcParams.put("commonTransactionParams", commonParamsJson);

        AccountCreateParams params = new AccountCreateParams().parse(jrpcParams);

        assertEquals(Optional.of("someKey"), params.getKey());
        assertEquals(Optional.of(1000L), params.getInitialBalance());
        assertEquals(Optional.of(true), params.getReceiverSignatureRequired());
        assertEquals(Optional.of(7890000L), params.getAutoRenewPeriod());
        assertEquals(Optional.of("test memo"), params.getMemo());
        assertEquals(Optional.of(10L), params.getMaxAutoTokenAssociations());
        assertEquals(Optional.of("stakedAccountId"), params.getStakedAccountId());
        assertEquals(Optional.of(5L), params.getStakedNodeId());
        assertEquals(Optional.of(true), params.getDeclineStakingReward());
        assertEquals(Optional.of("alias"), params.getAlias());

        assertTrue(params.getCommonTransactionParams().isPresent());
        CommonTransactionParams commonParams =
                params.getCommonTransactionParams().get();
        assertEquals(Optional.of("txId"), commonParams.getTransactionId());
        assertEquals(Optional.of(100L), commonParams.getMaxTransactionFee());
        assertEquals(Optional.of(120L), commonParams.getValidTransactionDuration());
        assertEquals(Optional.of("commonMemo"), commonParams.getMemo());
        assertEquals(Optional.of(true), commonParams.getRegenerateTransactionId());
        assertEquals(
                Optional.of(List.of(
                        "302e020100300506032b657004220420c1ed50ed4b024f5df25992d1fc4b8c5b4e3c3db63a5ff5fa05857f5b4b90f3bc",
                        "test")),
                commonParams.getSigners());
    }

    @Test
    void testParseWithOptionalFieldsAbsent() {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("key", "someKey");

        AccountCreateParams params = new AccountCreateParams().parse(jrpcParams);

        assertEquals(Optional.of("someKey"), params.getKey());
        assertEquals(Optional.empty(), params.getInitialBalance());
        assertEquals(Optional.empty(), params.getReceiverSignatureRequired());
        assertEquals(Optional.empty(), params.getAutoRenewPeriod());
        assertEquals(Optional.empty(), params.getMemo());
        assertEquals(Optional.empty(), params.getMaxAutoTokenAssociations());
        assertEquals(Optional.empty(), params.getStakedAccountId());
        assertEquals(Optional.empty(), params.getStakedNodeId());
        assertEquals(Optional.empty(), params.getDeclineStakingReward());
        assertEquals(Optional.empty(), params.getAlias());
        assertEquals(Optional.empty(), params.getCommonTransactionParams());
    }

    @Test
    void testParseWithInvalidFieldTypes() {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("key", 123); // Invalid type

        assertThrows(ClassCastException.class, () -> {
            new AccountCreateParams().parse(jrpcParams);
        });
    }

    @Test
    void testParseWithEmptyParams() {
        Map<String, Object> jrpcParams = new HashMap<>();

        AccountCreateParams params = new AccountCreateParams().parse(jrpcParams);

        assertEquals(Optional.empty(), params.getKey());
        assertEquals(Optional.empty(), params.getInitialBalance());
        assertEquals(Optional.empty(), params.getReceiverSignatureRequired());
        assertEquals(Optional.empty(), params.getAutoRenewPeriod());
        assertEquals(Optional.empty(), params.getMemo());
        assertEquals(Optional.empty(), params.getMaxAutoTokenAssociations());
        assertEquals(Optional.empty(), params.getStakedAccountId());
        assertEquals(Optional.empty(), params.getStakedNodeId());
        assertEquals(Optional.empty(), params.getDeclineStakingReward());
        assertEquals(Optional.empty(), params.getAlias());
        assertEquals(Optional.empty(), params.getCommonTransactionParams());
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/param/CommonTransactionParamsTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import static org.junit.jupiter.api.Assertions.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import net.minidev.json.JSONArray;
import org.junit.jupiter.api.Test;

class CommonTransactionParamsTest {
    @Test
    void testCommonTransactionParamsParse() {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("transactionId", "txId");
        jrpcParams.put("maxTransactionFee", 100L);
        jrpcParams.put("validTransactionDuration", 120L);
        jrpcParams.put("memo", "commonMemo");
        jrpcParams.put("regenerateTransactionId", true);
        JSONArray signersArray = new JSONArray();
        signersArray.add(
                "302e020100300506032b657004220420c1ed50ed4b024f5df25992d1fc4b8c5b4e3c3db63a5ff5fa05857f5b4b90f3bc");
        jrpcParams.put("signers", signersArray);

        CommonTransactionParams params = CommonTransactionParams.parse(jrpcParams);

        assertEquals(Optional.of("txId"), params.getTransactionId());
        assertEquals(Optional.of(100L), params.getMaxTransactionFee());
        assertEquals(Optional.of(120L), params.getValidTransactionDuration());
        assertEquals(Optional.of("commonMemo"), params.getMemo());
        assertEquals(Optional.of(true), params.getRegenerateTransactionId());
        assertEquals(
                Optional.of(
                        List.of(
                                "302e020100300506032b657004220420c1ed50ed4b024f5df25992d1fc4b8c5b4e3c3db63a5ff5fa05857f5b4b90f3bc")),
                params.getSigners());
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/param/GenerateKeyParamsTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import static org.junit.jupiter.api.Assertions.*;

import com.hedera.hashgraph.tck.util.KeyUtils.KeyType;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;
import org.junit.jupiter.api.Test;

class GenerateKeyParamsTest {
    @Test
    void testParseWithAllFields() throws Exception {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("type", "ed25519PublicKey");
        jrpcParams.put("fromKey", "someFromKey");
        jrpcParams.put("threshold", 2L);

        JSONArray jsonArray = new JSONArray();
        Map<String, Object> nestedParamsMap = new HashMap<>();
        nestedParamsMap.put("type", "ecdsaSecp256k1PublicKey");
        jsonArray.add(new JSONObject(nestedParamsMap));
        jrpcParams.put("keys", jsonArray);

        GenerateKeyParams params = new GenerateKeyParams().parse(jrpcParams);

        assertEquals(KeyType.ED25519_PUBLIC_KEY, params.getType());
        assertEquals(Optional.of("someFromKey"), params.getFromKey());
        assertEquals(Optional.of(2L), params.getThreshold());
        assertTrue(params.getKeys().isPresent());
        assertEquals(1, params.getKeys().get().size());
        assertEquals(
                KeyType.ECDSA_SECP256K1_PUBLIC_KEY,
                params.getKeys().get().get(0).getType());
    }

    @Test
    void testParseWithOptionalFieldsAbsent() throws Exception {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("type", "ed25519PublicKey");

        GenerateKeyParams params = new GenerateKeyParams().parse(jrpcParams);

        assertEquals(KeyType.ED25519_PUBLIC_KEY, params.getType());
        assertEquals(Optional.empty(), params.getFromKey());
        assertEquals(Optional.empty(), params.getThreshold());
        assertEquals(Optional.empty(), params.getKeys());
    }

    @Test
    void testParseWithInvalidFieldTypes() {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("type", 123); // Invalid type

        assertThrows(ClassCastException.class, () -> {
            new GenerateKeyParams().parse(jrpcParams);
        });
    }

    @Test
    void testParseWithEmptyParams() throws Exception {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("type", "keyList");

        GenerateKeyParams params = new GenerateKeyParams().parse(jrpcParams);

        assertEquals(Optional.empty(), params.getFromKey());
        assertEquals(Optional.empty(), params.getThreshold());
        assertEquals(Optional.empty(), params.getKeys());
    }

    @Test
    void testParseWithNestedKeys() throws Exception {
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("type", "keyList");

        JSONArray jsonArray = new JSONArray();
        Map<String, Object> nestedParamsMap1 = new HashMap<>();
        nestedParamsMap1.put("type", "ed25519PublicKey");
        Map<String, Object> nestedParamsMap2 = new HashMap<>();
        nestedParamsMap2.put("type", "ecdsaSecp256k1PublicKey");
        jsonArray.add(new JSONObject(nestedParamsMap1));
        jsonArray.add(new JSONObject(nestedParamsMap2));
        jrpcParams.put("keys", jsonArray);

        GenerateKeyParams params = new GenerateKeyParams().parse(jrpcParams);

        assertEquals(KeyType.LIST_KEY, params.getType());
        assertTrue(params.getKeys().isPresent());
        assertEquals(2, params.getKeys().get().size());
        assertEquals(KeyType.ED25519_PUBLIC_KEY, params.getKeys().get().get(0).getType());
        assertEquals(
                KeyType.ECDSA_SECP256K1_PUBLIC_KEY,
                params.getKeys().get().get(1).getType());
    }

    @Test
    void testKeyTypeFromString() {
        assertEquals(KeyType.ED25519_PRIVATE_KEY, KeyType.fromString("ed25519PrivateKey"));
        assertEquals(KeyType.ED25519_PUBLIC_KEY, KeyType.fromString("ed25519PublicKey"));
        assertEquals(KeyType.ECDSA_SECP256K1_PRIVATE_KEY, KeyType.fromString("ecdsaSecp256k1PrivateKey"));
        assertEquals(KeyType.ECDSA_SECP256K1_PUBLIC_KEY, KeyType.fromString("ecdsaSecp256k1PublicKey"));
        assertEquals(KeyType.LIST_KEY, KeyType.fromString("keyList"));
        assertEquals(KeyType.THRESHOLD_KEY, KeyType.fromString("thresholdKey"));
        assertEquals(KeyType.EVM_ADDRESS_KEY, KeyType.fromString("evmAddress"));
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/param/SetupParamsTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.param;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import org.junit.jupiter.api.Test;

class SetupParamsTest {

    @Test
    void testParse() {
        // Given
        Map<String, Object> jrpcParams = new HashMap<>();
        jrpcParams.put("operatorAccountId", "testAccountId");
        jrpcParams.put("operatorPrivateKey", "testPrivateKey");
        jrpcParams.put("nodeIp", "testNodeIp");
        jrpcParams.put("nodeAccountId", "testNodeAccountId");
        jrpcParams.put("mirrorNetworkIp", "testMirrorNetworkIp");

        // When
        SetupParams result = new SetupParams().parse(jrpcParams);

        // Then
        assertEquals("testAccountId", result.getOperatorAccountId());
        assertEquals("testPrivateKey", result.getOperatorPrivateKey());
        assertEquals(Optional.of("testNodeIp"), result.getNodeIp());
        assertEquals(Optional.of("testNodeAccountId"), result.getNodeAccountId());
        assertEquals(Optional.of("testMirrorNetworkIp"), result.getMirrorNetworkIp());
    }
}
// Filename: tck/src/test/java/com/hedera/hashgraph/tck/methods/sdk/response/SetupResponseTest.java
/*-
 *
 * Hedera Java SDK
 *
 * Copyright (C) 2024 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.hedera.hashgraph.tck.methods.sdk.response;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import org.junit.jupiter.api.Test;

class SetupResponseTest {

    @Test
    void testConstructorWithMessage() {
        // Given
        String message = "Test message";

        // When
        SetupResponse setupResponse = new SetupResponse(message);

        // Then
        assertNotNull(setupResponse);
        assertEquals(message, setupResponse.getMessage());
        assertEquals("SUCCESS", setupResponse.getStatus());
    }

    @Test
    void testConstructorWithNullMessage() {
        // Given
        String message = null;

        // When
        SetupResponse setupResponse = new SetupResponse(message);

        // Then
        assertNotNull(setupResponse);
        assertEquals("", setupResponse.getMessage()); // message should default to empty string
        assertEquals("SUCCESS", setupResponse.getStatus());
    }

    @Test
    void testConstructorWithEmptyMessage() {
        // Given
        String message = "";

        // When
        SetupResponse setupResponse = new SetupResponse(message);

        // Then
        assertNotNull(setupResponse);
        assertEquals("", setupResponse.getMessage());
        assertEquals("SUCCESS", setupResponse.getStatus());
    }
}
